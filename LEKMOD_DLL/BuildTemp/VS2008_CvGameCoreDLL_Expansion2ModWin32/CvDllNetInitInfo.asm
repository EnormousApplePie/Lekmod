; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvDllNetInitInfo.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_CIV5_XP2_DLL_VERSION DD FLAT:$SG218012
_DATA	ENDS
CONST	SEGMENT
$SG218012 DB	'1.0.0', 00H
	ORG $+2
$SG219236 DB	'true', 00H
	ORG $+3
$SG219237 DB	'false', 00H
	ORG $+2
$SG219238 DB	'NetInitInfo : m_szLoadFileName="%s", m_szMapScriptName="'
	DB	'%s", m_bWBMapNoPlayers="%s", m_eWorldSize=%d, m_eClimate=%d m'
	DB	'_eSeaLevel=%d m_eEra=%d m_eCalendar=%d m_iGameTurn=%d m_bGame'
	DB	'Started=%i m_eGameSpeed=%d m_eTurnTimer=%d m_szGameName="%s" '
	DB	'm_uiSyncRandSeed=%d m_uiMapRandSeed=%d', 00H
	ORG $+2
$SG219379 DB	'net_message_debug.log', 00H
	ORG $+2
$SG219383 DB	'Success', 00H
$SG219384 DB	'Failed', 00H
	ORG $+1
$SG219385 DB	'Evaluating Map Path: (%s)', 0aH, 'Original Path: %s', 0aH
	DB	'New Path: %s', 00H
	ORG $+3
_guidICvUnknown DD 0d89ba82fH
	DW	09fa3H
	DW	04696H
	DB	0b3H
	DB	0f4H
	DB	052H
	DB	0bdH
	DB	0b1H
	DB	01H
	DB	0cfH
	DB	0b2H
_guidICvNetInitInfo1 DD 07917c933H
	DW	02edcH
	DW	049afH
	DB	0b7H
	DB	0f3H
	DB	0c0H
	DB	065H
	DB	0cbH
	DB	0b5H
	DB	0ebH
	DB	02cH
CONST	ENDS
PUBLIC	??_7ICvUnknown@@6B@				; ICvUnknown::`vftable'
PUBLIC	??0ICvUnknown@@QAE@XZ				; ICvUnknown::ICvUnknown
PUBLIC	??_R4ICvUnknown@@6B@				; ICvUnknown::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVICvUnknown@@@8				; ICvUnknown `RTTI Type Descriptor'
PUBLIC	??_R3ICvUnknown@@8				; ICvUnknown::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ICvUnknown@@8				; ICvUnknown::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ICvUnknown@@8			; ICvUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__purecall:PROC
;	COMDAT ??_R1A@?0A@EA@ICvUnknown@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ICvUnknown@@8 DD FLAT:??_R0?AVICvUnknown@@@8 ; ICvUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ICvUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R2ICvUnknown@@8
rdata$r	SEGMENT
??_R2ICvUnknown@@8 DD FLAT:??_R1A@?0A@EA@ICvUnknown@@8	; ICvUnknown::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ICvUnknown@@8
rdata$r	SEGMENT
??_R3ICvUnknown@@8 DD 00H				; ICvUnknown::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ICvUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVICvUnknown@@@8
_DATA	SEGMENT
??_R0?AVICvUnknown@@@8 DD FLAT:??_7type_info@@6B@	; ICvUnknown `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVICvUnknown@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ICvUnknown@@6B@
rdata$r	SEGMENT
??_R4ICvUnknown@@6B@ DD 00H				; ICvUnknown::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVICvUnknown@@@8
	DD	FLAT:??_R3ICvUnknown@@8
rdata$r	ENDS
;	COMDAT ??_7ICvUnknown@@6B@
CONST	SEGMENT
??_7ICvUnknown@@6B@ DD FLAT:??_R4ICvUnknown@@6B@	; ICvUnknown::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0ICvUnknown@@QAE@XZ
_TEXT	SEGMENT
??0ICvUnknown@@QAE@XZ PROC				; ICvUnknown::ICvUnknown, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7ICvUnknown@@6B@
	ret	0
??0ICvUnknown@@QAE@XZ ENDP				; ICvUnknown::ICvUnknown
_TEXT	ENDS
PUBLIC	?IncrementReference@CvDllNetInitInfo@@QAEIXZ	; CvDllNetInitInfo::IncrementReference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdllnetinitinfo.cpp
;	COMDAT ?IncrementReference@CvDllNetInitInfo@@QAEIXZ
_TEXT	SEGMENT
?IncrementReference@CvDllNetInitInfo@@QAEIXZ PROC	; CvDllNetInitInfo::IncrementReference, COMDAT
; _this$ = ecx

; 76   : 	++m_uiRefCount;

	inc	DWORD PTR [ecx+760]

; 77   : 	return m_uiRefCount;

	mov	eax, DWORD PTR [ecx+760]

; 78   : }

	ret	0
?IncrementReference@CvDllNetInitInfo@@QAEIXZ ENDP	; CvDllNetInitInfo::IncrementReference
_TEXT	ENDS
PUBLIC	?GetReferenceCount@CvDllNetInitInfo@@QAEIXZ	; CvDllNetInitInfo::GetReferenceCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetReferenceCount@CvDllNetInitInfo@@QAEIXZ
_TEXT	SEGMENT
?GetReferenceCount@CvDllNetInitInfo@@QAEIXZ PROC	; CvDllNetInitInfo::GetReferenceCount, COMDAT
; _this$ = ecx

; 96   : 	return m_uiRefCount;

	mov	eax, DWORD PTR [ecx+760]

; 97   : }

	ret	0
?GetReferenceCount@CvDllNetInitInfo@@QAEIXZ ENDP	; CvDllNetInitInfo::GetReferenceCount
_TEXT	ENDS
PUBLIC	??3CvDllNetInitInfo@@SAXPAX@Z			; CvDllNetInitInfo::operator delete
EXTRN	?Free@CvDllGameContext@@SAXPAX@Z:PROC		; CvDllGameContext::Free
; Function compile flags: /Ogtpy
;	COMDAT ??3CvDllNetInitInfo@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CvDllNetInitInfo@@SAXPAX@Z PROC			; CvDllNetInitInfo::operator delete, COMDAT

; 106  : 	CvDllGameContext::Free(p);

	jmp	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
??3CvDllNetInitInfo@@SAXPAX@Z ENDP			; CvDllNetInitInfo::operator delete
_TEXT	ENDS
PUBLIC	??2CvDllNetInitInfo@@SAPAXI@Z			; CvDllNetInitInfo::operator new
EXTRN	?Allocate@CvDllGameContext@@SAPAXI@Z:PROC	; CvDllGameContext::Allocate
; Function compile flags: /Ogtpy
;	COMDAT ??2CvDllNetInitInfo@@SAPAXI@Z
_TEXT	SEGMENT
_bytes$ = 8						; size = 4
??2CvDllNetInitInfo@@SAPAXI@Z PROC			; CvDllNetInitInfo::operator new, COMDAT

; 111  : 	return CvDllGameContext::Allocate(bytes);

	jmp	?Allocate@CvDllGameContext@@SAPAXI@Z	; CvDllGameContext::Allocate
??2CvDllNetInitInfo@@SAPAXI@Z ENDP			; CvDllNetInitInfo::operator new
_TEXT	ENDS
PUBLIC	?GetDebugString@CvDllNetInitInfo@@UAGPBDXZ	; CvDllNetInitInfo::GetDebugString
EXTRN	__imp__sprintf:PROC
EXTRN	?loadFileName@CvPreGame@@YAABVCvString@@XZ:PROC	; CvPreGame::loadFileName
EXTRN	?mapScriptName@CvPreGame@@YAABVCvString@@XZ:PROC ; CvPreGame::mapScriptName
EXTRN	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ:PROC ; CvPreGame::worldSize
EXTRN	?climate@CvPreGame@@YA?AW4ClimateTypes@@XZ:PROC	; CvPreGame::climate
EXTRN	?seaLevel@CvPreGame@@YA?AW4SeaLevelTypes@@XZ:PROC ; CvPreGame::seaLevel
EXTRN	?era@CvPreGame@@YA?AW4EraTypes@@XZ:PROC		; CvPreGame::era
EXTRN	?calendar@CvPreGame@@YA?AW4CalendarTypes@@XZ:PROC ; CvPreGame::calendar
EXTRN	?gameTurn@CvPreGame@@YAHXZ:PROC			; CvPreGame::gameTurn
EXTRN	?gameStarted@CvPreGame@@YA_NXZ:PROC		; CvPreGame::gameStarted
EXTRN	?gameSpeed@CvPreGame@@YA?AW4GameSpeedTypes@@XZ:PROC ; CvPreGame::gameSpeed
EXTRN	?turnTimer@CvPreGame@@YA?AW4TurnTimerTypes@@XZ:PROC ; CvPreGame::turnTimer
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?gameName@CvPreGame@@YAABVCvString@@XZ:PROC	; CvPreGame::gameName
EXTRN	?syncRandomSeed@CvPreGame@@YAIXZ:PROC		; CvPreGame::syncRandomSeed
EXTRN	?mapRandomSeed@CvPreGame@@YAIXZ:PROC		; CvPreGame::mapRandomSeed
EXTRN	?mapNoPlayers@CvPreGame@@YA_NXZ:PROC		; CvPreGame::mapNoPlayers
; Function compile flags: /Ogtpy
;	COMDAT ?GetDebugString@CvDllNetInitInfo@@UAGPBDXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?GetDebugString@CvDllNetInitInfo@@UAGPBDXZ PROC		; CvDllNetInitInfo::GetDebugString, COMDAT

; 115  : {

	push	esi
	push	edi

; 116  : 	sprintf(m_szDebugString, "NetInitInfo : m_szLoadFileName=\"%s\", "\
; 117  : 	        "m_szMapScriptName=\"%s\", "\
; 118  : 	        "m_bWBMapNoPlayers=\"%s\", "\
; 119  : 	        "m_eWorldSize=%d, "\
; 120  : 	        "m_eClimate=%d "\
; 121  : 	        "m_eSeaLevel=%d "\
; 122  : 	        "m_eEra=%d "\
; 123  : 	        "m_eCalendar=%d "\
; 124  : 	        "m_iGameTurn=%d "\
; 125  : 					"m_bGameStarted=%i "\
; 126  : 	        "m_eGameSpeed=%d "\
; 127  : 	        "m_eTurnTimer=%d "\
; 128  : 	        "m_szGameName=\"%s\" "\
; 129  : 	        "m_uiSyncRandSeed=%d "\
; 130  : 	        "m_uiMapRandSeed=%d"
; 131  : 	        , CvPreGame::loadFileName().c_str()
; 132  : 	        , CvPreGame::mapScriptName().c_str()
; 133  : 	        , CvPreGame::mapNoPlayers() ? "true" : "false"
; 134  : 	        , static_cast<int>(CvPreGame::worldSize())
; 135  : 	        , static_cast<int>(CvPreGame::climate())
; 136  : 	        , static_cast<int>(CvPreGame::seaLevel())
; 137  : 	        , static_cast<int>(CvPreGame::era())
; 138  : 	        , static_cast<int>(CvPreGame::calendar())
; 139  : 	        , CvPreGame::gameTurn()
; 140  : #ifdef AUI_WARNING_FIXES
; 141  : 		, CvPreGame::gameStarted() ? 1 : 0
; 142  : #else
; 143  : 					, CvPreGame::gameStarted()
; 144  : #endif
; 145  : 	        , static_cast<int>(CvPreGame::gameSpeed())
; 146  : 	        , static_cast<int>(CvPreGame::turnTimer())
; 147  : 	        , CvPreGame::gameName().c_str()
; 148  : #ifdef AUI_WARNING_FIXES
; 149  : 		, (int)CvPreGame::syncRandomSeed()
; 150  : 		, (int)CvPreGame::mapRandomSeed()
; 151  : #else
; 152  : 	        , CvPreGame::syncRandomSeed()
; 153  : 	        , CvPreGame::mapRandomSeed()
; 154  : #endif
; 155  : 	       );

	call	?mapNoPlayers@CvPreGame@@YA_NXZ		; CvPreGame::mapNoPlayers
	mov	edi, OFFSET $SG219236
	test	al, al
	jne	SHORT $LN4@GetDebugSt
	mov	edi, OFFSET $SG219237
$LN4@GetDebugSt:
	mov	esi, DWORD PTR _this$[esp+4]
	add	esi, 245				; 000000f5H
	call	?mapRandomSeed@CvPreGame@@YAIXZ		; CvPreGame::mapRandomSeed
	push	eax
	call	?syncRandomSeed@CvPreGame@@YAIXZ	; CvPreGame::syncRandomSeed
	push	eax
	call	?gameName@CvPreGame@@YAABVCvString@@XZ	; CvPreGame::gameName
	mov	ecx, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	call	?turnTimer@CvPreGame@@YA?AW4TurnTimerTypes@@XZ ; CvPreGame::turnTimer
	push	eax
	call	?gameSpeed@CvPreGame@@YA?AW4GameSpeedTypes@@XZ ; CvPreGame::gameSpeed
	push	eax
	call	?gameStarted@CvPreGame@@YA_NXZ		; CvPreGame::gameStarted
	movzx	eax, al
	push	eax
	call	?gameTurn@CvPreGame@@YAHXZ		; CvPreGame::gameTurn
	push	eax
	call	?calendar@CvPreGame@@YA?AW4CalendarTypes@@XZ ; CvPreGame::calendar
	push	eax
	call	?era@CvPreGame@@YA?AW4EraTypes@@XZ	; CvPreGame::era
	push	eax
	call	?seaLevel@CvPreGame@@YA?AW4SeaLevelTypes@@XZ ; CvPreGame::seaLevel
	push	eax
	call	?climate@CvPreGame@@YA?AW4ClimateTypes@@XZ ; CvPreGame::climate
	push	eax
	call	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ ; CvPreGame::worldSize
	push	eax
	push	edi
	call	?mapScriptName@CvPreGame@@YAABVCvString@@XZ ; CvPreGame::mapScriptName
	mov	ecx, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	call	?loadFileName@CvPreGame@@YAABVCvString@@XZ ; CvPreGame::loadFileName
	mov	ecx, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG219238
	push	esi
	call	DWORD PTR __imp__sprintf
	add	esp, 68					; 00000044H
	pop	edi

; 156  : 
; 157  : 	return m_szDebugString;

	mov	eax, esi
	pop	esi

; 158  : }

	ret	4
?GetDebugString@CvDllNetInitInfo@@UAGPBDXZ ENDP		; CvDllNetInitInfo::GetDebugString
_TEXT	ENDS
PUBLIC	_IsEqualGUID
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v6.0a\include\guiddef.h
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_IsEqualGUID PROC					; COMDAT

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, DWORD PTR _rguid2$[esp-4]
	mov	edx, DWORD PTR _rguid1$[esp-4]
	mov	eax, 16					; 00000010H
	push	esi
	npad	2
$LL4@IsEqualGUI:
	mov	esi, DWORD PTR [edx]
	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN5@IsEqualGUI
	sub	eax, 4
	add	ecx, 4
	add	edx, 4
	cmp	eax, 4
	jae	SHORT $LL4@IsEqualGUI
	xor	eax, eax
	xor	edx, edx
	test	eax, eax
	sete	dl
	pop	esi
	mov	eax, edx

; 162  : }

	ret	0
$LN5@IsEqualGUI:

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	movzx	eax, BYTE PTR [edx]
	movzx	esi, BYTE PTR [ecx]
	sub	eax, esi
	jne	SHORT $LN7@IsEqualGUI
	movzx	eax, BYTE PTR [edx+1]
	movzx	esi, BYTE PTR [ecx+1]
	sub	eax, esi
	jne	SHORT $LN7@IsEqualGUI
	movzx	eax, BYTE PTR [edx+2]
	movzx	esi, BYTE PTR [ecx+2]
	sub	eax, esi
	jne	SHORT $LN7@IsEqualGUI
	movzx	eax, BYTE PTR [edx+3]
	movzx	ecx, BYTE PTR [ecx+3]
	sub	eax, ecx
$LN7@IsEqualGUI:
	sar	eax, 31					; 0000001fH
	or	eax, 1
	xor	edx, edx
	test	eax, eax
	sete	dl
	pop	esi
	mov	eax, edx

; 162  : }

	ret	0
_IsEqualGUID ENDP
_TEXT	ENDS
PUBLIC	_==
; Function compile flags: /Ogtpy
;	COMDAT _==
_TEXT	SEGMENT
_guidOne$ = 8						; size = 4
_guidOther$ = 12					; size = 4
_==	PROC						; COMDAT

; 194  :     return IsEqualGUID(guidOne,guidOther);

	jmp	_IsEqualGUID
_==	ENDP
_TEXT	ENDS
PUBLIC	??4?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAEAAV01@ABV01@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??4?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAEAAV01@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??4?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAEAAV01@ABV01@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::operator=, COMDAT
; _this$ = ecx

; 623  : 		{

	mov	eax, ecx

; 624  : 		return *this;
; 625  : 		}

	ret	4
??4?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAEAAV01@ABV01@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::operator=
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEIXZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEIXZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 2021161081				; 78787879H
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvPreGame::CustomOption> >::~_Container_base_aux_alloc_empty<std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPreGame::CustomOption> >::~_Container_base_aux_alloc_empty<std::allocator<CvPreGame::CustomOption> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPreGame::CustomOption> >::~_Container_base_aux_alloc_empty<std::allocator<CvPreGame::CustomOption> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCustomOption@CvPreGame@@@std@@QAE@XZ ; std::allocator<CvPreGame::CustomOption>::allocator<CvPreGame::CustomOption>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCustomOption@CvPreGame@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VCustomOption@CvPreGame@@@std@@QAE@XZ PROC ; std::allocator<CvPreGame::CustomOption>::allocator<CvPreGame::CustomOption>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VCustomOption@CvPreGame@@@std@@QAE@XZ ENDP ; std::allocator<CvPreGame::CustomOption>::allocator<CvPreGame::CustomOption>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@I@Z ; std::allocator<CvPreGame::CustomOption>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@I@Z PROC ; std::allocator<CvPreGame::CustomOption>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@I@Z ENDP ; std::allocator<CvPreGame::CustomOption>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE@V?$allocator@VCustomOption@CvPreGame@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvPreGame::CustomOption> >::_Container_base_aux_alloc_empty<std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE@V?$allocator@VCustomOption@CvPreGame@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE@V?$allocator@VCustomOption@CvPreGame@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPreGame::CustomOption> >::_Container_base_aux_alloc_empty<std::allocator<CvPreGame::CustomOption> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE@V?$allocator@VCustomOption@CvPreGame@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPreGame::CustomOption> >::_Container_base_aux_alloc_empty<std::allocator<CvPreGame::CustomOption> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCustomOption@CvPreGame@@@std@@QAE@ABV01@@Z ; std::allocator<CvPreGame::CustomOption>::allocator<CvPreGame::CustomOption>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCustomOption@CvPreGame@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VCustomOption@CvPreGame@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvPreGame::CustomOption>::allocator<CvPreGame::CustomOption>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@VCustomOption@CvPreGame@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvPreGame::CustomOption>::allocator<CvPreGame::CustomOption>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCustomOption@CvPreGame@@@std@@QBEIXZ ; std::allocator<CvPreGame::CustomOption>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@VCustomOption@CvPreGame@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCustomOption@CvPreGame@@@std@@QBEIXZ PROC ; std::allocator<CvPreGame::CustomOption>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 63161283				; 03c3c3c3H

; 167  : 		}

	ret	0
?max_size@?$allocator@VCustomOption@CvPreGame@@@std@@QBEIXZ ENDP ; std::allocator<CvPreGame::CustomOption>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@PAVCustomOption@CvPreGame@@@Z ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@PAVCustomOption@CvPreGame@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@PAVCustomOption@CvPreGame@@@Z PROC ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@PAVCustomOption@CvPreGame@@@Z ENDP ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator==
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::end
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCustomOption@CvPreGame@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCustomOption@CvPreGame@@0@Z ; std::_Iter_random<CvPreGame::CustomOption *,CvPreGame::CustomOption *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCustomOption@CvPreGame@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCustomOption@CvPreGame@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCustomOption@CvPreGame@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCustomOption@CvPreGame@@0@Z PROC ; std::_Iter_random<CvPreGame::CustomOption *,CvPreGame::CustomOption *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCustomOption@CvPreGame@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCustomOption@CvPreGame@@0@Z ENDP ; std::_Iter_random<CvPreGame::CustomOption *,CvPreGame::CustomOption *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCustomOption@CvPreGame@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCustomOption@CvPreGame@@0@Z ; std::_Ptr_cat<CvPreGame::CustomOption *,CvPreGame::CustomOption *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCustomOption@CvPreGame@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCustomOption@CvPreGame@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCustomOption@CvPreGame@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCustomOption@CvPreGame@@0@Z PROC ; std::_Ptr_cat<CvPreGame::CustomOption *,CvPreGame::CustomOption *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCustomOption@CvPreGame@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCustomOption@CvPreGame@@0@Z ENDP ; std::_Ptr_cat<CvPreGame::CustomOption *,CvPreGame::CustomOption *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCustomOption@CvPreGame@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::random_access_iterator_tag>
EXTRN	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z:PROC ; CvPreGame::CustomOption::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCustomOption@CvPreGame@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCustomOption@CvPreGame@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN8@Copy_opt
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	push	esi
	mov	ecx, edi
	call	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z ; CvPreGame::CustomOption::operator=
	add	esi, 68					; 00000044H
	add	edi, 68					; 00000044H
	cmp	esi, ebx
	jne	SHORT $LL3@Copy_opt

; 2473 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
$LN8@Copy_opt:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCustomOption@CvPreGame@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEABVCustomOption@CvPreGame@@XZ ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEABVCustomOption@CvPreGame@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEABVCustomOption@CvPreGame@@XZ PROC ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEABVCustomOption@CvPreGame@@XZ ENDP ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 68			; 00000044H

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator++
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@QAEXABVCustomOption@CvPreGame@@@Z ; SerializeFromSequenceContainer<CvPreGame::CustomOption const ,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > const >::operator()
EXTRN	??6CvPreGame@@YAAAVFDataStream@@AAV1@ABVCustomOption@0@@Z:PROC ; CvPreGame::operator<<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@QAEXABVCustomOption@CvPreGame@@@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@QAEXABVCustomOption@CvPreGame@@@Z PROC ; SerializeFromSequenceContainer<CvPreGame::CustomOption const ,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > const >::operator(), COMDAT
; _this$ = ecx

; 75   : 		m_saveTo << i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	ecx
	call	??6CvPreGame@@YAAAVFDataStream@@AAV1@ABVCustomOption@0@@Z ; CvPreGame::operator<<
	add	esp, 8

; 76   : 	}

	ret	4
??R?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@QAEXABVCustomOption@CvPreGame@@@Z ENDP ; SerializeFromSequenceContainer<CvPreGame::CustomOption const ,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > const >::operator()
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	edx, ecx
	shl	edx, 4
	add	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Destroy@VCustomOption@CvPreGame@@@std@@YAXPAVCustomOption@CvPreGame@@@Z ; std::_Destroy<CvPreGame::CustomOption>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@VCustomOption@CvPreGame@@@std@@YAXPAVCustomOption@CvPreGame@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCustomOption@CvPreGame@@@std@@YAXPAVCustomOption@CvPreGame@@@Z PROC ; std::_Destroy<CvPreGame::CustomOption>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCustomOption@CvPreGame@@@std@@YAXPAVCustomOption@CvPreGame@@@Z ENDP ; std::_Destroy<CvPreGame::CustomOption>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@0ABV12@@Z ; std::_Fill<CvPreGame::CustomOption *,CvPreGame::CustomOption>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAVCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@0ABV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@0ABV12@@Z PROC ; std::_Fill<CvPreGame::CustomOption *,CvPreGame::CustomOption>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Fill
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
$LL3@Fill:

; 3159 : 		*_First = _Val;

	push	ebx
	mov	ecx, esi
	call	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z ; CvPreGame::CustomOption::operator=
	add	esi, 68					; 00000044H
	cmp	esi, edi
	jne	SHORT $LL3@Fill
	pop	ebx
$LN1@Fill:
	pop	edi
	pop	esi

; 3160 : 	}

	ret	0
??$_Fill@PAVCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@0ABV12@@Z ENDP ; std::_Fill<CvPreGame::CustomOption *,CvPreGame::CustomOption>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAVCustomOption@CvPreGame@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCustomOption@CvPreGame@@@Z ; std::_Move_cat<CvPreGame::CustomOption *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAVCustomOption@CvPreGame@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCustomOption@CvPreGame@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVCustomOption@CvPreGame@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCustomOption@CvPreGame@@@Z PROC ; std::_Move_cat<CvPreGame::CustomOption *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAVCustomOption@CvPreGame@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCustomOption@CvPreGame@@@Z ENDP ; std::_Move_cat<CvPreGame::CustomOption *>
_TEXT	ENDS
PUBLIC	??$_Construct@VCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@ABV12@@Z ; std::_Construct<CvPreGame::CustomOption,CvPreGame::CustomOption>
EXTRN	??0CustomOption@CvPreGame@@QAE@ABV01@@Z:PROC	; CvPreGame::CustomOption::CustomOption
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Construct@VCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@ABV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@VCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@ABV12@@Z$0
__ehfuncinfo$??$_Construct@VCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@ABV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@VCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@ABV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@VCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@ABV12@@Z
_TEXT	SEGMENT
$T220834 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@ABV12@@Z PROC ; std::_Construct<CvPreGame::CustomOption,CvPreGame::CustomOption>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@VCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@ABV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$[esp+12], ecx

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T220834[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN3@Construct
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	??0CustomOption@CvPreGame@@QAE@ABV01@@Z	; CvPreGame::CustomOption::CustomOption
$LN3@Construct:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@VCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@ABV12@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T220834[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@VCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@ABV12@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@VCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@ABV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@VCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@ABV12@@Z ENDP ; std::_Construct<CvPreGame::CustomOption,CvPreGame::CustomOption>
PUBLIC	??$_Copy_backward_opt@PAVCustomOption@CvPreGame@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAVCustomOption@CvPreGame@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCustomOption@CvPreGame@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebx

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	cmp	ebx, esi
	je	SHORT $LN7@Copy_backw
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	sub	esi, 68					; 00000044H
	sub	edi, 68					; 00000044H
	push	esi
	mov	ecx, edi
	call	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z ; CvPreGame::CustomOption::operator=
	cmp	esi, ebx
	jne	SHORT $LL2@Copy_backw

; 2677 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
$LN7@Copy_backw:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCustomOption@CvPreGame@@PAV12@Urandom_access_iterator_tag@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?GetInterfaceId@ICvUnknown@@SG?AU_GUID@@XZ	; ICvUnknown::GetInterfaceId
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
;	COMDAT ?GetInterfaceId@ICvUnknown@@SG?AU_GUID@@XZ
_TEXT	SEGMENT
$T220870 = 8						; size = 4
?GetInterfaceId@ICvUnknown@@SG?AU_GUID@@XZ PROC		; ICvUnknown::GetInterfaceId, COMDAT

; 306  : 	static GUID DLLCALL GetInterfaceId(){ return guidICvUnknown; }

	mov	eax, DWORD PTR $T220870[esp-4]
	mov	ecx, DWORD PTR _guidICvUnknown
	mov	edx, DWORD PTR _guidICvUnknown+4
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _guidICvUnknown+8
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _guidICvUnknown+12
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	ret	4
?GetInterfaceId@ICvUnknown@@SG?AU_GUID@@XZ ENDP		; ICvUnknown::GetInterfaceId
_TEXT	ENDS
PUBLIC	?GetInterfaceId@ICvNetInitInfo1@@SG?AU_GUID@@XZ	; ICvNetInitInfo1::GetInterfaceId
; Function compile flags: /Ogtpy
;	COMDAT ?GetInterfaceId@ICvNetInitInfo1@@SG?AU_GUID@@XZ
_TEXT	SEGMENT
$T220874 = 8						; size = 4
?GetInterfaceId@ICvNetInitInfo1@@SG?AU_GUID@@XZ PROC	; ICvNetInitInfo1::GetInterfaceId, COMDAT

; 519  : 	static GUID DLLCALL GetInterfaceId() { return guidICvNetInitInfo1; }

	mov	eax, DWORD PTR $T220874[esp-4]
	mov	ecx, DWORD PTR _guidICvNetInitInfo1
	mov	edx, DWORD PTR _guidICvNetInitInfo1+4
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _guidICvNetInitInfo1+8
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _guidICvNetInitInfo1+12
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	ret	4
?GetInterfaceId@ICvNetInitInfo1@@SG?AU_GUID@@XZ ENDP	; ICvNetInitInfo1::GetInterfaceId
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::_Container_base_aux_alloc_empty<std::allocator<bool> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::_Container_base_aux_alloc_empty<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::_Container_base_aux_alloc_empty<std::allocator<bool> >
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
_TEXT	ENDS
PUBLIC	??0?$allocator@_N@std@@QAE@XZ			; std::allocator<bool>::allocator<bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@_N@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_N@std@@QAE@XZ PROC			; std::allocator<bool>::allocator<bool>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@_N@std@@QAE@XZ ENDP			; std::allocator<bool>::allocator<bool>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::~_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::~_Container_base_aux_alloc_empty<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::~_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@I@std@@QAE@XZ			; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@I@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@I@std@@QAE@XZ PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@I@std@@QAE@XZ ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
_TEXT	ENDS
PUBLIC	?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z ; std::vector<bool,std::allocator<bool> >::_Nw
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z PROC	; std::vector<bool,std::allocator<bool> >::_Nw, COMDAT

; 2331 : 		return ((_Count + _VBITS - 1) / _VBITS);

	mov	eax, DWORD PTR __Count$[esp-4]
	add	eax, 31					; 0000001fH
	shr	eax, 5

; 2332 : 		}

	ret	0
?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z ENDP	; std::vector<bool,std::allocator<bool> >::_Nw
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ DB 'vector<bool> to'
	DB	'o long', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$2
__ehfuncinfo$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T220909 = -80						; size = 28
$T220908 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ PROC ; std::vector<bool,std::allocator<bool> >::_Xlen, COMDAT
; _this$ = ecx

; 2374 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 2375 : 		_THROW(length_error, "vector<bool> too long");

	push	OFFSET ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T220909[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T220908[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T220909[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T220908[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T220908[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T220908[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T220908[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$0:
	lea	ecx, DWORD PTR $T220909[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$2:
	lea	ecx, DWORD PTR $T220908[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T220956 = -80						; size = 28
$T220955 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T220956[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T220955[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T220956[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T220955[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T220955[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T220955[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T220955[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T220956[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T220955[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@I@std@@QAE@ABV01@@Z		; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@I@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@I@std@@QAE@ABV01@@Z PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@I@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@I@std@@QAEXPAII@Z	; std::allocator<unsigned int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@I@std@@QAEXPAII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@I@std@@QAEXPAII@Z PROC		; std::allocator<unsigned int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@I@std@@QAEXPAII@Z ENDP		; std::allocator<unsigned int>::deallocate
_TEXT	ENDS
PUBLIC	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=, COMDAT
; _this$ = ecx

; 1602 : 		{	// increment by integer

	mov	eax, ecx

; 1603 : 		if (_Off == 0)

	mov	ecx, DWORD PTR __Off$[esp-4]
	test	ecx, ecx

; 1604 : 			return (*this); // early out

	je	SHORT $LN6@operator
	push	esi

; 1605 : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1606 : 		if (_Off < 0)
; 1607 : 			{
; 1608 : 			_SCL_SECURE_VALIDATE_RANGE(this->_My_actual_offset() >= ((size_type)-_Off));
; 1609 : 			}
; 1610 : 		else
; 1611 : 			{
; 1612 : 			_SCL_SECURE_VALIDATE_RANGE((this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1613 : 			}
; 1614 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	jge	SHORT $LN2@operator
	mov	edx, DWORD PTR [eax+4]
	mov	esi, ecx
	neg	esi
	cmp	edx, esi
	jae	SHORT $LN2@operator

; 1615 : 			{	/* add negative increment */
; 1616 : 			this->_Myoff += _Off;

	add	ecx, edx

; 1617 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	or	edx, -1
	sub	edx, ecx
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	mov	esi, -4					; fffffffcH
	sub	esi, edx
	add	DWORD PTR [eax], esi

; 1624 : 			this->_Myoff %= _VBITS;

	and	ecx, 31					; 0000001fH
	mov	DWORD PTR [eax+4], ecx
	pop	esi

; 1625 : 			}
; 1626 : 		return (*this);
; 1627 : 		}

	ret	4
$LN2@operator:

; 1618 : 			this->_Myoff %= _VBITS;
; 1619 : 			}
; 1620 : 		else
; 1621 : 			{	/* add non-negative increment */
; 1622 : 			this->_Myoff += _Off;

	mov	edx, DWORD PTR [eax+4]
	add	ecx, edx

; 1623 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	edx, ecx
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 1624 : 			this->_Myoff %= _VBITS;

	and	ecx, 31					; 0000001fH
	mov	DWORD PTR [eax+4], ecx
	pop	esi
$LN6@operator:

; 1625 : 			}
; 1626 : 		return (*this);
; 1627 : 		}

	ret	4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
_TEXT	ENDS
PUBLIC	??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-, COMDAT
; _this$ = ecx

; 1649 : 
; 1650 :  #if _HAS_ITERATOR_DEBUGGING
; 1651 : 		_Compat(_Right);
; 1652 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1653 : 
; 1654 : 		return (_VBITS * (this->_Myptr - _Right._Myptr)
; 1655 : 			+ (difference_type)this->_Myoff
; 1656 : 			- (difference_type)_Right._Myoff);

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx]
	sar	eax, 2
	shl	eax, 5
	sub	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR [ecx+4]

; 1657 : 		}

	ret	4
??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@I@std@@QBEIXZ		; std::allocator<unsigned int>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@I@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@I@std@@QBEIXZ PROC		; std::allocator<unsigned int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@I@std@@QBEIXZ ENDP		; std::allocator<unsigned int>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z ; std::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z PROC ; std::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1403 : 		{	// construct with offset and pointer

	mov	edx, DWORD PTR __Off$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1404 : 		}

	ret	8
??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z ENDP ; std::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z ; FDataStream::operator>><CvString>
EXTRN	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z PROC ; FDataStream::operator>><CvString>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z ENDP ; FDataStream::operator>><CvString>
_TEXT	ENDS
PUBLIC	??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z ; FDataStream::operator<<<CvString>
EXTRN	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z PROC ; FDataStream::operator<<<CvString>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z ENDP ; FDataStream::operator<<<CvString>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@I@std@@YAPAIIPAI@Z			; std::_Allocate<unsigned int>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@I@std@@YAPAIIPAI@Z
_TEXT	SEGMENT
$T221031 = -12						; size = 12
$T221035 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@I@std@@YAPAIIPAI@Z PROC			; std::_Allocate<unsigned int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T221035[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T221031[esp+16]
	mov	DWORD PTR $T221035[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T221031[esp+16]
	push	ecx
	mov	DWORD PTR $T221031[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@I@std@@YAPAIIPAI@Z ENDP			; std::_Allocate<unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC	; std::vector<bool,std::allocator<bool> >::size, COMDAT
; _this$ = ecx

; 2048 : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx]

; 2049 : 		}

	ret	0
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP	; std::vector<bool,std::allocator<bool> >::size
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const >::SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z
_TEXT	SEGMENT
$T221048 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z PROC ; SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const >::SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], eax

; 70   : 		m_saveTo << container.size();

	mov	eax, DWORD PTR [eax]
	lea	edx, DWORD PTR $T221048[esp]
	push	edx
	mov	DWORD PTR $T221048[esp+4], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z ENDP ; SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const >::SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const >
_TEXT	ENDS
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
_TEXT	ENDS
PUBLIC	??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator==, COMDAT
; _this$ = ecx

; 1666 : 
; 1667 :  #if _HAS_ITERATOR_DEBUGGING
; 1668 : 		_Compat(_Right);
; 1669 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1670 : 
; 1671 : 		return (this->_Myptr == _Right._Myptr
; 1672 : 			&& this->_Myoff == _Right._Myoff);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@operator@2
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator@2
	mov	eax, 1

; 1673 : 		}

	ret	4
$LN3@operator@2:

; 1666 : 
; 1667 :  #if _HAS_ITERATOR_DEBUGGING
; 1668 : 		_Compat(_Right);
; 1669 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1670 : 
; 1671 : 		return (this->_Myptr == _Right._Myptr
; 1672 : 			&& this->_Myoff == _Right._Myoff);

	xor	eax, eax

; 1673 : 		}

	ret	4
??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator==
_TEXT	ENDS
PUBLIC	?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Inc, COMDAT
; _this$ = ecx

; 1734 : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1735 : 		_SCL_SECURE_VALIDATE_RANGE((this->_My_actual_offset() + 1) <= ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1736 : 		if (this->_Myoff < _VBITS - 1)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 31					; 0000001fH
	jae	SHORT $LN2@Inc

; 1737 : 			++this->_Myoff;

	inc	eax
	mov	DWORD PTR [ecx+4], eax

; 1740 : 		}

	ret	0
$LN2@Inc:

; 1738 : 		else
; 1739 : 			this->_Myoff = 0, ++this->_Myptr;

	add	DWORD PTR [ecx], 4
	mov	DWORD PTR [ecx+4], 0

; 1740 : 		}

	ret	0
?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Inc
_TEXT	ENDS
PUBLIC	??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1465 : 		{	// construct with base

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1466 : 		}

	ret	4
??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Getptr
; Function compile flags: /Ogtpy
;	COMDAT ?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ
_TEXT	SEGMENT
?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Getptr, COMDAT
; _this$ = ecx

; 1500 : 
; 1501 :  #if _HAS_ITERATOR_DEBUGGING
; 1502 : 		if (this->_Mycont == 0 || this->_Myptr == 0)
; 1503 : 			{
; 1504 : 			_DEBUG_ERROR("vector<bool> iterator not dereferencable");
; 1505 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1506 : 			}
; 1507 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1508 :  		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1509 : 		_SCL_SECURE_VALIDATE_RANGE(this->_My_actual_offset() < ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1510 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1511 : 
; 1512 : 		return (this->_Myptr);

	mov	eax, DWORD PTR [ecx]

; 1513 : 		}

	ret	0
?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Getptr
_TEXT	ENDS
PUBLIC	?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Mask
; Function compile flags: /Ogtpy
;	COMDAT ?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ
_TEXT	SEGMENT
?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Mask, COMDAT
; _this$ = ecx

; 1518 : 		return ((_Vbase)(1 << this->_Myoff));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, 1
	shl	eax, cl

; 1519 : 		}

	ret	0
?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Mask
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ; std::_Iter_random<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z ; std::_Iter_random<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z PROC ; std::_Iter_random<unsigned int *,unsigned int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z ENDP ; std::_Iter_random<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ; std::_Ptr_cat<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z PROC ; std::_Ptr_cat<unsigned int *,unsigned int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ENDP ; std::_Ptr_cat<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@2

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@2:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*, COMDAT
; _this$ = ecx

; 1791 : 		return (_Reft(*this));

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 1792 : 		}

	ret	4
??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@QAEXAB_N@Z ; SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const >::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@QAEXAB_N@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@QAEXAB_N@Z PROC ; SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const >::operator(), COMDAT
; _this$ = ecx

; 75   : 		m_saveTo << i;

	mov	ecx, DWORD PTR [ecx]
	jmp	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
??R?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@QAEXAB_N@Z ENDP ; SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const >::operator()
_TEXT	ENDS
PUBLIC	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 1
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=, COMDAT
; _this$ = ecx

; 1475 : 		{	// assign _Val to bit

	mov	eax, ecx

; 1476 : 		if (_Val)
; 1477 : 			*_Getptr() |= _Mask();

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, 1
	shl	esi, cl
	cmp	BYTE PTR __Val$[esp], 0
	je	SHORT $LN2@operator@3
	or	DWORD PTR [edx], esi
	pop	esi

; 1480 : 		return (*this);
; 1481 : 		}

	ret	4
$LN2@operator@3:

; 1478 : 		else
; 1479 : 			*_Getptr() &= ~_Mask();

	not	esi
	and	DWORD PTR [edx], esi
	pop	esi

; 1480 : 		return (*this);
; 1481 : 		}

	ret	4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
_TEXT	ENDS
PUBLIC	?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
; Function compile flags: /Ogtpy
;	COMDAT ?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@2
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
_TEXT	ENDS
PUBLIC	??$_Fill@PAII@std@@YAXPAI0ABI@Z			; std::_Fill<unsigned int *,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAII@std@@YAXPAI0ABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAII@std@@YAXPAI0ABI@Z PROC			; std::_Fill<unsigned int *,unsigned int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@2
	pop	esi
$LN1@Fill@2:

; 3160 : 	}

	ret	0
??$_Fill@PAII@std@@YAXPAI0ABI@Z ENDP			; std::_Fill<unsigned int *,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ; std::_Move_cat<unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z PROC ; std::_Move_cat<unsigned int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ENDP ; std::_Move_cat<unsigned int *>
_TEXT	ENDS
PUBLIC	?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Dec
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Dec, COMDAT
; _this$ = ecx

; 1719 : 		if (this->_Myoff != 0)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN2@Dec

; 1720 : 			{
; 1721 : 			--this->_Myoff;

	dec	eax
	mov	DWORD PTR [ecx+4], eax

; 1729 : 			}
; 1730 : 		}

	ret	0
$LN2@Dec:

; 1722 : 			}
; 1723 : 		else
; 1724 : 			{
; 1725 : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1726 : 			_SCL_SECURE_VALIDATE_RANGE(this->_Myptr > this->_My_cont_begin());
; 1727 : 			--this->_Myptr;

	add	DWORD PTR [ecx], -4			; fffffffcH

; 1728 : 			this->_Myoff = _VBITS - 1;

	mov	DWORD PTR [ecx+4], 31			; 0000001fH

; 1729 : 			}
; 1730 : 		}

	ret	0
?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Dec
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@2

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@2:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ; std::_Iter_cat<unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z PROC ; std::_Iter_cat<unsigned int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ENDP ; std::_Iter_cat<unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
_TEXT	ENDS
PUBLIC	??_7ICvNetInitInfo1@@6B@			; ICvNetInitInfo1::`vftable'
PUBLIC	??0ICvNetInitInfo1@@QAE@XZ			; ICvNetInitInfo1::ICvNetInitInfo1
PUBLIC	??_R4ICvNetInitInfo1@@6B@			; ICvNetInitInfo1::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVICvNetInitInfo1@@@8			; ICvNetInitInfo1 `RTTI Type Descriptor'
PUBLIC	??_R3ICvNetInitInfo1@@8				; ICvNetInitInfo1::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ICvNetInitInfo1@@8				; ICvNetInitInfo1::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ICvNetInitInfo1@@8		; ICvNetInitInfo1::`RTTI Base Class Descriptor at (0,-1,0,64)'
;	COMDAT ??_R1A@?0A@EA@ICvNetInitInfo1@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ICvNetInitInfo1@@8 DD FLAT:??_R0?AVICvNetInitInfo1@@@8 ; ICvNetInitInfo1::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ICvNetInitInfo1@@8
rdata$r	ENDS
;	COMDAT ??_R2ICvNetInitInfo1@@8
rdata$r	SEGMENT
??_R2ICvNetInitInfo1@@8 DD FLAT:??_R1A@?0A@EA@ICvNetInitInfo1@@8 ; ICvNetInitInfo1::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ICvUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3ICvNetInitInfo1@@8
rdata$r	SEGMENT
??_R3ICvNetInitInfo1@@8 DD 00H				; ICvNetInitInfo1::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ICvNetInitInfo1@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVICvNetInitInfo1@@@8
_DATA	SEGMENT
??_R0?AVICvNetInitInfo1@@@8 DD FLAT:??_7type_info@@6B@	; ICvNetInitInfo1 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVICvNetInitInfo1@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ICvNetInitInfo1@@6B@
rdata$r	SEGMENT
??_R4ICvNetInitInfo1@@6B@ DD 00H			; ICvNetInitInfo1::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVICvNetInitInfo1@@@8
	DD	FLAT:??_R3ICvNetInitInfo1@@8
rdata$r	ENDS
;	COMDAT ??_7ICvNetInitInfo1@@6B@
CONST	SEGMENT
??_7ICvNetInitInfo1@@6B@ DD FLAT:??_R4ICvNetInitInfo1@@6B@ ; ICvNetInitInfo1::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0ICvNetInitInfo1@@QAE@XZ
_TEXT	SEGMENT
??0ICvNetInitInfo1@@QAE@XZ PROC				; ICvNetInitInfo1::ICvNetInitInfo1, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7ICvNetInitInfo1@@6B@
	ret	0
??0ICvNetInitInfo1@@QAE@XZ ENDP				; ICvNetInitInfo1::ICvNetInitInfo1
_TEXT	ENDS
PUBLIC	?QueryInterface@CvDllNetInitInfo@@UAGPAXU_GUID@@@Z ; CvDllNetInitInfo::QueryInterface
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdllnetinitinfo.cpp
;	COMDAT ?QueryInterface@CvDllNetInitInfo@@UAGPAXU_GUID@@@Z
_TEXT	SEGMENT
$T221186 = -16						; size = 16
$T221184 = -16						; size = 16
_this$ = 8						; size = 4
_guidInterface$ = 12					; size = 16
?QueryInterface@CvDllNetInitInfo@@UAGPAXU_GUID@@@Z PROC	; CvDllNetInitInfo::QueryInterface, COMDAT

; 63   : {

	sub	esp, 16					; 00000010H

; 64   : 	if(guidInterface == ICvUnknown::GetInterfaceId() ||
; 65   : 	        guidInterface == ICvNetInitInfo1::GetInterfaceId())

	mov	ecx, DWORD PTR _guidICvUnknown+4
	mov	edx, DWORD PTR _guidICvUnknown+8
	mov	eax, DWORD PTR _guidICvUnknown
	mov	DWORD PTR $T221184[esp+20], ecx
	lea	ecx, DWORD PTR $T221184[esp+16]
	mov	DWORD PTR $T221184[esp+24], edx
	mov	DWORD PTR $T221184[esp+16], eax
	mov	eax, DWORD PTR _guidICvUnknown+12
	push	ecx
	lea	edx, DWORD PTR _guidInterface$[esp+16]
	push	edx
	mov	DWORD PTR $T221184[esp+36], eax
	call	_IsEqualGUID
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@QueryInter
	mov	ecx, DWORD PTR _guidICvNetInitInfo1+4
	mov	edx, DWORD PTR _guidICvNetInitInfo1+8
	mov	eax, DWORD PTR _guidICvNetInitInfo1
	mov	DWORD PTR $T221186[esp+20], ecx
	lea	ecx, DWORD PTR $T221186[esp+16]
	mov	DWORD PTR $T221186[esp+24], edx
	mov	DWORD PTR $T221186[esp+16], eax
	mov	eax, DWORD PTR _guidICvNetInitInfo1+12
	push	ecx
	lea	edx, DWORD PTR _guidInterface$[esp+16]
	push	edx
	mov	DWORD PTR $T221186[esp+36], eax
	call	_IsEqualGUID
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@QueryInter

; 68   : 		return this;
; 69   : 	}
; 70   : 
; 71   : 	return NULL;
; 72   : }

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
$LN1@QueryInter:

; 66   : 	{
; 67   : 		IncrementReference();

	mov	eax, DWORD PTR _this$[esp+12]
	inc	DWORD PTR [eax+760]

; 68   : 		return this;
; 69   : 	}
; 70   : 
; 71   : 	return NULL;
; 72   : }

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
?QueryInterface@CvDllNetInitInfo@@UAGPAXU_GUID@@@Z ENDP	; CvDllNetInitInfo::QueryInterface
_TEXT	ENDS
PUBLIC	?Commit@CvDllNetInitInfo@@UAG_NXZ		; CvDllNetInitInfo::Commit
EXTRN	?setGameMode@CvPreGame@@YAXW4GameMode@@@Z:PROC	; CvPreGame::setGameMode
EXTRN	?setAdvancedStartPoints@CvPreGame@@YAXH@Z:PROC	; CvPreGame::setAdvancedStartPoints
EXTRN	?setNumMinorCivs@CvPreGame@@YAXH@Z:PROC		; CvPreGame::setNumMinorCivs
EXTRN	?setMaxCityElimination@CvPreGame@@YAXH@Z:PROC	; CvPreGame::setMaxCityElimination
EXTRN	?setMaxTurns@CvPreGame@@YAXH@Z:PROC		; CvPreGame::setMaxTurns
EXTRN	?setMultiplayerOptions@CvPreGame@@YAXABV?$vector@_NV?$allocator@_N@std@@@std@@@Z:PROC ; CvPreGame::setMultiplayerOptions
EXTRN	?SetMapOptions@CvPreGame@@YA_NABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z:PROC ; CvPreGame::SetMapOptions
EXTRN	?SetGameOptions@CvPreGame@@YA_NABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z:PROC ; CvPreGame::SetGameOptions
EXTRN	?setVictories@CvPreGame@@YAXABV?$vector@_NV?$allocator@_N@std@@@std@@@Z:PROC ; CvPreGame::setVictories
EXTRN	?setMapRandomSeed@CvPreGame@@YAXI@Z:PROC	; CvPreGame::setMapRandomSeed
EXTRN	?setSyncRandomSeed@CvPreGame@@YAXI@Z:PROC	; CvPreGame::setSyncRandomSeed
EXTRN	?setGameName@CvPreGame@@YAXABVCvString@@@Z:PROC	; CvPreGame::setGameName
EXTRN	?setPitBossTurnTime@CvPreGame@@YAXH@Z:PROC	; CvPreGame::setPitBossTurnTime
EXTRN	?setTurnTimer@CvPreGame@@YAXW4TurnTimerTypes@@@Z:PROC ; CvPreGame::setTurnTimer
EXTRN	?setGameSpeed@CvPreGame@@YAXW4GameSpeedTypes@@@Z:PROC ; CvPreGame::setGameSpeed
EXTRN	?setGameStarted@CvPreGame@@YAX_N@Z:PROC		; CvPreGame::setGameStarted
EXTRN	?setGameTurn@CvPreGame@@YAXH@Z:PROC		; CvPreGame::setGameTurn
EXTRN	?setCalendar@CvPreGame@@YAXW4CalendarTypes@@@Z:PROC ; CvPreGame::setCalendar
EXTRN	?setEra@CvPreGame@@YAXW4EraTypes@@@Z:PROC	; CvPreGame::setEra
EXTRN	?setSeaLevel@CvPreGame@@YAXW4SeaLevelTypes@@@Z:PROC ; CvPreGame::setSeaLevel
EXTRN	?setClimate@CvPreGame@@YAXW4ClimateTypes@@@Z:PROC ; CvPreGame::setClimate
EXTRN	?setRandomWorldSize@CvPreGame@@YAX_N@Z:PROC	; CvPreGame::setRandomWorldSize
EXTRN	?setWorldSize@CvPreGame@@YAXW4WorldSizeTypes@@_N@Z:PROC ; CvPreGame::setWorldSize
EXTRN	?setMapNoPlayers@CvPreGame@@YAX_N@Z:PROC	; CvPreGame::setMapNoPlayers
EXTRN	?setLoadFileName@CvPreGame@@YAXABVCvString@@W4StorageLocation@@@Z:PROC ; CvPreGame::setLoadFileName
EXTRN	?setTransferredMap@CvPreGame@@YAX_N@Z:PROC	; CvPreGame::setTransferredMap
EXTRN	?setRandomMapScript@CvPreGame@@YAX_N@Z:PROC	; CvPreGame::setRandomMapScript
EXTRN	?setMapScriptName@CvPreGame@@YAXABVCvString@@@Z:PROC ; CvPreGame::setMapScriptName
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	_memset:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Commit@CvDllNetInitInfo@@UAG_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Commit@CvDllNetInitInfo@@UAG_NXZ$0
__ehfuncinfo$?Commit@CvDllNetInitInfo@@UAG_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Commit@CvDllNetInitInfo@@UAG_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdllnetinitinfo.cpp
xdata$x	ENDS
;	COMDAT ?Commit@CvDllNetInitInfo@@UAG_NXZ
_TEXT	SEGMENT
_bResult$ = -1085					; size = 1
tv361 = -1084						; size = 4
tv149 = -1084						; size = 4
_strMapScriptPath$ = -1080				; size = 28
_szMapScriptPath$ = -1052				; size = 1040
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?Commit@CvDllNetInitInfo@@UAG_NXZ PROC			; CvDllNetInitInfo::Commit, COMDAT

; 239  : {

	push	-1
	push	__ehhandler$?Commit@CvDllNetInitInfo@@UAG_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1076				; 00000434H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 240  : 	// Copy the settings into our initialization data structure
; 241  : 
; 242  : 	//The map script path cannot be trusted since this structure is sent over the network.
; 243  : 	//Have the app search for the best candidate.
; 244  : 	FILogFile* logFile = LOGFILEMGR.GetLog("net_message_debug.log", 0);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	edx, DWORD PTR [eax]
	push	0
	push	0
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+12]
	push	OFFSET $SG219379
	call	eax

; 245  : 
; 246  : 	char szMapScriptPath[1040] = {0};

	push	1039					; 0000040fH
	lea	ecx, DWORD PTR _szMapScriptPath$[esp+1109]
	push	0
	push	ecx
	mov	ebx, eax
	mov	BYTE PTR _szMapScriptPath$[esp+1116], 0
	call	_memset

; 247  : 	const bool bResult = gDLL->GetEvaluatedMapScriptPath(m_szMapScriptName.c_str(), szMapScriptPath, 1040);

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	esi, DWORD PTR _this$[esp+1112]
	mov	edx, DWORD PTR [edi]
	add	esp, 12					; 0000000cH
	push	1040					; 00000410H
	lea	eax, DWORD PTR _szMapScriptPath$[esp+1108]
	lea	ebp, DWORD PTR [esi+36]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR tv361[esp+1112], edx
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR tv361[esp+1112]
	mov	edx, DWORD PTR [ecx+1036]
	push	eax
	push	edi
	call	edx
	mov	BYTE PTR _bResult$[esp+1104], al

; 248  : 
; 249  : 	CvString strMapScriptPath = szMapScriptPath;

	lea	eax, DWORD PTR _szMapScriptPath$[esp+1104]
	push	eax
	lea	ecx, DWORD PTR _strMapScriptPath$[esp+1108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 250  : 
; 251  : 	logFile->DebugMsg("Evaluating Map Path: (%s)\nOriginal Path: %s\nNew Path: %s", (bResult)? "Success": "Failed", m_szMapScriptName.c_str(), strMapScriptPath.c_str());

	cmp	BYTE PTR _bResult$[esp+1104], 0
	mov	DWORD PTR __$EHRec$[esp+1112], 0
	mov	DWORD PTR tv149[esp+1104], OFFSET $SG219383
	jne	SHORT $LN4@Commit
	mov	DWORD PTR tv149[esp+1104], OFFSET $SG219384
$LN4@Commit:
	mov	edi, DWORD PTR [ebx]
	lea	ecx, DWORD PTR _strMapScriptPath$[esp+1104]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, ebp
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR tv149[esp+1108]
	mov	edx, DWORD PTR [edi+4]
	push	eax
	push	ecx
	push	OFFSET $SG219385
	push	ebx
	call	edx

; 252  : 
; 253  : 	CvPreGame::setMapScriptName(strMapScriptPath);

	lea	eax, DWORD PTR _strMapScriptPath$[esp+1124]
	push	eax
	call	?setMapScriptName@CvPreGame@@YAXABVCvString@@@Z ; CvPreGame::setMapScriptName

; 254  : 	CvPreGame::setRandomMapScript(m_bIsRandomMapScript);

	movzx	ecx, BYTE PTR [esi+65]
	push	ecx
	call	?setRandomMapScript@CvPreGame@@YAX_N@Z	; CvPreGame::setRandomMapScript

; 255  : 	CvPreGame::setTransferredMap(false);		// We'll always set this manually

	push	0
	call	?setTransferredMap@CvPreGame@@YAX_N@Z	; CvPreGame::setTransferredMap

; 256  : 	CvPreGame::setLoadFileName(m_szLoadFileName, m_eLoadFileStorage);

	mov	edx, DWORD PTR [esi+32]
	push	edx
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	?setLoadFileName@CvPreGame@@YAXABVCvString@@W4StorageLocation@@@Z ; CvPreGame::setLoadFileName

; 257  : 	CvPreGame::setMapNoPlayers(m_bWBMapNoPlayers);

	movzx	ecx, BYTE PTR [esi+67]
	push	ecx
	call	?setMapNoPlayers@CvPreGame@@YAX_N@Z	; CvPreGame::setMapNoPlayers

; 258  : 	CvPreGame::setWorldSize(m_eWorldSize,false);

	mov	edx, DWORD PTR [esi+68]
	push	0
	push	edx
	call	?setWorldSize@CvPreGame@@YAXW4WorldSizeTypes@@_N@Z ; CvPreGame::setWorldSize

; 259  : 	CvPreGame::setRandomWorldSize(m_bIsRandomWorldSize);

	movzx	eax, BYTE PTR [esi+66]
	push	eax
	call	?setRandomWorldSize@CvPreGame@@YAX_N@Z	; CvPreGame::setRandomWorldSize

; 260  : 	CvPreGame::setClimate(m_eClimate);

	mov	ecx, DWORD PTR [esi+72]
	push	ecx
	call	?setClimate@CvPreGame@@YAXW4ClimateTypes@@@Z ; CvPreGame::setClimate

; 261  : 	CvPreGame::setSeaLevel(m_eSeaLevel);

	mov	edx, DWORD PTR [esi+76]
	push	edx
	call	?setSeaLevel@CvPreGame@@YAXW4SeaLevelTypes@@@Z ; CvPreGame::setSeaLevel

; 262  : 	CvPreGame::setEra(m_eEra);

	mov	eax, DWORD PTR [esi+80]
	add	esp, 64					; 00000040H
	push	eax
	call	?setEra@CvPreGame@@YAXW4EraTypes@@@Z	; CvPreGame::setEra

; 263  : 	CvPreGame::setCalendar(m_eCalendar);

	mov	ecx, DWORD PTR [esi+84]
	push	ecx
	call	?setCalendar@CvPreGame@@YAXW4CalendarTypes@@@Z ; CvPreGame::setCalendar

; 264  : 	CvPreGame::setGameTurn(m_iGameTurn);

	mov	edx, DWORD PTR [esi+88]
	push	edx
	call	?setGameTurn@CvPreGame@@YAXH@Z		; CvPreGame::setGameTurn

; 265  : 	CvPreGame::setGameStarted(m_bGameStarted);

	movzx	eax, BYTE PTR [esi+92]
	push	eax
	call	?setGameStarted@CvPreGame@@YAX_N@Z	; CvPreGame::setGameStarted

; 266  : 	CvPreGame::setGameSpeed(m_eGameSpeed);

	mov	ecx, DWORD PTR [esi+96]
	push	ecx
	call	?setGameSpeed@CvPreGame@@YAXW4GameSpeedTypes@@@Z ; CvPreGame::setGameSpeed

; 267  : 	CvPreGame::setTurnTimer(m_eTurnTimerEnabled);

	mov	edx, DWORD PTR [esi+100]
	push	edx
	call	?setTurnTimer@CvPreGame@@YAXW4TurnTimerTypes@@@Z ; CvPreGame::setTurnTimer

; 268  : 	CvPreGame::setPitBossTurnTime(m_iTurnTimerTime);

	mov	eax, DWORD PTR [esi+104]
	push	eax
	call	?setPitBossTurnTime@CvPreGame@@YAXH@Z	; CvPreGame::setPitBossTurnTime

; 269  : 	CvPreGame::setGameName(m_szGameName);

	lea	ecx, DWORD PTR [esi+108]
	push	ecx
	call	?setGameName@CvPreGame@@YAXABVCvString@@@Z ; CvPreGame::setGameName

; 270  : 	CvPreGame::setSyncRandomSeed(m_uiSyncRandSeed);

	mov	edx, DWORD PTR [esi+136]
	push	edx
	call	?setSyncRandomSeed@CvPreGame@@YAXI@Z	; CvPreGame::setSyncRandomSeed

; 271  : 	CvPreGame::setMapRandomSeed(m_uiMapRandSeed);

	mov	eax, DWORD PTR [esi+140]
	push	eax
	call	?setMapRandomSeed@CvPreGame@@YAXI@Z	; CvPreGame::setMapRandomSeed

; 272  : 	CvPreGame::setVictories(m_abVictories);

	lea	ecx, DWORD PTR [esi+148]
	push	ecx
	call	?setVictories@CvPreGame@@YAXABV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; CvPreGame::setVictories

; 273  : 	CvPreGame::SetGameOptions(m_aGameOptions);

	lea	edx, DWORD PTR [esi+168]
	push	edx
	call	?SetGameOptions@CvPreGame@@YA_NABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; CvPreGame::SetGameOptions

; 274  : 	CvPreGame::SetMapOptions(m_aMapOptions);

	lea	eax, DWORD PTR [esi+184]
	push	eax
	call	?SetMapOptions@CvPreGame@@YA_NABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; CvPreGame::SetMapOptions

; 275  : 	CvPreGame::setMultiplayerOptions(m_abMPOptions);

	lea	ecx, DWORD PTR [esi+200]
	push	ecx
	call	?setMultiplayerOptions@CvPreGame@@YAXABV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; CvPreGame::setMultiplayerOptions

; 276  : 	CvPreGame::setMaxTurns(m_iMaxTurns);

	mov	edx, DWORD PTR [esi+220]
	push	edx
	call	?setMaxTurns@CvPreGame@@YAXH@Z		; CvPreGame::setMaxTurns

; 277  : 	CvPreGame::setMaxCityElimination(m_iMaxCityElimination);

	mov	eax, DWORD PTR [esi+228]
	push	eax
	call	?setMaxCityElimination@CvPreGame@@YAXH@Z ; CvPreGame::setMaxCityElimination

; 278  : 	CvPreGame::setNumMinorCivs(m_iNumMinorCivs);

	mov	ecx, DWORD PTR [esi+232]
	add	esp, 64					; 00000040H
	push	ecx
	call	?setNumMinorCivs@CvPreGame@@YAXH@Z	; CvPreGame::setNumMinorCivs

; 279  : 	CvPreGame::setAdvancedStartPoints(m_iNumAdvancedStartPoints);

	mov	edx, DWORD PTR [esi+236]
	push	edx
	call	?setAdvancedStartPoints@CvPreGame@@YAXH@Z ; CvPreGame::setAdvancedStartPoints

; 280  : 	CvPreGame::setGameMode(m_eMode);

	mov	eax, DWORD PTR [esi+240]
	push	eax
	call	?setGameMode@CvPreGame@@YAXW4GameMode@@@Z ; CvPreGame::setGameMode
	add	esp, 12					; 0000000cH

; 281  : 
; 282  : 	return true;

	lea	ecx, DWORD PTR _strMapScriptPath$[esp+1104]
	mov	DWORD PTR __$EHRec$[esp+1112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 283  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+1104]
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 1088				; 00000440H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Commit@CvDllNetInitInfo@@UAG_NXZ$0:
	lea	ecx, DWORD PTR _strMapScriptPath$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?Commit@CvDllNetInitInfo@@UAG_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?Commit@CvDllNetInitInfo@@UAG_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Commit@CvDllNetInitInfo@@UAG_NXZ ENDP			; CvDllNetInitInfo::Commit
PUBLIC	??1?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE@V?$allocator@VCustomOption@CvPreGame@@@1@@Z ; std::_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE@V?$allocator@VCustomOption@CvPreGame@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE@V?$allocator@VCustomOption@CvPreGame@@@1@@Z PROC ; std::_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE@V?$allocator@VCustomOption@CvPreGame@@@1@@Z ENDP ; std::_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEIXZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 63161283				; 03c3c3c3H

; 732  : 		}

	ret	0
?max_size@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::max_size
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T221271 = -80						; size = 28
$T221270 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T221271[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T221270[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T221271[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T221270[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T221270[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T221270[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T221270[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@3:
$LN12@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T221271[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T221270[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Xlen
PUBLIC	??0?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@PAVCustomOption@CvPreGame@@@Z ; std::_Vector_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Vector_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@PAVCustomOption@CvPreGame@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@PAVCustomOption@CvPreGame@@@Z PROC ; std::_Vector_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Vector_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@PAVCustomOption@CvPreGame@@@Z ENDP ; std::_Vector_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Vector_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator!=
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z ; stdext::unchecked_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z PROC ; stdext::unchecked_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	esi, ebx
	je	SHORT $LN14@unchecked_
$LL9@unchecked_:
	push	esi
	mov	ecx, edi
	call	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z ; CvPreGame::CustomOption::operator=
	add	esi, 68					; 00000044H
	add	edi, 68					; 00000044H
	cmp	esi, ebx
	jne	SHORT $LL9@unchecked_
$LN14@unchecked_:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z ENDP ; stdext::unchecked_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *>
_TEXT	ENDS
PUBLIC	??$_Allocate@VCustomOption@CvPreGame@@@std@@YAPAVCustomOption@CvPreGame@@IPAV12@@Z ; std::_Allocate<CvPreGame::CustomOption>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@VCustomOption@CvPreGame@@@std@@YAPAVCustomOption@CvPreGame@@IPAV12@@Z
_TEXT	SEGMENT
$T221334 = -12						; size = 12
$T221338 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCustomOption@CvPreGame@@@std@@YAPAVCustomOption@CvPreGame@@IPAV12@@Z PROC ; std::_Allocate<CvPreGame::CustomOption>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, ecx
	shl	edx, 4
	add	edx, ecx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 68					; 00000044H
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T221338[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T221334[esp+16]
	mov	DWORD PTR $T221338[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T221334[esp+16]
	push	ecx
	mov	DWORD PTR $T221334[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@VCustomOption@CvPreGame@@@std@@YAPAVCustomOption@CvPreGame@@IPAV12@@Z ENDP ; std::_Allocate<CvPreGame::CustomOption>
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; SerializeFromSequenceContainer<CvPreGame::CustomOption const ,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > const >::SerializeFromSequenceContainer<CvPreGame::CustomOption const ,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > const >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z
_TEXT	SEGMENT
$T221344 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z PROC ; SerializeFromSequenceContainer<CvPreGame::CustomOption const ,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > const >::SerializeFromSequenceContainer<CvPreGame::CustomOption const ,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx

; 70   : 		m_saveTo << container.size();

	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	mov	eax, 2021161081				; 78787879H
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	edx, DWORD PTR $T221344[esp]
	push	edx
	mov	DWORD PTR $T221344[esp+4], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ENDP ; SerializeFromSequenceContainer<CvPreGame::CustomOption const ,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > const >::SerializeFromSequenceContainer<CvPreGame::CustomOption const ,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > const >
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >,SerializeFromSequenceContainer<CvPreGame::CustomOption const ,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > const > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >,SerializeFromSequenceContainer<CvPreGame::CustomOption const ,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > const > >, COMDAT

; 23   : 	{	// perform function for each element

	push	esi

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));

	mov	esi, DWORD PTR __First$[esp]
	push	edi

; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	edi, DWORD PTR __Last$[esp+4]

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, edi
	je	SHORT $LN1@for_each
	npad	2
$LL6@for_each:

; 29   : 		_Func(*_ChkFirst);

	mov	eax, DWORD PTR __Func$[esp+4]
	push	esi
	push	eax
	call	??6CvPreGame@@YAAAVFDataStream@@AAV1@ABVCustomOption@0@@Z ; CvPreGame::operator<<
	add	esi, 68					; 00000044H
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL6@for_each
$LN1@for_each:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Func$[esp+4]
	mov	edx, DWORD PTR __Func$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 31   : 	}

	ret	0
??$for_each@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBVCustomOption@CvPreGame@@$$CBV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_const_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >,SerializeFromSequenceContainer<CvPreGame::CustomOption const ,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > const > >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@@Z ; std::allocator<CvPreGame::CustomOption>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@@Z PROC ; std::allocator<CvPreGame::CustomOption>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@@Z ENDP ; std::allocator<CvPreGame::CustomOption>::destroy
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	edx, ecx
	shl	edx, 4
	add	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAVCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@0ABV12@@Z ; std::fill<CvPreGame::CustomOption *,CvPreGame::CustomOption>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAVCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@0ABV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@0ABV12@@Z PROC ; std::fill<CvPreGame::CustomOption *,CvPreGame::CustomOption>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN3@fill
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
$LL5@fill:
	push	ebx
	mov	ecx, esi
	call	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z ; CvPreGame::CustomOption::operator=
	add	esi, 68					; 00000044H
	cmp	esi, edi
	jne	SHORT $LL5@fill
	pop	ebx
$LN3@fill:
	pop	edi
	pop	esi

; 3188 : 	}

	ret	0
??$fill@PAVCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@0ABV12@@Z ENDP ; std::fill<CvPreGame::CustomOption *,CvPreGame::CustomOption>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@ABV34@@Z ; std::allocator<CvPreGame::CustomOption>::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@ABV34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@ABV34@@Z$0
__ehfuncinfo$?construct@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@ABV34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@ABV34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@ABV34@@Z
_TEXT	SEGMENT
$T221415 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$221412 = 8					; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@ABV34@@Z PROC ; std::allocator<CvPreGame::CustomOption>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@ABV34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$221412[esp+12], ecx
	mov	DWORD PTR $T221415[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN5@construct
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	??0CustomOption@CvPreGame@@QAE@ABV01@@Z	; CvPreGame::CustomOption::CustomOption
$LN5@construct:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@ABV34@@Z$0:
	mov	eax, DWORD PTR __Vptr$221412[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T221415[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@ABV34@@Z:
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@ABV34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@VCustomOption@CvPreGame@@@std@@QAEXPAVCustomOption@CvPreGame@@ABV34@@Z ENDP ; std::allocator<CvPreGame::CustomOption>::construct
PUBLIC	??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPreGame::CustomOption *,unsigned int,CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__unwindtable$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
__Vptr$221454 = 8					; size = 4
__First$ = 8						; size = 4
$T221457 = 12						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvPreGame::CustomOption *,unsigned int,CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	esi, DWORD PTR __First$[ebp]
	push	edi

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __Count$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	6
$LL6@Uninit_fil:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$221454[ebp], esi
	mov	DWORD PTR $T221457[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	??0CustomOption@CvPreGame@@QAE@ABV01@@Z	; CvPreGame::CustomOption::CustomOption
$LN18@Uninit_fil:
	dec	edi
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	add	esi, 68					; 00000044H
	jmp	SHORT $LL6@Uninit_fil
__catch$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN29@Uninit_fil:
$LN4@Uninit_fil:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@Uninit_fil:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$221454[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221457[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvPreGame::CustomOption *,unsigned int,CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
PUBLIC	??$_Move_backward_opt@PAVCustomOption@CvPreGame@@PAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Move_backward_opt@PAVCustomOption@CvPreGame@@PAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVCustomOption@CvPreGame@@PAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	ebx, esi
	je	SHORT $LN11@Move_backw
$LL6@Move_backw:
	sub	esi, 68					; 00000044H
	sub	edi, 68					; 00000044H
	push	esi
	mov	ecx, edi
	call	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z ; CvPreGame::CustomOption::operator=
	cmp	esi, ebx
	jne	SHORT $LL6@Move_backw
$LN11@Move_backw:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAVCustomOption@CvPreGame@@PAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=, COMDAT
; _this$ = ecx

; 1822 : 		*(_Mybase *)this += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=

; 1823 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1824 : 		}

	ret	4
??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
_TEXT	ENDS
PUBLIC	??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+, COMDAT
; _this$ = ecx

; 1827 : 		{	// return this + integer

	sub	esp, 8

; 1828 : 		_Mytype _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]

; 1829 : 		return (_Tmp += _Off);

	mov	edx, DWORD PTR __Off$[esp+4]
	mov	DWORD PTR __Tmp$[esp+12], ecx
	push	edx
	lea	ecx, DWORD PTR __Tmp$[esp+12]
	mov	DWORD PTR __Tmp$[esp+12], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Tmp$[esp+8]
	mov	edx, DWORD PTR __Tmp$[esp+12]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1830 : 		}

	add	esp, 8
	ret	8
??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
_TEXT	ENDS
PUBLIC	??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-, COMDAT
; _this$ = ecx

; 1845 : 		return (*(_Mybase *)this - _Right);

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx]
	sar	eax, 2
	shl	eax, 5
	sub	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR [ecx+4]

; 1846 : 		}

	ret	4
??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
_TEXT	ENDS
PUBLIC	?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@I@std@@QAEPAII@Z		; std::allocator<unsigned int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@I@std@@QAEPAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@I@std@@QAEPAII@Z PROC		; std::allocator<unsigned int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@I@std@@QAEPAII@Z ENDP		; std::allocator<unsigned int>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1567 : 		{	// construct with offset and pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1568 : 		}

	ret	4
??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z	; stdext::unchecked_copy<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z PROC	; stdext::unchecked_copy<unsigned int *,unsigned int *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ENDP	; stdext::unchecked_copy<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::begin, COMDAT
; _this$ = ecx

; 1990 : 		return (const_iterator(_VEC_ITER_BASE(_Myvec.begin())));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1991 : 		}

	ret	4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::end, COMDAT
; _this$ = ecx

; 2004 : 		const_iterator _Tmp = begin();

	mov	eax, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], 0

; 2005 : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jbe	SHORT $LN14@end

; 2006 : 			_Tmp += _Mysize;

	push	ecx
	mov	ecx, esi
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN14@end:

; 2007 : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 2008 : 		}

	ret	4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::end
_TEXT	ENDS
PUBLIC	??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++, COMDAT
; _this$ = ecx

; 1576 : 		{	// preincrement

	mov	eax, ecx

; 1577 : 		_Inc();

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN4@operator@4
	inc	ecx
	mov	DWORD PTR [eax+4], ecx

; 1578 : 		return (*this);
; 1579 : 		}

	ret	0

; 1577 : 		_Inc();

$LN4@operator@4:
	add	DWORD PTR [eax], 4
	mov	DWORD PTR [eax+4], 0

; 1578 : 		return (*this);
; 1579 : 		}

	ret	0
??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator!=, COMDAT
; _this$ = ecx

; 1677 : 		return (!(*this == _Right));

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@operator@5
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN5@operator@5
	mov	eax, 1
	xor	edx, edx
	test	al, al
	sete	dl
	mov	al, dl

; 1678 : 		}

	ret	4

; 1677 : 		return (!(*this == _Right));

$LN5@operator@5:
	xor	eax, eax
	xor	edx, edx
	test	al, al
	sete	dl
	mov	al, dl

; 1678 : 		}

	ret	4
??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator!=
_TEXT	ENDS
PUBLIC	??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator bool
; Function compile flags: /Ogtpy
;	COMDAT ??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator bool, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if bit is set

	mov	edx, ecx

; 1495 : 		return ((*_Getptr() & _Mask()) != 0);

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR [edx]
	and	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	neg	eax

; 1496 : 		}

	ret	0
??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator bool
_TEXT	ENDS
PUBLIC	??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++, COMDAT
; _this$ = ecx

; 1795 : 		{	// preincrement

	mov	eax, ecx

; 1796 : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN6@operator@6
	inc	ecx
	mov	DWORD PTR [eax+4], ecx

; 1797 : 		return (*this);
; 1798 : 		}

	ret	0

; 1796 : 		++*(_Mybase *)this;

$LN6@operator@6:
	add	DWORD PTR [eax], 4
	mov	DWORD PTR [eax+4], 0

; 1797 : 		return (*this);
; 1798 : 		}

	ret	0
??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
_TEXT	ENDS
PUBLIC	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=, COMDAT
; _this$ = ecx

; 1471 : 		return (*this = bool(_Right));

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR [edx+4]
	push	esi
	mov	esi, 1
	shl	esi, cl
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax]
	test	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	mov	esi, 1
	je	SHORT $LN10@operator@7
	shl	esi, cl
	or	DWORD PTR [edx], esi
	pop	esi

; 1472 : 		}

	ret	4

; 1471 : 		return (*this = bool(_Right));

$LN10@operator@7:
	shl	esi, cl
	not	esi
	and	DWORD PTR [edx], esi
	pop	esi

; 1472 : 		}

	ret	4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
_TEXT	ENDS
PUBLIC	??$fill@PAII@std@@YAXPAI0ABI@Z			; std::fill<unsigned int *,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAII@std@@YAXPAI0ABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAII@std@@YAXPAI0ABI@Z PROC			; std::fill<unsigned int *,unsigned int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@2
	pop	esi
$LN3@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAII@std@@YAXPAI0ABI@Z ENDP			; std::fill<unsigned int *,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z PROC ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
	npad	3

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

$LL10@Fill@3:
	cmp	eax, DWORD PTR __Last$[esp]
	jne	SHORT $LN18@Fill@3
	cmp	ecx, DWORD PTR __Last$[esp+4]
	je	SHORT $LN40@Fill@3
$LN18@Fill@3:

; 3159 : 		*_First = _Val;

	mov	esi, 1
	shl	esi, cl
	cmp	BYTE PTR [edx], 0
	je	SHORT $LN27@Fill@3
	or	DWORD PTR [eax], esi
	jmp	SHORT $LN2@Fill@3
$LN27@Fill@3:
	not	esi
	and	DWORD PTR [eax], esi
$LN2@Fill@3:
	mov	ecx, DWORD PTR __First$[esp+4]
	mov	eax, DWORD PTR __First$[esp]
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN11@Fill@3
	inc	ecx
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LL10@Fill@3

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

$LN11@Fill@3:
	xor	ecx, ecx
	add	eax, 4
	mov	DWORD PTR __First$[esp+4], ecx
	mov	DWORD PTR __First$[esp], eax
	jmp	SHORT $LL10@Fill@3
$LN40@Fill@3:
	pop	esi

; 3160 : 	}

	ret	0
??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ENDP ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@2:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--, COMDAT
; _this$ = ecx

; 1589 : 		{	// predecrement

	mov	eax, ecx

; 1590 : 		_Dec();

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN4@operator@8
	dec	ecx
	mov	DWORD PTR [eax+4], ecx

; 1591 : 		return (*this);
; 1592 : 		}

	ret	0

; 1590 : 		_Dec();

$LN4@operator@8:
	add	DWORD PTR [eax], -4			; fffffffcH
	mov	DWORD PTR [eax+4], 31			; 0000001fH

; 1591 : 		return (*this);
; 1592 : 		}

	ret	0
??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned int *,unsigned int,unsigned int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@2
	pop	esi
$LN3@Fill_n@2:

; 3243 : 	}

	ret	0
??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned int *,unsigned int,unsigned int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@XZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::end
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VCustomOption@CvPreGame@@@std@@QAEPAVCustomOption@CvPreGame@@I@Z ; std::allocator<CvPreGame::CustomOption>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VCustomOption@CvPreGame@@@std@@QAEPAVCustomOption@CvPreGame@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VCustomOption@CvPreGame@@@std@@QAEPAVCustomOption@CvPreGame@@I@Z PROC ; std::allocator<CvPreGame::CustomOption>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@VCustomOption@CvPreGame@@@std@@YAPAVCustomOption@CvPreGame@@IPAV12@@Z ; std::_Allocate<CvPreGame::CustomOption>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@VCustomOption@CvPreGame@@@std@@QAEPAVCustomOption@CvPreGame@@I@Z ENDP ; std::allocator<CvPreGame::CustomOption>::allocate
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$?6VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; operator<<<CvPreGame::CustomOption>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T221977 = 12						; size = 4
_readFrom$ = 12						; size = 4
??$?6VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z PROC ; operator<<<CvPreGame::CustomOption>, COMDAT

; 198  : {

	push	ebx

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	ebx, DWORD PTR _saveTo$[esp]
	push	esi
	mov	esi, DWORD PTR _readFrom$[esp+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	push	edi
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T221977[esp+8]
	add	eax, edx
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR $T221977[esp+12], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	edi, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+4]
	cmp	esi, edi
	je	SHORT $LN34@operator@9
	npad	4
$LL22@operator@9:
	push	esi
	push	ebx
	call	??6CvPreGame@@YAAAVFDataStream@@AAV1@ABVCustomOption@0@@Z ; CvPreGame::operator<<
	add	esi, 68					; 00000044H
	add	esp, 8
	cmp	esi, edi
	jne	SHORT $LL22@operator@9
$LN34@operator@9:
	pop	edi
	pop	esi

; 200  : 	return saveTo;

	mov	eax, ebx
	pop	ebx

; 201  : }

	ret	0
??$?6VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ENDP ; operator<<<CvPreGame::CustomOption>
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>, COMDAT
; _this$ = ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Ucopy
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Ucopy:
	pop	edi
	mov	eax, esi
	pop	esi

; 1142 : 		}

	ret	12					; 0000000cH
??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@0AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@0AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@0AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPreGame::CustomOption> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@0AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPreGame::CustomOption> >
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	edx, eax
	shl	edx, 4
	add	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator+
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__unwindtable$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
$T222123 = 8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Vptr$222120 = 16					; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __First$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	6
$LL6@Uninit_cop@2:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$222120[ebp], esi
	mov	DWORD PTR $T222123[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@2
	push	edi
	mov	ecx, esi
	call	??0CustomOption@CvPreGame@@QAE@ABV01@@Z	; CvPreGame::CustomOption::CustomOption
$LN18@Uninit_cop@2:
	add	esi, 68					; 00000044H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	add	edi, 68					; 00000044H
	jmp	SHORT $LL6@Uninit_cop@2
__catch$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN29@Uninit_cop@2:
$LN4@Uninit_cop@2:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@Uninit_cop@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$222120[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222123[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvPreGame::CustomOption *,unsigned int,CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z
_TEXT	SEGMENT
$T222145 = -4						; size = 1
__Cat$222149 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvPreGame::CustomOption *,unsigned int,CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T222145[esp+4], 0
	mov	eax, DWORD PTR $T222145[esp+4]
	mov	ecx, DWORD PTR __Cat$222149[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPreGame::CustomOption *,unsigned int,CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvPreGame::CustomOption *,unsigned int,CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z ; stdext::_Unchecked_move_backward<CvPreGame::CustomOption *,CvPreGame::CustomOption *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z PROC ; stdext::_Unchecked_move_backward<CvPreGame::CustomOption *,CvPreGame::CustomOption *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	ebx, esi
	je	SHORT $LN17@Unchecked_
$LL12@Unchecked_:
	sub	esi, 68					; 00000044H
	sub	edi, 68					; 00000044H
	push	esi
	mov	ecx, edi
	call	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z ; CvPreGame::CustomOption::operator=
	cmp	esi, ebx
	jne	SHORT $LL12@Unchecked_
$LN17@Unchecked_:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<CvPreGame::CustomOption *,CvPreGame::CustomOption *>
_TEXT	ENDS
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
_TEXT	ENDS
PUBLIC	??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1786 : 		{	// construct with offset and pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1787 : 		}

	ret	4
??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC ; std::vector<bool,std::allocator<bool> >::max_size, COMDAT
; _this$ = ecx

; 2053 : 		const size_type _Maxsize = _Myvec.max_size();
; 2054 : 		return (_Maxsize < (size_type)(-1) / _VBITS
; 2055 : 			? _Maxsize * _VBITS : (size_type)(-1));

	or	eax, -1

; 2056 : 		}

	ret	0
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP ; std::vector<bool,std::allocator<bool> >::max_size
_TEXT	ENDS
PUBLIC	?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+
_TEXT	ENDS
PUBLIC	??D?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??D?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*, COMDAT
; _this$ = ecx

; 1572 : 		return (_Reft(*this));

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, 1
	shl	eax, cl
	and	eax, DWORD PTR [edx]
	neg	eax
	sbb	eax, eax
	neg	eax

; 1573 : 		}

	ret	0
??D?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0U1@@Z ; std::for_each<std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
$T222323 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Func$ = 28						; size = 8
??$for_each@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const > >, COMDAT

; 23   : 	{	// perform function for each element

	push	ecx
	push	ebx

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));
; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	ebx, DWORD PTR __Last$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+12]
	push	esi
	mov	esi, DWORD PTR __First$[esp+16]
	push	edi
	mov	edi, DWORD PTR __First$[esp+16]

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

$LL8@for_each@2:
	cmp	edi, ebx
	jne	SHORT $LN16@for_each@2
	cmp	esi, ebp
	je	SHORT $LN36@for_each@2
$LN16@for_each@2:

; 29   : 		_Func(*_ChkFirst);

	mov	ecx, esi
	mov	eax, 1
	shl	eax, cl
	lea	edx, DWORD PTR $T222323[esp+20]
	push	edx
	test	eax, DWORD PTR [edi]
	setne	cl
	mov	BYTE PTR $T222323[esp+24], cl
	mov	ecx, DWORD PTR __Func$[esp+20]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	cmp	esi, 31					; 0000001fH
	jae	SHORT $LN9@for_each@2

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	inc	esi
	jmp	SHORT $LL8@for_each@2
$LN9@for_each@2:
	xor	esi, esi
	add	edi, 4
	jmp	SHORT $LL8@for_each@2
$LN36@for_each@2:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	ecx, DWORD PTR __Func$[esp+16]
	mov	edx, DWORD PTR __Func$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	ebx

; 31   : 	}

	pop	ecx
	ret	0
??$for_each@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First$[esp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Dest$[esp+8]
	npad	2

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

$LL18@Copy_opt@3:
	mov	eax, DWORD PTR __First$[esp+4]
	cmp	eax, DWORD PTR __Last$[esp+4]
	jne	SHORT $LN26@Copy_opt@3
	cmp	ecx, DWORD PTR __Last$[esp+8]
	je	SHORT $LN62@Copy_opt@3
$LN26@Copy_opt@3:

; 2472 : 		*_Dest = *_First;

	mov	ebx, 1
	shl	ebx, cl
	mov	ecx, esi
	test	ebx, DWORD PTR [eax]
	mov	eax, 1
	je	SHORT $LN49@Copy_opt@3
	shl	eax, cl
	or	DWORD PTR [edx], eax
	jmp	SHORT $LN2@Copy_opt@3
$LN49@Copy_opt@3:
	shl	eax, cl
	not	eax
	and	DWORD PTR [edx], eax
$LN2@Copy_opt@3:
	mov	esi, DWORD PTR __Dest$[esp+8]
	mov	edx, DWORD PTR __Dest$[esp+4]
	cmp	esi, 31					; 0000001fH
	jae	SHORT $LN11@Copy_opt@3

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	inc	esi
	jmp	SHORT $LN63@Copy_opt@3
$LN11@Copy_opt@3:
	xor	esi, esi
	add	edx, 4
	mov	DWORD PTR __Dest$[esp+4], edx
$LN63@Copy_opt@3:
	mov	ecx, DWORD PTR __First$[esp+8]
	mov	DWORD PTR __Dest$[esp+8], esi
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN19@Copy_opt@3
	inc	ecx
	mov	DWORD PTR __First$[esp+8], ecx
	jmp	SHORT $LL18@Copy_opt@3
$LN19@Copy_opt@3:
	xor	ecx, ecx
	add	DWORD PTR __First$[esp+4], 4
	mov	DWORD PTR __First$[esp+8], ecx
	jmp	SHORT $LL18@Copy_opt@3
$LN62@Copy_opt@3:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax+4], esi
	pop	esi
	mov	DWORD PTR [eax], edx
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z PROC ; std::fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __Last$[esp-4]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+4]
	push	edx
	push	eax
	push	ecx
	call	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
	add	esp, 20					; 00000014H

; 3188 : 	}

	ret	0
??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ENDP ; std::fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z PROC ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@2:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ENDP ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--, COMDAT
; _this$ = ecx

; 1808 : 		{	// predecrement

	mov	eax, ecx

; 1809 : 		--*(_Mybase *)this;

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN6@operator@10
	dec	ecx
	mov	DWORD PTR [eax+4], ecx

; 1810 : 		return (*this);
; 1811 : 		}

	ret	0

; 1809 : 		--*(_Mybase *)this;

$LN6@operator@10:
	add	DWORD PTR [eax], -4			; fffffffcH
	mov	DWORD PTR [eax+4], 31			; 0000001fH

; 1810 : 		return (*this);
; 1811 : 		}

	ret	0
??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z PROC	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@4
	pop	esi
$LN7@unchecked_@4:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ENDP	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE_NI@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 63161283				; 03c3c3c3H
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@VCustomOption@CvPreGame@@@std@@YAPAVCustomOption@CvPreGame@@IPAV12@@Z ; std::_Allocate<CvPreGame::CustomOption>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	ecx, edi
	shl	ecx, 4
	add	ecx, edi
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@0AAV?$allocator@VCustomOption@CvPreGame@@@0@@Z ; std::_Destroy_range<std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@0AAV?$allocator@VCustomOption@CvPreGame@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@0AAV?$allocator@VCustomOption@CvPreGame@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPreGame::CustomOption> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@0AAV?$allocator@VCustomOption@CvPreGame@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPreGame::CustomOption> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z
_TEXT	SEGMENT
$T222726 = -4						; size = 1
__Cat$222731 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T222726[esp+4], 0
	mov	eax, DWORD PTR $T222726[esp+4]
	mov	ecx, DWORD PTR __Cat$222731[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV34@IABV34@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV34@IABV34@@Z
_TEXT	SEGMENT
$T222743 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$222747 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV34@IABV34@@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$222747[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T222743[esp+12], 0
	mov	eax, DWORD PTR $T222743[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPreGame::CustomOption *,unsigned int,CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, esi
	add	esp, 24					; 00000018H
	shl	ecx, 4
	add	ecx, esi
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV34@IABV34@@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Ufill
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@U_Undefined_move_tag@4@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@U_Undefined_move_tag@4@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T222761 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$222765 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@U_Undefined_move_tag@4@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$222765[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T222761[esp+4], 0
	mov	eax, DWORD PTR $T222761[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@U_Undefined_move_tag@4@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::begin, COMDAT
; _this$ = ecx

; 1985 : 		return (iterator(_VEC_ITER_BASE(_Myvec.begin())));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1986 : 		}

	ret	4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::end, COMDAT
; _this$ = ecx

; 1996 : 		iterator _Tmp = begin();

	mov	eax, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], 0

; 1997 : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jbe	SHORT $LN20@end@2

; 1998 : 			_Tmp += _Mysize;

	push	ecx
	mov	ecx, esi
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN20@end@2:

; 1999 : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 2000 : 		}

	ret	4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::end
_TEXT	ENDS
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z PROC ; std::vector<bool,std::allocator<bool> >::_Make_iter, COMDAT
; _this$ = ecx

; 2012 : 		iterator _Tmp = begin();

	mov	eax, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], 0

; 2013 : 		if (0 < _Mysize)

	cmp	DWORD PTR [ecx], 0
	jbe	SHORT $LN36@Make_iter

; 2014 : 			_Tmp += _Where - begin();

	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __Where$[esp]
	sub	edx, ecx
	sar	edx, 2
	shl	edx, 5
	add	edx, DWORD PTR __Where$[esp+4]
	mov	ecx, esi
	push	edx
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN36@Make_iter:

; 2015 : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 2016 : 		}

	ret	12					; 0000000cH
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
_TEXT	ENDS
PUBLIC	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; operator<<<bool>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z
_TEXT	SEGMENT
$T223171 = -8						; size = 8
$T223169 = -8						; size = 8
$T223184 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z PROC ; operator<<<bool>, COMDAT

; 198  : {

	sub	esp, 8
	push	ebx
	push	esi

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	esi, DWORD PTR _readFrom$[esp+12]
	mov	eax, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR _saveTo$[esp+16]
	lea	ecx, DWORD PTR $T223184[esp+16]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T223184[esp+20], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR [esi+8]
	mov	DWORD PTR $T223169[esp+20], ebx
	mov	DWORD PTR $T223169[esp+24], 0
	test	eax, eax
	jbe	SHORT $LN9@operator@11
	push	eax
	lea	ecx, DWORD PTR $T223169[esp+24]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN9@operator@11:
	mov	edx, DWORD PTR $T223169[esp+24]
	mov	ecx, DWORD PTR $T223169[esp+20]
	push	esi
	push	edi
	push	edx
	push	ecx
	xor	eax, eax
	push	eax
	lea	edx, DWORD PTR $T223171[esp+40]
	push	ebx
	push	edx
	call	??$for_each@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0U1@@Z ; std::for_each<std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const > >
	add	esp, 28					; 0000001cH

; 200  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 201  : }

	add	esp, 8
	ret	0
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z ENDP ; operator<<<bool>
_TEXT	ENDS
PUBLIC	??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T223270 = -4						; size = 1
__Cat$223276 = 8					; size = 1
$T223272 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z PROC ; std::copy<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 2587 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 2588 : 	return (_Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, 
; 2589 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$223276[esp]
	mov	edx, DWORD PTR $T223272[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T223270[esp+8], 0
	mov	eax, DWORD PTR $T223270[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+28]
	push	edx
	mov	edx, DWORD PTR __First$[esp+28]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
	add	esp, 40					; 00000028H
	mov	eax, esi
	pop	esi

; 2590 : 	}

	pop	ecx
	ret	0
??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ENDP ; std::copy<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	esi
	push	edi
$LL2@Copy_backw@3:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	esi, DWORD PTR __Last$[esp+4]
	mov	ecx, DWORD PTR __Last$[esp+8]
	cmp	DWORD PTR __First$[esp+4], esi
	jne	SHORT $LN9@Copy_backw@3
	cmp	DWORD PTR __First$[esp+8], ecx
	je	SHORT $LN61@Copy_backw@3
$LN9@Copy_backw@3:

; 2676 : 		*--_Dest = *--_Last;

	test	ecx, ecx
	je	SHORT $LN16@Copy_backw@3
	dec	ecx
	jmp	SHORT $LN62@Copy_backw@3
$LN16@Copy_backw@3:
	sub	esi, 4
	mov	DWORD PTR __Last$[esp+4], esi
	mov	ecx, 31					; 0000001fH
$LN62@Copy_backw@3:
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	eax, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR __Last$[esp+8], ecx
	test	edx, edx
	je	SHORT $LN30@Copy_backw@3
	dec	edx
	jmp	SHORT $LN63@Copy_backw@3
$LN30@Copy_backw@3:
	sub	eax, 4
	mov	DWORD PTR __Dest$[esp+4], eax
	mov	edx, 31					; 0000001fH
$LN63@Copy_backw@3:
	mov	edi, 1
	shl	edi, cl
	mov	DWORD PTR __Dest$[esp+8], edx
	mov	ecx, edx
	test	edi, DWORD PTR [esi]
	mov	esi, 1
	je	SHORT $LN48@Copy_backw@3
	shl	esi, cl
	or	DWORD PTR [eax], esi
	jmp	SHORT $LL2@Copy_backw@3
$LN48@Copy_backw@3:
	shl	esi, cl
	not	esi
	and	DWORD PTR [eax], esi
	jmp	SHORT $LL2@Copy_backw@3
$LN61@Copy_backw@3:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@2
	pop	esi
$LN9@Uninit_fil@2:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?Write@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z ; CvDllNetInitInfo::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4GameMode@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4TurnTimerTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4GameSpeedTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4CalendarTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4SeaLevelTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4ClimateTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4WorldSizeTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4StorageLocation@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdllnetinitinfo.cpp
;	COMDAT ?Write@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_kStream$ = 12						; size = 4
?Write@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z PROC	; CvDllNetInitInfo::Write, COMDAT

; 201  : {

	push	esi

; 202  : 	kStream << m_szLoadFileName;

	mov	esi, DWORD PTR _this$[esp]
	push	edi
	mov	edi, DWORD PTR _kStream$[esp+4]
	lea	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 203  : 	kStream << m_eLoadFileStorage;

	lea	ecx, DWORD PTR [esi+32]
	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4StorageLocation@@@Z ; operator<<
	add	esp, 8

; 204  : 	kStream << m_szMapScriptName;

	lea	edx, DWORD PTR [esi+36]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 205  : 	kStream << m_bIsEarthMap;

	lea	eax, DWORD PTR [esi+64]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 206  : 	kStream << m_bIsRandomMapScript;

	lea	ecx, DWORD PTR [esi+65]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 207  : 	kStream << m_bIsRandomWorldSize;

	lea	edx, DWORD PTR [esi+66]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 208  : 	kStream << m_bWBMapNoPlayers;

	lea	eax, DWORD PTR [esi+67]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 209  : 	kStream << m_eWorldSize;

	lea	ecx, DWORD PTR [esi+68]
	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4WorldSizeTypes@@@Z ; operator<<

; 210  : 	kStream << m_eClimate;

	lea	edx, DWORD PTR [esi+72]
	push	edx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4ClimateTypes@@@Z ; operator<<

; 211  : 	kStream << m_eSeaLevel;

	lea	eax, DWORD PTR [esi+76]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4SeaLevelTypes@@@Z ; operator<<

; 212  : 	kStream << m_eEra;

	lea	ecx, DWORD PTR [esi+80]
	push	ecx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z ; operator<<

; 213  : 	kStream << m_eCalendar;

	lea	edx, DWORD PTR [esi+84]
	push	edx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4CalendarTypes@@@Z ; operator<<
	add	esp, 40					; 00000028H

; 214  : 	kStream << m_iGameTurn;

	lea	eax, DWORD PTR [esi+88]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 215  : 	kStream << m_bGameStarted;

	lea	ecx, DWORD PTR [esi+92]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 216  : 	kStream << m_eGameSpeed;

	lea	edx, DWORD PTR [esi+96]
	push	edx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4GameSpeedTypes@@@Z ; operator<<

; 217  : 	kStream << m_eTurnTimerEnabled;

	lea	eax, DWORD PTR [esi+100]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4TurnTimerTypes@@@Z ; operator<<
	add	esp, 16					; 00000010H

; 218  : 	kStream << m_iTurnTimerTime;

	lea	ecx, DWORD PTR [esi+104]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 219  : 	kStream << m_szGameName;

	lea	edx, DWORD PTR [esi+108]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 220  : 	kStream << m_uiSyncRandSeed;

	lea	eax, DWORD PTR [esi+136]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 221  : 	kStream << m_uiMapRandSeed;

	lea	ecx, DWORD PTR [esi+140]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 222  : 	kStream << m_iNumVictories;

	lea	edx, DWORD PTR [esi+144]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 223  : 	kStream << m_abVictories;

	lea	eax, DWORD PTR [esi+148]
	push	eax
	push	edi
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; operator<<<bool>

; 224  : 	kStream << m_aGameOptions;

	lea	ecx, DWORD PTR [esi+168]
	push	ecx
	push	edi
	call	??$?6VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; operator<<<CvPreGame::CustomOption>

; 225  : 	kStream << m_aMapOptions;

	lea	edx, DWORD PTR [esi+184]
	push	edx
	push	edi
	call	??$?6VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; operator<<<CvPreGame::CustomOption>

; 226  : 	kStream << m_abMPOptions;

	lea	eax, DWORD PTR [esi+200]
	push	eax
	push	edi
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; operator<<<bool>
	add	esp, 32					; 00000020H

; 227  : 	kStream << m_iMaxTurns;

	lea	ecx, DWORD PTR [esi+220]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 228  : 	kStream << m_iPitbossTurnTime;

	lea	edx, DWORD PTR [esi+224]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 229  : 	kStream << m_iMaxCityElimination;

	lea	eax, DWORD PTR [esi+228]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 230  : 	kStream << m_iNumMinorCivs;

	lea	ecx, DWORD PTR [esi+232]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 231  : 	kStream << m_iNumAdvancedStartPoints;

	lea	edx, DWORD PTR [esi+236]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 232  : 	kStream << m_eMode;

	lea	eax, DWORD PTR [esi+240]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4GameMode@@@Z ; operator<<
	add	esp, 8

; 233  : 	kStream << m_bStatReporting;

	add	esi, 244				; 000000f4H
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	pop	edi

; 234  : 
; 235  : 	return true;

	mov	al, 1
	pop	esi

; 236  : }

	ret	8
?Write@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z ENDP	; CvDllNetInitInfo::Write
_TEXT	ENDS
PUBLIC	??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::clear
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXPAVCustomOption@CvPreGame@@0@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXPAVCustomOption@CvPreGame@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXPAVCustomOption@CvPreGame@@0@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXPAVCustomOption@CvPreGame@@0@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXXZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXXZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@0@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@0@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	ebp
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, DWORD PTR __First_arg$[esp+8]
	mov	ebp, ecx
	mov	DWORD PTR [eax], edi
	cmp	edi, esi
	je	SHORT $LN1@erase@2
	push	ebx

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ebx, DWORD PTR [ebp+8]
	cmp	esi, ebx
	je	SHORT $LN26@erase@2
	npad	1
$LL28@erase@2:
	push	esi
	mov	ecx, edi
	call	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z ; CvPreGame::CustomOption::operator=
	add	esi, 68					; 00000044H
	add	edi, 68					; 00000044H
	cmp	esi, ebx
	jne	SHORT $LL28@erase@2
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ebp+8], edi
	pop	ebx
$LN1@erase@2:
	pop	edi
	pop	esi
	pop	ebp

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@0@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::erase
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAVCustomOption@CvPreGame@@@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV23@00@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Ucopy<CvPreGame::CustomOption *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ucopy@PAVCustomOption@CvPreGame@@@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV23@00@Z
_TEXT	SEGMENT
$T223975 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$223979 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAVCustomOption@CvPreGame@@@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV23@00@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Ucopy<CvPreGame::CustomOption *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$223979[esp]
	mov	BYTE PTR $T223975[esp+4], 0
	mov	eax, DWORD PTR $T223975[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@PAVCustomOption@CvPreGame@@@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV23@00@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Ucopy<CvPreGame::CustomOption *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z
_TEXT	SEGMENT
$T224012 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$224016 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$224016[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T224012[esp+4], 0
	mov	eax, DWORD PTR $T224012[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
_TEXT	ENDS
PUBLIC	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
; Function compile flags: /Ogtpy
;	COMDAT ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T224042 = 8						; size = 4
__Size$ = 8						; size = 4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z PROC ; std::vector<bool,std::allocator<bool> >::_Trim, COMDAT
; _this$ = ecx

; 2360 : 		{	// trim base vector to exact length in bits

	push	ebx

; 2361 : 		if (max_size() < _Size)

	mov	ebx, DWORD PTR __Size$[esp]
	push	edi
	mov	edi, ecx
	cmp	ebx, -1
	jbe	SHORT $LN3@Trim

; 2362 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
$LN42@Trim:
$LN3@Trim:

; 2363 : 		size_type _Words = _Nw(_Size);
; 2364 : 
; 2365 : 		if (_Words < _Myvec.size())

	mov	eax, DWORD PTR [edi+12]
	sub	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [edi+4]
	push	esi
	lea	esi, DWORD PTR [ebx+31]
	shr	esi, 5
	sar	eax, 2
	cmp	esi, eax
	jae	SHORT $LN2@Trim

; 2366 : 			_Myvec.erase(_Myvec.begin() + _Words, _Myvec.end());

	mov	eax, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+8]
	push	eax
	lea	edx, DWORD PTR [edx+esi*4]
	push	edx
	lea	eax, DWORD PTR $T224042[esp+16]
	push	eax
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
$LN2@Trim:

; 2367 : 		_Mysize = _Size;

	mov	DWORD PTR [edi], ebx

; 2368 : 		_Size %= _VBITS;

	and	ebx, 31					; 0000001fH

; 2369 : 		if (0 < _Size)

	jbe	SHORT $LN40@Trim

; 2370 : 			_Myvec[_Words - 1] &= (_Vbase)((1 << _Size) - 1);

	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [ecx+esi*4-4]
	mov	edx, 1
	mov	ecx, ebx
	shl	edx, cl
	dec	edx
	and	DWORD PTR [eax], edx
$LN40@Trim:
	pop	esi
	pop	edi
	pop	ebx

; 2371 : 		}

	ret	4
$LN41@Trim:
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Trim
_TEXT	ENDS
PUBLIC	??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T224138 = -4						; size = 1
__Cat$224143 = 8					; size = 1
$T224140 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z PROC ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 2740 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 2741 : 	return _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 2742 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Cat$224143[esp]
	mov	edx, DWORD PTR $T224140[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T224138[esp+8], 0
	mov	eax, DWORD PTR $T224138[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+28]
	push	edx
	mov	edx, DWORD PTR __First$[esp+28]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
	add	esp, 40					; 00000028H
	mov	eax, esi
	pop	esi

; 2743 : 	}

	pop	ecx
	ret	0
??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ENDP ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@5
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@5:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@5
	pop	esi
$LN13@unchecked_@5:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	esi
	push	edi

; 564  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	$LN33@operator@12
	push	ebx

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ebx, DWORD PTR [edi+8]
	push	ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	eax, ebx
	sub	eax, ebp
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator@12

; 572  : 				clear();	// new sequence empty, erase existing sequence

	call	?clear@?$vector@IV?$allocator@I@std@@@std@@QAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::clear
	pop	ebp
	pop	ebx
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN8@operator@12:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
	sar	edx, 2
	cmp	eax, edx
	ja	SHORT $LN6@operator@12

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	push	ecx
	push	ebx
	push	ebp
	call	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::unchecked_copy<unsigned int *,unsigned int *>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	pop	ebp
	sar	eax, 2
	pop	ebx
	lea	edx, DWORD PTR [ecx+eax*4]
	pop	edi
	mov	DWORD PTR [esi+8], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN6@operator@12:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	ecx, ecx
	jne	SHORT $LN24@operator@12
	xor	ebx, ebx
	jmp	SHORT $LN25@operator@12
$LN24@operator@12:
	mov	ebx, DWORD PTR [esi+12]
	sub	ebx, ecx
	sar	ebx, 2
$LN25@operator@12:
	cmp	eax, ebx
	ja	SHORT $LN4@operator@12

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, ebp

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	push	ecx
	lea	ebx, DWORD PTR [eax+edx*4]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::unchecked_copy<unsigned int *,unsigned int *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	push	ebx
	mov	ecx, esi
	call	??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
	pop	ebp
	pop	ebx
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN4@operator@12:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	ecx, ecx
	je	SHORT $LN28@operator@12

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN28@operator@12:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	eax, DWORD PTR [edi+8]
	sub	eax, DWORD PTR [edi+4]
	mov	ecx, esi
	sar	eax, 2
	push	eax
	call	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
	test	al, al
	je	SHORT $LN32@operator@12

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
	mov	DWORD PTR [esi+8], eax
$LN32@operator@12:
	pop	ebp
	pop	ebx
$LN33@operator@12:
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
_TEXT	ENDS
PUBLIC	??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEXXZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T224368 = -4						; size = 4
?clear@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEXXZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T224368[esp+12]
	push	eax
	call	?erase@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@0@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::clear
_TEXT	ENDS
PUBLIC	??$_Umove@PAVCustomOption@CvPreGame@@@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV23@00@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Umove<CvPreGame::CustomOption *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAVCustomOption@CvPreGame@@@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV23@00@Z
_TEXT	SEGMENT
$T224449 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$224453 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAVCustomOption@CvPreGame@@@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV23@00@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Umove<CvPreGame::CustomOption *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$224453[esp]
	mov	BYTE PTR $T224449[esp+4], 0
	mov	eax, DWORD PTR $T224449[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAVCustomOption@CvPreGame@@@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV23@00@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Umove<CvPreGame::CustomOption *>
_TEXT	ENDS
PUBLIC	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 1903 : 		{	// construct empty vector

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 1904 : 		}

	ret	0
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
_TEXT	ENDS
PUBLIC	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 1957 : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 1958 : 		_Mysize = 0;

	mov	DWORD PTR [esi], 0

; 1959 : 		}

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN9@vector@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@vector@3:
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	pop	esi
	ret	0
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T225082 = -28						; size = 1
__First$ = -24						; size = 8
$T224639 = -16						; size = 8
__Next$ = -8						; size = 8
__Last$ = -8						; size = 8
__Cat$225086 = 8					; size = 1
$T225084 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Tmp$225205 = 12					; size = 8
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z PROC ; std::vector<bool,std::allocator<bool> >::erase, COMDAT
; _this$ = ecx

; 2221 : 		{	// erase [_First, _Last)

	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 2222 : 		iterator _First = _Make_iter(_First_arg);

	mov	ebp, DWORD PTR [edi]
	mov	ebx, DWORD PTR [edi+8]
	xor	esi, esi
	mov	DWORD PTR __First$[esp+44], ebx
	mov	DWORD PTR __First$[esp+48], esi
	cmp	ebp, esi
	jbe	SHORT $LN36@erase@3
	mov	eax, DWORD PTR __First_arg$[esp+40]
	sub	eax, ebx
	sar	eax, 2
	shl	eax, 5
	add	eax, DWORD PTR __First_arg$[esp+44]
	lea	ecx, DWORD PTR __First$[esp+44]
	push	eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN36@erase@3:

; 2223 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	DWORD PTR __Last$[esp+44], ebx
	mov	DWORD PTR __Last$[esp+48], esi
	cmp	ebp, esi
	jbe	SHORT $LN71@erase@3
	mov	ecx, DWORD PTR __Last_arg$[esp+40]
	sub	ecx, ebx
	sar	ecx, 2
	shl	ecx, 5
	add	ecx, DWORD PTR __Last_arg$[esp+44]
	push	ecx
	lea	ecx, DWORD PTR __Last$[esp+48]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN71@erase@3:

; 2224 : 		size_type _Off = _First - begin();

	mov	esi, DWORD PTR __First$[esp+44]
	sub	esi, ebx
	sar	esi, 2
	shl	esi, 5
	add	esi, DWORD PTR __First$[esp+48]

; 2225 : 
; 2226 :  #if _HAS_ITERATOR_DEBUGGING
; 2227 : 		if (_Last < _First || end() < _Last)
; 2228 : 			_DEBUG_ERROR("vector<bool> erase iterator outside range");
; 2229 : 		iterator _Next = std::copy(_Last, end(), _First);
; 2230 : 		size_type _Newsize = _Next - begin();
; 2231 : 		_Orphan_range(_Newsize, _Mysize);
; 2232 : 		_Trim(_Newsize);
; 2233 : 
; 2234 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 2235 : 		iterator _Next = std::copy(_Last, end(), _First);

	mov	DWORD PTR $T224639[esp+44], ebx
	mov	DWORD PTR $T224639[esp+48], 0
	test	ebp, ebp
	jbe	SHORT $LN108@erase@3
	push	ebp
	lea	ecx, DWORD PTR $T224639[esp+48]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN108@erase@3:
	mov	eax, DWORD PTR __Cat$225086[esp+40]
	mov	ecx, DWORD PTR $T225084[esp+40]
	mov	BYTE PTR $T225082[esp+44], 0
	mov	edx, DWORD PTR $T225082[esp+44]
	push	edx
	mov	edx, DWORD PTR __First$[esp+52]
	push	eax
	mov	eax, DWORD PTR __First$[esp+52]
	push	ecx
	mov	ecx, DWORD PTR $T224639[esp+60]
	push	edx
	mov	edx, DWORD PTR $T224639[esp+60]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+68]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+68]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR __Next$[esp+80]
	push	edx
	call	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>

; 2236 : 		_Trim(_Next - begin());

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR __Next$[esp+84]
	sub	ecx, eax
	sar	ecx, 2
	shl	ecx, 5
	add	ecx, DWORD PTR __Next$[esp+88]
	add	esp, 40					; 00000028H
	push	ecx
	mov	ecx, edi
	call	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim

; 2237 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2238 : 
; 2239 : 		return (begin() + _Off);

	mov	edi, DWORD PTR [edi+8]
	xor	eax, eax
	push	esi
	lea	ecx, DWORD PTR __Tmp$225205[esp+44]
	mov	DWORD PTR __Tmp$225205[esp+44], edi
	mov	DWORD PTR __Tmp$225205[esp+48], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+40]
	mov	edx, DWORD PTR __Tmp$225205[esp+40]
	mov	ecx, DWORD PTR __Tmp$225205[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebx

; 2240 : 		}

	add	esp, 28					; 0000001cH
	ret	20					; 00000014H
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ENDP ; std::vector<bool,std::allocator<bool> >::erase
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
_TEXT	ENDS
PUBLIC	??4?$vector@_NV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<bool,std::allocator<bool> >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$vector@_NV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4?$vector@_NV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<bool,std::allocator<bool> >::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR [esi], ecx
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
	mov	eax, esi
	pop	esi
	ret	4
??4?$vector@_NV?$allocator@_N@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<bool,std::allocator<bool> >::operator=
_TEXT	ENDS
PUBLIC	??_7CvDllNetInitInfo@@6B@			; CvDllNetInitInfo::`vftable'
PUBLIC	??1CvDllNetInitInfo@@QAE@XZ			; CvDllNetInitInfo::~CvDllNetInitInfo
PUBLIC	??_R4CvDllNetInitInfo@@6B@			; CvDllNetInitInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvDllNetInitInfo@@@8			; CvDllNetInitInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvDllNetInitInfo@@8			; CvDllNetInitInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvDllNetInitInfo@@8			; CvDllNetInitInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvDllNetInitInfo@@8		; CvDllNetInitInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Destroy@CvDllNetInitInfo@@EAGXXZ		; CvDllNetInitInfo::Destroy
PUBLIC	?Read@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z	; CvDllNetInitInfo::Read
;	COMDAT ??_R1A@?0A@EA@CvDllNetInitInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvDllNetInitInfo@@8 DD FLAT:??_R0?AVCvDllNetInitInfo@@@8 ; CvDllNetInitInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvDllNetInitInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvDllNetInitInfo@@8
rdata$r	SEGMENT
??_R2CvDllNetInitInfo@@8 DD FLAT:??_R1A@?0A@EA@CvDllNetInitInfo@@8 ; CvDllNetInitInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ICvNetInitInfo1@@8
	DD	FLAT:??_R1A@?0A@EA@ICvUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3CvDllNetInitInfo@@8
rdata$r	SEGMENT
??_R3CvDllNetInitInfo@@8 DD 00H				; CvDllNetInitInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvDllNetInitInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvDllNetInitInfo@@@8
_DATA	SEGMENT
??_R0?AVCvDllNetInitInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvDllNetInitInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvDllNetInitInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvDllNetInitInfo@@6B@
rdata$r	SEGMENT
??_R4CvDllNetInitInfo@@6B@ DD 00H			; CvDllNetInitInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvDllNetInitInfo@@@8
	DD	FLAT:??_R3CvDllNetInitInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvDllNetInitInfo@@6B@
CONST	SEGMENT
??_7CvDllNetInitInfo@@6B@ DD FLAT:??_R4CvDllNetInitInfo@@6B@ ; CvDllNetInitInfo::`vftable'
	DD	FLAT:?QueryInterface@CvDllNetInitInfo@@UAGPAXU_GUID@@@Z
	DD	FLAT:?Destroy@CvDllNetInitInfo@@EAGXXZ
	DD	FLAT:?GetDebugString@CvDllNetInitInfo@@UAGPBDXZ
	DD	FLAT:?Read@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z
	DD	FLAT:?Write@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z
	DD	FLAT:?Commit@CvDllNetInitInfo@@UAG_NXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvDllNetInitInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$1
__ehfuncinfo$??1CvDllNetInitInfo@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvDllNetInitInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdllnetinitinfo.cpp
xdata$x	ENDS
;	COMDAT ??1CvDllNetInitInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvDllNetInitInfo@@QAE@XZ PROC			; CvDllNetInitInfo::~CvDllNetInitInfo, COMDAT
; _this$ = ecx

; 59   : {

	push	-1
	push	__ehhandler$??1CvDllNetInitInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvDllNetInitInfo@@6B@

; 60   : }

	xor	ebx, ebx
	mov	DWORD PTR [esi+200], ebx
	mov	eax, DWORD PTR [esi+208]
	mov	DWORD PTR __$EHRec$[esp+32], 1
	cmp	eax, ebx
	je	SHORT $LN17@CvDllNetIn
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@CvDllNetIn:
	mov	DWORD PTR [esi+208], ebx
	mov	DWORD PTR [esi+212], ebx
	mov	DWORD PTR [esi+216], ebx
	mov	eax, DWORD PTR [esi+188]
	cmp	eax, ebx
	je	SHORT $LN26@CvDllNetIn
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@CvDllNetIn:
	mov	DWORD PTR [esi+188], ebx
	mov	DWORD PTR [esi+192], ebx
	mov	DWORD PTR [esi+196], ebx
	mov	eax, DWORD PTR [esi+172]
	cmp	eax, ebx
	je	SHORT $LN33@CvDllNetIn
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN33@CvDllNetIn:
	mov	DWORD PTR [esi+172], ebx
	mov	DWORD PTR [esi+176], ebx
	mov	DWORD PTR [esi+180], ebx
	mov	DWORD PTR [esi+148], ebx
	mov	eax, DWORD PTR [esi+156]
	cmp	eax, ebx
	je	SHORT $LN42@CvDllNetIn
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN42@CvDllNetIn:
	lea	ecx, DWORD PTR [esi+108]
	mov	DWORD PTR [esi+156], ebx
	mov	DWORD PTR [esi+160], ebx
	mov	DWORD PTR [esi+164], ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+32], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvDllNetInitInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvDllNetInitInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvDllNetInitInfo@@QAE@XZ ENDP			; CvDllNetInitInfo::~CvDllNetInitInfo
PUBLIC	??_GCvDllNetInitInfo@@QAEPAXI@Z			; CvDllNetInitInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvDllNetInitInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvDllNetInitInfo@@QAEPAXI@Z PROC			; CvDllNetInitInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvDllNetInitInfo@@QAE@XZ		; CvDllNetInitInfo::~CvDllNetInitInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@4
	push	esi
	call	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
	add	esp, 4
$LN6@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvDllNetInitInfo@@QAEPAXI@Z ENDP			; CvDllNetInitInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??4?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??4?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T225517 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	esi
	push	edi

; 564  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	$LN47@operator@13

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	push	ebp
	sar	edx, 5
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH
	add	ebp, edx
	jne	SHORT $LN8@operator@13

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T225517[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@0@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::erase
	pop	ebp
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN8@operator@13:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR [esi+8]
	push	ebx
	mov	ebx, DWORD PTR [esi+4]
	sub	ecx, ebx
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ebp, ecx
	ja	SHORT $LN6@operator@13

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	eax, DWORD PTR [edi+8]
	push	ebx
	push	eax
	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	??$unchecked_copy@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z ; stdext::unchecked_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR [esi+4]
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	shl	ecx, 4
	pop	ebx
	add	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*4]
	pop	ebp

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN6@operator@13:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	ebx, ebx
	jne	SHORT $LN38@operator@13
	xor	eax, eax
	jmp	SHORT $LN39@operator@13
$LN38@operator@13:
	mov	edx, DWORD PTR [esi+12]
	sub	edx, ebx
	mov	eax, 2021161081				; 78787879H
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$LN39@operator@13:
	cmp	ebp, eax
	ja	SHORT $LN4@operator@13

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, DWORD PTR [edi+4]
	mov	edx, ecx
	shl	edx, 4
	add	edx, ecx
	lea	ebp, DWORD PTR [eax+edx*4]

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	push	ebx
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z ; stdext::unchecked_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	push	ebp
	mov	ecx, esi
	call	??$_Ucopy@PAVCustomOption@CvPreGame@@@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV23@00@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Ucopy<CvPreGame::CustomOption *>
	pop	ebx
	pop	ebp
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN4@operator@13:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN42@operator@13

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN42@operator@13:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	mov	ecx, esi
	call	?_Buy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE_NI@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Buy
	test	al, al
	je	SHORT $LN46@operator@13

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	??$_Ucopy@PAVCustomOption@CvPreGame@@@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV23@00@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Ucopy<CvPreGame::CustomOption *>
	mov	DWORD PTR [esi+8], eax
$LN46@operator@13:
	pop	ebx
	pop	ebp
$LN47@operator@13:
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
??4?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator=
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$2
__catchsym$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$0
__unwindtable$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z
_TEXT	SEGMENT
__Tmp$220032 = -156					; size = 68
__Tmp$220022 = -88					; size = 68
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$225776 = 8					; size = 1
__Cat$225704 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$220007 = 12					; size = 4
__Count$ = 12						; size = 4
tv493 = 16						; size = 4
$T225772 = 16						; size = 1
$T225700 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	eax, eax
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR __Capacity$[ebp], eax
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Capacity$[ebp], eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	ecx, ebx
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, 63161283				; 03c3c3c3H
	sub	ecx, eax
	cmp	ecx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Xlen
$LN87@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	add	eax, edi
	cmp	ecx, eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	edx, ecx
	shr	edx, 1
	mov	ebx, 63161283				; 03c3c3c3H
	sub	ebx, edx
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, edx
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, eax
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], eax
	mov	ecx, eax
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@VCustomOption@CvPreGame@@@std@@YAPAVCustomOption@CvPreGame@@IPAV12@@Z ; std::_Allocate<CvPreGame::CustomOption>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 2021161081				; 78787879H
	imul	edx
	sar	edx, 5
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	add	esp, 8
	mov	eax, ebx
	shl	eax, 4
	push	edx
	mov	DWORD PTR __Newvec$220007[ebp], ecx
	add	eax, ebx
	lea	ecx, DWORD PTR [ecx+eax*4]
	push	edi
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV34@IABV34@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Cat$225704[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T225700[ebp], 0
	mov	edx, DWORD PTR $T225700[ebp]
	push	edx
	mov	edx, DWORD PTR __Newvec$220007[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Where$[ebp]
	push	esi
	push	edx
	push	ecx
	push	eax
	call	??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Newvec$220007[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	ebx, edi
	mov	edx, ebx
	shl	edx, 4
	add	edx, ebx
	add	esp, 24					; 00000018H
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	BYTE PTR $T225772[ebp], 0
	mov	edx, DWORD PTR $T225772[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$225776[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN81@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	edx, eax
	shl	edx, 4
	add	edx, eax
	mov	eax, DWORD PTR __Newvec$220007[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, edi
	shl	edx, 4
	add	edx, edi
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$220007[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n:
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	sub	ebx, DWORD PTR __Where$[ebp]
	mov	eax, 2021161081				; 78787879H
	imul	ebx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$220022[ebp]
	call	??0CustomOption@CvPreGame@@QAE@ABV01@@Z	; CvPreGame::CustomOption::CustomOption

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [esi+8]
	mov	ebx, edi
	shl	ebx, 4
	add	ebx, edi
	add	ebx, ebx
	add	ebx, ebx
	lea	edx, DWORD PTR [ebx+eax]
	push	edx
	push	ecx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAVCustomOption@CvPreGame@@@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV23@00@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Umove<CvPreGame::CustomOption *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR __Tmp$220022[ebp]
	push	edx
	mov	edx, ecx
	sub	edx, DWORD PTR __Where$[ebp]
	mov	eax, 2021161081				; 78787879H
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV34@IABV34@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebx
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$220022[ebp]
	push	ecx
	sub	esi, ebx
	push	esi
	push	edx
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??$fill@PAVCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@0ABV12@@Z ; std::fill<CvPreGame::CustomOption *,CvPreGame::CustomOption>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$220032[ebp]
	call	??0CustomOption@CvPreGame@@QAE@ABV01@@Z	; CvPreGame::CustomOption::CustomOption

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR [esi+8]

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ebx, edi
	shl	ebx, 4
	add	ebx, edi
	add	ebx, ebx
	push	eax
	mov	edi, eax
	add	ebx, ebx
	push	eax
	sub	edi, ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR tv493[ebp], eax
	call	??$_Umove@PAVCustomOption@CvPreGame@@@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEPAVCustomOption@CvPreGame@@PAV23@00@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Umove<CvPreGame::CustomOption *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv493[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ecx
	push	edi
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z ; stdext::_Unchecked_move_backward<CvPreGame::CustomOption *,CvPreGame::CustomOption *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$220032[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	ebx, eax
	push	ebx
	push	eax
	call	??$fill@PAVCustomOption@CvPreGame@@V12@@std@@YAXPAVCustomOption@CvPreGame@@0ABV12@@Z ; std::fill<CvPreGame::CustomOption *,CvPreGame::CustomOption>
	add	esp, 24					; 00000018H
$LN1@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Insert_n
PUBLIC	?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<bool,std::allocator<bool> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T225811 = -8						; size = 8
$T225808 = -8						; size = 8
?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ PROC ; std::vector<bool,std::allocator<bool> >::clear, COMDAT
; _this$ = ecx

; 2243 : 		{	// erase all elements

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 2244 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR [esi+8]
	mov	DWORD PTR $T225808[esp+16], edi
	mov	DWORD PTR $T225808[esp+20], 0
	test	eax, eax
	jbe	SHORT $LN20@clear@2
	push	eax
	lea	ecx, DWORD PTR $T225808[esp+20]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN20@clear@2:
	mov	ecx, DWORD PTR $T225808[esp+20]
	mov	edx, DWORD PTR $T225808[esp+16]
	push	ecx
	push	edx
	xor	eax, eax
	push	eax
	push	edi
	lea	eax, DWORD PTR $T225811[esp+32]
	push	eax
	mov	ecx, esi
	call	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
	pop	edi
	pop	esi

; 2245 : 		}

	add	esp, 8
	ret	0
?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::clear
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$215581 = 16					; size = 4
__Tmp$215571 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@2
$LN29@Insert_n@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n@2
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN64@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$215571[esp+16], edx
	jae	SHORT $LN3@Insert_n@2
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215571[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215571[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAII@std@@YAXPAI0ABI@Z		; std::fill<unsigned int *,unsigned int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$215581[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAII@std@@YAXPAI0ABI@Z		; std::fill<unsigned int *,unsigned int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n@2:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n@2:
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
_TEXT	ENDS
PUBLIC	??0CvDllNetInitInfo@@QAE@XZ			; CvDllNetInitInfo::CvDllNetInitInfo
EXTRN	?gameMode@CvPreGame@@YA?AW4GameMode@@XZ:PROC	; CvPreGame::gameMode
EXTRN	?advancedStartPoints@CvPreGame@@YAHXZ:PROC	; CvPreGame::advancedStartPoints
EXTRN	?numMinorCivs@CvPreGame@@YAHXZ:PROC		; CvPreGame::numMinorCivs
EXTRN	?maxCityElimination@CvPreGame@@YAHXZ:PROC	; CvPreGame::maxCityElimination
EXTRN	?maxTurns@CvPreGame@@YAHXZ:PROC			; CvPreGame::maxTurns
EXTRN	?multiplayerOptions@CvPreGame@@YAABV?$vector@_NV?$allocator@_N@std@@@std@@XZ:PROC ; CvPreGame::multiplayerOptions
EXTRN	?GetMapOptions@CvPreGame@@YAABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@XZ:PROC ; CvPreGame::GetMapOptions
EXTRN	?GetGameOptions@CvPreGame@@YAABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@XZ:PROC ; CvPreGame::GetGameOptions
EXTRN	?victories@CvPreGame@@YAABV?$vector@_NV?$allocator@_N@std@@@std@@XZ:PROC ; CvPreGame::victories
EXTRN	?pitBossTurnTime@CvPreGame@@YAHXZ:PROC		; CvPreGame::pitBossTurnTime
EXTRN	?randomWorldSize@CvPreGame@@YA_NXZ:PROC		; CvPreGame::randomWorldSize
EXTRN	?randomMapScript@CvPreGame@@YA_NXZ:PROC		; CvPreGame::randomMapScript
EXTRN	?loadFileStorage@CvPreGame@@YA?AW4StorageLocation@@XZ:PROC ; CvPreGame::loadFileStorage
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$??0CvDllNetInitInfo@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0CvDllNetInitInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvDllNetInitInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdllnetinitinfo.cpp
xdata$x	ENDS
;	COMDAT ??0CvDllNetInitInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvDllNetInitInfo@@QAE@XZ PROC			; CvDllNetInitInfo::CvDllNetInitInfo, COMDAT
; _this$ = ecx

; 15   : {

	push	-1
	push	__ehhandler$??0CvDllNetInitInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvDllNetInitInfo@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ebx, ebx
	lea	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR __$EHRec$[esp+40], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+108]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR [esi+148], ebx
	mov	DWORD PTR [esi+156], ebx
	mov	DWORD PTR [esi+160], ebx
	mov	DWORD PTR [esi+164], ebx
	lea	edi, DWORD PTR [esi+168]
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi+8], ebx
	mov	DWORD PTR [edi+12], ebx
	lea	ebp, DWORD PTR [esi+184]
	mov	DWORD PTR [ebp+4], ebx
	mov	DWORD PTR [ebp+8], ebx
	mov	DWORD PTR [ebp+12], ebx
	mov	DWORD PTR [esi+200], ebx
	mov	DWORD PTR [esi+208], ebx
	mov	DWORD PTR [esi+212], ebx
	mov	DWORD PTR [esi+216], ebx
	mov	BYTE PTR __$EHRec$[esp+40], 6
	mov	DWORD PTR [esi+760], 1

; 16   : 	m_szLoadFileName = CvPreGame::loadFileName();

	call	?loadFileName@CvPreGame@@YAABVCvString@@XZ ; CvPreGame::loadFileName
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 17   : 	m_eLoadFileStorage = CvPreGame::loadFileStorage();

	call	?loadFileStorage@CvPreGame@@YA?AW4StorageLocation@@XZ ; CvPreGame::loadFileStorage
	mov	DWORD PTR [esi+32], eax

; 18   : 	m_szMapScriptName = CvPreGame::mapScriptName();

	call	?mapScriptName@CvPreGame@@YAABVCvString@@XZ ; CvPreGame::mapScriptName
	push	eax
	lea	ecx, DWORD PTR [esi+36]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 19   : 	m_bIsEarthMap = false;

	mov	BYTE PTR [esi+64], bl

; 20   : 	m_bIsRandomMapScript = CvPreGame::randomMapScript();

	call	?randomMapScript@CvPreGame@@YA_NXZ	; CvPreGame::randomMapScript
	mov	BYTE PTR [esi+65], al

; 21   : 	m_bIsRandomWorldSize = CvPreGame::randomWorldSize();

	call	?randomWorldSize@CvPreGame@@YA_NXZ	; CvPreGame::randomWorldSize
	mov	BYTE PTR [esi+66], al

; 22   : 	m_bWBMapNoPlayers = CvPreGame::mapNoPlayers();

	call	?mapNoPlayers@CvPreGame@@YA_NXZ		; CvPreGame::mapNoPlayers
	mov	BYTE PTR [esi+67], al

; 23   : 	m_eWorldSize = CvPreGame::worldSize();

	call	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ ; CvPreGame::worldSize
	mov	DWORD PTR [esi+68], eax

; 24   : 	m_eClimate = CvPreGame::climate();

	call	?climate@CvPreGame@@YA?AW4ClimateTypes@@XZ ; CvPreGame::climate
	mov	DWORD PTR [esi+72], eax

; 25   : 	m_eSeaLevel = CvPreGame::seaLevel();

	call	?seaLevel@CvPreGame@@YA?AW4SeaLevelTypes@@XZ ; CvPreGame::seaLevel
	mov	DWORD PTR [esi+76], eax

; 26   : 	m_eEra = CvPreGame::era();

	call	?era@CvPreGame@@YA?AW4EraTypes@@XZ	; CvPreGame::era
	mov	DWORD PTR [esi+80], eax

; 27   : 	m_eCalendar = CvPreGame::calendar();

	call	?calendar@CvPreGame@@YA?AW4CalendarTypes@@XZ ; CvPreGame::calendar
	mov	DWORD PTR [esi+84], eax

; 28   : 	m_iGameTurn = CvPreGame::gameTurn();

	call	?gameTurn@CvPreGame@@YAHXZ		; CvPreGame::gameTurn
	mov	DWORD PTR [esi+88], eax

; 29   : 	m_bGameStarted = CvPreGame::gameStarted();

	call	?gameStarted@CvPreGame@@YA_NXZ		; CvPreGame::gameStarted
	mov	BYTE PTR [esi+92], al

; 30   : 	m_eGameSpeed = CvPreGame::gameSpeed();

	call	?gameSpeed@CvPreGame@@YA?AW4GameSpeedTypes@@XZ ; CvPreGame::gameSpeed
	mov	DWORD PTR [esi+96], eax

; 31   : 	m_eTurnTimerEnabled = CvPreGame::turnTimer();

	call	?turnTimer@CvPreGame@@YA?AW4TurnTimerTypes@@XZ ; CvPreGame::turnTimer
	mov	DWORD PTR [esi+100], eax

; 32   : 	m_iTurnTimerTime = CvPreGame::pitBossTurnTime();

	call	?pitBossTurnTime@CvPreGame@@YAHXZ	; CvPreGame::pitBossTurnTime
	mov	DWORD PTR [esi+104], eax

; 33   : 	m_szGameName = CvPreGame::gameName();

	call	?gameName@CvPreGame@@YAABVCvString@@XZ	; CvPreGame::gameName
	push	eax
	lea	ecx, DWORD PTR [esi+108]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 34   : 	m_uiSyncRandSeed = CvPreGame::syncRandomSeed();

	call	?syncRandomSeed@CvPreGame@@YAIXZ	; CvPreGame::syncRandomSeed
	mov	DWORD PTR [esi+136], eax

; 35   : 	m_uiMapRandSeed = CvPreGame::mapRandomSeed();

	call	?mapRandomSeed@CvPreGame@@YAIXZ		; CvPreGame::mapRandomSeed
	mov	DWORD PTR [esi+140], eax

; 36   : 
; 37   : 	m_abVictories = CvPreGame::victories();

	call	?victories@CvPreGame@@YAABV?$vector@_NV?$allocator@_N@std@@@std@@XZ ; CvPreGame::victories
	mov	ecx, DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR [esi+148], ecx
	push	eax
	lea	ecx, DWORD PTR [esi+152]
	call	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=

; 38   : 
; 39   : 	m_aGameOptions = CvPreGame::GetGameOptions();

	call	?GetGameOptions@CvPreGame@@YAABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@XZ ; CvPreGame::GetGameOptions
	push	eax
	mov	ecx, edi
	call	??4?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator=

; 40   : 	m_aMapOptions = CvPreGame::GetMapOptions();

	call	?GetMapOptions@CvPreGame@@YAABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@XZ ; CvPreGame::GetMapOptions
	push	eax
	mov	ecx, ebp
	call	??4?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator=

; 41   : 	m_abMPOptions = CvPreGame::multiplayerOptions();

	call	?multiplayerOptions@CvPreGame@@YAABV?$vector@_NV?$allocator@_N@std@@@std@@XZ ; CvPreGame::multiplayerOptions
	mov	edx, DWORD PTR [eax]
	add	eax, 4
	push	eax
	lea	ecx, DWORD PTR [esi+204]
	mov	DWORD PTR [esi+200], edx
	call	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=

; 42   : 
; 43   : 	m_iMaxTurns = CvPreGame::maxTurns();

	call	?maxTurns@CvPreGame@@YAHXZ		; CvPreGame::maxTurns
	mov	DWORD PTR [esi+220], eax

; 44   : 	m_iMaxCityElimination = CvPreGame::maxCityElimination();

	call	?maxCityElimination@CvPreGame@@YAHXZ	; CvPreGame::maxCityElimination
	mov	DWORD PTR [esi+228], eax

; 45   : 	m_iNumMinorCivs = CvPreGame::numMinorCivs();

	call	?numMinorCivs@CvPreGame@@YAHXZ		; CvPreGame::numMinorCivs
	mov	DWORD PTR [esi+232], eax

; 46   : 	m_iNumAdvancedStartPoints = CvPreGame::advancedStartPoints();

	call	?advancedStartPoints@CvPreGame@@YAHXZ	; CvPreGame::advancedStartPoints
	mov	DWORD PTR [esi+236], eax

; 47   : 	m_eMode = CvPreGame::gameMode();

	call	?gameMode@CvPreGame@@YA?AW4GameMode@@XZ	; CvPreGame::gameMode

; 48   : 
; 49   : #ifdef AUI_WARNING_FIXES
; 50   : 	m_iNumVictories = 0;
; 51   : 	m_iPitbossTurnTime = m_iTurnTimerTime;
; 52   : 	m_bStatReporting = false;
; 53   : #endif
; 54   : 
; 55   : 	ZeroMemory(m_szDebugString, sizeof m_szDebugString);

	push	512					; 00000200H
	mov	DWORD PTR [esi+240], eax
	lea	eax, DWORD PTR [esi+245]
	push	ebx
	push	eax
	call	_memset

; 56   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	add	esp, 12					; 0000000cH
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	jmp	??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	jmp	??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__ehhandler$??0CvDllNetInitInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvDllNetInitInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvDllNetInitInfo@@QAE@XZ ENDP			; CvDllNetInitInfo::CvDllNetInitInfo
PUBLIC	?DecrementReference@CvDllNetInitInfo@@QAEIXZ	; CvDllNetInitInfo::DecrementReference
; Function compile flags: /Ogtpy
;	COMDAT ?DecrementReference@CvDllNetInitInfo@@QAEIXZ
_TEXT	SEGMENT
?DecrementReference@CvDllNetInitInfo@@QAEIXZ PROC	; CvDllNetInitInfo::DecrementReference, COMDAT
; _this$ = ecx

; 81   : {

	push	esi
	mov	esi, ecx

; 82   : 	if(m_uiRefCount == 1)

	mov	eax, DWORD PTR [esi+760]
	cmp	eax, 1
	jne	SHORT $LN2@DecrementR

; 83   : 	{
; 84   : 		delete this;

	call	??1CvDllNetInitInfo@@QAE@XZ		; CvDllNetInitInfo::~CvDllNetInitInfo
	push	esi
	call	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
	add	esp, 4

; 85   : 		return 0;

	xor	eax, eax
	pop	esi

; 90   : 		return m_uiRefCount;
; 91   : 	}
; 92   : }

	ret	0
$LN2@DecrementR:

; 86   : 	}
; 87   : 	else
; 88   : 	{
; 89   : 		--m_uiRefCount;

	dec	eax
	mov	DWORD PTR [esi+760], eax
	pop	esi

; 90   : 		return m_uiRefCount;
; 91   : 	}
; 92   : }

	ret	0
?DecrementReference@CvDllNetInitInfo@@QAEIXZ ENDP	; CvDllNetInitInfo::DecrementReference
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Destroy@CvDllNetInitInfo@@EAGXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Destroy@CvDllNetInitInfo@@EAGXXZ PROC			; CvDllNetInitInfo::Destroy, COMDAT

; 100  : {

	push	esi

; 101  : 	DecrementReference();

	mov	esi, DWORD PTR _this$[esp]
	mov	eax, DWORD PTR [esi+760]
	cmp	eax, 1
	jne	SHORT $LN4@Destroy
	mov	ecx, esi
	call	??1CvDllNetInitInfo@@QAE@XZ		; CvDllNetInitInfo::~CvDllNetInitInfo
	push	esi
	call	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
	add	esp, 4
	pop	esi

; 102  : }

	ret	4

; 101  : 	DecrementReference();

$LN4@Destroy:
	dec	eax
	mov	DWORD PTR [esi+760], eax
	pop	esi

; 102  : }

	ret	4
?Destroy@CvDllNetInitInfo@@EAGXXZ ENDP			; CvDllNetInitInfo::Destroy
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@ABVCustomOption@CvPreGame@@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@ABVCustomOption@CvPreGame@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@ABVCustomOption@CvPreGame@@@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	mov	edx, esi
	shl	edx, 4
	add	edx, esi
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@ABVCustomOption@CvPreGame@@@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::insert
_TEXT	ENDS
PUBLIC	?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z
_TEXT	SEGMENT
$T226880 = 8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::resize, COMDAT
; _this$ = ecx

; 718  : 		if (size() < _Newsize)

	mov	edx, DWORD PTR __Newsize$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	mov	eax, esi
	sub	eax, edi
	sar	eax, 2
	cmp	edx, eax
	jbe	SHORT $LN36@resize

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	edi, DWORD PTR __Val$[esp+4]
	push	edi
	sub	edx, eax
	push	edx
	push	esi
	call	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
	pop	edi
	pop	esi

; 722  : 		}

	ret	8
$LN36@resize:

; 720  : 		else if (_Newsize < size())

	jae	SHORT $LN1@resize

; 721  : 			erase(begin() + _Newsize, end());

	lea	eax, DWORD PTR [edi+edx*4]
	push	esi
	push	eax
	lea	eax, DWORD PTR $T226880[esp+12]
	push	eax
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
$LN1@resize:
	pop	edi
	pop	esi

; 722  : 		}

	ret	8
?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::resize
_TEXT	ENDS
PUBLIC	?push_back@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEXABVCustomOption@CvPreGame@@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEXABVCustomOption@CvPreGame@@@Z
_TEXT	SEGMENT
$T226989 = -4						; size = 1
__Cat$226993 = 8					; size = 1
$T226960 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEXABVCustomOption@CvPreGame@@@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back
$LN9@push_back:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 2021161081				; 78787879H
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 2021161081				; 78787879H
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$226993[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T226989[esp+16], 0
	mov	ecx, DWORD PTR $T226989[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPreGame::CustomOption *,unsigned int,CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
	add	esp, 24					; 00000018H
	add	edi, 68					; 00000044H
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T226960[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@ABVCustomOption@CvPreGame@@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEXABVCustomOption@CvPreGame@@@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::push_back
_TEXT	ENDS
PUBLIC	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z
_TEXT	SEGMENT
$T227017 = -32						; size = 8
__Oldend$215506 = -24					; size = 8
$T227020 = -16						; size = 8
$T227018 = -16						; size = 8
$T227019 = -8						; size = 8
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_x, COMDAT
; _this$ = ecx

; 2296 : 		{	// make room to insert _Count elements at _Where

	sub	esp, 32					; 00000020H
	push	ebx

; 2297 : 		size_type _Off = _Where - begin();
; 2298 : 
; 2299 :  #if _HAS_ITERATOR_DEBUGGING
; 2300 : 		if (end() < _Where)
; 2301 : 			_DEBUG_ERROR("vector<bool> insert iterator outside range");
; 2302 : 		bool _Realloc = capacity() - size() < _Count;
; 2303 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2304 : 
; 2305 : 		if (_Count == 0)

	mov	ebx, DWORD PTR __Count$[esp+32]
	push	ebp
	mov	ebp, DWORD PTR __Where$[esp+36]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	sub	ebp, eax
	sar	ebp, 2
	shl	ebp, 5
	add	ebp, DWORD PTR __Where$[esp+44]
	test	ebx, ebx
	je	$LN1@Insert_x

; 2306 : 			;
; 2307 : 		else if (max_size() - size() < _Count)

	mov	eax, DWORD PTR [esi]
	or	ecx, -1
	sub	ecx, eax
	cmp	ecx, ebx
	jae	SHORT $LN4@Insert_x

; 2308 : 			_Xlen();	// result too long

	mov	ecx, esi
	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
$LN97@Insert_x:
$LN4@Insert_x:
	push	edi

; 2309 : 		else
; 2310 : 			{	// worth doing
; 2311 : 			_Myvec.resize(_Nw(size() + _Count), 0);

	lea	edx, DWORD PTR [eax+ebx+31]
	push	0
	shr	edx, 5
	push	edx
	lea	ecx, DWORD PTR [esi+4]
	call	?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize

; 2312 : 			if (size() == 0)

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	jne	SHORT $LN2@Insert_x
	pop	edi

; 2313 : 				_Mysize += _Count;

	mov	DWORD PTR [esi], ebx
	pop	esi

; 2319 : 				}
; 2320 : 
; 2321 :  #if _HAS_ITERATOR_DEBUGGING
; 2322 : 			_Orphan_range(_Realloc ? 0 : _Off, _Mysize);
; 2323 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2324 : 
; 2325 : 			}
; 2326 : 		return (_Off);

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2327 : 		}

	add	esp, 32					; 00000020H
	ret	12					; 0000000cH
$LN2@Insert_x:

; 2314 : 			else
; 2315 : 				{	// make room and copy down suffix
; 2316 : 				iterator _Oldend = end();

	mov	ebx, DWORD PTR [esi+8]
	mov	DWORD PTR __Oldend$215506[esp+48], ebx
	mov	DWORD PTR __Oldend$215506[esp+52], 0
	test	edi, edi
	jbe	SHORT $LN60@Insert_x
	push	edi
	lea	ecx, DWORD PTR __Oldend$215506[esp+52]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN60@Insert_x:

; 2317 : 				_Mysize += _Count;

	mov	eax, DWORD PTR __Count$[esp+44]
	add	eax, edi
	mov	DWORD PTR [esi], eax

; 2318 : 				std::copy_backward(begin() + _Off, _Oldend, end());

	mov	DWORD PTR $T227017[esp+48], ebx
	mov	DWORD PTR $T227017[esp+52], 0
	je	SHORT $LN79@Insert_x
	push	eax
	lea	ecx, DWORD PTR $T227017[esp+52]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN79@Insert_x:
	push	ebp
	lea	ecx, DWORD PTR $T227019[esp+52]
	push	ecx
	lea	ecx, DWORD PTR $T227018[esp+56]
	mov	DWORD PTR $T227018[esp+56], ebx
	mov	DWORD PTR $T227018[esp+60], 0
	call	??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
	mov	edx, DWORD PTR $T227017[esp+52]
	mov	ecx, DWORD PTR $T227017[esp+48]
	push	edx
	mov	edx, DWORD PTR __Oldend$215506[esp+56]
	push	ecx
	mov	ecx, DWORD PTR __Oldend$215506[esp+56]
	push	edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T227020[esp+72]
	push	ecx
	call	??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
	add	esp, 28					; 0000001cH
	pop	edi
$LN1@Insert_x:
	pop	esi

; 2319 : 				}
; 2320 : 
; 2321 :  #if _HAS_ITERATOR_DEBUGGING
; 2322 : 			_Orphan_range(_Realloc ? 0 : _Off, _Mysize);
; 2323 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2324 : 
; 2325 : 			}
; 2326 : 		return (_Off);

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2327 : 		}

	add	esp, 32					; 00000020H
	ret	12					; 0000000cH
$LN96@Insert_x:
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_x
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@VCustomOption@CvPreGame@@V?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; SerializeToSequenceContainer<CvPreGame::CustomOption,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > >
EXTRN	??5CvPreGame@@YAAAVFDataStream@@AAV1@AAVCustomOption@0@@Z:PROC ; CvPreGame::operator>>
EXTRN	??0CustomOption@CvPreGame@@QAE@XZ:PROC		; CvPreGame::CustomOption::CustomOption
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$SerializeToSequenceContainer@VCustomOption@CvPreGame@@V?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z
_TEXT	SEGMENT
$T227363 = -72						; size = 4
_v$219896 = -68						; size = 68
_loadFrom$ = 8						; size = 4
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@VCustomOption@CvPreGame@@V?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<CvPreGame::CustomOption,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > >, COMDAT

; 83   : {

	sub	esp, 72					; 00000048H
	push	ebx
	push	esi

; 84   : 	container.clear();

	mov	esi, DWORD PTR _container$[esp+76]
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T227363[esp+92]
	push	eax
	mov	ecx, esi
	call	?erase@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@0@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::erase

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	ebx, DWORD PTR _loadFrom$[esp+80]
	lea	ecx, DWORD PTR _count$[esp+80]
	push	ecx
	xor	edi, edi
	mov	ecx, ebx
	mov	DWORD PTR _count$[esp+84], edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	cmp	DWORD PTR _count$[esp+80], edi
	jbe	SHORT $LN1@SerializeT
	npad	6
$LL3@SerializeT:

; 89   : 	{
; 90   : 		ElementType v;

	lea	ecx, DWORD PTR _v$219896[esp+84]
	call	??0CustomOption@CvPreGame@@QAE@XZ	; CvPreGame::CustomOption::CustomOption

; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$219896[esp+84]
	push	edx
	push	ebx
	call	??5CvPreGame@@YAAAVFDataStream@@AAV1@AAVCustomOption@0@@Z ; CvPreGame::operator>>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	eax, DWORD PTR _v$219896[esp+84]
	push	eax
	mov	ecx, esi
	call	?push_back@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEXABVCustomOption@CvPreGame@@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::push_back
	inc	edi
	cmp	edi, DWORD PTR _count$[esp+80]
	jb	SHORT $LL3@SerializeT
$LN1@SerializeT:
	pop	edi
	pop	esi
	pop	ebx

; 93   : 	}
; 94   : }

	add	esp, 72					; 00000048H
	ret	0
??$SerializeToSequenceContainer@VCustomOption@CvPreGame@@V?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<CvPreGame::CustomOption,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z
_TEXT	SEGMENT
__Tmp$227450 = -16					; size = 8
__Tmp$227508 = -8					; size = 8
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 1
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_n, COMDAT
; _this$ = ecx

; 2290 : 		{	// insert _Count * _Val at _Where

	sub	esp, 16					; 00000010H

; 2291 : 		size_type _Off = _Insert_x(_Where, _Count);

	mov	eax, DWORD PTR __Where$[esp+16]
	push	ebx
	mov	ebx, DWORD PTR __Count$[esp+16]
	push	esi
	push	edi
	push	ebx
	mov	esi, ecx
	mov	ecx, DWORD PTR __Where$[esp+28]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x

; 2292 : 		std::fill(begin() + _Off, begin() + (_Off + _Count), _Val);

	mov	esi, DWORD PTR [esi+8]
	mov	edi, eax
	lea	edx, DWORD PTR [edi+ebx]
	xor	eax, eax
	push	edx
	lea	ecx, DWORD PTR __Tmp$227450[esp+32]
	mov	DWORD PTR __Tmp$227450[esp+32], esi
	mov	DWORD PTR __Tmp$227450[esp+36], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	xor	eax, eax
	push	edi
	lea	ecx, DWORD PTR __Tmp$227508[esp+32]
	mov	DWORD PTR __Tmp$227508[esp+32], esi
	mov	DWORD PTR __Tmp$227508[esp+36], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$227450[esp+32]
	mov	edx, DWORD PTR __Tmp$227450[esp+28]
	lea	eax, DWORD PTR __Val$[esp+24]
	push	eax
	mov	eax, DWORD PTR __Tmp$227508[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __Tmp$227508[esp+36]
	push	edx
	push	eax
	push	ecx
	call	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 2293 : 		}

	add	esp, 16					; 00000010H
	ret	16					; 00000010H
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_n
_TEXT	ENDS
PUBLIC	??$?5VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; operator>><CvPreGame::CustomOption>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z PROC ; operator>><CvPreGame::CustomOption>, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@VCustomOption@CvPreGame@@V?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; SerializeToSequenceContainer<CvPreGame::CustomOption,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ENDP ; operator>><CvPreGame::CustomOption>
_TEXT	ENDS
PUBLIC	?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z ; std::vector<bool,std::allocator<bool> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Tmp$227631 = 12					; size = 8
__Where$ = 12						; size = 8
__Val$ = 20						; size = 1
?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z PROC ; std::vector<bool,std::allocator<bool> >::insert, COMDAT
; _this$ = ecx

; 2151 : 		size_type _Off = _Where - begin();
; 2152 : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR __Where$[esp+4]
	mov	eax, DWORD PTR [edi+8]
	mov	esi, ecx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[esp+8]
	push	edx
	push	1
	sar	esi, 2
	push	eax
	push	ecx
	shl	esi, 5
	mov	ecx, edi
	add	esi, eax
	call	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n

; 2153 : 		return (begin() + _Off);

	mov	edi, DWORD PTR [edi+8]
	xor	eax, eax
	push	esi
	lea	ecx, DWORD PTR __Tmp$227631[esp+8]
	mov	DWORD PTR __Tmp$227631[esp+8], edi
	mov	DWORD PTR __Tmp$227631[esp+12], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Tmp$227631[esp+4]
	mov	edx, DWORD PTR __Tmp$227631[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 2154 : 		}

	ret	16					; 00000010H
?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::insert
_TEXT	ENDS
PUBLIC	?push_back@?$vector@_NV?$allocator@_N@std@@@std@@QAEX_N@Z ; std::vector<bool,std::allocator<bool> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@_NV?$allocator@_N@std@@@std@@QAEX_N@Z
_TEXT	SEGMENT
$T227637 = -8						; size = 8
$T227636 = -8						; size = 8
__Val$ = 8						; size = 1
?push_back@?$vector@_NV?$allocator@_N@std@@@std@@QAEX_N@Z PROC ; std::vector<bool,std::allocator<bool> >::push_back, COMDAT
; _this$ = ecx

; 2115 : 		{	// insert element at end

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 2116 : 		insert(end(), _Val);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR $T227636[esp+12], eax
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR $T227636[esp+16], 0
	test	eax, eax
	jbe	SHORT $LN20@push_back@2
	push	eax
	lea	ecx, DWORD PTR $T227636[esp+16]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN20@push_back@2:
	mov	ecx, DWORD PTR __Val$[esp+8]
	mov	edx, DWORD PTR $T227636[esp+16]
	mov	eax, DWORD PTR $T227636[esp+12]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T227637[esp+24]
	push	ecx
	mov	ecx, esi
	call	?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z ; std::vector<bool,std::allocator<bool> >::insert
	pop	esi

; 2117 : 		}

	add	esp, 8
	ret	4
?push_back@?$vector@_NV?$allocator@_N@std@@@std@@QAEX_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::push_back
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@_NV?$vector@_NV?$allocator@_N@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; SerializeToSequenceContainer<bool,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$SerializeToSequenceContainer@_NV?$vector@_NV?$allocator@_N@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z
_TEXT	SEGMENT
_v$214350 = -8						; size = 1
$T227851 = -8						; size = 8
$T227848 = -8						; size = 8
_loadFrom$ = 8						; size = 4
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@_NV?$vector@_NV?$allocator@_N@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z PROC ; SerializeToSequenceContainer<bool,std::vector<bool,std::allocator<bool> > >, COMDAT

; 83   : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 84   : 	container.clear();

	mov	esi, DWORD PTR _container$[esp+16]
	mov	eax, DWORD PTR [esi]
	xor	ebp, ebp
	push	edi
	mov	edi, DWORD PTR [esi+8]
	mov	DWORD PTR $T227848[esp+24], edi
	mov	DWORD PTR $T227848[esp+28], ebp
	cmp	eax, ebp
	jbe	SHORT $LN25@SerializeT@2
	push	eax
	lea	ecx, DWORD PTR $T227848[esp+28]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN25@SerializeT@2:
	mov	ecx, DWORD PTR $T227848[esp+28]
	mov	edx, DWORD PTR $T227848[esp+24]
	push	ecx
	push	edx
	xor	eax, eax
	push	eax
	push	edi
	lea	eax, DWORD PTR $T227851[esp+40]
	push	eax
	mov	ecx, esi
	call	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	ebx, DWORD PTR _loadFrom$[esp+20]
	lea	ecx, DWORD PTR _count$[esp+20]
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR _count$[esp+24], ebp
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	xor	edi, edi
	cmp	DWORD PTR _count$[esp+20], ebp
	jbe	SHORT $LN1@SerializeT@2
	npad	2
$LL118@SerializeT@2:

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$214350[esp+24]
	push	edx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 92   : 		container.push_back(v);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	xor	edx, edx
	test	eax, eax
	jbe	SHORT $LN66@SerializeT@2
	jge	SHORT $LN67@SerializeT@2
	mov	edx, eax
	neg	edx
	je	SHORT $LN67@SerializeT@2
	or	edx, -1
	sub	edx, eax
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	mov	ebp, -4					; fffffffcH
	sub	ebp, edx
	add	ecx, ebp
	jmp	SHORT $LN119@SerializeT@2
$LN67@SerializeT@2:
	mov	edx, eax
	shr	edx, 5
	lea	ecx, DWORD PTR [ecx+edx*4]
$LN119@SerializeT@2:
	and	eax, 31					; 0000001fH
	mov	edx, eax
$LN66@SerializeT@2:
	mov	eax, DWORD PTR _v$214350[esp+24]
	push	eax
	push	1
	push	edx
	push	ecx
	mov	ecx, esi
	call	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
	inc	edi
	cmp	edi, DWORD PTR _count$[esp+20]
	jb	SHORT $LL118@SerializeT@2
$LN1@SerializeT@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 93   : 	}
; 94   : }

	add	esp, 8
	ret	0
??$SerializeToSequenceContainer@_NV?$vector@_NV?$allocator@_N@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<bool,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; operator>><bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z PROC ; operator>><bool>, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@_NV?$vector@_NV?$allocator@_N@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; SerializeToSequenceContainer<bool,std::vector<bool,std::allocator<bool> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z ENDP ; operator>><bool>
_TEXT	ENDS
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4GameMode@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4TurnTimerTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4GameSpeedTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4CalendarTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4SeaLevelTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4ClimateTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4WorldSizeTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4StorageLocation@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdllnetinitinfo.cpp
;	COMDAT ?Read@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_kStream$ = 12						; size = 4
?Read@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z PROC	; CvDllNetInitInfo::Read, COMDAT

; 161  : {

	push	esi

; 162  : 	kStream >> m_szLoadFileName;

	mov	esi, DWORD PTR _this$[esp]
	push	edi
	mov	edi, DWORD PTR _kStream$[esp+4]
	lea	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 163  : 	kStream >> m_eLoadFileStorage;

	lea	ecx, DWORD PTR [esi+32]
	push	ecx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4StorageLocation@@@Z ; operator>>
	add	esp, 8

; 164  : 	kStream >> m_szMapScriptName;

	lea	edx, DWORD PTR [esi+36]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 165  : 	kStream >> m_bIsEarthMap;

	lea	eax, DWORD PTR [esi+64]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 166  : 	kStream >> m_bIsRandomMapScript;

	lea	ecx, DWORD PTR [esi+65]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 167  : 	kStream >> m_bIsRandomWorldSize;

	lea	edx, DWORD PTR [esi+66]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 168  : 	kStream >> m_bWBMapNoPlayers;

	lea	eax, DWORD PTR [esi+67]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 169  : 	kStream >> m_eWorldSize;

	lea	ecx, DWORD PTR [esi+68]
	push	ecx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4WorldSizeTypes@@@Z ; operator>>

; 170  : 	kStream >> m_eClimate;

	lea	edx, DWORD PTR [esi+72]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4ClimateTypes@@@Z ; operator>>

; 171  : 	kStream >> m_eSeaLevel;

	lea	eax, DWORD PTR [esi+76]
	push	eax
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4SeaLevelTypes@@@Z ; operator>>

; 172  : 	kStream >> m_eEra;

	lea	ecx, DWORD PTR [esi+80]
	push	ecx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z ; operator>>

; 173  : 	kStream >> m_eCalendar;

	lea	edx, DWORD PTR [esi+84]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4CalendarTypes@@@Z ; operator>>
	add	esp, 40					; 00000028H

; 174  : 	kStream >> m_iGameTurn;

	lea	eax, DWORD PTR [esi+88]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 175  : 	kStream >> m_bGameStarted;

	lea	ecx, DWORD PTR [esi+92]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 176  : 	kStream >> m_eGameSpeed;

	lea	edx, DWORD PTR [esi+96]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4GameSpeedTypes@@@Z ; operator>>

; 177  : 	kStream >> m_eTurnTimerEnabled;

	lea	eax, DWORD PTR [esi+100]
	push	eax
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4TurnTimerTypes@@@Z ; operator>>
	add	esp, 16					; 00000010H

; 178  : 	kStream >> m_iTurnTimerTime;

	lea	ecx, DWORD PTR [esi+104]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 179  : 	kStream >> m_szGameName;

	lea	edx, DWORD PTR [esi+108]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 180  : 	kStream >> m_uiSyncRandSeed;

	lea	eax, DWORD PTR [esi+136]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 181  : 	kStream >> m_uiMapRandSeed;

	lea	ecx, DWORD PTR [esi+140]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 182  : 
; 183  : 	kStream >> m_iNumVictories;

	lea	edx, DWORD PTR [esi+144]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 184  : 	kStream >> m_abVictories;

	lea	eax, DWORD PTR [esi+148]
	push	eax
	push	edi
	call	??$SerializeToSequenceContainer@_NV?$vector@_NV?$allocator@_N@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; SerializeToSequenceContainer<bool,std::vector<bool,std::allocator<bool> > >

; 185  : 
; 186  : 	kStream >> m_aGameOptions;

	lea	ecx, DWORD PTR [esi+168]
	push	ecx
	push	edi
	call	??$SerializeToSequenceContainer@VCustomOption@CvPreGame@@V?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; SerializeToSequenceContainer<CvPreGame::CustomOption,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > >

; 187  : 	kStream >> m_aMapOptions;

	lea	edx, DWORD PTR [esi+184]
	push	edx
	push	edi
	call	??$SerializeToSequenceContainer@VCustomOption@CvPreGame@@V?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; SerializeToSequenceContainer<CvPreGame::CustomOption,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > >

; 188  : 	kStream >> m_abMPOptions;

	lea	eax, DWORD PTR [esi+200]
	push	eax
	push	edi
	call	??$SerializeToSequenceContainer@_NV?$vector@_NV?$allocator@_N@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; SerializeToSequenceContainer<bool,std::vector<bool,std::allocator<bool> > >
	add	esp, 32					; 00000020H

; 189  : 	kStream >> m_iMaxTurns;

	lea	ecx, DWORD PTR [esi+220]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 190  : 	kStream >> m_iPitbossTurnTime;

	lea	edx, DWORD PTR [esi+224]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 191  : 	kStream >> m_iMaxCityElimination;

	lea	eax, DWORD PTR [esi+228]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 192  : 	kStream >> m_iNumMinorCivs;

	lea	ecx, DWORD PTR [esi+232]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 193  : 	kStream >> m_iNumAdvancedStartPoints;

	lea	edx, DWORD PTR [esi+236]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 194  : 	kStream >> m_eMode;

	lea	eax, DWORD PTR [esi+240]
	push	eax
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4GameMode@@@Z ; operator>>
	add	esp, 8

; 195  : 	kStream >> m_bStatReporting;

	add	esi, 244				; 000000f4H
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	pop	edi

; 196  : 
; 197  : 	return true;

	mov	al, 1
	pop	esi

; 198  : }

	ret	8
?Read@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z ENDP	; CvDllNetInitInfo::Read
_TEXT	ENDS
END
