; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Lekmod Files\Lekmod DLL versions\v29\LEKMOD_DLL\CvGameCoreDLL_Expansion2\Lua\CvLuaPlot.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG220417 DB	'CanHaveFeature', 00H
	ORG $+1
$SG220418 DB	'GetFeatureType', 00H
	ORG $+1
$SG220419 DB	'GetTerrainType', 00H
	ORG $+1
$SG220420 DB	'IsRiver', 00H
$SG220421 DB	'IsWater', 00H
$SG220422 DB	'SetFeatureType', 00H
	ORG $+1
$SG220423 DB	'SetTerrainType', 00H
	ORG $+1
$SG220424 DB	'IsNone', 00H
	ORG $+1
$SG220425 DB	'Erase', 00H
	ORG $+2
$SG220426 DB	'GetTeam', 00H
$SG220427 DB	'NukeExplosion', 00H
	ORG $+2
$SG220428 DB	'GetInlandCorner', 00H
$SG220429 DB	'UpdateFog', 00H
	ORG $+2
$SG220430 DB	'UpdateVisibility', 00H
	ORG $+3
$SG220431 DB	'IsAdjacentToArea', 00H
	ORG $+3
$SG220432 DB	'ShareAdjacentArea', 00H
	ORG $+2
$SG220433 DB	'IsAdjacentToLand', 00H
	ORG $+3
$SG220434 DB	'IsAdjacentToShallowWater', 00H
	ORG $+3
$SG220435 DB	'IsCoastalLand', 00H
	ORG $+2
$SG220436 DB	'IsWithinTeamCityRadius', 00H
	ORG $+1
$SG220437 DB	'IsLake', 00H
	ORG $+1
$SG220438 DB	'IsFreshWater', 00H
	ORG $+3
$SG220439 DB	'IsRiverSide', 00H
$SG220440 DB	'IsRiverConnection', 00H
	ORG $+2
$SG220441 DB	'IsRiverCrossingFlowClockwise', 00H
	ORG $+3
$SG220442 DB	'GetNearestLandArea', 00H
	ORG $+1
$SG220443 DB	'SeeFromLevel', 00H
	ORG $+3
$SG220444 DB	'GetNearestLandPlot', 00H
	ORG $+1
$SG220445 DB	'SeeThroughLevel', 00H
$SG220446 DB	'CanHaveResource', 00H
$SG220447 DB	'CanHaveImprovement', 00H
	ORG $+1
$SG220448 DB	'CanBuild', 00H
	ORG $+3
$SG220449 DB	'GetBuildTime', 00H
	ORG $+3
$SG220450 DB	'GetBuildTurnsLeft', 00H
	ORG $+2
$SG220451 DB	'GetBuildTurnsTotal', 00H
	ORG $+1
$SG220452 DB	'GetFeatureProduction', 00H
	ORG $+3
$SG220453 DB	'GetFeatureFood', 00H
	ORG $+1
$SG220454 DB	'GetBestDefender', 00H
$SG220455 DB	'GetSelectedUnit', 00H
$SG220456 DB	'GetUnitPower', 00H
	ORG $+3
$SG220457 DB	'DefenseModifier', 00H
$SG220458 DB	'MovementCost', 00H
	ORG $+3
$SG220459 DB	'GetExtraMovePathCost', 00H
	ORG $+3
$SG220460 DB	'ChangeExtraMovePathCost', 00H
$SG220461 DB	'IsAdjacentOwned', 00H
$SG220462 DB	'IsAdjacentPlayer', 00H
	ORG $+3
$SG220463 DB	'IsAdjacentTeam', 00H
	ORG $+1
$SG220464 DB	'IsOwned', 00H
$SG220465 DB	'IsBarbarian', 00H
$SG220466 DB	'IsRevealedBarbarian', 00H
$SG220467 DB	'HasBarbarianCamp', 00H
	ORG $+3
$SG220468 DB	'IsVisible', 00H
	ORG $+2
$SG220469 DB	'IsActiveVisible', 00H
$SG220470 DB	'IsVisibleToWatchingHuman', 00H
	ORG $+3
$SG220471 DB	'IsAdjacentVisible', 00H
	ORG $+2
$SG220472 DB	'IsAdjacentNonvisible', 00H
	ORG $+3
$SG220473 DB	'IsAdjacentRevealed', 00H
	ORG $+1
$SG220474 DB	'IsAdjacentNonrevealed', 00H
	ORG $+2
$SG220475 DB	'RemoveGoody', 00H
$SG220476 DB	'IsGoody', 00H
$SG220477 DB	'IsRevealedGoody', 00H
$SG220478 DB	'IsFriendlyTerritory', 00H
$SG220479 DB	'IsCity', 00H
	ORG $+1
$SG220480 DB	'IsFriendlyCity', 00H
	ORG $+1
$SG220481 DB	'IsEnemyCity', 00H
$SG220482 DB	'IsBeingWorked', 00H
	ORG $+2
$SG220483 DB	'IsUnit', 00H
	ORG $+1
$SG220484 DB	'IsVisibleEnemyDefender', 00H
	ORG $+1
$SG220485 DB	'GetNumDefenders', 00H
$SG220486 DB	'GetNumVisibleEnemyDefenders', 00H
$SG220487 DB	'GetNumVisiblePotentialEnemyDefenders', 00H
	ORG $+3
$SG220488 DB	'IsVisibleEnemyUnit', 00H
	ORG $+1
$SG220489 DB	'IsVisibleOtherUnit', 00H
	ORG $+1
$SG220490 DB	'GetNumFriendlyUnitsOfType', 00H
	ORG $+2
$SG220491 DB	'IsFighting', 00H
	ORG $+1
$SG220492 DB	'IsRoute', 00H
$SG220493 DB	'IsTradeRoute', 00H
	ORG $+3
$SG220494 DB	'IsValidDomainForLocation', 00H
	ORG $+3
$SG220495 DB	'IsValidDomainForAction', 00H
	ORG $+1
$SG220496 DB	'IsImpassable', 00H
	ORG $+3
$SG220497 DB	'GetX', 00H
	ORG $+3
$SG220498 DB	'GetY', 00H
	ORG $+3
$SG220499 DB	'At', 00H
	ORG $+1
$SG220500 DB	'GetPlotIndex', 00H
	ORG $+3
$SG220501 DB	'GetLatitude', 00H
$SG220502 DB	'Area', 00H
	ORG $+3
$SG220503 DB	'WaterArea', 00H
	ORG $+2
$SG220504 DB	'GetArea', 00H
$SG220505 DB	'SetArea', 00H
$SG220506 DB	'GetFeatureVariety', 00H
	ORG $+2
$SG220507 DB	'GetOwnershipDuration', 00H
	ORG $+3
$SG220508 DB	'IsOwnershipScore', 00H
	ORG $+3
$SG220509 DB	'SetOwnershipDuration', 00H
	ORG $+3
$SG220510 DB	'ChangeOwnershipDuration', 00H
$SG220511 DB	'GetImprovementDuration', 00H
	ORG $+1
$SG220512 DB	'SetImprovementDuration', 00H
	ORG $+1
$SG220513 DB	'ChangeImprovementDuration', 00H
	ORG $+2
$SG220514 DB	'GetUpgradeProgress', 00H
	ORG $+1
$SG220515 DB	'GetUpgradeTimeLeft', 00H
	ORG $+1
$SG220516 DB	'SetUpgradeProgress', 00H
	ORG $+1
$SG220517 DB	'ChangeUpgradeProgress', 00H
	ORG $+2
$SG220518 DB	'GetCityRadiusCount', 00H
	ORG $+1
$SG220519 DB	'IsCityRadius', 00H
	ORG $+3
$SG220520 DB	'IsStartingPlot', 00H
	ORG $+1
$SG220521 DB	'SetStartingPlot', 00H
$SG220522 DB	'IsNEOfRiver', 00H
$SG220523 DB	'SetNEOfRiver', 00H
	ORG $+3
$SG220524 DB	'IsWOfRiver', 00H
	ORG $+1
$SG220525 DB	'SetWOfRiver', 00H
$SG220526 DB	'IsNWOfRiver', 00H
$SG220527 DB	'SetNWOfRiver', 00H
	ORG $+3
$SG220528 DB	'GetRiverEFlowDirection', 00H
	ORG $+1
$SG220529 DB	'GetRiverSEFlowDirection', 00H
$SG220530 DB	'GetRiverSWFlowDirection', 00H
$SG220531 DB	'IsPotentialCityWork', 00H
$SG220532 DB	'IsPotentialCityWorkForArea', 00H
	ORG $+1
$SG220533 DB	'GetOwner', 00H
	ORG $+3
$SG220534 DB	'SetOwner', 00H
	ORG $+3
$SG220535 DB	'GetPlotType', 00H
$SG220536 DB	'IsFlatlands', 00H
$SG220537 DB	'IsHills', 00H
$SG220538 DB	'IsOpenGround', 00H
	ORG $+3
$SG220539 DB	'IsRoughGround', 00H
	ORG $+2
$SG220540 DB	'IsMountain', 00H
	ORG $+1
$SG220541 DB	'SetPlotType', 00H
$SG220542 DB	'GetResourceType', 00H
$SG220543 DB	'GetNonObsoleteResourceType', 00H
	ORG $+1
$SG220544 DB	'SetResourceType', 00H
$SG220545 DB	'GetNumResource', 00H
	ORG $+1
$SG220546 DB	'SetNumResource', 00H
	ORG $+1
$SG220547 DB	'ChangeNumResource', 00H
	ORG $+2
$SG220548 DB	'GetImprovementType', 00H
	ORG $+1
$SG220549 DB	'SetImprovementType', 00H
	ORG $+1
$SG220550 DB	'SetImprovementPillaged', 00H
	ORG $+1
$SG220551 DB	'GetRouteType', 00H
	ORG $+3
$SG220552 DB	'SetRouteType', 00H
	ORG $+3
$SG220553 DB	'IsRoutePillaged', 00H
$SG220554 DB	'GetPlotCity', 00H
$SG220555 DB	'GetWorkingCity', 00H
	ORG $+1
$SG220556 DB	'GetWorkingCityOverride', 00H
	ORG $+1
$SG220557 DB	'GetReconCount', 00H
	ORG $+2
$SG220558 DB	'GetRiverCrossingCount', 00H
	ORG $+2
$SG220559 DB	'GetYield', 00H
	ORG $+3
$SG220560 DB	'CalculateNatureYield', 00H
	ORG $+3
$SG220561 DB	'CalculateBestNatureYield', 00H
	ORG $+3
$SG220562 DB	'CalculateTotalBestNatureYield', 00H
	ORG $+2
$SG220563 DB	'CalculateImprovementYieldChange', 00H
$SG220564 DB	'CalculateYield', 00H
	ORG $+1
$SG220565 DB	'HasYield', 00H
	ORG $+3
$SG220566 DB	'GetYieldWithBuild', 00H
	ORG $+2
$SG220567 DB	'CountNumAirUnits', 00H
	ORG $+3
$SG220568 DB	'GetFoundValue', 00H
	ORG $+2
$SG220569 DB	'IsBestAdjacentFound', 00H
$SG220570 DB	'GetPlayerCityRadiusCount', 00H
	ORG $+3
$SG220571 DB	'IsPlayerCityRadius', 00H
	ORG $+1
$SG220572 DB	'GetVisibilityCount', 00H
	ORG $+1
$SG220573 DB	'ChangeVisibilityCount', 00H
	ORG $+2
$SG220574 DB	'GetRevealedOwner', 00H
	ORG $+3
$SG220575 DB	'GetRevealedTeam', 00H
$SG220576 DB	'IsRiverCrossing', 00H
$SG220577 DB	'IsRiverCrossingToPlot', 00H
	ORG $+2
$SG220578 DB	'IsRevealed', 00H
	ORG $+1
$SG220579 DB	'SetRevealed', 00H
$SG220580 DB	'GetRevealedImprovementType', 00H
	ORG $+1
$SG220581 DB	'GetRevealedRouteType', 00H
	ORG $+3
$SG220582 DB	'GetBuildProgress', 00H
	ORG $+3
$SG220583 DB	'ChangeBuildProgress', 00H
$SG220584 DB	'GetInvisibleVisibilityCount', 00H
$SG220585 DB	'IsInvisibleVisible', 00H
	ORG $+1
$SG220586 DB	'ChangeInvisibleVisibilityCount', 00H
	ORG $+1
$SG220587 DB	'GetNumUnits', 00H
$SG220588 DB	'GetUnit', 00H
$SG220589 DB	'GetNumLayerUnits', 00H
	ORG $+3
$SG220590 DB	'GetLayerUnit', 00H
	ORG $+3
$SG220591 DB	'GetScriptData', 00H
	ORG $+2
$SG220592 DB	'SetScriptData', 00H
	ORG $+2
$SG220593 DB	'GetActiveFogOfWarMode', 00H
	ORG $+2
$SG220594 DB	'IsImprovementPillaged', 00H
	ORG $+2
$SG220595 DB	'CanSeePlot', 00H
	ORG $+1
$SG220596 DB	'GetContinentArtType', 00H
$SG220597 DB	'SetContinentArtType', 00H
$SG220598 DB	'IsResourceConnectedByImprovement', 00H
	ORG $+3
$SG220599 DB	'IsBuildRemovesFeature', 00H
	ORG $+2
$SG220600 DB	'GetArchaeologyArtifactType', 00H
	ORG $+1
$SG220601 DB	'GetArchaeologyArtifactEra', 00H
	ORG $+2
$SG220602 DB	'GetArchaeologyArtifactPlayer1', 00H
	ORG $+2
$SG220603 DB	'GetArchaeologyArtifactPlayer2', 00H
	ORG $+2
$SG220604 DB	'GetArchaeologyArtifactWork', 00H
	ORG $+1
$SG220605 DB	'HasWrittenArtifact', 00H
	ORG $+1
$SG220606 DB	'GetCityPurchaseID', 00H
	ORG $+2
$SG220607 DB	'SetCityPurchaseID', 00H
	ORG $+2
$SG220613 DB	'Plot', 00H
	ORG $+3
$SG222921 DB	'__instances', 00H
$SG222922 DB	'__mode', 00H
	ORG $+1
$SG222923 DB	'v', 00H
	ORG $+2
$SG222925 DB	'__instances', 00H
$SG222928 DB	'__instance', 00H
	ORG $+1
$SG222929 DB	'__index', 00H
$SG222944 DB	'__instance', 00H
	ORG $+1
$SG222950 DB	'Not a valid instance.  Either the instance is NULL or yo'
	DB	'u used ''.'' instead of '':''.', 00H
	ORG $+1
$SG222961 DB	'__instances', 00H
$SG222962 DB	'__mode', 00H
	ORG $+1
$SG222963 DB	'v', 00H
	ORG $+2
$SG222965 DB	'__instances', 00H
$SG222968 DB	'__instance', 00H
	ORG $+1
$SG222969 DB	'__index', 00H
$SG222990 DB	'__instances', 00H
$SG222991 DB	'__mode', 00H
	ORG $+1
$SG222992 DB	'v', 00H
	ORG $+2
$SG222994 DB	'__instances', 00H
$SG222997 DB	'__instance', 00H
	ORG $+1
$SG222998 DB	'__index', 00H
$SG223013 DB	'__instance', 00H
	ORG $+1
$SG223019 DB	'Not a valid instance.  Either the instance is NULL or yo'
	DB	'u used ''.'' instead of '':''.', 00H
	ORG $+1
$SG223027 DB	'Instance does not exist.', 00H
	ORG $+3
$SG223038 DB	'__instances', 00H
$SG223039 DB	'__mode', 00H
	ORG $+1
$SG223040 DB	'v', 00H
	ORG $+2
$SG223042 DB	'__instances', 00H
$SG223045 DB	'__instance', 00H
	ORG $+1
$SG223046 DB	'__index', 00H
$SG223061 DB	'__instance', 00H
	ORG $+5
$SG223067 DB	'Not a valid instance.  Either the instance is NULL or yo'
	DB	'u used ''.'' instead of '':''.', 00H
CONST	ENDS
EXTRN	_lua_tointeger:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvluaargtemplates.h
;	COMDAT ??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z PROC	; CvLuaArgs::toValue<int>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 19   : 		return lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 20   : 	}

	ret	0
??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z ENDP	; CvLuaArgs::toValue<int>
_TEXT	ENDS
EXTRN	_lua_toboolean:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z PROC	; CvLuaArgs::toValue<bool>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 24   : 		return lua_toboolean(L, idx) != 0;

	push	eax
	push	ecx
	call	_lua_toboolean
	add	esp, 8
	neg	eax
	sbb	eax, eax
	neg	eax

; 25   : 	}

	ret	0
??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ENDP	; CvLuaArgs::toValue<bool>
_TEXT	ENDS
EXTRN	_lua_pushinteger:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z
_TEXT	SEGMENT
??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z PROC	; CvLuaArgs::pushValue<int>, COMDAT
; _L$ = ecx
; _t$ = eax

; 39   : 		lua_pushinteger(L, t);

	push	eax
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 40   : 	}

	ret	0
??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ENDP	; CvLuaArgs::pushValue<int>
_TEXT	ENDS
EXTRN	_lua_pushboolean:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z
_TEXT	SEGMENT
??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z PROC	; CvLuaArgs::pushValue<bool>, COMDAT
; _L$ = ecx
; _t$ = eax

; 45   : 		lua_pushboolean(L, t);

	movzx	eax, al
	push	eax
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 46   : 	}

	ret	0
??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ENDP	; CvLuaArgs::pushValue<bool>
_TEXT	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?GetTypeName@CvLuaPlot@@SAPBDXZ			; CvLuaPlot::GetTypeName
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaplot.cpp
;	COMDAT ?GetTypeName@CvLuaPlot@@SAPBDXZ
_TEXT	SEGMENT
?GetTypeName@CvLuaPlot@@SAPBDXZ PROC			; CvLuaPlot::GetTypeName, COMDAT

; 283  : 	return "Plot";

	mov	eax, OFFSET $SG220613

; 284  : }

	ret	0
?GetTypeName@CvLuaPlot@@SAPBDXZ ENDP			; CvLuaPlot::GetTypeName
_TEXT	ENDS
PUBLIC	?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ; FObjectHandle<CvUnit>::pointer
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC ; FObjectHandle<CvUnit>::pointer, COMDAT
; _this$ = ecx

; 78   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 79   : 	}

	ret	0
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP ; FObjectHandle<CvUnit>::pointer
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
EXTRN	_lua_pushnil:PROC
EXTRN	_lua_remove:PROC
EXTRN	_lua_pushlightuserdata:PROC
EXTRN	_lua_rawget:PROC
EXTRN	?PushMethods@CvLuaArea@@SAXPAUlua_State@@H@Z:PROC ; CvLuaArea::PushMethods
EXTRN	_lua_gettop:PROC
EXTRN	_lua_setfield:PROC
EXTRN	_lua_pushvalue:PROC
EXTRN	_lua_setmetatable:PROC
EXTRN	_lua_rawset:PROC
EXTRN	_lua_pushstring:PROC
EXTRN	_lua_createtable:PROC
EXTRN	_lua_settop:PROC
EXTRN	_lua_type:PROC
EXTRN	_lua_getfield:PROC
EXTRN	?GetTypeName@CvLuaArea@@SAPBDXZ:PROC		; CvLuaArea::GetTypeName
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\lua\cvluascopedinstance.h
;	COMDAT ?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_pkType$ = 12						; size = 4
?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z PROC ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push, COMDAT

; 39   : {

	push	edi

; 40   : 	//Pushing an instance involves more than just actually pushing a pointer into the
; 41   : 	//Lua stack.  There are some caching optimizations that are done as well as some
; 42   : 	//checks.
; 43   : 	//The first step is to load or create a global table <Typename> to store all member
; 44   : 	//methods and all pushed instances.  This conserves memory and offers faster pushing
; 45   : 	//speed.
; 46   : 	//If <Typename>.__instances[pkType] is not nil, return that value.
; 47   : 	//otherwise push a new instance and assign it to __instances.
; 48   : 
; 49   : 	//NOTE: Raw gets and sets are used as an optimization over using lua_[get,set]field
; 50   : 	if(pkType)

	mov	edi, DWORD PTR _pkType$[esp]
	test	edi, edi
	je	$LN4@Push
	push	ebx
	push	ebp
	push	esi

; 51   : 	{
; 52   : 		//const int t = lua_gettop(L);
; 53   : 
; 54   : 		lua_getglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaArea@@SAPBDXZ		; CvLuaArea::GetTypeName
	mov	esi, DWORD PTR _L$[esp+12]
	push	eax
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_getfield

; 55   : 		if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN7@Push

; 56   : 		{
; 57   : 			//Typename wasn't found, time to build it.
; 58   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 59   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 60   : 
; 61   : 			//Create weak __instances table.
; 62   : 			lua_pushstring(L, "__instances");

	push	OFFSET $SG222921
	push	esi
	call	_lua_pushstring

; 63   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 64   : 
; 65   : 			//Create __instances.mt
; 66   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 67   : 			lua_pushstring(L, "__mode");

	push	OFFSET $SG222922
	push	esi
	call	_lua_pushstring

; 68   : 			lua_pushstring(L, "v");

	push	OFFSET $SG222923
	push	esi
	call	_lua_pushstring
	add	esp, 68					; 00000044H

; 69   : 			lua_rawset(L, -3);				// mt.__mode = "v";

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 70   : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_setmetatable

; 71   : 
; 72   : 			lua_rawset(L, -3);				//type.__instances = t;

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 73   : 
; 74   : 
; 75   : 			lua_pushvalue(L, -1);

	push	-1
	push	esi
	call	_lua_pushvalue

; 76   : 			lua_setglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaArea@@SAPBDXZ		; CvLuaArea::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_setfield

; 77   : 
; 78   : 			Derived::PushMethods(L, lua_gettop(L));

	push	esi
	call	_lua_gettop
	push	eax
	push	esi
	call	?PushMethods@CvLuaArea@@SAXPAUlua_State@@H@Z ; CvLuaArea::PushMethods
	add	esp, 56					; 00000038H
$LN7@Push:

; 79   : 		}
; 80   : 		const int type_index = lua_gettop(L);

	push	esi
	call	_lua_gettop

; 81   : 
; 82   : 		lua_pushstring(L, "__instances");

	push	OFFSET $SG222925
	push	esi
	mov	ebx, eax
	call	_lua_pushstring

; 83   : 		lua_rawget(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_rawget

; 84   : 
; 85   : 		const int instances_index = lua_gettop(L);

	push	esi
	call	_lua_gettop

; 86   : 
; 87   : 		lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	mov	ebp, eax
	call	_lua_pushlightuserdata

; 88   : 
; 89   : 		lua_rawget(L, -2);					//retrieve type.__instances[pkType]

	push	-2					; fffffffeH
	push	esi
	call	_lua_rawget

; 90   : 
; 91   : 		if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 48					; 00000030H
	test	eax, eax
	jne	SHORT $LN2@Push

; 92   : 		{
; 93   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 94   : 
; 95   : 			//Push new instance
; 96   : 			lua_createtable(L, 0, 1);

	push	1
	push	0
	push	esi
	call	_lua_createtable

; 97   : 			lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	call	_lua_pushlightuserdata

; 98   : 			lua_setfield(L, -2, "__instance");

	push	OFFSET $SG222928
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 99   : 
; 100  : 			lua_createtable(L, 0, 1);			// create mt

	push	1
	push	0
	push	esi
	call	_lua_createtable

; 101  : 			lua_pushstring(L, "__index");

	push	OFFSET $SG222929
	push	esi
	call	_lua_pushstring

; 102  : 			lua_pushvalue(L, type_index);

	push	ebx
	push	esi
	call	_lua_pushvalue
	add	esp, 68					; 00000044H

; 103  : 			lua_rawset(L, -3);					// mt.__index = Type

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 104  : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_setmetatable

; 105  : 
; 106  : 			//Assign it in instances
; 107  : 			lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	call	_lua_pushlightuserdata

; 108  : 			lua_pushvalue(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_pushvalue

; 109  : 			lua_rawset(L, instances_index);				//__instances[pkType] = t;

	push	ebp
	push	esi
	call	_lua_rawset
	add	esp, 40					; 00000028H
$LN2@Push:

; 110  : 		}
; 111  : 
; 112  : 		//VERIFY(instances_index > type_index);
; 113  : 		lua_remove(L, instances_index);

	push	ebp
	push	esi
	call	_lua_remove

; 114  : 		lua_remove(L, type_index);

	push	ebx
	push	esi
	call	_lua_remove
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 122  : 	}
; 123  : }

	ret	0
$LN4@Push:

; 115  : 
; 116  : 		//const int dt = lua_gettop(L);
; 117  : 		//VERIFY(dt == t + 1)
; 118  : 	}
; 119  : 	else
; 120  : 	{
; 121  : 		lua_pushnil(L);

	mov	eax, DWORD PTR _L$[esp]
	push	eax
	call	_lua_pushnil
	add	esp, 4
	pop	edi

; 122  : 	}
; 123  : }

	ret	0
?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ENDP ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
_TEXT	ENDS
PUBLIC	?GetInstance@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAPAVCvArea@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::GetInstance
EXTRN	?HandleMissingInstance@CvLuaArea@@SAXPAUlua_State@@@Z:PROC ; CvLuaArea::HandleMissingInstance
EXTRN	_luaL_error:PROC
EXTRN	_lua_touserdata:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetInstance@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAPAVCvArea@@PAUlua_State@@H_N@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
_bErrorOnFail$ = 16					; size = 1
?GetInstance@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAPAVCvArea@@PAUlua_State@@H_N@Z PROC ; CvLuaScopedInstance<CvLuaArea,CvArea>::GetInstance, COMDAT

; 127  : {

	push	ebx
	push	ebp
	push	esi

; 128  : 	const int stack_size = lua_gettop(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	mov	ebp, eax

; 129  : 	bool bFail = true;
; 130  : 
; 131  : 	InstanceType* pkInstance = NULL;
; 132  : 	if(lua_type(L, idx) == LUA_TTABLE)

	mov	eax, DWORD PTR _idx$[esp+16]
	push	eax
	push	esi
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN3@GetInstanc

; 133  : 	{
; 134  : 		lua_getfield(L, idx, "__instance");

	mov	ecx, DWORD PTR _idx$[esp+12]
	push	OFFSET $SG222944
	push	ecx
	push	esi
	call	_lua_getfield

; 135  : 		if(lua_type(L, -1) == LUA_TLIGHTUSERDATA)

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN3@GetInstanc

; 136  : 		{
; 137  : 			pkInstance = static_cast<InstanceType*>(lua_touserdata(L, -1));

	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8

; 138  : 			if(pkInstance)

	test	edi, edi
	je	SHORT $LN3@GetInstanc

; 139  : 			{
; 140  : 				bFail = false;

	xor	bl, bl
$LN3@GetInstanc:

; 141  : 			}
; 142  : 		}
; 143  : 	}
; 144  : 
; 145  : 	lua_settop(L, stack_size);

	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8

; 146  : 
; 147  : 	if(bFail && bErrorOnFail)

	test	bl, bl
	je	SHORT $LN9@GetInstanc
	cmp	BYTE PTR _bErrorOnFail$[esp+12], 0
	je	SHORT $LN9@GetInstanc

; 148  : 	{
; 149  : 		if(idx == 1)

	cmp	DWORD PTR _idx$[esp+12], 1
	jne	SHORT $LN1@GetInstanc

; 150  : 			luaL_error(L, "Not a valid instance.  Either the instance is NULL or you used '.' instead of ':'.");

	push	OFFSET $SG222950
	push	esi
	call	_luaL_error
	add	esp, 8
$LN1@GetInstanc:

; 151  : 		Derived::HandleMissingInstance(L);

	push	esi
	call	?HandleMissingInstance@CvLuaArea@@SAXPAUlua_State@@@Z ; CvLuaArea::HandleMissingInstance
	add	esp, 4
$LN9@GetInstanc:

; 152  : 	}
; 153  : 	return pkInstance;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 154  : }

	ret	0
?GetInstance@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAPAVCvArea@@PAUlua_State@@H_N@Z ENDP ; CvLuaScopedInstance<CvLuaArea,CvArea>::GetInstance
_TEXT	ENDS
PUBLIC	?Push@?$CvLuaScopedInstance@VCvLuaCity@@VCvCity@@@@SAXPAUlua_State@@PAVCvCity@@@Z ; CvLuaScopedInstance<CvLuaCity,CvCity>::Push
EXTRN	?PushMethods@CvLuaCity@@SAXPAUlua_State@@H@Z:PROC ; CvLuaCity::PushMethods
EXTRN	?GetTypeName@CvLuaCity@@SAPBDXZ:PROC		; CvLuaCity::GetTypeName
; Function compile flags: /Ogtpy
;	COMDAT ?Push@?$CvLuaScopedInstance@VCvLuaCity@@VCvCity@@@@SAXPAUlua_State@@PAVCvCity@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_pkType$ = 12						; size = 4
?Push@?$CvLuaScopedInstance@VCvLuaCity@@VCvCity@@@@SAXPAUlua_State@@PAVCvCity@@@Z PROC ; CvLuaScopedInstance<CvLuaCity,CvCity>::Push, COMDAT

; 39   : {

	push	edi

; 40   : 	//Pushing an instance involves more than just actually pushing a pointer into the
; 41   : 	//Lua stack.  There are some caching optimizations that are done as well as some
; 42   : 	//checks.
; 43   : 	//The first step is to load or create a global table <Typename> to store all member
; 44   : 	//methods and all pushed instances.  This conserves memory and offers faster pushing
; 45   : 	//speed.
; 46   : 	//If <Typename>.__instances[pkType] is not nil, return that value.
; 47   : 	//otherwise push a new instance and assign it to __instances.
; 48   : 
; 49   : 	//NOTE: Raw gets and sets are used as an optimization over using lua_[get,set]field
; 50   : 	if(pkType)

	mov	edi, DWORD PTR _pkType$[esp]
	test	edi, edi
	je	$LN4@Push@2
	push	ebx
	push	ebp
	push	esi

; 51   : 	{
; 52   : 		//const int t = lua_gettop(L);
; 53   : 
; 54   : 		lua_getglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaCity@@SAPBDXZ		; CvLuaCity::GetTypeName
	mov	esi, DWORD PTR _L$[esp+12]
	push	eax
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_getfield

; 55   : 		if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN7@Push@2

; 56   : 		{
; 57   : 			//Typename wasn't found, time to build it.
; 58   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 59   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 60   : 
; 61   : 			//Create weak __instances table.
; 62   : 			lua_pushstring(L, "__instances");

	push	OFFSET $SG222961
	push	esi
	call	_lua_pushstring

; 63   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 64   : 
; 65   : 			//Create __instances.mt
; 66   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 67   : 			lua_pushstring(L, "__mode");

	push	OFFSET $SG222962
	push	esi
	call	_lua_pushstring

; 68   : 			lua_pushstring(L, "v");

	push	OFFSET $SG222963
	push	esi
	call	_lua_pushstring
	add	esp, 68					; 00000044H

; 69   : 			lua_rawset(L, -3);				// mt.__mode = "v";

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 70   : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_setmetatable

; 71   : 
; 72   : 			lua_rawset(L, -3);				//type.__instances = t;

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 73   : 
; 74   : 
; 75   : 			lua_pushvalue(L, -1);

	push	-1
	push	esi
	call	_lua_pushvalue

; 76   : 			lua_setglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaCity@@SAPBDXZ		; CvLuaCity::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_setfield

; 77   : 
; 78   : 			Derived::PushMethods(L, lua_gettop(L));

	push	esi
	call	_lua_gettop
	push	eax
	push	esi
	call	?PushMethods@CvLuaCity@@SAXPAUlua_State@@H@Z ; CvLuaCity::PushMethods
	add	esp, 56					; 00000038H
$LN7@Push@2:

; 79   : 		}
; 80   : 		const int type_index = lua_gettop(L);

	push	esi
	call	_lua_gettop

; 81   : 
; 82   : 		lua_pushstring(L, "__instances");

	push	OFFSET $SG222965
	push	esi
	mov	ebx, eax
	call	_lua_pushstring

; 83   : 		lua_rawget(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_rawget

; 84   : 
; 85   : 		const int instances_index = lua_gettop(L);

	push	esi
	call	_lua_gettop

; 86   : 
; 87   : 		lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	mov	ebp, eax
	call	_lua_pushlightuserdata

; 88   : 
; 89   : 		lua_rawget(L, -2);					//retrieve type.__instances[pkType]

	push	-2					; fffffffeH
	push	esi
	call	_lua_rawget

; 90   : 
; 91   : 		if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 48					; 00000030H
	test	eax, eax
	jne	SHORT $LN2@Push@2

; 92   : 		{
; 93   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 94   : 
; 95   : 			//Push new instance
; 96   : 			lua_createtable(L, 0, 1);

	push	1
	push	0
	push	esi
	call	_lua_createtable

; 97   : 			lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	call	_lua_pushlightuserdata

; 98   : 			lua_setfield(L, -2, "__instance");

	push	OFFSET $SG222968
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 99   : 
; 100  : 			lua_createtable(L, 0, 1);			// create mt

	push	1
	push	0
	push	esi
	call	_lua_createtable

; 101  : 			lua_pushstring(L, "__index");

	push	OFFSET $SG222969
	push	esi
	call	_lua_pushstring

; 102  : 			lua_pushvalue(L, type_index);

	push	ebx
	push	esi
	call	_lua_pushvalue
	add	esp, 68					; 00000044H

; 103  : 			lua_rawset(L, -3);					// mt.__index = Type

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 104  : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_setmetatable

; 105  : 
; 106  : 			//Assign it in instances
; 107  : 			lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	call	_lua_pushlightuserdata

; 108  : 			lua_pushvalue(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_pushvalue

; 109  : 			lua_rawset(L, instances_index);				//__instances[pkType] = t;

	push	ebp
	push	esi
	call	_lua_rawset
	add	esp, 40					; 00000028H
$LN2@Push@2:

; 110  : 		}
; 111  : 
; 112  : 		//VERIFY(instances_index > type_index);
; 113  : 		lua_remove(L, instances_index);

	push	ebp
	push	esi
	call	_lua_remove

; 114  : 		lua_remove(L, type_index);

	push	ebx
	push	esi
	call	_lua_remove
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 122  : 	}
; 123  : }

	ret	0
$LN4@Push@2:

; 115  : 
; 116  : 		//const int dt = lua_gettop(L);
; 117  : 		//VERIFY(dt == t + 1)
; 118  : 	}
; 119  : 	else
; 120  : 	{
; 121  : 		lua_pushnil(L);

	mov	eax, DWORD PTR _L$[esp]
	push	eax
	call	_lua_pushnil
	add	esp, 4
	pop	edi

; 122  : 	}
; 123  : }

	ret	0
?Push@?$CvLuaScopedInstance@VCvLuaCity@@VCvCity@@@@SAXPAUlua_State@@PAVCvCity@@@Z ENDP ; CvLuaScopedInstance<CvLuaCity,CvCity>::Push
_TEXT	ENDS
PUBLIC	?DefaultHandleMissingInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@KAXPAUlua_State@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::DefaultHandleMissingInstance
; Function compile flags: /Ogtpy
;	COMDAT ?DefaultHandleMissingInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@KAXPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?DefaultHandleMissingInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@KAXPAUlua_State@@@Z PROC ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::DefaultHandleMissingInstance, COMDAT

; 165  : 	luaL_error(L, "Instance does not exist.");

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET $SG223027
	push	eax
	call	_luaL_error
	add	esp, 8

; 166  : }

	ret	0
?DefaultHandleMissingInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@KAXPAUlua_State@@@Z ENDP ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::DefaultHandleMissingInstance
_TEXT	ENDS
PUBLIC	?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::Push
EXTRN	?PushMethods@CvLuaUnit@@SAXPAUlua_State@@H@Z:PROC ; CvLuaUnit::PushMethods
EXTRN	?GetTypeName@CvLuaUnit@@SAPBDXZ:PROC		; CvLuaUnit::GetTypeName
; Function compile flags: /Ogtpy
;	COMDAT ?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_pkType$ = 12						; size = 4
?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z PROC ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::Push, COMDAT

; 39   : {

	push	edi

; 40   : 	//Pushing an instance involves more than just actually pushing a pointer into the
; 41   : 	//Lua stack.  There are some caching optimizations that are done as well as some
; 42   : 	//checks.
; 43   : 	//The first step is to load or create a global table <Typename> to store all member
; 44   : 	//methods and all pushed instances.  This conserves memory and offers faster pushing
; 45   : 	//speed.
; 46   : 	//If <Typename>.__instances[pkType] is not nil, return that value.
; 47   : 	//otherwise push a new instance and assign it to __instances.
; 48   : 
; 49   : 	//NOTE: Raw gets and sets are used as an optimization over using lua_[get,set]field
; 50   : 	if(pkType)

	mov	edi, DWORD PTR _pkType$[esp]
	test	edi, edi
	je	$LN4@Push@3
	push	ebx
	push	ebp
	push	esi

; 51   : 	{
; 52   : 		//const int t = lua_gettop(L);
; 53   : 
; 54   : 		lua_getglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaUnit@@SAPBDXZ		; CvLuaUnit::GetTypeName
	mov	esi, DWORD PTR _L$[esp+12]
	push	eax
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_getfield

; 55   : 		if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN7@Push@3

; 56   : 		{
; 57   : 			//Typename wasn't found, time to build it.
; 58   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 59   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 60   : 
; 61   : 			//Create weak __instances table.
; 62   : 			lua_pushstring(L, "__instances");

	push	OFFSET $SG223038
	push	esi
	call	_lua_pushstring

; 63   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 64   : 
; 65   : 			//Create __instances.mt
; 66   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 67   : 			lua_pushstring(L, "__mode");

	push	OFFSET $SG223039
	push	esi
	call	_lua_pushstring

; 68   : 			lua_pushstring(L, "v");

	push	OFFSET $SG223040
	push	esi
	call	_lua_pushstring
	add	esp, 68					; 00000044H

; 69   : 			lua_rawset(L, -3);				// mt.__mode = "v";

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 70   : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_setmetatable

; 71   : 
; 72   : 			lua_rawset(L, -3);				//type.__instances = t;

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 73   : 
; 74   : 
; 75   : 			lua_pushvalue(L, -1);

	push	-1
	push	esi
	call	_lua_pushvalue

; 76   : 			lua_setglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaUnit@@SAPBDXZ		; CvLuaUnit::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_setfield

; 77   : 
; 78   : 			Derived::PushMethods(L, lua_gettop(L));

	push	esi
	call	_lua_gettop
	push	eax
	push	esi
	call	?PushMethods@CvLuaUnit@@SAXPAUlua_State@@H@Z ; CvLuaUnit::PushMethods
	add	esp, 56					; 00000038H
$LN7@Push@3:

; 79   : 		}
; 80   : 		const int type_index = lua_gettop(L);

	push	esi
	call	_lua_gettop

; 81   : 
; 82   : 		lua_pushstring(L, "__instances");

	push	OFFSET $SG223042
	push	esi
	mov	ebx, eax
	call	_lua_pushstring

; 83   : 		lua_rawget(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_rawget

; 84   : 
; 85   : 		const int instances_index = lua_gettop(L);

	push	esi
	call	_lua_gettop

; 86   : 
; 87   : 		lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	mov	ebp, eax
	call	_lua_pushlightuserdata

; 88   : 
; 89   : 		lua_rawget(L, -2);					//retrieve type.__instances[pkType]

	push	-2					; fffffffeH
	push	esi
	call	_lua_rawget

; 90   : 
; 91   : 		if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 48					; 00000030H
	test	eax, eax
	jne	SHORT $LN2@Push@3

; 92   : 		{
; 93   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 94   : 
; 95   : 			//Push new instance
; 96   : 			lua_createtable(L, 0, 1);

	push	1
	push	0
	push	esi
	call	_lua_createtable

; 97   : 			lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	call	_lua_pushlightuserdata

; 98   : 			lua_setfield(L, -2, "__instance");

	push	OFFSET $SG223045
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 99   : 
; 100  : 			lua_createtable(L, 0, 1);			// create mt

	push	1
	push	0
	push	esi
	call	_lua_createtable

; 101  : 			lua_pushstring(L, "__index");

	push	OFFSET $SG223046
	push	esi
	call	_lua_pushstring

; 102  : 			lua_pushvalue(L, type_index);

	push	ebx
	push	esi
	call	_lua_pushvalue
	add	esp, 68					; 00000044H

; 103  : 			lua_rawset(L, -3);					// mt.__index = Type

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 104  : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_setmetatable

; 105  : 
; 106  : 			//Assign it in instances
; 107  : 			lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	call	_lua_pushlightuserdata

; 108  : 			lua_pushvalue(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_pushvalue

; 109  : 			lua_rawset(L, instances_index);				//__instances[pkType] = t;

	push	ebp
	push	esi
	call	_lua_rawset
	add	esp, 40					; 00000028H
$LN2@Push@3:

; 110  : 		}
; 111  : 
; 112  : 		//VERIFY(instances_index > type_index);
; 113  : 		lua_remove(L, instances_index);

	push	ebp
	push	esi
	call	_lua_remove

; 114  : 		lua_remove(L, type_index);

	push	ebx
	push	esi
	call	_lua_remove
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 122  : 	}
; 123  : }

	ret	0
$LN4@Push@3:

; 115  : 
; 116  : 		//const int dt = lua_gettop(L);
; 117  : 		//VERIFY(dt == t + 1)
; 118  : 	}
; 119  : 	else
; 120  : 	{
; 121  : 		lua_pushnil(L);

	mov	eax, DWORD PTR _L$[esp]
	push	eax
	call	_lua_pushnil
	add	esp, 4
	pop	edi

; 122  : 	}
; 123  : }

	ret	0
?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z ENDP ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::Push
_TEXT	ENDS
PUBLIC	?GetInstance@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAPAVCvUnit@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::GetInstance
EXTRN	?HandleMissingInstance@CvLuaUnit@@SAXPAUlua_State@@@Z:PROC ; CvLuaUnit::HandleMissingInstance
; Function compile flags: /Ogtpy
;	COMDAT ?GetInstance@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAPAVCvUnit@@PAUlua_State@@H_N@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
_bErrorOnFail$ = 16					; size = 1
?GetInstance@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAPAVCvUnit@@PAUlua_State@@H_N@Z PROC ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::GetInstance, COMDAT

; 127  : {

	push	ebx
	push	ebp
	push	esi

; 128  : 	const int stack_size = lua_gettop(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	mov	ebp, eax

; 129  : 	bool bFail = true;
; 130  : 
; 131  : 	InstanceType* pkInstance = NULL;
; 132  : 	if(lua_type(L, idx) == LUA_TTABLE)

	mov	eax, DWORD PTR _idx$[esp+16]
	push	eax
	push	esi
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN3@GetInstanc@2

; 133  : 	{
; 134  : 		lua_getfield(L, idx, "__instance");

	mov	ecx, DWORD PTR _idx$[esp+12]
	push	OFFSET $SG223061
	push	ecx
	push	esi
	call	_lua_getfield

; 135  : 		if(lua_type(L, -1) == LUA_TLIGHTUSERDATA)

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN3@GetInstanc@2

; 136  : 		{
; 137  : 			pkInstance = static_cast<InstanceType*>(lua_touserdata(L, -1));

	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8

; 138  : 			if(pkInstance)

	test	edi, edi
	je	SHORT $LN3@GetInstanc@2

; 139  : 			{
; 140  : 				bFail = false;

	xor	bl, bl
$LN3@GetInstanc@2:

; 141  : 			}
; 142  : 		}
; 143  : 	}
; 144  : 
; 145  : 	lua_settop(L, stack_size);

	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8

; 146  : 
; 147  : 	if(bFail && bErrorOnFail)

	test	bl, bl
	je	SHORT $LN9@GetInstanc@2
	cmp	BYTE PTR _bErrorOnFail$[esp+12], 0
	je	SHORT $LN9@GetInstanc@2

; 148  : 	{
; 149  : 		if(idx == 1)

	cmp	DWORD PTR _idx$[esp+12], 1
	jne	SHORT $LN1@GetInstanc@2

; 150  : 			luaL_error(L, "Not a valid instance.  Either the instance is NULL or you used '.' instead of ':'.");

	push	OFFSET $SG223067
	push	esi
	call	_luaL_error
	add	esp, 8
$LN1@GetInstanc@2:

; 151  : 		Derived::HandleMissingInstance(L);

	push	esi
	call	?HandleMissingInstance@CvLuaUnit@@SAXPAUlua_State@@@Z ; CvLuaUnit::HandleMissingInstance
	add	esp, 4
$LN9@GetInstanc@2:

; 152  : 	}
; 153  : 	return pkInstance;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 154  : }

	ret	0
?GetInstance@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAPAVCvUnit@@PAUlua_State@@H_N@Z ENDP ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::GetInstance
_TEXT	ENDS
PUBLIC	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ
_TEXT	SEGMENT
?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ PROC ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex, COMDAT

; 159  : 	return 2;

	mov	eax, 2

; 160  : }

	ret	0
?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ENDP ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvluaargtemplates.h
_TEXT	ENDS
;	COMDAT ??$pushValue@W4TeamTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4TeamTypes@@@Z
_TEXT	SEGMENT
??$pushValue@W4TeamTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4TeamTypes@@@Z PROC ; CvLuaArgs::pushValue<enum TeamTypes>, COMDAT
; _L$ = ecx
; _t$ = eax

; 31   : 		//This is pretty unsafe, but common.
; 32   : 		//Assume T is a poorly designed enum =(
; 33   : 		lua_pushinteger(L, t);

	push	eax
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 34   : 	}

	ret	0
??$pushValue@W4TeamTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4TeamTypes@@@Z ENDP ; CvLuaArgs::pushValue<enum TeamTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$toValue@PAVCvUnit@@@CvLuaArgs@@YAPAVCvUnit@@PAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@PAVCvUnit@@@CvLuaArgs@@YAPAVCvUnit@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<CvUnit *>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	ret	0
??$toValue@PAVCvUnit@@@CvLuaArgs@@YAPAVCvUnit@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<CvUnit *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum TeamTypes>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	ret	0
??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum TeamTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum PlayerTypes>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	ret	0
??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum PlayerTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$toValue@W4DirectionTypes@@@CvLuaArgs@@YA?AW4DirectionTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@W4DirectionTypes@@@CvLuaArgs@@YA?AW4DirectionTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum DirectionTypes>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	ret	0
??$toValue@W4DirectionTypes@@@CvLuaArgs@@YA?AW4DirectionTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum DirectionTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$toValue@W4ResourceTypes@@@CvLuaArgs@@YA?AW4ResourceTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@W4ResourceTypes@@@CvLuaArgs@@YA?AW4ResourceTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum ResourceTypes>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	ret	0
??$toValue@W4ResourceTypes@@@CvLuaArgs@@YA?AW4ResourceTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum ResourceTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$toValue@W4ImprovementTypes@@@CvLuaArgs@@YA?AW4ImprovementTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@W4ImprovementTypes@@@CvLuaArgs@@YA?AW4ImprovementTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum ImprovementTypes>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	ret	0
??$toValue@W4ImprovementTypes@@@CvLuaArgs@@YA?AW4ImprovementTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum ImprovementTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$toValue@W4BuildTypes@@@CvLuaArgs@@YA?AW4BuildTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@W4BuildTypes@@@CvLuaArgs@@YA?AW4BuildTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum BuildTypes>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	ret	0
??$toValue@W4BuildTypes@@@CvLuaArgs@@YA?AW4BuildTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum BuildTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$toValue@PBVCvUnit@@@CvLuaArgs@@YAPBVCvUnit@@PAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@PBVCvUnit@@@CvLuaArgs@@YAPBVCvUnit@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<CvUnit const *>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	ret	0
??$toValue@PBVCvUnit@@@CvLuaArgs@@YAPBVCvUnit@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<CvUnit const *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$toValue@PBVCvPlot@@@CvLuaArgs@@YAPBVCvPlot@@PAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@PBVCvPlot@@@CvLuaArgs@@YAPBVCvPlot@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<CvPlot const *>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	ret	0
??$toValue@PBVCvPlot@@@CvLuaArgs@@YAPBVCvPlot@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<CvPlot const *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$toValue@W4FlowDirectionTypes@@@CvLuaArgs@@YA?AW4FlowDirectionTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@W4FlowDirectionTypes@@@CvLuaArgs@@YA?AW4FlowDirectionTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum FlowDirectionTypes>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	ret	0
??$toValue@W4FlowDirectionTypes@@@CvLuaArgs@@YA?AW4FlowDirectionTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum FlowDirectionTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$pushValue@W4FlowDirectionTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4FlowDirectionTypes@@@Z
_TEXT	SEGMENT
??$pushValue@W4FlowDirectionTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4FlowDirectionTypes@@@Z PROC ; CvLuaArgs::pushValue<enum FlowDirectionTypes>, COMDAT
; _L$ = ecx
; _t$ = eax

; 31   : 		//This is pretty unsafe, but common.
; 32   : 		//Assume T is a poorly designed enum =(
; 33   : 		lua_pushinteger(L, t);

	push	eax
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 34   : 	}

	ret	0
??$pushValue@W4FlowDirectionTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4FlowDirectionTypes@@@Z ENDP ; CvLuaArgs::pushValue<enum FlowDirectionTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$toValue@PAVCvArea@@@CvLuaArgs@@YAPAVCvArea@@PAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@PAVCvArea@@@CvLuaArgs@@YAPAVCvArea@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<CvArea *>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	ret	0
??$toValue@PAVCvArea@@@CvLuaArgs@@YAPAVCvArea@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<CvArea *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$pushValue@W4PlayerTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
??$pushValue@W4PlayerTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4PlayerTypes@@@Z PROC ; CvLuaArgs::pushValue<enum PlayerTypes>, COMDAT
; _L$ = ecx
; _t$ = eax

; 31   : 		//This is pretty unsafe, but common.
; 32   : 		//Assume T is a poorly designed enum =(
; 33   : 		lua_pushinteger(L, t);

	push	eax
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 34   : 	}

	ret	0
??$pushValue@W4PlayerTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4PlayerTypes@@@Z ENDP ; CvLuaArgs::pushValue<enum PlayerTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$pushValue@W4PlotTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4PlotTypes@@@Z
_TEXT	SEGMENT
??$pushValue@W4PlotTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4PlotTypes@@@Z PROC ; CvLuaArgs::pushValue<enum PlotTypes>, COMDAT
; _L$ = ecx
; _t$ = eax

; 31   : 		//This is pretty unsafe, but common.
; 32   : 		//Assume T is a poorly designed enum =(
; 33   : 		lua_pushinteger(L, t);

	push	eax
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 34   : 	}

	ret	0
??$pushValue@W4PlotTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4PlotTypes@@@Z ENDP ; CvLuaArgs::pushValue<enum PlotTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$toValue@W4PlotTypes@@@CvLuaArgs@@YA?AW4PlotTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@W4PlotTypes@@@CvLuaArgs@@YA?AW4PlotTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum PlotTypes>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	ret	0
??$toValue@W4PlotTypes@@@CvLuaArgs@@YA?AW4PlotTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum PlotTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$pushValue@W4ResourceTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4ResourceTypes@@@Z
_TEXT	SEGMENT
??$pushValue@W4ResourceTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4ResourceTypes@@@Z PROC ; CvLuaArgs::pushValue<enum ResourceTypes>, COMDAT
; _L$ = ecx
; _t$ = eax

; 31   : 		//This is pretty unsafe, but common.
; 32   : 		//Assume T is a poorly designed enum =(
; 33   : 		lua_pushinteger(L, t);

	push	eax
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 34   : 	}

	ret	0
??$pushValue@W4ResourceTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4ResourceTypes@@@Z ENDP ; CvLuaArgs::pushValue<enum ResourceTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$pushValue@W4ImprovementTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4ImprovementTypes@@@Z
_TEXT	SEGMENT
??$pushValue@W4ImprovementTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4ImprovementTypes@@@Z PROC ; CvLuaArgs::pushValue<enum ImprovementTypes>, COMDAT
; _L$ = ecx
; _t$ = eax

; 31   : 		//This is pretty unsafe, but common.
; 32   : 		//Assume T is a poorly designed enum =(
; 33   : 		lua_pushinteger(L, t);

	push	eax
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 34   : 	}

	ret	0
??$pushValue@W4ImprovementTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4ImprovementTypes@@@Z ENDP ; CvLuaArgs::pushValue<enum ImprovementTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$pushValue@W4RouteTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4RouteTypes@@@Z
_TEXT	SEGMENT
??$pushValue@W4RouteTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4RouteTypes@@@Z PROC ; CvLuaArgs::pushValue<enum RouteTypes>, COMDAT
; _L$ = ecx
; _t$ = eax

; 31   : 		//This is pretty unsafe, but common.
; 32   : 		//Assume T is a poorly designed enum =(
; 33   : 		lua_pushinteger(L, t);

	push	eax
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 34   : 	}

	ret	0
??$pushValue@W4RouteTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4RouteTypes@@@Z ENDP ; CvLuaArgs::pushValue<enum RouteTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$toValue@W4RouteTypes@@@CvLuaArgs@@YA?AW4RouteTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@W4RouteTypes@@@CvLuaArgs@@YA?AW4RouteTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum RouteTypes>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	ret	0
??$toValue@W4RouteTypes@@@CvLuaArgs@@YA?AW4RouteTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum RouteTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$toValue@W4YieldTypes@@@CvLuaArgs@@YA?AW4YieldTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@W4YieldTypes@@@CvLuaArgs@@YA?AW4YieldTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum YieldTypes>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	ret	0
??$toValue@W4YieldTypes@@@CvLuaArgs@@YA?AW4YieldTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum YieldTypes>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$toValue@W4InvisibleTypes@@@CvLuaArgs@@YA?AW4InvisibleTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
??$toValue@W4InvisibleTypes@@@CvLuaArgs@@YA?AW4InvisibleTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum InvisibleTypes>, COMDAT
; _L$ = ecx
; _idx$ = eax

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	push	eax
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	ret	0
??$toValue@W4InvisibleTypes@@@CvLuaArgs@@YA?AW4InvisibleTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum InvisibleTypes>
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ	; CvPlot::getPlotType
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ
_TEXT	SEGMENT
?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ PROC		; CvPlot::getPlotType, COMDAT
; _this$ = ecx

; 405  : 		return (PlotTypes)m_ePlotType;

	movsx	eax, BYTE PTR [ecx+5]

; 406  : 	}

	ret	0
?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ ENDP		; CvPlot::getPlotType
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?isHills@CvPlot@@QBE_NXZ			; CvPlot::isHills
; Function compile flags: /Ogtpy
;	COMDAT ?isHills@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isHills@CvPlot@@QBE_NXZ PROC				; CvPlot::isHills, COMDAT
; _this$ = ecx

; 413  : 		return (PlotTypes)m_ePlotType == PLOT_HILLS;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 1
	sete	al

; 414  : 	};

	ret	0
?isHills@CvPlot@@QBE_NXZ ENDP				; CvPlot::isHills
_TEXT	ENDS
PUBLIC	?isOpenGround@CvPlot@@QBE_NXZ			; CvPlot::isOpenGround
; Function compile flags: /Ogtpy
;	COMDAT ?isOpenGround@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isOpenGround@CvPlot@@QBE_NXZ PROC			; CvPlot::isOpenGround, COMDAT
; _this$ = ecx

; 417  : 		if((PlotTypes)m_ePlotType == PLOT_HILLS || (PlotTypes)m_ePlotType == PLOT_MOUNTAIN || m_bRoughFeature) return false;

	mov	al, BYTE PTR [ecx+5]
	cmp	al, 1
	je	SHORT $LN1@isOpenGrou
	test	al, al
	je	SHORT $LN1@isOpenGrou
	test	BYTE PTR [ecx+462], 8
	jne	SHORT $LN1@isOpenGrou

; 418  : 		return true;

	mov	al, 1

; 419  : 	}

	ret	0
$LN1@isOpenGrou:

; 417  : 		if((PlotTypes)m_ePlotType == PLOT_HILLS || (PlotTypes)m_ePlotType == PLOT_MOUNTAIN || m_bRoughFeature) return false;

	xor	al, al

; 419  : 	}

	ret	0
?isOpenGround@CvPlot@@QBE_NXZ ENDP			; CvPlot::isOpenGround
_TEXT	ENDS
PUBLIC	?isMountain@CvPlot@@QBE_NXZ			; CvPlot::isMountain
; Function compile flags: /Ogtpy
;	COMDAT ?isMountain@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isMountain@CvPlot@@QBE_NXZ PROC			; CvPlot::isMountain, COMDAT
; _this$ = ecx

; 422  : 		return (PlotTypes)m_ePlotType == PLOT_MOUNTAIN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], al
	sete	al

; 423  : 	};

	ret	0
?isMountain@CvPlot@@QBE_NXZ ENDP			; CvPlot::isMountain
_TEXT	ENDS
PUBLIC	?isRiver@CvPlot@@QBE_NXZ			; CvPlot::isRiver
; Function compile flags: /Ogtpy
;	COMDAT ?isRiver@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isRiver@CvPlot@@QBE_NXZ PROC				; CvPlot::isRiver, COMDAT
; _this$ = ecx

; 426  : 		return m_iRiverCrossingCount > 0;

	xor	eax, eax
	cmp	BYTE PTR [ecx+457], al
	setg	al

; 427  : 	}

	ret	0
?isRiver@CvPlot@@QBE_NXZ ENDP				; CvPlot::isRiver
_TEXT	ENDS
PUBLIC	?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ	; CvPlot::getTerrainType
; Function compile flags: /Ogtpy
;	COMDAT ?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ
_TEXT	SEGMENT
?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ PROC	; CvPlot::getTerrainType, COMDAT
; _this$ = ecx

; 431  : 		return (TerrainTypes)m_eTerrainType;

	movsx	eax, BYTE PTR [ecx+6]

; 432  : 	}

	ret	0
?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ ENDP	; CvPlot::getTerrainType
_TEXT	ENDS
PUBLIC	?isImpassable@CvPlot@@QBE_NXZ			; CvPlot::isImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?isImpassable@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isImpassable@CvPlot@@QBE_NXZ PROC			; CvPlot::isImpassable, COMDAT
; _this$ = ecx

; 444  : 		return m_bIsImpassable;

	mov	al, BYTE PTR [ecx+462]
	shr	al, 7

; 445  : 	}

	ret	0
?isImpassable@CvPlot@@QBE_NXZ ENDP			; CvPlot::isImpassable
_TEXT	ENDS
PUBLIC	?isRoughGround@CvPlot@@QBE_NXZ			; CvPlot::isRoughGround
; Function compile flags: /Ogtpy
;	COMDAT ?isRoughGround@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isRoughGround@CvPlot@@QBE_NXZ PROC			; CvPlot::isRoughGround, COMDAT
; _this$ = ecx

; 453  : 		if(isHills())

	mov	al, BYTE PTR [ecx+5]
	cmp	al, 1
	jne	SHORT $LN2@isRoughGro
$LN9@isRoughGro:

; 454  : 		{
; 455  : 			return true;

	mov	al, 1

; 463  : 	}

	ret	0
$LN2@isRoughGro:

; 456  : 		}
; 457  : 		if(isMountain())

	test	al, al

; 458  : 		{
; 459  : 			return true;

	je	SHORT $LN9@isRoughGro

; 460  : 		}
; 461  : 
; 462  : 		return m_bRoughFeature;

	mov	al, BYTE PTR [ecx+462]
	shr	al, 3
	and	al, 1

; 463  : 	}

	ret	0
?isRoughGround@CvPlot@@QBE_NXZ ENDP			; CvPlot::isRoughGround
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::getVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::getVisibilityCount, COMDAT
; _this$ = ecx

; 588  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 589  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 590  : 
; 591  : 		return m_aiVisibilityCount[eTeam];

	mov	eax, DWORD PTR [ecx+156]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 592  : 	}

	ret	4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::getVisibilityCount
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ
_TEXT	SEGMENT
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ PROC		; FAutoVariable<char,CvPlot>::operator char const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ ENDP		; FAutoVariable<char,CvPlot>::operator char const &
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z	; directionXY
; Function compile flags: /Ogtpy
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@HHHH@Z
_TEXT	SEGMENT
_iSourceX$ = 8						; size = 4
_iSourceY$ = 12						; size = 4
_iDestX$ = 16						; size = 4
_iDestY$ = 20						; size = 4
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z PROC		; directionXY, COMDAT

; 264  : {

	push	ebx

; 265  : 	int iSourceHexX = xToHexspaceX(iSourceX, iSourceY);

	mov	ebx, DWORD PTR _iSourceY$[esp]
	push	esi
	push	edi
	test	ebx, ebx
	jl	SHORT $LN17@directionX
	mov	eax, ebx
	jmp	SHORT $LN51@directionX
$LN17@directionX:
	lea	eax, DWORD PTR [ebx-1]
	cdq
	sub	eax, edx
$LN51@directionX:
	mov	esi, DWORD PTR _iSourceX$[esp+8]

; 266  : 	int iDestHexX = xToHexspaceX(iDestX, iDestY);

	mov	edi, DWORD PTR _iDestY$[esp+8]
	sar	eax, 1
	sub	esi, eax
	test	edi, edi
	jl	SHORT $LN21@directionX
	mov	eax, edi
	jmp	SHORT $LN52@directionX
$LN21@directionX:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN52@directionX:

; 267  : 
; 268  : 	int iWrappedXOffset = dxWrap(iDestHexX - iSourceHexX);

	mov	ecx, DWORD PTR _iDestX$[esp+8]
	sar	eax, 1
	sub	ecx, eax
	sub	ecx, esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [esi+4056], 0
	mov	edx, DWORD PTR [esi+4020]
	je	SHORT $LN31@directionX
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN33@directionX
	sub	ecx, edx
	jmp	SHORT $LN31@directionX
$LN33@directionX:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN35@directionX
$LN31@directionX:
	mov	eax, ecx
$LN35@directionX:

; 269  : 	int iWrappedYOffset = dyWrap(iDestY - iSourceY);

	sub	edi, ebx
	cmp	BYTE PTR [esi+4057], 0
	mov	edx, edi
	mov	edi, DWORD PTR [esi+4024]
	je	SHORT $LN45@directionX
	mov	esi, edi
	shr	esi, 1
	cmp	edx, esi
	jle	SHORT $LN47@directionX
	sub	edx, edi
	jmp	SHORT $LN45@directionX
$LN47@directionX:
	neg	esi
	cmp	edx, esi
	jge	SHORT $LN45@directionX
	add	edx, edi
$LN45@directionX:
	pop	edi
	pop	esi
	pop	ebx

; 270  : 
; 271  : 	if(iWrappedYOffset > 0)

	test	edx, edx
	jle	SHORT $LN53@directionX

; 272  : 	{
; 273  : 		if(iWrappedXOffset >= 0)

	xor	ecx, ecx
	test	eax, eax
	setge	cl
	dec	ecx
	and	ecx, 5
	mov	eax, ecx

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
$LN53@directionX:

; 274  : 		{
; 275  : 			return DIRECTION_NORTHEAST;
; 276  : 		}
; 277  : 		else
; 278  : 		{
; 279  : 			return DIRECTION_NORTHWEST;
; 280  : 		}
; 281  : 	}
; 282  : 	else if(iWrappedYOffset == 0)

	jne	SHORT $LN8@directionX

; 283  : 	{
; 284  : 		if(iWrappedXOffset > 0)

	test	eax, eax
	jle	SHORT $LN7@directionX

; 285  : 		{
; 286  : 			return DIRECTION_EAST;

	mov	eax, 1

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
$LN7@directionX:

; 287  : 		}
; 288  : 		else if(iWrappedXOffset == 0)

	neg	eax
	sbb	eax, eax
	and	eax, 5
	dec	eax

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
$LN8@directionX:

; 289  : 		{
; 290  : 			return NO_DIRECTION;
; 291  : 		}
; 292  : 		else
; 293  : 		{
; 294  : 			return DIRECTION_WEST;
; 295  : 		}
; 296  : 	}
; 297  : 	else// if (iWrappedYOffset < 0)
; 298  : 	{
; 299  : 		if(iWrappedXOffset > 0)

	xor	edx, edx
	test	eax, eax
	setle	dl
	add	edx, 2
	mov	eax, edx

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ENDP		; directionXY
_TEXT	ENDS
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
; Function compile flags: /Ogtpy
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z
_TEXT	SEGMENT
_pFromPlot$ = 8						; size = 4
_pToPlot$ = 12						; size = 4
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z PROC	; directionXY, COMDAT

; 312  : 	return directionXY(pFromPlot->getX(), pFromPlot->getY(),
; 313  : 	                   pToPlot->getX(), pToPlot->getY());

	mov	eax, DWORD PTR _pToPlot$[esp-4]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	mov	eax, DWORD PTR _pFromPlot$[esp-4]
	push	ecx
	movsx	ecx, WORD PTR [eax+2]
	push	edx
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	call	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ; directionXY
	add	esp, 16					; 00000010H

; 314  : 
; 315  : }

	ret	0
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ENDP	; directionXY
_TEXT	ENDS
PUBLIC	?HandleMissingInstance@CvLuaPlot@@SAXPAUlua_State@@@Z ; CvLuaPlot::HandleMissingInstance
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaplot.cpp
;	COMDAT ?HandleMissingInstance@CvLuaPlot@@SAXPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?HandleMissingInstance@CvLuaPlot@@SAXPAUlua_State@@@Z PROC ; CvLuaPlot::HandleMissingInstance, COMDAT

; 278  : 	DefaultHandleMissingInstance(L);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET $SG223027
	push	eax
	call	_luaL_error
	add	esp, 8

; 279  : }

	ret	0
?HandleMissingInstance@CvLuaPlot@@SAXPAUlua_State@@@Z ENDP ; CvLuaPlot::HandleMissingInstance
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\lua\cvluascopedinstance.h
;	COMDAT ?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
_bErrorOnFail$ = 16					; size = 1
?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z PROC ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance, COMDAT

; 127  : {

	push	ebx
	push	ebp
	push	esi

; 128  : 	const int stack_size = lua_gettop(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	mov	ebp, eax

; 129  : 	bool bFail = true;
; 130  : 
; 131  : 	InstanceType* pkInstance = NULL;
; 132  : 	if(lua_type(L, idx) == LUA_TTABLE)

	mov	eax, DWORD PTR _idx$[esp+16]
	push	eax
	push	esi
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN3@GetInstanc@3

; 133  : 	{
; 134  : 		lua_getfield(L, idx, "__instance");

	mov	ecx, DWORD PTR _idx$[esp+12]
	push	OFFSET $SG223013
	push	ecx
	push	esi
	call	_lua_getfield

; 135  : 		if(lua_type(L, -1) == LUA_TLIGHTUSERDATA)

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN3@GetInstanc@3

; 136  : 		{
; 137  : 			pkInstance = static_cast<InstanceType*>(lua_touserdata(L, -1));

	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8

; 138  : 			if(pkInstance)

	test	edi, edi
	je	SHORT $LN3@GetInstanc@3

; 139  : 			{
; 140  : 				bFail = false;

	xor	bl, bl
$LN3@GetInstanc@3:

; 141  : 			}
; 142  : 		}
; 143  : 	}
; 144  : 
; 145  : 	lua_settop(L, stack_size);

	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8

; 146  : 
; 147  : 	if(bFail && bErrorOnFail)

	test	bl, bl
	je	SHORT $LN13@GetInstanc@3
	cmp	BYTE PTR _bErrorOnFail$[esp+12], 0
	je	SHORT $LN13@GetInstanc@3

; 148  : 	{
; 149  : 		if(idx == 1)

	cmp	DWORD PTR _idx$[esp+12], 1
	jne	SHORT $LN1@GetInstanc@3

; 150  : 			luaL_error(L, "Not a valid instance.  Either the instance is NULL or you used '.' instead of ':'.");

	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	add	esp, 8
$LN1@GetInstanc@3:

; 151  : 		Derived::HandleMissingInstance(L);

	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 8
$LN13@GetInstanc@3:

; 152  : 	}
; 153  : 	return pkInstance;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 154  : }

	ret	0
?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ENDP ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvluamethodwrapper.h
;	COMDAT ??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>, COMDAT

; 230  : {

	push	ebx
	push	ebp
	push	esi

; 231  : 	const int idx = Derived::GetStartingArgIndex();
; 232  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe
	xor	bl, bl
$LN7@BasicLuaMe:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe:

; 233  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx));

	push	2
	push	esi
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	al
	movzx	ecx, al
	push	ecx
	mov	ecx, edi
	call	DWORD PTR _func$[esp+16]
	pop	edi
	pop	esi
	pop	ebp

; 234  : 	return 0;

	xor	eax, eax
	pop	ebx

; 235  : }

	ret	0
??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4TeamTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4TeamTypes@@XZ@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4TeamTypes@@XZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes>, COMDAT

; 69   : {

	push	ebx
	push	ebp
	push	esi

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@BasicLuaMe@2
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@BasicLuaMe@2
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@BasicLuaMe@2
	xor	bl, bl
$LN5@BasicLuaMe@2:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@BasicLuaMe@2
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@BasicLuaMe@2:

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, edi
	call	DWORD PTR _func$[esp+12]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 72   : 
; 73   : 	return 1;

	mov	eax, 1
	pop	ebx

; 74   : }

	ret	0
??$BasicLuaMethod@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4TeamTypes@@XZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HPAVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXHPAVCvUnit@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HPAVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXHPAVCvUnit@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HPAVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXHPAVCvUnit@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit *>, COMDAT

; 239  : {

	push	ebx
	push	ebp
	push	esi

; 240  : 	const int idx = Derived::GetStartingArgIndex();
; 241  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@3
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@3
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@3
	xor	bl, bl
$LN7@BasicLuaMe@3:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@3
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@3:

; 242  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1));

	push	3
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+20]
	pop	edi
	pop	esi
	pop	ebp

; 243  : 	return 0;

	xor	eax, eax
	pop	ebx

; 244  : }

	ret	0
??$BasicLuaMethod@HPAVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXHPAVCvUnit@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit *>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>, COMDAT

; 69   : {

	push	ebx
	push	ebp
	push	esi

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@BasicLuaMe@4
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@BasicLuaMe@4
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@BasicLuaMe@4
	xor	bl, bl
$LN5@BasicLuaMe@4:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@BasicLuaMe@4
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@BasicLuaMe@4:

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, edi
	call	DWORD PTR _func$[esp+12]
	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 72   : 
; 73   : 	return 1;

	mov	eax, 1
	pop	ebx

; 74   : }

	ret	0
??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NH@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NH@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int>, COMDAT

; 78   : {

	push	ebx
	push	ebp
	push	esi

; 79   : 	const int idx = Derived::GetStartingArgIndex();
; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@5
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@5
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@5
	xor	bl, bl
$LN7@BasicLuaMe@5:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@5
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@5:

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+16]
	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 82   : 
; 83   : 	return 1;

	mov	eax, 1
	pop	ebx

; 84   : }

	ret	0
??$BasicLuaMethod@_NH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NH@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4TeamTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NW4TeamTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4TeamTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum PlayerTypes>, COMDAT

; 88   : {

	push	ebx
	push	ebp
	push	esi

; 89   : 	const int idx = Derived::GetStartingArgIndex();
; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@6
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@6
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@6
	xor	bl, bl
$LN7@BasicLuaMe@6:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@6
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@6:

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	push	3
	push	esi
	call	_lua_tointeger
	push	2
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	add	esp, 16					; 00000010H
	push	ebx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+20]
	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 92   : 
; 93   : 	return 1;

	mov	eax, 1
	pop	ebx

; 94   : }

	ret	0
??$BasicLuaMethod@_NW4TeamTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4DirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4DirectionTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum DirectionTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NW4DirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4DirectionTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4DirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4DirectionTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum DirectionTypes>, COMDAT

; 78   : {

	push	ebx
	push	ebp
	push	esi

; 79   : 	const int idx = Derived::GetStartingArgIndex();
; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@7
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@7
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@7
	xor	bl, bl
$LN7@BasicLuaMe@7:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@7
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@7:

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+16]
	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 82   : 
; 83   : 	return 1;

	mov	eax, 1
	pop	ebx

; 84   : }

	ret	0
??$BasicLuaMethod@_NW4DirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4DirectionTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum DirectionTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>, COMDAT

; 69   : {

	push	ebx
	push	ebp
	push	esi

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@BasicLuaMe@8
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@BasicLuaMe@8
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@BasicLuaMe@8
	xor	bl, bl
$LN5@BasicLuaMe@8:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@BasicLuaMe@8
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@BasicLuaMe@8:

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, edi
	call	DWORD PTR _func$[esp+12]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 72   : 
; 73   : 	return 1;

	mov	eax, 1
	pop	ebx

; 74   : }

	ret	0
??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes>, COMDAT

; 78   : {

	push	ebx
	push	ebp
	push	esi

; 79   : 	const int idx = Derived::GetStartingArgIndex();
; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@9
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@9
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@9
	xor	bl, bl
$LN7@BasicLuaMe@9:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@9
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@9:

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+16]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 82   : 
; 83   : 	return 1;

	mov	eax, 1
	pop	ebx

; 84   : }

	ret	0
??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEH_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEH_N@Z@Z
_TEXT	SEGMENT
$T224670 = -4						; size = 1
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEH_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,bool>, COMDAT

; 78   : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 79   : 	const int idx = Derived::GetStartingArgIndex();
; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@10
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@10
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@10
	xor	bl, bl
$LN7@BasicLuaMe@10:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@10
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@10:

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	push	2
	push	esi
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	al
	mov	BYTE PTR $T224670[esp+20], al
	mov	ecx, DWORD PTR $T224670[esp+20]
	push	ecx
	mov	ecx, edi
	call	DWORD PTR _func$[esp+20]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 82   : 
; 83   : 	return 1;

	mov	eax, 1
	pop	ebx

; 84   : }

	pop	ecx
	ret	0
??$BasicLuaMethod@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEH_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,bool>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4ResourceTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ResourceTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ResourceTypes,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NW4ResourceTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ResourceTypes@@_N@Z@Z
_TEXT	SEGMENT
$T224707 = -4						; size = 1
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4ResourceTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ResourceTypes@@_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ResourceTypes,bool>, COMDAT

; 88   : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 89   : 	const int idx = Derived::GetStartingArgIndex();
; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@11
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@11
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@11
	xor	bl, bl
$LN7@BasicLuaMe@11:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@11
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@11:

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	push	3
	push	esi
	call	_lua_toboolean
	test	eax, eax
	setne	al
	push	2
	push	esi
	mov	BYTE PTR $T224707[esp+36], al
	call	_lua_tointeger
	mov	ecx, DWORD PTR $T224707[esp+36]
	add	esp, 16					; 00000010H
	push	ecx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+24]
	movzx	edx, al
	push	edx
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 92   : 
; 93   : 	return 1;

	mov	eax, 1
	pop	ebx

; 94   : }

	pop	ecx
	ret	0
??$BasicLuaMethod@_NW4ResourceTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ResourceTypes@@_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ResourceTypes,bool>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4ImprovementTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ImprovementTypes,enum TeamTypes,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NW4ImprovementTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z@Z
_TEXT	SEGMENT
$T224748 = -4						; size = 1
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4ImprovementTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ImprovementTypes,enum TeamTypes,bool>, COMDAT

; 98   : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 99   : 	const int idx = Derived::GetStartingArgIndex();
; 100  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@12
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@12
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@12
	xor	bl, bl
$LN7@BasicLuaMe@12:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@12
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@12:

; 101  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2)));

	push	4
	push	esi
	call	_lua_toboolean
	test	eax, eax
	setne	al
	push	3
	push	esi
	mov	BYTE PTR $T224748[esp+36], al
	call	_lua_tointeger
	push	2
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	mov	ecx, DWORD PTR $T224748[esp+44]
	add	esp, 24					; 00000018H
	push	ecx
	push	ebx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+28]
	movzx	edx, al
	push	edx
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 102  : 
; 103  : 	return 1;

	mov	eax, 1
	pop	ebx

; 104  : }

	pop	ecx
	ret	0
??$BasicLuaMethod@_NW4ImprovementTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ImprovementTypes,enum TeamTypes,bool>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4BuildTypes@@W4PlayerTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4BuildTypes@@W4PlayerTypes@@_N3@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,enum PlayerTypes,bool,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NW4BuildTypes@@W4PlayerTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4BuildTypes@@W4PlayerTypes@@_N3@Z@Z
_TEXT	SEGMENT
$T224793 = -8						; size = 1
$T224797 = -4						; size = 1
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4BuildTypes@@W4PlayerTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4BuildTypes@@W4PlayerTypes@@_N3@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,enum PlayerTypes,bool,bool>, COMDAT

; 108  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 109  : 	const int idx = Derived::GetStartingArgIndex();
; 110  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+16]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@13
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@13
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@13
	xor	bl, bl
$LN7@BasicLuaMe@13:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@13
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@13:

; 111  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2), CvLuaArgs::toValue<arg4>(L, idx + 3)));

	push	5
	push	esi
	call	_lua_toboolean
	test	eax, eax
	setne	al
	push	4
	push	esi
	mov	BYTE PTR $T224793[esp+40], al
	call	_lua_toboolean
	test	eax, eax
	setne	cl
	push	3
	push	esi
	mov	BYTE PTR $T224797[esp+48], cl
	call	_lua_tointeger
	push	2
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	mov	edx, DWORD PTR $T224793[esp+56]
	mov	ecx, DWORD PTR $T224797[esp+56]
	add	esp, 32					; 00000020H
	push	edx
	push	ecx
	push	ebx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+36]
	movzx	edx, al
	push	edx
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 112  : 
; 113  : 	return 1;

	mov	eax, 1
	pop	ebx

; 114  : }

	add	esp, 8
	ret	0
??$BasicLuaMethod@_NW4BuildTypes@@W4PlayerTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4BuildTypes@@W4PlayerTypes@@_N3@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,enum PlayerTypes,bool,bool>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes>, COMDAT

; 88   : {

	push	ebx
	push	ebp
	push	esi

; 89   : 	const int idx = Derived::GetStartingArgIndex();
; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@14
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@14
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@14
	xor	bl, bl
$LN7@BasicLuaMe@14:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@14
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@14:

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	push	3
	push	esi
	call	_lua_tointeger
	push	2
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	add	esp, 16					; 00000010H
	push	ebx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+20]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 92   : 
; 93   : 	return 1;

	mov	eax, 1
	pop	ebx

; 94   : }

	ret	0
??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@HH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@HH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes,int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@HH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@HH@Z@Z
_TEXT	SEGMENT
$T224891 = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@HH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@HH@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes,int,int>, COMDAT

; 108  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 109  : 	const int idx = Derived::GetStartingArgIndex();
; 110  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@15
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@15
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@15
	xor	bl, bl
$LN7@BasicLuaMe@15:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@15
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@15:

; 111  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2), CvLuaArgs::toValue<arg4>(L, idx + 3)));

	push	5
	push	esi
	call	_lua_tointeger
	push	4
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	push	3
	push	esi
	mov	ebp, eax
	call	_lua_tointeger
	push	2
	push	esi
	mov	DWORD PTR $T224891[esp+52], eax
	call	_lua_tointeger
	mov	ecx, DWORD PTR $T224891[esp+52]
	add	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	ecx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+32]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 112  : 
; 113  : 	return 1;

	mov	eax, 1
	pop	ebx

; 114  : }

	pop	ecx
	ret	0
??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@HH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@HH@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes,int,int>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>, COMDAT

; 78   : {

	push	ebx
	push	ebp
	push	esi

; 79   : 	const int idx = Derived::GetStartingArgIndex();
; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@16
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@16
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@16
	xor	bl, bl
$LN7@BasicLuaMe@16:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@16
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@16:

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+16]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 82   : 
; 83   : 	return 1;

	mov	eax, 1
	pop	ebx

; 84   : }

	ret	0
??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4TeamTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@_N2@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,bool,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HW4TeamTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@_N2@Z@Z
_TEXT	SEGMENT
$T224969 = -8						; size = 1
$T224973 = -4						; size = 1
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4TeamTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@_N2@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,bool,bool>, COMDAT

; 98   : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 99   : 	const int idx = Derived::GetStartingArgIndex();
; 100  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+16]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@17
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@17
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@17
	xor	bl, bl
$LN7@BasicLuaMe@17:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@17
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@17:

; 101  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2)));

	push	4
	push	esi
	call	_lua_toboolean
	test	eax, eax
	setne	al
	push	3
	push	esi
	mov	BYTE PTR $T224969[esp+40], al
	call	_lua_toboolean
	test	eax, eax
	setne	cl
	push	2
	push	esi
	mov	BYTE PTR $T224973[esp+48], cl
	call	_lua_tointeger
	mov	edx, DWORD PTR $T224969[esp+48]
	mov	ecx, DWORD PTR $T224973[esp+48]
	add	esp, 24					; 00000018H
	push	edx
	push	ecx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+32]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 102  : 
; 103  : 	return 1;

	mov	eax, 1
	pop	ebx

; 104  : }

	add	esp, 8
	ret	0
??$BasicLuaMethod@HW4TeamTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@_N2@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,bool,bool>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HPBVCvUnit@@PBVCvPlot@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@PBV2@H@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *,CvPlot const *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HPBVCvUnit@@PBVCvPlot@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@PBV2@H@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HPBVCvUnit@@PBVCvPlot@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@PBV2@H@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *,CvPlot const *,int>, COMDAT

; 98   : {

	push	ebx
	push	ebp
	push	esi

; 99   : 	const int idx = Derived::GetStartingArgIndex();
; 100  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@18
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@18
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@18
	xor	bl, bl
$LN7@BasicLuaMe@18:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@18
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@18:

; 101  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2)));

	push	4
	push	esi
	call	_lua_tointeger
	push	3
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	push	2
	push	esi
	mov	ebp, eax
	call	_lua_tointeger
	add	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+24]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 102  : 
; 103  : 	return 1;

	mov	eax, 1
	pop	ebx

; 104  : }

	ret	0
??$BasicLuaMethod@HPBVCvUnit@@PBVCvPlot@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@PBV2@H@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *,CvPlot const *,int>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>, COMDAT

; 230  : {

	push	ebx
	push	ebp
	push	esi

; 231  : 	const int idx = Derived::GetStartingArgIndex();
; 232  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@19
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@19
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@19
	xor	bl, bl
$LN7@BasicLuaMe@19:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@19
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@19:

; 233  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx));

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+16]
	pop	edi
	pop	esi
	pop	ebp

; 234  : 	return 0;

	xor	eax, eax
	pop	ebx

; 235  : }

	ret	0
??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4PlayerTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NW4PlayerTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@_N@Z@Z
_TEXT	SEGMENT
$T225091 = -4						; size = 1
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4PlayerTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes,bool>, COMDAT

; 88   : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 89   : 	const int idx = Derived::GetStartingArgIndex();
; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@20
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@20
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@20
	xor	bl, bl
$LN7@BasicLuaMe@20:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@20
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@20:

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	push	3
	push	esi
	call	_lua_toboolean
	test	eax, eax
	setne	al
	push	2
	push	esi
	mov	BYTE PTR $T225091[esp+36], al
	call	_lua_tointeger
	mov	ecx, DWORD PTR $T225091[esp+36]
	add	esp, 16					; 00000010H
	push	ecx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+24]
	movzx	edx, al
	push	edx
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 92   : 
; 93   : 	return 1;

	mov	eax, 1
	pop	ebx

; 94   : }

	pop	ecx
	ret	0
??$BasicLuaMethod@_NW4PlayerTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes,bool>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NW4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@_N@Z@Z
_TEXT	SEGMENT
$T225132 = -4						; size = 1
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,bool>, COMDAT

; 88   : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 89   : 	const int idx = Derived::GetStartingArgIndex();
; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@21
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@21
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@21
	xor	bl, bl
$LN7@BasicLuaMe@21:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@21
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@21:

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	push	3
	push	esi
	call	_lua_toboolean
	test	eax, eax
	setne	al
	push	2
	push	esi
	mov	BYTE PTR $T225132[esp+36], al
	call	_lua_tointeger
	mov	ecx, DWORD PTR $T225132[esp+36]
	add	esp, 16					; 00000010H
	push	ecx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+24]
	movzx	edx, al
	push	edx
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 92   : 
; 93   : 	return 1;

	mov	eax, 1
	pop	ebx

; 94   : }

	pop	ecx
	ret	0
??$BasicLuaMethod@_NW4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,bool>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NXZ@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NXZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>, COMDAT

; 121  : {

	push	ebx
	push	ebp
	push	esi

; 122  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@BasicLuaMe@22
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@BasicLuaMe@22
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@BasicLuaMe@22
	xor	bl, bl
$LN5@BasicLuaMe@22:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@BasicLuaMe@22
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@BasicLuaMe@22:

; 123  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, edi
	call	DWORD PTR _func$[esp+12]
	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 124  : 
; 125  : 	return 1;

	mov	eax, 1
	pop	ebx

; 126  : }

	ret	0
??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NXZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>, COMDAT

; 78   : {

	push	ebx
	push	ebp
	push	esi

; 79   : 	const int idx = Derived::GetStartingArgIndex();
; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@23
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@23
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@23
	xor	bl, bl
$LN7@BasicLuaMe@23:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@23
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@23:

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+16]
	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 82   : 
; 83   : 	return 1;

	mov	eax, 1
	pop	ebx

; 84   : }

	ret	0
??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HPBVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HPBVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HPBVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *>, COMDAT

; 78   : {

	push	ebx
	push	ebp
	push	esi

; 79   : 	const int idx = Derived::GetStartingArgIndex();
; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@24
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@24
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@24
	xor	bl, bl
$LN7@BasicLuaMe@24:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@24
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@24:

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+16]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 82   : 
; 83   : 	return 1;

	mov	eax, 1
	pop	ebx

; 84   : }

	ret	0
??$BasicLuaMethod@HPBVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>, COMDAT

; 78   : {

	push	ebx
	push	ebp
	push	esi

; 79   : 	const int idx = Derived::GetStartingArgIndex();
; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@25
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@25
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@25
	xor	bl, bl
$LN7@BasicLuaMe@25:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@25
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@25:

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+16]
	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 82   : 
; 83   : 	return 1;

	mov	eax, 1
	pop	ebx

; 84   : }

	ret	0
??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NHH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NHH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NHH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NHH@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NHH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NHH@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int,int>, COMDAT

; 88   : {

	push	ebx
	push	ebp
	push	esi

; 89   : 	const int idx = Derived::GetStartingArgIndex();
; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@26
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@26
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@26
	xor	bl, bl
$LN7@BasicLuaMe@26:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@26
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@26:

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	push	3
	push	esi
	call	_lua_tointeger
	push	2
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	add	esp, 16					; 00000010H
	push	ebx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+20]
	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 92   : 
; 93   : 	return 1;

	mov	eax, 1
	pop	ebx

; 94   : }

	ret	0
??$BasicLuaMethod@_NHH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NHH@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int,int>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4ImprovementTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum ImprovementTypes,enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HW4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4ImprovementTypes@@W4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4ImprovementTypes@@W4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum ImprovementTypes,enum PlayerTypes>, COMDAT

; 88   : {

	push	ebx
	push	ebp
	push	esi

; 89   : 	const int idx = Derived::GetStartingArgIndex();
; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@27
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@27
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@27
	xor	bl, bl
$LN7@BasicLuaMe@27:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@27
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@27:

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	push	3
	push	esi
	call	_lua_tointeger
	push	2
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	add	esp, 16					; 00000010H
	push	ebx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+20]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 92   : 
; 93   : 	return 1;

	mov	eax, 1
	pop	ebx

; 94   : }

	ret	0
??$BasicLuaMethod@HW4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4ImprovementTypes@@W4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum ImprovementTypes,enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_NW4FlowDirectionTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum FlowDirectionTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NW4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_NW4FlowDirectionTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_NW4FlowDirectionTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum FlowDirectionTypes>, COMDAT

; 239  : {

	push	ebx
	push	ebp
	push	esi

; 240  : 	const int idx = Derived::GetStartingArgIndex();
; 241  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@28
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@28
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@28
	xor	bl, bl
$LN7@BasicLuaMe@28:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@28
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@28:

; 242  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1));

	push	3
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	push	2
	push	esi
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	al
	movzx	ecx, al
	push	ecx
	mov	ecx, edi
	call	DWORD PTR _func$[esp+20]
	pop	edi
	pop	esi
	pop	ebp

; 243  : 	return 0;

	xor	eax, eax
	pop	ebx

; 244  : }

	ret	0
??$BasicLuaMethod@_NW4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_NW4FlowDirectionTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum FlowDirectionTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4FlowDirectionTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum FlowDirectionTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@W4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4FlowDirectionTypes@@XZ@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4FlowDirectionTypes@@XZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum FlowDirectionTypes>, COMDAT

; 69   : {

	push	ebx
	push	ebp
	push	esi

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@BasicLuaMe@29
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@BasicLuaMe@29
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@BasicLuaMe@29
	xor	bl, bl
$LN5@BasicLuaMe@29:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@BasicLuaMe@29
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@BasicLuaMe@29:

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, edi
	call	DWORD PTR _func$[esp+12]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 72   : 
; 73   : 	return 1;

	mov	eax, 1
	pop	ebx

; 74   : }

	ret	0
??$BasicLuaMethod@W4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4FlowDirectionTypes@@XZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum FlowDirectionTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NPAVCvArea@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NPAVCvArea@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,CvArea *>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NPAVCvArea@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NPAVCvArea@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NPAVCvArea@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NPAVCvArea@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,CvArea *>, COMDAT

; 78   : {

	push	ebx
	push	ebp
	push	esi

; 79   : 	const int idx = Derived::GetStartingArgIndex();
; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@30
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@30
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@30
	xor	bl, bl
$LN7@BasicLuaMe@30:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@30
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@30:

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+16]
	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 82   : 
; 83   : 	return 1;

	mov	eax, 1
	pop	ebx

; 84   : }

	ret	0
??$BasicLuaMethod@_NPAVCvArea@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NPAVCvArea@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,CvArea *>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlayerTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlayerTypes@@XZ@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlayerTypes@@XZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes>, COMDAT

; 69   : {

	push	ebx
	push	ebp
	push	esi

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@BasicLuaMe@31
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@BasicLuaMe@31
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@BasicLuaMe@31
	xor	bl, bl
$LN5@BasicLuaMe@31:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@BasicLuaMe@31
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@BasicLuaMe@31:

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, edi
	call	DWORD PTR _func$[esp+12]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 72   : 
; 73   : 	return 1;

	mov	eax, 1
	pop	ebx

; 74   : }

	ret	0
??$BasicLuaMethod@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlayerTypes@@XZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4PlayerTypes@@H_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlayerTypes@@H_N2@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes,int,bool,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@W4PlayerTypes@@H_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlayerTypes@@H_N2@Z@Z
_TEXT	SEGMENT
$T225529 = -8						; size = 1
$T225533 = -4						; size = 1
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4PlayerTypes@@H_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlayerTypes@@H_N2@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes,int,bool,bool>, COMDAT

; 259  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 260  : 	const int idx = Derived::GetStartingArgIndex();
; 261  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+16]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@32
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@32
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@32
	xor	bl, bl
$LN7@BasicLuaMe@32:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@32
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@32:

; 262  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2), CvLuaArgs::toValue<arg4>(L, idx + 3));

	push	5
	push	esi
	call	_lua_toboolean
	test	eax, eax
	setne	al
	push	4
	push	esi
	mov	BYTE PTR $T225529[esp+40], al
	call	_lua_toboolean
	test	eax, eax
	setne	cl
	push	3
	push	esi
	mov	BYTE PTR $T225533[esp+48], cl
	call	_lua_tointeger
	mov	edx, DWORD PTR $T225529[esp+48]
	mov	ecx, DWORD PTR $T225533[esp+48]
	add	esp, 24					; 00000018H
	push	edx
	push	ecx
	push	eax
	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+36]
	pop	edi
	pop	esi
	pop	ebp

; 263  : 	return 0;

	xor	eax, eax
	pop	ebx

; 264  : }

	add	esp, 8
	ret	0
??$BasicLuaMethod@W4PlayerTypes@@H_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlayerTypes@@H_N2@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes,int,bool,bool>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4PlotTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlotTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@W4PlotTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlotTypes@@XZ@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4PlotTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlotTypes@@XZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes>, COMDAT

; 69   : {

	push	ebx
	push	ebp
	push	esi

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@BasicLuaMe@33
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@BasicLuaMe@33
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@BasicLuaMe@33
	xor	bl, bl
$LN5@BasicLuaMe@33:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@BasicLuaMe@33
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@BasicLuaMe@33:

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, edi
	call	DWORD PTR _func$[esp+12]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 72   : 
; 73   : 	return 1;

	mov	eax, 1
	pop	ebx

; 74   : }

	ret	0
??$BasicLuaMethod@W4PlotTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlotTypes@@XZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4PlotTypes@@_N_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlotTypes@@_N22@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes,bool,bool,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@W4PlotTypes@@_N_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlotTypes@@_N22@Z@Z
_TEXT	SEGMENT
$T225603 = -12						; size = 1
$T225607 = -8						; size = 1
$T225611 = -4						; size = 1
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4PlotTypes@@_N_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlotTypes@@_N22@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes,bool,bool,bool>, COMDAT

; 259  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi

; 260  : 	const int idx = Derived::GetStartingArgIndex();
; 261  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+20]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@34
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@34
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@34
	xor	bl, bl
$LN7@BasicLuaMe@34:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@34
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@34:

; 262  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2), CvLuaArgs::toValue<arg4>(L, idx + 3));

	push	5
	push	esi
	call	_lua_toboolean
	test	eax, eax
	setne	al
	push	4
	push	esi
	mov	BYTE PTR $T225603[esp+44], al
	call	_lua_toboolean
	test	eax, eax
	setne	cl
	push	3
	push	esi
	mov	BYTE PTR $T225607[esp+52], cl
	call	_lua_toboolean
	mov	ecx, DWORD PTR $T225607[esp+52]
	add	esp, 24					; 00000018H
	test	eax, eax
	mov	eax, DWORD PTR $T225603[esp+28]
	setne	dl
	push	eax
	mov	BYTE PTR $T225611[esp+32], dl
	mov	edx, DWORD PTR $T225611[esp+32]
	push	ecx
	push	edx
	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+40]
	pop	edi
	pop	esi
	pop	ebp

; 263  : 	return 0;

	xor	eax, eax
	pop	ebx

; 264  : }

	add	esp, 12					; 0000000cH
	ret	0
??$BasicLuaMethod@W4PlotTypes@@_N_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlotTypes@@_N22@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes,bool,bool,bool>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4ResourceTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ResourceTypes@@W4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,enum TeamTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@W4ResourceTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ResourceTypes@@W4TeamTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4ResourceTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ResourceTypes@@W4TeamTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,enum TeamTypes>, COMDAT

; 78   : {

	push	ebx
	push	ebp
	push	esi

; 79   : 	const int idx = Derived::GetStartingArgIndex();
; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@35
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@35
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@35
	xor	bl, bl
$LN7@BasicLuaMe@35:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@35
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@35:

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+16]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 82   : 
; 83   : 	return 1;

	mov	eax, 1
	pop	ebx

; 84   : }

	ret	0
??$BasicLuaMethod@W4ResourceTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ResourceTypes@@W4TeamTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,enum TeamTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4ResourceTypes@@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ResourceTypes@@H_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,int,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@W4ResourceTypes@@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ResourceTypes@@H_N@Z@Z
_TEXT	SEGMENT
$T225684 = -4						; size = 1
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4ResourceTypes@@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ResourceTypes@@H_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,int,bool>, COMDAT

; 249  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 250  : 	const int idx = Derived::GetStartingArgIndex();
; 251  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@36
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@36
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@36
	xor	bl, bl
$LN7@BasicLuaMe@36:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@36
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@36:

; 252  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2));

	push	4
	push	esi
	call	_lua_toboolean
	test	eax, eax
	setne	al
	push	3
	push	esi
	mov	BYTE PTR $T225684[esp+36], al
	call	_lua_tointeger
	mov	ecx, DWORD PTR $T225684[esp+36]
	add	esp, 16					; 00000010H
	push	ecx
	push	eax
	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+28]
	pop	edi
	pop	esi
	pop	ebp

; 253  : 	return 0;

	xor	eax, eax
	pop	ebx

; 254  : }

	pop	ecx
	ret	0
??$BasicLuaMethod@W4ResourceTypes@@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ResourceTypes@@H_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,int,bool>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4ImprovementTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ImprovementTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@W4ImprovementTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ImprovementTypes@@XZ@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4ImprovementTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ImprovementTypes@@XZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes>, COMDAT

; 69   : {

	push	ebx
	push	ebp
	push	esi

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@BasicLuaMe@37
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@BasicLuaMe@37
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@BasicLuaMe@37
	xor	bl, bl
$LN5@BasicLuaMe@37:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@BasicLuaMe@37
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@BasicLuaMe@37:

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, edi
	call	DWORD PTR _func$[esp+12]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 72   : 
; 73   : 	return 1;

	mov	eax, 1
	pop	ebx

; 74   : }

	ret	0
??$BasicLuaMethod@W4ImprovementTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ImprovementTypes@@XZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ImprovementTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes,enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@W4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ImprovementTypes@@W4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ImprovementTypes@@W4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes,enum PlayerTypes>, COMDAT

; 239  : {

	push	ebx
	push	ebp
	push	esi

; 240  : 	const int idx = Derived::GetStartingArgIndex();
; 241  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@38
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@38
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@38
	xor	bl, bl
$LN7@BasicLuaMe@38:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@38
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@38:

; 242  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1));

	push	3
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+20]
	pop	edi
	pop	esi
	pop	ebp

; 243  : 	return 0;

	xor	eax, eax
	pop	ebx

; 244  : }

	ret	0
??$BasicLuaMethod@W4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ImprovementTypes@@W4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes,enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4RouteTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4RouteTypes@@XZ@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4RouteTypes@@XZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>, COMDAT

; 69   : {

	push	ebx
	push	ebp
	push	esi

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@BasicLuaMe@39
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@BasicLuaMe@39
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@BasicLuaMe@39
	xor	bl, bl
$LN5@BasicLuaMe@39:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@BasicLuaMe@39
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@BasicLuaMe@39:

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, edi
	call	DWORD PTR _func$[esp+12]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 72   : 
; 73   : 	return 1;

	mov	eax, 1
	pop	ebx

; 74   : }

	ret	0
??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4RouteTypes@@XZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4RouteTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4RouteTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4RouteTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>, COMDAT

; 230  : {

	push	ebx
	push	ebp
	push	esi

; 231  : 	const int idx = Derived::GetStartingArgIndex();
; 232  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@40
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@40
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@40
	xor	bl, bl
$LN7@BasicLuaMe@40:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@40
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@40:

; 233  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx));

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+16]
	pop	edi
	pop	esi
	pop	ebp

; 234  : 	return 0;

	xor	eax, eax
	pop	ebx

; 235  : }

	ret	0
??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4RouteTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@_N@Z@Z
_TEXT	SEGMENT
$T225852 = -4						; size = 1
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes,bool>, COMDAT

; 98   : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 99   : 	const int idx = Derived::GetStartingArgIndex();
; 100  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@41
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@41
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@41
	xor	bl, bl
$LN7@BasicLuaMe@41:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@41
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@41:

; 101  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2)));

	push	4
	push	esi
	call	_lua_toboolean
	test	eax, eax
	setne	al
	push	3
	push	esi
	mov	BYTE PTR $T225852[esp+36], al
	call	_lua_tointeger
	push	2
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	mov	ecx, DWORD PTR $T225852[esp+44]
	add	esp, 24					; 00000018H
	push	ecx
	push	ebx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+28]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 102  : 
; 103  : 	return 1;

	mov	eax, 1
	pop	ebx

; 104  : }

	pop	ecx
	ret	0
??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes,bool>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes>, COMDAT

; 88   : {

	push	ebx
	push	ebp
	push	esi

; 89   : 	const int idx = Derived::GetStartingArgIndex();
; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@42
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@42
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@42
	xor	bl, bl
$LN7@BasicLuaMe@42:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@42
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@42:

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	push	3
	push	esi
	call	_lua_tointeger
	push	2
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	add	esp, 16					; 00000010H
	push	ebx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+20]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 92   : 
; 93   : 	return 1;

	mov	eax, 1
	pop	ebx

; 94   : }

	ret	0
??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4YieldTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4YieldTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HW4YieldTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4YieldTypes@@_N@Z@Z
_TEXT	SEGMENT
$T225938 = -4						; size = 1
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4YieldTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4YieldTypes@@_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,bool>, COMDAT

; 140  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 141  : 	const int idx = Derived::GetStartingArgIndex();
; 142  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@43
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@43
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@43
	xor	bl, bl
$LN7@BasicLuaMe@43:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@43
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@43:

; 143  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	push	3
	push	esi
	call	_lua_toboolean
	test	eax, eax
	setne	al
	push	2
	push	esi
	mov	BYTE PTR $T225938[esp+36], al
	call	_lua_tointeger
	mov	ecx, DWORD PTR $T225938[esp+36]
	add	esp, 16					; 00000010H
	push	ecx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+24]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 144  : 
; 145  : 	return 1;

	mov	eax, 1
	pop	ebx

; 146  : }

	pop	ecx
	ret	0
??$BasicLuaMethod@HW4YieldTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4YieldTypes@@_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,bool>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum YieldTypes,bool,enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
$T225983 = -4						; size = 1
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum YieldTypes,bool,enum PlayerTypes>, COMDAT

; 108  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 109  : 	const int idx = Derived::GetStartingArgIndex();
; 110  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@44
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@44
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@44
	xor	bl, bl
$LN7@BasicLuaMe@44:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@44
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@44:

; 111  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2), CvLuaArgs::toValue<arg4>(L, idx + 3)));

	push	5
	push	esi
	call	_lua_tointeger
	push	4
	push	esi
	mov	ebx, eax
	call	_lua_toboolean
	test	eax, eax
	setne	al
	push	3
	push	esi
	mov	BYTE PTR $T225983[esp+44], al
	call	_lua_tointeger
	push	2
	push	esi
	mov	ebp, eax
	call	_lua_tointeger
	mov	ecx, DWORD PTR $T225983[esp+52]
	add	esp, 32					; 00000020H
	push	ebx
	push	ecx
	push	ebp
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+32]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 112  : 
; 113  : 	return 1;

	mov	eax, 1
	pop	ebx

; 114  : }

	pop	ecx
	ret	0
??$BasicLuaMethod@HW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum YieldTypes,bool,enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>, COMDAT

; 130  : {

	push	ebx
	push	ebp
	push	esi

; 131  : 	const int idx = Derived::GetStartingArgIndex();
; 132  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@45
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@45
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@45
	xor	bl, bl
$LN7@BasicLuaMe@45:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@45
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@45:

; 133  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+16]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 134  : 
; 135  : 	return 1;

	mov	eax, 1
	pop	ebx

; 136  : }

	ret	0
??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>, COMDAT

; 130  : {

	push	ebx
	push	ebp
	push	esi

; 131  : 	const int idx = Derived::GetStartingArgIndex();
; 132  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@46
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@46
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@46
	xor	bl, bl
$LN7@BasicLuaMe@46:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@46
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@46:

; 133  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+16]
	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 134  : 
; 135  : 	return 1;

	mov	eax, 1
	pop	ebx

; 136  : }

	ret	0
??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4BuildTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HW4BuildTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4BuildTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes>, COMDAT

; 78   : {

	push	ebx
	push	ebp
	push	esi

; 79   : 	const int idx = Derived::GetStartingArgIndex();
; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@47
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@47
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@47
	xor	bl, bl
$LN7@BasicLuaMe@47:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@47
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@47:

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+16]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 82   : 
; 83   : 	return 1;

	mov	eax, 1
	pop	ebx

; 84   : }

	ret	0
??$BasicLuaMethod@HW4BuildTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4BuildTypes@@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4BuildTypes@@HW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,int,enum PlayerTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NW4BuildTypes@@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4BuildTypes@@HW4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4BuildTypes@@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4BuildTypes@@HW4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,int,enum PlayerTypes>, COMDAT

; 150  : {

	push	ebx
	push	ebp
	push	esi

; 151  : 	const int idx = Derived::GetStartingArgIndex();
; 152  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@48
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@48
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@48
	xor	bl, bl
$LN7@BasicLuaMe@48:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@48
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@48:

; 153  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2)));

	push	4
	push	esi
	call	_lua_tointeger
	push	3
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	push	2
	push	esi
	mov	ebp, eax
	call	_lua_tointeger
	add	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+24]
	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 154  : 
; 155  : 	return 1;

	mov	eax, 1
	pop	ebx

; 156  : }

	ret	0
??$BasicLuaMethod@_NW4BuildTypes@@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4BuildTypes@@HW4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,int,enum PlayerTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@W4InvisibleTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,enum InvisibleTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@HW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@W4InvisibleTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@W4InvisibleTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,enum InvisibleTypes>, COMDAT

; 88   : {

	push	ebx
	push	ebp
	push	esi

; 89   : 	const int idx = Derived::GetStartingArgIndex();
; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@49
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@49
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@49
	xor	bl, bl
$LN7@BasicLuaMe@49:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@49
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@49:

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	push	3
	push	esi
	call	_lua_tointeger
	push	2
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	add	esp, 16					; 00000010H
	push	ebx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+20]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 92   : 
; 93   : 	return 1;

	mov	eax, 1
	pop	ebx

; 94   : }

	ret	0
??$BasicLuaMethod@HW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@W4InvisibleTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,enum InvisibleTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4InvisibleTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum InvisibleTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@_NW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4InvisibleTypes@@@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4InvisibleTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum InvisibleTypes>, COMDAT

; 88   : {

	push	ebx
	push	ebp
	push	esi

; 89   : 	const int idx = Derived::GetStartingArgIndex();
; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@50
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@50
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@50
	xor	bl, bl
$LN7@BasicLuaMe@50:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@50
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@50:

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	push	3
	push	esi
	call	_lua_tointeger
	push	2
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	add	esp, 16					; 00000010H
	push	ebx
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+20]
	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 92   : 
; 93   : 	return 1;

	mov	eax, 1
	pop	ebx

; 94   : }

	ret	0
??$BasicLuaMethod@_NW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4InvisibleTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum InvisibleTypes>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4TeamTypes@@W4InvisibleTypes@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4TeamTypes@@W4InvisibleTypes@@H@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes,enum InvisibleTypes,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@W4TeamTypes@@W4InvisibleTypes@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4TeamTypes@@W4InvisibleTypes@@H@Z@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4TeamTypes@@W4InvisibleTypes@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4TeamTypes@@W4InvisibleTypes@@H@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes,enum InvisibleTypes,int>, COMDAT

; 249  : {

	push	ebx
	push	ebp
	push	esi

; 250  : 	const int idx = Derived::GetStartingArgIndex();
; 251  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@BasicLuaMe@51
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@BasicLuaMe@51
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@BasicLuaMe@51
	xor	bl, bl
$LN7@BasicLuaMe@51:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@BasicLuaMe@51
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@BasicLuaMe@51:

; 252  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2));

	push	4
	push	esi
	call	_lua_tointeger
	push	3
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	add	esp, 16					; 00000010H
	push	ebx
	push	eax
	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	DWORD PTR _func$[esp+24]
	pop	edi
	pop	esi
	pop	ebp

; 253  : 	return 0;

	xor	eax, eax
	pop	ebx

; 254  : }

	ret	0
??$BasicLuaMethod@W4TeamTypes@@W4InvisibleTypes@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4TeamTypes@@W4InvisibleTypes@@H@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes,enum InvisibleTypes,int>
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHXZ@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHXZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>, COMDAT

; 121  : {

	push	ebx
	push	ebp
	push	esi

; 122  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@BasicLuaMe@52
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@BasicLuaMe@52
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@BasicLuaMe@52
	xor	bl, bl
$LN5@BasicLuaMe@52:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@BasicLuaMe@52
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@BasicLuaMe@52:

; 123  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, edi
	call	DWORD PTR _func$[esp+12]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 124  : 
; 125  : 	return 1;

	mov	eax, 1
	pop	ebx

; 126  : }

	ret	0
??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHXZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlayer::getTeam
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayerID$ = 8						; size = 4
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlayer::getTeam, COMDAT

; 1173 : 		return CvPreGame::teamType(ePlayerID);

	mov	eax, DWORD PTR _ePlayerID$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1174 : 	}

	ret	0

; 1173 : 		return CvPreGame::teamType(ePlayerID);

$LN3@getTeam:
	or	eax, -1

; 1174 : 	}

	ret	0
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z	; CvPlot::isVisible
EXTRN	?isDebugMode@CvGame@@QBE_NXZ:PROC		; CvGame::isDebugMode
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?isVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z PROC		; CvPlot::isVisible, COMDAT
; _this$ = ecx

; 197  : 		if(bDebug && GC.getGame().isDebugMode())

	cmp	BYTE PTR _bDebug$[esp-4], 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN3@isVisible
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN3@isVisible

; 198  : 			return true;

	mov	al, 1
	pop	esi

; 205  : 		}
; 206  : 	}

	ret	8
$LN3@isVisible:

; 199  : 		else
; 200  : 		{
; 201  : 			if(eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp]
	cmp	eax, -1
	jne	SHORT $LN1@isVisible

; 202  : 				return false;

	xor	al, al
	pop	esi

; 205  : 		}
; 206  : 	}

	ret	8
$LN1@isVisible:

; 203  : 
; 204  : 			return ((getVisibilityCount(eTeam) > 0));

	mov	ecx, DWORD PTR [esi+156]
	xor	edx, edx
	cmp	WORD PTR [ecx+eax*2], dx
	pop	esi
	setg	dl
	mov	al, dl

; 205  : 		}
; 206  : 	}

	ret	8
?isVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z ENDP		; CvPlot::isVisible
_TEXT	ENDS
PUBLIC	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ		; CvPlot::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ PROC		; CvPlot::getTeam, COMDAT
; _this$ = ecx

; 232  : 		PlayerTypes playerID = getOwner();

	movsx	eax, BYTE PTR [ecx+4]

; 233  : 		if(playerID != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN2@getTeam@2

; 234  : 		{
; 235  : 			return CvPlayer::getTeam(playerID);

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@getTeam@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 240  : 		}
; 241  : 	}

	ret	0
$LN2@getTeam@2:

; 236  : 		}
; 237  : 		else
; 238  : 		{
; 239  : 			return NO_TEAM;

	or	eax, -1

; 240  : 		}
; 241  : 	}

	ret	0
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlot::getTeam
_TEXT	ENDS
PUBLIC	?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z		; CvPlot::isEnemyCity
EXTRN	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isEnemy
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z
_TEXT	SEGMENT
_kUnit$ = 8						; size = 4
?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z PROC		; CvPlot::isEnemyCity, COMDAT
; _this$ = ecx

; 252  : 	{

	push	esi
	mov	esi, ecx

; 253  : 		CvCity* pCity = getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN1@isEnemyCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isEnemyCit
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 254  : 		if(pCity != NULL)

	test	eax, eax
	je	SHORT $LN1@isEnemyCit

; 255  : 			return kUnit.isEnemy(pCity->getTeam(), this);

	push	esi
	mov	ecx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	ecx, DWORD PTR _kUnit$[esp+4]
	push	eax
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	pop	esi

; 258  : 	}

	ret	4
$LN1@isEnemyCit:

; 256  : 
; 257  : 		return false;

	xor	al, al
	pop	esi

; 258  : 	}

	ret	4
?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z ENDP		; CvPlot::isEnemyCity
_TEXT	ENDS
PUBLIC	?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ	; CvPlot::getFeatureType
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ
_TEXT	SEGMENT
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ PROC	; CvPlot::getFeatureType, COMDAT
; _this$ = ecx

; 435  : #ifdef AUI_WARNING_FIXES
; 436  : 		int f = m_eFeatureType;
; 437  : #else
; 438  : 		char f = m_eFeatureType;
; 439  : #endif
; 440  : 		return (FeatureTypes)f;

	movsx	eax, BYTE PTR [ecx+432]

; 441  : 	}

	ret	0
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ ENDP	; CvPlot::getFeatureType
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 612  : 		if(bDebug && GC.getGame().isDebugMode())

	cmp	BYTE PTR _bDebug$[esp-4], 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN1@isRevealed
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN1@isRevealed

; 613  : 			return true;

	mov	al, 1
	pop	esi

; 617  : 	}

	ret	8
$LN1@isRevealed:

; 614  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 615  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 616  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp]
	mov	eax, ecx
	shr	eax, 5
	mov	edx, eax
	shl	edx, 5
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [esi+eax*4+8]
	pop	esi
	setne	al

; 617  : 	}

	ret	8
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?lCanHaveFeature@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lCanHaveFeature
EXTRN	?canHaveFeature@CvPlot@@QBE_NW4FeatureTypes@@@Z:PROC ; CvPlot::canHaveFeature
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaplot.cpp
;	COMDAT ?lCanHaveFeature@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCanHaveFeature@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lCanHaveFeature, COMDAT

; 291  : {

	push	ebx
	push	ebp
	push	esi

; 292  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lCanHaveFe
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lCanHaveFe
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lCanHaveFe
	xor	bl, bl
$LN5@lCanHaveFe:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lCanHaveFe
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lCanHaveFe:

; 293  : 
; 294  : 	const int featureType = lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8

; 295  : 	const bool canHasFeature = pkPlot->canHaveFeature((FeatureTypes)featureType);

	push	eax
	mov	ecx, edi
	call	?canHaveFeature@CvPlot@@QBE_NW4FeatureTypes@@@Z ; CvPlot::canHaveFeature

; 296  : 
; 297  : 	lua_pushboolean(L, canHasFeature);

	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 298  : 
; 299  : 	return 1;

	mov	eax, 1
	pop	ebx

; 300  : }

	ret	0
?lCanHaveFeature@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lCanHaveFeature
_TEXT	ENDS
PUBLIC	?lGetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetFeatureType
; Function compile flags: /Ogtpy
;	COMDAT ?lGetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetFeatureType, COMDAT

; 303  : {

	push	ebx
	push	ebp
	push	esi

; 304  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetFeatur
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetFeatur
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetFeatur
	xor	bl, bl
$LN5@lGetFeatur:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetFeatur
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetFeatur:

; 305  : 
; 306  : 	const int featureType = (int)pkPlot->getFeatureType();
; 307  : 	lua_pushinteger(L, featureType);

	movsx	eax, BYTE PTR [edi+432]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 308  : 
; 309  : 	return 1;

	mov	eax, 1
	pop	ebx

; 310  : }

	ret	0
?lGetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetFeatureType
_TEXT	ENDS
PUBLIC	?lGetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetTerrainType
; Function compile flags: /Ogtpy
;	COMDAT ?lGetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetTerrainType, COMDAT

; 313  : {

	push	ebx
	push	ebp
	push	esi

; 314  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetTerrai
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetTerrai
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetTerrai
	xor	bl, bl
$LN5@lGetTerrai:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetTerrai
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetTerrai:

; 315  : 
; 316  : 	lua_pushinteger(L, pkPlot->getTerrainType());

	movsx	eax, BYTE PTR [edi+6]
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 317  : 
; 318  : 	return 1;

	mov	eax, 1
	pop	ebx

; 319  : }

	ret	0
?lGetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetTerrainType
_TEXT	ENDS
PUBLIC	?lIsRiver@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsRiver
; Function compile flags: /Ogtpy
;	COMDAT ?lIsRiver@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRiver@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsRiver, COMDAT

; 322  : {

	push	ebx
	push	ebp
	push	esi

; 323  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lIsRiver
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lIsRiver
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lIsRiver
	xor	bl, bl
$LN5@lIsRiver:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lIsRiver
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lIsRiver:

; 324  : 
; 325  : 	lua_pushboolean(L, pkPlot->isRiver());

	xor	eax, eax
	cmp	BYTE PTR [edi+457], al
	setg	al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 326  : 
; 327  : 	return 1;

	mov	eax, 1
	pop	ebx

; 328  : }

	ret	0
?lIsRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsRiver
_TEXT	ENDS
PUBLIC	?lIsWater@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsWater
; Function compile flags: /Ogtpy
;	COMDAT ?lIsWater@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsWater@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsWater, COMDAT

; 331  : {

	push	ebx
	push	ebp
	push	esi

; 332  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lIsWater
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lIsWater
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lIsWater
	xor	bl, bl
$LN5@lIsWater:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lIsWater
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lIsWater:

; 333  : 
; 334  : 	lua_pushboolean(L, pkPlot->isWater());

	xor	eax, eax
	cmp	BYTE PTR [edi+5], 3
	sete	al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 335  : 
; 336  : 	return 1;

	mov	eax, 1
	pop	ebx

; 337  : }

	ret	0
?lIsWater@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsWater
_TEXT	ENDS
PUBLIC	?lSetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetFeatureType
EXTRN	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z:PROC ; CvPlot::setFeatureType
EXTRN	_luaL_optinteger:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?lSetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetFeatureType, COMDAT

; 340  : {

	push	ebx
	push	ebp
	push	esi

; 341  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lSetFeatur
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lSetFeatur
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lSetFeatur
	xor	bl, bl
$LN5@lSetFeatur:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lSetFeatur
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lSetFeatur:

; 342  : 
; 343  : 	const int featureType = lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 344  : 	const int variety = luaL_optinteger(L, 3, -1);

	push	-1
	push	3
	push	esi
	mov	ebx, eax
	call	_luaL_optinteger
	add	esp, 20					; 00000014H

; 345  : 
; 346  : 
; 347  : 	pkPlot->setFeatureType((FeatureTypes)featureType, variety);

	push	eax
	push	ebx
	mov	ecx, edi
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType
	pop	edi
	pop	esi
	pop	ebp

; 348  : 
; 349  : 	return 0;

	xor	eax, eax
	pop	ebx

; 350  : }

	ret	0
?lSetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetFeatureType
_TEXT	ENDS
PUBLIC	?lSetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetTerrainType
EXTRN	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z:PROC ; CvPlot::setTerrainType
; Function compile flags: /Ogtpy
;	COMDAT ?lSetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bRebuildGraphics$ = -8					; size = 1
_bRecalculate$ = -4					; size = 1
_L$ = 8							; size = 4
?lSetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetTerrainType, COMDAT

; 353  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 354  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+16]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lSetTerrai
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lSetTerrai
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lSetTerrai
	xor	bl, bl
$LN5@lSetTerrai:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lSetTerrai
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lSetTerrai:

; 355  : 
; 356  : 	const int terrainType = lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 357  : 	const bool bRecalculate = lua_toboolean(L, 3);

	push	3
	push	esi
	mov	ebx, eax
	call	_lua_toboolean
	test	eax, eax
	setne	al

; 358  : 	const bool bRebuildGraphics = lua_toboolean(L, 4);

	push	4
	push	esi
	mov	BYTE PTR _bRecalculate$[esp+48], al
	call	_lua_toboolean
	add	esp, 24					; 00000018H
	test	eax, eax

; 359  : 
; 360  : 	pkPlot->setTerrainType((TerrainTypes)terrainType, bRecalculate, bRebuildGraphics);

	mov	eax, DWORD PTR _bRecalculate$[esp+24]
	setne	cl
	mov	BYTE PTR _bRebuildGraphics$[esp+24], cl
	mov	edx, DWORD PTR _bRebuildGraphics$[esp+24]
	push	edx
	push	eax
	push	ebx
	mov	ecx, edi
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType
	pop	edi
	pop	esi
	pop	ebp

; 361  : 
; 362  : 	return 0;

	xor	eax, eax
	pop	ebx

; 363  : }

	add	esp, 8
	ret	0
?lSetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetTerrainType
_TEXT	ENDS
PUBLIC	?lIsNone@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lIsNone
; Function compile flags: /Ogtpy
;	COMDAT ?lIsNone@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsNone@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsNone, COMDAT

; 374  : {

	push	ebx
	push	ebp
	push	esi

; 375  : #ifdef AUI_WARNING_FIXES
; 376  : 	const bool bDoesNotExist = (GetInstance(L, 1, false) == NULL);
; 377  : 	lua_pushboolean(L, bDoesNotExist ? 1 : 0);
; 378  : #else
; 379  : 	const bool bDoesNotExist = (GetInstance(L, false) == NULL);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	xor	edi, edi
	push	edi
	push	esi
	mov	ebp, eax
	mov	bl, 1
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lIsNone
	push	OFFSET $SG223013
	push	edi
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lIsNone
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lIsNone
	xor	bl, bl
$LN5@lIsNone:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lIsNone
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 8
$LN12@lIsNone:
	xor	eax, eax
	test	edi, edi
	sete	al

; 380  : 	lua_pushboolean(L, bDoesNotExist);

	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 381  : #endif
; 382  : 
; 383  : 	return 1;

	mov	eax, 1
	pop	ebx

; 384  : }

	ret	0
?lIsNone@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsNone
_TEXT	ENDS
PUBLIC	?lErase@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lErase
EXTRN	?erase@CvPlot@@QAEX_N@Z:PROC			; CvPlot::erase
; Function compile flags: /Ogtpy
;	COMDAT ?lErase@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lErase@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lErase, COMDAT

; 389  : 	return BasicLuaMethod(L, &CvPlot::erase);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?erase@CvPlot@@QAEX_N@Z		; CvPlot::erase
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 390  : }

	ret	0
?lErase@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lErase
_TEXT	ENDS
PUBLIC	?lGetTeam@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetTeam
; Function compile flags: /Ogtpy
;	COMDAT ?lGetTeam@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetTeam@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lGetTeam, COMDAT

; 396  : 	return BasicLuaMethod(L, &CvPlot::getTeam);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ ; CvPlot::getTeam
	push	eax
	call	??$BasicLuaMethod@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4TeamTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes>
	add	esp, 8

; 397  : }

	ret	0
?lGetTeam@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lGetTeam
_TEXT	ENDS
PUBLIC	?lNukeExplosion@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lNukeExplosion
EXTRN	?nukeExplosion@CvPlot@@QAEXHPAVCvUnit@@@Z:PROC	; CvPlot::nukeExplosion
; Function compile flags: /Ogtpy
;	COMDAT ?lNukeExplosion@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lNukeExplosion@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lNukeExplosion, COMDAT

; 403  : 	return BasicLuaMethod(L, &CvPlot::nukeExplosion);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?nukeExplosion@CvPlot@@QAEXHPAVCvUnit@@@Z ; CvPlot::nukeExplosion
	push	eax
	call	??$BasicLuaMethod@HPAVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXHPAVCvUnit@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit *>
	add	esp, 8

; 404  : }

	ret	0
?lNukeExplosion@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lNukeExplosion
_TEXT	ENDS
PUBLIC	?lUpdateFog@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lUpdateFog
EXTRN	?updateFog@CvPlot@@QAEX_N@Z:PROC		; CvPlot::updateFog
; Function compile flags: /Ogtpy
;	COMDAT ?lUpdateFog@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lUpdateFog@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lUpdateFog, COMDAT

; 410  : 	return BasicLuaMethod(L, &CvPlot::updateFog);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?updateFog@CvPlot@@QAEX_N@Z	; CvPlot::updateFog
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 411  : }

	ret	0
?lUpdateFog@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lUpdateFog
_TEXT	ENDS
PUBLIC	?lIsAdjacentToArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentToArea
EXTRN	?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z:PROC ; CvPlot::isAdjacentToArea
; Function compile flags: /Ogtpy
;	COMDAT ?lIsAdjacentToArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkInstance$226652 = -4					; size = 4
_L$ = 8							; size = 4
?lIsAdjacentToArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsAdjacentToArea, COMDAT

; 422  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 423  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	edi, eax
	mov	bl, 1
	mov	DWORD PTR _pkInstance$226652[esp+32], 0
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lIsAdjacen
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lIsAdjacen
	push	-1
	push	esi
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pkInstance$226652[esp+20], eax
	test	eax, eax
	je	SHORT $LN5@lIsAdjacen
	xor	bl, bl
$LN5@lIsAdjacen:
	push	edi
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lIsAdjacen
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lIsAdjacen:

; 424  : 	CvArea* pkArea = CvLuaArea::GetInstance(L, 2);

	push	esi
	call	_lua_gettop
	push	2
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN16@lIsAdjacen
	push	OFFSET $SG222944
	push	2
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN16@lIsAdjacen
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN16@lIsAdjacen
	xor	bl, bl
$LN16@lIsAdjacen:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN15@lIsAdjacen
	push	esi
	call	?HandleMissingInstance@CvLuaArea@@SAXPAUlua_State@@@Z ; CvLuaArea::HandleMissingInstance
	add	esp, 4
$LN15@lIsAdjacen:

; 425  : 
; 426  : 	const bool bResult = pkPlot->isAdjacentToArea(pkArea);

	mov	ecx, DWORD PTR _pkInstance$226652[esp+20]
	push	edi
	call	?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z ; CvPlot::isAdjacentToArea

; 427  : 	lua_pushboolean(L, bResult);

	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 428  : 
; 429  : 	return 1;

	mov	eax, 1
	pop	ebx

; 430  : }

	pop	ecx
	ret	0
?lIsAdjacentToArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsAdjacentToArea
_TEXT	ENDS
PUBLIC	?lShareAdjacentArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lShareAdjacentArea
EXTRN	?shareAdjacentArea@CvPlot@@QBE_NPBV1@@Z:PROC	; CvPlot::shareAdjacentArea
; Function compile flags: /Ogtpy
;	COMDAT ?lShareAdjacentArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkInstance$226689 = -4					; size = 4
_L$ = 8							; size = 4
?lShareAdjacentArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lShareAdjacentArea, COMDAT

; 434  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 435  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	edi, eax
	mov	bl, 1
	mov	DWORD PTR _pkInstance$226689[esp+32], 0
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lShareAdja
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lShareAdja
	push	-1
	push	esi
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pkInstance$226689[esp+20], eax
	test	eax, eax
	je	SHORT $LN5@lShareAdja
	xor	bl, bl
$LN5@lShareAdja:
	push	edi
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lShareAdja
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lShareAdja:

; 436  : 	CvPlot* pkPlot2 = GetInstance(L, 2);

	push	esi
	call	_lua_gettop
	push	2
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN16@lShareAdja
	push	OFFSET $SG223013
	push	2
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN16@lShareAdja
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN16@lShareAdja
	xor	bl, bl
$LN16@lShareAdja:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN23@lShareAdja
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 8
$LN23@lShareAdja:

; 437  : 
; 438  : 	const bool bResult = pkPlot->shareAdjacentArea(pkPlot2);

	mov	ecx, DWORD PTR _pkInstance$226689[esp+20]
	push	edi
	call	?shareAdjacentArea@CvPlot@@QBE_NPBV1@@Z	; CvPlot::shareAdjacentArea

; 439  : 	lua_pushboolean(L, bResult);

	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 440  : 
; 441  : 	return 1;

	mov	eax, 1
	pop	ebx

; 442  : }

	pop	ecx
	ret	0
?lShareAdjacentArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lShareAdjacentArea
_TEXT	ENDS
PUBLIC	?lIsAdjacentToLand@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentToLand
EXTRN	?isAdjacentToLand@CvPlot@@QBE_NXZ:PROC		; CvPlot::isAdjacentToLand
; Function compile flags: /Ogtpy
;	COMDAT ?lIsAdjacentToLand@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentToLand@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsAdjacentToLand, COMDAT

; 447  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentToLand);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isAdjacentToLand@CvPlot@@QBE_NXZ ; CvPlot::isAdjacentToLand
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 448  : }

	ret	0
?lIsAdjacentToLand@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsAdjacentToLand
_TEXT	ENDS
PUBLIC	?lIsAdjacentToShallowWater@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentToShallowWater
EXTRN	?isAdjacentToShallowWater@CvPlot@@QBE_NXZ:PROC	; CvPlot::isAdjacentToShallowWater
; Function compile flags: /Ogtpy
;	COMDAT ?lIsAdjacentToShallowWater@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentToShallowWater@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsAdjacentToShallowWater, COMDAT

; 453  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentToShallowWater);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isAdjacentToShallowWater@CvPlot@@QBE_NXZ ; CvPlot::isAdjacentToShallowWater
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 454  : }

	ret	0
?lIsAdjacentToShallowWater@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsAdjacentToShallowWater
_TEXT	ENDS
PUBLIC	?lIsCoastalLand@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsCoastalLand
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
; Function compile flags: /Ogtpy
;	COMDAT ?lIsCoastalLand@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsCoastalLand@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsCoastalLand, COMDAT

; 459  : 	return BasicLuaMethod(L, &CvPlot::isCoastalLand);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isCoastalLand@CvPlot@@QBE_NH@Z	; CvPlot::isCoastalLand
	push	eax
	call	??$BasicLuaMethod@_NH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int>
	add	esp, 8

; 460  : }

	ret	0
?lIsCoastalLand@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsCoastalLand
_TEXT	ENDS
PUBLIC	?lIsWithinTeamCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsWithinTeamCityRadius
EXTRN	?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::isWithinTeamCityRadius
; Function compile flags: /Ogtpy
;	COMDAT ?lIsWithinTeamCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsWithinTeamCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsWithinTeamCityRadius, COMDAT

; 466  : 	return BasicLuaMethod(L, &CvPlot::isWithinTeamCityRadius);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::isWithinTeamCityRadius
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum PlayerTypes>
	add	esp, 8

; 467  : }

	ret	0
?lIsWithinTeamCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsWithinTeamCityRadius
_TEXT	ENDS
PUBLIC	?lIsLake@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lIsLake
EXTRN	?isLake@CvPlot@@QBE_NXZ:PROC			; CvPlot::isLake
; Function compile flags: /Ogtpy
;	COMDAT ?lIsLake@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsLake@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsLake, COMDAT

; 472  : 	return BasicLuaMethod(L, &CvPlot::isLake);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isLake@CvPlot@@QBE_NXZ		; CvPlot::isLake
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 473  : }

	ret	0
?lIsLake@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsLake
_TEXT	ENDS
PUBLIC	?lIsFreshWater@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsFreshWater
EXTRN	?isFreshWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isFreshWater
; Function compile flags: /Ogtpy
;	COMDAT ?lIsFreshWater@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsFreshWater@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsFreshWater, COMDAT

; 478  : 	return BasicLuaMethod(L, &CvPlot::isFreshWater);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isFreshWater@CvPlot@@QBE_NXZ	; CvPlot::isFreshWater
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 479  : }

	ret	0
?lIsFreshWater@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsFreshWater
_TEXT	ENDS
PUBLIC	?lIsRiverSide@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsRiverSide
EXTRN	?isRiverSide@CvPlot@@QBE_NXZ:PROC		; CvPlot::isRiverSide
; Function compile flags: /Ogtpy
;	COMDAT ?lIsRiverSide@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRiverSide@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsRiverSide, COMDAT

; 485  : 	return BasicLuaMethod(L, &CvPlot::isRiverSide);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isRiverSide@CvPlot@@QBE_NXZ	; CvPlot::isRiverSide
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 486  : }

	ret	0
?lIsRiverSide@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsRiverSide
_TEXT	ENDS
PUBLIC	?lIsRiverConnection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverConnection
EXTRN	?isRiverConnection@CvPlot@@QBE_NW4DirectionTypes@@@Z:PROC ; CvPlot::isRiverConnection
; Function compile flags: /Ogtpy
;	COMDAT ?lIsRiverConnection@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRiverConnection@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsRiverConnection, COMDAT

; 491  : 	return BasicLuaMethod(L, &CvPlot::isRiverConnection);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isRiverConnection@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverConnection
	push	eax
	call	??$BasicLuaMethod@_NW4DirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4DirectionTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum DirectionTypes>
	add	esp, 8

; 492  : }

	ret	0
?lIsRiverConnection@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsRiverConnection
_TEXT	ENDS
PUBLIC	?lIsRiverCrossingFlowClockwise@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverCrossingFlowClockwise
EXTRN	?isRiverCrossingFlowClockwise@CvPlot@@QBE_NW4DirectionTypes@@@Z:PROC ; CvPlot::isRiverCrossingFlowClockwise
; Function compile flags: /Ogtpy
;	COMDAT ?lIsRiverCrossingFlowClockwise@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRiverCrossingFlowClockwise@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsRiverCrossingFlowClockwise, COMDAT

; 495  : {

	push	ebx
	push	ebp
	push	esi

; 496  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lIsRiverCr
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lIsRiverCr
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lIsRiverCr
	xor	bl, bl
$LN5@lIsRiverCr:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lIsRiverCr
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lIsRiverCr:

; 497  : 	const DirectionTypes eDirection = (DirectionTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8

; 498  : 	const bool bResult = pkPlot->isRiverCrossingFlowClockwise(eDirection);

	push	eax
	mov	ecx, edi
	call	?isRiverCrossingFlowClockwise@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossingFlowClockwise

; 499  : 	lua_pushboolean(L, bResult);

	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 500  : 	return 1;

	mov	eax, 1
	pop	ebx

; 501  : }

	ret	0
?lIsRiverCrossingFlowClockwise@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsRiverCrossingFlowClockwise
_TEXT	ENDS
PUBLIC	?lGetNearestLandArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNearestLandArea
EXTRN	?getNearestLandArea@CvPlot@@QBEHXZ:PROC		; CvPlot::getNearestLandArea
; Function compile flags: /Ogtpy
;	COMDAT ?lGetNearestLandArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNearestLandArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetNearestLandArea, COMDAT

; 506  : 	return BasicLuaMethod(L, &CvPlot::getNearestLandArea);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getNearestLandArea@CvPlot@@QBEHXZ ; CvPlot::getNearestLandArea
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 507  : }

	ret	0
?lGetNearestLandArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetNearestLandArea
_TEXT	ENDS
PUBLIC	?lSeeFromLevel@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSeeFromLevel
EXTRN	?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z:PROC	; CvPlot::seeFromLevel
; Function compile flags: /Ogtpy
;	COMDAT ?lSeeFromLevel@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSeeFromLevel@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSeeFromLevel, COMDAT

; 512  : 	return BasicLuaMethod(L, &CvPlot::seeFromLevel);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::seeFromLevel
	push	eax
	call	??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes>
	add	esp, 8

; 513  : }

	ret	0
?lSeeFromLevel@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSeeFromLevel
_TEXT	ENDS
PUBLIC	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
PUBLIC	?lGetNearestLandPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNearestLandPlot
EXTRN	?getNearestLandPlot@CvPlot@@QBEPAV1@XZ:PROC	; CvPlot::getNearestLandPlot
; Function compile flags: /Ogtpy
;	COMDAT ?lGetNearestLandPlot@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNearestLandPlot@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetNearestLandPlot, COMDAT

; 517  : {

	push	ebx
	push	ebp
	push	esi

; 518  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetNeares
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetNeares
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetNeares
	xor	bl, bl
$LN5@lGetNeares:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetNeares
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetNeares:

; 519  : 	CvPlot* pkNearestPlot = pkPlot->getNearestLandPlot();

	mov	ecx, edi
	call	?getNearestLandPlot@CvPlot@@QBEPAV1@XZ	; CvPlot::getNearestLandPlot

; 520  : 	CvLuaPlot::Push(L, pkNearestPlot);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 521  : 	return 1;

	mov	eax, 1
	pop	ebx

; 522  : }

	ret	0
?lGetNearestLandPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetNearestLandPlot
_TEXT	ENDS
PUBLIC	?lSeeThroughLevel@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSeeThroughLevel
EXTRN	?seeThroughLevel@CvPlot@@QBEH_N@Z:PROC		; CvPlot::seeThroughLevel
; Function compile flags: /Ogtpy
;	COMDAT ?lSeeThroughLevel@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSeeThroughLevel@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSeeThroughLevel, COMDAT

; 527  : 	return BasicLuaMethod(L, &CvPlot::seeThroughLevel);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?seeThroughLevel@CvPlot@@QBEH_N@Z ; CvPlot::seeThroughLevel
	push	eax
	call	??$BasicLuaMethod@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEH_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,bool>
	add	esp, 8

; 528  : }

	ret	0
?lSeeThroughLevel@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSeeThroughLevel
_TEXT	ENDS
PUBLIC	?lCanHaveResource@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCanHaveResource
EXTRN	?canHaveResource@CvPlot@@QBE_NW4ResourceTypes@@_N@Z:PROC ; CvPlot::canHaveResource
; Function compile flags: /Ogtpy
;	COMDAT ?lCanHaveResource@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCanHaveResource@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lCanHaveResource, COMDAT

; 533  : 	return BasicLuaMethod(L, &CvPlot::canHaveResource);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?canHaveResource@CvPlot@@QBE_NW4ResourceTypes@@_N@Z ; CvPlot::canHaveResource
	push	eax
	call	??$BasicLuaMethod@_NW4ResourceTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ResourceTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ResourceTypes,bool>
	add	esp, 8

; 534  : }

	ret	0
?lCanHaveResource@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lCanHaveResource
_TEXT	ENDS
PUBLIC	?lCanHaveImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCanHaveImprovement
EXTRN	?canHaveImprovement@CvPlot@@QBE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::canHaveImprovement
; Function compile flags: /Ogtpy
;	COMDAT ?lCanHaveImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCanHaveImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lCanHaveImprovement, COMDAT

; 539  : 	return BasicLuaMethod(L, &CvPlot::canHaveImprovement);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?canHaveImprovement@CvPlot@@QBE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z ; CvPlot::canHaveImprovement
	push	eax
	call	??$BasicLuaMethod@_NW4ImprovementTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ImprovementTypes,enum TeamTypes,bool>
	add	esp, 8

; 540  : }

	ret	0
?lCanHaveImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lCanHaveImprovement
_TEXT	ENDS
PUBLIC	?lCanBuild@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lCanBuild
EXTRN	?canBuild@CvPlot@@QBE_NW4BuildTypes@@W4PlayerTypes@@_N2@Z:PROC ; CvPlot::canBuild
; Function compile flags: /Ogtpy
;	COMDAT ?lCanBuild@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCanBuild@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lCanBuild, COMDAT

; 545  : 	return BasicLuaMethod(L, &CvPlot::canBuild);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?canBuild@CvPlot@@QBE_NW4BuildTypes@@W4PlayerTypes@@_N2@Z ; CvPlot::canBuild
	push	eax
	call	??$BasicLuaMethod@_NW4BuildTypes@@W4PlayerTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4BuildTypes@@W4PlayerTypes@@_N3@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,enum PlayerTypes,bool,bool>
	add	esp, 8

; 546  : }

	ret	0
?lCanBuild@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lCanBuild
_TEXT	ENDS
PUBLIC	?lGetBuildTime@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetBuildTime
EXTRN	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::getBuildTime
; Function compile flags: /Ogtpy
;	COMDAT ?lGetBuildTime@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetBuildTime@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetBuildTime, COMDAT

; 551  : 	return BasicLuaMethod(L, &CvPlot::getBuildTime);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTime
	push	eax
	call	??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes>
	add	esp, 8

; 552  : }

	ret	0
?lGetBuildTime@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetBuildTime
_TEXT	ENDS
PUBLIC	?lGetBuildTurnsLeft@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBuildTurnsLeft
EXTRN	?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z:PROC ; CvPlot::getBuildTurnsLeft
; Function compile flags: /Ogtpy
;	COMDAT ?lGetBuildTurnsLeft@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetBuildTurnsLeft@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetBuildTurnsLeft, COMDAT

; 557  : 	return BasicLuaMethod(L, &CvPlot::getBuildTurnsLeft);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z ; CvPlot::getBuildTurnsLeft
	push	eax
	call	??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@HH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@HH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes,int,int>
	add	esp, 8

; 558  : }

	ret	0
?lGetBuildTurnsLeft@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetBuildTurnsLeft
_TEXT	ENDS
PUBLIC	?lGetBuildTurnsTotal@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBuildTurnsTotal
EXTRN	?getBuildTurnsTotal@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::getBuildTurnsTotal
; Function compile flags: /Ogtpy
;	COMDAT ?lGetBuildTurnsTotal@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetBuildTurnsTotal@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetBuildTurnsTotal, COMDAT

; 563  : 	return BasicLuaMethod(L, &CvPlot::getBuildTurnsTotal);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getBuildTurnsTotal@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTurnsTotal
	push	eax
	call	??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes>
	add	esp, 8

; 564  : }

	ret	0
?lGetBuildTurnsTotal@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetBuildTurnsTotal
_TEXT	ENDS
PUBLIC	?lGetFeatureProduction@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetFeatureProduction
EXTRN	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z:PROC ; CvPlot::getFeatureProduction
; Function compile flags: /Ogtpy
;	COMDAT ?lGetFeatureProduction@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pCity$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetFeatureProduction@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetFeatureProduction, COMDAT

; 568  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 569  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetFeatur@2
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetFeatur@2
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetFeatur@2
	xor	bl, bl
$LN5@lGetFeatur@2:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetFeatur@2
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetFeatur@2:

; 570  : 	const BuildTypes eBuild = (BuildTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 571  : 	const PlayerTypes ePlayer = (PlayerTypes)lua_tointeger(L, 3);

	push	3
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	add	esp, 16					; 00000010H

; 572  : 	CvCity* pCity;
; 573  : 
; 574  : 	const int iResult = pkPlot->getFeatureProduction(eBuild, ePlayer, &pCity);

	lea	ecx, DWORD PTR _pCity$[esp+20]
	push	ecx
	push	eax
	push	ebx
	mov	ecx, edi
	call	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureProduction

; 575  : 
; 576  : 	lua_pushinteger(L, iResult);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 577  : 	return 1;

	mov	eax, 1
	pop	ebx

; 578  : }

	pop	ecx
	ret	0
?lGetFeatureProduction@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetFeatureProduction
_TEXT	ENDS
PUBLIC	?lGetFeatureFood@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetFeatureFood
EXTRN	?getFeatureFood@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z:PROC ; CvPlot::getFeatureFood
; Function compile flags: /Ogtpy
;	COMDAT ?lGetFeatureFood@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pCity$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetFeatureFood@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetFeatureFood, COMDAT

; 583  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 584  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetFeatur@3
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetFeatur@3
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetFeatur@3
	xor	bl, bl
$LN5@lGetFeatur@3:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetFeatur@3
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetFeatur@3:

; 585  : 	const BuildTypes eBuild = (BuildTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 586  : 	const PlayerTypes ePlayer = (PlayerTypes)lua_tointeger(L, 3);

	push	3
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	add	esp, 16					; 00000010H

; 587  : 	CvCity* pCity;
; 588  : 
; 589  : 	const int iResult = pkPlot->getFeatureFood(eBuild, ePlayer, &pCity);

	lea	ecx, DWORD PTR _pCity$[esp+20]
	push	ecx
	push	eax
	push	ebx
	mov	ecx, edi
	call	?getFeatureFood@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureFood

; 590  : 
; 591  : 	lua_pushinteger(L, iResult);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 592  : 	return 1;

	mov	eax, 1
	pop	ebx

; 593  : }

	pop	ecx
	ret	0
?lGetFeatureFood@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetFeatureFood
_TEXT	ENDS
PUBLIC	?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBestDefender
EXTRN	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z:PROC ; CvPlot::getBestDefender
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z$0
__ehfuncinfo$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaplot.cpp
xdata$x	ENDS
;	COMDAT ?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkInstance$226902 = -36				; size = 4
_bTestCanMove$ = -32					; size = 1
_stack_size$226911 = -32				; size = 4
_bTestPotentialEnemy$ = -28				; size = 1
_bTestAtWar$ = -24					; size = 1
_pkUnit$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_L$ = 8							; size = 4
?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetBestDefender, COMDAT

; 598  : {

	push	-1
	push	__ehhandler$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi

; 599  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+44]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	edi, eax
	mov	bl, 1
	mov	DWORD PTR _pkInstance$226902[esp+64], 0
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN30@lGetBestDe
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN30@lGetBestDe
	push	-1
	push	esi
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pkInstance$226902[esp+52], eax
	test	eax, eax
	je	SHORT $LN30@lGetBestDe
	xor	bl, bl
$LN30@lGetBestDe:
	push	edi
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN13@lGetBestDe
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN13@lGetBestDe:

; 600  : 	const PlayerTypes eOwner = (PlayerTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 601  : 	const PlayerTypes eAttackingPlayer = (PlayerTypes)lua_tointeger(L, 3);

	push	3
	push	esi
	mov	ebx, eax
	call	_lua_tointeger

; 602  : 	CvUnit* pkAttacker = CvLuaUnit::GetInstance(L, 4, false);

	push	esi
	mov	ebp, eax
	call	_lua_gettop
	push	4
	push	esi
	mov	DWORD PTR _stack_size$226911[esp+80], eax
	xor	edi, edi
	call	_lua_type
	add	esp, 28					; 0000001cH
	cmp	eax, 5
	jne	SHORT $LN17@lGetBestDe
	push	OFFSET $SG223061
	push	4
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN17@lGetBestDe
	push	-1
	push	esi
	call	_lua_touserdata
	add	esp, 8
	mov	edi, eax
$LN17@lGetBestDe:
	mov	eax, DWORD PTR _stack_size$226911[esp+52]
	push	eax
	push	esi
	call	_lua_settop

; 603  : 	const bool bTestAtWar = luaL_optint(L, 5, 0);

	push	0
	push	5
	push	esi
	call	_luaL_optinteger

; 604  : 	const bool bTestPotentialEnemy = luaL_optint(L, 6, 0);

	push	0
	test	eax, eax
	setne	cl
	push	6
	push	esi
	mov	BYTE PTR _bTestAtWar$[esp+84], cl
	call	_luaL_optinteger

; 605  : 	const bool bTestCanMove = luaL_optint(L, 7, 0);

	push	0
	test	eax, eax
	setne	dl
	push	7
	push	esi
	mov	BYTE PTR _bTestPotentialEnemy$[esp+96], dl
	call	_luaL_optinteger

; 606  : 	UnitHandle pkUnit = pkPlot->getBestDefender(eOwner, eAttackingPlayer, pkAttacker, bTestAtWar, bTestPotentialEnemy, bTestCanMove);

	mov	edx, DWORD PTR _bTestPotentialEnemy$[esp+96]
	add	esp, 44					; 0000002cH
	test	eax, eax
	push	0
	setne	al
	mov	BYTE PTR _bTestCanMove$[esp+56], al
	mov	ecx, DWORD PTR _bTestCanMove$[esp+56]
	mov	eax, DWORD PTR _bTestAtWar$[esp+56]
	push	ecx
	push	edx
	push	eax
	push	edi
	push	ebp
	push	ebx
	lea	ecx, DWORD PTR _pkUnit$[esp+80]
	push	ecx
	mov	ecx, DWORD PTR _pkInstance$226902[esp+84]
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender

; 607  : 	CvLuaUnit::Push(L, pkUnit.pointer());

	mov	edx, DWORD PTR _pkUnit$[esp+52]
	push	edx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+68], 0
	call	?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::Push

; 608  : 	return 1;

	mov	ecx, DWORD PTR _pkUnit$[esp+60]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR __$EHRec$[esp+48], -1
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN29@lGetBestDe
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN29@lGetBestDe:

; 609  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	eax, 1
	mov	DWORD PTR fs:0, ecx
	add	esp, 36					; 00000024H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z$0:
	lea	ecx, DWORD PTR _pkUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetBestDefender
PUBLIC	?lGetSelectedUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetSelectedUnit
EXTRN	?getSelectedUnit@CvPlot@@QAEPAVCvUnit@@XZ:PROC	; CvPlot::getSelectedUnit
; Function compile flags: /Ogtpy
;	COMDAT ?lGetSelectedUnit@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetSelectedUnit@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetSelectedUnit, COMDAT

; 613  : {

	push	ebx
	push	ebp
	push	esi

; 614  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetSelect
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetSelect
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetSelect
	xor	bl, bl
$LN5@lGetSelect:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetSelect
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetSelect:

; 615  : 	CvUnit* pkUnit = pkPlot->getSelectedUnit();

	mov	ecx, edi
	call	?getSelectedUnit@CvPlot@@QAEPAVCvUnit@@XZ ; CvPlot::getSelectedUnit

; 616  : 	CvLuaUnit::Push(L, pkUnit);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::Push
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 617  : 	return 1;

	mov	eax, 1
	pop	ebx

; 618  : }

	ret	0
?lGetSelectedUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetSelectedUnit
_TEXT	ENDS
PUBLIC	?lGetUnitPower@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetUnitPower
EXTRN	?getUnitPower@CvPlot@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlot::getUnitPower
; Function compile flags: /Ogtpy
;	COMDAT ?lGetUnitPower@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetUnitPower@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetUnitPower, COMDAT

; 623  : 	return BasicLuaMethod(L, &CvPlot::getUnitPower);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getUnitPower@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getUnitPower
	push	eax
	call	??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
	add	esp, 8

; 624  : }

	ret	0
?lGetUnitPower@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetUnitPower
_TEXT	ENDS
PUBLIC	?lDefenseModifier@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lDefenseModifier
EXTRN	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z:PROC ; CvPlot::defenseModifier
; Function compile flags: /Ogtpy
;	COMDAT ?lDefenseModifier@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lDefenseModifier@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lDefenseModifier, COMDAT

; 630  : 	return BasicLuaMethod(L, &CvPlot::defenseModifier);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ; CvPlot::defenseModifier
	push	eax
	call	??$BasicLuaMethod@HW4TeamTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@_N2@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,bool,bool>
	add	esp, 8

; 631  : }

	ret	0
?lDefenseModifier@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lDefenseModifier
_TEXT	ENDS
PUBLIC	?lMovementCost@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lMovementCost
EXTRN	?movementCost@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z:PROC ; CvPlot::movementCost
; Function compile flags: /Ogtpy
;	COMDAT ?lMovementCost@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lMovementCost@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lMovementCost, COMDAT

; 636  : 	return BasicLuaMethod(L, &CvPlot::movementCost);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?movementCost@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z ; CvPlot::movementCost
	push	eax
	call	??$BasicLuaMethod@HPBVCvUnit@@PBVCvPlot@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@PBV2@H@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *,CvPlot const *,int>
	add	esp, 8

; 637  : }

	ret	0
?lMovementCost@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lMovementCost
_TEXT	ENDS
PUBLIC	?lGetExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetExtraMovePathCost
EXTRN	?getExtraMovePathCost@CvPlot@@QBEHXZ:PROC	; CvPlot::getExtraMovePathCost
; Function compile flags: /Ogtpy
;	COMDAT ?lGetExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetExtraMovePathCost, COMDAT

; 643  : 	return BasicLuaMethod(L, &CvPlot::getExtraMovePathCost);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getExtraMovePathCost@CvPlot@@QBEHXZ ; CvPlot::getExtraMovePathCost
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 644  : }

	ret	0
?lGetExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetExtraMovePathCost
_TEXT	ENDS
PUBLIC	?lChangeExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeExtraMovePathCost
EXTRN	?changeExtraMovePathCost@CvPlot@@QAEXH@Z:PROC	; CvPlot::changeExtraMovePathCost
; Function compile flags: /Ogtpy
;	COMDAT ?lChangeExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lChangeExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lChangeExtraMovePathCost, COMDAT

; 649  : 	return BasicLuaMethod(L, &CvPlot::changeExtraMovePathCost);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?changeExtraMovePathCost@CvPlot@@QAEXH@Z ; CvPlot::changeExtraMovePathCost
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 650  : }

	ret	0
?lChangeExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lChangeExtraMovePathCost
_TEXT	ENDS
PUBLIC	?lIsAdjacentOwned@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentOwned
EXTRN	?isAdjacentOwned@CvPlot@@QBE_NXZ:PROC		; CvPlot::isAdjacentOwned
; Function compile flags: /Ogtpy
;	COMDAT ?lIsAdjacentOwned@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentOwned@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsAdjacentOwned, COMDAT

; 656  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentOwned);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isAdjacentOwned@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentOwned
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 657  : }

	ret	0
?lIsAdjacentOwned@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsAdjacentOwned
_TEXT	ENDS
PUBLIC	?lIsAdjacentPlayer@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentPlayer
EXTRN	?isAdjacentPlayer@CvPlot@@QBE_NW4PlayerTypes@@_N@Z:PROC ; CvPlot::isAdjacentPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?lIsAdjacentPlayer@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentPlayer@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsAdjacentPlayer, COMDAT

; 662  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentPlayer);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isAdjacentPlayer@CvPlot@@QBE_NW4PlayerTypes@@_N@Z ; CvPlot::isAdjacentPlayer
	push	eax
	call	??$BasicLuaMethod@_NW4PlayerTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes,bool>
	add	esp, 8

; 663  : }

	ret	0
?lIsAdjacentPlayer@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsAdjacentPlayer
_TEXT	ENDS
PUBLIC	?lIsAdjacentTeam@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsAdjacentTeam
EXTRN	?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z:PROC ; CvPlot::isAdjacentTeam
; Function compile flags: /Ogtpy
;	COMDAT ?lIsAdjacentTeam@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentTeam@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsAdjacentTeam, COMDAT

; 668  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentTeam);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isAdjacentTeam
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,bool>
	add	esp, 8

; 669  : }

	ret	0
?lIsAdjacentTeam@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsAdjacentTeam
_TEXT	ENDS
PUBLIC	?lIsOwned@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsOwned
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
; Function compile flags: /Ogtpy
;	COMDAT ?lIsOwned@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsOwned@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsOwned, COMDAT

; 674  : 	return BasicLuaMethod(L, &CvPlot::isOwned);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 675  : }

	ret	0
?lIsOwned@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsOwned
_TEXT	ENDS
PUBLIC	?lIsBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsBarbarian
EXTRN	?isBarbarian@CvPlot@@QBE_NXZ:PROC		; CvPlot::isBarbarian
; Function compile flags: /Ogtpy
;	COMDAT ?lIsBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsBarbarian, COMDAT

; 680  : 	return BasicLuaMethod(L, &CvPlot::isBarbarian);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isBarbarian@CvPlot@@QBE_NXZ	; CvPlot::isBarbarian
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 681  : }

	ret	0
?lIsBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsBarbarian
_TEXT	ENDS
PUBLIC	?lIsRevealedBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRevealedBarbarian
EXTRN	?isRevealedBarbarian@CvPlot@@QBE_NXZ:PROC	; CvPlot::isRevealedBarbarian
; Function compile flags: /Ogtpy
;	COMDAT ?lIsRevealedBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRevealedBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsRevealedBarbarian, COMDAT

; 686  : 	return BasicLuaMethod(L, &CvPlot::isRevealedBarbarian);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isRevealedBarbarian@CvPlot@@QBE_NXZ ; CvPlot::isRevealedBarbarian
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 687  : }

	ret	0
?lIsRevealedBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsRevealedBarbarian
_TEXT	ENDS
PUBLIC	?lHasBarbarianCamp@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lHasBarbarianCamp
EXTRN	?HasBarbarianCamp@CvPlot@@QAE_NXZ:PROC		; CvPlot::HasBarbarianCamp
; Function compile flags: /Ogtpy
;	COMDAT ?lHasBarbarianCamp@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lHasBarbarianCamp@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lHasBarbarianCamp, COMDAT

; 691  : 	return BasicLuaMethod(L, &CvPlot::HasBarbarianCamp);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?HasBarbarianCamp@CvPlot@@QAE_NXZ ; CvPlot::HasBarbarianCamp
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 692  : }

	ret	0
?lHasBarbarianCamp@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lHasBarbarianCamp
_TEXT	ENDS
PUBLIC	?lIsVisible@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsVisible
EXTRN	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z:PROC	; luaL_optbool
; Function compile flags: /Ogtpy
;	COMDAT ?lIsVisible@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsVisible@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsVisible, COMDAT

; 696  : {

	push	ebx
	push	ebp
	push	esi

; 697  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lIsVisible
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lIsVisible
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lIsVisible
	xor	bl, bl
$LN5@lIsVisible:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lIsVisible
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lIsVisible:

; 698  : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 699  : 	const bool bDebug = luaL_optbool(L, 3, false);

	push	0
	push	3
	push	esi
	mov	ebx, eax
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 20					; 00000014H

; 700  : 
; 701  : 	lua_pushboolean(L, pkPlot->isVisible(eTeam, bDebug));

	test	al, al
	je	SHORT $LN16@lIsVisible
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN16@lIsVisible
	mov	al, 1
	jmp	SHORT $LN15@lIsVisible
$LN16@lIsVisible:
	cmp	ebx, -1
	jne	SHORT $LN14@lIsVisible
	xor	al, al
	jmp	SHORT $LN15@lIsVisible
$LN14@lIsVisible:
	mov	eax, DWORD PTR [edi+156]
	cmp	WORD PTR [eax+ebx*2], 0
	setg	al
$LN15@lIsVisible:
	movzx	ecx, al
	push	ecx
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 702  : 	return 1;

	mov	eax, 1
	pop	ebx

; 703  : }

	ret	0
?lIsVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsVisible
_TEXT	ENDS
PUBLIC	?lIsActiveVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsActiveVisible
EXTRN	?isActiveVisible@CvPlot@@QBE_N_N@Z:PROC		; CvPlot::isActiveVisible
EXTRN	?isActiveVisible@CvPlot@@QBE_NXZ:PROC		; CvPlot::isActiveVisible
; Function compile flags: /Ogtpy
;	COMDAT ?lIsActiveVisible@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsActiveVisible@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsActiveVisible, COMDAT

; 707  : {

	push	ebx
	push	ebp
	push	esi

; 708  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@lIsActiveV
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@lIsActiveV
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@lIsActiveV
	xor	bl, bl
$LN7@lIsActiveV:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@lIsActiveV
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@lIsActiveV:

; 709  : 	const bool bDebug = luaL_optbool(L, 2, false);

	push	0
	push	2
	push	esi
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 12					; 0000000cH

; 710  : 
; 711  : 	if (!bDebug)
; 712  : 		lua_pushboolean(L, pkPlot->isActiveVisible());

	mov	ecx, edi
	test	al, al
	jne	SHORT $LN2@lIsActiveV
	call	?isActiveVisible@CvPlot@@QBE_NXZ	; CvPlot::isActiveVisible
	movzx	eax, al
	push	eax

; 713  : 	else
; 714  : 		lua_pushboolean(L, pkPlot->isActiveVisible(true));

	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 715  : 
; 716  : 	return 1;

	mov	eax, 1
	pop	ebx

; 717  : }

	ret	0
$LN2@lIsActiveV:

; 713  : 	else
; 714  : 		lua_pushboolean(L, pkPlot->isActiveVisible(true));

	push	1
	call	?isActiveVisible@CvPlot@@QBE_N_N@Z	; CvPlot::isActiveVisible
	movzx	ecx, al
	push	ecx
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 715  : 
; 716  : 	return 1;

	mov	eax, 1
	pop	ebx

; 717  : }

	ret	0
?lIsActiveVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsActiveVisible
_TEXT	ENDS
PUBLIC	?lIsVisibleToWatchingHuman@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleToWatchingHuman
EXTRN	?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ:PROC	; CvPlot::isVisibleToWatchingHuman
; Function compile flags: /Ogtpy
;	COMDAT ?lIsVisibleToWatchingHuman@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsVisibleToWatchingHuman@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsVisibleToWatchingHuman, COMDAT

; 722  : 	return BasicLuaMethod(L, &CvPlot::isVisibleToWatchingHuman);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ ; CvPlot::isVisibleToWatchingHuman
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 723  : }

	ret	0
?lIsVisibleToWatchingHuman@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsVisibleToWatchingHuman
_TEXT	ENDS
PUBLIC	?lIsAdjacentVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentVisible
EXTRN	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z:PROC ; CvPlot::isAdjacentVisible
EXTRN	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isAdjacentVisible
; Function compile flags: /Ogtpy
;	COMDAT ?lIsAdjacentVisible@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentVisible@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsAdjacentVisible, COMDAT

; 727  : {

	push	ebx
	push	ebp
	push	esi

; 728  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@lIsAdjacen@2
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@lIsAdjacen@2
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@lIsAdjacen@2
	xor	bl, bl
$LN7@lIsAdjacen@2:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@lIsAdjacen@2
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@lIsAdjacen@2:

; 729  : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 730  : 	const bool bDebug = luaL_optbool(L, 3, false);

	push	0
	push	3
	push	esi
	mov	ebx, eax
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 20					; 00000014H

; 731  : 
; 732  : 	if (!bDebug)
; 733  : 		lua_pushboolean(L, pkPlot->isAdjacentVisible(eTeam));

	mov	ecx, edi
	test	al, al
	jne	SHORT $LN2@lIsAdjacen@2
	push	ebx
	call	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentVisible
	movzx	eax, al
	push	eax

; 734  : 	else
; 735  : 		lua_pushboolean(L, pkPlot->isAdjacentVisible(eTeam, true));

	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 736  : 
; 737  : 	return 1;

	mov	eax, 1
	pop	ebx

; 738  : }

	ret	0
$LN2@lIsAdjacen@2:

; 734  : 	else
; 735  : 		lua_pushboolean(L, pkPlot->isAdjacentVisible(eTeam, true));

	push	1
	push	ebx
	call	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isAdjacentVisible
	movzx	ecx, al
	push	ecx
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 736  : 
; 737  : 	return 1;

	mov	eax, 1
	pop	ebx

; 738  : }

	ret	0
?lIsAdjacentVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsAdjacentVisible
_TEXT	ENDS
PUBLIC	?lIsAdjacentNonvisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentNonvisible
EXTRN	?isAdjacentNonvisible@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isAdjacentNonvisible
; Function compile flags: /Ogtpy
;	COMDAT ?lIsAdjacentNonvisible@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentNonvisible@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsAdjacentNonvisible, COMDAT

; 743  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentNonvisible);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isAdjacentNonvisible@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentNonvisible
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>
	add	esp, 8

; 744  : }

	ret	0
?lIsAdjacentNonvisible@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsAdjacentNonvisible
_TEXT	ENDS
PUBLIC	?lIsAdjacentRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentRevealed
EXTRN	?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isAdjacentRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?lIsAdjacentRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsAdjacentRevealed, COMDAT

; 749  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentRevealed);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentRevealed
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>
	add	esp, 8

; 750  : }

	ret	0
?lIsAdjacentRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsAdjacentRevealed
_TEXT	ENDS
PUBLIC	?lIsAdjacentNonrevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentNonrevealed
EXTRN	?isAdjacentNonrevealed@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isAdjacentNonrevealed
; Function compile flags: /Ogtpy
;	COMDAT ?lIsAdjacentNonrevealed@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentNonrevealed@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsAdjacentNonrevealed, COMDAT

; 755  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentNonrevealed);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isAdjacentNonrevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentNonrevealed
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>
	add	esp, 8

; 756  : }

	ret	0
?lIsAdjacentNonrevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsAdjacentNonrevealed
_TEXT	ENDS
PUBLIC	?lIsGoody@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsGoody
EXTRN	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC	; CvPlot::isGoody
; Function compile flags: /Ogtpy
;	COMDAT ?lIsGoody@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsGoody@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsGoody, COMDAT

; 768  : 	return BasicLuaMethod(L, &CvPlot::isGoody);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isGoody
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>
	add	esp, 8

; 769  : }

	ret	0
?lIsGoody@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsGoody
_TEXT	ENDS
PUBLIC	?lIsRevealedGoody@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRevealedGoody
EXTRN	?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isRevealedGoody
; Function compile flags: /Ogtpy
;	COMDAT ?lIsRevealedGoody@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRevealedGoody@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsRevealedGoody, COMDAT

; 774  : 	return BasicLuaMethod(L, &CvPlot::isRevealedGoody);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isRevealedGoody
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>
	add	esp, 8

; 775  : }

	ret	0
?lIsRevealedGoody@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsRevealedGoody
_TEXT	ENDS
PUBLIC	?lIsFriendlyTerritory@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsFriendlyTerritory
EXTRN	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsFriendlyTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?lIsFriendlyTerritory@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsFriendlyTerritory@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsFriendlyTerritory, COMDAT

; 779  : {

	push	ebx
	push	ebp
	push	esi

; 780  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lIsFriendl
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lIsFriendl
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lIsFriendl
	xor	bl, bl
$LN5@lIsFriendl:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lIsFriendl
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lIsFriendl:

; 781  : 	const PlayerTypes ePlayer = (PlayerTypes) lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8

; 782  : 
; 783  : 	const bool bResult = pkPlot->IsFriendlyTerritory(ePlayer);

	push	eax
	mov	ecx, edi
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory

; 784  : 	lua_pushboolean(L, bResult);

	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 785  : 	return 1;

	mov	eax, 1
	pop	ebx

; 786  : }

	ret	0
?lIsFriendlyTerritory@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsFriendlyTerritory
_TEXT	ENDS
PUBLIC	?lIsCity@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lIsCity
; Function compile flags: /Ogtpy
;	COMDAT ?lIsCity@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsCity@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsCity, COMDAT

; 792  : 	return BasicLuaMethod(L, &CvPlot::isCity);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isCity@CvPlot@@QBE_NXZ		; CvPlot::isCity
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 793  : }

	ret	0
?lIsCity@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsCity
_TEXT	ENDS
PUBLIC	?lIsFriendlyCity@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsFriendlyCity
EXTRN	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z:PROC ; CvPlot::isFriendlyCity
; Function compile flags: /Ogtpy
;	COMDAT ?lIsFriendlyCity@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkInstance$227164 = -8					; size = 4
_bCheckImprovement$ = -4				; size = 1
_L$ = 8							; size = 4
?lIsFriendlyCity@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsFriendlyCity, COMDAT

; 797  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 798  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+16]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	edi, eax
	mov	bl, 1
	mov	DWORD PTR _pkInstance$227164[esp+36], 0
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lIsFriendl@2
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lIsFriendl@2
	push	-1
	push	esi
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pkInstance$227164[esp+24], eax
	test	eax, eax
	je	SHORT $LN5@lIsFriendl@2
	xor	bl, bl
$LN5@lIsFriendl@2:
	push	edi
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lIsFriendl@2
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lIsFriendl@2:

; 799  : 	CvUnit* pkUnit = CvLuaUnit::GetInstance(L, 2);

	push	esi
	call	_lua_gettop
	push	2
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN16@lIsFriendl@2
	push	OFFSET $SG223061
	push	2
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN16@lIsFriendl@2
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN16@lIsFriendl@2
	xor	bl, bl
$LN16@lIsFriendl@2:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN15@lIsFriendl@2
	push	esi
	call	?HandleMissingInstance@CvLuaUnit@@SAXPAUlua_State@@@Z ; CvLuaUnit::HandleMissingInstance
	add	esp, 4
$LN15@lIsFriendl@2:

; 800  : 	const bool bCheckImprovement = lua_toboolean(L, 3);

	push	3
	push	esi
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	al
	mov	BYTE PTR _bCheckImprovement$[esp+24], al

; 801  : 
; 802  : 	const bool bResult = pkPlot->isFriendlyCity(*pkUnit, bCheckImprovement);

	mov	ecx, DWORD PTR _bCheckImprovement$[esp+24]
	push	ecx
	mov	ecx, DWORD PTR _pkInstance$227164[esp+28]
	push	edi
	call	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z ; CvPlot::isFriendlyCity

; 803  : 	lua_pushboolean(L, bResult);

	movzx	edx, al
	push	edx
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 804  : 	return 1;

	mov	eax, 1
	pop	ebx

; 805  : }

	add	esp, 8
	ret	0
?lIsFriendlyCity@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsFriendlyCity
_TEXT	ENDS
PUBLIC	?lIsEnemyCity@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsEnemyCity
; Function compile flags: /Ogtpy
;	COMDAT ?lIsEnemyCity@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_stack_size$227214 = -4					; size = 4
_L$ = 8							; size = 4
?lIsEnemyCity@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsEnemyCity, COMDAT

; 809  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 810  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lIsEnemyCi
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lIsEnemyCi
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lIsEnemyCi
	xor	bl, bl
$LN5@lIsEnemyCi:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lIsEnemyCi
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lIsEnemyCi:

; 811  : 	CvUnit* pkUnit = CvLuaUnit::GetInstance(L, 2);

	push	esi
	call	_lua_gettop
	push	2
	push	esi
	mov	DWORD PTR _stack_size$227214[esp+32], eax
	mov	bl, 1
	xor	ebp, ebp
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN16@lIsEnemyCi
	push	OFFSET $SG223061
	push	2
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN16@lIsEnemyCi
	push	-1
	push	esi
	call	_lua_touserdata
	mov	ebp, eax
	add	esp, 8
	test	ebp, ebp
	je	SHORT $LN16@lIsEnemyCi
	xor	bl, bl
$LN16@lIsEnemyCi:
	mov	eax, DWORD PTR _stack_size$227214[esp+20]
	push	eax
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN15@lIsEnemyCi
	push	esi
	call	?HandleMissingInstance@CvLuaUnit@@SAXPAUlua_State@@@Z ; CvLuaUnit::HandleMissingInstance
	add	esp, 4
$LN15@lIsEnemyCi:

; 812  : 	const bool bResult = pkPlot->isEnemyCity(*pkUnit);

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	SHORT $LN21@lIsEnemyCi
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN21@lIsEnemyCi
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN21@lIsEnemyCi
	push	edi
	mov	ecx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, ebp
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	jmp	SHORT $LN22@lIsEnemyCi
$LN21@lIsEnemyCi:
	xor	al, al
$LN22@lIsEnemyCi:

; 813  : 	lua_pushboolean(L, bResult);

	movzx	edx, al
	push	edx
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 814  : 	return 1;

	mov	eax, 1
	pop	ebx

; 815  : }

	pop	ecx
	ret	0
?lIsEnemyCity@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsEnemyCity
_TEXT	ENDS
PUBLIC	?lIsBeingWorked@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsBeingWorked
EXTRN	?isBeingWorked@CvPlot@@QBE_NXZ:PROC		; CvPlot::isBeingWorked
; Function compile flags: /Ogtpy
;	COMDAT ?lIsBeingWorked@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsBeingWorked@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsBeingWorked, COMDAT

; 820  : 	return BasicLuaMethod(L, &CvPlot::isBeingWorked);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isBeingWorked@CvPlot@@QBE_NXZ	; CvPlot::isBeingWorked
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 821  : }

	ret	0
?lIsBeingWorked@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsBeingWorked
_TEXT	ENDS
PUBLIC	?lIsUnit@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lIsUnit
EXTRN	?isUnit@CvPlot@@QBE_NXZ:PROC			; CvPlot::isUnit
; Function compile flags: /Ogtpy
;	COMDAT ?lIsUnit@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsUnit@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsUnit, COMDAT

; 827  : 	return BasicLuaMethod(L, &CvPlot::isUnit);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isUnit@CvPlot@@QBE_NXZ		; CvPlot::isUnit
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 828  : }

	ret	0
?lIsUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsUnit
_TEXT	ENDS
PUBLIC	?lIsVisibleEnemyDefender@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleEnemyDefender
EXTRN	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z:PROC ; CvPlot::isVisibleEnemyDefender
; Function compile flags: /Ogtpy
;	COMDAT ?lIsVisibleEnemyDefender@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkInstance$227264 = -4					; size = 4
_L$ = 8							; size = 4
?lIsVisibleEnemyDefender@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsVisibleEnemyDefender, COMDAT

; 832  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 833  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	edi, eax
	mov	bl, 1
	mov	DWORD PTR _pkInstance$227264[esp+32], 0
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lIsVisible@2
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lIsVisible@2
	push	-1
	push	esi
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pkInstance$227264[esp+20], eax
	test	eax, eax
	je	SHORT $LN5@lIsVisible@2
	xor	bl, bl
$LN5@lIsVisible@2:
	push	edi
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lIsVisible@2
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lIsVisible@2:

; 834  : 	CvUnit* pkUnit = CvLuaUnit::GetInstance(L, 2);

	push	esi
	call	_lua_gettop
	push	2
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN16@lIsVisible@2
	push	OFFSET $SG223061
	push	2
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN16@lIsVisible@2
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN16@lIsVisible@2
	xor	bl, bl
$LN16@lIsVisible@2:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN15@lIsVisible@2
	push	esi
	call	?HandleMissingInstance@CvLuaUnit@@SAXPAUlua_State@@@Z ; CvLuaUnit::HandleMissingInstance
	add	esp, 4
$LN15@lIsVisible@2:

; 835  : 	const bool bResult = pkPlot->isVisibleEnemyDefender(pkUnit);

	mov	ecx, DWORD PTR _pkInstance$227264[esp+20]
	push	edi
	call	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyDefender

; 836  : 	lua_pushboolean(L, bResult);

	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 837  : 
; 838  : 	return 1;

	mov	eax, 1
	pop	ebx

; 839  : }

	pop	ecx
	ret	0
?lIsVisibleEnemyDefender@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsVisibleEnemyDefender
_TEXT	ENDS
PUBLIC	?lGetNumDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumDefenders
EXTRN	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlot::getNumDefenders
; Function compile flags: /Ogtpy
;	COMDAT ?lGetNumDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetNumDefenders, COMDAT

; 844  : 	return BasicLuaMethod(L, &CvPlot::getNumDefenders);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumDefenders
	push	eax
	call	??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
	add	esp, 8

; 845  : }

	ret	0
?lGetNumDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetNumDefenders
_TEXT	ENDS
PUBLIC	?lGetNumVisibleEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumVisibleEnemyDefenders
EXTRN	?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z:PROC ; CvPlot::getNumVisibleEnemyDefenders
; Function compile flags: /Ogtpy
;	COMDAT ?lGetNumVisibleEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumVisibleEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetNumVisibleEnemyDefenders, COMDAT

; 850  : 	return BasicLuaMethod(L, &CvPlot::getNumVisibleEnemyDefenders);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ; CvPlot::getNumVisibleEnemyDefenders
	push	eax
	call	??$BasicLuaMethod@HPBVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *>
	add	esp, 8

; 851  : }

	ret	0
?lGetNumVisibleEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetNumVisibleEnemyDefenders
_TEXT	ENDS
PUBLIC	?lGetNumVisiblePotentialEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumVisiblePotentialEnemyDefenders
EXTRN	?getNumVisiblePotentialEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z:PROC ; CvPlot::getNumVisiblePotentialEnemyDefenders
; Function compile flags: /Ogtpy
;	COMDAT ?lGetNumVisiblePotentialEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumVisiblePotentialEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetNumVisiblePotentialEnemyDefenders, COMDAT

; 856  : 	return BasicLuaMethod(L, &CvPlot::getNumVisiblePotentialEnemyDefenders);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getNumVisiblePotentialEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ; CvPlot::getNumVisiblePotentialEnemyDefenders
	push	eax
	call	??$BasicLuaMethod@HPBVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *>
	add	esp, 8

; 857  : }

	ret	0
?lGetNumVisiblePotentialEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetNumVisiblePotentialEnemyDefenders
_TEXT	ENDS
PUBLIC	?lIsVisibleEnemyUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleEnemyUnit
EXTRN	?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::isVisibleEnemyUnit
; Function compile flags: /Ogtpy
;	COMDAT ?lIsVisibleEnemyUnit@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsVisibleEnemyUnit@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsVisibleEnemyUnit, COMDAT

; 861  : {

	push	ebx
	push	ebp
	push	esi

; 862  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lIsVisible@3
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lIsVisible@3
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lIsVisible@3
	xor	bl, bl
$LN5@lIsVisible@3:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lIsVisible@3
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lIsVisible@3:

; 863  : 	const PlayerTypes ePlayer = (PlayerTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8

; 864  : 	const bool bResult = pkPlot->isVisibleEnemyUnit(ePlayer);

	push	eax
	mov	ecx, edi
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleEnemyUnit

; 865  : 	lua_pushboolean(L, bResult);

	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 866  : 	return 1;

	mov	eax, 1
	pop	ebx

; 867  : }

	ret	0
?lIsVisibleEnemyUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsVisibleEnemyUnit
_TEXT	ENDS
PUBLIC	?lIsVisibleOtherUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleOtherUnit
EXTRN	?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::isVisibleOtherUnit
; Function compile flags: /Ogtpy
;	COMDAT ?lIsVisibleOtherUnit@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsVisibleOtherUnit@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsVisibleOtherUnit, COMDAT

; 872  : 	return BasicLuaMethod(L, &CvPlot::isVisibleOtherUnit);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleOtherUnit
	push	eax
	call	??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>
	add	esp, 8

; 873  : }

	ret	0
?lIsVisibleOtherUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsVisibleOtherUnit
_TEXT	ENDS
PUBLIC	?lGetNumFriendlyUnitsOfType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumFriendlyUnitsOfType
EXTRN	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z:PROC ; CvPlot::getNumFriendlyUnitsOfType
; Function compile flags: /Ogtpy
;	COMDAT ?lGetNumFriendlyUnitsOfType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkInstance$227343 = -8					; size = 4
_bBreakOnUnitLimit$ = -4				; size = 1
_L$ = 8							; size = 4
?lGetNumFriendlyUnitsOfType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetNumFriendlyUnitsOfType, COMDAT

; 877  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 878  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+16]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	edi, eax
	mov	bl, 1
	mov	DWORD PTR _pkInstance$227343[esp+36], 0
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetNumFri
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetNumFri
	push	-1
	push	esi
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pkInstance$227343[esp+24], eax
	test	eax, eax
	je	SHORT $LN5@lGetNumFri
	xor	bl, bl
$LN5@lGetNumFri:
	push	edi
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetNumFri
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetNumFri:

; 879  : 	CvUnit* pkUnit = CvLuaUnit::GetInstance(L, 2);

	push	esi
	call	_lua_gettop
	push	2
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN16@lGetNumFri
	push	OFFSET $SG223061
	push	2
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN16@lGetNumFri
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN16@lGetNumFri
	xor	bl, bl
$LN16@lGetNumFri:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN15@lGetNumFri
	push	esi
	call	?HandleMissingInstance@CvLuaUnit@@SAXPAUlua_State@@@Z ; CvLuaUnit::HandleMissingInstance
	add	esp, 4
$LN15@lGetNumFri:

; 880  : 
; 881  : 	bool bBreakOnUnitLimit = luaL_optbool(L, 3, true);

	push	1
	push	3
	push	esi
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool

; 882  : 	int iResult = pkPlot->getNumFriendlyUnitsOfType(pkUnit, bBreakOnUnitLimit);

	mov	ecx, DWORD PTR _pkInstance$227343[esp+36]
	mov	BYTE PTR _bBreakOnUnitLimit$[esp+36], al
	mov	eax, DWORD PTR _bBreakOnUnitLimit$[esp+36]
	add	esp, 12					; 0000000cH
	push	eax
	push	edi
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType

; 883  : 
; 884  : 	lua_pushinteger(L, iResult);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 885  : 	return 1;

	mov	eax, 1
	pop	ebx

; 886  : }

	add	esp, 8
	ret	0
?lGetNumFriendlyUnitsOfType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetNumFriendlyUnitsOfType
_TEXT	ENDS
PUBLIC	?lIsFighting@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsFighting
EXTRN	?isFighting@CvPlot@@QBE_NXZ:PROC		; CvPlot::isFighting
; Function compile flags: /Ogtpy
;	COMDAT ?lIsFighting@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsFighting@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsFighting, COMDAT

; 891  : 	return BasicLuaMethod(L, &CvPlot::isFighting);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isFighting@CvPlot@@QBE_NXZ	; CvPlot::isFighting
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 892  : }

	ret	0
?lIsFighting@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsFighting
_TEXT	ENDS
PUBLIC	?lIsRoute@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsRoute
EXTRN	?isRoute@CvPlot@@QBE_NXZ:PROC			; CvPlot::isRoute
; Function compile flags: /Ogtpy
;	COMDAT ?lIsRoute@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRoute@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsRoute, COMDAT

; 897  : 	return BasicLuaMethod(L, &CvPlot::isRoute);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isRoute@CvPlot@@QBE_NXZ		; CvPlot::isRoute
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 898  : }

	ret	0
?lIsRoute@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsRoute
_TEXT	ENDS
PUBLIC	?lIsTradeRoute@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsTradeRoute
EXTRN	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsTradeRoute
; Function compile flags: /Ogtpy
;	COMDAT ?lIsTradeRoute@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsTradeRoute@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsTradeRoute, COMDAT

; 901  : {

	push	ebx
	push	ebp
	push	esi

; 902  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lIsTradeRo
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lIsTradeRo
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lIsTradeRo
	xor	bl, bl
$LN5@lIsTradeRo:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lIsTradeRo
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lIsTradeRo:

; 903  : 	PlayerTypes ePlayer = (PlayerTypes)luaL_optint(L, 2, -1);

	push	-1
	push	2
	push	esi
	call	_luaL_optinteger
	add	esp, 12					; 0000000cH

; 904  : 	bool bResult = pkPlot->IsTradeRoute(ePlayer);

	push	eax
	mov	ecx, edi
	call	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsTradeRoute

; 905  : 	lua_pushboolean(L, bResult);

	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 906  : 	return 1;

	mov	eax, 1
	pop	ebx

; 907  : }

	ret	0
?lIsTradeRoute@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsTradeRoute
_TEXT	ENDS
PUBLIC	?lIsValidDomainForLocation@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsValidDomainForLocation
EXTRN	?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z:PROC ; CvPlot::isValidDomainForLocation
; Function compile flags: /Ogtpy
;	COMDAT ?lIsValidDomainForLocation@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkInstance$227413 = -4					; size = 4
_L$ = 8							; size = 4
?lIsValidDomainForLocation@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsValidDomainForLocation, COMDAT

; 911  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 912  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	edi, eax
	mov	bl, 1
	mov	DWORD PTR _pkInstance$227413[esp+32], 0
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lIsValidDo
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lIsValidDo
	push	-1
	push	esi
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pkInstance$227413[esp+20], eax
	test	eax, eax
	je	SHORT $LN5@lIsValidDo
	xor	bl, bl
$LN5@lIsValidDo:
	push	edi
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lIsValidDo
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lIsValidDo:

; 913  : 	CvUnit* pkUnit = CvLuaUnit::GetInstance(L, 2);

	push	esi
	call	_lua_gettop
	push	2
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN16@lIsValidDo
	push	OFFSET $SG223061
	push	2
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN16@lIsValidDo
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN16@lIsValidDo
	xor	bl, bl
$LN16@lIsValidDo:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN15@lIsValidDo
	push	esi
	call	?HandleMissingInstance@CvLuaUnit@@SAXPAUlua_State@@@Z ; CvLuaUnit::HandleMissingInstance
	add	esp, 4
$LN15@lIsValidDo:

; 914  : 
; 915  : 	const bool bResult = pkPlot->isValidDomainForLocation(*pkUnit);

	mov	ecx, DWORD PTR _pkInstance$227413[esp+20]
	push	edi
	call	?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForLocation

; 916  : 	lua_pushboolean(L, bResult);

	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 917  : 	return 1;

	mov	eax, 1
	pop	ebx

; 918  : }

	pop	ecx
	ret	0
?lIsValidDomainForLocation@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsValidDomainForLocation
_TEXT	ENDS
PUBLIC	?lIsValidDomainForAction@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsValidDomainForAction
EXTRN	?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z:PROC ; CvPlot::isValidDomainForAction
; Function compile flags: /Ogtpy
;	COMDAT ?lIsValidDomainForAction@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkInstance$227450 = -4					; size = 4
_L$ = 8							; size = 4
?lIsValidDomainForAction@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsValidDomainForAction, COMDAT

; 922  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 923  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	edi, eax
	mov	bl, 1
	mov	DWORD PTR _pkInstance$227450[esp+32], 0
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lIsValidDo@2
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lIsValidDo@2
	push	-1
	push	esi
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pkInstance$227450[esp+20], eax
	test	eax, eax
	je	SHORT $LN5@lIsValidDo@2
	xor	bl, bl
$LN5@lIsValidDo@2:
	push	edi
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lIsValidDo@2
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lIsValidDo@2:

; 924  : 	CvUnit* pkUnit = CvLuaUnit::GetInstance(L, 2);

	push	esi
	call	_lua_gettop
	push	2
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN16@lIsValidDo@2
	push	OFFSET $SG223061
	push	2
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN16@lIsValidDo@2
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN16@lIsValidDo@2
	xor	bl, bl
$LN16@lIsValidDo@2:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN15@lIsValidDo@2
	push	esi
	call	?HandleMissingInstance@CvLuaUnit@@SAXPAUlua_State@@@Z ; CvLuaUnit::HandleMissingInstance
	add	esp, 4
$LN15@lIsValidDo@2:

; 925  : 
; 926  : 	const bool bResult = pkPlot->isValidDomainForAction(*pkUnit);

	mov	ecx, DWORD PTR _pkInstance$227450[esp+20]
	push	edi
	call	?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForAction

; 927  : 	lua_pushboolean(L, bResult);

	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 928  : 	return 1;

	mov	eax, 1
	pop	ebx

; 929  : }

	pop	ecx
	ret	0
?lIsValidDomainForAction@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsValidDomainForAction
_TEXT	ENDS
PUBLIC	?lIsImpassable@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?lIsImpassable@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsImpassable@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsImpassable, COMDAT

; 934  : 	return BasicLuaMethod(L, &CvPlot::isImpassable);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isImpassable@CvPlot@@QBE_NXZ	; CvPlot::isImpassable
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 935  : }

	ret	0
?lIsImpassable@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsImpassable
_TEXT	ENDS
PUBLIC	?lGetX@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lGetX
; Function compile flags: /Ogtpy
;	COMDAT ?lGetX@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetX@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lGetX, COMDAT

; 941  : 	return BasicLuaMethod(L, &CvPlot::getX);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getX@CvPlot@@QBEHXZ		; CvPlot::getX
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 942  : }

	ret	0
?lGetX@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lGetX
_TEXT	ENDS
PUBLIC	?lGetY@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lGetY
; Function compile flags: /Ogtpy
;	COMDAT ?lGetY@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetY@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lGetY, COMDAT

; 947  : 	return BasicLuaMethod(L, &CvPlot::getY);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getY@CvPlot@@QBEHXZ		; CvPlot::getY
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 948  : }

	ret	0
?lGetY@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lGetY
_TEXT	ENDS
PUBLIC	?lAt@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lAt
EXTRN	?at@CvPlot@@QBE_NHH@Z:PROC			; CvPlot::at
; Function compile flags: /Ogtpy
;	COMDAT ?lAt@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lAt@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lAt, COMDAT

; 953  : 	return BasicLuaMethod(L, &CvPlot::at);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?at@CvPlot@@QBE_NHH@Z		; CvPlot::at
	push	eax
	call	??$BasicLuaMethod@_NHH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NHH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int,int>
	add	esp, 8

; 954  : }

	ret	0
?lAt@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lAt
_TEXT	ENDS
PUBLIC	?lGetPlotIndex@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetPlotIndex
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
; Function compile flags: /Ogtpy
;	COMDAT ?lGetPlotIndex@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetPlotIndex@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetPlotIndex, COMDAT

; 959  : 	return BasicLuaMethod(L, &CvPlot::GetPlotIndex);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?GetPlotIndex@CvPlot@@QBEHXZ	; CvPlot::GetPlotIndex
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 960  : }

	ret	0
?lGetPlotIndex@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetPlotIndex
_TEXT	ENDS
PUBLIC	?lGetLatitude@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetLatitude
EXTRN	?getLatitude@CvPlot@@QBEHXZ:PROC		; CvPlot::getLatitude
; Function compile flags: /Ogtpy
;	COMDAT ?lGetLatitude@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetLatitude@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetLatitude, COMDAT

; 965  : 	return BasicLuaMethod(L, &CvPlot::getLatitude);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getLatitude@CvPlot@@QBEHXZ	; CvPlot::getLatitude
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 966  : }

	ret	0
?lGetLatitude@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetLatitude
_TEXT	ENDS
PUBLIC	?lArea@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lArea
EXTRN	?area@CvPlot@@QBEPAVCvArea@@XZ:PROC		; CvPlot::area
; Function compile flags: /Ogtpy
;	COMDAT ?lArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lArea, COMDAT

; 970  : {

	push	ebx
	push	ebp
	push	esi

; 971  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lArea
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lArea
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lArea
	xor	bl, bl
$LN5@lArea:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lArea
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lArea:

; 972  : 	CvArea* pkArea = pkPlot->area();

	mov	ecx, edi
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area

; 973  : 	CvLuaArea::Push(L, pkArea);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 974  : 	return 1;

	mov	eax, 1
	pop	ebx

; 975  : }

	ret	0
?lArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lArea
_TEXT	ENDS
PUBLIC	?lWaterArea@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lWaterArea
EXTRN	?waterArea@CvPlot@@QBEPAVCvArea@@XZ:PROC	; CvPlot::waterArea
; Function compile flags: /Ogtpy
;	COMDAT ?lWaterArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lWaterArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lWaterArea, COMDAT

; 979  : {

	push	ebx
	push	ebp
	push	esi

; 980  : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lWaterArea
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lWaterArea
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lWaterArea
	xor	bl, bl
$LN5@lWaterArea:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lWaterArea
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lWaterArea:

; 981  : 	CvArea* pkArea = pkPlot->waterArea();

	mov	ecx, edi
	call	?waterArea@CvPlot@@QBEPAVCvArea@@XZ	; CvPlot::waterArea

; 982  : 	CvLuaArea::Push(L, pkArea);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 983  : 	return 1;

	mov	eax, 1
	pop	ebx

; 984  : }

	ret	0
?lWaterArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lWaterArea
_TEXT	ENDS
PUBLIC	?lGetArea@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetArea
; Function compile flags: /Ogtpy
;	COMDAT ?lGetArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lGetArea, COMDAT

; 989  : 	return BasicLuaMethod(L, &CvPlot::getArea);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getArea@CvPlot@@QBEHXZ		; CvPlot::getArea
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 990  : }

	ret	0
?lGetArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lGetArea
_TEXT	ENDS
PUBLIC	?lSetArea@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetArea
EXTRN	?setArea@CvPlot@@QAEXH@Z:PROC			; CvPlot::setArea
; Function compile flags: /Ogtpy
;	COMDAT ?lSetArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lSetArea, COMDAT

; 995  : 	return BasicLuaMethod(L, &CvPlot::setArea);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?setArea@CvPlot@@QAEXH@Z		; CvPlot::setArea
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 996  : }

	ret	0
?lSetArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lSetArea
_TEXT	ENDS
PUBLIC	?lGetFeatureVariety@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetFeatureVariety
EXTRN	?getFeatureVariety@CvPlot@@QBEHXZ:PROC		; CvPlot::getFeatureVariety
; Function compile flags: /Ogtpy
;	COMDAT ?lGetFeatureVariety@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetFeatureVariety@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetFeatureVariety, COMDAT

; 1001 : 	return BasicLuaMethod(L, &CvPlot::getFeatureVariety);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getFeatureVariety@CvPlot@@QBEHXZ ; CvPlot::getFeatureVariety
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1002 : }

	ret	0
?lGetFeatureVariety@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetFeatureVariety
_TEXT	ENDS
PUBLIC	?lGetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetOwnershipDuration
EXTRN	?getOwnershipDuration@CvPlot@@QBEHXZ:PROC	; CvPlot::getOwnershipDuration
; Function compile flags: /Ogtpy
;	COMDAT ?lGetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetOwnershipDuration, COMDAT

; 1008 : 	return BasicLuaMethod(L, &CvPlot::getOwnershipDuration);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getOwnershipDuration@CvPlot@@QBEHXZ ; CvPlot::getOwnershipDuration
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1009 : }

	ret	0
?lGetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetOwnershipDuration
_TEXT	ENDS
PUBLIC	?lIsOwnershipScore@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsOwnershipScore
EXTRN	?isOwnershipScore@CvPlot@@QBE_NXZ:PROC		; CvPlot::isOwnershipScore
; Function compile flags: /Ogtpy
;	COMDAT ?lIsOwnershipScore@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsOwnershipScore@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsOwnershipScore, COMDAT

; 1014 : 	return BasicLuaMethod(L, &CvPlot::isOwnershipScore);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isOwnershipScore@CvPlot@@QBE_NXZ ; CvPlot::isOwnershipScore
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1015 : }

	ret	0
?lIsOwnershipScore@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsOwnershipScore
_TEXT	ENDS
PUBLIC	?lSetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetOwnershipDuration
EXTRN	?setOwnershipDuration@CvPlot@@QAEXH@Z:PROC	; CvPlot::setOwnershipDuration
; Function compile flags: /Ogtpy
;	COMDAT ?lSetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lSetOwnershipDuration, COMDAT

; 1020 : 	return BasicLuaMethod(L, &CvPlot::setOwnershipDuration);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?setOwnershipDuration@CvPlot@@QAEXH@Z ; CvPlot::setOwnershipDuration
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1021 : }

	ret	0
?lSetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lSetOwnershipDuration
_TEXT	ENDS
PUBLIC	?lChangeOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeOwnershipDuration
EXTRN	?changeOwnershipDuration@CvPlot@@QAEXH@Z:PROC	; CvPlot::changeOwnershipDuration
; Function compile flags: /Ogtpy
;	COMDAT ?lChangeOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lChangeOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lChangeOwnershipDuration, COMDAT

; 1026 : 	return BasicLuaMethod(L, &CvPlot::changeOwnershipDuration);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?changeOwnershipDuration@CvPlot@@QAEXH@Z ; CvPlot::changeOwnershipDuration
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1027 : }

	ret	0
?lChangeOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lChangeOwnershipDuration
_TEXT	ENDS
PUBLIC	?lGetInlandCorner@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetInlandCorner
EXTRN	?getInlandCorner@CvPlot@@QBEPAV1@XZ:PROC	; CvPlot::getInlandCorner
; Function compile flags: /Ogtpy
;	COMDAT ?lGetInlandCorner@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetInlandCorner@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetInlandCorner, COMDAT

; 1031 : {

	push	ebx
	push	ebp
	push	esi

; 1032 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetInland
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetInland
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetInland
	xor	bl, bl
$LN5@lGetInland:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetInland
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetInland:

; 1033 : 	CvPlot* pkInlandCorner = pkPlot->getInlandCorner();

	mov	ecx, edi
	call	?getInlandCorner@CvPlot@@QBEPAV1@XZ	; CvPlot::getInlandCorner

; 1034 : 
; 1035 : 	CvLuaPlot::Push(L, pkInlandCorner);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1036 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1037 : }

	ret	0
?lGetInlandCorner@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetInlandCorner
_TEXT	ENDS
PUBLIC	?lGetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetImprovementDuration
EXTRN	?getImprovementDuration@CvPlot@@QBEHXZ:PROC	; CvPlot::getImprovementDuration
; Function compile flags: /Ogtpy
;	COMDAT ?lGetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetImprovementDuration, COMDAT

; 1042 : 	return BasicLuaMethod(L, &CvPlot::getImprovementDuration);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getImprovementDuration@CvPlot@@QBEHXZ ; CvPlot::getImprovementDuration
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1043 : }

	ret	0
?lGetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetImprovementDuration
_TEXT	ENDS
PUBLIC	?lSetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetImprovementDuration
EXTRN	?setImprovementDuration@CvPlot@@QAEXH@Z:PROC	; CvPlot::setImprovementDuration
; Function compile flags: /Ogtpy
;	COMDAT ?lSetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lSetImprovementDuration, COMDAT

; 1048 : 	return BasicLuaMethod(L, &CvPlot::setImprovementDuration);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?setImprovementDuration@CvPlot@@QAEXH@Z ; CvPlot::setImprovementDuration
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1049 : }

	ret	0
?lSetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lSetImprovementDuration
_TEXT	ENDS
PUBLIC	?lChangeImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeImprovementDuration
EXTRN	?changeImprovementDuration@CvPlot@@QAEXH@Z:PROC	; CvPlot::changeImprovementDuration
; Function compile flags: /Ogtpy
;	COMDAT ?lChangeImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lChangeImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lChangeImprovementDuration, COMDAT

; 1054 : 	return BasicLuaMethod(L, &CvPlot::changeImprovementDuration);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?changeImprovementDuration@CvPlot@@QAEXH@Z ; CvPlot::changeImprovementDuration
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1055 : }

	ret	0
?lChangeImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lChangeImprovementDuration
_TEXT	ENDS
PUBLIC	?lGetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetUpgradeProgress
EXTRN	?getUpgradeProgress@CvPlot@@QBEHXZ:PROC		; CvPlot::getUpgradeProgress
; Function compile flags: /Ogtpy
;	COMDAT ?lGetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetUpgradeProgress, COMDAT

; 1061 : 	return BasicLuaMethod(L, &CvPlot::getUpgradeProgress);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getUpgradeProgress@CvPlot@@QBEHXZ ; CvPlot::getUpgradeProgress
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1062 : }

	ret	0
?lGetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetUpgradeProgress
_TEXT	ENDS
PUBLIC	?lGetUpgradeTimeLeft@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetUpgradeTimeLeft
EXTRN	?getUpgradeTimeLeft@CvPlot@@QBEHW4ImprovementTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::getUpgradeTimeLeft
; Function compile flags: /Ogtpy
;	COMDAT ?lGetUpgradeTimeLeft@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetUpgradeTimeLeft@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetUpgradeTimeLeft, COMDAT

; 1067 : 	return BasicLuaMethod(L, &CvPlot::getUpgradeTimeLeft);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getUpgradeTimeLeft@CvPlot@@QBEHW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::getUpgradeTimeLeft
	push	eax
	call	??$BasicLuaMethod@HW4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4ImprovementTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum ImprovementTypes,enum PlayerTypes>
	add	esp, 8

; 1068 : }

	ret	0
?lGetUpgradeTimeLeft@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetUpgradeTimeLeft
_TEXT	ENDS
PUBLIC	?lSetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetUpgradeProgress
EXTRN	?setUpgradeProgress@CvPlot@@QAEXH@Z:PROC	; CvPlot::setUpgradeProgress
; Function compile flags: /Ogtpy
;	COMDAT ?lSetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lSetUpgradeProgress, COMDAT

; 1074 : 	return BasicLuaMethod(L, &CvPlot::setUpgradeProgress);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?setUpgradeProgress@CvPlot@@QAEXH@Z ; CvPlot::setUpgradeProgress
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1075 : }

	ret	0
?lSetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lSetUpgradeProgress
_TEXT	ENDS
PUBLIC	?lChangeUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeUpgradeProgress
EXTRN	?changeUpgradeProgress@CvPlot@@QAEXH@Z:PROC	; CvPlot::changeUpgradeProgress
; Function compile flags: /Ogtpy
;	COMDAT ?lChangeUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lChangeUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lChangeUpgradeProgress, COMDAT

; 1080 : 	return BasicLuaMethod(L, &CvPlot::changeUpgradeProgress);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?changeUpgradeProgress@CvPlot@@QAEXH@Z ; CvPlot::changeUpgradeProgress
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1081 : }

	ret	0
?lChangeUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lChangeUpgradeProgress
_TEXT	ENDS
PUBLIC	?lGetCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetCityRadiusCount
EXTRN	?getCityRadiusCount@CvPlot@@QBEHXZ:PROC		; CvPlot::getCityRadiusCount
; Function compile flags: /Ogtpy
;	COMDAT ?lGetCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetCityRadiusCount, COMDAT

; 1086 : 	return BasicLuaMethod(L, &CvPlot::getCityRadiusCount);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getCityRadiusCount@CvPlot@@QBEHXZ ; CvPlot::getCityRadiusCount
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1087 : }

	ret	0
?lGetCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetCityRadiusCount
_TEXT	ENDS
PUBLIC	?lIsCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsCityRadius
EXTRN	?isCityRadius@CvPlot@@QBEHXZ:PROC		; CvPlot::isCityRadius
; Function compile flags: /Ogtpy
;	COMDAT ?lIsCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsCityRadius, COMDAT

; 1092 : 	return BasicLuaMethod(L, &CvPlot::isCityRadius);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isCityRadius@CvPlot@@QBEHXZ	; CvPlot::isCityRadius
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1093 : }

	ret	0
?lIsCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsCityRadius
_TEXT	ENDS
PUBLIC	?lIsStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsStartingPlot
EXTRN	?isStartingPlot@CvPlot@@QBE_NXZ:PROC		; CvPlot::isStartingPlot
; Function compile flags: /Ogtpy
;	COMDAT ?lIsStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsStartingPlot, COMDAT

; 1099 : 	return BasicLuaMethod(L, &CvPlot::isStartingPlot);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isStartingPlot@CvPlot@@QBE_NXZ	; CvPlot::isStartingPlot
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1100 : }

	ret	0
?lIsStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsStartingPlot
_TEXT	ENDS
PUBLIC	?lSetStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetStartingPlot
EXTRN	?setStartingPlot@CvPlot@@QAEX_N@Z:PROC		; CvPlot::setStartingPlot
; Function compile flags: /Ogtpy
;	COMDAT ?lSetStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetStartingPlot, COMDAT

; 1105 : 	return BasicLuaMethod(L, &CvPlot::setStartingPlot);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?setStartingPlot@CvPlot@@QAEX_N@Z ; CvPlot::setStartingPlot
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1106 : }

	ret	0
?lSetStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetStartingPlot
_TEXT	ENDS
PUBLIC	?lIsNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsNEOfRiver
EXTRN	?isNEOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isNEOfRiver
; Function compile flags: /Ogtpy
;	COMDAT ?lIsNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsNEOfRiver, COMDAT

; 1111 : 	return BasicLuaMethod(L, &CvPlot::isNEOfRiver);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isNEOfRiver@CvPlot@@QBE_NXZ	; CvPlot::isNEOfRiver
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1112 : }

	ret	0
?lIsNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsNEOfRiver
_TEXT	ENDS
PUBLIC	?lSetNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetNEOfRiver
EXTRN	?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z:PROC ; CvPlot::setNEOfRiver
; Function compile flags: /Ogtpy
;	COMDAT ?lSetNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetNEOfRiver, COMDAT

; 1117 : 	return BasicLuaMethod(L, &CvPlot::setNEOfRiver);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNEOfRiver
	push	eax
	call	??$BasicLuaMethod@_NW4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_NW4FlowDirectionTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum FlowDirectionTypes>
	add	esp, 8

; 1118 : }

	ret	0
?lSetNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetNEOfRiver
_TEXT	ENDS
PUBLIC	?lIsWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsWOfRiver
EXTRN	?isWOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isWOfRiver
; Function compile flags: /Ogtpy
;	COMDAT ?lIsWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsWOfRiver, COMDAT

; 1123 : 	return BasicLuaMethod(L, &CvPlot::isWOfRiver);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isWOfRiver@CvPlot@@QBE_NXZ	; CvPlot::isWOfRiver
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1124 : }

	ret	0
?lIsWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsWOfRiver
_TEXT	ENDS
PUBLIC	?lSetWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetWOfRiver
EXTRN	?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z:PROC ; CvPlot::setWOfRiver
; Function compile flags: /Ogtpy
;	COMDAT ?lSetWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetWOfRiver, COMDAT

; 1129 : 	return BasicLuaMethod(L, &CvPlot::setWOfRiver);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setWOfRiver
	push	eax
	call	??$BasicLuaMethod@_NW4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_NW4FlowDirectionTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum FlowDirectionTypes>
	add	esp, 8

; 1130 : }

	ret	0
?lSetWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetWOfRiver
_TEXT	ENDS
PUBLIC	?lIsNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsNWOfRiver
EXTRN	?isNWOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isNWOfRiver
; Function compile flags: /Ogtpy
;	COMDAT ?lIsNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsNWOfRiver, COMDAT

; 1135 : 	return BasicLuaMethod(L, &CvPlot::isNWOfRiver);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isNWOfRiver@CvPlot@@QBE_NXZ	; CvPlot::isNWOfRiver
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1136 : }

	ret	0
?lIsNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsNWOfRiver
_TEXT	ENDS
PUBLIC	?lSetNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetNWOfRiver
EXTRN	?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z:PROC ; CvPlot::setNWOfRiver
; Function compile flags: /Ogtpy
;	COMDAT ?lSetNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetNWOfRiver, COMDAT

; 1141 : 	return BasicLuaMethod(L, &CvPlot::setNWOfRiver);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNWOfRiver
	push	eax
	call	??$BasicLuaMethod@_NW4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_NW4FlowDirectionTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum FlowDirectionTypes>
	add	esp, 8

; 1142 : }

	ret	0
?lSetNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetNWOfRiver
_TEXT	ENDS
PUBLIC	?lGetRiverEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverEFlowDirection
EXTRN	?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ:PROC ; CvPlot::getRiverEFlowDirection
; Function compile flags: /Ogtpy
;	COMDAT ?lGetRiverEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetRiverEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetRiverEFlowDirection, COMDAT

; 1147 : 	return BasicLuaMethod(L, &CvPlot::getRiverEFlowDirection);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverEFlowDirection
	push	eax
	call	??$BasicLuaMethod@W4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4FlowDirectionTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum FlowDirectionTypes>
	add	esp, 8

; 1148 : }

	ret	0
?lGetRiverEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetRiverEFlowDirection
_TEXT	ENDS
PUBLIC	?lGetRiverSEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverSEFlowDirection
EXTRN	?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ:PROC ; CvPlot::getRiverSEFlowDirection
; Function compile flags: /Ogtpy
;	COMDAT ?lGetRiverSEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetRiverSEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetRiverSEFlowDirection, COMDAT

; 1153 : 	return BasicLuaMethod(L, &CvPlot::getRiverSEFlowDirection);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSEFlowDirection
	push	eax
	call	??$BasicLuaMethod@W4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4FlowDirectionTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum FlowDirectionTypes>
	add	esp, 8

; 1154 : }

	ret	0
?lGetRiverSEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetRiverSEFlowDirection
_TEXT	ENDS
PUBLIC	?lGetRiverSWFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverSWFlowDirection
EXTRN	?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ:PROC ; CvPlot::getRiverSWFlowDirection
; Function compile flags: /Ogtpy
;	COMDAT ?lGetRiverSWFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetRiverSWFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetRiverSWFlowDirection, COMDAT

; 1159 : 	return BasicLuaMethod(L, &CvPlot::getRiverSWFlowDirection);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSWFlowDirection
	push	eax
	call	??$BasicLuaMethod@W4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4FlowDirectionTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum FlowDirectionTypes>
	add	esp, 8

; 1160 : }

	ret	0
?lGetRiverSWFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetRiverSWFlowDirection
_TEXT	ENDS
PUBLIC	?lIsPotentialCityWork@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsPotentialCityWork
EXTRN	?isPotentialCityWork@CvPlot@@QBE_NXZ:PROC	; CvPlot::isPotentialCityWork
; Function compile flags: /Ogtpy
;	COMDAT ?lIsPotentialCityWork@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsPotentialCityWork@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsPotentialCityWork, COMDAT

; 1166 : 	return BasicLuaMethod(L, &CvPlot::isPotentialCityWork);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isPotentialCityWork@CvPlot@@QBE_NXZ ; CvPlot::isPotentialCityWork
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1167 : }

	ret	0
?lIsPotentialCityWork@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsPotentialCityWork
_TEXT	ENDS
PUBLIC	?lIsPotentialCityWorkForArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsPotentialCityWorkForArea
EXTRN	?isPotentialCityWorkForArea@CvPlot@@QBE_NPAVCvArea@@@Z:PROC ; CvPlot::isPotentialCityWorkForArea
; Function compile flags: /Ogtpy
;	COMDAT ?lIsPotentialCityWorkForArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsPotentialCityWorkForArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsPotentialCityWorkForArea, COMDAT

; 1172 : 	return BasicLuaMethod(L, &CvPlot::isPotentialCityWorkForArea);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isPotentialCityWorkForArea@CvPlot@@QBE_NPAVCvArea@@@Z ; CvPlot::isPotentialCityWorkForArea
	push	eax
	call	??$BasicLuaMethod@_NPAVCvArea@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NPAVCvArea@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,CvArea *>
	add	esp, 8

; 1173 : }

	ret	0
?lIsPotentialCityWorkForArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsPotentialCityWorkForArea
_TEXT	ENDS
PUBLIC	?lGetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetOwner
; Function compile flags: /Ogtpy
;	COMDAT ?lGetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lGetOwner, COMDAT

; 1179 : 	return BasicLuaMethod(L, &CvPlot::getOwner);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::getOwner
	push	eax
	call	??$BasicLuaMethod@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlayerTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes>
	add	esp, 8

; 1180 : }

	ret	0
?lGetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lGetOwner
_TEXT	ENDS
PUBLIC	?lSetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetOwner
EXTRN	?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z:PROC ; CvPlot::setOwner
; Function compile flags: /Ogtpy
;	COMDAT ?lSetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lSetOwner, COMDAT

; 1185 : 	return BasicLuaMethod(L, &CvPlot::setOwner);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z ; CvPlot::setOwner
	push	eax
	call	??$BasicLuaMethod@W4PlayerTypes@@H_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlayerTypes@@H_N2@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes,int,bool,bool>
	add	esp, 8

; 1186 : }

	ret	0
?lSetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lSetOwner
_TEXT	ENDS
PUBLIC	?lGetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetPlotType
; Function compile flags: /Ogtpy
;	COMDAT ?lGetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetPlotType, COMDAT

; 1191 : 	return BasicLuaMethod(L, &CvPlot::getPlotType);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ ; CvPlot::getPlotType
	push	eax
	call	??$BasicLuaMethod@W4PlotTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlotTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes>
	add	esp, 8

; 1192 : }

	ret	0
?lGetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetPlotType
_TEXT	ENDS
PUBLIC	?lIsFlatlands@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsFlatlands
EXTRN	?isFlatlands@CvPlot@@QBE_NXZ:PROC		; CvPlot::isFlatlands
; Function compile flags: /Ogtpy
;	COMDAT ?lIsFlatlands@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsFlatlands@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsFlatlands, COMDAT

; 1197 : 	return BasicLuaMethod(L, &CvPlot::isFlatlands);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isFlatlands@CvPlot@@QBE_NXZ	; CvPlot::isFlatlands
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1198 : }

	ret	0
?lIsFlatlands@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsFlatlands
_TEXT	ENDS
PUBLIC	?lIsHills@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsHills
; Function compile flags: /Ogtpy
;	COMDAT ?lIsHills@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsHills@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsHills, COMDAT

; 1203 : 	return BasicLuaMethod(L, &CvPlot::isHills);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isHills@CvPlot@@QBE_NXZ		; CvPlot::isHills
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1204 : }

	ret	0
?lIsHills@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsHills
_TEXT	ENDS
PUBLIC	?lIsOpenGround@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsOpenGround
; Function compile flags: /Ogtpy
;	COMDAT ?lIsOpenGround@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsOpenGround@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsOpenGround, COMDAT

; 1209 : 	return BasicLuaMethod(L, &CvPlot::isOpenGround);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isOpenGround@CvPlot@@QBE_NXZ	; CvPlot::isOpenGround
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1210 : }

	ret	0
?lIsOpenGround@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsOpenGround
_TEXT	ENDS
PUBLIC	?lIsRoughGround@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsRoughGround
; Function compile flags: /Ogtpy
;	COMDAT ?lIsRoughGround@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRoughGround@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsRoughGround, COMDAT

; 1215 : 	return BasicLuaMethod(L, &CvPlot::isRoughGround);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isRoughGround@CvPlot@@QBE_NXZ	; CvPlot::isRoughGround
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1216 : }

	ret	0
?lIsRoughGround@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsRoughGround
_TEXT	ENDS
PUBLIC	?lIsMountain@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsMountain
; Function compile flags: /Ogtpy
;	COMDAT ?lIsMountain@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsMountain@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsMountain, COMDAT

; 1221 : 	return BasicLuaMethod(L, &CvPlot::isMountain);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isMountain@CvPlot@@QBE_NXZ	; CvPlot::isMountain
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1222 : }

	ret	0
?lIsMountain@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsMountain
_TEXT	ENDS
PUBLIC	?lSetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetPlotType
EXTRN	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z:PROC ; CvPlot::setPlotType
; Function compile flags: /Ogtpy
;	COMDAT ?lSetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetPlotType, COMDAT

; 1228 : 	return BasicLuaMethod(L, &CvPlot::setPlotType);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType
	push	eax
	call	??$BasicLuaMethod@W4PlotTypes@@_N_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlotTypes@@_N22@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes,bool,bool,bool>
	add	esp, 8

; 1229 : }

	ret	0
?lSetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetPlotType
_TEXT	ENDS
PUBLIC	?lGetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetResourceType
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
; Function compile flags: /Ogtpy
;	COMDAT ?lGetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetResourceType, COMDAT

; 1233 : {

	push	ebx
	push	ebp
	push	esi

; 1234 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN9@lGetResour
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN9@lGetResour
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN9@lGetResour
	xor	bl, bl
$LN9@lGetResour:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN16@lGetResour
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN16@lGetResour:

; 1235 : 	if(pkPlot != NULL)

	test	edi, edi
	je	SHORT $LN4@lGetResour

; 1236 : 	{
; 1237 : 		if(lua_gettop(L) >= 2)

	push	esi
	call	_lua_gettop
	add	esp, 4
	cmp	eax, 2
	jl	SHORT $LN3@lGetResour

; 1238 : 		{
; 1239 : 			TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8

; 1240 : 			ResourceTypes eResource = pkPlot->getResourceType(eTeam);

	push	eax
	mov	ecx, edi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType

; 1241 : 			lua_pushinteger(L, eResource);

	push	eax

; 1248 : 			return 1;
; 1249 : 		}
; 1250 : 	}
; 1251 : 	else
; 1252 : 	{
; 1253 : 		lua_pushinteger(L, -1);

	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1254 : 		return 1;

	mov	eax, 1
	pop	ebx

; 1255 : 	}
; 1256 : }

	ret	0
$LN3@lGetResour:

; 1242 : 			return 1;
; 1243 : 		}
; 1244 : 		else
; 1245 : 		{
; 1246 : 			ResourceTypes eResource = pkPlot->getResourceType(NO_TEAM);

	push	-1
	mov	ecx, edi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType

; 1247 : 			lua_pushinteger(L, eResource);

	push	eax

; 1248 : 			return 1;
; 1249 : 		}
; 1250 : 	}
; 1251 : 	else
; 1252 : 	{
; 1253 : 		lua_pushinteger(L, -1);

	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1254 : 		return 1;

	mov	eax, 1
	pop	ebx

; 1255 : 	}
; 1256 : }

	ret	0
$LN4@lGetResour:

; 1248 : 			return 1;
; 1249 : 		}
; 1250 : 	}
; 1251 : 	else
; 1252 : 	{
; 1253 : 		lua_pushinteger(L, -1);

	push	-1
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1254 : 		return 1;

	mov	eax, 1
	pop	ebx

; 1255 : 	}
; 1256 : }

	ret	0
?lGetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetResourceType
_TEXT	ENDS
PUBLIC	?lGetNonObsoleteResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNonObsoleteResourceType
EXTRN	?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getNonObsoleteResourceType
; Function compile flags: /Ogtpy
;	COMDAT ?lGetNonObsoleteResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNonObsoleteResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetNonObsoleteResourceType, COMDAT

; 1261 : 	return BasicLuaMethod(L, &CvPlot::getNonObsoleteResourceType);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getNonObsoleteResourceType
	push	eax
	call	??$BasicLuaMethod@W4ResourceTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ResourceTypes@@W4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,enum TeamTypes>
	add	esp, 8

; 1262 : }

	ret	0
?lGetNonObsoleteResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetNonObsoleteResourceType
_TEXT	ENDS
PUBLIC	?lSetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetResourceType
EXTRN	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z:PROC ; CvPlot::setResourceType
; Function compile flags: /Ogtpy
;	COMDAT ?lSetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetResourceType, COMDAT

; 1267 : 	return BasicLuaMethod(L, &CvPlot::setResourceType);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType
	push	eax
	call	??$BasicLuaMethod@W4ResourceTypes@@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ResourceTypes@@H_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,int,bool>
	add	esp, 8

; 1268 : }

	ret	0
?lSetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetResourceType
_TEXT	ENDS
PUBLIC	?lGetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetNumResource
EXTRN	?getNumResource@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumResource
; Function compile flags: /Ogtpy
;	COMDAT ?lGetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetNumResource, COMDAT

; 1273 : 	return BasicLuaMethod(L, &CvPlot::getNumResource);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getNumResource@CvPlot@@QBEHXZ	; CvPlot::getNumResource
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1274 : }

	ret	0
?lGetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetNumResource
_TEXT	ENDS
PUBLIC	?lSetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetNumResource
EXTRN	?setNumResource@CvPlot@@QAEXH@Z:PROC		; CvPlot::setNumResource
; Function compile flags: /Ogtpy
;	COMDAT ?lSetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetNumResource, COMDAT

; 1279 : 	return BasicLuaMethod(L, &CvPlot::setNumResource);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?setNumResource@CvPlot@@QAEXH@Z	; CvPlot::setNumResource
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1280 : }

	ret	0
?lSetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetNumResource
_TEXT	ENDS
PUBLIC	?lChangeNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeNumResource
EXTRN	?changeNumResource@CvPlot@@QAEXH@Z:PROC		; CvPlot::changeNumResource
; Function compile flags: /Ogtpy
;	COMDAT ?lChangeNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lChangeNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lChangeNumResource, COMDAT

; 1285 : 	return BasicLuaMethod(L, &CvPlot::changeNumResource);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?changeNumResource@CvPlot@@QAEXH@Z ; CvPlot::changeNumResource
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1286 : }

	ret	0
?lChangeNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lChangeNumResource
_TEXT	ENDS
PUBLIC	?lGetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetImprovementType
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
; Function compile flags: /Ogtpy
;	COMDAT ?lGetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetImprovementType, COMDAT

; 1292 : 	return BasicLuaMethod(L, &CvPlot::getImprovementType);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	call	??$BasicLuaMethod@W4ImprovementTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ImprovementTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes>
	add	esp, 8

; 1293 : }

	ret	0
?lGetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetImprovementType
_TEXT	ENDS
PUBLIC	?lSetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetImprovementType
EXTRN	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::setImprovementType
; Function compile flags: /Ogtpy
;	COMDAT ?lSetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lSetImprovementType, COMDAT

; 1298 : 	return BasicLuaMethod(L, &CvPlot::setImprovementType);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType
	push	eax
	call	??$BasicLuaMethod@W4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ImprovementTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes,enum PlayerTypes>
	add	esp, 8

; 1299 : }

	ret	0
?lSetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lSetImprovementType
_TEXT	ENDS
PUBLIC	?lSetImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetImprovementPillaged
EXTRN	?SetImprovementPillaged@CvPlot@@QAEX_N@Z:PROC	; CvPlot::SetImprovementPillaged
; Function compile flags: /Ogtpy
;	COMDAT ?lSetImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lSetImprovementPillaged, COMDAT

; 1304 : 	return BasicLuaMethod(L, &CvPlot::SetImprovementPillaged);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?SetImprovementPillaged@CvPlot@@QAEX_N@Z ; CvPlot::SetImprovementPillaged
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1305 : }

	ret	0
?lSetImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lSetImprovementPillaged
_TEXT	ENDS
PUBLIC	?lGetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetRouteType
EXTRN	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ:PROC ; CvPlot::getRouteType
; Function compile flags: /Ogtpy
;	COMDAT ?lGetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetRouteType, COMDAT

; 1310 : 	return BasicLuaMethod(L, &CvPlot::getRouteType);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	call	??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4RouteTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>
	add	esp, 8

; 1311 : }

	ret	0
?lGetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetRouteType
_TEXT	ENDS
PUBLIC	?lSetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetRouteType
EXTRN	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z:PROC	; CvPlot::setRouteType
; Function compile flags: /Ogtpy
;	COMDAT ?lSetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetRouteType, COMDAT

; 1316 : 	return BasicLuaMethod(L, &CvPlot::setRouteType);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::setRouteType
	push	eax
	call	??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4RouteTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>
	add	esp, 8

; 1317 : }

	ret	0
?lSetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetRouteType
_TEXT	ENDS
PUBLIC	?lIsRoutePillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRoutePillaged
EXTRN	?IsRoutePillaged@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsRoutePillaged
; Function compile flags: /Ogtpy
;	COMDAT ?lIsRoutePillaged@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRoutePillaged@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsRoutePillaged, COMDAT

; 1320 : {

	push	ebx
	push	ebp
	push	esi

; 1321 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lIsRoutePi
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lIsRoutePi
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lIsRoutePi
	xor	bl, bl
$LN5@lIsRoutePi:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lIsRoutePi
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lIsRoutePi:

; 1322 : 	lua_pushboolean(L, pkPlot->IsRoutePillaged());

	mov	ecx, edi
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1323 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1324 : }

	ret	0
?lIsRoutePillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsRoutePillaged
_TEXT	ENDS
PUBLIC	?lGetPlotCity@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetPlotCity
; Function compile flags: /Ogtpy
;	COMDAT ?lGetPlotCity@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetPlotCity@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetPlotCity, COMDAT

; 1328 : {

	push	ebx
	push	ebp
	push	esi

; 1329 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetPlotCi
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetPlotCi
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetPlotCi
	xor	bl, bl
$LN5@lGetPlotCi:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetPlotCi
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetPlotCi:

; 1330 : 	CvCity* pkCity = pkPlot->getPlotCity();

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	SHORT $LN14@lGetPlotCi
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN14@lGetPlotCi
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 1331 : 	CvLuaCity::Push(L, pkCity);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaCity@@VCvCity@@@@SAXPAUlua_State@@PAVCvCity@@@Z ; CvLuaScopedInstance<CvLuaCity,CvCity>::Push
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1332 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1333 : }

	ret	0

; 1330 : 	CvCity* pkCity = pkPlot->getPlotCity();

$LN14@lGetPlotCi:
	xor	eax, eax

; 1331 : 	CvLuaCity::Push(L, pkCity);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaCity@@VCvCity@@@@SAXPAUlua_State@@PAVCvCity@@@Z ; CvLuaScopedInstance<CvLuaCity,CvCity>::Push
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1332 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1333 : }

	ret	0
?lGetPlotCity@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetPlotCity
_TEXT	ENDS
PUBLIC	?lGetWorkingCity@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetWorkingCity
EXTRN	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ:PROC	; CvPlot::getWorkingCity
; Function compile flags: /Ogtpy
;	COMDAT ?lGetWorkingCity@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetWorkingCity@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetWorkingCity, COMDAT

; 1337 : {

	push	ebx
	push	ebp
	push	esi

; 1338 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetWorkin
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetWorkin
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetWorkin
	xor	bl, bl
$LN5@lGetWorkin:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetWorkin
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetWorkin:

; 1339 : 	CvCity* pkCity = pkPlot->getWorkingCity();

	mov	ecx, edi
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity

; 1340 : 	CvLuaCity::Push(L, pkCity);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaCity@@VCvCity@@@@SAXPAUlua_State@@PAVCvCity@@@Z ; CvLuaScopedInstance<CvLuaCity,CvCity>::Push
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1341 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1342 : }

	ret	0
?lGetWorkingCity@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetWorkingCity
_TEXT	ENDS
PUBLIC	?lGetWorkingCityOverride@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetWorkingCityOverride
EXTRN	?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ:PROC ; CvPlot::getWorkingCityOverride
; Function compile flags: /Ogtpy
;	COMDAT ?lGetWorkingCityOverride@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetWorkingCityOverride@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetWorkingCityOverride, COMDAT

; 1346 : {

	push	ebx
	push	ebp
	push	esi

; 1347 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetWorkin@2
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetWorkin@2
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetWorkin@2
	xor	bl, bl
$LN5@lGetWorkin@2:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetWorkin@2
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetWorkin@2:

; 1348 : 	CvCity* pkCity = pkPlot->getWorkingCityOverride();

	mov	ecx, edi
	call	?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCityOverride

; 1349 : 	CvLuaCity::Push(L, pkCity);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaCity@@VCvCity@@@@SAXPAUlua_State@@PAVCvCity@@@Z ; CvLuaScopedInstance<CvLuaCity,CvCity>::Push
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1350 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1351 : }

	ret	0
?lGetWorkingCityOverride@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetWorkingCityOverride
_TEXT	ENDS
PUBLIC	?lGetReconCount@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetReconCount
EXTRN	?getReconCount@CvPlot@@QBEHXZ:PROC		; CvPlot::getReconCount
; Function compile flags: /Ogtpy
;	COMDAT ?lGetReconCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetReconCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetReconCount, COMDAT

; 1356 : 	return BasicLuaMethod(L, &CvPlot::getReconCount);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getReconCount@CvPlot@@QBEHXZ	; CvPlot::getReconCount
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1357 : }

	ret	0
?lGetReconCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetReconCount
_TEXT	ENDS
PUBLIC	?lGetRiverCrossingCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverCrossingCount
EXTRN	?getRiverCrossingCount@CvPlot@@QBEHXZ:PROC	; CvPlot::getRiverCrossingCount
; Function compile flags: /Ogtpy
;	COMDAT ?lGetRiverCrossingCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetRiverCrossingCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetRiverCrossingCount, COMDAT

; 1362 : 	return BasicLuaMethod(L, &CvPlot::getRiverCrossingCount);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getRiverCrossingCount@CvPlot@@QBEHXZ ; CvPlot::getRiverCrossingCount
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1363 : }

	ret	0
?lGetRiverCrossingCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetRiverCrossingCount
_TEXT	ENDS
PUBLIC	?lGetYield@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetYield
EXTRN	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z:PROC	; CvPlot::getYield
; Function compile flags: /Ogtpy
;	COMDAT ?lGetYield@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetYield@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lGetYield, COMDAT

; 1367 : {

	push	ebx
	push	ebp
	push	esi

; 1368 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetYield
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetYield
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetYield
	xor	bl, bl
$LN5@lGetYield:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetYield
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetYield:

; 1369 : 	const YieldTypes eIndex = (YieldTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8

; 1370 : 	const int iResult = pkPlot->getYield(eIndex);

	push	eax
	mov	ecx, edi
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield

; 1371 : 	lua_pushinteger(L, iResult);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1372 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1373 : }

	ret	0
?lGetYield@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lGetYield
_TEXT	ENDS
PUBLIC	?lCalculateNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateNatureYield
EXTRN	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::calculateNatureYield
; Function compile flags: /Ogtpy
;	COMDAT ?lCalculateNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCalculateNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lCalculateNatureYield, COMDAT

; 1378 : 	return BasicLuaMethod(L, &CvPlot::calculateNatureYield);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	push	eax
	call	??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes,bool>
	add	esp, 8

; 1379 : }

	ret	0
?lCalculateNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lCalculateNatureYield
_TEXT	ENDS
PUBLIC	?lCalculateBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateBestNatureYield
EXTRN	?calculateBestNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::calculateBestNatureYield
; Function compile flags: /Ogtpy
;	COMDAT ?lCalculateBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCalculateBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lCalculateBestNatureYield, COMDAT

; 1384 : 	return BasicLuaMethod(L, &CvPlot::calculateBestNatureYield);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?calculateBestNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@@Z ; CvPlot::calculateBestNatureYield
	push	eax
	call	??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes>
	add	esp, 8

; 1385 : }

	ret	0
?lCalculateBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lCalculateBestNatureYield
_TEXT	ENDS
PUBLIC	?lCalculateTotalBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateTotalBestNatureYield
EXTRN	?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z:PROC ; CvPlot::calculateTotalBestNatureYield
; Function compile flags: /Ogtpy
;	COMDAT ?lCalculateTotalBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCalculateTotalBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lCalculateTotalBestNatureYield, COMDAT

; 1390 : 	return BasicLuaMethod(L, &CvPlot::calculateTotalBestNatureYield);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::calculateTotalBestNatureYield
	push	eax
	call	??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes>
	add	esp, 8

; 1391 : }

	ret	0
?lCalculateTotalBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lCalculateTotalBestNatureYield
_TEXT	ENDS
PUBLIC	?lCalculateImprovementYieldChange@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateImprovementYieldChange
EXTRN	?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z:PROC ; CvPlot::calculateImprovementYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?lCalculateImprovementYieldChange@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkInstance$227916 = -8					; size = 4
_bOptional$ = -4					; size = 1
_L$ = 8							; size = 4
?lCalculateImprovementYieldChange@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lCalculateImprovementYieldChange, COMDAT

; 1395 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 1396 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+16]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	edi, eax
	mov	bl, 1
	mov	DWORD PTR _pkInstance$227916[esp+36], 0
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN14@lCalculate
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN14@lCalculate
	push	-1
	push	esi
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pkInstance$227916[esp+24], eax
	test	eax, eax
	je	SHORT $LN14@lCalculate
	xor	bl, bl
$LN14@lCalculate:
	push	edi
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lCalculate
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lCalculate:

; 1397 : 	const ImprovementTypes eImprovement = (ImprovementTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 1398 : 	const YieldTypes eYield = (YieldTypes)lua_tointeger(L,3);

	push	3
	push	esi
	mov	edi, eax
	call	_lua_tointeger

; 1399 : 	const PlayerTypes ePlayer = (PlayerTypes)lua_tointeger(L, 4);

	push	4
	push	esi
	mov	ebx, eax
	call	_lua_tointeger

; 1400 : 	const bool bOptional = luaL_optbool(L, 5, false);

	push	0
	push	5
	push	esi
	mov	ebp, eax
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool

; 1401 : 	const RouteTypes eRoute = (RouteTypes)luaL_optint(L, 5, NUM_ROUTE_TYPES);

	push	2
	push	5
	push	esi
	mov	BYTE PTR _bOptional$[esp+72], al
	call	_luaL_optinteger

; 1402 : 
; 1403 : 	const int iResult = pkPlot->calculateImprovementYieldChange(eImprovement, eYield, ePlayer, bOptional, eRoute);

	mov	ecx, DWORD PTR _pkInstance$227916[esp+72]
	add	esp, 48					; 00000030H
	push	eax
	mov	eax, DWORD PTR _bOptional$[esp+28]
	push	eax
	push	ebp
	push	ebx
	push	edi
	call	?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z ; CvPlot::calculateImprovementYieldChange

; 1404 : 	lua_pushinteger(L, iResult);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1405 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1406 : }

	add	esp, 8
	ret	0
?lCalculateImprovementYieldChange@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lCalculateImprovementYieldChange
_TEXT	ENDS
PUBLIC	?lCalculateYield@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lCalculateYield
EXTRN	?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z:PROC ; CvPlot::calculateYield
; Function compile flags: /Ogtpy
;	COMDAT ?lCalculateYield@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCalculateYield@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lCalculateYield, COMDAT

; 1411 : 	return BasicLuaMethod(L, &CvPlot::calculateYield);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z ; CvPlot::calculateYield
	push	eax
	call	??$BasicLuaMethod@HW4YieldTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4YieldTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,bool>
	add	esp, 8

; 1412 : }

	ret	0
?lCalculateYield@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lCalculateYield
_TEXT	ENDS
PUBLIC	?lHasYield@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lHasYield
EXTRN	?hasYield@CvPlot@@QBE_NXZ:PROC			; CvPlot::hasYield
; Function compile flags: /Ogtpy
;	COMDAT ?lHasYield@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lHasYield@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lHasYield, COMDAT

; 1417 : 	return BasicLuaMethod(L, &CvPlot::hasYield);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?hasYield@CvPlot@@QBE_NXZ	; CvPlot::hasYield
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1418 : }

	ret	0
?lHasYield@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lHasYield
_TEXT	ENDS
PUBLIC	?lGetYieldWithBuild@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetYieldWithBuild
EXTRN	?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z:PROC ; CvPlot::getYieldWithBuild
; Function compile flags: /Ogtpy
;	COMDAT ?lGetYieldWithBuild@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetYieldWithBuild@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetYieldWithBuild, COMDAT

; 1423 : 	return BasicLuaMethod(L, &CvPlot::getYieldWithBuild);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z ; CvPlot::getYieldWithBuild
	push	eax
	call	??$BasicLuaMethod@HW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum YieldTypes,bool,enum PlayerTypes>
	add	esp, 8

; 1424 : }

	ret	0
?lGetYieldWithBuild@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetYieldWithBuild
_TEXT	ENDS
PUBLIC	?lCountNumAirUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCountNumAirUnits
EXTRN	?countNumAirUnits@CvPlot@@QBEHW4TeamTypes@@@Z:PROC ; CvPlot::countNumAirUnits
; Function compile flags: /Ogtpy
;	COMDAT ?lCountNumAirUnits@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCountNumAirUnits@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lCountNumAirUnits, COMDAT

; 1429 : 	return BasicLuaMethod(L, &CvPlot::countNumAirUnits);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?countNumAirUnits@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::countNumAirUnits
	push	eax
	call	??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes>
	add	esp, 8

; 1430 : }

	ret	0
?lCountNumAirUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lCountNumAirUnits
_TEXT	ENDS
PUBLIC	?lGetFoundValue@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetFoundValue
EXTRN	?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z:PROC ; CvPlot::getFoundValue
; Function compile flags: /Ogtpy
;	COMDAT ?lGetFoundValue@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetFoundValue@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetFoundValue, COMDAT

; 1435 : 	return BasicLuaMethod(L, &CvPlot::getFoundValue);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z ; CvPlot::getFoundValue
	push	eax
	call	??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
	add	esp, 8

; 1436 : }

	ret	0
?lGetFoundValue@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetFoundValue
_TEXT	ENDS
PUBLIC	?lIsBestAdjacentFound@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsBestAdjacentFound
EXTRN	?isBestAdjacentFound@CvPlot@@QAE_NW4PlayerTypes@@@Z:PROC ; CvPlot::isBestAdjacentFound
; Function compile flags: /Ogtpy
;	COMDAT ?lIsBestAdjacentFound@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsBestAdjacentFound@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsBestAdjacentFound, COMDAT

; 1441 : 	return BasicLuaMethod(L, &CvPlot::isBestAdjacentFound);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isBestAdjacentFound@CvPlot@@QAE_NW4PlayerTypes@@@Z ; CvPlot::isBestAdjacentFound
	push	eax
	call	??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>
	add	esp, 8

; 1442 : }

	ret	0
?lIsBestAdjacentFound@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsBestAdjacentFound
_TEXT	ENDS
PUBLIC	?lGetPlayerCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetPlayerCityRadiusCount
EXTRN	?getPlayerCityRadiusCount@CvPlot@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlot::getPlayerCityRadiusCount
; Function compile flags: /Ogtpy
;	COMDAT ?lGetPlayerCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetPlayerCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetPlayerCityRadiusCount, COMDAT

; 1447 : 	return BasicLuaMethod(L, &CvPlot::getPlayerCityRadiusCount);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getPlayerCityRadiusCount@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getPlayerCityRadiusCount
	push	eax
	call	??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
	add	esp, 8

; 1448 : }

	ret	0
?lGetPlayerCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetPlayerCityRadiusCount
_TEXT	ENDS
PUBLIC	?lIsPlayerCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsPlayerCityRadius
EXTRN	?isPlayerCityRadius@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::isPlayerCityRadius
; Function compile flags: /Ogtpy
;	COMDAT ?lIsPlayerCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsPlayerCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsPlayerCityRadius, COMDAT

; 1453 : 	return BasicLuaMethod(L, &CvPlot::isPlayerCityRadius);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isPlayerCityRadius@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isPlayerCityRadius
	push	eax
	call	??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>
	add	esp, 8

; 1454 : }

	ret	0
?lIsPlayerCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsPlayerCityRadius
_TEXT	ENDS
PUBLIC	?lGetVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?lGetVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetVisibilityCount, COMDAT

; 1459 : 	return BasicLuaMethod(L, &CvPlot::getVisibilityCount);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::getVisibilityCount
	push	eax
	call	??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes>
	add	esp, 8

; 1460 : }

	ret	0
?lGetVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetVisibilityCount
_TEXT	ENDS
PUBLIC	?lChangeVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeVisibilityCount
EXTRN	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z:PROC ; CvPlot::changeVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?lChangeVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bAlwaysSeeInvisible$ = -12				; size = 1
_bInformExplorationTracking$ = -8			; size = 1
_eSeeInvisible$ = -4					; size = 4
_L$ = 8							; size = 4
?lChangeVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lChangeVisibilityCount, COMDAT

; 1464 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi

; 1465 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+20]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lChangeVis
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lChangeVis
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lChangeVis
	xor	bl, bl
$LN5@lChangeVis:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lChangeVis
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lChangeVis:

; 1466 : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 1467 : 	const int iChange = lua_toboolean(L, 3);

	push	3
	push	esi
	mov	ebx, eax
	call	_lua_toboolean

; 1468 : 	const int eSeeInvisible = lua_tointeger(L, 4);

	push	4
	push	esi
	mov	ebp, eax
	call	_lua_tointeger

; 1469 : 	const bool bInformExplorationTracking = lua_toboolean(L, 5);

	push	5
	push	esi
	mov	DWORD PTR _eSeeInvisible$[esp+60], eax
	call	_lua_toboolean
	test	eax, eax
	setne	al

; 1470 : 	const bool bAlwaysSeeInvisible = lua_toboolean(L, 6);

	push	6
	push	esi
	mov	BYTE PTR _bInformExplorationTracking$[esp+68], al
	call	_lua_toboolean
	add	esp, 40					; 00000028H
	test	eax, eax

; 1471 : 
; 1472 : 	pkPlot->changeVisibilityCount(eTeam, iChange, static_cast<InvisibleTypes>(eSeeInvisible), bInformExplorationTracking, bAlwaysSeeInvisible);

	mov	eax, DWORD PTR _bInformExplorationTracking$[esp+28]
	setne	cl
	mov	BYTE PTR _bAlwaysSeeInvisible$[esp+28], cl
	mov	edx, DWORD PTR _bAlwaysSeeInvisible$[esp+28]
	mov	ecx, DWORD PTR _eSeeInvisible$[esp+28]
	push	edx
	push	eax
	push	ecx
	push	ebp
	push	ebx
	mov	ecx, edi
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount
	pop	edi
	pop	esi
	pop	ebp

; 1473 : 
; 1474 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1475 : }

	add	esp, 12					; 0000000cH
	ret	0
?lChangeVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lChangeVisibilityCount
_TEXT	ENDS
PUBLIC	?lGetRevealedOwner@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedOwner
EXTRN	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::getRevealedOwner
EXTRN	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getRevealedOwner
; Function compile flags: /Ogtpy
;	COMDAT ?lGetRevealedOwner@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetRevealedOwner@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetRevealedOwner, COMDAT

; 1479 : {

	push	ebx
	push	ebp
	push	esi

; 1480 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@lGetReveal
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@lGetReveal
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@lGetReveal
	xor	bl, bl
$LN7@lGetReveal:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@lGetReveal
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@lGetReveal:

; 1481 : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 1482 : 	const bool bDebug = luaL_optbool(L, 3, false);

	push	0
	push	3
	push	esi
	mov	ebx, eax
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 20					; 00000014H

; 1483 : 
; 1484 : 	if (!bDebug)
; 1485 : 		lua_pushinteger(L, pkPlot->getRevealedOwner(eTeam));

	mov	ecx, edi
	test	al, al
	jne	SHORT $LN2@lGetReveal
	push	ebx
	call	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedOwner

; 1486 : 	else
; 1487 : 		lua_pushinteger(L, pkPlot->getRevealedOwner(eTeam, true));

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1488 : 
; 1489 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1490 : }

	ret	0
$LN2@lGetReveal:

; 1486 : 	else
; 1487 : 		lua_pushinteger(L, pkPlot->getRevealedOwner(eTeam, true));

	push	1
	push	ebx
	call	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedOwner
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1488 : 
; 1489 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1490 : }

	ret	0
?lGetRevealedOwner@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetRevealedOwner
_TEXT	ENDS
PUBLIC	?lGetRevealedTeam@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedTeam
EXTRN	?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@_N@Z:PROC ; CvPlot::getRevealedTeam
EXTRN	?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@@Z:PROC ; CvPlot::getRevealedTeam
; Function compile flags: /Ogtpy
;	COMDAT ?lGetRevealedTeam@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetRevealedTeam@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetRevealedTeam, COMDAT

; 1494 : {

	push	ebx
	push	ebp
	push	esi

; 1495 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@lGetReveal@2
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@lGetReveal@2
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@lGetReveal@2
	xor	bl, bl
$LN7@lGetReveal@2:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@lGetReveal@2
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@lGetReveal@2:

; 1496 : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 1497 : 	const bool bDebug = luaL_optbool(L, 3, false);

	push	0
	push	3
	push	esi
	mov	ebx, eax
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 20					; 00000014H

; 1498 : 
; 1499 : 	if (!bDebug)
; 1500 : 		lua_pushinteger(L, pkPlot->getRevealedTeam(eTeam));

	mov	ecx, edi
	test	al, al
	jne	SHORT $LN2@lGetReveal@2
	push	ebx
	call	?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@@Z ; CvPlot::getRevealedTeam

; 1501 : 	else
; 1502 : 		lua_pushinteger(L, pkPlot->getRevealedTeam(eTeam, true));

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1503 : 
; 1504 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1505 : }

	ret	0
$LN2@lGetReveal@2:

; 1501 : 	else
; 1502 : 		lua_pushinteger(L, pkPlot->getRevealedTeam(eTeam, true));

	push	1
	push	ebx
	call	?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@_N@Z ; CvPlot::getRevealedTeam
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1503 : 
; 1504 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1505 : }

	ret	0
?lGetRevealedTeam@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetRevealedTeam
_TEXT	ENDS
PUBLIC	?lIsRiverCrossing@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverCrossing
EXTRN	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z:PROC ; CvPlot::isRiverCrossing
; Function compile flags: /Ogtpy
;	COMDAT ?lIsRiverCrossing@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRiverCrossing@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsRiverCrossing, COMDAT

; 1510 : 	return BasicLuaMethod(L, &CvPlot::isRiverCrossing);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	push	eax
	call	??$BasicLuaMethod@_NW4DirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4DirectionTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum DirectionTypes>
	add	esp, 8

; 1511 : }

	ret	0
?lIsRiverCrossing@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsRiverCrossing
_TEXT	ENDS
PUBLIC	?lIsRiverCrossingToPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverCrossingToPlot
; Function compile flags: /Ogtpy
;	COMDAT ?lIsRiverCrossingToPlot@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bIsCrossingRiver$ = -5					; size = 1
_stack_size$228074 = -4					; size = 4
_L$ = 8							; size = 4
?lIsRiverCrossingToPlot@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsRiverCrossingToPlot, COMDAT

; 1515 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 1516 : 	bool bIsCrossingRiver = false;
; 1517 : 	CvPlot* pkMyPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+16]
	push	edi
	push	esi
	mov	BYTE PTR _bIsCrossingRiver$[esp+28], 0
	call	_lua_gettop
	push	1
	push	esi
	mov	edi, eax
	mov	bl, 1
	xor	ebp, ebp
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN6@lIsRiverCr@2
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN6@lIsRiverCr@2
	push	-1
	push	esi
	call	_lua_touserdata
	mov	ebp, eax
	add	esp, 8
	test	ebp, ebp
	je	SHORT $LN6@lIsRiverCr@2
	xor	bl, bl
$LN6@lIsRiverCr@2:
	push	edi
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN13@lIsRiverCr@2
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN13@lIsRiverCr@2:

; 1518 : 	CvPlot* pkOtherPlot = GetInstance(L, 2);

	push	esi
	call	_lua_gettop
	push	2
	push	esi
	mov	DWORD PTR _stack_size$228074[esp+36], eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN17@lIsRiverCr@2
	push	OFFSET $SG223013
	push	2
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN17@lIsRiverCr@2
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN17@lIsRiverCr@2
	xor	bl, bl
$LN17@lIsRiverCr@2:
	mov	eax, DWORD PTR _stack_size$228074[esp+24]
	push	eax
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN24@lIsRiverCr@2
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 8
$LN24@lIsRiverCr@2:

; 1519 : 
; 1520 : 	if(pkMyPlot->isRiverCrossing(directionXY(pkMyPlot, pkOtherPlot)))

	movsx	ecx, WORD PTR [edi+2]
	movsx	edx, WORD PTR [edi]
	movsx	eax, WORD PTR [ebp+2]
	push	ecx
	movsx	ecx, WORD PTR [ebp]
	push	edx
	push	eax
	push	ecx
	call	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ; directionXY
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, ebp
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	test	al, al

; 1521 : 	{
; 1522 : 		bIsCrossingRiver = true;

	mov	al, 1
	jne	SHORT $LN1@lIsRiverCr@2
	mov	al, BYTE PTR _bIsCrossingRiver$[esp+24]
$LN1@lIsRiverCr@2:

; 1523 : 	}
; 1524 : 
; 1525 : 	lua_pushboolean(L, bIsCrossingRiver);

	movzx	edx, al
	push	edx
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1526 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1527 : }

	add	esp, 8
	ret	0
?lIsRiverCrossingToPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsRiverCrossingToPlot
_TEXT	ENDS
PUBLIC	?lIsRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?lIsRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsRevealed, COMDAT

; 1531 : {

	push	ebx
	push	ebp
	push	esi

; 1532 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	edi, eax
	mov	bl, 1
	xor	ebp, ebp
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@lIsReveale
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@lIsReveale
	push	-1
	push	esi
	call	_lua_touserdata
	mov	ebp, eax
	add	esp, 8
	test	ebp, ebp
	je	SHORT $LN7@lIsReveale
	xor	bl, bl
$LN7@lIsReveale:
	push	edi
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@lIsReveale
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@lIsReveale:

; 1533 : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 1534 : 	const bool bDebug = luaL_optbool(L, 3, false);

	push	0
	push	3
	push	esi
	mov	edi, eax
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 20					; 00000014H

; 1535 : 
; 1536 : 	if (!bDebug)

	test	al, al
	jne	SHORT $LN2@lIsReveale

; 1537 : 		lua_pushboolean(L, pkPlot->isRevealed(eTeam));

	mov	eax, edi
	shr	eax, 5
	mov	ecx, eax
	shl	ecx, 5
	mov	edx, ecx
	mov	ecx, edi
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	and	edx, DWORD PTR [ebp+eax*4+8]
	neg	edx
	sbb	edx, edx
	neg	edx
	push	edx

; 1538 : 	else
; 1539 : 		lua_pushboolean(L, pkPlot->isRevealed(eTeam, true));

	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1540 : 
; 1541 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1542 : }

	ret	0
$LN2@lIsReveale:

; 1538 : 	else
; 1539 : 		lua_pushboolean(L, pkPlot->isRevealed(eTeam, true));

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	test	al, al
	je	SHORT $LN20@lIsReveale
	mov	al, 1
	jmp	SHORT $LN21@lIsReveale
$LN20@lIsReveale:
	mov	eax, edi
	shr	eax, 5
	mov	ecx, eax
	shl	ecx, 5
	mov	edx, ecx
	mov	ecx, edi
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [ebp+eax*4+8]
	setne	al
$LN21@lIsReveale:
	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1540 : 
; 1541 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1542 : }

	ret	0
?lIsRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsRevealed
_TEXT	ENDS
PUBLIC	?lSetRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetRevealed
EXTRN	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z:PROC ; CvPlot::setRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?lSetRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bTerrainOnly$ = -8					; size = 1
_bNewValue$ = -4					; size = 1
_L$ = 8							; size = 4
?lSetRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetRevealed, COMDAT

; 1546 : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 1547 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+16]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lSetReveal
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lSetReveal
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lSetReveal
	xor	bl, bl
$LN5@lSetReveal:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lSetReveal
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lSetReveal:

; 1548 : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 1549 : 	const bool bNewValue = lua_toboolean(L, 3);

	push	3
	push	esi
	mov	ebx, eax
	call	_lua_toboolean

; 1550 : 	const bool bTerrainOnly = luaL_optint(L, 4, 0);

	push	0
	test	eax, eax
	setne	al
	push	4
	push	esi
	mov	BYTE PTR _bNewValue$[esp+52], al
	call	_luaL_optinteger

; 1551 : 	const TeamTypes eFromTeam = (TeamTypes)luaL_optint(L, 5, NO_TEAM);

	push	-1
	test	eax, eax
	setne	cl
	push	5
	push	esi
	mov	BYTE PTR _bTerrainOnly$[esp+64], cl
	call	_luaL_optinteger

; 1552 : 	pkPlot->setRevealed(eTeam, bNewValue, bTerrainOnly, eFromTeam);

	mov	edx, DWORD PTR _bTerrainOnly$[esp+64]
	add	esp, 40					; 00000028H
	push	eax
	mov	eax, DWORD PTR _bNewValue$[esp+28]
	push	edx
	push	eax
	push	ebx
	mov	ecx, edi
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed
	pop	edi
	pop	esi
	pop	ebp

; 1553 : 
; 1554 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1555 : }

	add	esp, 8
	ret	0
?lSetRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetRevealed
_TEXT	ENDS
PUBLIC	?lGetRevealedImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedImprovementType
EXTRN	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::getRevealedImprovementType
EXTRN	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getRevealedImprovementType
; Function compile flags: /Ogtpy
;	COMDAT ?lGetRevealedImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetRevealedImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetRevealedImprovementType, COMDAT

; 1559 : {

	push	ebx
	push	ebp
	push	esi

; 1560 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@lGetReveal@3
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@lGetReveal@3
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@lGetReveal@3
	xor	bl, bl
$LN7@lGetReveal@3:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@lGetReveal@3
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@lGetReveal@3:

; 1561 : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 1562 : 	const bool bDebug = luaL_optbool(L, 3, false);

	push	0
	push	3
	push	esi
	mov	ebx, eax
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 20					; 00000014H

; 1563 : 
; 1564 : 	if (!bDebug)
; 1565 : 		lua_pushinteger(L, pkPlot->getRevealedImprovementType(eTeam));

	mov	ecx, edi
	test	al, al
	jne	SHORT $LN2@lGetReveal@3
	push	ebx
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedImprovementType

; 1566 : 	else
; 1567 : 		lua_pushinteger(L, pkPlot->getRevealedImprovementType(eTeam, true));

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1568 : 
; 1569 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1570 : }

	ret	0
$LN2@lGetReveal@3:

; 1566 : 	else
; 1567 : 		lua_pushinteger(L, pkPlot->getRevealedImprovementType(eTeam, true));

	push	1
	push	ebx
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedImprovementType
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1568 : 
; 1569 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1570 : }

	ret	0
?lGetRevealedImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetRevealedImprovementType
_TEXT	ENDS
PUBLIC	?lGetRevealedRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedRouteType
EXTRN	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::getRevealedRouteType
EXTRN	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getRevealedRouteType
; Function compile flags: /Ogtpy
;	COMDAT ?lGetRevealedRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetRevealedRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetRevealedRouteType, COMDAT

; 1574 : {

	push	ebx
	push	ebp
	push	esi

; 1575 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@lGetReveal@4
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@lGetReveal@4
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@lGetReveal@4
	xor	bl, bl
$LN7@lGetReveal@4:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@lGetReveal@4
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@lGetReveal@4:

; 1576 : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 1577 : 	const bool bDebug = luaL_optbool(L, 3, false);

	push	0
	push	3
	push	esi
	mov	ebx, eax
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 20					; 00000014H

; 1578 : 
; 1579 : 	if (!bDebug)
; 1580 : 		lua_pushinteger(L, pkPlot->getRevealedRouteType(eTeam));

	mov	ecx, edi
	test	al, al
	jne	SHORT $LN2@lGetReveal@4
	push	ebx
	call	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedRouteType

; 1581 : 	else
; 1582 : 		lua_pushinteger(L, pkPlot->getRevealedRouteType(eTeam, true));

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1583 : 
; 1584 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1585 : }

	ret	0
$LN2@lGetReveal@4:

; 1581 : 	else
; 1582 : 		lua_pushinteger(L, pkPlot->getRevealedRouteType(eTeam, true));

	push	1
	push	ebx
	call	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedRouteType
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1583 : 
; 1584 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1585 : }

	ret	0
?lGetRevealedRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetRevealedRouteType
_TEXT	ENDS
PUBLIC	?lGetBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBuildProgress
EXTRN	?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z:PROC ; CvPlot::getBuildProgress
; Function compile flags: /Ogtpy
;	COMDAT ?lGetBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetBuildProgress, COMDAT

; 1590 : 	return BasicLuaMethod(L, &CvPlot::getBuildProgress);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z ; CvPlot::getBuildProgress
	push	eax
	call	??$BasicLuaMethod@HW4BuildTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes>
	add	esp, 8

; 1591 : }

	ret	0
?lGetBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetBuildProgress
_TEXT	ENDS
PUBLIC	?lChangeBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeBuildProgress
EXTRN	?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z:PROC ; CvPlot::changeBuildProgress
; Function compile flags: /Ogtpy
;	COMDAT ?lChangeBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lChangeBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lChangeBuildProgress, COMDAT

; 1596 : 	return BasicLuaMethod(L, &CvPlot::changeBuildProgress);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z ; CvPlot::changeBuildProgress
	push	eax
	call	??$BasicLuaMethod@_NW4BuildTypes@@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4BuildTypes@@HW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,int,enum PlayerTypes>
	add	esp, 8

; 1597 : }

	ret	0
?lChangeBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lChangeBuildProgress
_TEXT	ENDS
PUBLIC	?lGetInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetInvisibleVisibilityCount
EXTRN	?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z:PROC ; CvPlot::getInvisibleVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?lGetInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetInvisibleVisibilityCount, COMDAT

; 1602 : 	return BasicLuaMethod(L, &CvPlot::getInvisibleVisibilityCount);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::getInvisibleVisibilityCount
	push	eax
	call	??$BasicLuaMethod@HW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@W4InvisibleTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,enum InvisibleTypes>
	add	esp, 8

; 1603 : }

	ret	0
?lGetInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetInvisibleVisibilityCount
_TEXT	ENDS
PUBLIC	?lIsInvisibleVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsInvisibleVisible
EXTRN	?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z:PROC ; CvPlot::isInvisibleVisible
; Function compile flags: /Ogtpy
;	COMDAT ?lIsInvisibleVisible@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsInvisibleVisible@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsInvisibleVisible, COMDAT

; 1608 : 	return BasicLuaMethod(L, &CvPlot::isInvisibleVisible);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::isInvisibleVisible
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4InvisibleTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum InvisibleTypes>
	add	esp, 8

; 1609 : }

	ret	0
?lIsInvisibleVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsInvisibleVisible
_TEXT	ENDS
PUBLIC	?lChangeInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeInvisibleVisibilityCount
EXTRN	?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z:PROC ; CvPlot::changeInvisibleVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?lChangeInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lChangeInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lChangeInvisibleVisibilityCount, COMDAT

; 1614 : 	return BasicLuaMethod(L, &CvPlot::changeInvisibleVisibilityCount);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z ; CvPlot::changeInvisibleVisibilityCount
	push	eax
	call	??$BasicLuaMethod@W4TeamTypes@@W4InvisibleTypes@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4TeamTypes@@W4InvisibleTypes@@H@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes,enum InvisibleTypes,int>
	add	esp, 8

; 1615 : }

	ret	0
?lChangeInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lChangeInvisibleVisibilityCount
_TEXT	ENDS
PUBLIC	?lGetNumUnits@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetNumUnits
EXTRN	?getNumUnits@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumUnits
; Function compile flags: /Ogtpy
;	COMDAT ?lGetNumUnits@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumUnits@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetNumUnits, COMDAT

; 1620 : 	return BasicLuaMethod(L, &CvPlot::getNumUnits);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?getNumUnits@CvPlot@@QBEHXZ	; CvPlot::getNumUnits
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1621 : }

	ret	0
?lGetNumUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetNumUnits
_TEXT	ENDS
PUBLIC	?lGetUnit@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetUnit
EXTRN	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z:PROC	; CvPlot::getUnitByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?lGetUnit@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetUnit@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lGetUnit, COMDAT

; 1625 : {

	push	ebx
	push	ebp
	push	esi

; 1626 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetUnit
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetUnit
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetUnit
	xor	bl, bl
$LN5@lGetUnit:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetUnit
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetUnit:

; 1627 : 	const int iIndex = lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8

; 1628 : 
; 1629 : 	CvUnit* pkUnit = pkPlot->getUnitByIndex(iIndex);

	push	eax
	mov	ecx, edi
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex

; 1630 : 	CvLuaUnit::Push(L, pkUnit);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::Push
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1631 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1632 : }

	ret	0
?lGetUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lGetUnit
_TEXT	ENDS
PUBLIC	?lGetNumLayerUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumLayerUnits
EXTRN	?getNumLayerUnits@CvPlot@@QBEHH@Z:PROC		; CvPlot::getNumLayerUnits
; Function compile flags: /Ogtpy
;	COMDAT ?lGetNumLayerUnits@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumLayerUnits@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetNumLayerUnits, COMDAT

; 1636 : {

	push	ebx
	push	ebp
	push	esi

; 1637 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetNumLay
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetNumLay
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetNumLay
	xor	bl, bl
$LN5@lGetNumLay:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetNumLay
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetNumLay:

; 1638 : 	const int iLayerID = luaL_optinteger(L, 2, -1);

	push	-1
	push	2
	push	esi
	call	_luaL_optinteger
	add	esp, 12					; 0000000cH

; 1639 : 
; 1640 : 	lua_pushinteger(L, pkPlot->getNumLayerUnits(iLayerID));

	push	eax
	mov	ecx, edi
	call	?getNumLayerUnits@CvPlot@@QBEHH@Z	; CvPlot::getNumLayerUnits
	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1641 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1642 : }

	ret	0
?lGetNumLayerUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetNumLayerUnits
_TEXT	ENDS
PUBLIC	?lGetLayerUnit@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetLayerUnit
EXTRN	?getLayerUnit@CvPlot@@QBEPAVCvUnit@@HH@Z:PROC	; CvPlot::getLayerUnit
; Function compile flags: /Ogtpy
;	COMDAT ?lGetLayerUnit@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetLayerUnit@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetLayerUnit, COMDAT

; 1646 : {

	push	ebx
	push	ebp
	push	esi

; 1647 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetLayerU
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetLayerU
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetLayerU
	xor	bl, bl
$LN5@lGetLayerU:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetLayerU
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetLayerU:

; 1648 : 	const int iIndex = lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger

; 1649 : 	const int iLayerID = luaL_optinteger(L, 3, -1);

	push	-1
	push	3
	push	esi
	mov	ebx, eax
	call	_luaL_optinteger
	add	esp, 20					; 00000014H

; 1650 : 
; 1651 : 	CvUnit* pkUnit = pkPlot->getLayerUnit(iIndex, iLayerID);

	push	eax
	push	ebx
	mov	ecx, edi
	call	?getLayerUnit@CvPlot@@QBEPAVCvUnit@@HH@Z ; CvPlot::getLayerUnit

; 1652 : 	CvLuaUnit::Push(L, pkUnit);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::Push
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1653 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1654 : }

	ret	0
?lGetLayerUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetLayerUnit
_TEXT	ENDS
PUBLIC	?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetScriptData
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?getScriptData@CvPlot@@QBE?AVCvString@@XZ:PROC	; CvPlot::getScriptData
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z$0
__ehfuncinfo$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaplot.cpp
xdata$x	ENDS
;	COMDAT ?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_strResult$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
_L$ = 8							; size = 4
?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetScriptData, COMDAT

; 1658 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi

; 1659 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+48]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN6@lGetScript
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN6@lGetScript
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN6@lGetScript
	xor	bl, bl
$LN6@lGetScript:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN13@lGetScript
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN13@lGetScript:

; 1660 : 	const CvString strResult = pkPlot->getScriptData();

	lea	eax, DWORD PTR _strResult$[esp+56]
	push	eax
	mov	ecx, edi
	call	?getScriptData@CvPlot@@QBE?AVCvString@@XZ ; CvPlot::getScriptData

; 1661 : 	lua_pushstring(L, strResult.c_str());

	lea	ecx, DWORD PTR _strResult$[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], 0
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	esi
	call	_lua_pushstring
	add	esp, 8

; 1662 : 	return 1;

	lea	ecx, DWORD PTR _strResult$[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1663 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z$0:
	lea	ecx, DWORD PTR _strResult$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetScriptData
PUBLIC	?lSetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetScriptData
EXTRN	?setScriptData@CvPlot@@QAEXPBD@Z:PROC		; CvPlot::setScriptData
EXTRN	_lua_tolstring:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?lSetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetScriptData, COMDAT

; 1667 : {

	push	ebx
	push	ebp
	push	esi

; 1668 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lSetScript
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lSetScript
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lSetScript
	xor	bl, bl
$LN5@lSetScript:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lSetScript
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lSetScript:

; 1669 : 	const char* strNewValue = lua_tostring(L, 2);

	push	0
	push	2
	push	esi
	call	_lua_tolstring
	add	esp, 12					; 0000000cH

; 1670 : 
; 1671 : 	pkPlot->setScriptData(strNewValue);

	push	eax
	mov	ecx, edi
	call	?setScriptData@CvPlot@@QAEXPBD@Z	; CvPlot::setScriptData
	pop	edi
	pop	esi
	pop	ebp

; 1672 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1673 : }

	ret	0
?lSetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetScriptData
_TEXT	ENDS
PUBLIC	?lGetActiveFogOfWarMode@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetActiveFogOfWarMode
EXTRN	?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ:PROC ; CvPlot::GetActiveFogOfWarMode
; Function compile flags: /Ogtpy
;	COMDAT ?lGetActiveFogOfWarMode@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetActiveFogOfWarMode@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetActiveFogOfWarMode, COMDAT

; 1677 : {

	push	ebx
	push	ebp
	push	esi

; 1678 : 	CvPlot* pkPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN10@lGetActive
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN10@lGetActive
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN10@lGetActive
	xor	bl, bl
$LN10@lGetActive:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN17@lGetActive
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN17@lGetActive:

; 1679 : 
; 1680 : 	int fow = 0;
; 1681 : 	// convert from game fog of war defines to engine fog of war defines
; 1682 : 	switch(pkPlot->GetActiveFogOfWarMode())

	mov	ecx, edi
	xor	ebx, ebx
	call	?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ ; CvPlot::GetActiveFogOfWarMode
	sub	eax, ebx
	je	SHORT $LN19@lGetActive
	sub	eax, 1
	je	SHORT $LN19@lGetActive
	sub	eax, 1
	jne	SHORT $LN4@lGetActive
$LN19@lGetActive:

; 1683 : 	{
; 1684 : 	case FOGOFWARMODE_OFF:
; 1685 : 		fow = 2;
; 1686 : #ifdef AUI_WARNING_FIXES
; 1687 : 		break;
; 1688 : #else
; 1689 : 	case FOGOFWARMODE_UNEXPLORED:
; 1690 : 		fow = 0;
; 1691 : #endif
; 1692 : 	case FOGOFWARMODE_NOVIS:
; 1693 : 		fow = 1;

	mov	ebx, 1
$LN4@lGetActive:

; 1694 : #ifdef AUI_WARNING_FIXES
; 1695 : 		break;
; 1696 : #endif
; 1697 : 	}
; 1698 : 
; 1699 : 	lua_pushinteger(L, fow);

	push	ebx
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1700 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1701 : }

	ret	0
?lGetActiveFogOfWarMode@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetActiveFogOfWarMode
_TEXT	ENDS
PUBLIC	?lIsImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsImprovementPillaged
EXTRN	?IsImprovementPillaged@CvPlot@@QBE_NXZ:PROC	; CvPlot::IsImprovementPillaged
; Function compile flags: /Ogtpy
;	COMDAT ?lIsImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsImprovementPillaged, COMDAT

; 1706 : 	return BasicLuaMethod(L, &CvPlot::IsImprovementPillaged);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?IsImprovementPillaged@CvPlot@@QBE_NXZ ; CvPlot::IsImprovementPillaged
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1707 : }

	ret	0
?lIsImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsImprovementPillaged
_TEXT	ENDS
PUBLIC	?lCanSeePlot@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lCanSeePlot
EXTRN	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z:PROC ; CvPlot::canSeePlot
; Function compile flags: /Ogtpy
;	COMDAT ?lCanSeePlot@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkInstance$228475 = -4					; size = 4
_L$ = 8							; size = 4
?lCanSeePlot@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lCanSeePlot, COMDAT

; 1712 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 1713 : 	CvPlot* pkThisPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	edi, eax
	mov	bl, 1
	xor	ebp, ebp
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN6@lCanSeePlo
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN6@lCanSeePlo
	push	-1
	push	esi
	call	_lua_touserdata
	mov	ebp, eax
	add	esp, 8
	test	ebp, ebp
	je	SHORT $LN6@lCanSeePlo
	xor	bl, bl
$LN6@lCanSeePlo:
	push	edi
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN13@lCanSeePlo
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN13@lCanSeePlo:

; 1714 : 	CvPlot* pkThatPlot = GetInstance(L, 2);

	push	esi
	call	_lua_gettop
	push	2
	push	esi
	mov	edi, eax
	mov	bl, 1
	mov	DWORD PTR _pkInstance$228475[esp+32], 0
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN17@lCanSeePlo
	push	OFFSET $SG223013
	push	2
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN17@lCanSeePlo
	push	-1
	push	esi
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pkInstance$228475[esp+20], eax
	test	eax, eax
	je	SHORT $LN17@lCanSeePlo
	xor	bl, bl
$LN17@lCanSeePlo:
	push	edi
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN24@lCanSeePlo
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 8
$LN24@lCanSeePlo:

; 1715 : 	TeamTypes eTeam = (TeamTypes) lua_tointeger(L, 3);

	push	3
	push	esi
	call	_lua_tointeger

; 1716 : 	int iRange = lua_tointeger(L, 4);

	push	4
	push	esi
	mov	edi, eax
	call	_lua_tointeger

; 1717 : 	DirectionTypes eFacingDirection = (DirectionTypes) lua_tointeger(L, 5);

	push	5
	push	esi
	mov	ebx, eax
	call	_lua_tointeger
	mov	ecx, eax
	add	esp, 24					; 00000018H

; 1718 : 
; 1719 : 	bool bCanSee = false;

	xor	al, al

; 1720 : 	if(pkThisPlot)

	test	ebp, ebp
	je	SHORT $LN1@lCanSeePlo

; 1721 : 	{
; 1722 : 		bCanSee = pkThisPlot->canSeePlot(pkThatPlot, eTeam, iRange, eFacingDirection);

	mov	eax, DWORD PTR _pkInstance$228475[esp+20]
	push	ecx
	push	ebx
	push	edi
	push	eax
	mov	ecx, ebp
	call	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z ; CvPlot::canSeePlot
$LN1@lCanSeePlo:

; 1723 : 	}
; 1724 : 
; 1725 : 	lua_pushboolean(L, bCanSee);

	movzx	ecx, al
	push	ecx
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1726 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1727 : 
; 1728 : }

	pop	ecx
	ret	0
?lCanSeePlot@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lCanSeePlot
_TEXT	ENDS
PUBLIC	?lGetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetContinentArtType
EXTRN	?GetContinentType@CvPlot@@QBEDXZ:PROC		; CvPlot::GetContinentType
; Function compile flags: /Ogtpy
;	COMDAT ?lGetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetContinentArtType, COMDAT

; 1732 : {

	push	ebx
	push	ebp
	push	esi

; 1733 : 	CvPlot* pkThisPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN7@lGetContin
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN7@lGetContin
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN7@lGetContin
	xor	bl, bl
$LN7@lGetContin:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN14@lGetContin
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN14@lGetContin:

; 1734 : 	if(pkThisPlot)

	test	edi, edi
	je	SHORT $LN2@lGetContin

; 1735 : 	{
; 1736 : 		lua_pushinteger(L, pkThisPlot->GetContinentType());

	mov	ecx, edi
	call	?GetContinentType@CvPlot@@QBEDXZ	; CvPlot::GetContinentType
	movsx	eax, al
	push	eax

; 1737 : 	}
; 1738 : 	else
; 1739 : 	{
; 1740 : 		lua_pushinteger(L, 0);

	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1741 : 	}
; 1742 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1743 : }

	ret	0
$LN2@lGetContin:

; 1737 : 	}
; 1738 : 	else
; 1739 : 	{
; 1740 : 		lua_pushinteger(L, 0);

	push	0
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1741 : 	}
; 1742 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1743 : }

	ret	0
?lGetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetContinentArtType
_TEXT	ENDS
PUBLIC	?lSetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetContinentArtType
EXTRN	?SetContinentType@CvPlot@@QAEXD@Z:PROC		; CvPlot::SetContinentType
; Function compile flags: /Ogtpy
;	COMDAT ?lSetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lSetContinentArtType, COMDAT

; 1747 : {

	push	ebx
	push	ebp
	push	esi

; 1748 : 	CvPlot* pkThisPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN6@lSetContin
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN6@lSetContin
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN6@lSetContin
	xor	bl, bl
$LN6@lSetContin:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN13@lSetContin
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN13@lSetContin:

; 1749 : 	if(pkThisPlot)

	test	edi, edi
	je	SHORT $LN15@lSetContin

; 1750 : 	{
; 1751 : 		const int iContinentType = lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8

; 1752 : 		pkThisPlot->SetContinentType((char) iContinentType);

	push	eax
	mov	ecx, edi
	call	?SetContinentType@CvPlot@@QAEXD@Z	; CvPlot::SetContinentType
$LN15@lSetContin:
	pop	edi
	pop	esi
	pop	ebp

; 1753 : 	}
; 1754 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1755 : }

	ret	0
?lSetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lSetContinentArtType
_TEXT	ENDS
PUBLIC	?lIsResourceConnectedByImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsResourceConnectedByImprovement
EXTRN	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceTrade
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
; Function compile flags: /Ogtpy
;	COMDAT ?lIsResourceConnectedByImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bResult$ = -1						; size = 1
_L$ = 8							; size = 4
?lIsResourceConnectedByImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsResourceConnectedByImprovement, COMDAT

; 1760 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 1761 : 	bool bResult = false;
; 1762 : 	CvPlot* kPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	mov	BYTE PTR _bResult$[esp+24], 0
	call	_lua_gettop
	push	1
	push	esi
	mov	edi, eax
	mov	bl, 1
	xor	ebp, ebp
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN6@lIsResourc
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN6@lIsResourc
	push	-1
	push	esi
	call	_lua_touserdata
	mov	ebp, eax
	add	esp, 8
	test	ebp, ebp
	je	SHORT $LN6@lIsResourc
	xor	bl, bl
$LN6@lIsResourc:
	push	edi
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN13@lIsResourc
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN13@lIsResourc:

; 1763 : 	const ImprovementTypes eImprovement = (ImprovementTypes) lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8

; 1764 : 	CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	edi, eax

; 1765 : 	if(pkImprovementInfo)

	test	edi, edi
	je	SHORT $LN17@lIsResourc

; 1766 : 	{
; 1767 : 		bResult = pkImprovementInfo->IsImprovementResourceTrade(kPlot->getResourceType(GC.getGame().getActiveTeam()));

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, ebp
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, edi
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	jmp	SHORT $LN1@lIsResourc
$LN17@lIsResourc:
	mov	al, BYTE PTR _bResult$[esp+20]
$LN1@lIsResourc:

; 1768 : 	}
; 1769 : 
; 1770 : 	lua_pushboolean(L, bResult);

	movzx	eax, al
	push	eax
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1771 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1772 : }

	pop	ecx
	ret	0
?lIsResourceConnectedByImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsResourceConnectedByImprovement
_TEXT	ENDS
PUBLIC	?lIsBuildRemovesFeature@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsBuildRemovesFeature
EXTRN	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z:PROC	; CvBuildInfo::isFeatureRemove
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
; Function compile flags: /Ogtpy
;	COMDAT ?lIsBuildRemovesFeature@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsBuildRemovesFeature@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsBuildRemovesFeature, COMDAT

; 1776 : {

	push	ebx
	push	ebp
	push	esi

; 1777 : 	CvPlot* kPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN6@lIsBuildRe
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN6@lIsBuildRe
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN6@lIsBuildRe
	xor	bl, bl
$LN6@lIsBuildRe:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN13@lIsBuildRe
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN13@lIsBuildRe:

; 1778 : 	const BuildTypes eBuild = (BuildTypes) lua_tointeger(L, 2);

	push	2
	push	esi
	call	_lua_tointeger
	add	esp, 8

; 1779 : 	bool bFeatureRemoved = false;
; 1780 : 
; 1781 : 	CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	bl, bl
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 1782 : 	if(NULL != pkBuildInfo && kPlot->getFeatureType() != NO_FEATURE)

	test	eax, eax
	je	SHORT $LN1@lIsBuildRe
	mov	cl, BYTE PTR [edi+432]
	cmp	cl, -1
	je	SHORT $LN1@lIsBuildRe

; 1783 : 		bFeatureRemoved = pkBuildInfo->isFeatureRemove(kPlot->getFeatureType());

	movsx	ecx, cl
	push	ecx
	mov	ecx, eax
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	mov	bl, al
$LN1@lIsBuildRe:

; 1784 : 
; 1785 : 	lua_pushboolean(L, bFeatureRemoved);

	movzx	edx, bl
	push	edx
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1786 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1787 : }

	ret	0
?lIsBuildRemovesFeature@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsBuildRemovesFeature
_TEXT	ENDS
PUBLIC	?lGetArchaeologyArtifactType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactType
EXTRN	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ:PROC ; CvPlot::GetArchaeologicalRecord
; Function compile flags: /Ogtpy
;	COMDAT ?lGetArchaeologyArtifactType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T228613 = -20						; size = 20
_L$ = 8							; size = 4
?lGetArchaeologyArtifactType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetArchaeologyArtifactType, COMDAT

; 1791 : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi

; 1792 : 	CvPlot* kPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+28]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetArchae
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetArchae
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetArchae
	xor	bl, bl
$LN5@lGetArchae:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetArchae
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetArchae:

; 1793 : 	int iType = kPlot->GetArchaeologicalRecord().m_eArtifactType;

	lea	eax, DWORD PTR $T228613[esp+36]
	push	eax
	mov	ecx, edi
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	eax, DWORD PTR [eax]

; 1794 : 	lua_pushinteger(L, iType);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1795 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1796 : }

	add	esp, 20					; 00000014H
	ret	0
?lGetArchaeologyArtifactType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetArchaeologyArtifactType
_TEXT	ENDS
PUBLIC	?lGetArchaeologyArtifactEra@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactEra
; Function compile flags: /Ogtpy
;	COMDAT ?lGetArchaeologyArtifactEra@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T228640 = -20						; size = 20
_L$ = 8							; size = 4
?lGetArchaeologyArtifactEra@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetArchaeologyArtifactEra, COMDAT

; 1800 : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi

; 1801 : 	CvPlot* kPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+28]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetArchae@2
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetArchae@2
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetArchae@2
	xor	bl, bl
$LN5@lGetArchae@2:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetArchae@2
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetArchae@2:

; 1802 : 	int iEra = kPlot->GetArchaeologicalRecord().m_eEra;

	lea	eax, DWORD PTR $T228640[esp+36]
	push	eax
	mov	ecx, edi
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	eax, DWORD PTR [eax+4]

; 1803 : 	lua_pushinteger(L, iEra);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1804 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1805 : }

	add	esp, 20					; 00000014H
	ret	0
?lGetArchaeologyArtifactEra@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetArchaeologyArtifactEra
_TEXT	ENDS
PUBLIC	?lGetArchaeologyArtifactPlayer1@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactPlayer1
; Function compile flags: /Ogtpy
;	COMDAT ?lGetArchaeologyArtifactPlayer1@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T228667 = -20						; size = 20
_L$ = 8							; size = 4
?lGetArchaeologyArtifactPlayer1@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetArchaeologyArtifactPlayer1, COMDAT

; 1809 : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi

; 1810 : 	CvPlot* kPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+28]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetArchae@3
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetArchae@3
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetArchae@3
	xor	bl, bl
$LN5@lGetArchae@3:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetArchae@3
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetArchae@3:

; 1811 : 	int iPlayer = kPlot->GetArchaeologicalRecord().m_ePlayer1;

	lea	eax, DWORD PTR $T228667[esp+36]
	push	eax
	mov	ecx, edi
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	eax, DWORD PTR [eax+8]

; 1812 : 	lua_pushinteger(L, iPlayer);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1813 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1814 : }

	add	esp, 20					; 00000014H
	ret	0
?lGetArchaeologyArtifactPlayer1@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetArchaeologyArtifactPlayer1
_TEXT	ENDS
PUBLIC	?lGetArchaeologyArtifactPlayer2@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactPlayer2
; Function compile flags: /Ogtpy
;	COMDAT ?lGetArchaeologyArtifactPlayer2@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T228694 = -20						; size = 20
_L$ = 8							; size = 4
?lGetArchaeologyArtifactPlayer2@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetArchaeologyArtifactPlayer2, COMDAT

; 1818 : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi

; 1819 : 	CvPlot* kPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+28]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetArchae@4
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetArchae@4
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetArchae@4
	xor	bl, bl
$LN5@lGetArchae@4:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetArchae@4
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetArchae@4:

; 1820 : 	int iPlayer = kPlot->GetArchaeologicalRecord().m_ePlayer2;

	lea	eax, DWORD PTR $T228694[esp+36]
	push	eax
	mov	ecx, edi
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	eax, DWORD PTR [eax+12]

; 1821 : 	lua_pushinteger(L, iPlayer);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1822 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1823 : }

	add	esp, 20					; 00000014H
	ret	0
?lGetArchaeologyArtifactPlayer2@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetArchaeologyArtifactPlayer2
_TEXT	ENDS
PUBLIC	?lGetArchaeologyArtifactWork@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactWork
; Function compile flags: /Ogtpy
;	COMDAT ?lGetArchaeologyArtifactWork@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T228721 = -20						; size = 20
_L$ = 8							; size = 4
?lGetArchaeologyArtifactWork@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetArchaeologyArtifactWork, COMDAT

; 1827 : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi

; 1828 : 	CvPlot* kPlot = GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+28]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lGetArchae@5
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lGetArchae@5
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lGetArchae@5
	xor	bl, bl
$LN5@lGetArchae@5:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@lGetArchae@5
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@lGetArchae@5:

; 1829 : 	int iWork = (int)kPlot->GetArchaeologicalRecord().m_eWork;

	lea	eax, DWORD PTR $T228721[esp+36]
	push	eax
	mov	ecx, edi
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	eax, DWORD PTR [eax+16]

; 1830 : 	lua_pushinteger(L, iWork);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 1831 : 	return 1;

	mov	eax, 1
	pop	ebx

; 1832 : }

	add	esp, 20					; 00000014H
	ret	0
?lGetArchaeologyArtifactWork@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetArchaeologyArtifactWork
_TEXT	ENDS
PUBLIC	?lHasWrittenArtifact@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lHasWrittenArtifact
EXTRN	?HasWrittenArtifact@CvPlot@@QBE_NXZ:PROC	; CvPlot::HasWrittenArtifact
; Function compile flags: /Ogtpy
;	COMDAT ?lHasWrittenArtifact@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lHasWrittenArtifact@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lHasWrittenArtifact, COMDAT

; 1838 : 	return BasicLuaMethod(L, &CvPlot::HasWrittenArtifact);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?HasWrittenArtifact@CvPlot@@QBE_NXZ ; CvPlot::HasWrittenArtifact
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1839 : }

	ret	0
?lHasWrittenArtifact@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lHasWrittenArtifact
_TEXT	ENDS
PUBLIC	?lGetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetCityPurchaseID
EXTRN	?GetCityPurchaseID@CvPlot@@QAEHXZ:PROC		; CvPlot::GetCityPurchaseID
; Function compile flags: /Ogtpy
;	COMDAT ?lGetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetCityPurchaseID, COMDAT

; 1845 : 	return BasicLuaMethod(L, &CvPlot::GetCityPurchaseID);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?GetCityPurchaseID@CvPlot@@QAEHXZ ; CvPlot::GetCityPurchaseID
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1846 : }

	ret	0
?lGetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetCityPurchaseID
_TEXT	ENDS
PUBLIC	?lSetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetCityPurchaseID
EXTRN	?SetCityPurchaseID@CvPlot@@QAEXH@Z:PROC		; CvPlot::SetCityPurchaseID
; Function compile flags: /Ogtpy
;	COMDAT ?lSetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetCityPurchaseID, COMDAT

; 1852 : 	return BasicLuaMethod(L, &CvPlot::SetCityPurchaseID);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?SetCityPurchaseID@CvPlot@@QAEXH@Z ; CvPlot::SetCityPurchaseID
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1853 : }

	ret	0
?lSetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetCityPurchaseID
_TEXT	ENDS
PUBLIC	?BasicLuaMethod@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvluamethodwrapper.h
;	COMDAT ?BasicLuaMethod@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXXZ@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
?BasicLuaMethod@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXXZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod, COMDAT

; 222  : {

	push	ebx
	push	ebp
	push	esi

; 223  : 	InstanceType* pkType = Derived::GetInstance(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@BasicLuaMe@53
	push	OFFSET $SG223013
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@BasicLuaMe@53
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@BasicLuaMe@53
	xor	bl, bl
$LN5@BasicLuaMe@53:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN12@BasicLuaMe@53
	push	OFFSET $SG223019
	push	esi
	call	_luaL_error
	push	OFFSET $SG223027
	push	esi
	call	_luaL_error
	add	esp, 16					; 00000010H
$LN12@BasicLuaMe@53:

; 224  : 	(pkType->*func)();

	mov	ecx, edi
	call	DWORD PTR _func$[esp+12]
	pop	edi
	pop	esi
	pop	ebp

; 225  : 	return 0;

	xor	eax, eax
	pop	ebx

; 226  : }

	ret	0
?BasicLuaMethod@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXXZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod
_TEXT	ENDS
PUBLIC	?lUpdateVisibility@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lUpdateVisibility
EXTRN	?updateVisibility@CvPlot@@QAEXXZ:PROC		; CvPlot::updateVisibility
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaplot.cpp
;	COMDAT ?lUpdateVisibility@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lUpdateVisibility@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lUpdateVisibility, COMDAT

; 417  : 	return BasicLuaMethod(L, &CvPlot::updateVisibility);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?updateVisibility@CvPlot@@QAEXXZ	; CvPlot::updateVisibility
	push	eax
	call	?BasicLuaMethod@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod
	add	esp, 8

; 418  : }

	ret	0
?lUpdateVisibility@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lUpdateVisibility
_TEXT	ENDS
PUBLIC	?lRemoveGoody@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lRemoveGoody
EXTRN	?removeGoody@CvPlot@@QAEXXZ:PROC		; CvPlot::removeGoody
; Function compile flags: /Ogtpy
;	COMDAT ?lRemoveGoody@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lRemoveGoody@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lRemoveGoody, COMDAT

; 762  : 	return BasicLuaMethod(L, &CvPlot::removeGoody);

	mov	eax, DWORD PTR _L$[esp-4]
	push	OFFSET ?removeGoody@CvPlot@@QAEXXZ	; CvPlot::removeGoody
	push	eax
	call	?BasicLuaMethod@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod
	add	esp, 8

; 763  : }

	ret	0
?lRemoveGoody@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lRemoveGoody
_TEXT	ENDS
PUBLIC	?PushMethods@CvLuaPlot@@SAXPAUlua_State@@H@Z	; CvLuaPlot::PushMethods
EXTRN	_lua_pushcclosure:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?PushMethods@CvLuaPlot@@SAXPAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_t$ = 12						; size = 4
?PushMethods@CvLuaPlot@@SAXPAUlua_State@@H@Z PROC	; CvLuaPlot::PushMethods, COMDAT

; 30   : {

	push	esi

; 31   : 	Method(CanHaveFeature);

	mov	esi, DWORD PTR _L$[esp]
	push	edi
	push	0
	push	OFFSET ?lCanHaveFeature@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCanHaveFeature
	push	esi
	call	_lua_pushcclosure
	mov	edi, DWORD PTR _t$[esp+16]
	push	OFFSET $SG220417
	push	edi
	push	esi
	call	_lua_setfield

; 32   : 	Method(GetFeatureType);

	push	0
	push	OFFSET ?lGetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetFeatureType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220418
	push	edi
	push	esi
	call	_lua_setfield

; 33   : 	Method(GetTerrainType);

	push	0
	push	OFFSET ?lGetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetTerrainType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220419
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 34   : 	Method(IsRiver);

	push	0
	push	OFFSET ?lIsRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiver
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220420
	push	edi
	push	esi
	call	_lua_setfield

; 35   : 	Method(IsWater);

	push	0
	push	OFFSET ?lIsWater@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsWater
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220421
	push	edi
	push	esi
	call	_lua_setfield

; 36   : 	Method(SetFeatureType);

	push	0
	push	OFFSET ?lSetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetFeatureType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220422
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 37   : 	Method(SetTerrainType);

	push	0
	push	OFFSET ?lSetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetTerrainType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220423
	push	edi
	push	esi
	call	_lua_setfield

; 38   : 
; 39   : 	Method(IsNone);

	push	0
	push	OFFSET ?lIsNone@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsNone
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220424
	push	edi
	push	esi
	call	_lua_setfield

; 40   : 	Method(Erase);

	push	0
	push	OFFSET ?lErase@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lErase
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220425
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 41   : 	Method(GetTeam);

	push	0
	push	OFFSET ?lGetTeam@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetTeam
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220426
	push	edi
	push	esi
	call	_lua_setfield

; 42   : 
; 43   : 	Method(NukeExplosion);

	push	0
	push	OFFSET ?lNukeExplosion@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lNukeExplosion
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220427
	push	edi
	push	esi
	call	_lua_setfield

; 44   : 
; 45   : 	Method(GetInlandCorner);

	push	0
	push	OFFSET ?lGetInlandCorner@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetInlandCorner
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220428
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 46   : 
; 47   : 	Method(UpdateFog);

	push	0
	push	OFFSET ?lUpdateFog@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lUpdateFog
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220429
	push	edi
	push	esi
	call	_lua_setfield

; 48   : 	Method(UpdateVisibility);

	push	0
	push	OFFSET ?lUpdateVisibility@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lUpdateVisibility
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220430
	push	edi
	push	esi
	call	_lua_setfield

; 49   : 	Method(IsAdjacentToArea);

	push	0
	push	OFFSET ?lIsAdjacentToArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentToArea
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220431
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 50   : 	Method(ShareAdjacentArea);

	push	0
	push	OFFSET ?lShareAdjacentArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lShareAdjacentArea
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220432
	push	edi
	push	esi
	call	_lua_setfield

; 51   : 	Method(IsAdjacentToLand);

	push	0
	push	OFFSET ?lIsAdjacentToLand@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentToLand
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220433
	push	edi
	push	esi
	call	_lua_setfield

; 52   : 	Method(IsAdjacentToShallowWater);

	push	0
	push	OFFSET ?lIsAdjacentToShallowWater@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentToShallowWater
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220434
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 53   : 	Method(IsCoastalLand);

	push	0
	push	OFFSET ?lIsCoastalLand@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsCoastalLand
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220435
	push	edi
	push	esi
	call	_lua_setfield

; 54   : 
; 55   : 	Method(IsWithinTeamCityRadius);

	push	0
	push	OFFSET ?lIsWithinTeamCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsWithinTeamCityRadius
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220436
	push	edi
	push	esi
	call	_lua_setfield

; 56   : 
; 57   : 	Method(IsLake);

	push	0
	push	OFFSET ?lIsLake@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsLake
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220437
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 58   : 	Method(IsFreshWater);

	push	0
	push	OFFSET ?lIsFreshWater@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsFreshWater
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220438
	push	edi
	push	esi
	call	_lua_setfield

; 59   : 
; 60   : 	Method(IsRiverSide);

	push	0
	push	OFFSET ?lIsRiverSide@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverSide
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220439
	push	edi
	push	esi
	call	_lua_setfield

; 61   : 	Method(IsRiverConnection);

	push	0
	push	OFFSET ?lIsRiverConnection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverConnection
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220440
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 62   : 	Method(IsRiverCrossingFlowClockwise);

	push	0
	push	OFFSET ?lIsRiverCrossingFlowClockwise@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverCrossingFlowClockwise
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220441
	push	edi
	push	esi
	call	_lua_setfield

; 63   : 
; 64   : 	Method(GetNearestLandArea);

	push	0
	push	OFFSET ?lGetNearestLandArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNearestLandArea
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220442
	push	edi
	push	esi
	call	_lua_setfield

; 65   : 	Method(SeeFromLevel);

	push	0
	push	OFFSET ?lSeeFromLevel@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSeeFromLevel
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220443
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 66   : 	Method(GetNearestLandPlot);

	push	0
	push	OFFSET ?lGetNearestLandPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNearestLandPlot
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220444
	push	edi
	push	esi
	call	_lua_setfield

; 67   : 	Method(SeeThroughLevel);

	push	0
	push	OFFSET ?lSeeThroughLevel@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSeeThroughLevel
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220445
	push	edi
	push	esi
	call	_lua_setfield

; 68   : 	Method(CanHaveResource);

	push	0
	push	OFFSET ?lCanHaveResource@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCanHaveResource
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220446
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 69   : 	Method(CanHaveImprovement);

	push	0
	push	OFFSET ?lCanHaveImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCanHaveImprovement
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220447
	push	edi
	push	esi
	call	_lua_setfield

; 70   : 	Method(CanBuild);

	push	0
	push	OFFSET ?lCanBuild@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCanBuild
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220448
	push	edi
	push	esi
	call	_lua_setfield

; 71   : 	Method(GetBuildTime);

	push	0
	push	OFFSET ?lGetBuildTime@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBuildTime
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220449
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 72   : 	Method(GetBuildTurnsLeft);

	push	0
	push	OFFSET ?lGetBuildTurnsLeft@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBuildTurnsLeft
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220450
	push	edi
	push	esi
	call	_lua_setfield

; 73   : 	Method(GetBuildTurnsTotal);

	push	0
	push	OFFSET ?lGetBuildTurnsTotal@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBuildTurnsTotal
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220451
	push	edi
	push	esi
	call	_lua_setfield

; 74   : 	Method(GetFeatureProduction);

	push	0
	push	OFFSET ?lGetFeatureProduction@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetFeatureProduction
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220452
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 75   : #ifdef NQ_FOOD_FROM_CHOPS
; 76   : 	Method(GetFeatureFood);

	push	0
	push	OFFSET ?lGetFeatureFood@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetFeatureFood
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220453
	push	edi
	push	esi
	call	_lua_setfield

; 77   : #endif
; 78   : 
; 79   : 	Method(GetBestDefender);

	push	0
	push	OFFSET ?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBestDefender
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220454
	push	edi
	push	esi
	call	_lua_setfield

; 80   : 	Method(GetSelectedUnit);

	push	0
	push	OFFSET ?lGetSelectedUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetSelectedUnit
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220455
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 81   : 	Method(GetUnitPower);

	push	0
	push	OFFSET ?lGetUnitPower@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetUnitPower
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220456
	push	edi
	push	esi
	call	_lua_setfield

; 82   : 
; 83   : 	Method(DefenseModifier);

	push	0
	push	OFFSET ?lDefenseModifier@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lDefenseModifier
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220457
	push	edi
	push	esi
	call	_lua_setfield

; 84   : 	Method(MovementCost);

	push	0
	push	OFFSET ?lMovementCost@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lMovementCost
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220458
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 85   : 
; 86   : 	Method(GetExtraMovePathCost);

	push	0
	push	OFFSET ?lGetExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetExtraMovePathCost
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220459
	push	edi
	push	esi
	call	_lua_setfield

; 87   : 	Method(ChangeExtraMovePathCost);

	push	0
	push	OFFSET ?lChangeExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeExtraMovePathCost
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220460
	push	edi
	push	esi
	call	_lua_setfield

; 88   : 
; 89   : 	Method(IsAdjacentOwned);

	push	0
	push	OFFSET ?lIsAdjacentOwned@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentOwned
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220461
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 90   : 	Method(IsAdjacentPlayer);

	push	0
	push	OFFSET ?lIsAdjacentPlayer@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentPlayer
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220462
	push	edi
	push	esi
	call	_lua_setfield

; 91   : 	Method(IsAdjacentTeam);

	push	0
	push	OFFSET ?lIsAdjacentTeam@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentTeam
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220463
	push	edi
	push	esi
	call	_lua_setfield

; 92   : 
; 93   : 	Method(IsOwned);

	push	0
	push	OFFSET ?lIsOwned@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsOwned
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220464
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 94   : 	Method(IsBarbarian);

	push	0
	push	OFFSET ?lIsBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsBarbarian
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220465
	push	edi
	push	esi
	call	_lua_setfield

; 95   : 	Method(IsRevealedBarbarian);

	push	0
	push	OFFSET ?lIsRevealedBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRevealedBarbarian
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220466
	push	edi
	push	esi
	call	_lua_setfield

; 96   : 	Method(HasBarbarianCamp);

	push	0
	push	OFFSET ?lHasBarbarianCamp@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lHasBarbarianCamp
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220467
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 97   : 	Method(IsVisible);

	push	0
	push	OFFSET ?lIsVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisible
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220468
	push	edi
	push	esi
	call	_lua_setfield

; 98   : 	Method(IsActiveVisible);

	push	0
	push	OFFSET ?lIsActiveVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsActiveVisible
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220469
	push	edi
	push	esi
	call	_lua_setfield

; 99   : 	Method(IsVisibleToWatchingHuman);

	push	0
	push	OFFSET ?lIsVisibleToWatchingHuman@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleToWatchingHuman
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220470
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 100  : 	Method(IsAdjacentVisible);

	push	0
	push	OFFSET ?lIsAdjacentVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentVisible
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220471
	push	edi
	push	esi
	call	_lua_setfield

; 101  : 	Method(IsAdjacentNonvisible);

	push	0
	push	OFFSET ?lIsAdjacentNonvisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentNonvisible
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220472
	push	edi
	push	esi
	call	_lua_setfield

; 102  : 	Method(IsAdjacentRevealed);

	push	0
	push	OFFSET ?lIsAdjacentRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentRevealed
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220473
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 103  : 	Method(IsAdjacentNonrevealed);

	push	0
	push	OFFSET ?lIsAdjacentNonrevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentNonrevealed
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220474
	push	edi
	push	esi
	call	_lua_setfield

; 104  : 
; 105  : 	Method(RemoveGoody);

	push	0
	push	OFFSET ?lRemoveGoody@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lRemoveGoody
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220475
	push	edi
	push	esi
	call	_lua_setfield

; 106  : 	Method(IsGoody);

	push	0
	push	OFFSET ?lIsGoody@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsGoody
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220476
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 107  : 	Method(IsRevealedGoody);

	push	0
	push	OFFSET ?lIsRevealedGoody@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRevealedGoody
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220477
	push	edi
	push	esi
	call	_lua_setfield

; 108  : 
; 109  : 	Method(IsFriendlyTerritory);

	push	0
	push	OFFSET ?lIsFriendlyTerritory@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsFriendlyTerritory
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220478
	push	edi
	push	esi
	call	_lua_setfield

; 110  : 
; 111  : 	Method(IsCity);

	push	0
	push	OFFSET ?lIsCity@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsCity
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220479
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 112  : 	Method(IsFriendlyCity);

	push	0
	push	OFFSET ?lIsFriendlyCity@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsFriendlyCity
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220480
	push	edi
	push	esi
	call	_lua_setfield

; 113  : 	Method(IsEnemyCity);

	push	0
	push	OFFSET ?lIsEnemyCity@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsEnemyCity
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220481
	push	edi
	push	esi
	call	_lua_setfield

; 114  : 	Method(IsBeingWorked);

	push	0
	push	OFFSET ?lIsBeingWorked@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsBeingWorked
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220482
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 115  : 
; 116  : 	Method(IsUnit);

	push	0
	push	OFFSET ?lIsUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsUnit
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220483
	push	edi
	push	esi
	call	_lua_setfield

; 117  : 	Method(IsVisibleEnemyDefender);

	push	0
	push	OFFSET ?lIsVisibleEnemyDefender@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleEnemyDefender
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220484
	push	edi
	push	esi
	call	_lua_setfield

; 118  : 	Method(GetNumDefenders);

	push	0
	push	OFFSET ?lGetNumDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumDefenders
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220485
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 119  : 	Method(GetNumVisibleEnemyDefenders);

	push	0
	push	OFFSET ?lGetNumVisibleEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumVisibleEnemyDefenders
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220486
	push	edi
	push	esi
	call	_lua_setfield

; 120  : 	Method(GetNumVisiblePotentialEnemyDefenders);

	push	0
	push	OFFSET ?lGetNumVisiblePotentialEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumVisiblePotentialEnemyDefenders
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220487
	push	edi
	push	esi
	call	_lua_setfield

; 121  : 	Method(IsVisibleEnemyUnit);

	push	0
	push	OFFSET ?lIsVisibleEnemyUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleEnemyUnit
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220488
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 122  : 	Method(IsVisibleOtherUnit);

	push	0
	push	OFFSET ?lIsVisibleOtherUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleOtherUnit
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220489
	push	edi
	push	esi
	call	_lua_setfield

; 123  : 	Method(GetNumFriendlyUnitsOfType);

	push	0
	push	OFFSET ?lGetNumFriendlyUnitsOfType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumFriendlyUnitsOfType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220490
	push	edi
	push	esi
	call	_lua_setfield

; 124  : 	Method(IsFighting);

	push	0
	push	OFFSET ?lIsFighting@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsFighting
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220491
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 125  : 
; 126  : 	Method(IsRoute);

	push	0
	push	OFFSET ?lIsRoute@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRoute
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220492
	push	edi
	push	esi
	call	_lua_setfield

; 127  : 	Method(IsTradeRoute);

	push	0
	push	OFFSET ?lIsTradeRoute@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsTradeRoute
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220493
	push	edi
	push	esi
	call	_lua_setfield

; 128  : 
; 129  : 	Method(IsValidDomainForLocation);

	push	0
	push	OFFSET ?lIsValidDomainForLocation@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsValidDomainForLocation
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220494
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 130  : 	Method(IsValidDomainForAction);

	push	0
	push	OFFSET ?lIsValidDomainForAction@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsValidDomainForAction
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220495
	push	edi
	push	esi
	call	_lua_setfield

; 131  : 	Method(IsImpassable);

	push	0
	push	OFFSET ?lIsImpassable@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsImpassable
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220496
	push	edi
	push	esi
	call	_lua_setfield

; 132  : 
; 133  : 	Method(GetX);

	push	0
	push	OFFSET ?lGetX@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetX
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220497
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 134  : 	Method(GetY);

	push	0
	push	OFFSET ?lGetY@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetY
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220498
	push	edi
	push	esi
	call	_lua_setfield

; 135  : 	Method(At);

	push	0
	push	OFFSET ?lAt@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lAt
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220499
	push	edi
	push	esi
	call	_lua_setfield

; 136  : 	Method(GetPlotIndex);

	push	0
	push	OFFSET ?lGetPlotIndex@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetPlotIndex
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220500
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 137  : 	Method(GetLatitude);

	push	0
	push	OFFSET ?lGetLatitude@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetLatitude
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220501
	push	edi
	push	esi
	call	_lua_setfield

; 138  : 	Method(Area);

	push	0
	push	OFFSET ?lArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lArea
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220502
	push	edi
	push	esi
	call	_lua_setfield

; 139  : 	Method(WaterArea);

	push	0
	push	OFFSET ?lWaterArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lWaterArea
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220503
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 140  : 	Method(GetArea);

	push	0
	push	OFFSET ?lGetArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArea
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220504
	push	edi
	push	esi
	call	_lua_setfield

; 141  : 	Method(SetArea);

	push	0
	push	OFFSET ?lSetArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetArea
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220505
	push	edi
	push	esi
	call	_lua_setfield

; 142  : 	Method(GetFeatureVariety);

	push	0
	push	OFFSET ?lGetFeatureVariety@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetFeatureVariety
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220506
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 143  : 
; 144  : 	Method(GetOwnershipDuration);

	push	0
	push	OFFSET ?lGetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetOwnershipDuration
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220507
	push	edi
	push	esi
	call	_lua_setfield

; 145  : 	Method(IsOwnershipScore);

	push	0
	push	OFFSET ?lIsOwnershipScore@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsOwnershipScore
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220508
	push	edi
	push	esi
	call	_lua_setfield

; 146  : 	Method(SetOwnershipDuration);

	push	0
	push	OFFSET ?lSetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetOwnershipDuration
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220509
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 147  : 	Method(ChangeOwnershipDuration);

	push	0
	push	OFFSET ?lChangeOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeOwnershipDuration
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220510
	push	edi
	push	esi
	call	_lua_setfield

; 148  : 
; 149  : 	Method(GetImprovementDuration);

	push	0
	push	OFFSET ?lGetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetImprovementDuration
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220511
	push	edi
	push	esi
	call	_lua_setfield

; 150  : 	Method(SetImprovementDuration);

	push	0
	push	OFFSET ?lSetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetImprovementDuration
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220512
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 151  : 	Method(ChangeImprovementDuration);

	push	0
	push	OFFSET ?lChangeImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeImprovementDuration
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220513
	push	edi
	push	esi
	call	_lua_setfield

; 152  : 
; 153  : 	Method(GetUpgradeProgress);

	push	0
	push	OFFSET ?lGetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetUpgradeProgress
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220514
	push	edi
	push	esi
	call	_lua_setfield

; 154  : 	Method(GetUpgradeTimeLeft);

	push	0
	push	OFFSET ?lGetUpgradeTimeLeft@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetUpgradeTimeLeft
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220515
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 155  : 
; 156  : 	Method(SetUpgradeProgress);

	push	0
	push	OFFSET ?lSetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetUpgradeProgress
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220516
	push	edi
	push	esi
	call	_lua_setfield

; 157  : 	Method(ChangeUpgradeProgress);

	push	0
	push	OFFSET ?lChangeUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeUpgradeProgress
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220517
	push	edi
	push	esi
	call	_lua_setfield

; 158  : 
; 159  : 	Method(GetCityRadiusCount);

	push	0
	push	OFFSET ?lGetCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetCityRadiusCount
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220518
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 160  : 	Method(IsCityRadius);

	push	0
	push	OFFSET ?lIsCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsCityRadius
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220519
	push	edi
	push	esi
	call	_lua_setfield

; 161  : 
; 162  : 	Method(IsStartingPlot);

	push	0
	push	OFFSET ?lIsStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsStartingPlot
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220520
	push	edi
	push	esi
	call	_lua_setfield

; 163  : 	Method(SetStartingPlot);

	push	0
	push	OFFSET ?lSetStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetStartingPlot
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220521
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 164  : 	Method(IsNEOfRiver);

	push	0
	push	OFFSET ?lIsNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsNEOfRiver
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220522
	push	edi
	push	esi
	call	_lua_setfield

; 165  : 	Method(SetNEOfRiver);

	push	0
	push	OFFSET ?lSetNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetNEOfRiver
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220523
	push	edi
	push	esi
	call	_lua_setfield

; 166  : 	Method(IsWOfRiver);

	push	0
	push	OFFSET ?lIsWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsWOfRiver
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220524
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 167  : 	Method(SetWOfRiver);

	push	0
	push	OFFSET ?lSetWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetWOfRiver
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220525
	push	edi
	push	esi
	call	_lua_setfield

; 168  : 	Method(IsNWOfRiver);

	push	0
	push	OFFSET ?lIsNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsNWOfRiver
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220526
	push	edi
	push	esi
	call	_lua_setfield

; 169  : 	Method(SetNWOfRiver);

	push	0
	push	OFFSET ?lSetNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetNWOfRiver
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220527
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 170  : 	Method(GetRiverEFlowDirection);

	push	0
	push	OFFSET ?lGetRiverEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverEFlowDirection
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220528
	push	edi
	push	esi
	call	_lua_setfield

; 171  : 	Method(GetRiverSEFlowDirection);

	push	0
	push	OFFSET ?lGetRiverSEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverSEFlowDirection
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220529
	push	edi
	push	esi
	call	_lua_setfield

; 172  : 	Method(GetRiverSWFlowDirection);

	push	0
	push	OFFSET ?lGetRiverSWFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverSWFlowDirection
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220530
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 173  : 
; 174  : 	Method(IsPotentialCityWork);

	push	0
	push	OFFSET ?lIsPotentialCityWork@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsPotentialCityWork
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220531
	push	edi
	push	esi
	call	_lua_setfield

; 175  : 	Method(IsPotentialCityWorkForArea);

	push	0
	push	OFFSET ?lIsPotentialCityWorkForArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsPotentialCityWorkForArea
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220532
	push	edi
	push	esi
	call	_lua_setfield

; 176  : 
; 177  : 	Method(GetOwner);

	push	0
	push	OFFSET ?lGetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetOwner
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220533
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 178  : 	Method(SetOwner);

	push	0
	push	OFFSET ?lSetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetOwner
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220534
	push	edi
	push	esi
	call	_lua_setfield

; 179  : 	Method(GetPlotType);

	push	0
	push	OFFSET ?lGetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetPlotType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220535
	push	edi
	push	esi
	call	_lua_setfield

; 180  : 	Method(IsFlatlands);

	push	0
	push	OFFSET ?lIsFlatlands@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsFlatlands
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220536
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 181  : 	Method(IsHills);

	push	0
	push	OFFSET ?lIsHills@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsHills
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220537
	push	edi
	push	esi
	call	_lua_setfield

; 182  : 	Method(IsOpenGround);

	push	0
	push	OFFSET ?lIsOpenGround@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsOpenGround
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220538
	push	edi
	push	esi
	call	_lua_setfield

; 183  : 	Method(IsRoughGround);

	push	0
	push	OFFSET ?lIsRoughGround@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRoughGround
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220539
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 184  : 	Method(IsMountain);

	push	0
	push	OFFSET ?lIsMountain@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsMountain
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220540
	push	edi
	push	esi
	call	_lua_setfield

; 185  : 
; 186  : 	Method(SetPlotType);

	push	0
	push	OFFSET ?lSetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetPlotType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220541
	push	edi
	push	esi
	call	_lua_setfield

; 187  : 	Method(GetResourceType);

	push	0
	push	OFFSET ?lGetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetResourceType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220542
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 188  : 	Method(GetNonObsoleteResourceType);

	push	0
	push	OFFSET ?lGetNonObsoleteResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNonObsoleteResourceType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220543
	push	edi
	push	esi
	call	_lua_setfield

; 189  : 	Method(SetResourceType);

	push	0
	push	OFFSET ?lSetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetResourceType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220544
	push	edi
	push	esi
	call	_lua_setfield

; 190  : 	Method(GetNumResource);

	push	0
	push	OFFSET ?lGetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumResource
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220545
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 191  : 	Method(SetNumResource);

	push	0
	push	OFFSET ?lSetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetNumResource
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220546
	push	edi
	push	esi
	call	_lua_setfield

; 192  : 	Method(ChangeNumResource);

	push	0
	push	OFFSET ?lChangeNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeNumResource
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220547
	push	edi
	push	esi
	call	_lua_setfield

; 193  : 
; 194  : 	Method(GetImprovementType);

	push	0
	push	OFFSET ?lGetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetImprovementType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220548
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 195  : 	Method(SetImprovementType);

	push	0
	push	OFFSET ?lSetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetImprovementType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220549
	push	edi
	push	esi
	call	_lua_setfield

; 196  : 	Method(SetImprovementPillaged);

	push	0
	push	OFFSET ?lSetImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetImprovementPillaged
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220550
	push	edi
	push	esi
	call	_lua_setfield

; 197  : 	Method(GetRouteType);

	push	0
	push	OFFSET ?lGetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRouteType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220551
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 198  : 	Method(SetRouteType);

	push	0
	push	OFFSET ?lSetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetRouteType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220552
	push	edi
	push	esi
	call	_lua_setfield

; 199  : 	Method(IsRoutePillaged);

	push	0
	push	OFFSET ?lIsRoutePillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRoutePillaged
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220553
	push	edi
	push	esi
	call	_lua_setfield

; 200  : 
; 201  : 	Method(GetPlotCity);

	push	0
	push	OFFSET ?lGetPlotCity@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetPlotCity
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220554
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 202  : 	Method(GetWorkingCity);

	push	0
	push	OFFSET ?lGetWorkingCity@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetWorkingCity
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220555
	push	edi
	push	esi
	call	_lua_setfield

; 203  : 	Method(GetWorkingCityOverride);

	push	0
	push	OFFSET ?lGetWorkingCityOverride@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetWorkingCityOverride
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220556
	push	edi
	push	esi
	call	_lua_setfield

; 204  : 	Method(GetReconCount);

	push	0
	push	OFFSET ?lGetReconCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetReconCount
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220557
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 205  : 	Method(GetRiverCrossingCount);

	push	0
	push	OFFSET ?lGetRiverCrossingCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverCrossingCount
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220558
	push	edi
	push	esi
	call	_lua_setfield

; 206  : 	Method(GetYield);

	push	0
	push	OFFSET ?lGetYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetYield
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220559
	push	edi
	push	esi
	call	_lua_setfield

; 207  : 	Method(CalculateNatureYield);

	push	0
	push	OFFSET ?lCalculateNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateNatureYield
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220560
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 208  : 	Method(CalculateBestNatureYield);

	push	0
	push	OFFSET ?lCalculateBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateBestNatureYield
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220561
	push	edi
	push	esi
	call	_lua_setfield

; 209  : 	Method(CalculateTotalBestNatureYield);

	push	0
	push	OFFSET ?lCalculateTotalBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateTotalBestNatureYield
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220562
	push	edi
	push	esi
	call	_lua_setfield

; 210  : 	Method(CalculateImprovementYieldChange);

	push	0
	push	OFFSET ?lCalculateImprovementYieldChange@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateImprovementYieldChange
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220563
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 211  : 	Method(CalculateYield);

	push	0
	push	OFFSET ?lCalculateYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateYield
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220564
	push	edi
	push	esi
	call	_lua_setfield

; 212  : 	Method(HasYield);

	push	0
	push	OFFSET ?lHasYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lHasYield
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220565
	push	edi
	push	esi
	call	_lua_setfield

; 213  : 	Method(GetYieldWithBuild);

	push	0
	push	OFFSET ?lGetYieldWithBuild@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetYieldWithBuild
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220566
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 214  : 
; 215  : 	Method(CountNumAirUnits);

	push	0
	push	OFFSET ?lCountNumAirUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCountNumAirUnits
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220567
	push	edi
	push	esi
	call	_lua_setfield

; 216  : 
; 217  : 	Method(GetFoundValue);

	push	0
	push	OFFSET ?lGetFoundValue@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetFoundValue
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220568
	push	edi
	push	esi
	call	_lua_setfield

; 218  : 	Method(IsBestAdjacentFound);

	push	0
	push	OFFSET ?lIsBestAdjacentFound@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsBestAdjacentFound
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220569
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 219  : 
; 220  : 	Method(GetPlayerCityRadiusCount);

	push	0
	push	OFFSET ?lGetPlayerCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetPlayerCityRadiusCount
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220570
	push	edi
	push	esi
	call	_lua_setfield

; 221  : 	Method(IsPlayerCityRadius);

	push	0
	push	OFFSET ?lIsPlayerCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsPlayerCityRadius
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220571
	push	edi
	push	esi
	call	_lua_setfield

; 222  : 
; 223  : 	Method(GetVisibilityCount);

	push	0
	push	OFFSET ?lGetVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetVisibilityCount
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220572
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 224  : 	Method(ChangeVisibilityCount);

	push	0
	push	OFFSET ?lChangeVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeVisibilityCount
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220573
	push	edi
	push	esi
	call	_lua_setfield

; 225  : 
; 226  : 	Method(GetRevealedOwner);

	push	0
	push	OFFSET ?lGetRevealedOwner@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedOwner
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220574
	push	edi
	push	esi
	call	_lua_setfield

; 227  : 	Method(GetRevealedTeam);

	push	0
	push	OFFSET ?lGetRevealedTeam@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedTeam
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220575
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 228  : 
; 229  : 	Method(IsRiverCrossing);

	push	0
	push	OFFSET ?lIsRiverCrossing@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverCrossing
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220576
	push	edi
	push	esi
	call	_lua_setfield

; 230  : 	Method(IsRiverCrossingToPlot);

	push	0
	push	OFFSET ?lIsRiverCrossingToPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverCrossingToPlot
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220577
	push	edi
	push	esi
	call	_lua_setfield

; 231  : 
; 232  : 	Method(IsRevealed);

	push	0
	push	OFFSET ?lIsRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRevealed
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220578
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 233  : 	Method(SetRevealed);

	push	0
	push	OFFSET ?lSetRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetRevealed
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220579
	push	edi
	push	esi
	call	_lua_setfield

; 234  : 	Method(GetRevealedImprovementType);

	push	0
	push	OFFSET ?lGetRevealedImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedImprovementType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220580
	push	edi
	push	esi
	call	_lua_setfield

; 235  : 	Method(GetRevealedRouteType);

	push	0
	push	OFFSET ?lGetRevealedRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedRouteType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220581
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 236  : 	Method(GetBuildProgress);

	push	0
	push	OFFSET ?lGetBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBuildProgress
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220582
	push	edi
	push	esi
	call	_lua_setfield

; 237  : 	Method(ChangeBuildProgress);

	push	0
	push	OFFSET ?lChangeBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeBuildProgress
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220583
	push	edi
	push	esi
	call	_lua_setfield

; 238  : 
; 239  : 	Method(GetInvisibleVisibilityCount);

	push	0
	push	OFFSET ?lGetInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetInvisibleVisibilityCount
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220584
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 240  : 	Method(IsInvisibleVisible);

	push	0
	push	OFFSET ?lIsInvisibleVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsInvisibleVisible
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220585
	push	edi
	push	esi
	call	_lua_setfield

; 241  : 	Method(ChangeInvisibleVisibilityCount);

	push	0
	push	OFFSET ?lChangeInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeInvisibleVisibilityCount
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220586
	push	edi
	push	esi
	call	_lua_setfield

; 242  : 
; 243  : 	Method(GetNumUnits);

	push	0
	push	OFFSET ?lGetNumUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumUnits
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220587
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 244  : 	Method(GetUnit);

	push	0
	push	OFFSET ?lGetUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetUnit
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220588
	push	edi
	push	esi
	call	_lua_setfield

; 245  : 
; 246  : 	Method(GetNumLayerUnits);

	push	0
	push	OFFSET ?lGetNumLayerUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumLayerUnits
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220589
	push	edi
	push	esi
	call	_lua_setfield

; 247  : 	Method(GetLayerUnit);

	push	0
	push	OFFSET ?lGetLayerUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetLayerUnit
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220590
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 248  : 
; 249  : 	Method(GetScriptData);

	push	0
	push	OFFSET ?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetScriptData
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220591
	push	edi
	push	esi
	call	_lua_setfield

; 250  : 	Method(SetScriptData);

	push	0
	push	OFFSET ?lSetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetScriptData
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220592
	push	edi
	push	esi
	call	_lua_setfield

; 251  : 
; 252  : 	Method(GetActiveFogOfWarMode);

	push	0
	push	OFFSET ?lGetActiveFogOfWarMode@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetActiveFogOfWarMode
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220593
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 253  : 
; 254  : 	Method(IsImprovementPillaged);

	push	0
	push	OFFSET ?lIsImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsImprovementPillaged
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220594
	push	edi
	push	esi
	call	_lua_setfield

; 255  : 
; 256  : 	Method(CanSeePlot);

	push	0
	push	OFFSET ?lCanSeePlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCanSeePlot
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220595
	push	edi
	push	esi
	call	_lua_setfield

; 257  : 
; 258  : 	Method(GetContinentArtType);

	push	0
	push	OFFSET ?lGetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetContinentArtType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220596
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 259  : 	Method(SetContinentArtType);

	push	0
	push	OFFSET ?lSetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetContinentArtType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220597
	push	edi
	push	esi
	call	_lua_setfield

; 260  : 
; 261  : 	Method(IsResourceConnectedByImprovement);

	push	0
	push	OFFSET ?lIsResourceConnectedByImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsResourceConnectedByImprovement
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220598
	push	edi
	push	esi
	call	_lua_setfield

; 262  : 
; 263  : 	Method(IsBuildRemovesFeature);

	push	0
	push	OFFSET ?lIsBuildRemovesFeature@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsBuildRemovesFeature
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220599
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 264  : 
; 265  : 	Method(GetArchaeologyArtifactType);

	push	0
	push	OFFSET ?lGetArchaeologyArtifactType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactType
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220600
	push	edi
	push	esi
	call	_lua_setfield

; 266  : 	Method(GetArchaeologyArtifactEra);

	push	0
	push	OFFSET ?lGetArchaeologyArtifactEra@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactEra
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220601
	push	edi
	push	esi
	call	_lua_setfield

; 267  : 	Method(GetArchaeologyArtifactPlayer1);

	push	0
	push	OFFSET ?lGetArchaeologyArtifactPlayer1@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactPlayer1
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220602
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 268  : 	Method(GetArchaeologyArtifactPlayer2);

	push	0
	push	OFFSET ?lGetArchaeologyArtifactPlayer2@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactPlayer2
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220603
	push	edi
	push	esi
	call	_lua_setfield

; 269  : 	Method(GetArchaeologyArtifactWork);

	push	0
	push	OFFSET ?lGetArchaeologyArtifactWork@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactWork
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220604
	push	edi
	push	esi
	call	_lua_setfield

; 270  : 	Method(HasWrittenArtifact);

	push	0
	push	OFFSET ?lHasWrittenArtifact@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lHasWrittenArtifact
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220605
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 271  : 
; 272  : 	Method(GetCityPurchaseID);

	push	0
	push	OFFSET ?lGetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetCityPurchaseID
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220606
	push	edi
	push	esi
	call	_lua_setfield

; 273  : 	Method(SetCityPurchaseID);

	push	0
	push	OFFSET ?lSetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetCityPurchaseID
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG220607
	push	edi
	push	esi
	call	_lua_setfield
	add	esp, 48					; 00000030H
	pop	edi
	pop	esi

; 274  : }

	ret	0
?PushMethods@CvLuaPlot@@SAXPAUlua_State@@H@Z ENDP	; CvLuaPlot::PushMethods
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\lua\cvluascopedinstance.h
_TEXT	ENDS
;	COMDAT ?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_pkType$ = 12						; size = 4
?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z PROC ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push, COMDAT

; 39   : {

	push	edi

; 40   : 	//Pushing an instance involves more than just actually pushing a pointer into the
; 41   : 	//Lua stack.  There are some caching optimizations that are done as well as some
; 42   : 	//checks.
; 43   : 	//The first step is to load or create a global table <Typename> to store all member
; 44   : 	//methods and all pushed instances.  This conserves memory and offers faster pushing
; 45   : 	//speed.
; 46   : 	//If <Typename>.__instances[pkType] is not nil, return that value.
; 47   : 	//otherwise push a new instance and assign it to __instances.
; 48   : 
; 49   : 	//NOTE: Raw gets and sets are used as an optimization over using lua_[get,set]field
; 50   : 	if(pkType)

	mov	edi, DWORD PTR _pkType$[esp]
	test	edi, edi
	je	$LN4@Push@4
	push	ebx
	push	ebp
	push	esi

; 51   : 	{
; 52   : 		//const int t = lua_gettop(L);
; 53   : 
; 54   : 		lua_getglobal(L, Derived::GetTypeName());

	mov	esi, DWORD PTR _L$[esp+12]
	push	OFFSET $SG220613
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_getfield

; 55   : 		if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN11@Push@4

; 56   : 		{
; 57   : 			//Typename wasn't found, time to build it.
; 58   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 59   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 60   : 
; 61   : 			//Create weak __instances table.
; 62   : 			lua_pushstring(L, "__instances");

	push	OFFSET $SG222990
	push	esi
	call	_lua_pushstring

; 63   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 64   : 
; 65   : 			//Create __instances.mt
; 66   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 67   : 			lua_pushstring(L, "__mode");

	push	OFFSET $SG222991
	push	esi
	call	_lua_pushstring

; 68   : 			lua_pushstring(L, "v");

	push	OFFSET $SG222992
	push	esi
	call	_lua_pushstring
	add	esp, 68					; 00000044H

; 69   : 			lua_rawset(L, -3);				// mt.__mode = "v";

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 70   : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_setmetatable

; 71   : 
; 72   : 			lua_rawset(L, -3);				//type.__instances = t;

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 73   : 
; 74   : 
; 75   : 			lua_pushvalue(L, -1);

	push	-1
	push	esi
	call	_lua_pushvalue

; 76   : 			lua_setglobal(L, Derived::GetTypeName());

	push	OFFSET $SG220613
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_setfield

; 77   : 
; 78   : 			Derived::PushMethods(L, lua_gettop(L));

	push	esi
	call	_lua_gettop
	push	eax
	push	esi
	call	?PushMethods@CvLuaPlot@@SAXPAUlua_State@@H@Z ; CvLuaPlot::PushMethods
	add	esp, 56					; 00000038H
$LN11@Push@4:

; 79   : 		}
; 80   : 		const int type_index = lua_gettop(L);

	push	esi
	call	_lua_gettop

; 81   : 
; 82   : 		lua_pushstring(L, "__instances");

	push	OFFSET $SG222994
	push	esi
	mov	ebx, eax
	call	_lua_pushstring

; 83   : 		lua_rawget(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_rawget

; 84   : 
; 85   : 		const int instances_index = lua_gettop(L);

	push	esi
	call	_lua_gettop

; 86   : 
; 87   : 		lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	mov	ebp, eax
	call	_lua_pushlightuserdata

; 88   : 
; 89   : 		lua_rawget(L, -2);					//retrieve type.__instances[pkType]

	push	-2					; fffffffeH
	push	esi
	call	_lua_rawget

; 90   : 
; 91   : 		if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 48					; 00000030H
	test	eax, eax
	jne	SHORT $LN2@Push@4

; 92   : 		{
; 93   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 94   : 
; 95   : 			//Push new instance
; 96   : 			lua_createtable(L, 0, 1);

	push	1
	push	0
	push	esi
	call	_lua_createtable

; 97   : 			lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	call	_lua_pushlightuserdata

; 98   : 			lua_setfield(L, -2, "__instance");

	push	OFFSET $SG222997
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 99   : 
; 100  : 			lua_createtable(L, 0, 1);			// create mt

	push	1
	push	0
	push	esi
	call	_lua_createtable

; 101  : 			lua_pushstring(L, "__index");

	push	OFFSET $SG222998
	push	esi
	call	_lua_pushstring

; 102  : 			lua_pushvalue(L, type_index);

	push	ebx
	push	esi
	call	_lua_pushvalue
	add	esp, 68					; 00000044H

; 103  : 			lua_rawset(L, -3);					// mt.__index = Type

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 104  : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_setmetatable

; 105  : 
; 106  : 			//Assign it in instances
; 107  : 			lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	call	_lua_pushlightuserdata

; 108  : 			lua_pushvalue(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_pushvalue

; 109  : 			lua_rawset(L, instances_index);				//__instances[pkType] = t;

	push	ebp
	push	esi
	call	_lua_rawset
	add	esp, 40					; 00000028H
$LN2@Push@4:

; 110  : 		}
; 111  : 
; 112  : 		//VERIFY(instances_index > type_index);
; 113  : 		lua_remove(L, instances_index);

	push	ebp
	push	esi
	call	_lua_remove

; 114  : 		lua_remove(L, type_index);

	push	ebx
	push	esi
	call	_lua_remove
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 122  : 	}
; 123  : }

	ret	0
$LN4@Push@4:

; 115  : 
; 116  : 		//const int dt = lua_gettop(L);
; 117  : 		//VERIFY(dt == t + 1)
; 118  : 	}
; 119  : 	else
; 120  : 	{
; 121  : 		lua_pushnil(L);

	mov	eax, DWORD PTR _L$[esp]
	push	eax
	call	_lua_pushnil
	add	esp, 4
	pop	edi

; 122  : 	}
; 123  : }

	ret	0
?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ENDP ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
_TEXT	ENDS
END
