; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvAStar.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG219413 DB	'.\CvAStar.cpp', 00H
	ORG $+2
$SG219419 DB	'.\CvAStar.cpp', 00H
	ORG $+2
$SG220533 DB	'Game Turn, Player, Unit, From X, From Y, To X, To Y, Inf'
	DB	'o, Checksum', 00H
$SG220534 DB	'AStar_GC.log', 00H
	ORG $+3
$SG220535 DB	'AStar_APP.log', 00H
	ORG $+2
$SG220536 DB	'?', 00H
	ORG $+2
$SG220537 DB	'%03d, %s, UnitID: %d, ', 00H
	ORG $+1
$SG220559 DB	'%d, %d, %d, %d, %d, %8x', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	??0CvAStar@@QAE@XZ				; CvAStar::CvAStar
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
;	COMDAT ??0CvAStar@@QAE@XZ
_TEXT	SEGMENT
??0CvAStar@@QAE@XZ PROC					; CvAStar::CvAStar, COMDAT
; _this$ = ecx

; 103  : {

	mov	eax, ecx

; 104  : 	udIsPathDest = NULL;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 105  : 	udDestValid = NULL;

	mov	DWORD PTR [eax+4], ecx

; 106  : 	udHeuristic = NULL;

	mov	DWORD PTR [eax+8], ecx

; 107  : 	udCost = NULL;

	mov	DWORD PTR [eax+12], ecx

; 108  : 	udValid = NULL;

	mov	DWORD PTR [eax+16], ecx

; 109  : 	udNotifyChild = NULL;

	mov	DWORD PTR [eax+20], ecx

; 110  : 	udNotifyList = NULL;

	mov	DWORD PTR [eax+24], ecx

; 111  : 	udNumExtraChildrenFunc = NULL;

	mov	DWORD PTR [eax+28], ecx

; 112  : 	udGetExtraChildFunc = NULL;

	mov	DWORD PTR [eax+32], ecx

; 113  : 	udInitializeFunc = NULL;

	mov	DWORD PTR [eax+36], ecx

; 114  : 	udUninitializeFunc = NULL;

	mov	DWORD PTR [eax+40], ecx

; 115  : 
; 116  : 	m_pData = NULL;

	mov	DWORD PTR [eax+44], ecx

; 117  : 
; 118  : 	m_pOpen = NULL;

	mov	DWORD PTR [eax+84], ecx

; 119  : 	m_pOpenTail = NULL;

	mov	DWORD PTR [eax+88], ecx

; 120  : 	m_pClosed = NULL;

	mov	DWORD PTR [eax+92], ecx

; 121  : 	m_pBest = NULL;

	mov	DWORD PTR [eax+96], ecx

; 122  : 	m_pStackHead = NULL;

	mov	DWORD PTR [eax+100], ecx

; 123  : 
; 124  : 	m_ppaaNodes = NULL;

	mov	DWORD PTR [eax+104], ecx

; 125  : 
; 126  : 	m_bIsMPCacheSafe = false;

	mov	BYTE PTR [eax+79], cl

; 127  : 	m_bDataChangeInvalidatesCache = false;

	mov	BYTE PTR [eax+80], cl

; 128  : #ifdef AUI_WARNING_FIXES
; 129  : #ifdef AUI_ASTAR_TURN_LIMITER
; 130  : 	m_iMaxTurns = 0;
; 131  : #endif
; 132  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 133  : 	m_bIsMultiplayer = false;
; 134  : #endif
; 135  : #endif
; 136  : }

	ret	0
??0CvAStar@@QAE@XZ ENDP					; CvAStar::CvAStar
_TEXT	ENDS
PUBLIC	?DeInit@CvAStar@@QAEXXZ				; CvAStar::DeInit
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?DeInit@CvAStar@@QAEXXZ
_TEXT	SEGMENT
?DeInit@CvAStar@@QAEXXZ PROC				; CvAStar::DeInit, COMDAT
; _this$ = ecx

; 148  : {

	push	esi
	mov	esi, ecx

; 149  : 	if(m_ppaaNodes != NULL)

	cmp	DWORD PTR [esi+104], 0
	je	SHORT $LN4@DeInit
	push	edi

; 150  : 	{
; 151  : 		for(int iI = 0; iI < m_iColumns; iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+48], edi
	jle	SHORT $LN1@DeInit
$LL3@DeInit:

; 152  : 		{
; 153  : #ifdef AUI_ASTAR_REMOVE_MALLOC
; 154  : 			SAFE_DELETE_ARRAY(m_ppaaNodes[iI]);
; 155  : 		}
; 156  : 
; 157  : 		SAFE_DELETE_ARRAY(m_ppaaNodes);
; 158  : #else
; 159  : 			FFREEALIGNED(m_ppaaNodes[iI]);

	mov	eax, DWORD PTR [esi+104]
	mov	ecx, DWORD PTR [eax+edi*4]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	inc	edi
	add	esp, 4
	cmp	edi, DWORD PTR [esi+48]
	jl	SHORT $LL3@DeInit
$LN1@DeInit:

; 160  : 		}
; 161  : 
; 162  : 		FFREEALIGNED(m_ppaaNodes);

	mov	edx, DWORD PTR [esi+104]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 163  : 		m_ppaaNodes=0;

	mov	DWORD PTR [esi+104], 0
	pop	edi
$LN4@DeInit:
	pop	esi

; 164  : #endif
; 165  : 	}
; 166  : }

	ret	0
?DeInit@CvAStar@@QAEXXZ ENDP				; CvAStar::DeInit
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?UpdateOpenNode@CvAStar@@IAEXPAVCvAStarNode@@@Z	; CvAStar::UpdateOpenNode
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
;	COMDAT ?UpdateOpenNode@CvAStar@@IAEXPAVCvAStarNode@@@Z
_TEXT	SEGMENT
_node$ = 8						; size = 4
?UpdateOpenNode@CvAStar@@IAEXPAVCvAStarNode@@@Z PROC	; CvAStar::UpdateOpenNode, COMDAT
; _this$ = ecx

; 852  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 853  : 	CvAStarNode* temp = node->m_pPrev;
; 854  : #else
; 855  : 	CvAStarNode* temp;
; 856  : #endif
; 857  : 
; 858  : 	FAssert(node->m_eCvAStarListType == CVASTARLIST_OPEN);
; 859  : 
; 860  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 861  : 	if (temp && (node->m_iTotalCost < temp->m_iTotalCost))
; 862  : 	{
; 863  : 		// have node free float for now
; 864  : 		temp->m_pNext = node->m_pNext;
; 865  : 		if (node->m_pNext)
; 866  : 		{
; 867  : 			node->m_pNext->m_pPrev = temp;
; 868  : 		}
; 869  : 		else
; 870  : 		{
; 871  : 			m_pOpenTail = temp;
; 872  : 		}
; 873  : #else
; 874  : 	if((node->m_pPrev != NULL) && (node->m_iTotalCost < node->m_pPrev->m_iTotalCost))

	mov	eax, DWORD PTR _node$[esp-4]
	mov	edx, DWORD PTR [eax+32]
	test	edx, edx
	je	SHORT $LN2@UpdateOpen
	push	esi
	mov	esi, DWORD PTR [eax]
	cmp	esi, DWORD PTR [edx]
	jge	SHORT $LN14@UpdateOpen

; 875  : 	{
; 876  : 		// have node free float for now
; 877  : 		node->m_pPrev->m_pNext = node->m_pNext;

	mov	esi, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+28], esi

; 878  : 		if(node->m_pNext)

	mov	edx, DWORD PTR [eax+28]
	test	edx, edx
	je	SHORT $LN8@UpdateOpen

; 879  : 		{
; 880  : 			node->m_pNext->m_pPrev = node->m_pPrev;

	mov	esi, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], esi

; 881  : 		}
; 882  : 		else

	jmp	SHORT $LN7@UpdateOpen
$LN8@UpdateOpen:

; 883  : 		{
; 884  : 			m_pOpenTail = node->m_pPrev;

	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR [ecx+88], edx
$LN7@UpdateOpen:

; 885  : 		}
; 886  : #endif
; 887  : 		// scoot down the list till we find where node goes (without connecting up as we go)
; 888  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 889  : 		temp = node->m_pPrev;

	mov	edx, DWORD PTR [eax+32]

; 890  : #endif
; 891  : 		while((temp != NULL) && (node->m_iTotalCost < temp->m_iTotalCost))

	test	edx, edx
	je	SHORT $LN4@UpdateOpen
	mov	esi, DWORD PTR [eax]
$LL6@UpdateOpen:
	cmp	esi, DWORD PTR [edx]
	jge	SHORT $LN5@UpdateOpen

; 892  : 		{
; 893  : 			temp = temp->m_pPrev;

	mov	edx, DWORD PTR [edx+32]
	test	edx, edx
	jne	SHORT $LL6@UpdateOpen
$LN4@UpdateOpen:

; 905  : 		}
; 906  : 		else
; 907  : 		{
; 908  : 			node->m_pNext = m_pOpen;

	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+28], edx

; 909  : 			node->m_pPrev = NULL;

	mov	DWORD PTR [eax+32], 0

; 910  : 			if(node->m_pNext)

	test	edx, edx
	je	SHORT $LN1@UpdateOpen

; 911  : 			{
; 912  : 				node->m_pNext->m_pPrev = node;

	mov	DWORD PTR [edx+32], eax
$LN1@UpdateOpen:

; 913  : 			}
; 914  : 			m_pOpen = node;

	mov	DWORD PTR [ecx+84], eax
$LN14@UpdateOpen:
	pop	esi
$LN2@UpdateOpen:

; 915  : 		}
; 916  : 	}
; 917  : }

	ret	4
$LN5@UpdateOpen:

; 894  : 		}
; 895  : 		// connect node up
; 896  : 		if(temp != NULL)
; 897  : 		{
; 898  : 			node->m_pNext = temp->m_pNext;

	mov	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR [eax+28], ecx

; 899  : 			node->m_pPrev = temp;

	mov	DWORD PTR [eax+32], edx

; 900  : 			if(temp->m_pNext)

	mov	ecx, DWORD PTR [edx+28]
	test	ecx, ecx
	je	SHORT $LN3@UpdateOpen

; 901  : 			{
; 902  : 				temp->m_pNext->m_pPrev = node;

	mov	DWORD PTR [ecx+32], eax
$LN3@UpdateOpen:

; 903  : 			}
; 904  : 			temp->m_pNext = node;

	mov	DWORD PTR [edx+28], eax
	pop	esi

; 915  : 		}
; 916  : 	}
; 917  : }

	ret	4
?UpdateOpenNode@CvAStar@@IAEXPAVCvAStarNode@@@Z ENDP	; CvAStar::UpdateOpenNode
_TEXT	ENDS
PUBLIC	?Push@CvAStar@@IAEXPAVCvAStarNode@@@Z		; CvAStar::Push
; Function compile flags: /Ogtpy
;	COMDAT ?Push@CvAStar@@IAEXPAVCvAStarNode@@@Z
_TEXT	SEGMENT
_node$ = 8						; size = 4
?Push@CvAStar@@IAEXPAVCvAStarNode@@@Z PROC		; CvAStar::Push, COMDAT
; _this$ = ecx

; 985  : 	if(node->m_bOnStack)

	mov	eax, DWORD PTR _node$[esp-4]
	cmp	BYTE PTR [eax+86], 0
	jne	SHORT $LN4@Push

; 986  : 	{
; 987  : 		return;
; 988  : 	}
; 989  : 
; 990  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 991  : 	if(m_pStackHead == NULL)

	mov	edx, DWORD PTR [ecx+100]
	test	edx, edx
	jne	SHORT $LN2@Push

; 992  : 	{
; 993  : 		m_pStackHead = &(m_ppaaNodes[node->m_iX][node->m_iY]);

	movsx	edx, WORD PTR [eax+82]
	push	esi
	movsx	esi, WORD PTR [eax+80]
	push	edi
	mov	edi, DWORD PTR [ecx+104]
	lea	edx, DWORD PTR [edx+edx*2]
	shl	edx, 5
	add	edx, DWORD PTR [edi+esi*4]
	pop	edi
	mov	DWORD PTR [ecx+100], edx
	pop	esi

; 1001 : 	}
; 1002 : 
; 1003 : 	node->m_bOnStack = true;

	mov	BYTE PTR [eax+86], 1

; 1004 : }

	ret	4
$LN2@Push:

; 994  : 	}
; 995  : 	else
; 996  : #endif
; 997  : 	{
; 998  : 		FAssert(node->m_pStack == NULL);
; 999  : 		node->m_pStack = m_pStackHead;

	mov	DWORD PTR [eax+36], edx

; 1000 : 		m_pStackHead = node;

	mov	DWORD PTR [ecx+100], eax

; 1001 : 	}
; 1002 : 
; 1003 : 	node->m_bOnStack = true;

	mov	BYTE PTR [eax+86], 1
$LN4@Push:

; 1004 : }

	ret	4
?Push@CvAStar@@IAEXPAVCvAStarNode@@@Z ENDP		; CvAStar::Push
_TEXT	ENDS
PUBLIC	?Pop@CvAStar@@IAEPAVCvAStarNode@@XZ		; CvAStar::Pop
; Function compile flags: /Ogtpy
;	COMDAT ?Pop@CvAStar@@IAEPAVCvAStarNode@@XZ
_TEXT	SEGMENT
?Pop@CvAStar@@IAEPAVCvAStarNode@@XZ PROC		; CvAStar::Pop, COMDAT
; _this$ = ecx

; 1010 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 1011 : 	CvAStarNode* node;
; 1012 : #endif
; 1013 : 
; 1014 : 	if(m_pStackHead == NULL)

	mov	eax, DWORD PTR [ecx+100]
	xor	edx, edx
	cmp	eax, edx
	jne	SHORT $LN1@Pop

; 1015 : 	{
; 1016 : 		return NULL;

	xor	eax, eax

; 1028 : 
; 1029 : 	return node;
; 1030 : }

	ret	0
$LN1@Pop:
	push	esi

; 1017 : 	}
; 1018 : 
; 1019 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1020 : 	CvAStarNode* node = m_pStackHead;
; 1021 : #else
; 1022 : 	node = m_pStackHead;
; 1023 : #endif
; 1024 : 	m_pStackHead = m_pStackHead->m_pStack;

	mov	esi, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+100], esi

; 1025 : 	node->m_pStack = NULL;

	mov	DWORD PTR [eax+36], edx

; 1026 : 
; 1027 : 	node->m_bOnStack = false;

	mov	BYTE PTR [eax+86], dl
	pop	esi

; 1028 : 
; 1029 : 	return node;
; 1030 : }

	ret	0
?Pop@CvAStar@@IAEPAVCvAStarNode@@XZ ENDP		; CvAStar::Pop
_TEXT	ENDS
PUBLIC	?baseMoves@UnitPathCacheData@@QBEHW4DomainTypes@@@Z ; UnitPathCacheData::baseMoves
; Function compile flags: /Ogtpy
;	COMDAT ?baseMoves@UnitPathCacheData@@QBEHW4DomainTypes@@@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
?baseMoves@UnitPathCacheData@@QBEHW4DomainTypes@@@Z PROC ; UnitPathCacheData::baseMoves, COMDAT
; _this$ = ecx

; 1051 : 	inline int baseMoves(DomainTypes eType) const { return m_aBaseMoves[eType]; }

	mov	eax, DWORD PTR _eType$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4]
	ret	4
?baseMoves@UnitPathCacheData@@QBEHW4DomainTypes@@@Z ENDP ; UnitPathCacheData::baseMoves
_TEXT	ENDS
PUBLIC	?maxMoves@UnitPathCacheData@@QBEHXZ		; UnitPathCacheData::maxMoves
; Function compile flags: /Ogtpy
;	COMDAT ?maxMoves@UnitPathCacheData@@QBEHXZ
_TEXT	SEGMENT
?maxMoves@UnitPathCacheData@@QBEHXZ PROC		; UnitPathCacheData::maxMoves, COMDAT
; _this$ = ecx

; 1052 : 	inline int maxMoves() const { return m_iMaxMoves; }

	mov	eax, DWORD PTR [ecx+20]
	ret	0
?maxMoves@UnitPathCacheData@@QBEHXZ ENDP		; UnitPathCacheData::maxMoves
_TEXT	ENDS
PUBLIC	?getOwner@UnitPathCacheData@@QBE?AW4PlayerTypes@@XZ ; UnitPathCacheData::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@UnitPathCacheData@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@UnitPathCacheData@@QBE?AW4PlayerTypes@@XZ PROC ; UnitPathCacheData::getOwner, COMDAT
; _this$ = ecx

; 1053 : 	inline PlayerTypes getOwner() const { return m_ePlayerID; }

	mov	eax, DWORD PTR [ecx+24]
	ret	0
?getOwner@UnitPathCacheData@@QBE?AW4PlayerTypes@@XZ ENDP ; UnitPathCacheData::getOwner
_TEXT	ENDS
PUBLIC	?getTeam@UnitPathCacheData@@QBE?AW4TeamTypes@@XZ ; UnitPathCacheData::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@UnitPathCacheData@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@UnitPathCacheData@@QBE?AW4TeamTypes@@XZ PROC	; UnitPathCacheData::getTeam, COMDAT
; _this$ = ecx

; 1054 : 	inline TeamTypes getTeam() const { return m_eTeamID; }

	mov	eax, DWORD PTR [ecx+28]
	ret	0
?getTeam@UnitPathCacheData@@QBE?AW4TeamTypes@@XZ ENDP	; UnitPathCacheData::getTeam
_TEXT	ENDS
PUBLIC	?getDomainType@UnitPathCacheData@@QBE?AW4DomainTypes@@XZ ; UnitPathCacheData::getDomainType
; Function compile flags: /Ogtpy
;	COMDAT ?getDomainType@UnitPathCacheData@@QBE?AW4DomainTypes@@XZ
_TEXT	SEGMENT
?getDomainType@UnitPathCacheData@@QBE?AW4DomainTypes@@XZ PROC ; UnitPathCacheData::getDomainType, COMDAT
; _this$ = ecx

; 1055 : 	inline DomainTypes getDomainType() const { return m_eDomainType; }

	mov	eax, DWORD PTR [ecx+32]
	ret	0
?getDomainType@UnitPathCacheData@@QBE?AW4DomainTypes@@XZ ENDP ; UnitPathCacheData::getDomainType
_TEXT	ENDS
PUBLIC	?isHuman@UnitPathCacheData@@QBE_NXZ		; UnitPathCacheData::isHuman
; Function compile flags: /Ogtpy
;	COMDAT ?isHuman@UnitPathCacheData@@QBE_NXZ
_TEXT	SEGMENT
?isHuman@UnitPathCacheData@@QBE_NXZ PROC		; UnitPathCacheData::isHuman, COMDAT
; _this$ = ecx

; 1056 : 	inline bool isHuman() const { return m_bIsHuman; }

	mov	al, BYTE PTR [ecx+36]
	ret	0
?isHuman@UnitPathCacheData@@QBE_NXZ ENDP		; UnitPathCacheData::isHuman
_TEXT	ENDS
PUBLIC	?IsAutomated@UnitPathCacheData@@QBE_NXZ		; UnitPathCacheData::IsAutomated
; Function compile flags: /Ogtpy
;	COMDAT ?IsAutomated@UnitPathCacheData@@QBE_NXZ
_TEXT	SEGMENT
?IsAutomated@UnitPathCacheData@@QBE_NXZ PROC		; UnitPathCacheData::IsAutomated, COMDAT
; _this$ = ecx

; 1057 : 	inline bool IsAutomated() const { return m_bIsAutomated; }

	mov	al, BYTE PTR [ecx+37]
	ret	0
?IsAutomated@UnitPathCacheData@@QBE_NXZ ENDP		; UnitPathCacheData::IsAutomated
_TEXT	ENDS
PUBLIC	?IsImmobile@UnitPathCacheData@@QBE_NXZ		; UnitPathCacheData::IsImmobile
; Function compile flags: /Ogtpy
;	COMDAT ?IsImmobile@UnitPathCacheData@@QBE_NXZ
_TEXT	SEGMENT
?IsImmobile@UnitPathCacheData@@QBE_NXZ PROC		; UnitPathCacheData::IsImmobile, COMDAT
; _this$ = ecx

; 1058 : 	inline bool IsImmobile() const { return m_bIsImmobile; }

	mov	al, BYTE PTR [ecx+38]
	ret	0
?IsImmobile@UnitPathCacheData@@QBE_NXZ ENDP		; UnitPathCacheData::IsImmobile
_TEXT	ENDS
PUBLIC	?isNoRevealMap@UnitPathCacheData@@QBE_NXZ	; UnitPathCacheData::isNoRevealMap
; Function compile flags: /Ogtpy
;	COMDAT ?isNoRevealMap@UnitPathCacheData@@QBE_NXZ
_TEXT	SEGMENT
?isNoRevealMap@UnitPathCacheData@@QBE_NXZ PROC		; UnitPathCacheData::isNoRevealMap, COMDAT
; _this$ = ecx

; 1059 : 	inline bool isNoRevealMap() const { return m_bIsNoRevealMap; }

	mov	al, BYTE PTR [ecx+39]
	ret	0
?isNoRevealMap@UnitPathCacheData@@QBE_NXZ ENDP		; UnitPathCacheData::isNoRevealMap
_TEXT	ENDS
PUBLIC	?isEmbarked@UnitPathCacheData@@QBE_NXZ		; UnitPathCacheData::isEmbarked
; Function compile flags: /Ogtpy
;	COMDAT ?isEmbarked@UnitPathCacheData@@QBE_NXZ
_TEXT	SEGMENT
?isEmbarked@UnitPathCacheData@@QBE_NXZ PROC		; UnitPathCacheData::isEmbarked, COMDAT
; _this$ = ecx

; 1061 : 	inline bool isEmbarked() const { return m_bIsEmbarked; }

	mov	al, BYTE PTR [ecx+41]
	ret	0
?isEmbarked@UnitPathCacheData@@QBE_NXZ ENDP		; UnitPathCacheData::isEmbarked
_TEXT	ENDS
PUBLIC	?IsCanAttack@UnitPathCacheData@@QBE_NXZ		; UnitPathCacheData::IsCanAttack
; Function compile flags: /Ogtpy
;	COMDAT ?IsCanAttack@UnitPathCacheData@@QBE_NXZ
_TEXT	SEGMENT
?IsCanAttack@UnitPathCacheData@@QBE_NXZ PROC		; UnitPathCacheData::IsCanAttack, COMDAT
; _this$ = ecx

; 1062 : 	inline bool IsCanAttack() const { return m_bCanAttack; }

	mov	al, BYTE PTR [ecx+42]
	ret	0
?IsCanAttack@UnitPathCacheData@@QBE_NXZ ENDP		; UnitPathCacheData::IsCanAttack
_TEXT	ENDS
PUBLIC	?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z	; UnitPathUninitialize
; Function compile flags: /Ogtpy
;	COMDAT ?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_pointer$ = 8						; size = 4
_finder$ = 12						; size = 4
?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z PROC	; UnitPathUninitialize, COMDAT

; 1104 : 
; 1105 : }

	ret	0
?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z ENDP	; UnitPathUninitialize
_TEXT	ENDS
PUBLIC	?StepCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepCost
; Function compile flags: /Ogtpy
;	COMDAT ?StepCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?StepCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; StepCost, COMDAT

; 3124 : 	return 1;

	mov	eax, 1

; 3125 : }

	ret	0
?StepCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; StepCost
_TEXT	ENDS
PUBLIC	?StepAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepAdd
; Function compile flags: /Ogtpy
;	COMDAT ?StepAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?StepAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; StepAdd, COMDAT

; 3269 : 	if(data == ASNC_INITIALADD)

	cmp	DWORD PTR _data$[esp-4], 0

; 3270 : 	{
; 3271 : 		node->m_iData1 = 0;

	mov	eax, DWORD PTR _node$[esp-4]
	jne	SHORT $LN2@StepAdd
	mov	DWORD PTR [eax+12], 0

; 3276 : 	}
; 3277 : 
; 3278 : 	FAssertMsg(node->m_iData1 >= 0, "node->m_iData1 is expected to be non-negative (invalid Index)");
; 3279 : 
; 3280 : 	return 1;

	mov	eax, 1

; 3281 : }

	ret	0
$LN2@StepAdd:

; 3272 : 	}
; 3273 : 	else
; 3274 : 	{
; 3275 : 		node->m_iData1 = (parent->m_iData1 + 1);

	mov	ecx, DWORD PTR _parent$[esp-4]
	mov	edx, DWORD PTR [ecx+12]
	inc	edx
	mov	DWORD PTR [eax+12], edx

; 3276 : 	}
; 3277 : 
; 3278 : 	FAssertMsg(node->m_iData1 >= 0, "node->m_iData1 is expected to be non-negative (invalid Index)");
; 3279 : 
; 3280 : 	return 1;

	mov	eax, 1

; 3281 : }

	ret	0
?StepAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; StepAdd
_TEXT	ENDS
PUBLIC	?InfluenceAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; InfluenceAdd
; Function compile flags: /Ogtpy
;	COMDAT ?InfluenceAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?InfluenceAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; InfluenceAdd, COMDAT

; 3433 : 	if(data == ASNC_INITIALADD)

	cmp	DWORD PTR _data$[esp-4], 0

; 3434 : 	{
; 3435 : 		node->m_iData1 = 0;

	mov	eax, DWORD PTR _node$[esp-4]
	jne	SHORT $LN2@InfluenceA
	mov	DWORD PTR [eax+12], 0

; 3440 : 	}
; 3441 : 
; 3442 : 	FAssertMsg(node->m_iData1 >= 0, "node->m_iData1 is expected to be non-negative (invalid Index)");
; 3443 : 
; 3444 : 	return 1;

	mov	eax, 1

; 3445 : }

	ret	0
$LN2@InfluenceA:

; 3436 : 	}
; 3437 : 	else
; 3438 : 	{
; 3439 : 		node->m_iData1 = (parent->m_iData1 + 1/*influenceCost(parent,node,data,pointer,finder)*/);

	mov	ecx, DWORD PTR _parent$[esp-4]
	mov	edx, DWORD PTR [ecx+12]
	inc	edx
	mov	DWORD PTR [eax+12], edx

; 3440 : 	}
; 3441 : 
; 3442 : 	FAssertMsg(node->m_iData1 >= 0, "node->m_iData1 is expected to be non-negative (invalid Index)");
; 3443 : 
; 3444 : 	return 1;

	mov	eax, 1

; 3445 : }

	ret	0
?InfluenceAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; InfluenceAdd
_TEXT	ENDS
PUBLIC	?GetPartialMoveNode@CvTwoLayerPathFinder@@QAEPAVCvAStarNode@@HH@Z ; CvTwoLayerPathFinder::GetPartialMoveNode
; Function compile flags: /Ogtpy
;	COMDAT ?GetPartialMoveNode@CvTwoLayerPathFinder@@QAEPAVCvAStarNode@@HH@Z
_TEXT	SEGMENT
_iCol$ = 8						; size = 4
_iRow$ = 12						; size = 4
?GetPartialMoveNode@CvTwoLayerPathFinder@@QAEPAVCvAStarNode@@HH@Z PROC ; CvTwoLayerPathFinder::GetPartialMoveNode, COMDAT
; _this$ = ecx

; 4066 : 	return &(m_ppaaPartialMoveNodes[iCol][iRow]);

	mov	eax, DWORD PTR _iRow$[esp-4]
	mov	ecx, DWORD PTR [ecx+628]
	mov	edx, DWORD PTR _iCol$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 5
	add	eax, DWORD PTR [ecx+edx*4]

; 4067 : }

	ret	8
?GetPartialMoveNode@CvTwoLayerPathFinder@@QAEPAVCvAStarNode@@HH@Z ENDP ; CvTwoLayerPathFinder::GetPartialMoveNode
_TEXT	ENDS
PUBLIC	?getTeam@TradePathCacheData@@QBEAAVCvTeam@@XZ	; TradePathCacheData::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@TradePathCacheData@@QBEAAVCvTeam@@XZ
_TEXT	SEGMENT
?getTeam@TradePathCacheData@@QBEAAVCvTeam@@XZ PROC	; TradePathCacheData::getTeam, COMDAT
; _this$ = ecx

; 5700 : 	inline CvTeam& getTeam() const { return *m_pTeam; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?getTeam@TradePathCacheData@@QBEAAVCvTeam@@XZ ENDP	; TradePathCacheData::getTeam
_TEXT	ENDS
PUBLIC	?CanEmbarkAllWaterPassage@TradePathCacheData@@QBE_NXZ ; TradePathCacheData::CanEmbarkAllWaterPassage
; Function compile flags: /Ogtpy
;	COMDAT ?CanEmbarkAllWaterPassage@TradePathCacheData@@QBE_NXZ
_TEXT	SEGMENT
?CanEmbarkAllWaterPassage@TradePathCacheData@@QBE_NXZ PROC ; TradePathCacheData::CanEmbarkAllWaterPassage, COMDAT
; _this$ = ecx

; 5701 : 	inline bool CanEmbarkAllWaterPassage() const { return m_bCanEmbarkAllWaterPassage; }

	mov	al, BYTE PTR [ecx+4]
	ret	0
?CanEmbarkAllWaterPassage@TradePathCacheData@@QBE_NXZ ENDP ; TradePathCacheData::CanEmbarkAllWaterPassage
_TEXT	ENDS
PUBLIC	?IsRiverTradeRoad@TradePathCacheData@@QBE_NXZ	; TradePathCacheData::IsRiverTradeRoad
; Function compile flags: /Ogtpy
;	COMDAT ?IsRiverTradeRoad@TradePathCacheData@@QBE_NXZ
_TEXT	SEGMENT
?IsRiverTradeRoad@TradePathCacheData@@QBE_NXZ PROC	; TradePathCacheData::IsRiverTradeRoad, COMDAT
; _this$ = ecx

; 5702 : 	inline bool IsRiverTradeRoad() const { return m_bIsRiverTradeRoad; }

	mov	al, BYTE PTR [ecx+5]
	ret	0
?IsRiverTradeRoad@TradePathCacheData@@QBE_NXZ ENDP	; TradePathCacheData::IsRiverTradeRoad
_TEXT	ENDS
PUBLIC	?IsMoveFriendlyWoodsAsRoad@TradePathCacheData@@QBE_NXZ ; TradePathCacheData::IsMoveFriendlyWoodsAsRoad
; Function compile flags: /Ogtpy
;	COMDAT ?IsMoveFriendlyWoodsAsRoad@TradePathCacheData@@QBE_NXZ
_TEXT	SEGMENT
?IsMoveFriendlyWoodsAsRoad@TradePathCacheData@@QBE_NXZ PROC ; TradePathCacheData::IsMoveFriendlyWoodsAsRoad, COMDAT
; _this$ = ecx

; 5703 : 	inline bool IsMoveFriendlyWoodsAsRoad() const { return m_bIsMoveFriendlyWoodsAsRoad; }

	mov	al, BYTE PTR [ecx+6]
	ret	0
?IsMoveFriendlyWoodsAsRoad@TradePathCacheData@@QBE_NXZ ENDP ; TradePathCacheData::IsMoveFriendlyWoodsAsRoad
_TEXT	ENDS
PUBLIC	?TradePathUninitialize@@YAXPBXPAVCvAStar@@@Z	; TradePathUninitialize
; Function compile flags: /Ogtpy
;	COMDAT ?TradePathUninitialize@@YAXPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_pointer$ = 8						; size = 4
_finder$ = 12						; size = 4
?TradePathUninitialize@@YAXPBXPAVCvAStar@@@Z PROC	; TradePathUninitialize, COMDAT

; 5743 : 
; 5744 : }

	ret	0
?TradePathUninitialize@@YAXPBXPAVCvAStar@@@Z ENDP	; TradePathUninitialize
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@H$00@@QBEIXZ			; BaseVector<int,1>::size
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?size@?$BaseVector@H$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@H$00@@QBEIXZ PROC			; BaseVector<int,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@H$00@@QBEIXZ ENDP			; BaseVector<int,1>::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@PAVCvAStarNode@@$00@@QAEAAPAVCvAStarNode@@I@Z ; BaseVector<CvAStarNode *,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@PAVCvAStarNode@@$00@@QAEAAPAVCvAStarNode@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@PAVCvAStarNode@@$00@@QAEAAPAVCvAStarNode@@I@Z PROC ; BaseVector<CvAStarNode *,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@PAVCvAStarNode@@$00@@QAEAAPAVCvAStarNode@@I@Z ENDP ; BaseVector<CvAStarNode *,1>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvPathNode@@$00@@QAEAAVCvPathNode@@I@Z ; BaseVector<CvPathNode,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@VCvPathNode@@$00@@QAEAAVCvPathNode@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvPathNode@@$00@@QAEAAVCvPathNode@@I@Z PROC ; BaseVector<CvPathNode,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvPathNode@@$00@@QAEAAVCvPathNode@@I@Z ENDP ; BaseVector<CvPathNode,1>::operator[]
_TEXT	ENDS
PUBLIC	?at@?$BaseVector@VCvPathNode@@$00@@QAEAAVCvPathNode@@I@Z ; BaseVector<CvPathNode,1>::at
; Function compile flags: /Ogtpy
;	COMDAT ?at@?$BaseVector@VCvPathNode@@$00@@QAEAAVCvPathNode@@I@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?at@?$BaseVector@VCvPathNode@@$00@@QAEAAVCvPathNode@@I@Z PROC ; BaseVector<CvPathNode,1>::at, COMDAT
; _this$ = ecx

; 145  : 	    FAssert(i < m_uiCurrSize);
; 146  : 		return m_pData[i];

	mov	eax, DWORD PTR _i$[esp-4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 147  :     };

	ret	4
?at@?$BaseVector@VCvPathNode@@$00@@QAEAAVCvPathNode@@I@Z ENDP ; BaseVector<CvPathNode,1>::at
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvPathNode@@$00@@QBEIXZ	; BaseVector<CvPathNode,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@VCvPathNode@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvPathNode@@$00@@QBEIXZ PROC	; BaseVector<CvPathNode,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvPathNode@@$00@@QBEIXZ ENDP	; BaseVector<CvPathNode,1>::size
_TEXT	ENDS
PUBLIC	?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ; FObjectHandle<CvUnit>::pointer
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC ; FObjectHandle<CvUnit>::pointer, COMDAT
; _this$ = ecx

; 78   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 79   : 	}

	ret	0
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP ; FObjectHandle<CvUnit>::pointer
_TEXT	ENDS
PUBLIC	??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator->, COMDAT
; _this$ = ecx

; 88   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 89   : 	}

	ret	0
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator->
_TEXT	ENDS
PUBLIC	??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ		; FObjectHandle<CvUnit>::operator bool
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ
_TEXT	SEGMENT
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ PROC		; FObjectHandle<CvUnit>::operator bool, COMDAT
; _this$ = ecx

; 108  : 		return m_target != 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 109  : 	}

	ret	0
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ ENDP		; FObjectHandle<CvUnit>::operator bool
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z PROC ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 669  : 	auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()

	mov	eax, ecx

; 670  : 		{	// construct by assuming pointer from _Right auto_ptr_ref
; 671  : 		_Ty *_Ptr = _Right._Ref;
; 672  : 		_Right._Ref = 0;	// release old
; 673  : 		_Myptr = _Ptr;	// reset this

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 674  : 		}

	ret	4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z ENDP ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ ; std::auto_ptr<ICvPlot1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ PROC ; std::auto_ptr<ICvPlot1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ ENDP ; std::auto_ptr<ICvPlot1>::get
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z PROC	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ENDP	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ ; std::auto_ptr<ICvUnit1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ PROC ; std::auto_ptr<ICvUnit1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ ENDP ; std::auto_ptr<ICvUnit1>::get
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvPathNode@@$00@@IAEXPAVCvPathNode@@I@Z ; BaseVector<CvPathNode,1>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@VCvPathNode@@$00@@IAEXPAVCvPathNode@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvPathNode@@$00@@IAEXPAVCvPathNode@@I@Z PROC ; BaseVector<CvPathNode,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvPathNode@@$00@@IAEXPAVCvPathNode@@I@Z ENDP ; BaseVector<CvPathNode,1>::Destroy
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@SAPAXIIII@Z ; BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator::AllocAligned
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@SAPAXIIII@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_nAlign$ = 12						; size = 4
_nAllocPool$ = 16					; size = 4
_nAllocSubID$ = 20					; size = 4
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@SAPAXIIII@Z PROC ; BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator::AllocAligned, COMDAT

; 85   : 			return FMALLOCALIGNED( nBytes, nAlign, nAllocPool, nAllocSubID );

	mov	DWORD PTR _nAllocSubID$[esp-4], 85	; 00000055H
	mov	DWORD PTR _nAllocPool$[esp-4], OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	jmp	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@SAPAXIIII@Z ENDP ; BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator::AllocAligned
_TEXT	ENDS
PUBLIC	?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@SAXPAX@Z ; BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator::FreeAligned
; Function compile flags: /Ogtpy
;	COMDAT ?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@SAXPAX@Z
_TEXT	SEGMENT
_pBlock$ = 8						; size = 4
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@SAXPAX@Z PROC ; BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator::FreeAligned, COMDAT

; 90   : 			FFREEALIGNED( pBlock );

	jmp	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@SAXPAX@Z ENDP ; BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator::FreeAligned
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@PAVCvAStarNode@@@@YAXAAPAPAVCvAStarNode@@@Z ; SAFE_DELETE_ARRAY<CvAStarNode *>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@PAVCvAStarNode@@@@YAXAAPAPAVCvAStarNode@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@PAVCvAStarNode@@@@YAXAAPAPAVCvAStarNode@@@Z PROC ; SAFE_DELETE_ARRAY<CvAStarNode *>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@PAVCvAStarNode@@@@YAXAAPAPAVCvAStarNode@@@Z ENDP ; SAFE_DELETE_ARRAY<CvAStarNode *>
_TEXT	ENDS
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jb	SHORT $LN4@min@2
	mov	eax, ecx
$LN4@min@2:

; 3400 : 	}

	ret	0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ; std::auto_ptr_ref<ICvPlot1>::auto_ptr_ref<ICvPlot1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z PROC ; std::auto_ptr_ref<ICvPlot1>::auto_ptr_ref<ICvPlot1>, COMDAT
; _this$ = ecx

; 647  : 		{	// construct from generic pointer to auto_ptr ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 648  : 		}

	ret	4
??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ENDP ; std::auto_ptr_ref<ICvPlot1>::auto_ptr_ref<ICvPlot1>
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??3ICvUnknown@@SGXPAX@Z				; ICvUnknown::operator delete
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
;	COMDAT ??3ICvUnknown@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3ICvUnknown@@SGXPAX@Z PROC				; ICvUnknown::operator delete, COMDAT

; 310  : 		if (p)

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN1@operator

; 311  : 		{
; 312  : 			ICvUnknown* inst = (ICvUnknown*)(p);
; 313  : 			inst->Destroy();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[esp-4], eax
	jmp	edx
$LN1@operator:

; 314  : 		}
; 315  : 	}

	ret	4
??3ICvUnknown@@SGXPAX@Z ENDP				; ICvUnknown::operator delete
_TEXT	ENDS
PUBLIC	??4CvPathNode@@QAEAAV0@ABVCvAStarNode@@@Z	; CvPathNode::operator=
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastarnode.h
;	COMDAT ??4CvPathNode@@QAEAAV0@ABVCvAStarNode@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4CvPathNode@@QAEAAV0@ABVCvAStarNode@@@Z PROC		; CvPathNode::operator=, COMDAT
; _this$ = ecx

; 267  : 	{

	mov	eax, ecx

; 268  : 		m_iX = rhs.m_iX;

	mov	ecx, DWORD PTR _rhs$[esp-4]
	movzx	edx, WORD PTR [ecx+80]
	mov	WORD PTR [eax+12], dx

; 269  : 		m_iY = rhs.m_iY;

	movzx	edx, WORD PTR [ecx+82]
	mov	WORD PTR [eax+14], dx

; 270  : 		m_iData1 = rhs.m_iData1;

	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx

; 271  : 		m_iData2 = rhs.m_iData2;

	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+4], ecx

; 272  : 		m_iFlags = 0;

	mov	DWORD PTR [eax+8], 0

; 273  : 		return *this;
; 274  : 	}

	ret	4
??4CvPathNode@@QAEAAV0@ABVCvAStarNode@@@Z ENDP		; CvPathNode::operator=
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ		; CvGlobals::getMOVE_DENOMINATOR
; Function compile flags: /Ogtpy
;	COMDAT ?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMOVE_DENOMINATOR, COMDAT
; _this$ = ecx

; 5312 : 		return m_iMOVE_DENOMINATOR;

	mov	eax, DWORD PTR [ecx+6236]

; 5313 : 	}

	ret	0
?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMOVE_DENOMINATOR
_TEXT	ENDS
PUBLIC	?getPATH_DAMAGE_WEIGHT@CvGlobals@@QAEHXZ	; CvGlobals::getPATH_DAMAGE_WEIGHT
; Function compile flags: /Ogtpy
;	COMDAT ?getPATH_DAMAGE_WEIGHT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPATH_DAMAGE_WEIGHT@CvGlobals@@QAEHXZ PROC		; CvGlobals::getPATH_DAMAGE_WEIGHT, COMDAT
; _this$ = ecx

; 6020 : 		return m_iPATH_DAMAGE_WEIGHT;

	mov	eax, DWORD PTR [ecx+6944]

; 6021 : 	}

	ret	0
?getPATH_DAMAGE_WEIGHT@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getPATH_DAMAGE_WEIGHT
_TEXT	ENDS
PUBLIC	?getINFLUENCE_MOUNTAIN_COST@CvGlobals@@QAEHXZ	; CvGlobals::getINFLUENCE_MOUNTAIN_COST
; Function compile flags: /Ogtpy
;	COMDAT ?getINFLUENCE_MOUNTAIN_COST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getINFLUENCE_MOUNTAIN_COST@CvGlobals@@QAEHXZ PROC	; CvGlobals::getINFLUENCE_MOUNTAIN_COST, COMDAT
; _this$ = ecx

; 6076 : 		return m_iINFLUENCE_MOUNTAIN_COST;

	mov	eax, DWORD PTR [ecx+7000]

; 6077 : 	}

	ret	0
?getINFLUENCE_MOUNTAIN_COST@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getINFLUENCE_MOUNTAIN_COST
_TEXT	ENDS
PUBLIC	?getINFLUENCE_HILL_COST@CvGlobals@@QAEHXZ	; CvGlobals::getINFLUENCE_HILL_COST
; Function compile flags: /Ogtpy
;	COMDAT ?getINFLUENCE_HILL_COST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getINFLUENCE_HILL_COST@CvGlobals@@QAEHXZ PROC		; CvGlobals::getINFLUENCE_HILL_COST, COMDAT
; _this$ = ecx

; 6080 : 		return m_iINFLUENCE_HILL_COST;

	mov	eax, DWORD PTR [ecx+7004]

; 6081 : 	}

	ret	0
?getINFLUENCE_HILL_COST@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getINFLUENCE_HILL_COST
_TEXT	ENDS
PUBLIC	?getINFLUENCE_RIVER_COST@CvGlobals@@QAEHXZ	; CvGlobals::getINFLUENCE_RIVER_COST
; Function compile flags: /Ogtpy
;	COMDAT ?getINFLUENCE_RIVER_COST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getINFLUENCE_RIVER_COST@CvGlobals@@QAEHXZ PROC		; CvGlobals::getINFLUENCE_RIVER_COST, COMDAT
; _this$ = ecx

; 6084 : 		return m_iINFLUENCE_RIVER_COST;

	mov	eax, DWORD PTR [ecx+7008]

; 6085 : 	}

	ret	0
?getINFLUENCE_RIVER_COST@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getINFLUENCE_RIVER_COST
_TEXT	ENDS
PUBLIC	?getUSE_FIRST_RING_INFLUENCE_TERRAIN_COST@CvGlobals@@QAEHXZ ; CvGlobals::getUSE_FIRST_RING_INFLUENCE_TERRAIN_COST
; Function compile flags: /Ogtpy
;	COMDAT ?getUSE_FIRST_RING_INFLUENCE_TERRAIN_COST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getUSE_FIRST_RING_INFLUENCE_TERRAIN_COST@CvGlobals@@QAEHXZ PROC ; CvGlobals::getUSE_FIRST_RING_INFLUENCE_TERRAIN_COST, COMDAT
; _this$ = ecx

; 6088 : 		return m_iUSE_FIRST_RING_INFLUENCE_TERRAIN_COST;

	mov	eax, DWORD PTR [ecx+7012]

; 6089 : 	}

	ret	0
?getUSE_FIRST_RING_INFLUENCE_TERRAIN_COST@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getUSE_FIRST_RING_INFLUENCE_TERRAIN_COST
_TEXT	ENDS
PUBLIC	?getPLOT_UNIT_LIMIT@CvGlobals@@QAEHXZ		; CvGlobals::getPLOT_UNIT_LIMIT
; Function compile flags: /Ogtpy
;	COMDAT ?getPLOT_UNIT_LIMIT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPLOT_UNIT_LIMIT@CvGlobals@@QAEHXZ PROC		; CvGlobals::getPLOT_UNIT_LIMIT, COMDAT
; _this$ = ecx

; 6485 : 		return m_iPLOT_UNIT_LIMIT;

	mov	eax, DWORD PTR [ecx+7356]

; 6486 : 	}

	ret	0
?getPLOT_UNIT_LIMIT@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getPLOT_UNIT_LIMIT
_TEXT	ENDS
PUBLIC	?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ		; CvGlobals::getMAX_HIT_POINTS
; Function compile flags: /Ogtpy
;	COMDAT ?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMAX_HIT_POINTS, COMDAT
; _this$ = ecx

; 6497 : 		return m_iMAX_HIT_POINTS;

	mov	eax, DWORD PTR [ecx+7368]

; 6498 : 	}

	ret	0
?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMAX_HIT_POINTS
_TEXT	ENDS
PUBLIC	?getRIVER_ATTACK_MODIFIER@CvGlobals@@QAEHXZ	; CvGlobals::getRIVER_ATTACK_MODIFIER
; Function compile flags: /Ogtpy
;	COMDAT ?getRIVER_ATTACK_MODIFIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getRIVER_ATTACK_MODIFIER@CvGlobals@@QAEHXZ PROC	; CvGlobals::getRIVER_ATTACK_MODIFIER, COMDAT
; _this$ = ecx

; 6517 : 		return m_iRIVER_ATTACK_MODIFIER;

	mov	eax, DWORD PTR [ecx+7388]

; 6518 : 	}

	ret	0
?getRIVER_ATTACK_MODIFIER@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getRIVER_ATTACK_MODIFIER
_TEXT	ENDS
PUBLIC	?getSHALLOW_WATER_TERRAIN@CvGlobals@@QAEHXZ	; CvGlobals::getSHALLOW_WATER_TERRAIN
; Function compile flags: /Ogtpy
;	COMDAT ?getSHALLOW_WATER_TERRAIN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSHALLOW_WATER_TERRAIN@CvGlobals@@QAEHXZ PROC	; CvGlobals::getSHALLOW_WATER_TERRAIN, COMDAT
; _this$ = ecx

; 7179 : 		return m_iSHALLOW_WATER_TERRAIN;

	mov	eax, DWORD PTR [ecx+8396]

; 7180 : 	}

	ret	0
?getSHALLOW_WATER_TERRAIN@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getSHALLOW_WATER_TERRAIN
_TEXT	ENDS
PUBLIC	?getPROMOTION_UNWELCOME_EVANGELIST@CvGlobals@@QAEHXZ ; CvGlobals::getPROMOTION_UNWELCOME_EVANGELIST
; Function compile flags: /Ogtpy
;	COMDAT ?getPROMOTION_UNWELCOME_EVANGELIST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getPROMOTION_UNWELCOME_EVANGELIST@CvGlobals@@QAEHXZ PROC ; CvGlobals::getPROMOTION_UNWELCOME_EVANGELIST, COMDAT
; _this$ = ecx

; 7331 : 		return m_iPROMOTION_UNWELCOME_EVANGELIST;

	mov	eax, DWORD PTR [ecx+8560]

; 7332 : 	}

	ret	0
?getPROMOTION_UNWELCOME_EVANGELIST@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getPROMOTION_UNWELCOME_EVANGELIST
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7713 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8568]

; 7714 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?isAdjacentToLand_Cached@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand_Cached
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isAdjacentToLand_Cached@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isAdjacentToLand_Cached@CvPlot@@QBE_NXZ PROC		; CvPlot::isAdjacentToLand_Cached, COMDAT
; _this$ = ecx

; 120  : 	bool isAdjacentToLand_Cached() const { return m_bIsAdjacentToLand; }

	mov	al, BYTE PTR [ecx+462]
	shr	al, 6
	and	al, 1
	ret	0
?isAdjacentToLand_Cached@CvPlot@@QBE_NXZ ENDP		; CvPlot::isAdjacentToLand_Cached
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?isHills@CvPlot@@QBE_NXZ			; CvPlot::isHills
; Function compile flags: /Ogtpy
;	COMDAT ?isHills@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isHills@CvPlot@@QBE_NXZ PROC				; CvPlot::isHills, COMDAT
; _this$ = ecx

; 413  : 		return (PlotTypes)m_ePlotType == PLOT_HILLS;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 1
	sete	al

; 414  : 	};

	ret	0
?isHills@CvPlot@@QBE_NXZ ENDP				; CvPlot::isHills
_TEXT	ENDS
PUBLIC	?isMountain@CvPlot@@QBE_NXZ			; CvPlot::isMountain
; Function compile flags: /Ogtpy
;	COMDAT ?isMountain@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isMountain@CvPlot@@QBE_NXZ PROC			; CvPlot::isMountain, COMDAT
; _this$ = ecx

; 422  : 		return (PlotTypes)m_ePlotType == PLOT_MOUNTAIN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], al
	sete	al

; 423  : 	};

	ret	0
?isMountain@CvPlot@@QBE_NXZ ENDP			; CvPlot::isMountain
_TEXT	ENDS
PUBLIC	?isRiver@CvPlot@@QBE_NXZ			; CvPlot::isRiver
; Function compile flags: /Ogtpy
;	COMDAT ?isRiver@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isRiver@CvPlot@@QBE_NXZ PROC				; CvPlot::isRiver, COMDAT
; _this$ = ecx

; 426  : 		return m_iRiverCrossingCount > 0;

	xor	eax, eax
	cmp	BYTE PTR [ecx+457], al
	setg	al

; 427  : 	}

	ret	0
?isRiver@CvPlot@@QBE_NXZ ENDP				; CvPlot::isRiver
_TEXT	ENDS
PUBLIC	?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ	; CvPlot::getTerrainType
; Function compile flags: /Ogtpy
;	COMDAT ?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ
_TEXT	SEGMENT
?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ PROC	; CvPlot::getTerrainType, COMDAT
; _this$ = ecx

; 431  : 		return (TerrainTypes)m_eTerrainType;

	movsx	eax, BYTE PTR [ecx+6]

; 432  : 	}

	ret	0
?getTerrainType@CvPlot@@QBE?AW4TerrainTypes@@XZ ENDP	; CvPlot::getTerrainType
_TEXT	ENDS
PUBLIC	?isImpassable@CvPlot@@QBE_NXZ			; CvPlot::isImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?isImpassable@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isImpassable@CvPlot@@QBE_NXZ PROC			; CvPlot::isImpassable, COMDAT
; _this$ = ecx

; 444  : 		return m_bIsImpassable;

	mov	al, BYTE PTR [ecx+462]
	shr	al, 7

; 445  : 	}

	ret	0
?isImpassable@CvPlot@@QBE_NXZ ENDP			; CvPlot::isImpassable
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::getVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::getVisibilityCount, COMDAT
; _this$ = ecx

; 588  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 589  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 590  : 
; 591  : 		return m_aiVisibilityCount[eTeam];

	mov	eax, DWORD PTR [ecx+156]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 592  : 	}

	ret	4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::getVisibilityCount
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z	; CvTacticalAnalysisCell::GetBit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
;	COMDAT ?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z
_TEXT	SEGMENT
_uiFlag$ = 8						; size = 4
?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z PROC		; CvTacticalAnalysisCell::GetBit, COMDAT
; _this$ = ecx

; 83   : 	FBITFLAGS(uint);

	mov	eax, DWORD PTR [ecx]
	and	eax, DWORD PTR _uiFlag$[esp-4]
	neg	eax
	sbb	eax, eax
	neg	eax
	ret	4
?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z ENDP		; CvTacticalAnalysisCell::GetBit
_TEXT	ENDS
PUBLIC	?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ PROC	; CvTacticalAnalysisCell::IsRevealed, COMDAT
; _this$ = ecx

; 92   : 		return GetBit(TACTICAL_FLAG_REVEALED);

	mov	eax, DWORD PTR [ecx]
	and	eax, 1

; 93   : 	};

	ret	0
?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ ENDP	; CvTacticalAnalysisCell::IsRevealed
_TEXT	ENDS
PUBLIC	?IsVisible@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsVisible
; Function compile flags: /Ogtpy
;	COMDAT ?IsVisible@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsVisible@CvTacticalAnalysisCell@@QAE_NXZ PROC		; CvTacticalAnalysisCell::IsVisible, COMDAT
; _this$ = ecx

; 100  : 		return GetBit(TACTICAL_FLAG_VISIBLE);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 1
	and	eax, 1

; 101  : 	};

	ret	0
?IsVisible@CvTacticalAnalysisCell@@QAE_NXZ ENDP		; CvTacticalAnalysisCell::IsVisible
_TEXT	ENDS
PUBLIC	?IsFriendlyCity@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsFriendlyCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsFriendlyCity@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsFriendlyCity@CvTacticalAnalysisCell@@QAE_NXZ PROC	; CvTacticalAnalysisCell::IsFriendlyCity, COMDAT
; _this$ = ecx

; 156  : 		return GetBit(TACTICAL_FLAG_FRIENDLY_CITY);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 8
	and	eax, 1

; 157  : 	};

	ret	0
?IsFriendlyCity@CvTacticalAnalysisCell@@QAE_NXZ ENDP	; CvTacticalAnalysisCell::IsFriendlyCity
_TEXT	ENDS
PUBLIC	?IsEnemyCity@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsEnemyCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsEnemyCity@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsEnemyCity@CvTacticalAnalysisCell@@QAE_NXZ PROC	; CvTacticalAnalysisCell::IsEnemyCity, COMDAT
; _this$ = ecx

; 164  : 		return GetBit(TACTICAL_FLAG_ENEMY_CITY);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 9
	and	eax, 1

; 165  : 	};

	ret	0
?IsEnemyCity@CvTacticalAnalysisCell@@QAE_NXZ ENDP	; CvTacticalAnalysisCell::IsEnemyCity
_TEXT	ENDS
PUBLIC	?IsNeutralCity@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsNeutralCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsNeutralCity@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsNeutralCity@CvTacticalAnalysisCell@@QAE_NXZ PROC	; CvTacticalAnalysisCell::IsNeutralCity, COMDAT
; _this$ = ecx

; 172  : 		return GetBit(TACTICAL_FLAG_NEUTRAL_CITY);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 10					; 0000000aH
	and	eax, 1

; 173  : 	};

	ret	0
?IsNeutralCity@CvTacticalAnalysisCell@@QAE_NXZ ENDP	; CvTacticalAnalysisCell::IsNeutralCity
_TEXT	ENDS
PUBLIC	?IsCity@CvTacticalAnalysisCell@@QAE_NXZ		; CvTacticalAnalysisCell::IsCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsCity@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsCity@CvTacticalAnalysisCell@@QAE_NXZ PROC		; CvTacticalAnalysisCell::IsCity, COMDAT
; _this$ = ecx

; 180  : 		return IsFriendlyCity() || IsEnemyCity() || IsNeutralCity();

	mov	eax, DWORD PTR [ecx]
	mov	ecx, eax
	shr	ecx, 8
	test	cl, 1
	jne	SHORT $LN3@IsCity
	mov	edx, eax
	shr	edx, 9
	test	dl, 1
	jne	SHORT $LN3@IsCity
	shr	eax, 10					; 0000000aH
	test	al, 1
	jne	SHORT $LN3@IsCity
	xor	eax, eax

; 181  : 	}

	ret	0
$LN3@IsCity:

; 180  : 		return IsFriendlyCity() || IsEnemyCity() || IsNeutralCity();

	mov	eax, 1

; 181  : 	}

	ret	0
?IsCity@CvTacticalAnalysisCell@@QAE_NXZ ENDP		; CvTacticalAnalysisCell::IsCity
_TEXT	ENDS
PUBLIC	?IsWater@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsWater
; Function compile flags: /Ogtpy
;	COMDAT ?IsWater@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsWater@CvTacticalAnalysisCell@@QAE_NXZ PROC		; CvTacticalAnalysisCell::IsWater, COMDAT
; _this$ = ecx

; 184  : 		return GetBit(TACTICAL_FLAG_WATER);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 11					; 0000000bH
	and	eax, 1

; 185  : 	};

	ret	0
?IsWater@CvTacticalAnalysisCell@@QAE_NXZ ENDP		; CvTacticalAnalysisCell::IsWater
_TEXT	ENDS
PUBLIC	?IsUnclaimedTerritory@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsUnclaimedTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?IsUnclaimedTerritory@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsUnclaimedTerritory@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsUnclaimedTerritory, COMDAT
; _this$ = ecx

; 224  : 		return GetBit(TACTICAL_FLAG_UNCLAIMED_TERRITORY);

	movzx	eax, WORD PTR [ecx+2]
	and	eax, 1

; 225  : 	};

	ret	0
?IsUnclaimedTerritory@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsUnclaimedTerritory
_TEXT	ENDS
PUBLIC	?GetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ ; CvTacticalAnalysisCell::GetEnemyMilitaryUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?GetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ PROC ; CvTacticalAnalysisCell::GetEnemyMilitaryUnit, COMDAT
; _this$ = ecx

; 258  : 		return m_pEnemyMilitary;

	mov	eax, DWORD PTR [ecx+4]

; 259  : 	};

	ret	0
?GetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ ENDP ; CvTacticalAnalysisCell::GetEnemyMilitaryUnit
_TEXT	ENDS
PUBLIC	?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z ; CvTacticalAnalysisMap::GetCell
; Function compile flags: /Ogtpy
;	COMDAT ?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z
_TEXT	SEGMENT
_iPlotIndex$ = 8					; size = 4
?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z PROC ; CvTacticalAnalysisMap::GetCell, COMDAT
; _this$ = ecx

; 630  : 		return &m_pPlots[iPlotIndex];

	mov	eax, DWORD PTR _iPlotIndex$[esp-4]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx+12]

; 631  : 	};

	ret	4
?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z ENDP ; CvTacticalAnalysisMap::GetCell
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ ; CvPlayerTraits::IsMoveFriendlyWoodsAsRoad
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ PROC	; CvPlayerTraits::IsMoveFriendlyWoodsAsRoad, COMDAT
; _this$ = ecx

; 716  : 		return m_bMoveFriendlyWoodsAsRoad;

	mov	al, BYTE PTR [ecx+325]

; 717  : 	};

	ret	0
?IsMoveFriendlyWoodsAsRoad@CvPlayerTraits@@QBE_NXZ ENDP	; CvPlayerTraits::IsMoveFriendlyWoodsAsRoad
_TEXT	ENDS
PUBLIC	?IsRiverTradeRoad@CvPlayerTraits@@QBE_NXZ	; CvPlayerTraits::IsRiverTradeRoad
; Function compile flags: /Ogtpy
;	COMDAT ?IsRiverTradeRoad@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsRiverTradeRoad@CvPlayerTraits@@QBE_NXZ PROC		; CvPlayerTraits::IsRiverTradeRoad, COMDAT
; _this$ = ecx

; 817  : 		return m_bRiverTradeRoad;

	mov	al, BYTE PTR [ecx+346]

; 818  : 	}

	ret	0
?IsRiverTradeRoad@CvPlayerTraits@@QBE_NXZ ENDP		; CvPlayerTraits::IsRiverTradeRoad
_TEXT	ENDS
PUBLIC	?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ	; CvAStar::GetLastNode
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.h
;	COMDAT ?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ
_TEXT	SEGMENT
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ PROC	; CvAStar::GetLastNode, COMDAT
; _this$ = ecx

; 98   : 		return m_pBest;

	mov	eax, DWORD PTR [ecx+96]

; 99   : 	}

	ret	0
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ ENDP	; CvAStar::GetLastNode
_TEXT	ENDS
PUBLIC	?IsPathDest@CvAStar@@QAE_NHH@Z			; CvAStar::IsPathDest
; Function compile flags: /Ogtpy
;	COMDAT ?IsPathDest@CvAStar@@QAE_NHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?IsPathDest@CvAStar@@QAE_NHH@Z PROC			; CvAStar::IsPathDest, COMDAT
; _this$ = ecx

; 124  : 		if(udIsPathDest && udIsPathDest(iX, iY, m_pData, this))

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN1@IsPathDest
	mov	edx, DWORD PTR _iY$[esp-4]
	push	ecx
	mov	ecx, DWORD PTR [ecx+44]
	push	ecx
	mov	ecx, DWORD PTR _iX$[esp+4]
	push	edx
	push	ecx
	call	eax
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@IsPathDest

; 125  : 		{
; 126  : 			return TRUE;

	mov	al, 1

; 129  : 	}

	ret	8
$LN1@IsPathDest:

; 127  : 		}
; 128  : 		return FALSE;

	xor	al, al

; 129  : 	}

	ret	8
?IsPathDest@CvAStar@@QAE_NHH@Z ENDP			; CvAStar::IsPathDest
_TEXT	ENDS
PUBLIC	?GetStartX@CvAStar@@QAEHXZ			; CvAStar::GetStartX
; Function compile flags: /Ogtpy
;	COMDAT ?GetStartX@CvAStar@@QAEHXZ
_TEXT	SEGMENT
?GetStartX@CvAStar@@QAEHXZ PROC				; CvAStar::GetStartX, COMDAT
; _this$ = ecx

; 137  : 		return m_iXstart;

	mov	eax, DWORD PTR [ecx+56]

; 138  : 	}

	ret	0
?GetStartX@CvAStar@@QAEHXZ ENDP				; CvAStar::GetStartX
_TEXT	ENDS
PUBLIC	?GetStartY@CvAStar@@QAEHXZ			; CvAStar::GetStartY
; Function compile flags: /Ogtpy
;	COMDAT ?GetStartY@CvAStar@@QAEHXZ
_TEXT	SEGMENT
?GetStartY@CvAStar@@QAEHXZ PROC				; CvAStar::GetStartY, COMDAT
; _this$ = ecx

; 146  : 		return m_iYstart;

	mov	eax, DWORD PTR [ecx+60]

; 147  : 	}

	ret	0
?GetStartY@CvAStar@@QAEHXZ ENDP				; CvAStar::GetStartY
_TEXT	ENDS
PUBLIC	?GetDestX@CvAStar@@QAEHXZ			; CvAStar::GetDestX
; Function compile flags: /Ogtpy
;	COMDAT ?GetDestX@CvAStar@@QAEHXZ
_TEXT	SEGMENT
?GetDestX@CvAStar@@QAEHXZ PROC				; CvAStar::GetDestX, COMDAT
; _this$ = ecx

; 155  : 		return m_iXdest;

	mov	eax, DWORD PTR [ecx+64]

; 156  : 	}

	ret	0
?GetDestX@CvAStar@@QAEHXZ ENDP				; CvAStar::GetDestX
_TEXT	ENDS
PUBLIC	?GetDestY@CvAStar@@QAEHXZ			; CvAStar::GetDestY
; Function compile flags: /Ogtpy
;	COMDAT ?GetDestY@CvAStar@@QAEHXZ
_TEXT	SEGMENT
?GetDestY@CvAStar@@QAEHXZ PROC				; CvAStar::GetDestY, COMDAT
; _this$ = ecx

; 164  : 		return m_iYdest;

	mov	eax, DWORD PTR [ecx+68]

; 165  : 	}

	ret	0
?GetDestY@CvAStar@@QAEHXZ ENDP				; CvAStar::GetDestY
_TEXT	ENDS
PUBLIC	?GetInfo@CvAStar@@QAEHXZ			; CvAStar::GetInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetInfo@CvAStar@@QAEHXZ
_TEXT	SEGMENT
?GetInfo@CvAStar@@QAEHXZ PROC				; CvAStar::GetInfo, COMDAT
; _this$ = ecx

; 173  : 		return m_iInfo;

	mov	eax, DWORD PTR [ecx+72]

; 174  : 	}

	ret	0
?GetInfo@CvAStar@@QAEHXZ ENDP				; CvAStar::GetInfo
_TEXT	ENDS
PUBLIC	?SetData@CvAStar@@QAEXPBX@Z			; CvAStar::SetData
; Function compile flags: /Ogtpy
;	COMDAT ?SetData@CvAStar@@QAEXPBX@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?SetData@CvAStar@@QAEXPBX@Z PROC			; CvAStar::SetData, COMDAT
; _this$ = ecx

; 202  : 		if(m_bDataChangeInvalidatesCache && m_pData != pData)

	cmp	BYTE PTR [ecx+80], 0
	mov	eax, DWORD PTR _pData$[esp-4]
	je	SHORT $LN4@SetData
	cmp	DWORD PTR [ecx+44], eax

; 205  : 		m_pData = pData;

	mov	DWORD PTR [ecx+44], eax
	je	SHORT $LN1@SetData

; 203  : #endif
; 204  : 			m_bForceReset = true;

	mov	BYTE PTR [ecx+78], 1

; 206  : #ifdef AUI_ASTAR_TURN_LIMITER
; 207  : 		m_iMaxTurns = iMaxTurns;
; 208  : #endif
; 209  : 	}

	ret	4
$LN4@SetData:

; 205  : 		m_pData = pData;

	mov	DWORD PTR [ecx+44], eax
$LN1@SetData:

; 206  : #ifdef AUI_ASTAR_TURN_LIMITER
; 207  : 		m_iMaxTurns = iMaxTurns;
; 208  : #endif
; 209  : 	}

	ret	4
?SetData@CvAStar@@QAEXPBX@Z ENDP			; CvAStar::SetData
_TEXT	ENDS
PUBLIC	?GetScratchBuffer@CvAStar@@QAEPAXXZ		; CvAStar::GetScratchBuffer
; Function compile flags: /Ogtpy
;	COMDAT ?GetScratchBuffer@CvAStar@@QAEPAXXZ
_TEXT	SEGMENT
?GetScratchBuffer@CvAStar@@QAEPAXXZ PROC		; CvAStar::GetScratchBuffer, COMDAT
; _this$ = ecx

; 383  : 	void* GetScratchBuffer() { return &m_ScratchBuffer[0]; }

	lea	eax, DWORD PTR [ecx+116]
	ret	0
?GetScratchBuffer@CvAStar@@QAEPAXXZ ENDP		; CvAStar::GetScratchBuffer
_TEXT	ENDS
PUBLIC	?xRange@CvAStar@@IAEHH@Z			; CvAStar::xRange
; Function compile flags: /Ogtpy
;	COMDAT ?xRange@CvAStar@@IAEHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
?xRange@CvAStar@@IAEHH@Z PROC				; CvAStar::xRange, COMDAT
; _this$ = ecx

; 480  : 	if(m_bWrapX)

	cmp	BYTE PTR [ecx+76], 0

; 481  : 	{
; 482  : 		if(iX < 0)

	mov	eax, DWORD PTR _iX$[esp-4]
	je	SHORT $LN1@xRange

; 483  : 		{
; 484  : 			return (m_iColumns + (iX % m_iColumns));

	mov	ecx, DWORD PTR [ecx+48]
	test	eax, eax
	jge	SHORT $LN5@xRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 489  : 		}
; 490  : 		else
; 491  : 		{
; 492  : 			return iX;
; 493  : 		}
; 494  : 	}
; 495  : 	else
; 496  : 	{
; 497  : 		return iX;
; 498  : 	}
; 499  : }

	ret	4
$LN5@xRange:

; 485  : 		}
; 486  : 		else if(iX >= m_iColumns)

	cmp	eax, ecx
	jl	SHORT $LN1@xRange

; 487  : 		{
; 488  : 			return (iX % m_iColumns);

	cdq
	idiv	ecx
	mov	eax, edx
$LN1@xRange:

; 489  : 		}
; 490  : 		else
; 491  : 		{
; 492  : 			return iX;
; 493  : 		}
; 494  : 	}
; 495  : 	else
; 496  : 	{
; 497  : 		return iX;
; 498  : 	}
; 499  : }

	ret	4
?xRange@CvAStar@@IAEHH@Z ENDP				; CvAStar::xRange
_TEXT	ENDS
PUBLIC	?yRange@CvAStar@@IAEHH@Z			; CvAStar::yRange
; Function compile flags: /Ogtpy
;	COMDAT ?yRange@CvAStar@@IAEHH@Z
_TEXT	SEGMENT
_iY$ = 8						; size = 4
?yRange@CvAStar@@IAEHH@Z PROC				; CvAStar::yRange, COMDAT
; _this$ = ecx

; 508  : 	if(m_bWrapY)

	cmp	BYTE PTR [ecx+77], 0

; 509  : 	{
; 510  : 		if(iY < 0)

	mov	eax, DWORD PTR _iY$[esp-4]
	je	SHORT $LN1@yRange

; 511  : 		{
; 512  : 			return (m_iRows + (iY % m_iRows));

	mov	ecx, DWORD PTR [ecx+52]
	test	eax, eax
	jge	SHORT $LN5@yRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 517  : 		}
; 518  : 		else
; 519  : 		{
; 520  : 			return iY;
; 521  : 		}
; 522  : 	}
; 523  : 	else
; 524  : 	{
; 525  : 		return iY;
; 526  : 	}
; 527  : }

	ret	4
$LN5@yRange:

; 513  : 		}
; 514  : 		else if(iY >= m_iRows)

	cmp	eax, ecx
	jl	SHORT $LN1@yRange

; 515  : 		{
; 516  : 			return (iY % m_iRows);

	cdq
	idiv	ecx
	mov	eax, edx
$LN1@yRange:

; 517  : 		}
; 518  : 		else
; 519  : 		{
; 520  : 			return iY;
; 521  : 		}
; 522  : 	}
; 523  : 	else
; 524  : 	{
; 525  : 		return iY;
; 526  : 	}
; 527  : }

	ret	4
?yRange@CvAStar@@IAEHH@Z ENDP				; CvAStar::yRange
_TEXT	ENDS
PUBLIC	?isValid@CvAStar@@IAE_NHH@Z			; CvAStar::isValid
; Function compile flags: /Ogtpy
;	COMDAT ?isValid@CvAStar@@IAE_NHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isValid@CvAStar@@IAE_NHH@Z PROC			; CvAStar::isValid, COMDAT
; _this$ = ecx

; 536  : 	if((iX < 0) || (iX >= m_iColumns))

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isValid
	cmp	eax, DWORD PTR [ecx+48]
	jge	SHORT $LN3@isValid

; 539  : 	}
; 540  : 
; 541  : 	if((iY < 0) || (iY >= m_iRows))

	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isValid
	cmp	eax, DWORD PTR [ecx+52]
	jge	SHORT $LN3@isValid

; 542  : 	{
; 543  : 		return false;
; 544  : 	}
; 545  : 
; 546  : 	return true;

	mov	al, 1

; 547  : }

	ret	8
$LN3@isValid:

; 537  : 	{
; 538  : 		return false;

	xor	al, al

; 547  : }

	ret	8
?isValid@CvAStar@@IAE_NHH@Z ENDP			; CvAStar::isValid
_TEXT	ENDS
PUBLIC	?udFunc@CvAStar@@IAEHP6AHPAVCvAStarNode@@0HPBXPAV1@@Z00H1@Z ; CvAStar::udFunc
; Function compile flags: /Ogtpy
;	COMDAT ?udFunc@CvAStar@@IAEHP6AHPAVCvAStarNode@@0HPBXPAV1@@Z00H1@Z
_TEXT	SEGMENT
_func$ = 8						; size = 4
_param1$ = 12						; size = 4
_param2$ = 16						; size = 4
_data$ = 20						; size = 4
_cb$ = 24						; size = 4
?udFunc@CvAStar@@IAEHP6AHPAVCvAStarNode@@0HPBXPAV1@@Z00H1@Z PROC ; CvAStar::udFunc, COMDAT
; _this$ = ecx

; 552  : 	return (func) ? func(param1, param2, data, cb, this) : 1;

	mov	eax, DWORD PTR _func$[esp-4]
	test	eax, eax
	je	SHORT $LN3@udFunc
	mov	edx, DWORD PTR _data$[esp-4]
	push	ecx
	mov	ecx, DWORD PTR _cb$[esp]
	push	ecx
	mov	ecx, DWORD PTR _param2$[esp+4]
	push	edx
	mov	edx, DWORD PTR _param1$[esp+8]
	push	ecx
	push	edx
	call	eax
	add	esp, 20					; 00000014H

; 553  : }

	ret	20					; 00000014H
$LN3@udFunc:

; 552  : 	return (func) ? func(param1, param2, data, cb, this) : 1;

	mov	eax, 1

; 553  : }

	ret	20					; 00000014H
?udFunc@CvAStar@@IAEHP6AHPAVCvAStarNode@@0HPBXPAV1@@Z00H1@Z ENDP ; CvAStar::udFunc
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEPAPAVCvAStarNode@@I@Z ; FStaticVector<CvAStarNode *,6,1,297,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEPAPAVCvAStarNode@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEPAPAVCvAStarNode@@I@Z PROC ; FStaticVector<CvAStarNode *,6,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 6
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 6
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEPAPAVCvAStarNode@@I@Z ENDP ; FStaticVector<CvAStarNode *,6,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ	; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ PROC	; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ ENDP	; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@PAVCvAStarNode@@$00@@IAE@XZ	; BaseVector<CvAStarNode *,1>::BaseVector<CvAStarNode *,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@PAVCvAStarNode@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@PAVCvAStarNode@@$00@@IAE@XZ PROC	; BaseVector<CvAStarNode *,1>::BaseVector<CvAStarNode *,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@PAVCvAStarNode@@$00@@IAE@XZ ENDP	; BaseVector<CvAStarNode *,1>::BaseVector<CvAStarNode *,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@PAVCvAStarNode@@$00@@IAEXPAPAVCvAStarNode@@I@Z ; BaseVector<CvAStarNode *,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@PAVCvAStarNode@@$00@@IAEXPAPAVCvAStarNode@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@PAVCvAStarNode@@$00@@IAEXPAPAVCvAStarNode@@I@Z PROC ; BaseVector<CvAStarNode *,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@PAVCvAStarNode@@$00@@IAEXPAPAVCvAStarNode@@I@Z ENDP ; BaseVector<CvAStarNode *,1>::Destroy
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ	; FAutoVariable<bool,CvUnit>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ PROC		; FAutoVariable<bool,CvUnit>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ ENDP		; FAutoVariable<bool,CvUnit>::operator bool const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ
_TEXT	SEGMENT
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ PROC		; FAutoVariable<char,CvPlot>::operator char const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ ENDP		; FAutoVariable<char,CvPlot>::operator char const &
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z	; directionXY
; Function compile flags: /Ogtpy
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@HHHH@Z
_TEXT	SEGMENT
_iSourceX$ = 8						; size = 4
_iSourceY$ = 12						; size = 4
_iDestX$ = 16						; size = 4
_iDestY$ = 20						; size = 4
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z PROC		; directionXY, COMDAT

; 264  : {

	push	ebx

; 265  : 	int iSourceHexX = xToHexspaceX(iSourceX, iSourceY);

	mov	ebx, DWORD PTR _iSourceY$[esp]
	push	esi
	push	edi
	test	ebx, ebx
	jl	SHORT $LN17@directionX
	mov	eax, ebx
	jmp	SHORT $LN51@directionX
$LN17@directionX:
	lea	eax, DWORD PTR [ebx-1]
	cdq
	sub	eax, edx
$LN51@directionX:
	mov	esi, DWORD PTR _iSourceX$[esp+8]

; 266  : 	int iDestHexX = xToHexspaceX(iDestX, iDestY);

	mov	edi, DWORD PTR _iDestY$[esp+8]
	sar	eax, 1
	sub	esi, eax
	test	edi, edi
	jl	SHORT $LN21@directionX
	mov	eax, edi
	jmp	SHORT $LN52@directionX
$LN21@directionX:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN52@directionX:

; 267  : 
; 268  : 	int iWrappedXOffset = dxWrap(iDestHexX - iSourceHexX);

	mov	ecx, DWORD PTR _iDestX$[esp+8]
	sar	eax, 1
	sub	ecx, eax
	sub	ecx, esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [esi+4056], 0
	mov	edx, DWORD PTR [esi+4020]
	je	SHORT $LN31@directionX
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN33@directionX
	sub	ecx, edx
	jmp	SHORT $LN31@directionX
$LN33@directionX:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN35@directionX
$LN31@directionX:
	mov	eax, ecx
$LN35@directionX:

; 269  : 	int iWrappedYOffset = dyWrap(iDestY - iSourceY);

	sub	edi, ebx
	cmp	BYTE PTR [esi+4057], 0
	mov	edx, edi
	mov	edi, DWORD PTR [esi+4024]
	je	SHORT $LN45@directionX
	mov	esi, edi
	shr	esi, 1
	cmp	edx, esi
	jle	SHORT $LN47@directionX
	sub	edx, edi
	jmp	SHORT $LN45@directionX
$LN47@directionX:
	neg	esi
	cmp	edx, esi
	jge	SHORT $LN45@directionX
	add	edx, edi
$LN45@directionX:
	pop	edi
	pop	esi
	pop	ebx

; 270  : 
; 271  : 	if(iWrappedYOffset > 0)

	test	edx, edx
	jle	SHORT $LN53@directionX

; 272  : 	{
; 273  : 		if(iWrappedXOffset >= 0)

	xor	ecx, ecx
	test	eax, eax
	setge	cl
	dec	ecx
	and	ecx, 5
	mov	eax, ecx

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
$LN53@directionX:

; 274  : 		{
; 275  : 			return DIRECTION_NORTHEAST;
; 276  : 		}
; 277  : 		else
; 278  : 		{
; 279  : 			return DIRECTION_NORTHWEST;
; 280  : 		}
; 281  : 	}
; 282  : 	else if(iWrappedYOffset == 0)

	jne	SHORT $LN8@directionX

; 283  : 	{
; 284  : 		if(iWrappedXOffset > 0)

	test	eax, eax
	jle	SHORT $LN7@directionX

; 285  : 		{
; 286  : 			return DIRECTION_EAST;

	mov	eax, 1

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
$LN7@directionX:

; 287  : 		}
; 288  : 		else if(iWrappedXOffset == 0)

	neg	eax
	sbb	eax, eax
	and	eax, 5
	dec	eax

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
$LN8@directionX:

; 289  : 		{
; 290  : 			return NO_DIRECTION;
; 291  : 		}
; 292  : 		else
; 293  : 		{
; 294  : 			return DIRECTION_WEST;
; 295  : 		}
; 296  : 	}
; 297  : 	else// if (iWrappedYOffset < 0)
; 298  : 	{
; 299  : 		if(iWrappedXOffset > 0)

	xor	edx, edx
	test	eax, eax
	setle	dl
	add	edx, 2
	mov	eax, edx

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;
; 302  : 		}
; 303  : 		else
; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;
; 306  : 		}
; 307  : 	}
; 308  : }

	ret	0
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ENDP		; directionXY
_TEXT	ENDS
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
; Function compile flags: /Ogtpy
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z
_TEXT	SEGMENT
_pFromPlot$ = 8						; size = 4
_pToPlot$ = 12						; size = 4
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z PROC	; directionXY, COMDAT

; 312  : 	return directionXY(pFromPlot->getX(), pFromPlot->getY(),
; 313  : 	                   pToPlot->getX(), pToPlot->getY());

	mov	eax, DWORD PTR _pToPlot$[esp-4]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	mov	eax, DWORD PTR _pFromPlot$[esp-4]
	push	ecx
	movsx	ecx, WORD PTR [eax+2]
	push	edx
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	call	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ; directionXY
	add	esp, 16					; 00000010H

; 314  : 
; 315  : }

	ret	0
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ENDP	; directionXY
_TEXT	ENDS
PUBLIC	??1CvAStar@@QAE@XZ				; CvAStar::~CvAStar
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
;	COMDAT ??1CvAStar@@QAE@XZ
_TEXT	SEGMENT
??1CvAStar@@QAE@XZ PROC					; CvAStar::~CvAStar, COMDAT
; _this$ = ecx

; 142  : 	DeInit();

	jmp	?DeInit@CvAStar@@QAEXXZ			; CvAStar::DeInit
??1CvAStar@@QAE@XZ ENDP					; CvAStar::~CvAStar
_TEXT	ENDS
PUBLIC	?GetBest@CvAStar@@IAEPAVCvAStarNode@@XZ		; CvAStar::GetBest
; Function compile flags: /Ogtpy
;	COMDAT ?GetBest@CvAStar@@IAEPAVCvAStarNode@@XZ
_TEXT	SEGMENT
?GetBest@CvAStar@@IAEPAVCvAStarNode@@XZ PROC		; CvAStar::GetBest, COMDAT
; _this$ = ecx

; 442  : {

	push	esi
	mov	esi, ecx
	push	edi

; 443  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 444  : 	CvAStarNode* temp;
; 445  : #endif
; 446  : 
; 447  : 	if(!m_pOpen)

	mov	edi, DWORD PTR [esi+84]
	test	edi, edi
	jne	SHORT $LN4@GetBest
	pop	edi

; 448  : 	{
; 449  : 		return NULL;

	xor	eax, eax
	pop	esi

; 485  : }

	ret	0
$LN4@GetBest:

; 450  : 	}
; 451  : 
; 452  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 453  : 	CvAStarNode* temp = m_pOpen;
; 454  : #else
; 455  : 	temp = m_pOpen;
; 456  : #endif
; 457  : 
; 458  : 	m_pOpen = temp->m_pNext;

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+84], eax

; 459  : 	if(m_pOpen != NULL)

	test	eax, eax
	je	SHORT $LN3@GetBest

; 460  : 	{
; 461  : 		m_pOpen->m_pPrev = NULL;

	mov	DWORD PTR [eax+32], 0

; 462  : 	}
; 463  : 	else

	jmp	SHORT $LN2@GetBest
$LN3@GetBest:

; 464  : 	{
; 465  : 		m_pOpenTail = NULL;

	mov	DWORD PTR [esi+88], 0
$LN2@GetBest:

; 466  : 	}
; 467  : 
; 468  : 	udFunc(udNotifyList, NULL, temp, ASNL_DELETEOPEN, m_pData);

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN9@GetBest
	mov	ecx, DWORD PTR [esi+44]
	push	esi
	push	ecx
	push	2
	push	edi
	push	0
	call	eax
	add	esp, 20					; 00000014H
$LN9@GetBest:

; 469  : 
; 470  : 	temp->m_eCvAStarListType = CVASTARLIST_CLOSED;

	mov	DWORD PTR [edi+20], 1

; 471  : 
; 472  : 	temp->m_pNext = m_pClosed;

	mov	edx, DWORD PTR [esi+92]
	mov	DWORD PTR [edi+28], edx

; 473  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 474  : 	temp->m_pPrev = NULL;
; 475  : #endif
; 476  : 	if(m_pClosed != NULL)

	mov	eax, DWORD PTR [esi+92]
	test	eax, eax
	je	SHORT $LN1@GetBest

; 477  : 	{
; 478  : 		m_pClosed->m_pPrev = temp;

	mov	DWORD PTR [eax+32], edi
$LN1@GetBest:

; 479  : 	}
; 480  : 	m_pClosed = temp;
; 481  : 
; 482  : 	udFunc(udNotifyList, NULL, m_pClosed, ASNL_ADDCLOSED, m_pData);

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+92], edi
	test	eax, eax
	je	SHORT $LN13@GetBest
	mov	ecx, DWORD PTR [esi+44]
	push	esi
	push	ecx
	push	3
	push	edi
	push	0
	call	eax
	add	esp, 20					; 00000014H
$LN13@GetBest:

; 483  : 
; 484  : 	return temp;

	mov	eax, edi
	pop	edi
	pop	esi

; 485  : }

	ret	0
?GetBest@CvAStar@@IAEPAVCvAStarNode@@XZ ENDP		; CvAStar::GetBest
_TEXT	ENDS
PUBLIC	?AddToOpen@CvAStar@@QAEXPAVCvAStarNode@@@Z	; CvAStar::AddToOpen
; Function compile flags: /Ogtpy
;	COMDAT ?AddToOpen@CvAStar@@QAEXPAVCvAStarNode@@@Z
_TEXT	SEGMENT
tv380 = -4						; size = 4
tv452 = 8						; size = 4
_addnode$ = 8						; size = 4
?AddToOpen@CvAStar@@QAEXPAVCvAStarNode@@@Z PROC		; CvAStar::AddToOpen, COMDAT
; _this$ = ecx

; 683  : {

	push	ecx
	push	ebx
	push	esi

; 684  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 685  : 	CvAStarNode* node;
; 686  : #endif
; 687  : 
; 688  : 	addnode->m_eCvAStarListType = CVASTARLIST_OPEN;

	mov	esi, DWORD PTR _addnode$[esp+8]
	xor	edx, edx
	mov	DWORD PTR [esi+20], edx

; 689  : 
; 690  : 	if(!m_pOpen)

	mov	ebx, DWORD PTR [ecx+84]
	cmp	ebx, edx
	jne	SHORT $LN21@AddToOpen

; 691  : 	{
; 692  : 		m_pOpen = addnode;

	mov	DWORD PTR [ecx+84], esi

; 693  : 		m_pOpenTail = addnode;

	mov	DWORD PTR [ecx+88], esi

; 694  : 		m_pOpen->m_pNext = NULL;

	mov	DWORD PTR [esi+28], edx

; 695  : 		m_pOpen->m_pPrev = NULL;

	mov	eax, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+32], edx

; 696  : 
; 697  : 		udFunc(udNotifyList, NULL, addnode, ASNL_STARTOPEN, m_pData);

	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, edx
	je	$LN8@AddToOpen
	push	ecx
	mov	ecx, DWORD PTR [ecx+44]
	push	ecx
	push	1
	push	esi
	push	edx
	call	eax
	add	esp, 20					; 00000014H
	pop	esi
	pop	ebx

; 845  : 	}
; 846  : }

	pop	ecx
	ret	4
$LN21@AddToOpen:
	push	ebp

; 698  : 
; 699  : 		return;
; 700  : 	}
; 701  : #ifdef AUI_ASTAR_FIX_POSSIBLE_NULL_POINTERS
; 702  : 	else if (!m_pOpenTail)
; 703  : 	{
; 704  : 		CvAStarNode* temp = m_pOpen;
; 705  : 		while (temp->m_pNext)
; 706  : 		{
; 707  : 			temp = temp->m_pNext;
; 708  : 		}
; 709  : 		m_pOpenTail = temp;
; 710  : 	}
; 711  : 
; 712  : 	if (addnode->m_iTotalCost < m_pOpen->m_iTotalCost)
; 713  : #else
; 714  : 
; 715  : 	if(addnode->m_iTotalCost <= m_pOpen->m_iTotalCost)

	mov	ebp, DWORD PTR [ebx]
	push	edi
	mov	edi, DWORD PTR [esi]
	cmp	edi, ebp
	jg	SHORT $LN20@AddToOpen

; 716  : #endif
; 717  : 	{
; 718  : 		addnode->m_pNext = m_pOpen;

	mov	DWORD PTR [esi+28], ebx

; 719  : 		m_pOpen->m_pPrev = addnode;

	mov	eax, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+32], esi

; 720  : 		m_pOpen = addnode;
; 721  : 
; 722  : 		udFunc(udNotifyList, m_pOpen->m_pNext, m_pOpen, ASNL_STARTOPEN, m_pData);

	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+84], esi
	cmp	eax, edx
	je	$LN38@AddToOpen
	mov	edx, DWORD PTR [esi+28]
	push	ecx
	mov	ecx, DWORD PTR [ecx+44]
	push	ecx
	push	1
	push	esi
	push	edx
	call	eax
	add	esp, 20					; 00000014H
	pop	edi
	pop	ebp
	pop	esi
	pop	ebx

; 845  : 	}
; 846  : }

	pop	ecx
	ret	4
$LN20@AddToOpen:

; 723  : 	}
; 724  : 	else if(addnode->m_iTotalCost >= m_pOpenTail->m_iTotalCost)

	mov	eax, DWORD PTR [ecx+88]
	mov	edx, DWORD PTR [eax]
	cmp	edi, edx
	jl	SHORT $LN18@AddToOpen

; 725  : 	{
; 726  : 		addnode->m_pPrev = m_pOpenTail;

	mov	DWORD PTR [esi+32], eax

; 727  : 		m_pOpenTail->m_pNext = addnode;

	mov	eax, DWORD PTR [ecx+88]
	mov	DWORD PTR [eax+28], esi

; 728  : 		m_pOpenTail = addnode;
; 729  : 
; 730  : 		udFunc(udNotifyList, addnode->m_pPrev, addnode, ASNL_ADDOPEN, m_pData);

	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+88], esi
	test	eax, eax
	je	$LN38@AddToOpen
	mov	edx, DWORD PTR [esi+32]
	push	ecx
	mov	ecx, DWORD PTR [ecx+44]
	push	ecx
	push	0
	push	esi
	push	edx
	call	eax
	add	esp, 20					; 00000014H
	pop	edi
	pop	ebp
	pop	esi
	pop	ebx

; 845  : 	}
; 846  : }

	pop	ecx
	ret	4
$LN18@AddToOpen:

; 731  : 	}
; 732  : 	else if(abs(addnode->m_iTotalCost-m_pOpenTail->m_iTotalCost) < abs(addnode->m_iTotalCost-m_pOpen->m_iTotalCost))  //(addnode->m_iTotalCost > m_iOpenListAverage) // let's start at the end and work forwards

	mov	eax, edi
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR tv452[esp+16], eax
	mov	eax, edi
	sub	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR tv452[esp+16]
	cmp	edx, eax
	jge	$LN16@AddToOpen

; 733  : 	{
; 734  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 735  : 		CvAStarNode* next = NULL;
; 736  : 		CvAStarNode* node = m_pOpenTail;
; 737  : #else
; 738  : 		CvAStarNode* next;
; 739  : 		node = m_pOpenTail;

	mov	ebx, DWORD PTR [ecx+88]
	mov	eax, ebx

; 740  : 		next = NULL;

	xor	edx, edx

; 741  : #endif
; 742  : 
; 743  : 		while(node)

	test	eax, eax
	je	SHORT $LN14@AddToOpen
$LL15@AddToOpen:

; 744  : 		{
; 745  : 			if(addnode->m_iTotalCost < node->m_iTotalCost)

	cmp	edi, DWORD PTR [eax]
	jge	SHORT $LN13@AddToOpen

; 746  : 			{
; 747  : 				next = node;

	mov	edx, eax

; 748  : 				node = node->m_pPrev;

	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	jne	SHORT $LL15@AddToOpen
$LN14@AddToOpen:

; 774  : 				}
; 775  : 
; 776  : 				return;
; 777  : 			}
; 778  : 		}
; 779  : 
; 780  : 		// we made it to the start of this list - insert it at the beginning - we shouldn't ever get here, but...
; 781  : 		next->m_pPrev = addnode;

	mov	DWORD PTR [edx+32], esi

; 782  : 		addnode->m_pNext = next;

	mov	DWORD PTR [esi+28], edx

; 783  : 		m_pOpen = addnode;
; 784  : 
; 785  : 		udFunc(udNotifyList, m_pOpen->m_pNext, m_pOpen, ASNL_STARTOPEN, m_pData);

	mov	edx, DWORD PTR [ecx+44]
	push	edx

; 843  : 
; 844  : 		udFunc(udNotifyList, prev, addnode, ASNL_ADDOPEN, m_pData);

	mov	edx, DWORD PTR [ecx+24]
	push	1
	mov	DWORD PTR [ecx+84], esi
	mov	eax, DWORD PTR [esi+28]
	push	esi
	push	eax
	push	edx
	call	?udFunc@CvAStar@@IAEHP6AHPAVCvAStarNode@@0HPBXPAV1@@Z00H1@Z ; CvAStar::udFunc
	pop	edi
	pop	ebp
	pop	esi
	pop	ebx

; 845  : 	}
; 846  : }

	pop	ecx
	ret	4
$LN13@AddToOpen:

; 749  : 			}
; 750  : 			else
; 751  : 			{
; 752  : 				if(next)

	test	edx, edx
	je	SHORT $LN11@AddToOpen

; 753  : 				{
; 754  : 					next->m_pPrev = addnode;

	mov	DWORD PTR [edx+32], esi

; 755  : 					addnode->m_pNext = next;

	mov	DWORD PTR [esi+28], edx

; 756  : 					addnode->m_pPrev = node;

	mov	DWORD PTR [esi+32], eax

; 757  : 					node->m_pNext = addnode;

	mov	DWORD PTR [eax+28], esi

; 758  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 759  : 					if(node->m_pNext == NULL)
; 760  : 					{
; 761  : 						m_pOpenTail = node;
; 762  : 					}
; 763  : #endif
; 764  : 
; 765  : 					udFunc(udNotifyList, addnode->m_pPrev, addnode, ASNL_ADDOPEN, m_pData);

	mov	eax, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR [esi+32]
	push	eax
	mov	eax, DWORD PTR [ecx+24]
	push	0
	push	esi
	push	edx
	push	eax

; 843  : 
; 844  : 		udFunc(udNotifyList, prev, addnode, ASNL_ADDOPEN, m_pData);

	call	?udFunc@CvAStar@@IAEHP6AHPAVCvAStarNode@@0HPBXPAV1@@Z00H1@Z ; CvAStar::udFunc
	pop	edi
	pop	ebp
	pop	esi
	pop	ebx

; 845  : 	}
; 846  : }

	pop	ecx
	ret	4
$LN11@AddToOpen:

; 766  : 				}
; 767  : 				else // we should just add it to the end of the list
; 768  : 				{
; 769  : 					addnode->m_pPrev = m_pOpenTail;

	mov	DWORD PTR [esi+32], ebx

; 770  : 					m_pOpenTail->m_pNext = addnode;

	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR [edx+28], esi

; 771  : 					m_pOpenTail = addnode;
; 772  : 
; 773  : 					udFunc(udNotifyList, addnode->m_pPrev, addnode, ASNL_ADDOPEN, m_pData);

	mov	eax, DWORD PTR [ecx+44]
	push	eax
	mov	eax, DWORD PTR [ecx+24]
	push	0
	mov	DWORD PTR [ecx+88], esi
	mov	edx, DWORD PTR [esi+32]
	push	esi
	push	edx
	push	eax

; 843  : 
; 844  : 		udFunc(udNotifyList, prev, addnode, ASNL_ADDOPEN, m_pData);

	call	?udFunc@CvAStar@@IAEHP6AHPAVCvAStarNode@@0HPBXPAV1@@Z00H1@Z ; CvAStar::udFunc
	pop	edi
	pop	ebp
	pop	esi
	pop	ebx

; 845  : 	}
; 846  : }

	pop	ecx
	ret	4
$LN16@AddToOpen:

; 786  : 	}
; 787  : 	else // let's start at the beginning as it should be closer
; 788  : 	{
; 789  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 790  : 		CvAStarNode* node = m_pOpen;
; 791  : 		CvAStarNode* prev = NULL;
; 792  : #else
; 793  : 		CvAStarNode* prev;
; 794  : 		node = m_pOpen;

	mov	eax, ebx

; 795  : 		prev = NULL;

	xor	edx, edx
	npad	5
$LL7@AddToOpen:

; 796  : #endif
; 797  : 
; 798  : 		while(node)
; 799  : 		{
; 800  : #ifdef AUI_ASTAR_FIX_POSSIBLE_NULL_POINTERS
; 801  : 			if (addnode->m_iTotalCost >= node->m_iTotalCost)
; 802  : #else
; 803  : 			if(addnode->m_iTotalCost > node->m_iTotalCost)

	cmp	edi, DWORD PTR [eax]
	jle	SHORT $LN5@AddToOpen

; 804  : #endif
; 805  : 			{
; 806  : 				prev = node;

	mov	edx, eax

; 807  : 				node = node->m_pNext;

	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	jne	SHORT $LL7@AddToOpen

; 833  : 				}
; 834  : 
; 835  : 				return;
; 836  : 			}
; 837  : 		}
; 838  : 
; 839  : 		// we made it to the end of this list - insert it at the end - we shouldn't ever get here, but...
; 840  : 		prev->m_pNext = addnode;

	mov	DWORD PTR [edx+28], esi

; 841  : 		addnode->m_pPrev = prev;

	mov	DWORD PTR [esi+32], edx

; 842  : 		m_pOpenTail = addnode;

	mov	DWORD PTR [ecx+88], esi
$LN2@AddToOpen:

; 843  : 
; 844  : 		udFunc(udNotifyList, prev, addnode, ASNL_ADDOPEN, m_pData);

	mov	eax, DWORD PTR [ecx+44]
	push	eax
	push	0
	push	esi
	push	edx
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?udFunc@CvAStar@@IAEHP6AHPAVCvAStarNode@@0HPBXPAV1@@Z00H1@Z ; CvAStar::udFunc
$LN38@AddToOpen:
	pop	edi
	pop	ebp
$LN8@AddToOpen:
	pop	esi
	pop	ebx

; 845  : 	}
; 846  : }

	pop	ecx
	ret	4
$LN5@AddToOpen:

; 808  : 			}
; 809  : 			else
; 810  : 			{
; 811  : 				if(prev)

	test	edx, edx
	je	SHORT $LN3@AddToOpen

; 812  : 				{
; 813  : 					prev->m_pNext = addnode;

	mov	DWORD PTR [edx+28], esi

; 814  : 					addnode->m_pPrev = prev;

	mov	DWORD PTR [esi+32], edx

; 815  : 					addnode->m_pNext = node;

	mov	DWORD PTR [esi+28], eax

; 816  : 					node->m_pPrev = addnode;
; 817  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 818  : 					if(node->m_pNext == NULL)

	cmp	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+32], esi
	jne	SHORT $LN2@AddToOpen

; 819  : 					{
; 820  : 						m_pOpenTail = node;

	mov	DWORD PTR [ecx+88], eax

; 821  : 					}
; 822  : #endif
; 823  : 
; 824  : 					udFunc(udNotifyList, prev, addnode, ASNL_ADDOPEN, m_pData);
; 825  : 				}
; 826  : 				else

	jmp	SHORT $LN2@AddToOpen
$LN3@AddToOpen:

; 827  : 				{
; 828  : 					addnode->m_pNext = m_pOpen;

	mov	DWORD PTR [esi+28], ebx

; 829  : 					m_pOpen->m_pPrev = addnode;

	mov	eax, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+32], esi

; 830  : 					m_pOpen = addnode;
; 831  : 
; 832  : 					udFunc(udNotifyList, m_pOpen->m_pNext, m_pOpen, ASNL_STARTOPEN, m_pData);

	mov	edx, DWORD PTR [ecx+44]
	push	edx

; 843  : 
; 844  : 		udFunc(udNotifyList, prev, addnode, ASNL_ADDOPEN, m_pData);

	mov	edx, DWORD PTR [ecx+24]
	push	1
	mov	DWORD PTR [ecx+84], esi
	mov	eax, DWORD PTR [esi+28]
	push	esi
	push	eax
	push	edx
	call	?udFunc@CvAStar@@IAEHP6AHPAVCvAStarNode@@0HPBXPAV1@@Z00H1@Z ; CvAStar::udFunc
	pop	edi
	pop	ebp
	pop	esi
	pop	ebx

; 845  : 	}
; 846  : }

	pop	ecx
	ret	4
?AddToOpen@CvAStar@@QAEXPAVCvAStarNode@@@Z ENDP		; CvAStar::AddToOpen
_TEXT	ENDS
PUBLIC	?UpdateParents@CvAStar@@IAEXPAVCvAStarNode@@@Z	; CvAStar::UpdateParents
; Function compile flags: /Ogtpy
;	COMDAT ?UpdateParents@CvAStar@@IAEXPAVCvAStarNode@@@Z
_TEXT	SEGMENT
_iNumChildren$ = 8					; size = 4
_node$ = 8						; size = 4
?UpdateParents@CvAStar@@IAEXPAVCvAStarNode@@@Z PROC	; CvAStar::UpdateParents, COMDAT
; _this$ = ecx

; 922  : {

	push	ebp

; 923  : 	CvAStarNode* kid;
; 924  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 925  : 	CvAStarNode* parent;
; 926  : #endif
; 927  : 	int iKnownCost;
; 928  : 	int iNumChildren;
; 929  : 	int i;
; 930  : 
; 931  : 	FAssert(m_pStackHead == NULL);
; 932  : 
; 933  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 934  : 	CvAStarNode* parent = node;
; 935  : #else
; 936  : 	parent = node;

	mov	ebp, DWORD PTR _node$[esp]
	push	edi
	mov	edi, ecx

; 937  : #endif
; 938  : 
; 939  : 	while(parent != NULL)

	test	ebp, ebp
	je	$LN32@UpdatePare
	push	ebx
	push	esi
$LL7@UpdatePare:

; 940  : 	{
; 941  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 942  : 		iNumChildren = parent->m_apChildren.size();
; 943  : #else
; 944  : 		iNumChildren = parent->m_iNumChildren;

	movsx	eax, WORD PTR [ebp+84]

; 945  : #endif
; 946  : 
; 947  : 		for(i = 0; i < iNumChildren; i++)

	xor	ebx, ebx
	mov	DWORD PTR _iNumChildren$[esp+12], eax
	test	eax, eax
	jle	$LN3@UpdatePare
$LL33@UpdatePare:

; 948  : 		{
; 949  : 			kid = parent->m_apChildren[i];

	mov	eax, DWORD PTR [ebp+40]
	mov	esi, DWORD PTR [eax+ebx*4]

; 950  : 
; 951  : 			iKnownCost = (parent->m_iKnownCost + udFunc(udCost, parent, kid, 0, m_pData));

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi+44]
	test	eax, eax
	je	SHORT $LN14@UpdatePare
	push	edi
	push	ecx
	push	0
	push	esi
	push	ebp
	call	eax
	add	esp, 20					; 00000014H
	jmp	SHORT $LN15@UpdatePare
$LN14@UpdatePare:
	mov	eax, 1
$LN15@UpdatePare:
	mov	ecx, DWORD PTR [ebp+4]
	add	ecx, eax

; 952  : 
; 953  : 			if(iKnownCost < kid->m_iKnownCost)

	cmp	ecx, DWORD PTR [esi+4]
	jge	SHORT $LN4@UpdatePare

; 954  : 			{
; 955  : 				kid->m_iKnownCost = iKnownCost;
; 956  : 				kid->m_iTotalCost = kid->m_iKnownCost + kid->m_iHeuristicCost;

	mov	edx, DWORD PTR [esi+8]
	add	edx, ecx

; 957  : 				FAssert(parent->m_pParent != kid);
; 958  : 				kid->m_pParent = parent;
; 959  : 				if(kid->m_eCvAStarListType == CVASTARLIST_OPEN)

	cmp	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+24], ebp
	jne	SHORT $LN1@UpdatePare

; 960  : 				{
; 961  : 					UpdateOpenNode(kid);

	push	esi
	mov	ecx, edi
	call	?UpdateOpenNode@CvAStar@@IAEXPAVCvAStarNode@@@Z ; CvAStar::UpdateOpenNode
$LN1@UpdatePare:

; 962  : 				}
; 963  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 964  : 				else
; 965  : 				{
; 966  : 					Push(kid); // Kid cannot be a parent if it's in the open list, since adding children goes through GetBest(), which adds the node to the closed list
; 967  : 				}
; 968  : #endif
; 969  : 				udFunc(udNotifyChild, parent, kid, ASNC_PARENTADD_UP, m_pData);

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN18@UpdatePare
	mov	ecx, DWORD PTR [edi+44]
	push	edi
	push	ecx
	push	3
	push	esi
	push	ebp
	call	eax
	add	esp, 20					; 00000014H
$LN18@UpdatePare:

; 970  : 
; 971  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 972  : 				Push(kid);

	cmp	BYTE PTR [esi+86], 0
	jne	SHORT $LN4@UpdatePare
	mov	eax, DWORD PTR [edi+100]
	test	eax, eax
	jne	SHORT $LN21@UpdatePare
	movsx	eax, WORD PTR [esi+82]
	movsx	edx, WORD PTR [esi+80]
	mov	ecx, DWORD PTR [edi+104]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 5
	add	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edi+100], eax
	jmp	SHORT $LN20@UpdatePare
$LN21@UpdatePare:
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [edi+100], esi
$LN20@UpdatePare:
	mov	BYTE PTR [esi+86], 1
$LN4@UpdatePare:

; 945  : #endif
; 946  : 
; 947  : 		for(i = 0; i < iNumChildren; i++)

	inc	ebx
	cmp	ebx, DWORD PTR _iNumChildren$[esp+12]
	jl	$LL33@UpdatePare
$LN3@UpdatePare:

; 973  : #endif
; 974  : 			}
; 975  : 		}
; 976  : 
; 977  : 		parent = Pop();

	mov	ebp, DWORD PTR [edi+100]
	test	ebp, ebp
	je	SHORT $LN34@UpdatePare
	mov	ecx, DWORD PTR [ebp+36]
	mov	DWORD PTR [edi+100], ecx
	mov	DWORD PTR [ebp+36], 0
	mov	BYTE PTR [ebp+86], 0
	jmp	$LL7@UpdatePare
$LN34@UpdatePare:
	pop	esi
	pop	ebx
$LN32@UpdatePare:
	pop	edi
	pop	ebp

; 978  : 	}
; 979  : }

	ret	4
?UpdateParents@CvAStar@@IAEXPAVCvAStarNode@@@Z ENDP	; CvAStar::UpdateParents
_TEXT	ENDS
PUBLIC	?PathDest@@YAHHHPBXPAVCvAStar@@@Z		; PathDest
; Function compile flags: /Ogtpy
;	COMDAT ?PathDest@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?PathDest@@YAHHHPBXPAVCvAStar@@@Z PROC			; PathDest, COMDAT

; 1114 : 	if(iToX == finder->GetDestX() && iToY == finder->GetDestY())

	mov	eax, DWORD PTR _finder$[esp-4]
	mov	ecx, DWORD PTR _iToX$[esp-4]
	cmp	ecx, DWORD PTR [eax+64]
	jne	SHORT $LN2@PathDest
	mov	edx, DWORD PTR _iToY$[esp-4]
	cmp	edx, DWORD PTR [eax+68]
	jne	SHORT $LN2@PathDest

; 1115 : 	{
; 1116 : #ifdef AUI_WARNING_FIXES
; 1117 : 		return TRUE;
; 1118 : #else
; 1119 : 		return true;

	mov	eax, 1

; 1128 : #endif
; 1129 : 	}
; 1130 : }

	ret	0
$LN2@PathDest:

; 1120 : #endif
; 1121 : 	}
; 1122 : 	else
; 1123 : 	{
; 1124 : #ifdef AUI_WARNING_FIXES
; 1125 : 		return FALSE;
; 1126 : #else
; 1127 : 		return false;

	xor	eax, eax

; 1128 : #endif
; 1129 : 	}
; 1130 : }

	ret	0
?PathDest@@YAHHHPBXPAVCvAStar@@@Z ENDP			; PathDest
_TEXT	ENDS
PUBLIC	?PathHeuristic@@YAHHHHH@Z			; PathHeuristic
; Function compile flags: /Ogtpy
;	COMDAT ?PathHeuristic@@YAHHHHH@Z
_TEXT	SEGMENT
_iFromX$ = 8						; size = 4
_iFromY$ = 12						; size = 4
_iToX$ = 16						; size = 4
_iToY$ = 20						; size = 4
?PathHeuristic@@YAHHHHH@Z PROC				; PathHeuristic, COMDAT

; 1276 : 	return (plotDistance(iFromX, iFromY, iToX, iToY) * PATH_MOVEMENT_WEIGHT);

	mov	eax, DWORD PTR _iToY$[esp-4]
	mov	ecx, DWORD PTR _iToX$[esp-4]
	mov	edx, DWORD PTR _iFromY$[esp-4]
	push	eax
	mov	eax, DWORD PTR _iFromX$[esp]
	push	ecx
	push	edx
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	imul	eax, 1000				; 000003e8H
	add	esp, 16					; 00000010H

; 1277 : }

	ret	0
?PathHeuristic@@YAHHHHH@Z ENDP				; PathHeuristic
_TEXT	ENDS
PUBLIC	?StepHeuristic@@YAHHHHH@Z			; StepHeuristic
; Function compile flags: /Ogtpy
;	COMDAT ?StepHeuristic@@YAHHHHH@Z
_TEXT	SEGMENT
_iFromX$ = 8						; size = 4
_iFromY$ = 12						; size = 4
_iToX$ = 16						; size = 4
_iToY$ = 20						; size = 4
?StepHeuristic@@YAHHHHH@Z PROC				; StepHeuristic, COMDAT

; 3116 : 	return plotDistance(iFromX, iFromY, iToX, iToY);

	jmp	?plotDistance@@YAHHHHH@Z		; plotDistance
?StepHeuristic@@YAHHHHH@Z ENDP				; StepHeuristic
_TEXT	ENDS
PUBLIC	?InfluenceHeuristic@@YAHHHHH@Z			; InfluenceHeuristic
; Function compile flags: /Ogtpy
;	COMDAT ?InfluenceHeuristic@@YAHHHHH@Z
_TEXT	SEGMENT
_iFromX$ = 8						; size = 4
_iFromY$ = 12						; size = 4
_iToX$ = 16						; size = 4
_iToY$ = 20						; size = 4
?InfluenceHeuristic@@YAHHHHH@Z PROC			; InfluenceHeuristic, COMDAT

; 3323 : 	return plotDistance(iFromX, iFromY, iToX, iToY);

	jmp	?plotDistance@@YAHHHHH@Z		; plotDistance
?InfluenceHeuristic@@YAHHHHH@Z ENDP			; InfluenceHeuristic
_TEXT	ENDS
PUBLIC	??0CvTwoLayerPathFinder@@QAE@XZ			; CvTwoLayerPathFinder::CvTwoLayerPathFinder
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvTwoLayerPathFinder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTwoLayerPathFinder@@QAE@XZ$0
__ehfuncinfo$??0CvTwoLayerPathFinder@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvTwoLayerPathFinder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0CvTwoLayerPathFinder@@QAE@XZ
_TEXT	SEGMENT
_this$ = -644						; size = 4
$T222724 = -640						; size = 628
__$EHRec$ = -12						; size = 12
??0CvTwoLayerPathFinder@@QAE@XZ PROC			; CvTwoLayerPathFinder::CvTwoLayerPathFinder, COMDAT
; _this$ = ecx

; 3998 : {

	push	-1
	push	__ehhandler$??0CvTwoLayerPathFinder@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 632				; 00000278H
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+652], esi
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+20], ebx
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+28], ebx
	mov	DWORD PTR [esi+32], ebx
	mov	DWORD PTR [esi+36], ebx
	mov	DWORD PTR [esi+40], ebx
	mov	DWORD PTR [esi+44], ebx
	mov	DWORD PTR [esi+84], ebx
	mov	DWORD PTR [esi+88], ebx
	mov	DWORD PTR [esi+92], ebx
	mov	DWORD PTR [esi+96], ebx
	mov	DWORD PTR [esi+100], ebx
	mov	DWORD PTR [esi+104], ebx
	mov	BYTE PTR [esi+79], bl
	mov	BYTE PTR [esi+80], bl

; 3999 : #ifdef AUI_WARNING_FIXES
; 4000 : 	this->CvAStar::CvAStar();
; 4001 : #else
; 4002 : 	CvAStar::CvAStar();

	lea	ecx, DWORD PTR $T222724[esp+652]
	mov	DWORD PTR __$EHRec$[esp+660], ebx
	mov	DWORD PTR $T222724[esp+652], ebx
	mov	DWORD PTR $T222724[esp+656], ebx
	mov	DWORD PTR $T222724[esp+660], ebx
	mov	DWORD PTR $T222724[esp+664], ebx
	mov	DWORD PTR $T222724[esp+668], ebx
	mov	DWORD PTR $T222724[esp+672], ebx
	mov	DWORD PTR $T222724[esp+676], ebx
	mov	DWORD PTR $T222724[esp+680], ebx
	mov	DWORD PTR $T222724[esp+684], ebx
	mov	DWORD PTR $T222724[esp+688], ebx
	mov	DWORD PTR $T222724[esp+692], ebx
	mov	DWORD PTR $T222724[esp+696], ebx
	mov	DWORD PTR $T222724[esp+736], ebx
	mov	DWORD PTR $T222724[esp+740], ebx
	mov	DWORD PTR $T222724[esp+744], ebx
	mov	DWORD PTR $T222724[esp+748], ebx
	mov	DWORD PTR $T222724[esp+752], ebx
	mov	DWORD PTR $T222724[esp+756], ebx
	mov	BYTE PTR $T222724[esp+731], bl
	mov	BYTE PTR $T222724[esp+732], bl
	call	?DeInit@CvAStar@@QAEXXZ			; CvAStar::DeInit

; 4003 : #endif
; 4004 : 	m_ppaaPartialMoveNodes = NULL;
; 4005 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+652]
	mov	DWORD PTR [esi+628], ebx
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 644				; 00000284H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTwoLayerPathFinder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
__ehhandler$??0CvTwoLayerPathFinder@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvTwoLayerPathFinder@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTwoLayerPathFinder@@QAE@XZ ENDP			; CvTwoLayerPathFinder::CvTwoLayerPathFinder
PUBLIC	?GetPathLength@CvIgnoreUnitsPathFinder@@QAEHXZ	; CvIgnoreUnitsPathFinder::GetPathLength
; Function compile flags: /Ogtpy
;	COMDAT ?GetPathLength@CvIgnoreUnitsPathFinder@@QAEHXZ
_TEXT	SEGMENT
?GetPathLength@CvIgnoreUnitsPathFinder@@QAEHXZ PROC	; CvIgnoreUnitsPathFinder::GetPathLength, COMDAT
; _this$ = ecx

; 4393 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4394 : 	CvAStarNode* pNode = GetLastNode();
; 4395 : 	if (pNode != NULL)
; 4396 : 	{
; 4397 : 		return pNode->m_iData2;
; 4398 : 	}
; 4399 : 
; 4400 : 	return MAX_INT;
; 4401 : #else
; 4402 : 	int iPathDistance = MAX_INT;
; 4403 : 
; 4404 : 	CvAStarNode* pNode = GetLastNode();

	mov	ecx, DWORD PTR [ecx+96]
	mov	eax, 2147483647				; 7fffffffH

; 4405 : 	if(pNode != NULL)

	test	ecx, ecx
	je	SHORT $LN1@GetPathLen

; 4406 : 	{
; 4407 : 		iPathDistance = pNode->m_iData2;
; 4408 : 	}
; 4409 : 
; 4410 : 	return iPathDistance;

	mov	eax, DWORD PTR [ecx+16]
$LN1@GetPathLen:

; 4411 : #endif
; 4412 : }

	ret	0
?GetPathLength@CvIgnoreUnitsPathFinder@@QAEHXZ ENDP	; CvIgnoreUnitsPathFinder::GetPathLength
_TEXT	ENDS
PUBLIC	?TradeRouteHeuristic@@YAHHHHH@Z			; TradeRouteHeuristic
; Function compile flags: /Ogtpy
;	COMDAT ?TradeRouteHeuristic@@YAHHHHH@Z
_TEXT	SEGMENT
_iFromX$ = 8						; size = 4
_iFromY$ = 12						; size = 4
_iToX$ = 16						; size = 4
_iToY$ = 20						; size = 4
?TradeRouteHeuristic@@YAHHHHH@Z PROC			; TradeRouteHeuristic, COMDAT

; 5749 : 	return plotDistance(iFromX, iFromY, iToX, iToY) * 100;

	mov	eax, DWORD PTR _iToY$[esp-4]
	mov	ecx, DWORD PTR _iToX$[esp-4]
	mov	edx, DWORD PTR _iFromY$[esp-4]
	push	eax
	mov	eax, DWORD PTR _iFromX$[esp]
	push	ecx
	push	edx
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	imul	eax, 100				; 00000064H
	add	esp, 16					; 00000010H

; 5750 : }

	ret	0
?TradeRouteHeuristic@@YAHHHHH@Z ENDP			; TradeRouteHeuristic
_TEXT	ENDS
PUBLIC	?GetTurnDest@CvPathNodeArray@@QAEPBVCvPathNode@@H@Z ; CvPathNodeArray::GetTurnDest
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnDest@CvPathNodeArray@@QAEPBVCvPathNode@@H@Z
_TEXT	SEGMENT
_iTurn$ = 8						; size = 4
?GetTurnDest@CvPathNodeArray@@QAEPBVCvPathNode@@H@Z PROC ; CvPathNodeArray::GetTurnDest, COMDAT
; _this$ = ecx

; 6049 : 	for (uint i = size(); i--; )

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	je	SHORT $LN18@GetTurnDes
	mov	eax, edx
	shl	eax, 4
	add	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iTurn$[esp-4]
$LL6@GetTurnDes:
	dec	edx
	sub	eax, 16					; 00000010H

; 6050 : 	{
; 6051 : 		const CvPathNode& kNode = at(i);
; 6052 : 		if (i == 0)

	test	edx, edx
	je	SHORT $LN16@GetTurnDes

; 6056 : 				return &kNode;
; 6057 : 			return NULL;
; 6058 : 		}
; 6059 : 		else
; 6060 : 		{
; 6061 : 			// Is this node the correct turn and the next node is a turn after it?
; 6062 : 			if (kNode.m_iData2 == iTurn && at(i-1).m_iData2 > iTurn)

	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LL6@GetTurnDes
	cmp	DWORD PTR [eax-12], ecx
	jle	SHORT $LL6@GetTurnDes

; 6068 : }

	ret	4
$LN16@GetTurnDes:

; 6053 : 		{
; 6054 : 			// Last node, only return it if it is the desired turn
; 6055 : 			if (kNode.m_iData2 == iTurn)

	xor	edx, edx
	cmp	DWORD PTR [eax+4], ecx
	setne	dl
	dec	edx
	and	eax, edx

; 6068 : }

	ret	4
$LN18@GetTurnDes:

; 6063 : 				return &kNode;
; 6064 : 		}
; 6065 : 	}
; 6066 : 
; 6067 : 	return NULL;

	xor	eax, eax

; 6068 : }

	ret	4
?GetTurnDest@CvPathNodeArray@@QAEPBVCvPathNode@@H@Z ENDP ; CvPathNodeArray::GetTurnDest
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 222  : 	{

	mov	eax, DWORD PTR _source$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	mov	dl, BYTE PTR [eax+4]
	mov	BYTE PTR [esi+4], dl

; 223  : 		OBJECT_HANDLE_STACK;
; 224  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@2

; 225  : 		{
; 226  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@2:

; 227  : 		}
; 228  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr@2
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr@2:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	?Alloc@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEPAVCvPathNode@@I@Z ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEPAVCvPathNode@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEPAVCvPathNode@@I@Z PROC ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 503  : 	T* Alloc( unsigned int uiSize ){

	push	esi

; 504  : 		if( uiSize > 0 ){

	mov	esi, DWORD PTR _uiSize$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jbe	SHORT $LN1@Alloc@2

; 505  :             
; 506  :             T* pRet = (T*)FAST_VEC_ALLOC::AllocAligned( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	mov	eax, esi
	shl	eax, 4
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 507  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi

; 511  : 	};

	ret	4
$LN1@Alloc@2:
	pop	edi

; 508  : 			return pRet;
; 509  : 		}
; 510  : 		return NULL;

	xor	eax, eax
	pop	esi

; 511  : 	};

	ret	4
?Alloc@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEPAVCvPathNode@@I@Z ENDP ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXPAVCvPathNode@@I@Z ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXPAVCvPathNode@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXPAVCvPathNode@@I@Z PROC ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::Free, COMDAT
; _this$ = ecx

; 516  : 		if( !bPODType) 
; 517  :             Destroy(pVal, uiNumElements);
; 518  : 
; 519  : 		FAST_VEC_ALLOC::FreeAligned( (void*)pVal );

	mov	eax, DWORD PTR _pVal$[esp-4]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 520  : 	};

	ret	8
?Free@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXPAVCvPathNode@@I@Z ENDP ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::Free
_TEXT	ENDS
PUBLIC	??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ ; std::auto_ptr<ICvPlot1>::operator<ICvPlot1> std::auto_ptr_ref<ICvPlot1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ PROC ; std::auto_ptr<ICvPlot1>::operator<ICvPlot1> std::auto_ptr_ref<ICvPlot1>, COMDAT
; _this$ = ecx

; 684  : 		{	// convert to compatible auto_ptr_ref
; 685  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 686  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 687  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 688  : 		return (_Ans);
; 689  : 		}

	ret	4
??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ ENDP ; std::auto_ptr<ICvPlot1>::operator<ICvPlot1> std::auto_ptr_ref<ICvPlot1>
_TEXT	ENDS
PUBLIC	?isEmbarked@CvUnit@@QBE_NXZ			; CvUnit::isEmbarked
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?isEmbarked@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?isEmbarked@CvUnit@@QBE_NXZ PROC			; CvUnit::isEmbarked, COMDAT
; _this$ = ecx

; 257  : 		return m_bEmbarked;

	mov	al, BYTE PTR [ecx+1652]

; 258  : 	}

	ret	0
?isEmbarked@CvUnit@@QBE_NXZ ENDP			; CvUnit::isEmbarked
_TEXT	ENDS
PUBLIC	?GetID@CvUnit@@QBEHXZ				; CvUnit::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvUnit@@QBEHXZ PROC				; CvUnit::GetID, COMDAT
; _this$ = ecx

; 662  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+100]

; 663  : 	}

	ret	0
?GetID@CvUnit@@QBEHXZ ENDP				; CvUnit::GetID
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
PUBLIC	?IsCombatUnit@CvUnit@@QBE_NXZ			; CvUnit::IsCombatUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsCombatUnit@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?IsCombatUnit@CvUnit@@QBE_NXZ PROC			; CvUnit::IsCombatUnit, COMDAT
; _this$ = ecx

; 1243 : 		return (m_iBaseCombat > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+1044], eax
	setg	al

; 1244 : 	}

	ret	0
?IsCombatUnit@CvUnit@@QBE_NXZ ENDP			; CvUnit::IsCombatUnit
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlayer::getTeam
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayerID$ = 8						; size = 4
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlayer::getTeam, COMDAT

; 1173 : 		return CvPreGame::teamType(ePlayerID);

	mov	eax, DWORD PTR _ePlayerID$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1174 : 	}

	ret	0

; 1173 : 		return CvPreGame::teamType(ePlayerID);

$LN3@getTeam:
	or	eax, -1

; 1174 : 	}

	ret	0
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam@2:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z		; CvPlot::isVisible
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isVisible, COMDAT
; _this$ = ecx

; 210  : 		if(eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@isVisible

; 211  : 			return false;

	xor	al, al

; 214  : 	}

	ret	4
$LN1@isVisible:

; 212  : 
; 213  : 		return ((getVisibilityCount(eTeam) > 0));

	mov	ecx, DWORD PTR [ecx+156]
	xor	edx, edx
	cmp	WORD PTR [ecx+eax*2], dx
	setg	dl
	mov	al, dl

; 214  : 	}

	ret	4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isVisible
_TEXT	ENDS
PUBLIC	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ		; CvPlot::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ PROC		; CvPlot::getTeam, COMDAT
; _this$ = ecx

; 232  : 		PlayerTypes playerID = getOwner();

	movsx	eax, BYTE PTR [ecx+4]

; 233  : 		if(playerID != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN2@getTeam@3

; 234  : 		{
; 235  : 			return CvPlayer::getTeam(playerID);

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@getTeam@3
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 240  : 		}
; 241  : 	}

	ret	0
$LN2@getTeam@3:

; 236  : 		}
; 237  : 		else
; 238  : 		{
; 239  : 			return NO_TEAM;

	or	eax, -1

; 240  : 		}
; 241  : 	}

	ret	0
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlot::getTeam
_TEXT	ENDS
PUBLIC	?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z		; CvPlot::isEnemyCity
EXTRN	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isEnemy
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z
_TEXT	SEGMENT
_kUnit$ = 8						; size = 4
?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z PROC		; CvPlot::isEnemyCity, COMDAT
; _this$ = ecx

; 252  : 	{

	push	esi
	mov	esi, ecx

; 253  : 		CvCity* pCity = getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN1@isEnemyCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isEnemyCit
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 254  : 		if(pCity != NULL)

	test	eax, eax
	je	SHORT $LN1@isEnemyCit

; 255  : 			return kUnit.isEnemy(pCity->getTeam(), this);

	push	esi
	mov	ecx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	ecx, DWORD PTR _kUnit$[esp+4]
	push	eax
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	pop	esi

; 258  : 	}

	ret	4
$LN1@isEnemyCit:

; 256  : 
; 257  : 		return false;

	xor	al, al
	pop	esi

; 258  : 	}

	ret	4
?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z ENDP		; CvPlot::isEnemyCity
_TEXT	ENDS
PUBLIC	?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ	; CvPlot::getFeatureType
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ
_TEXT	SEGMENT
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ PROC	; CvPlot::getFeatureType, COMDAT
; _this$ = ecx

; 435  : #ifdef AUI_WARNING_FIXES
; 436  : 		int f = m_eFeatureType;
; 437  : #else
; 438  : 		char f = m_eFeatureType;
; 439  : #endif
; 440  : 		return (FeatureTypes)f;

	movsx	eax, BYTE PTR [ecx+432]

; 441  : 	}

	ret	0
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ ENDP	; CvPlot::getFeatureType
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z	; CvMap::plotCheckInvalid
; Function compile flags: /Ogtpy
;	COMDAT ?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z PROC	; CvMap::plotCheckInvalid, COMDAT
; _this$ = ecx

; 282  : 	{

	push	esi

; 283  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	esi, DWORD PTR _iX$[esp]
	cmp	esi, -2147483647			; 80000001H
	je	SHORT $LN1@plotCheckI
	mov	edx, DWORD PTR _iY$[esp]
	cmp	edx, -2147483647			; 80000001H
	je	SHORT $LN1@plotCheckI

; 286  : 		}
; 287  : 		return &(m_pMapPlots[plotNum(iX, iY)]);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, edx
	add	eax, esi
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	pop	esi

; 288  : 	}

	ret	8
$LN1@plotCheckI:

; 284  : 		{
; 285  : 			return NULL;

	xor	eax, eax
	pop	esi

; 288  : 	}

	ret	8
?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z ENDP	; CvMap::plotCheckInvalid
_TEXT	ENDS
PUBLIC	?plotUnchecked@CvMap@@QBEPAVCvPlot@@HH@Z	; CvMap::plotUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotUnchecked@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotUnchecked@CvMap@@QBEPAVCvPlot@@HH@Z PROC		; CvMap::plotUnchecked, COMDAT
; _this$ = ecx

; 292  : 		return &(m_pMapPlots[plotNum(iX, iY)]);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 293  : 	}

	ret	8
?plotUnchecked@CvMap@@QBEPAVCvPlot@@HH@Z ENDP		; CvMap::plotUnchecked
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,6,1,297,0>::FStaticVector<CvAStarNode *,6,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvAStarNode *,6,1,297,0>::FStaticVector<CvAStarNode *,6,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 6
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvAStarNode *,6,1,297,0>::FStaticVector<CvAStarNode *,6,1,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@PAVCvAStarNode@@$00@@QAEXXZ	; BaseVector<CvAStarNode *,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@PAVCvAStarNode@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@PAVCvAStarNode@@$00@@QAEXXZ PROC	; BaseVector<CvAStarNode *,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@PAVCvAStarNode@@$00@@QAEXXZ ENDP	; BaseVector<CvAStarNode *,1>::clear
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXPAPAVCvAStarNode@@I@Z ; FStaticVector<CvAStarNode *,6,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXPAPAVCvAStarNode@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXPAPAVCvAStarNode@@I@Z PROC ; FStaticVector<CvAStarNode *,6,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXPAPAVCvAStarNode@@I@Z ENDP ; FStaticVector<CvAStarNode *,6,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z	; UnitPathInitialize
EXTRN	?IsCanAttack@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanAttack
EXTRN	?CanEverEmbark@CvUnit@@QBE_NXZ:PROC		; CvUnit::CanEverEmbark
EXTRN	?isNoRevealMap@CvUnit@@QBE_NXZ:PROC		; CvUnit::isNoRevealMap
EXTRN	?IsImmobile@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsImmobile
EXTRN	?IsAutomated@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsAutomated
EXTRN	?isHuman@CvUnit@@QBE_NXZ:PROC			; CvUnit::isHuman
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
EXTRN	?maxMoves@CvUnit@@QBEHXZ:PROC			; CvUnit::maxMoves
EXTRN	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z:PROC	; CvUnit::baseMoves
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
;	COMDAT ?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_pointer$ = 8						; size = 4
_finder$ = 12						; size = 4
?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z PROC		; UnitPathInitialize, COMDAT

; 1072 : {

	push	ebx

; 1073 : 	CvUnit* pUnit = ((CvUnit*)pointer);
; 1074 : 
; 1075 : 	UnitPathCacheData* pCacheData = reinterpret_cast<UnitPathCacheData*>(finder->GetScratchBuffer());

	mov	ebx, DWORD PTR _finder$[esp]
	push	esi
	push	edi

; 1076 : 
; 1077 : 	for (int i = 0; i < NUM_DOMAIN_TYPES; ++i)

	mov	edi, DWORD PTR _pointer$[esp+8]
	xor	esi, esi
	npad	3
$LL3@UnitPathIn:

; 1078 : 	{
; 1079 : 		pCacheData->m_aBaseMoves[i] = pUnit->baseMoves((DomainTypes)i);

	push	esi
	mov	ecx, edi
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves
	mov	DWORD PTR [ebx+esi*4+116], eax
	inc	esi
	cmp	esi, 5
	jl	SHORT $LL3@UnitPathIn

; 1080 : 	}
; 1081 : 
; 1082 : 	pCacheData->m_iMaxMoves = pUnit->maxMoves();

	mov	ecx, edi
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	mov	DWORD PTR [ebx+136], eax

; 1083 : 
; 1084 : 	pCacheData->m_ePlayerID = pUnit->getOwner();

	mov	eax, DWORD PTR [edi+40]

; 1085 : 	pCacheData->m_eTeamID = pUnit->getTeam();

	mov	ecx, edi
	mov	DWORD PTR [ebx+140], eax
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam

; 1086 : 	pCacheData->m_eDomainType = pUnit->getDomainType();

	mov	ecx, edi
	mov	DWORD PTR [ebx+144], eax
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 1087 : 	pCacheData->m_bIsHuman = pUnit->isHuman();

	mov	ecx, edi
	mov	DWORD PTR [ebx+148], eax
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman

; 1088 : 	pCacheData->m_bIsAutomated = pUnit->IsAutomated();

	mov	ecx, edi
	mov	BYTE PTR [ebx+152], al
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated

; 1089 : 	pCacheData->m_bIsImmobile = pUnit->IsImmobile();

	mov	ecx, edi
	mov	BYTE PTR [ebx+153], al
	call	?IsImmobile@CvUnit@@QBE_NXZ		; CvUnit::IsImmobile

; 1090 : 	pCacheData->m_bIsNoRevealMap = pUnit->isNoRevealMap();

	mov	ecx, edi
	mov	BYTE PTR [ebx+154], al
	call	?isNoRevealMap@CvUnit@@QBE_NXZ		; CvUnit::isNoRevealMap

; 1091 : 	pCacheData->m_bCanEverEmbark = pUnit->CanEverEmbark();

	mov	ecx, edi
	mov	BYTE PTR [ebx+155], al
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	mov	BYTE PTR [ebx+156], al

; 1092 : 	pCacheData->m_bIsEmbarked = pUnit->isEmbarked();

	mov	cl, BYTE PTR [edi+1652]
	mov	BYTE PTR [ebx+157], cl

; 1093 : 	pCacheData->m_bCanAttack = pUnit->IsCanAttack();

	mov	ecx, edi
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	pop	edi
	pop	esi
	mov	BYTE PTR [ebx+158], al
	pop	ebx

; 1094 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH
; 1095 : 	pCacheData->m_iBaseCombatStrengthConsideringDamage = 0;
; 1096 : 	if (!pCacheData->m_bIsHuman || pCacheData->m_bIsAutomated)
; 1097 : 		pCacheData->m_iBaseCombatStrengthConsideringDamage = pUnit->GetBaseCombatStrengthConsideringDamage();
; 1098 : #endif
; 1099 : }

	ret	0
?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z ENDP		; UnitPathInitialize
_TEXT	ENDS
PUBLIC	?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z		; PathDestValid
EXTRN	?canMoveOrAttackInto@CvUnit@@QBE_NABVCvPlot@@E@Z:PROC ; CvUnit::canMoveOrAttackInto
EXTRN	?IsDeclareWar@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsDeclareWar
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?IsAllowsWalkWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsAllowsWalkWater
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
; Function compile flags: /Ogtpy
;	COMDAT ?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_bMoveFlags$219714 = 8					; size = 1
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z PROC		; PathDestValid, COMDAT

; 1141 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1142 : 	CvPlot* pToPlot = GC.getMap().plotCheckInvalid(iToX, iToY);
; 1143 : #else
; 1144 : 	CvUnit* pUnit;
; 1145 : 	CvPlot* pToPlot;
; 1146 : 	bool bAIControl;
; 1147 : 
; 1148 : 	pToPlot = GC.getMap().plotCheckInvalid(iToX, iToY);

	mov	edx, DWORD PTR _iToX$[esp-4]
	push	ebp
	push	esi
	cmp	edx, -2147483647			; 80000001H
	je	SHORT $LN20@PathDestVa
	mov	ecx, DWORD PTR _iToY$[esp+4]
	cmp	ecx, -2147483647			; 80000001H
	je	SHORT $LN20@PathDestVa
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [eax+4020]
	imul	esi, ecx
	add	esi, edx
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [eax+4068]
	jmp	SHORT $LN22@PathDestVa
$LN20@PathDestVa:
	xor	esi, esi
$LN22@PathDestVa:

; 1149 : #endif
; 1150 : 	FAssert(pToPlot != NULL);
; 1151 : 
; 1152 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1153 : 	CvUnit* pUnit = (CvUnit*)pointer;
; 1154 : #else
; 1155 : 	pUnit = ((CvUnit*)pointer);
; 1156 : #endif
; 1157 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());

	mov	ebp, DWORD PTR _finder$[esp+4]

; 1158 : 
; 1159 : 	if(pToPlot == NULL || pUnit == NULL)

	test	esi, esi
	je	SHORT $LN58@PathDestVa
	mov	ecx, DWORD PTR _pointer$[esp+4]
	test	ecx, ecx
	je	SHORT $LN58@PathDestVa

; 1160 : 		return FALSE;
; 1161 : 
; 1162 : 	if(pUnit->plot() == pToPlot)

	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, esi
	jne	SHORT $LN13@PathDestVa
	pop	esi

; 1163 : 	{
; 1164 : 		return TRUE;

	mov	eax, 1
	pop	ebp

; 1269 : }

	ret	0
$LN13@PathDestVa:

; 1165 : 	}
; 1166 : 
; 1167 : #ifndef ASTAR_AI_CONTROL_FIX_RADAR
; 1168 : 	if(pToPlot->isMountain() && (!pCacheData->isHuman() || pCacheData->IsAutomated()))
; 1169 : 	{
; 1170 : 		return FALSE;
; 1171 : 	}
; 1172 : #endif
; 1173 : 
; 1174 : 	if(pCacheData->IsImmobile())

	cmp	BYTE PTR [ebp+154], 0
	je	SHORT $LN12@PathDestVa
$LN58@PathDestVa:
	pop	esi

; 1175 : 	{
; 1176 : 		return FALSE;

	xor	eax, eax
	pop	ebp

; 1269 : }

	ret	0
$LN12@PathDestVa:

; 1177 : 	}
; 1178 : 
; 1179 : 	if ((finder->GetInfo() & CvUnit::MOVEFLAG_STAY_ON_LAND) && (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater()))

	test	DWORD PTR [ebp+72], 256			; 00000100H
	je	SHORT $LN11@PathDestVa
	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN11@PathDestVa
	mov	ecx, esi
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	test	al, al

; 1180 : 	{
; 1181 : 		return FALSE;

	je	SHORT $LN58@PathDestVa
$LN11@PathDestVa:
	push	edi

; 1182 : 	}
; 1183 : #ifndef ASTAR_AI_CONTROL_FIX_RADAR
; 1184 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1185 : 	bool bAIControl = pCacheData->IsAutomated();
; 1186 : #else
; 1187 : 	bAIControl = pCacheData->IsAutomated();
; 1188 : #endif
; 1189 : 
; 1190 : 	if(bAIControl)
; 1191 : 	{
; 1192 : #ifndef AUI_ASTAR_FIX_CONSIDER_DANGER_ONLY_PATH
; 1193 : 		if(!(finder->GetInfo() & MOVE_UNITS_IGNORE_DANGER))
; 1194 : 		{
; 1195 : 			if(!pUnit->IsCombatUnit() || pUnit->getArmyID() == FFreeList::INVALID_INDEX)
; 1196 : 			{
; 1197 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH
; 1198 : 				if (GET_PLAYER(pUnit->getOwner()).GetPlotDanger(*pToPlot) > pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 1199 : #else
; 1200 : 				if(GET_PLAYER(pUnit->getOwner()).GetPlotDanger(*pToPlot) > 0)
; 1201 : #endif
; 1202 : 				{
; 1203 : 					return FALSE;
; 1204 : 				}
; 1205 : 			}
; 1206 : 		}
; 1207 : #endif
; 1208 : 
; 1209 : 		if(pCacheData->getDomainType() == DOMAIN_LAND)
; 1210 : 		{
; 1211 : 			int iGroupAreaID = pUnit->area()->GetID();
; 1212 : 			if(pToPlot->getArea() != iGroupAreaID)
; 1213 : 			{
; 1214 : 				if(!(pToPlot->isAdjacentToArea(iGroupAreaID)) && !pUnit->CanEverEmbark())
; 1215 : 				{
; 1216 : 					return FALSE;
; 1217 : 				}
; 1218 : 			}
; 1219 : 		}
; 1220 : 	}
; 1221 : #endif
; 1222 : 	TeamTypes eTeam = pCacheData->getTeam();

	mov	edi, DWORD PTR [ebp+144]

; 1223 : 	bool bToPlotRevealed = pToPlot->isRevealed(eTeam);

	push	edi
	mov	ecx, esi
	call	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isRevealed

; 1224 : 	if(!bToPlotRevealed)

	test	al, al
	jne	SHORT $LN54@PathDestVa

; 1225 : 	{
; 1226 : 		if(pCacheData->isNoRevealMap())

	cmp	BYTE PTR [ebp+155], al
	je	SHORT $LN1@PathDestVa
$LN57@PathDestVa:
	pop	edi
	pop	esi

; 1227 : 		{
; 1228 : 			return FALSE;

	xor	eax, eax
	pop	ebp

; 1269 : }

	ret	0
$LN54@PathDestVa:

; 1229 : 		}
; 1230 : 	}
; 1231 : 
; 1232 : 	if(bToPlotRevealed)
; 1233 : 	{
; 1234 : 		CvCity* pCity = pToPlot->getPlotCity();

	mov	ecx, esi
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity

; 1235 : 		if(pCity)

	test	eax, eax
	je	SHORT $LN6@PathDestVa

; 1236 : 		{
; 1237 : 			if(pCacheData->getOwner() != pCity->getOwner() && !GET_TEAM(eTeam).isAtWar(pCity->getTeam()) && !(finder->GetInfo() & MOVE_IGNORE_STACKING))

	mov	ecx, DWORD PTR [ebp+140]
	cmp	ecx, DWORD PTR [eax+84]
	je	SHORT $LN6@PathDestVa
	imul	edi, 2980				; 00000ba4H
	add	edi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, edi
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	SHORT $LN6@PathDestVa
	test	BYTE PTR [ebp+72], 4

; 1238 : 			{
; 1239 : 				return FALSE;

	je	SHORT $LN57@PathDestVa
$LN6@PathDestVa:

; 1240 : 			}
; 1241 : 		}
; 1242 : 	}
; 1243 : 
; 1244 : #ifdef ASTAR_AI_CONTROL_FIX_RADAR
; 1245 : 	if(bToPlotRevealed)
; 1246 : #else
; 1247 : 	if(bAIControl || bToPlotRevealed)
; 1248 : #endif
; 1249 : 	{
; 1250 : 		// assume that we can change our embarking state
; 1251 : 		byte bMoveFlags = CvUnit::MOVEFLAG_DESTINATION | CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE;
; 1252 : 
; 1253 : 		if((pUnit->IsDeclareWar() || (finder->GetInfo() & MOVE_DECLARE_WAR)))

	mov	edi, DWORD PTR _pointer$[esp+8]
	mov	ecx, edi
	mov	BYTE PTR _bMoveFlags$219714[esp+8], 132	; 00000084H
	call	?IsDeclareWar@CvUnit@@QBE_NXZ		; CvUnit::IsDeclareWar
	test	al, al
	jne	SHORT $LN3@PathDestVa
	test	BYTE PTR [ebp+72], 32			; 00000020H
	je	SHORT $LN55@PathDestVa
$LN3@PathDestVa:

; 1254 : 		{
; 1255 : 			bMoveFlags |= CvUnit::MOVEFLAG_ATTACK;

	mov	BYTE PTR _bMoveFlags$219714[esp+8], 133	; 00000085H
$LN55@PathDestVa:

; 1256 : 		}
; 1257 : 
; 1258 : 		if(finder->GetInfo() & MOVE_IGNORE_STACKING)

	test	BYTE PTR [ebp+72], 4
	je	SHORT $LN2@PathDestVa

; 1259 : 		{
; 1260 : 			bMoveFlags |= CvUnit::MOVEFLAG_IGNORE_STACKING;

	or	BYTE PTR _bMoveFlags$219714[esp+8], 16	; 00000010H
$LN2@PathDestVa:

; 1261 : 		}
; 1262 : 
; 1263 : 		if(!(pUnit->canMoveOrAttackInto(*pToPlot, bMoveFlags)))

	mov	edx, DWORD PTR _bMoveFlags$219714[esp+8]
	push	edx
	push	esi
	mov	ecx, edi
	call	?canMoveOrAttackInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveOrAttackInto
	test	al, al

; 1264 : 		{
; 1265 : 			return FALSE;

	je	SHORT $LN57@PathDestVa
$LN1@PathDestVa:
	pop	edi
	pop	esi

; 1266 : 		}
; 1267 : 	}
; 1268 : 	return TRUE;

	mov	eax, 1
	pop	ebp

; 1269 : }

	ret	0
?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z ENDP		; PathDestValid
_TEXT	ENDS
PUBLIC	?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathCost
EXTRN	?isRiverCrossingNoPenalty@CvUnit@@QBE_NXZ:PROC	; CvUnit::isRiverCrossingNoPenalty
EXTRN	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z:PROC ; CvPlot::isRiverCrossing
EXTRN	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z:PROC ; CvPlot::isVisibleEnemyDefender
EXTRN	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z:PROC ; CvPlot::defenseModifier
EXTRN	?noDefensiveBonus@CvUnit@@QBE_NXZ:PROC		; CvUnit::noDefensiveBonus
EXTRN	?getNumAdjacentNonrevealed@CvPlot@@QBEHW4TeamTypes@@@Z:PROC ; CvPlot::getNumAdjacentNonrevealed
EXTRN	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsAllowsOpenBordersToTeam
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?isHasPromotion@CvUnit@@QBE_NW4PromotionTypes@@@Z:PROC ; CvUnit::isHasPromotion
EXTRN	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z:PROC ; CvPlot::getNumFriendlyUnitsOfType
EXTRN	?getExtraMovePathCost@CvPlot@@QBEHXZ:PROC	; CvPlot::getExtraMovePathCost
EXTRN	?getTurnDamage@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getTurnDamage
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z:PROC ; CvUnit::canEmbarkOnto
EXTRN	?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z:PROC ; CvUnitMovement::MovementCost
EXTRN	?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z:PROC ; CvUnitMovement::IsSlowedByZOC
EXTRN	?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z:PROC ; CvUnitMovement::ConsumesAllMoves
; Function compile flags: /Ogtpy
;	COMDAT ?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_eUnitTeam$ = -40					; size = 4
_iMovesLeft$ = -36					; size = 4
_kMap$ = -32						; size = 4
_eUnitDomain$ = -28					; size = 4
$T223231 = -24						; size = 4
$T223232 = -20						; size = 4
_iToPlotY$ = -16					; size = 4
_iToPlotX$ = -12					; size = 4
_iFromPlotY$ = -8					; size = 4
_iFromPlotX$ = -4					; size = 4
$T223242 = 8						; size = 4
$T223235 = 8						; size = 4
_bToPlotIsWater$ = 8					; size = 1
_parent$ = 8						; size = 4
tv966 = 12						; size = 4
$T223238 = 12						; size = 4
_bMaximizeExplore$ = 12					; size = 1
_node$ = 12						; size = 4
_data$ = 16						; size = 4
$T223239 = 20						; size = 4
_pointer$ = 20						; size = 4
_iCost$ = 24						; size = 4
_finder$ = 24						; size = 4
?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; PathCost, COMDAT

; 1282 : {

	sub	esp, 40					; 00000028H

; 1283 : 	CvMap& kMap = GC.getMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 1284 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 1285 : 	const CvPlot* pFromPlot = parent->m_pPlot;
; 1286 : 	const CvPlot* pToPlot = node->m_pPlot;
; 1287 : 
; 1288 : 	const int iFromPlotX = parent->m_iX;
; 1289 : 	const int iFromPlotY = parent->m_iY;
; 1290 : 	const int iToPlotX = node->m_iX;
; 1291 : 	const int iToPlotY = node->m_iY;
; 1292 : #else
; 1293 : 	int iFromPlotX = parent->m_iX;
; 1294 : 	int iFromPlotY = parent->m_iY;
; 1295 : 	CvPlot* pFromPlot = kMap.plotUnchecked(iFromPlotX, iFromPlotY);

	mov	eax, DWORD PTR [ecx+4020]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _parent$[esp+52]
	movsx	ebx, WORD PTR [edi+82]
	movsx	edx, WORD PTR [edi+80]
	mov	esi, eax
	imul	esi, ebx
	add	esi, edx
	mov	DWORD PTR _iFromPlotX$[esp+56], edx
	imul	esi, 484				; 000001e4H

; 1296 : 
; 1297 : 	int iToPlotX = node->m_iX;

	mov	edx, DWORD PTR _node$[esp+52]
	mov	DWORD PTR _iFromPlotY$[esp+56], ebx
	movsx	ebx, WORD PTR [edx+80]

; 1298 : 	int iToPlotY = node->m_iY;

	movsx	edx, WORD PTR [edx+82]

; 1299 : 	CvPlot* pToPlot = kMap.plotUnchecked(iToPlotX, iToPlotY);
; 1300 : #endif
; 1301 : 
; 1302 : 	CvUnit* pUnit = ((CvUnit*)pointer);
; 1303 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());

	mov	ebp, DWORD PTR _finder$[esp+52]
	imul	eax, edx
	add	eax, ebx
	imul	eax, 484				; 000001e4H
	mov	DWORD PTR _kMap$[esp+56], ecx
	mov	ecx, DWORD PTR [ecx+4068]
	add	eax, ecx
	mov	DWORD PTR _iToPlotX$[esp+56], ebx
	mov	ebx, eax

; 1304 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1305 : 	bool bIsAIControl = !pCacheData->isHuman() || pCacheData->IsAutomated();
; 1306 : #endif
; 1307 : 
; 1308 : 	DomainTypes eUnitDomain = pCacheData->getDomainType();

	mov	eax, DWORD PTR [ebp+148]
	add	esi, ecx

; 1309 : 
; 1310 : 	CvAssertMsg(eUnitDomain != DOMAIN_AIR, "pUnit->getDomainType() is not expected to be equal with DOMAIN_AIR");
; 1311 : 
; 1312 : #if defined(AUI_ASTAR_MINOR_OPTIMIZATION) || defined (AUI_UNIT_FIX_HOVERING_EMBARK) || defined(AUI_UNIT_MOVEMENT_FIX_BAD_ALLOWS_WATER_WALK_CHECK)
; 1313 : 	bool bToPlotIsWater = !pToPlot->IsAllowsWalkWater();
; 1314 : 	bool bFromPlotIsWater = !pFromPlot->IsAllowsWalkWater();
; 1315 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 1316 : 	if (pUnit->IsHoveringUnit())
; 1317 : 	{
; 1318 : 		bToPlotIsWater = bToPlotIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 1319 : 		bFromPlotIsWater = bFromPlotIsWater && pFromPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 1320 : 	}
; 1321 : 	else
; 1322 : #endif
; 1323 : 	{
; 1324 : 		bToPlotIsWater = bToPlotIsWater && pToPlot->isWater();
; 1325 : 		bFromPlotIsWater = bFromPlotIsWater && pFromPlot->isWater();
; 1326 : 	}
; 1327 : 	int iBaseMoves = pCacheData->baseMoves(bFromPlotIsWater || pCacheData->isEmbarked() ? DOMAIN_SEA : pCacheData->getDomainType());
; 1328 : 	int iMaxMoves = iBaseMoves * GC.getMOVE_DENOMINATOR();
; 1329 : #else
; 1330 : 	bool bToPlotIsWater = pToPlot->isWater() && !pToPlot->IsAllowsWalkWater();

	cmp	BYTE PTR [ebx+5], 3
	mov	DWORD PTR _iToPlotY$[esp+56], edx
	mov	DWORD PTR _eUnitDomain$[esp+56], eax
	jne	SHORT $LN42@PathCost
	mov	ecx, ebx
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	mov	BYTE PTR _bToPlotIsWater$[esp+52], 1
	test	al, al
	je	SHORT $LN43@PathCost
$LN42@PathCost:
	mov	BYTE PTR _bToPlotIsWater$[esp+52], 0
$LN43@PathCost:

; 1331 : #endif
; 1332 : 	int iMax;
; 1333 : 	if(parent->m_iData1 > 0)

	mov	edi, DWORD PTR [edi+12]
	test	edi, edi

; 1334 : 	{
; 1335 : 		iMax = parent->m_iData1;
; 1336 : 	}
; 1337 : 	else

	jg	SHORT $LN35@PathCost

; 1338 : 	{
; 1339 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1340 : 		iMax = iMaxMoves;
; 1341 : #else
; 1342 : 		if (CvUnitMovement::ConsumesAllMoves(pUnit, pFromPlot, pToPlot) || CvUnitMovement::IsSlowedByZOC(pUnit, pFromPlot, pToPlot))

	mov	edi, DWORD PTR _pointer$[esp+52]
	push	ebx
	push	esi
	push	edi
	call	?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::ConsumesAllMoves
	add	esp, 12					; 0000000cH
	test	al, al
	jne	SHORT $LN36@PathCost
	push	ebx
	push	esi
	push	edi
	call	?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::IsSlowedByZOC
	add	esp, 12					; 0000000cH
	test	al, al
	jne	SHORT $LN36@PathCost

; 1348 : 		}
; 1349 : 		else
; 1350 : 			iMax = pCacheData->baseMoves(bToPlotIsWater?DOMAIN_SEA:DOMAIN_LAND) * GC.getMOVE_DENOMINATOR();

	xor	ecx, ecx
	cmp	BYTE PTR _bToPlotIsWater$[esp+52], cl
	setne	cl
	dec	ecx
	and	ecx, 2
	mov	edi, DWORD PTR [ebp+ecx*4+116]
	jmp	SHORT $LN230@PathCost
$LN36@PathCost:

; 1343 : 		{
; 1344 : 			// The movement would consume all moves, get the moves we will forfeit based on the source plot, rather than
; 1345 : 			// the destination plot.  This fixes issues where a land unit that has more movement points on water than on land
; 1346 : 			// would have a very high cost to move onto water if their first move of the turn was at the edge of the water.
; 1347 : 			iMax = pCacheData->baseMoves((pFromPlot->isWater() && !pFromPlot->IsAllowsWalkWater())?DOMAIN_SEA:DOMAIN_LAND) * GC.getMOVE_DENOMINATOR();

	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN44@PathCost
	mov	ecx, esi
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	test	al, al
	jne	SHORT $LN44@PathCost
	xor	eax, eax
	jmp	SHORT $LN45@PathCost
$LN44@PathCost:
	mov	eax, 2
$LN45@PathCost:
	mov	edi, DWORD PTR [ebp+eax*4+116]
$LN230@PathCost:
	imul	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
$LN35@PathCost:

; 1351 : #endif
; 1352 : 	}
; 1353 : 
; 1354 : 	// Get the cost of moving to the new plot, passing in our max moves or the moves we have left, in case the movementCost 
; 1355 : 	// method wants to burn all our remaining moves.  This is needed because our remaining moves for this segment of the path
; 1356 : 	// may be larger or smaller than the baseMoves if some moves have already been used or if the starting domain (LAND/SEA)
; 1357 : 	// of the path segment is different from the destination plot.
; 1358 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1359 : 	int iCost = CvUnitMovement::MovementCost(pUnit, pFromPlot, pToPlot, iBaseMoves, iMaxMoves, iMax);
; 1360 : #else
; 1361 : 	int iCost = CvUnitMovement::MovementCost(pUnit, pFromPlot, pToPlot, pCacheData->baseMoves((pToPlot->isWater() || pCacheData->isEmbarked())?DOMAIN_SEA:pCacheData->getDomainType()), pCacheData->maxMoves(), iMax);

	cmp	BYTE PTR [ebx+5], 3
	je	SHORT $LN46@PathCost
	cmp	BYTE PTR [ebp+157], 0
	jne	SHORT $LN46@PathCost
	mov	ecx, DWORD PTR [ebp+148]
	jmp	SHORT $LN47@PathCost
$LN46@PathCost:
	xor	ecx, ecx
$LN47@PathCost:
	mov	eax, DWORD PTR [ebp+136]
	mov	ecx, DWORD PTR [ebp+ecx*4+116]
	mov	edx, DWORD PTR _pointer$[esp+52]
	push	edi
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edx
	call	?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCost

; 1362 : #endif
; 1363 : 
; 1364 : 	TeamTypes eUnitTeam = pCacheData->getTeam();

	mov	ecx, DWORD PTR [ebp+144]
	mov	DWORD PTR _eUnitTeam$[esp+80], ecx

; 1365 : #ifdef AUI_ASTAR_EXPLORE_UNITAITYPE_ALWAYS_MAXIMIZES_EXPLORE
; 1366 : 	bool bMaximizeExplore = finder->GetInfo() & MOVE_MAXIMIZE_EXPLORE || pUnit->AI_getUnitAIType() == UNITAI_EXPLORE || pUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA;
; 1367 : #else
; 1368 : 	bool bMaximizeExplore = finder->GetInfo() & MOVE_MAXIMIZE_EXPLORE;

	mov	ecx, DWORD PTR [ebp+72]
	shr	ecx, 7
	and	cl, 1
	mov	BYTE PTR _bMaximizeExplore$[esp+76], cl

; 1369 : #endif
; 1370 : 
; 1371 : 	int iMovesLeft = iMax - iCost;

	mov	ecx, edi
	add	esp, 24					; 00000018H
	sub	ecx, eax
	mov	DWORD PTR _iMovesLeft$[esp+56], ecx

; 1372 : 	// Is the cost greater than our max?
; 1373 : 	if (iMovesLeft < 0)

	jns	SHORT $LN34@PathCost

; 1374 : 	{
; 1375 : 		// Yes, we will still let the move happen, but that is the end of the turn.
; 1376 : 		iCost = iMax;

	mov	eax, edi

; 1377 : 		iMovesLeft = 0;

	mov	DWORD PTR _iMovesLeft$[esp+56], 0

; 1378 : 	}
; 1379 : 
; 1380 : 	if(iMovesLeft == 0)

	jmp	SHORT $LN221@PathCost
$LN34@PathCost:
	cmp	DWORD PTR _iMovesLeft$[esp+56], 0
	jne	$LN33@PathCost
$LN221@PathCost:

; 1381 : 	{
; 1382 : 		iCost = (PATH_MOVEMENT_WEIGHT * iCost);

	imul	eax, 1000				; 000003e8H

; 1383 : 
; 1384 : #ifdef AUI_UNIT_MOVEMENT_FIX_BAD_ALLOWS_WATER_WALK_CHECK
; 1385 : 		if (eUnitDomain == DOMAIN_LAND && !bFromPlotIsWater && bToPlotIsWater && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))
; 1386 : #else
; 1387 : 		if(eUnitDomain == DOMAIN_LAND && !pFromPlot->isWater() && bToPlotIsWater && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))

	cmp	DWORD PTR _eUnitDomain$[esp+56], 2
	mov	DWORD PTR _iCost$[esp+52], eax
	jne	SHORT $LN223@PathCost
	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN223@PathCost
	cmp	BYTE PTR _bToPlotIsWater$[esp+52], 0
	je	SHORT $LN223@PathCost
	mov	ecx, DWORD PTR _pointer$[esp+52]
	push	0
	push	1
	push	ebx
	push	esi
	call	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z ; CvUnit::canEmbarkOnto
	test	al, al
	jne	SHORT $LN223@PathCost

; 1388 : #endif
; 1389 : 		{
; 1390 : 			iCost += PATH_INCORRECT_EMBARKING_WEIGHT;

	add	DWORD PTR _iCost$[esp+52], 1000000	; 000f4240H
$LN223@PathCost:

; 1391 : 		}
; 1392 : 
; 1393 : 		if(bMaximizeExplore)

	cmp	BYTE PTR _bMaximizeExplore$[esp+52], 0
	je	SHORT $LN30@PathCost

; 1394 : 		{
; 1395 : #ifdef AUI_ASTAR_FIX_MAXIMIZE_EXPLORE_UNHARDCODE_HILL_PREFERENCE
; 1396 : 			iCost += PATH_EXPLORE_NON_HILL_WEIGHT * (2 - pToPlot->seeFromLevel(eUnitTeam));
; 1397 : #else
; 1398 : 			if(!pToPlot->isHills())

	cmp	BYTE PTR [ebx+5], 1
	je	SHORT $LN30@PathCost

; 1399 : 			{
; 1400 : 				iCost += PATH_EXPLORE_NON_HILL_WEIGHT;

	add	DWORD PTR _iCost$[esp+52], 300		; 0000012cH
$LN30@PathCost:

; 1401 : 			}
; 1402 : #endif
; 1403 : 		}
; 1404 : 
; 1405 : 		// Damage caused by features (mods)
; 1406 : 		if(0 != GC.getPATH_DAMAGE_WEIGHT())

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6944, 0
	je	SHORT $LN27@PathCost

; 1407 : 		{
; 1408 : 			if(pToPlot->getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [ebx+432]
	cmp	al, -1
	je	SHORT $LN224@PathCost

; 1409 : 			{
; 1410 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1411 : 				iCost += (GC.getPATH_DAMAGE_WEIGHT() * MAX(0, GC.getFeatureInfo(pToPlot->getFeatureType())->getTurnDamage())) / GC.getMAX_HIT_POINTS();
; 1412 : #else
; 1413 : 				iCost += (GC.getPATH_DAMAGE_WEIGHT() * std::max(0, GC.getFeatureInfo(pToPlot->getFeatureType())->getTurnDamage())) / GC.getMAX_HIT_POINTS();

	movsx	edx, al
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getTurnDamage@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getTurnDamage
	mov	DWORD PTR $T223231[esp+56], eax
	test	eax, eax
	mov	DWORD PTR $T223232[esp+56], 0
	lea	eax, DWORD PTR $T223231[esp+56]
	jg	SHORT $LN117@PathCost
	lea	eax, DWORD PTR $T223232[esp+56]
$LN117@PathCost:
	mov	eax, DWORD PTR [eax]
	imul	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6944
	cdq
	idiv	DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	add	DWORD PTR _iCost$[esp+52], eax
$LN224@PathCost:

; 1414 : #endif
; 1415 : 			}
; 1416 : 
; 1417 : 			if(pToPlot->getExtraMovePathCost() > 0)

	mov	ecx, ebx
	call	?getExtraMovePathCost@CvPlot@@QBEHXZ	; CvPlot::getExtraMovePathCost
	test	eax, eax
	jle	SHORT $LN27@PathCost

; 1418 : 			{
; 1419 : 				iCost += (PATH_MOVEMENT_WEIGHT * pToPlot->getExtraMovePathCost());

	mov	ecx, ebx
	call	?getExtraMovePathCost@CvPlot@@QBEHXZ	; CvPlot::getExtraMovePathCost
	imul	eax, 1000				; 000003e8H
	add	DWORD PTR _iCost$[esp+52], eax
$LN27@PathCost:

; 1420 : 			}
; 1421 : 		}
; 1422 : 
; 1423 : 		// Penalty for stacking
; 1424 : 		if(GC.getPLOT_UNIT_LIMIT() > 0 && !(finder->GetInfo() & MOVE_IGNORE_STACKING))

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7356
	test	edi, edi
	jle	SHORT $LN225@PathCost
	test	BYTE PTR [ebp+72], 4
	jne	SHORT $LN225@PathCost

; 1425 : 		{
; 1426 : 			// Check to see if any units are present at this full-turn move plot... if the player can see what's there
; 1427 : 			if(pToPlot->getNumFriendlyUnitsOfType(pUnit) >= GC.getPLOT_UNIT_LIMIT())

	mov	eax, DWORD PTR _pointer$[esp+52]
	push	1
	push	eax
	mov	ecx, ebx
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	cmp	eax, edi
	jl	SHORT $LN225@PathCost

; 1428 : 			{
; 1429 : 				iCost += PATH_STACKING_WEIGHT;

	add	DWORD PTR _iCost$[esp+52], 1000000	; 000f4240H
$LN225@PathCost:

; 1430 : 			}
; 1431 : 		}
; 1432 : 
; 1433 : 		// Penalty for ending a turn on a mountain
; 1434 : 		if(pToPlot->isMountain())

	cmp	BYTE PTR [ebx+5], 0
	jne	SHORT $LN226@PathCost

; 1435 : 		{
; 1436 : 			// We want to discourage AIs and automated units from exhausting their movement on a mountain, but if the unit is manually controlled by the human, let them do what they want.
; 1437 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1438 : 			if (bIsAIControl)
; 1439 : #else
; 1440 : 			if (!pCacheData->isHuman() || pCacheData->IsAutomated())

	cmp	BYTE PTR [ebp+152], 0
	je	SHORT $LN22@PathCost
	cmp	BYTE PTR [ebp+153], 0
	je	SHORT $LN226@PathCost
$LN22@PathCost:

; 1441 : #endif
; 1442 : 			{
; 1443 : 				iCost += PATH_END_TURN_MOUNTAIN_WEIGHT;

	add	DWORD PTR _iCost$[esp+52], 1000000	; 000f4240H
$LN226@PathCost:

; 1444 : 			}
; 1445 : #ifdef AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT
; 1446 : 			else
; 1447 : 			{
; 1448 : 				iCost += AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT + PATH_TERRITORY_WEIGHT;
; 1449 : 			}
; 1450 : #endif
; 1451 : 		}
; 1452 : 
; 1453 : 		if (pUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_UNWELCOME_EVANGELIST()))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8560
	push	ecx
	mov	ecx, DWORD PTR _pointer$[esp+56]
	call	?isHasPromotion@CvUnit@@QBE_NW4PromotionTypes@@@Z ; CvUnit::isHasPromotion
	test	al, al
	je	$LN21@PathCost

; 1454 : 		{
; 1455 : 			// Avoid being in a territory that we are not welcome in, unless the human is manually controlling the unit.
; 1456 : #ifndef AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT
; 1457 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1458 : 			if (bIsAIControl)
; 1459 : #else
; 1460 : 			if (!pCacheData->isHuman() || pCacheData->IsAutomated())

	cmp	BYTE PTR [ebp+152], 0
	je	SHORT $LN19@PathCost
	cmp	BYTE PTR [ebp+153], 0
	je	$LN227@PathCost
$LN19@PathCost:

; 1461 : #endif
; 1462 : #endif
; 1463 : 			{
; 1464 : 				// Also, ignore the penalty if the destination of the path is in the same team's territory, no sense in avoiding a place we want to get to.				
; 1465 : 				PlayerTypes ePlotOwner = pToPlot->getOwner();
; 1466 : 				CvPlot* pDestPlot = (finder->GetDestX() >= 0 && finder->GetDestY() >= 0)?kMap.plotCheckInvalid(finder->GetDestX(), finder->GetDestY()):NULL;

	mov	ecx, DWORD PTR [ebp+64]
	movsx	edx, BYTE PTR [ebx+4]
	test	ecx, ecx
	jl	SHORT $LN48@PathCost
	mov	edi, DWORD PTR [ebp+68]
	test	edi, edi
	jl	SHORT $LN48@PathCost
	cmp	ecx, -2147483647			; 80000001H
	je	SHORT $LN48@PathCost
	cmp	edi, -2147483647			; 80000001H
	je	SHORT $LN48@PathCost
	mov	eax, DWORD PTR _kMap$[esp+56]
	mov	eax, DWORD PTR [eax+4020]
	imul	eax, edi
	add	eax, ecx
	mov	ecx, DWORD PTR _kMap$[esp+56]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	jmp	SHORT $LN49@PathCost
$LN48@PathCost:
	xor	eax, eax
$LN49@PathCost:

; 1467 : 				if (!pDestPlot || pDestPlot->getOwner() != ePlotOwner)

	test	eax, eax
	je	SHORT $LN17@PathCost
	movsx	eax, BYTE PTR [eax+4]
	cmp	eax, edx
	je	$LN227@PathCost
$LN17@PathCost:

; 1468 : 				{
; 1469 : 					TeamTypes ePlotTeam = pToPlot->getTeam();

	cmp	edx, -1
	je	SHORT $LN159@PathCost
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN159@PathCost
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	eax, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN158@PathCost
$LN159@PathCost:
	or	edi, -1
$LN158@PathCost:

; 1470 : 					if (ePlotOwner != NO_PLAYER && !GET_PLAYER(ePlotOwner).isMinorCiv() && ePlotTeam != pCacheData->getTeam() && !GET_TEAM(ePlotTeam).IsAllowsOpenBordersToTeam(pCacheData->getTeam()))

	cmp	edx, -1
	je	SHORT $LN227@PathCost
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, edx
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN227@PathCost
	mov	eax, DWORD PTR [ebp+144]
	cmp	edi, eax
	je	SHORT $LN227@PathCost
	imul	edi, 2980				; 00000ba4H
	add	edi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	mov	ecx, edi
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	test	al, al
	jne	SHORT $LN227@PathCost

; 1471 : 					{
; 1472 : #ifdef AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT
; 1473 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1474 : 						if (bIsAIControl)
; 1475 : #else
; 1476 : 						if (!pCacheData->isHuman() || pCacheData->IsAutomated())
; 1477 : #endif
; 1478 : 						{
; 1479 : 							iCost += PATH_END_TURN_MISSIONARY_OTHER_TERRITORY;
; 1480 : 						}
; 1481 : 						else
; 1482 : 						{
; 1483 : 							iCost += AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT + PATH_TERRITORY_WEIGHT;
; 1484 : 						}
; 1485 : #else
; 1486 : 						iCost += PATH_END_TURN_MISSIONARY_OTHER_TERRITORY;

	add	DWORD PTR _iCost$[esp+52], 150000	; 000249f0H

; 1487 : #endif
; 1488 : 					}
; 1489 : 				}
; 1490 : 			}
; 1491 : 		}
; 1492 : 		else

	jmp	SHORT $LN227@PathCost
$LN21@PathCost:

; 1493 : 		{
; 1494 : 			if(pToPlot->getTeam() != eUnitTeam)

	movsx	eax, BYTE PTR [ebx+4]
	cmp	eax, -1
	je	SHORT $LN180@PathCost
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN180@PathCost
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN179@PathCost
$LN180@PathCost:
	or	eax, -1
$LN179@PathCost:
	cmp	eax, DWORD PTR _eUnitTeam$[esp+56]
	je	SHORT $LN227@PathCost

; 1495 : 			{
; 1496 : 				iCost += PATH_TERRITORY_WEIGHT;

	add	DWORD PTR _iCost$[esp+52], 3

; 1497 : 			}
; 1498 : 		}
; 1499 : 
; 1500 : #if PATH_CITY_AVOID_WEIGHT != 0
; 1501 : 		if(pToPlot->getPlotCity() && !(pToPlot->getX() == finder->GetDestX() && pToPlot->getY() == finder->GetDestY()))
; 1502 : 		{
; 1503 : 			iCost += PATH_CITY_AVOID_WEIGHT; // slewis - this should be zeroed out currently
; 1504 : 		}
; 1505 : #endif
; 1506 : 	}
; 1507 : 	else

	jmp	SHORT $LN227@PathCost
$LN33@PathCost:

; 1508 : 	{
; 1509 : 		iCost = (PATH_MOVEMENT_WEIGHT * iCost);

	imul	eax, 1000				; 000003e8H
	mov	DWORD PTR _iCost$[esp+52], eax
$LN227@PathCost:

; 1510 : 	}
; 1511 : 
; 1512 : 	if(bMaximizeExplore)

	cmp	BYTE PTR _bMaximizeExplore$[esp+52], 0
	je	SHORT $LN228@PathCost

; 1513 : 	{
; 1514 : #ifdef AUI_ASTAR_FIX_MAXIMIZE_EXPLORE_CONSIDER_2ND_RING_NONREVEALED
; 1515 : 		int iUnseenPlots = pToPlot->getNumNonrevealedInRange(eUnitTeam, pToPlot->seeFromLevel(eUnitTeam));
; 1516 : #else
; 1517 : 		int iUnseenPlots = pToPlot->getNumAdjacentNonrevealed(eUnitTeam);

	mov	edi, DWORD PTR _eUnitTeam$[esp+56]
	push	edi
	mov	ecx, ebx
	call	?getNumAdjacentNonrevealed@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::getNumAdjacentNonrevealed

; 1518 : #endif
; 1519 : 		if(!pToPlot->isRevealed(eUnitTeam))

	mov	edx, edi
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	DWORD PTR tv966[esp+52], ecx
	mov	ecx, edi
	mov	edi, DWORD PTR tv966[esp+52]
	sub	ecx, edi
	mov	edi, 1
	shl	edi, cl
	test	edi, DWORD PTR [ebx+edx*4+8]
	jne	SHORT $LN11@PathCost

; 1520 : 		{
; 1521 : 			iUnseenPlots += 1;

	inc	eax
$LN11@PathCost:

; 1522 : 		}
; 1523 : 
; 1524 : 		iCost += (7 - iUnseenPlots) * PATH_EXPLORE_NON_REVEAL_WEIGHT;

	mov	ecx, 7
	sub	ecx, eax
	mov	eax, DWORD PTR _iCost$[esp+52]
	lea	edx, DWORD PTR [ecx+ecx*4]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _iCost$[esp+52], ecx
$LN228@PathCost:

; 1525 : 	}
; 1526 : 
; 1527 : 	// If we are a land unit and we are moving through the water, make the cost a little higher so that
; 1528 : 	// we favor staying on land or getting back to land as quickly as possible because it is dangerous to
; 1529 : 	// be on the water.  Don't add this penalty if the unit is human controlled however, we will assume they want
; 1530 : 	// the best path, rather than the safest.
; 1531 : #ifdef AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT
; 1532 : 	if (eUnitDomain == DOMAIN_LAND && bToPlotIsWater)
; 1533 : 	{
; 1534 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1535 : 		if (bIsAIControl)
; 1536 : #else
; 1537 : 		if (!pCacheData->isHuman() || pCacheData->IsAutomated())
; 1538 : #endif
; 1539 : 		{
; 1540 : 			iCost += PATH_THROUGH_WATER;
; 1541 : 		}
; 1542 : 		else
; 1543 : 		{
; 1544 : 			iCost += AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT + PATH_TERRITORY_WEIGHT;
; 1545 : 		}
; 1546 : 	}
; 1547 : #else
; 1548 : 	if(eUnitDomain == DOMAIN_LAND && bToPlotIsWater && (!pCacheData->isHuman() || pCacheData->IsAutomated()))

	cmp	DWORD PTR _eUnitDomain$[esp+56], 2
	jne	SHORT $LN10@PathCost
	cmp	BYTE PTR _bToPlotIsWater$[esp+52], 0
	je	SHORT $LN10@PathCost
	cmp	BYTE PTR [ebp+152], 0
	je	SHORT $LN9@PathCost
	cmp	BYTE PTR [ebp+153], 0
	je	SHORT $LN10@PathCost
$LN9@PathCost:

; 1549 : 	{
; 1550 : 		iCost += PATH_THROUGH_WATER;

	add	DWORD PTR _iCost$[esp+52], 1000		; 000003e8H
$LN10@PathCost:

; 1551 : 	}
; 1552 : #endif
; 1553 : 
; 1554 : 	if(pUnit->IsCombatUnit())

	mov	edx, DWORD PTR _pointer$[esp+52]
	cmp	DWORD PTR [edx+1044], 0
	jle	$LN1@PathCost

; 1555 : 	{
; 1556 : #if defined(AUI_ASTAR_AVOID_RIVER_CROSSING_WHEN_ATTACKING) || defined(AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING)
; 1557 : 		bool bToPlotHasEnemy = pToPlot->isVisibleEnemyDefender(pUnit) || pToPlot->isEnemyCity(*pUnit);
; 1558 : 		if (iMovesLeft == 0 && !bToPlotHasEnemy)
; 1559 : #else
; 1560 : 		if(iMovesLeft == 0)

	cmp	DWORD PTR _iMovesLeft$[esp+56], 0
	jne	SHORT $LN229@PathCost

; 1561 : #endif
; 1562 : 		{
; 1563 : #ifdef AUI_ASTAR_FIX_DEFENSE_PENALTIES_CONSIDERED_FOR_UNITS_WITHOUT_DEFENSE_BONUS
; 1564 : 			int iDefenseBonus = pToPlot->defenseModifier(eUnitTeam, false);
; 1565 : 			if (iDefenseBonus > 0)
; 1566 : 			{
; 1567 : 				if (pUnit->noDefensiveBonus())
; 1568 : 					iDefenseBonus = 0;
; 1569 : 				else if (iDefenseBonus > 200)
; 1570 : 					iDefenseBonus = 200;
; 1571 : 			}
; 1572 : 			iCost += PATH_DEFENSE_WEIGHT * (200 - iDefenseBonus);
; 1573 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 1574 : 			iCost += (PATH_DEFENSE_WEIGHT * MAX(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pToPlot->defenseModifier(eUnitTeam, false)))));
; 1575 : #else
; 1576 : 			iCost += (PATH_DEFENSE_WEIGHT * std::max(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pToPlot->defenseModifier(eUnitTeam, false)))));

	mov	ecx, edx
	call	?noDefensiveBonus@CvUnit@@QBE_NXZ	; CvUnit::noDefensiveBonus
	test	al, al
	je	SHORT $LN50@PathCost
	xor	eax, eax
	jmp	SHORT $LN51@PathCost
$LN50@PathCost:
	mov	eax, DWORD PTR _eUnitTeam$[esp+56]
	push	0
	push	0
	push	eax
	mov	ecx, ebx
	call	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ; CvPlot::defenseModifier
$LN51@PathCost:
	mov	ecx, 200				; 000000c8H
	sub	ecx, eax
	mov	DWORD PTR $T223235[esp+52], ecx
	mov	DWORD PTR $T223238[esp+52], 0
	lea	eax, DWORD PTR $T223235[esp+52]
	test	ecx, ecx
	jg	SHORT $LN207@PathCost
	lea	eax, DWORD PTR $T223238[esp+52]
$LN207@PathCost:
	mov	eax, DWORD PTR [eax]
	mov	edx, DWORD PTR _iCost$[esp+52]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _iCost$[esp+52], eax
$LN229@PathCost:

; 1577 : #endif
; 1578 : 		}
; 1579 : 
; 1580 : #if !defined(AUI_ASTAR_AVOID_RIVER_CROSSING_WHEN_ATTACKING) && !defined(AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING)
; 1581 : 		if(pCacheData->IsAutomated())

	cmp	BYTE PTR [ebp+153], 0
	je	$LN1@PathCost

; 1582 : #endif
; 1583 : 		{
; 1584 : 			if(pCacheData->IsCanAttack())

	cmp	BYTE PTR [ebp+158], 0
	je	$LN1@PathCost

; 1585 : 			{
; 1586 : 				if(finder->IsPathDest(iToPlotX, iToPlotY))

	mov	eax, DWORD PTR [ebp]
	test	eax, eax
	je	$LN1@PathCost
	mov	ecx, DWORD PTR [ebp+44]
	mov	edi, DWORD PTR _iToPlotY$[esp+56]
	push	ebp
	mov	ebp, DWORD PTR _iToPlotX$[esp+60]
	push	ecx
	push	edi
	push	ebp
	call	eax
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN1@PathCost

; 1587 : 				{
; 1588 : #if defined(AUI_ASTAR_AVOID_RIVER_CROSSING_WHEN_ATTACKING) || defined(AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING)
; 1589 : 					if (bToPlotHasEnemy)
; 1590 : #else
; 1591 : 					if(pToPlot->isVisibleEnemyDefender(pUnit))

	mov	edx, DWORD PTR _pointer$[esp+52]
	push	edx
	mov	ecx, ebx
	call	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyDefender
	test	al, al
	je	$LN1@PathCost

; 1592 : #endif
; 1593 : 					{
; 1594 : #ifdef AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING
; 1595 : 						int iDealtDamage = 0;
; 1596 : 						int iSelfDamage = 0;
; 1597 : 						CvCity* pCity = pToPlot->getPlotCity();
; 1598 : 						if (pCity)
; 1599 : 						{
; 1600 : 							int iAttackerStrength = pUnit->GetMaxAttackStrength(pFromPlot, pToPlot, NULL);
; 1601 : 							int iDefenderStrength = pCity->getStrengthValue();
; 1602 : 
; 1603 : 							iDealtDamage = pUnit->getCombatDamage(iAttackerStrength, iDefenderStrength, pUnit->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ true);
; 1604 : 							iSelfDamage = pUnit->getCombatDamage(iDefenderStrength, iAttackerStrength, pCity->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ true, /*bDefenderIsCity*/ false);
; 1605 : 
; 1606 : 							// Will both the attacker die, and the city fall? If so, the unit wins
; 1607 : 							if (iDealtDamage + pCity->getDamage() >= pCity->GetMaxHitPoints())
; 1608 : 							{
; 1609 : 								if (pUnit->isNoCapture())
; 1610 : 									iDealtDamage = pCity->GetMaxHitPoints() - pCity->getDamage() - 1;
; 1611 : 								if (iSelfDamage >= pUnit->GetCurrHitPoints())
; 1612 : 									iSelfDamage = pUnit->GetCurrHitPoints() - 1;
; 1613 : 							}
; 1614 : 					}
; 1615 : 						else
; 1616 : 						{
; 1617 : 							CvUnit* pDefender = pToPlot->getVisibleEnemyDefender(pUnit);
; 1618 : 							if (pDefender && pDefender->IsCanDefend())
; 1619 : 							{
; 1620 : 								// handle the Zulu special thrown spear first attack
; 1621 : 								if (pUnit->isRangedSupportFire() && pUnit->canEverRangeStrikeAt(pToPlot->getX(), pToPlot->getY()))
; 1622 : 									iDealtDamage = pUnit->GetRangeCombatDamage(pDefender, /*pCity*/ NULL, /*bIncludeRand*/ false);
; 1623 : 
; 1624 : 								if (iDealtDamage < pDefender->GetCurrHitPoints())
; 1625 : 								{
; 1626 : 									int iAttackerStrength = pUnit->GetMaxAttackStrength(pFromPlot, pToPlot, pDefender);
; 1627 : 									int iDefenderStrength = pDefender->GetMaxDefenseStrength(pToPlot, pUnit);
; 1628 : 
; 1629 : #ifdef NQ_HEAVY_CHARGE_DOWNHILL
; 1630 : 									bool isAttackingFromHigherElevation = 
; 1631 : 										((pUnit->plot()->isMountain() && !pDefender->plot()->isMountain()) || // attacking from mountain to non-mountain
; 1632 : 										(pUnit->plot()->isHills() && pDefender->plot()->isFlatlands())); // attacking from hills to flatlands
; 1633 : 									if ((pUnit->IsCanHeavyCharge() || (pUnit->GetHeavyChargeDownhill() > 0 && isAttackingFromHigherElevation))
; 1634 : 										&& !pDefender->CanFallBackFromMelee(*pUnit))
; 1635 : #else
; 1636 : 									if (pUnit->IsCanHeavyCharge() && !pDefender->CanFallBackFromMelee(*pUnit))
; 1637 : #endif
; 1638 : 										iAttackerStrength = (iAttackerStrength * 150) / 100;
; 1639 : 
; 1640 : 									iSelfDamage = pDefender->getCombatDamage(iDefenderStrength, iAttackerStrength, pDefender->getDamage() + iDealtDamage, /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);
; 1641 : 									iDealtDamage = pUnit->getCombatDamage(iAttackerStrength, iDefenderStrength, pUnit->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);
; 1642 : 
; 1643 : 									// Will both units be killed by this? :o If so, take drastic corrective measures
; 1644 : 									if (iDealtDamage >= pDefender->GetCurrHitPoints() && iSelfDamage >= pUnit->GetCurrHitPoints())
; 1645 : 									{
; 1646 : 										// He who hath the least amount of damage survives with 1 HP left
; 1647 : 										if (iDealtDamage + pDefender->getDamage() > iSelfDamage + pUnit->getDamage())
; 1648 : 											iSelfDamage = pUnit->GetCurrHitPoints() - 1;
; 1649 : 										else
; 1650 : 											iDealtDamage = pDefender->GetCurrHitPoints() - 1;
; 1651 : 									}
; 1652 : 								}
; 1653 : 							}
; 1654 : 						}
; 1655 : 						if (iSelfDamage > pUnit->GetCurrHitPoints())
; 1656 : 							iSelfDamage = pUnit->GetMaxHitPoints();
; 1657 : 						if (iDealtDamage > GC.getMAX_HIT_POINTS())
; 1658 : 							iDealtDamage = GC.getMAX_HIT_POINTS();
; 1659 : 						iCost += iSelfDamage * PATH_DAMAGE_WEIGHT * pUnit->GetMaxHitPoints() / 100 + (GC.getMAX_HIT_POINTS() - iDealtDamage) * PATH_DAMAGE_WEIGHT / 10;
; 1660 : #elif defined(AUI_ASTAR_FIX_DEFENSE_PENALTIES_CONSIDERED_FOR_UNITS_WITHOUT_DEFENSE_BONUS)
; 1661 : 						int iDefenseBonus = pFromPlot->defenseModifier(eUnitTeam, false);
; 1662 : 						if (iDefenseBonus > 0)
; 1663 : 						{
; 1664 : 							if (pUnit->noDefensiveBonus())
; 1665 : 								iDefenseBonus = 0;
; 1666 : 							else if (iDefenseBonus > 200)
; 1667 : 								iDefenseBonus = 200;
; 1668 : 						}
; 1669 : 						iCost += PATH_DEFENSE_WEIGHT * (200 - iDefenseBonus);
; 1670 : #else
; 1671 : #if defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 1672 : 						iCost += (PATH_DEFENSE_WEIGHT * MAX(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pFromPlot->defenseModifier(eUnitTeam, false)))));
; 1673 : #else
; 1674 : 						iCost += (PATH_DEFENSE_WEIGHT * std::max(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pFromPlot->defenseModifier(eUnitTeam, false)))));

	mov	ebx, DWORD PTR _pointer$[esp+52]
	mov	ecx, ebx
	call	?noDefensiveBonus@CvUnit@@QBE_NXZ	; CvUnit::noDefensiveBonus
	test	al, al
	je	SHORT $LN52@PathCost
	xor	eax, eax
	jmp	SHORT $LN53@PathCost
$LN52@PathCost:
	mov	eax, DWORD PTR _eUnitTeam$[esp+56]
	push	0
	push	0
	push	eax
	mov	ecx, esi
	call	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ; CvPlot::defenseModifier
$LN53@PathCost:
	mov	ecx, 200				; 000000c8H
	sub	ecx, eax
	mov	DWORD PTR $T223239[esp+52], ecx
	mov	DWORD PTR $T223242[esp+52], 0
	lea	eax, DWORD PTR $T223239[esp+52]
	test	ecx, ecx
	jg	SHORT $LN218@PathCost
	lea	eax, DWORD PTR $T223242[esp+52]
$LN218@PathCost:
	mov	eax, DWORD PTR [eax]
	mov	edx, DWORD PTR _iCost$[esp+52]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edx+ecx*2]

; 1675 : #endif
; 1676 : 
; 1677 : 						// I guess we may as well be the garrison
; 1678 : #if PATH_CITY_WEIGHT != 0
; 1679 : 						if(!(pFromPlot->isCity()))
; 1680 : 						{
; 1681 : 							iCost += PATH_CITY_WEIGHT;
; 1682 : 						}
; 1683 : #endif
; 1684 : 
; 1685 : 						if(pFromPlot->isRiverCrossing(directionXY(iFromPlotX, iFromPlotY, iToPlotX, iToPlotY)))

	mov	ecx, DWORD PTR _iFromPlotY$[esp+56]
	mov	edx, DWORD PTR _iFromPlotX$[esp+56]
	push	edi
	push	ebp
	push	ecx
	push	edx
	mov	DWORD PTR _iCost$[esp+68], eax
	call	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ; directionXY
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, esi
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	test	al, al
	je	SHORT $LN1@PathCost

; 1686 : 						{
; 1687 : 							if(!(pUnit->isRiverCrossingNoPenalty()))

	mov	ecx, ebx
	call	?isRiverCrossingNoPenalty@CvUnit@@QBE_NXZ ; CvUnit::isRiverCrossingNoPenalty
	test	al, al
	jne	SHORT $LN1@PathCost

; 1688 : 							{
; 1689 : 								iCost += (PATH_RIVER_WEIGHT * -(GC.getRIVER_ATTACK_MODIFIER()));
; 1690 : 								iCost += (PATH_MOVEMENT_WEIGHT * iMovesLeft);

	mov	eax, DWORD PTR _iMovesLeft$[esp+56]
	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	sub	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7388
	imul	eax, 100				; 00000064H
	add	DWORD PTR _iCost$[esp+52], eax
$LN1@PathCost:

; 1691 : 							}
; 1692 : 						}
; 1693 : #endif
; 1694 : 					}
; 1695 : 				}
; 1696 : 			}
; 1697 : 		}
; 1698 : 	}
; 1699 : 
; 1700 : 	FAssert(iCost != MAX_INT);
; 1701 : 
; 1702 : 	iCost += PATH_STEP_WEIGHT;

	mov	eax, DWORD PTR _iCost$[esp+52]
	pop	edi
	pop	esi
	pop	ebp
	add	eax, 2
	pop	ebx

; 1703 : 
; 1704 : 	FAssert(iCost > 0);
; 1705 : 
; 1706 : 	return iCost;
; 1707 : }

	add	esp, 40					; 00000028H
	ret	0
?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; PathCost
_TEXT	ENDS
PUBLIC	?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathValid
EXTRN	?canMoveThrough@CvUnit@@QBE_NABVCvPlot@@E@Z:PROC ; CvUnit::canMoveThrough
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
EXTRN	?isAdjacent@CvPlot@@QBE_NPBV1@@Z:PROC		; CvPlot::isAdjacent
EXTRN	?canMoveAllTerrain@CvUnit@@QBE_NXZ:PROC		; CvUnit::canMoveAllTerrain
EXTRN	?IsHoveringUnit@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsHoveringUnit
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
EXTRN	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z:PROC ; CvPlot::getBestDefender
EXTRN	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z:PROC ; CvPlot::isVisibleEnemyUnit
EXTRN	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z:PROC ; CvUnit::canEnterTerrain
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
; Function compile flags: /Ogtpy
;	COMDAT ?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_bFirstRun$ = -72					; size = 1
_bFromPlotOwned$ = -71					; size = 1
_bIsHuman$ = -70					; size = 1
_bAIControl$ = -69					; size = 1
_iNumTurns$ = -68					; size = 4
_iFinderIgnoreStacking$ = -64				; size = 4
_iFinderInfo$ = -60					; size = 4
_iNodeX$ = -56						; size = 4
_iNodeY$ = -52						; size = 4
_eUnitTeam$ = -48					; size = 4
_eFromPlotTeam$ = -44					; size = 4
_iOldNumTurns$ = -40					; size = 4
_theMap$ = -40						; size = 4
_iUnitPlotLimit$ = -36					; size = 4
_kUnitTeam$ = -36					; size = 4
tv971 = -32						; size = 4
_pUnitPlot$ = -32					; size = 4
_iDestX$ = -28						; size = 4
_iDestY$ = -24						; size = 4
_iUnitX$ = -20						; size = 4
_iUnitY$ = -16						; size = 4
tv820 = -12						; size = 4
_unit_domain_type$ = -8					; size = 4
$T223620 = -8						; size = 8
_parent$ = 8						; size = 4
_bPreviousNodeHostile$ = 12				; size = 1
_unit_owner$ = 12					; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; PathValid, COMDAT

; 1712 : {

	sub	esp, 72					; 00000048H

; 1713 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1714 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 1715 : 	CvPlot* pToPlot = node->m_pPlot;
; 1716 : 	if (!pToPlot)
; 1717 : 		return FALSE;
; 1718 : #else
; 1719 : 	CvMap& theMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	ebp
	push	esi

; 1720 : 
; 1721 : 	CvPlot* pToPlot = theMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	esi, DWORD PTR _node$[esp+80]
	movsx	ebp, WORD PTR [esi+82]
	imul	ebp, DWORD PTR [eax+4020]
	movsx	ecx, WORD PTR [esi+80]
	add	ebp, ecx
	imul	ebp, 484				; 000001e4H
	add	ebp, DWORD PTR [eax+4068]
	mov	DWORD PTR _theMap$[esp+84], eax

; 1722 : #endif
; 1723 : 	PREFETCH_FASTAR_CVPLOT(reinterpret_cast<char*>(pToPlot));
; 1724 : #endif
; 1725 : 
; 1726 : 	CvUnit* pUnit = ((CvUnit*)pointer);
; 1727 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());

	mov	eax, DWORD PTR _finder$[esp+80]

; 1728 : 	TeamTypes eUnitTeam = pCacheData->getTeam();
; 1729 : 	PlayerTypes unit_owner = pCacheData->getOwner();

	mov	edx, DWORD PTR [eax+140]
	prefetcht0 BYTE PTR [ebp]
	prefetcht0 BYTE PTR [ebp+64]
	push	edi
	mov	edi, DWORD PTR [eax+144]
	mov	DWORD PTR _eUnitTeam$[esp+88], edi
	mov	DWORD PTR _unit_owner$[esp+84], edx

; 1730 : 
; 1731 : 	CvAssertMsg(eUnitTeam != NO_TEAM, "The unit's team should be a vaild value");
; 1732 : 	if (eUnitTeam == NO_TEAM)

	cmp	edi, -1
	jne	SHORT $LN48@PathValid

; 1733 : 	{
; 1734 : 		eUnitTeam = GC.getGame().getActiveTeam();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	edi, eax
	mov	DWORD PTR _eUnitTeam$[esp+88], eax
$LN48@PathValid:

; 1735 : 	}
; 1736 : 
; 1737 : 	CvTeam& kUnitTeam = GET_TEAM(eUnitTeam);

	mov	eax, edi
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kUnitTeam$[esp+88], eax

; 1738 : 
; 1739 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1740 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 1741 : 	CvPlot* pToPlot = node->m_pPlot;
; 1742 : 	if (!pToPlot)
; 1743 : 		return FALSE;
; 1744 : #else
; 1745 : 	CvMap& theMap = GC.getMap();
; 1746 : 
; 1747 : 	CvPlot* pToPlot = theMap.plotUnchecked(node->m_iX, node->m_iY);
; 1748 : #endif
; 1749 : 	PREFETCH_FASTAR_CVPLOT(reinterpret_cast<char*>(pToPlot));
; 1750 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1751 : 	CvAStarNode& kToNodeCacheData = *node;
; 1752 : #else
; 1753 : 	CvPathNodeCacheData& kToNodeCacheData = node->m_kCostCacheData;
; 1754 : #endif
; 1755 : #endif
; 1756 : 
; 1757 : #ifdef AUI_ASTAR_FIX_PARENT_NODE_ALWAYS_VALID_OPTIMIZATION
; 1758 : 	// If this is the first node in the path, it is always valid (starting location)
; 1759 : 	if (parent == NULL)
; 1760 : 	{
; 1761 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1762 : 		// Cache values for this node that we will use in the loop
; 1763 : 		if (!kToNodeCacheData.bIsCalculated)
; 1764 : 		{
; 1765 : 			kToNodeCacheData.bIsCalculated = true;
; 1766 : 			kToNodeCacheData.bPlotVisibleToTeam = true;
; 1767 : 			kToNodeCacheData.bIsMountain = pToPlot->isMountain();
; 1768 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 1769 : 			kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 1770 : 			if (pUnit->IsHoveringUnit())
; 1771 : 				kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 1772 : 			else
; 1773 : 				kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 1774 : #else
; 1775 : 			kToNodeCacheData.bIsWater = (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater());
; 1776 : #endif
; 1777 : 			kToNodeCacheData.bCanEnterTerrain = true;
; 1778 : 			kToNodeCacheData.bIsRevealedToTeam = true;
; 1779 : 			kToNodeCacheData.bContainsOtherFriendlyTeamCity = false;
; 1780 : 			CvCity* pCity = pToPlot->getPlotCity();
; 1781 : 			if (pCity)
; 1782 : 			{
; 1783 : 				if (unit_owner != pCity->getOwner() && !kUnitTeam.isAtWar(pCity->getTeam()))
; 1784 : 					kToNodeCacheData.bContainsOtherFriendlyTeamCity = true;
; 1785 : 			}
; 1786 : 			kToNodeCacheData.bContainsEnemyCity = pToPlot->isEnemyCity(*pUnit);
; 1787 : 			kToNodeCacheData.iNumFriendlyUnitsOfType = pToPlot->getNumFriendlyUnitsOfType(pUnit);
; 1788 : 			kToNodeCacheData.bContainsVisibleEnemy = pToPlot->isVisibleEnemyUnit(pUnit);
; 1789 : 			kToNodeCacheData.bContainsVisibleEnemyDefender = pToPlot->getBestDefender(NO_PLAYER, unit_owner, pUnit).pointer() != NULL;
; 1790 : 		}
; 1791 : #endif
; 1792 : 		return TRUE;
; 1793 : 	}
; 1794 : #endif
; 1795 : 
; 1796 : 	// Cache values for this node that we will use in the loop
; 1797 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1798 : 	if (!kToNodeCacheData.bIsCalculated)
; 1799 : 	{
; 1800 : 		kToNodeCacheData.bPlotVisibleToTeam = pToPlot->isVisible(eUnitTeam);
; 1801 : 		kToNodeCacheData.bIsMountain = pToPlot->isMountain();
; 1802 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 1803 : 		kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 1804 : 		if (pUnit->IsHoveringUnit())
; 1805 : 			kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 1806 : 		else
; 1807 : 			kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 1808 : #else
; 1809 : 		kToNodeCacheData.bIsWater = (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater());
; 1810 : #endif
; 1811 : 		kToNodeCacheData.bIsRevealedToTeam = pToPlot->isRevealed(eUnitTeam);
; 1812 : 		kToNodeCacheData.bContainsOtherFriendlyTeamCity = false;
; 1813 : 		CvCity* pCity = pToPlot->getPlotCity();
; 1814 : 		if (pCity)
; 1815 : 		{
; 1816 : 			if (unit_owner != pCity->getOwner() && !kUnitTeam.isAtWar(pCity->getTeam()))
; 1817 : 				kToNodeCacheData.bContainsOtherFriendlyTeamCity = true;
; 1818 : 		}
; 1819 : 		kToNodeCacheData.bContainsEnemyCity = pToPlot->isEnemyCity(*pUnit);
; 1820 : 		if (kToNodeCacheData.bPlotVisibleToTeam)
; 1821 : 		{
; 1822 : 			kToNodeCacheData.iNumFriendlyUnitsOfType = pToPlot->getNumFriendlyUnitsOfType(pUnit);
; 1823 : 			kToNodeCacheData.bContainsVisibleEnemy = pToPlot->isVisibleEnemyUnit(pUnit);
; 1824 : 			kToNodeCacheData.bContainsVisibleEnemyDefender = pToPlot->getBestDefender(NO_PLAYER, unit_owner, pUnit).pointer() != NULL;
; 1825 : 		}
; 1826 : 		else
; 1827 : 		{
; 1828 : 			kToNodeCacheData.iNumFriendlyUnitsOfType = 0;
; 1829 : 			kToNodeCacheData.bContainsVisibleEnemy = false;
; 1830 : 			kToNodeCacheData.bContainsVisibleEnemyDefender = false;
; 1831 : 		}
; 1832 : 	}
; 1833 : #else
; 1834 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1835 : 	CvAStarNode& kToNodeCacheData = *node;
; 1836 : #else
; 1837 : 	CvPathNodeCacheData& kToNodeCacheData = node->m_kCostCacheData;
; 1838 : #endif
; 1839 : 	kToNodeCacheData.bPlotVisibleToTeam = pToPlot->isVisible(eUnitTeam);

	cmp	edi, -1
	jne	SHORT $LN72@PathValid
	xor	al, al
	jmp	SHORT $LN73@PathValid
$LN72@PathValid:
	mov	eax, DWORD PTR [ebp+156]
	cmp	WORD PTR [eax+edi*2], 0
	setg	al
$LN73@PathValid:
	mov	cl, BYTE PTR [esi+88]

; 1840 : 	kToNodeCacheData.iNumFriendlyUnitsOfType = pToPlot->getNumFriendlyUnitsOfType(pUnit);

	mov	ebx, DWORD PTR _pointer$[esp+84]
	xor	cl, al
	and	cl, 1
	xor	BYTE PTR [esi+88], cl
	push	1
	push	ebx
	mov	ecx, ebp
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	mov	DWORD PTR [esi+92], eax

; 1841 : 	kToNodeCacheData.bIsMountain = pToPlot->isMountain();

	cmp	BYTE PTR [ebp+5], 0
	sete	dl
	add	dl, dl
	xor	dl, BYTE PTR [esi+88]
	and	dl, 2
	xor	BYTE PTR [esi+88], dl

; 1842 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 1843 : 	kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 1844 : 	if (pUnit->IsHoveringUnit())
; 1845 : 		kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 1846 : 	else
; 1847 : 		kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 1848 : #else
; 1849 : 	kToNodeCacheData.bIsWater = (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater());

	cmp	BYTE PTR [ebp+5], 3
	jne	SHORT $LN51@PathValid
	mov	ecx, ebp
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	test	al, al
	jne	SHORT $LN51@PathValid
	mov	al, 1
	jmp	SHORT $LN52@PathValid
$LN51@PathValid:
	xor	al, al
$LN52@PathValid:
	add	al, al
	add	al, al
	xor	al, BYTE PTR [esi+88]

; 1850 : #endif
; 1851 : 	kToNodeCacheData.bCanEnterTerrain = pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE);

	push	128					; 00000080H
	and	al, 4
	xor	BYTE PTR [esi+88], al
	push	ebp
	mov	ecx, ebx
	call	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canEnterTerrain
	add	al, al
	add	al, al
	add	al, al
	xor	al, BYTE PTR [esi+88]
	and	al, 8
	xor	BYTE PTR [esi+88], al
	mov	dl, BYTE PTR [esi+88]

; 1852 : 	kToNodeCacheData.bIsRevealedToTeam = pToPlot->isRevealed(eUnitTeam);

	mov	eax, edi
	shr	eax, 5
	mov	ecx, eax
	shl	ecx, 5
	mov	DWORD PTR tv971[esp+88], ecx
	mov	ecx, edi
	mov	edi, DWORD PTR tv971[esp+88]
	sub	ecx, edi
	mov	edi, 1
	shl	edi, cl
	test	edi, DWORD PTR [ebp+eax*4+8]
	setne	al

; 1853 : 	kToNodeCacheData.bContainsOtherFriendlyTeamCity = false;

	and	al, 1
	shl	al, 4
	and	dl, 207					; 000000cfH
	or	al, dl
	mov	BYTE PTR [esi+88], al

; 1854 : 	CvCity* pCity = pToPlot->getPlotCity();

	mov	eax, DWORD PTR [ebp+104]
	test	eax, eax
	jl	SHORT $LN177@PathValid
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN177@PathValid
	mov	ecx, DWORD PTR [ebp+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 1855 : 	if(pCity)

	test	eax, eax
	je	SHORT $LN177@PathValid

; 1856 : 	{
; 1857 : 		if(unit_owner != pCity->getOwner() && !kUnitTeam.isAtWar(pCity->getTeam()))

	mov	edx, DWORD PTR _unit_owner$[esp+84]
	cmp	edx, DWORD PTR [eax+84]
	je	SHORT $LN177@PathValid
	mov	ecx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	ecx, DWORD PTR _kUnitTeam$[esp+88]
	push	eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	SHORT $LN177@PathValid

; 1858 : 			kToNodeCacheData.bContainsOtherFriendlyTeamCity = true;

	or	BYTE PTR [esi+88], 32			; 00000020H
$LN177@PathValid:

; 1859 : 	}
; 1860 : 	kToNodeCacheData.bContainsEnemyCity = pToPlot->isEnemyCity(*pUnit);

	mov	eax, DWORD PTR [ebp+104]
	test	eax, eax
	jl	SHORT $LN94@PathValid
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN94@PathValid
	mov	ecx, DWORD PTR [ebp+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN94@PathValid
	push	ebp
	mov	ecx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, ebx
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	jmp	SHORT $LN95@PathValid
$LN94@PathValid:
	xor	al, al
$LN95@PathValid:
	shl	al, 6
	xor	al, BYTE PTR [esi+88]

; 1861 : 	kToNodeCacheData.bContainsVisibleEnemy = pToPlot->isVisibleEnemyUnit(pUnit);

	push	ebx
	and	al, 64					; 00000040H
	xor	BYTE PTR [esi+88], al
	mov	ecx, ebp
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	mov	dl, BYTE PTR [esi+88]

; 1862 : 	kToNodeCacheData.bContainsVisibleEnemyDefender = pToPlot->getBestDefender(NO_PLAYER, unit_owner, pUnit).pointer() != NULL;

	push	0
	push	0
	push	0
	push	0
	shl	al, 7
	and	dl, 127					; 0000007fH
	or	dl, al
	mov	eax, DWORD PTR _unit_owner$[esp+100]
	push	ebx
	push	eax
	push	-1
	lea	ecx, DWORD PTR $T223620[esp+116]
	push	ecx
	mov	ecx, ebp
	mov	BYTE PTR [esi+88], dl
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	cmp	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T223620[esp+88]
	setne	dl
	xor	dl, BYTE PTR [esi+89]
	and	dl, 1
	xor	BYTE PTR [esi+89], dl
	test	ecx, ecx
	je	SHORT $LN107@PathValid
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN107@PathValid:

; 1863 : #endif
; 1864 : 
; 1865 : #ifndef AUI_ASTAR_FIX_PARENT_NODE_ALWAYS_VALID_OPTIMIZATION
; 1866 : 	// If this is the first node in the path, it is always valid (starting location)
; 1867 : 	if (parent == NULL)

	cmp	DWORD PTR _parent$[esp+84], 0

; 1868 : 	{
; 1869 : 		return TRUE;

	je	$LN1@PathValid

; 1870 : 	}
; 1871 : #endif
; 1872 : 
; 1873 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 1874 : 	CvPlot* pFromPlot = parent->m_pPlot;
; 1875 : 	if (!pFromPlot)
; 1876 : 		return FALSE;
; 1877 : #else
; 1878 : 	CvPlot* pFromPlot = theMap.plotUnchecked(parent->m_iX, parent->m_iY);

	mov	eax, DWORD PTR _parent$[esp+84]
	movsx	edi, WORD PTR [eax+82]
	mov	ecx, DWORD PTR _theMap$[esp+88]
	imul	edi, DWORD PTR [ecx+4020]
	movsx	eax, WORD PTR [eax+80]

; 1879 : #endif
; 1880 : 	PREFETCH_FASTAR_CVPLOT(reinterpret_cast<char*>(pFromPlot));
; 1881 : 
; 1882 : 	// pulling invariants out of the loop
; 1883 : 	bool bAIControl = pCacheData->IsAutomated();
; 1884 : 	int iUnitX = pUnit->getX();

	mov	edx, DWORD PTR [ebx+76]
	add	edi, eax
	mov	eax, DWORD PTR _finder$[esp+84]
	imul	edi, 484				; 000001e4H
	add	edi, DWORD PTR [ecx+4068]
	movzx	ecx, BYTE PTR [eax+153]
	prefetcht0 BYTE PTR [edi]
	prefetcht0 BYTE PTR [edi+64]
	mov	BYTE PTR _bAIControl$[esp+88], cl

; 1885 : 	int iUnitY = pUnit->getY();

	mov	ecx, DWORD PTR [ebx+88]
	mov	DWORD PTR _iUnitY$[esp+88], ecx

; 1886 : 	DomainTypes unit_domain_type = pCacheData->getDomainType();
; 1887 : 	bool bUnitIsCombat           = pUnit->IsCombatUnit();
; 1888 : 	bool bIsHuman				 = pCacheData->isHuman();

	movzx	ecx, BYTE PTR [eax+152]
	mov	DWORD PTR _iUnitX$[esp+88], edx
	mov	edx, DWORD PTR [eax+148]
	mov	DWORD PTR _unit_domain_type$[esp+88], edx

; 1889 : 	int iFinderInfo              = finder->GetInfo();

	mov	edx, DWORD PTR [eax+72]
	mov	BYTE PTR _bIsHuman$[esp+88], cl

; 1890 : 	CvPlot* pUnitPlot            = pUnit->plot();

	mov	ecx, ebx
	mov	DWORD PTR _iFinderInfo$[esp+88], edx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pUnitPlot$[esp+88], eax

; 1891 : 	int iFinderIgnoreStacking    = iFinderInfo & MOVE_IGNORE_STACKING;

	mov	eax, DWORD PTR _iFinderInfo$[esp+88]
	and	eax, 4
	mov	DWORD PTR _iFinderIgnoreStacking$[esp+88], eax

; 1892 : 	int iUnitPlotLimit           = GC.getPLOT_UNIT_LIMIT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7356

; 1893 : 	bool bFromPlotOwned          = pFromPlot->isOwned();

	mov	ecx, edi
	mov	DWORD PTR _iUnitPlotLimit$[esp+88], eax
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	mov	BYTE PTR _bFromPlotOwned$[esp+88], al

; 1894 : 	TeamTypes eFromPlotTeam      = pFromPlot->getTeam();

	movsx	eax, BYTE PTR [edi+4]
	cmp	eax, -1
	je	SHORT $LN138@PathValid
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN145@PathValid
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _eFromPlotTeam$[esp+88], eax
	jmp	SHORT $LN137@PathValid
$LN145@PathValid:
	or	eax, -1
	mov	DWORD PTR _eFromPlotTeam$[esp+88], eax
	jmp	SHORT $LN137@PathValid
$LN138@PathValid:
	mov	DWORD PTR _eFromPlotTeam$[esp+88], -1
$LN137@PathValid:

; 1895 : 
; 1896 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1897 : 	if (!kToNodeCacheData.bIsCalculated)
; 1898 : 	{
; 1899 : 		if (bAIControl || kToNodeCacheData.bIsRevealedToTeam || !bIsHuman)
; 1900 : 			kToNodeCacheData.bCanEnterTerrain = pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE);
; 1901 : 		else
; 1902 : 			kToNodeCacheData.bCanEnterTerrain = true;
; 1903 : 		kToNodeCacheData.bIsCalculated = true;
; 1904 : 	}
; 1905 : #endif
; 1906 : 
; 1907 : 	// We have determined that this node is not the origin above (parent == NULL)
; 1908 : 	CvAStarNode* pNode = node;
; 1909 : 	bool bPreviousNodeHostile = false;
; 1910 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1911 : 	bool bPreviousVisibleToTeam = kToNodeCacheData.bPlotVisibleToTeam;
; 1912 : #endif
; 1913 : 	int iDestX = finder->GetDestX();

	mov	edx, DWORD PTR _finder$[esp+84]
	mov	ebx, DWORD PTR [edx+64]

; 1914 : 	int iDestY = finder->GetDestY();

	mov	edx, DWORD PTR [edx+68]
	mov	cl, BYTE PTR [esi+88]
	mov	DWORD PTR _iDestY$[esp+88], edx

; 1915 : 	int iNodeX = node->m_iX;

	movsx	edx, WORD PTR [esi+80]
	mov	DWORD PTR _iNodeX$[esp+88], edx

; 1916 : 	int iNodeY = node->m_iY;

	movsx	edx, WORD PTR [esi+82]
	mov	DWORD PTR _iNodeY$[esp+88], edx

; 1917 : 	int iOldNumTurns = -1;
; 1918 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 1919 : 	int iNumTurns;
; 1920 : #endif
; 1921 : 
; 1922 : 	// First run special case for checking "node" since it doesn't have a parent set yet
; 1923 : 	bool bFirstRun = true;
; 1924 : 
; 1925 : 	// Have to calculate this specially because the node passed into this function doesn't yet have data stored it in (hasn't reached pathAdd yet)
; 1926 : 	int iStartMoves = parent->m_iData1;
; 1927 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1928 : 	int iNumTurns = parent->m_iData2;
; 1929 : #else
; 1930 : 	iNumTurns = parent->m_iData2;

	mov	edx, DWORD PTR _parent$[esp+84]
	mov	DWORD PTR _iDestX$[esp+88], ebx
	mov	ebx, DWORD PTR [edx+16]
	and	cl, 1

; 1931 : #endif
; 1932 : #if defined(AUI_ASTAR_TURN_LIMITER)
; 1933 : 	int iMaxTurns = finder->GetMaxTurns();
; 1934 : #endif
; 1935 : 
; 1936 : 	if(iStartMoves == 0)

	cmp	DWORD PTR [edx+12], 0
	mov	eax, esi
	mov	BYTE PTR _bPreviousNodeHostile$[esp+84], 0
	mov	BYTE PTR _bFirstRun$[esp+88], 1
	mov	DWORD PTR _iNumTurns$[esp+88], ebx
	jne	SHORT $LN44@PathValid

; 1937 : 	{
; 1938 : 		iNumTurns++;

	inc	DWORD PTR _iNumTurns$[esp+88]
$LN44@PathValid:

; 1939 : 	}
; 1940 : 
; 1941 : 	iOldNumTurns = -1;

	or	ebx, -1
$LN184@PathValid:

; 1942 : 
; 1943 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 1944 : 	CvPlot* pPlot = NULL;
; 1945 : #endif
; 1946 : 
; 1947 : 	// Get a reference to the parent node cache data
; 1948 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1949 : 	CvAStarNode& kFromNodeCacheData = *parent;
; 1950 : #else
; 1951 : 	CvPathNodeCacheData& kFromNodeCacheData = parent->m_kCostCacheData;
; 1952 : #endif
; 1953 : 
; 1954 : 	// Loop through the current path until we find the path origin.
; 1955 : 	// This validates the path with the inclusion of the new path node.  We must do this because of the rules of where a unit can finish a turn.
; 1956 : 	// Please note that this can be an expensive loop as the path gets longer and longer, do as little work as possible in validating each node.  
; 1957 : 	// If there is an invariant value that needs to be fetched from the plot or unit for the node, please do the calculation and put it in the node's data cache.
; 1958 : 	while(pNode != NULL)
; 1959 : 	{
; 1960 : #ifdef AUI_ASTAR_TURN_LIMITER
; 1961 : 		if (iNumTurns > iMaxTurns)
; 1962 : 		{
; 1963 : 			return FALSE;  // Path is too long, terminate now
; 1964 : 		}
; 1965 : #endif
; 1966 : 		PREFETCH_FASTAR_NODE(pNode->m_pParent);

	mov	edx, DWORD PTR [eax+24]
	prefetcht0 BYTE PTR [edx]
	prefetcht0 BYTE PTR [edx+64]
	add	edx, 64					; 00000040H
	mov	DWORD PTR _iOldNumTurns$[esp+88], ebx

; 1967 : 
; 1968 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1969 : 		CvAStarNode& kNodeCacheData = *node;
; 1970 : #else
; 1971 : 		CvPathNodeCacheData& kNodeCacheData = pNode->m_kCostCacheData;
; 1972 : #endif
; 1973 : 		// This is a safeguard against the algorithm believing a plot to be impassable before actually knowing it (mid-search)
; 1974 : 		if(iOldNumTurns != -1 || (iDestX == iNodeX && iDestY == iNodeY))

	cmp	ebx, -1
	jne	SHORT $LN178@PathValid
	mov	edx, DWORD PTR _iNodeX$[esp+88]
	cmp	DWORD PTR _iDestX$[esp+88], edx
	jne	$LN168@PathValid
	mov	edx, DWORD PTR _iNodeY$[esp+88]
	cmp	DWORD PTR _iDestY$[esp+88], edx
	jne	$LN168@PathValid
$LN178@PathValid:

; 1975 : 		{
; 1976 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1977 : 			if (!kNodeCacheData.bCanEnterTerrain)
; 1978 : 			{
; 1979 : 				return FALSE;
; 1980 : 			}
; 1981 : #endif
; 1982 : 			// This plot is of greater distance than previously, so we know the unit is ending its turn here (pNode), or it's trying to attack through a unit (and might end up on this tile if an attack fails to kill the enemy)
; 1983 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1984 : 			if (iNumTurns != iOldNumTurns || bPreviousNodeHostile)
; 1985 : #else
; 1986 : 			if(iNumTurns != iOldNumTurns || bPreviousNodeHostile || !bPreviousVisibleToTeam)

	cmp	DWORD PTR _iNumTurns$[esp+88], ebx
	jne	SHORT $LN163@PathValid
	cmp	BYTE PTR _bPreviousNodeHostile$[esp+84], 0
	jne	SHORT $LN163@PathValid
	test	cl, cl
	jne	$LN168@PathValid
$LN163@PathValid:

; 1987 : #endif
; 1988 : 			{
; 1989 : 				// Don't count origin, or else a unit will block its own movement!
; 1990 : 				if(iNodeX != iUnitX || iNodeY != iUnitY)

	mov	ecx, DWORD PTR _iUnitX$[esp+88]
	cmp	DWORD PTR _iNodeX$[esp+88], ecx
	jne	SHORT $LN36@PathValid
	mov	edx, DWORD PTR _iUnitY$[esp+88]
	cmp	DWORD PTR _iNodeY$[esp+88], edx
	je	SHORT $LN168@PathValid
$LN36@PathValid:

; 1991 : 				{
; 1992 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1993 : 					if (kNodeCacheData.bIsRevealedToTeam)
; 1994 : #else
; 1995 : 					if(kNodeCacheData.bPlotVisibleToTeam)

	mov	dl, BYTE PTR [eax+88]
	test	dl, 1
	je	SHORT $LN166@PathValid

; 1996 : #endif
; 1997 : 					{
; 1998 : 						// Check to see if any units are present at this full-turn move plot... if the player can see what's there
; 1999 : 						if(kNodeCacheData.iNumFriendlyUnitsOfType >= iUnitPlotLimit && !(iFinderIgnoreStacking))

	mov	ecx, DWORD PTR [eax+92]
	cmp	ecx, DWORD PTR _iUnitPlotLimit$[esp+88]
	jl	SHORT $LN164@PathValid
	cmp	DWORD PTR _iFinderIgnoreStacking$[esp+88], 0
	je	$LN157@PathValid
$LN164@PathValid:

; 2000 : 						{
; 2001 : 							return FALSE;
; 2002 : 						}
; 2003 : 
; 2004 : #ifndef AUI_ASTAR_FIX_PATH_VALID_PATH_PEAKS_FOR_NONHUMAN
; 2005 : 						if (kNodeCacheData.bIsMountain && !(iFinderIgnoreStacking) && (!bIsHuman || bAIControl))

	mov	cl, dl
	shr	cl, 1
	and	cl, 1
	je	SHORT $LN179@PathValid
	cmp	DWORD PTR _iFinderIgnoreStacking$[esp+88], 0
	jne	SHORT $LN179@PathValid
	cmp	BYTE PTR _bIsHuman$[esp+88], 0
	je	$LN157@PathValid
	cmp	BYTE PTR _bAIControl$[esp+88], 0
	jne	$LN157@PathValid
$LN179@PathValid:

; 2006 : 						{
; 2007 : 							return FALSE;
; 2008 : 						}
; 2009 : #endif
; 2010 : 
; 2011 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2012 : 						if(kNodeCacheData.bIsMountain && !kNodeCacheData.bCanEnterTerrain)

	test	cl, cl
	je	SHORT $LN31@PathValid
	test	dl, 8
	je	$LN157@PathValid
$LN31@PathValid:

; 2013 : 						{
; 2014 : 							return FALSE;
; 2015 : 						}
; 2016 : #endif
; 2017 : 
; 2018 : 						if ((iFinderInfo & CvUnit::MOVEFLAG_STAY_ON_LAND) && kNodeCacheData.bIsWater)

	test	DWORD PTR _iFinderInfo$[esp+88], 256	; 00000100H
	je	SHORT $LN166@PathValid
	test	dl, 4
	jne	$LN157@PathValid
$LN166@PathValid:

; 2019 : 						{
; 2020 : 							return FALSE;
; 2021 : 						}
; 2022 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2023 : 					}
; 2024 : 
; 2025 : 					if(kNodeCacheData.bIsRevealedToTeam)

	test	dl, 16					; 00000010H
	je	SHORT $LN168@PathValid

; 2026 : 					{
; 2027 : #endif
; 2028 : 						if (kNodeCacheData.bContainsOtherFriendlyTeamCity && !(iFinderIgnoreStacking))

	test	dl, 32					; 00000020H
	je	SHORT $LN168@PathValid
	cmp	DWORD PTR _iFinderIgnoreStacking$[esp+88], 0
	je	$LN157@PathValid
$LN168@PathValid:

; 2029 : 							return FALSE;
; 2030 : 					}
; 2031 : 				}
; 2032 : 			}
; 2033 : 		}
; 2034 : 
; 2035 : 		bPreviousNodeHostile = false;
; 2036 : 		if(kNodeCacheData.bContainsEnemyCity)

	mov	cl, BYTE PTR [eax+88]
	mov	BYTE PTR _bPreviousNodeHostile$[esp+84], 0
	test	cl, 64					; 00000040H

; 2037 : 		{
; 2038 : 			bPreviousNodeHostile = true;

	jne	SHORT $LN183@PathValid

; 2039 : 		}
; 2040 : 		// Prevents units from passing through one another on its way to attack another unit
; 2041 : 		else if(kNodeCacheData.bContainsVisibleEnemy)

	test	cl, cl
	jns	SHORT $LN24@PathValid

; 2042 : 		{
; 2043 : 			// except when attacking an unguarded civilian unit
; 2044 : 			if(kNodeCacheData.bContainsVisibleEnemyDefender)

	test	BYTE PTR [eax+89], 1
	je	SHORT $LN24@PathValid
$LN183@PathValid:

; 2045 : 			{
; 2046 : 				bPreviousNodeHostile = true;

	mov	BYTE PTR _bPreviousNodeHostile$[esp+84], 1
$LN24@PathValid:

; 2047 : 			}
; 2048 : 		}
; 2049 : 
; 2050 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2051 : 		bPreviousVisibleToTeam = kNodeCacheData.bPlotVisibleToTeam;

	and	cl, 1

; 2052 : #endif
; 2053 : 		// JON - Special case for the original node passed into this function because it's not yet linked to any parent
; 2054 : 		if(pNode == node && bFirstRun)

	cmp	eax, esi
	jne	SHORT $LN23@PathValid
	cmp	BYTE PTR _bFirstRun$[esp+88], 0
	je	SHORT $LN23@PathValid

; 2055 : 		{
; 2056 : 			pNode = parent;

	mov	eax, DWORD PTR _parent$[esp+84]

; 2057 : 			bFirstRun = false;

	mov	BYTE PTR _bFirstRun$[esp+88], 0

; 2058 : 		}
; 2059 : 		else

	jmp	SHORT $LN22@PathValid
$LN23@PathValid:

; 2060 : 		{
; 2061 : 			pNode = pNode->m_pParent;

	mov	eax, DWORD PTR [eax+24]
$LN22@PathValid:

; 2062 : 		}
; 2063 : 
; 2064 : 		if(pNode != NULL)

	test	eax, eax
	je	SHORT $LN42@PathValid

; 2065 : 		{
; 2066 : 			iNodeX = pNode->m_iX;

	movsx	edx, WORD PTR [eax+80]

; 2067 : 			iNodeY = pNode->m_iY;
; 2068 : 			iOldNumTurns = iNumTurns;

	mov	ebx, DWORD PTR _iNumTurns$[esp+88]
	mov	DWORD PTR _iNodeX$[esp+88], edx
	movsx	edx, WORD PTR [eax+82]
	mov	DWORD PTR _iNodeY$[esp+88], edx

; 2069 : 			iNumTurns = pNode->m_iData2;

	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR _iNumTurns$[esp+88], edx
	jmp	$LN184@PathValid
$LN42@PathValid:

; 2070 : 		}
; 2071 : 	}
; 2072 : 
; 2073 : 	// slewis - moved this up so units can't move directly into the water. Not 100% sure this is the right solution.
; 2074 : 	if(unit_domain_type == DOMAIN_LAND)

	mov	eax, DWORD PTR _unit_domain_type$[esp+88]
	cmp	eax, 2
	jne	SHORT $LN18@PathValid

; 2075 : 	{
; 2076 : 		if(!kFromNodeCacheData.bIsWater && kToNodeCacheData.bIsWater && kToNodeCacheData.bIsRevealedToTeam && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))

	mov	eax, DWORD PTR _parent$[esp+84]
	test	BYTE PTR [eax+88], 4
	jne	SHORT $LN173@PathValid
	mov	al, BYTE PTR [esi+88]
	test	al, 4
	je	SHORT $LN173@PathValid
	test	al, 16					; 00000010H
	je	SHORT $LN173@PathValid
	mov	ebx, DWORD PTR _pointer$[esp+84]
	push	0
	push	1
	push	ebp
	push	edi
	mov	ecx, ebx
	call	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z ; CvUnit::canEmbarkOnto
	test	al, al
	jne	SHORT $LN162@PathValid

; 2077 : 		{
; 2078 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 2079 : 			if (!pUnit->canMoveAllTerrain())
; 2080 : #else
; 2081 : 			if(!pUnit->IsHoveringUnit() && !pUnit->canMoveAllTerrain() && !pToPlot->IsAllowsWalkWater())

	mov	ecx, ebx
	call	?IsHoveringUnit@CvUnit@@QBE_NXZ		; CvUnit::IsHoveringUnit
	test	al, al
	jne	SHORT $LN162@PathValid
	mov	ecx, ebx
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	test	al, al
	jne	SHORT $LN162@PathValid
	mov	ecx, ebp
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	test	al, al
	jne	SHORT $LN162@PathValid
$LN157@PathValid:
	pop	edi
	pop	esi
	pop	ebp

; 2082 : #endif
; 2083 : 			{
; 2084 : 				return FALSE;

	xor	eax, eax
	pop	ebx

; 2221 : }

	add	esp, 72					; 00000048H
	ret	0
$LN18@PathValid:

; 2085 : 			}
; 2086 : 		}
; 2087 : 	}
; 2088 : 
; 2089 : #ifndef AUI_ASTAR_FIX_RADAR
; 2090 : 	if(!bUnitIsCombat && unit_domain_type != DOMAIN_AIR)
; 2091 : 	{
; 2092 : 		const PlayerTypes eUnitPlayer = unit_owner;
; 2093 : 		const int iUnitCount = pToPlot->getNumUnits();
; 2094 : 		for(int iUnit = 0; iUnit < iUnitCount; ++iUnit)
; 2095 : 		{
; 2096 : 			const CvUnit* pToPlotUnit = pToPlot->getUnitByIndex(iUnit);
; 2097 : 			if(pToPlotUnit != NULL && pToPlotUnit->getOwner() != eUnitPlayer)
; 2098 : 			{
; 2099 : 				return FALSE; // Plot occupied by another player
; 2100 : 			}
; 2101 : 		}
; 2102 : 	}
; 2103 : #endif
; 2104 : 
; 2105 : 	// slewis - Added to catch when the unit is adjacent to an enemy unit while it is stacked with a friendly unit.
; 2106 : 	//          The logic above (with bPreviousNodeHostile) catches this problem with a path that's longer than one step
; 2107 : 	//          but does not catch when the path is only one step.
; 2108 : #ifdef AUI_ASTAR_FIX_RADAR
; 2109 : 	if (unit_domain_type != DOMAIN_AIR && pUnitPlot->isAdjacent(pToPlot) && kToNodeCacheData.bContainsVisibleEnemy && !(iFinderIgnoreStacking))

	cmp	eax, 1
	je	SHORT $LN174@PathValid
$LN173@PathValid:
	mov	ebx, DWORD PTR _pointer$[esp+84]
$LN162@PathValid:
	push	ebp
	mov	ebp, DWORD PTR _pUnitPlot$[esp+92]
	mov	ecx, ebp
	call	?isAdjacent@CvPlot@@QBE_NPBV1@@Z	; CvPlot::isAdjacent
	test	al, al
	je	SHORT $LN15@PathValid
	test	BYTE PTR [esi+88], 128			; 00000080H
	je	SHORT $LN15@PathValid
	cmp	DWORD PTR _iFinderIgnoreStacking$[esp+88], 0
	jne	SHORT $LN15@PathValid

; 2110 : #else
; 2111 : 	if(bUnitIsCombat && unit_domain_type != DOMAIN_AIR && pUnitPlot->isAdjacent(pToPlot) && kToNodeCacheData.bContainsVisibleEnemy && !(iFinderIgnoreStacking))
; 2112 : #endif
; 2113 : 	{
; 2114 : 		if(kToNodeCacheData.bContainsVisibleEnemyDefender)

	test	BYTE PTR [esi+89], 1
	je	SHORT $LN15@PathValid

; 2115 : 		{
; 2116 : 			if(pUnitPlot->getNumFriendlyUnitsOfType(pUnit) > iUnitPlotLimit)

	push	1
	push	ebx
	mov	ecx, ebp
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	cmp	eax, DWORD PTR _iUnitPlotLimit$[esp+88]
	jle	SHORT $LN15@PathValid
	pop	edi
	pop	esi
	pop	ebp

; 2117 : 			{
; 2118 : 				return FALSE;

	xor	eax, eax
	pop	ebx

; 2221 : }

	add	esp, 72					; 00000048H
	ret	0
$LN174@PathValid:

; 2115 : 		{
; 2116 : 			if(pUnitPlot->getNumFriendlyUnitsOfType(pUnit) > iUnitPlotLimit)

	mov	ebx, DWORD PTR _pointer$[esp+84]
	mov	ebp, DWORD PTR _pUnitPlot$[esp+88]
$LN15@PathValid:

; 2119 : 			}
; 2120 : 		}
; 2121 : 	}
; 2122 : 
; 2123 : 	if(pUnitPlot == pFromPlot)

	cmp	ebp, edi

; 2124 : 	{
; 2125 : 		return TRUE;

	je	$LN1@PathValid

; 2126 : 	}
; 2127 : 
; 2128 : 	if(iFinderInfo & MOVE_TERRITORY_NO_UNEXPLORED)

	mov	al, BYTE PTR _iFinderInfo$[esp+88]
	test	al, 1
	je	SHORT $LN175@PathValid

; 2129 : 	{
; 2130 : 		if(!(kFromNodeCacheData.bIsRevealedToTeam))

	mov	ecx, DWORD PTR _parent$[esp+84]
	test	BYTE PTR [ecx+88], 16			; 00000010H

; 2131 : 		{
; 2132 : 			return FALSE;

	je	SHORT $LN157@PathValid

; 2133 : 		}
; 2134 : 
; 2135 : 		if(bFromPlotOwned)

	cmp	BYTE PTR _bFromPlotOwned$[esp+88], 0
	je	SHORT $LN175@PathValid

; 2136 : 		{
; 2137 : 			if(eFromPlotTeam != eUnitTeam)

	mov	edx, DWORD PTR _eFromPlotTeam$[esp+88]
	cmp	edx, DWORD PTR _eUnitTeam$[esp+88]

; 2138 : 			{
; 2139 : 				return FALSE;

	jne	$LN157@PathValid
$LN175@PathValid:

; 2140 : 			}
; 2141 : 		}
; 2142 : 	}
; 2143 : 
; 2144 : 	if(iFinderInfo & MOVE_TERRITORY_NO_ENEMY)

	test	al, 2
	je	SHORT $LN7@PathValid

; 2145 : 	{
; 2146 : 		if(bFromPlotOwned)

	cmp	BYTE PTR _bFromPlotOwned$[esp+88], 0
	je	SHORT $LN7@PathValid

; 2147 : 		{
; 2148 : 			if(atWar(eFromPlotTeam, eUnitTeam))

	mov	eax, DWORD PTR _eUnitTeam$[esp+88]
	mov	ecx, DWORD PTR _eFromPlotTeam$[esp+88]
	push	eax
	push	ecx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al

; 2149 : 			{
; 2150 : 				return FALSE;

	jne	$LN157@PathValid

; 2147 : 		{
; 2148 : 			if(atWar(eFromPlotTeam, eUnitTeam))

	mov	al, BYTE PTR _iFinderInfo$[esp+88]
$LN7@PathValid:

; 2151 : 			}
; 2152 : 		}
; 2153 : 	}
; 2154 : #ifndef ASTAR_AI_CONTROL_FIX_RADAR
; 2155 : 	if(bAIControl)
; 2156 : 	{
; 2157 : 		if((parent->m_iData2 > 1) || (parent->m_iData1 == 0))
; 2158 : 		{
; 2159 : 			if(!(iFinderInfo & MOVE_UNITS_IGNORE_DANGER))
; 2160 : 			{
; 2161 : 				if(!bUnitIsCombat || pUnit->getArmyID() == FFreeList::INVALID_INDEX)
; 2162 : 				{
; 2163 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_USES_TO_PLOT_NOT_FROM_PLOT
; 2164 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH
; 2165 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_ONLY_POSITIVE_DANGER_DELTA
; 2166 : 					if (GET_PLAYER(pUnit->getOwner()).GetPlotDanger(*pToPlot) > pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH &&
; 2167 : 						GET_PLAYER(pUnit->getOwner()).GetPlotDanger(*pFromPlot) <= pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 2168 : #else
; 2169 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pToPlot) > pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 2170 : #endif
; 2171 : #elif defined(AUI_ASTAR_FIX_CONSIDER_DANGER_ONLY_POSITIVE_DANGER_DELTA)
; 2172 : 					if (GET_PLAYER(pUnit->getOwner()).GetPlotDanger(*pToPlot) > 0 && GET_PLAYER(pUnit->getOwner()).GetPlotDanger(*pFromPlot) <= 0)
; 2173 : #else
; 2174 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pToPlot) > 0)
; 2175 : #endif
; 2176 : #elif defined(AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 2177 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pFromPlot) > pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 2178 : #else
; 2179 : 					if(GET_PLAYER(unit_owner).GetPlotDanger(*pFromPlot) > 0)
; 2180 : #endif
; 2181 : 					{
; 2182 : 						return FALSE;
; 2183 : 					}
; 2184 : 				}
; 2185 : 			}
; 2186 : 		}
; 2187 : 	}
; 2188 : #endif
; 2189 : 	// slewis - added AI check and embark check to prevent units from moving into unexplored areas
; 2190 : #ifdef ASTAR_AI_CONTROL_FIX_RADAR
; 2191 : 	if(kFromNodeCacheData.bIsRevealedToTeam || pCacheData->isEmbarked() || !bIsHuman)

	mov	edx, DWORD PTR _parent$[esp+84]
	test	BYTE PTR [edx+88], 16			; 00000010H
	jne	SHORT $LN5@PathValid
	mov	ecx, DWORD PTR _finder$[esp+84]
	cmp	BYTE PTR [ecx+157], 0
	jne	SHORT $LN5@PathValid
	cmp	BYTE PTR _bIsHuman$[esp+88], 0
	jne	SHORT $LN1@PathValid
$LN5@PathValid:

; 2192 : #else
; 2193 : 	if(bAIControl || kFromNodeCacheData.bIsRevealedToTeam || pCacheData->isEmbarked() || !bIsHuman)
; 2194 : #endif
; 2195 : 	{
; 2196 : 		if(iFinderInfo & MOVE_UNITS_THROUGH_ENEMY)
; 2197 : 		{
; 2198 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2199 : 			if (!(pUnit->canMoveOrAttackInto(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE, kFromNodeCacheData.bCanEnterTerrain, true)))
; 2200 : #else
; 2201 : 			if(!(pUnit->canMoveOrAttackInto(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE)))

	push	128					; 00000080H
	mov	ecx, ebx
	push	edi
	test	al, 16					; 00000010H
	je	SHORT $LN4@PathValid
	call	?canMoveOrAttackInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveOrAttackInto
	test	al, al
	jne	SHORT $LN1@PathValid
	pop	edi
	pop	esi
	pop	ebp

; 2202 : #endif
; 2203 : 			{
; 2204 : 				return FALSE;

	xor	eax, eax
	pop	ebx

; 2221 : }

	add	esp, 72					; 00000048H
	ret	0
$LN4@PathValid:

; 2205 : 			}
; 2206 : 		}
; 2207 : 		else
; 2208 : 		{
; 2209 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2210 : 			if (!(pUnit->canMoveThrough(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE, kFromNodeCacheData.bCanEnterTerrain, true)))
; 2211 : #else
; 2212 : 			if(!(pUnit->canMoveThrough(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE)))

	call	?canMoveThrough@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveThrough
	test	al, al

; 2213 : #endif
; 2214 : 			{
; 2215 : 				return FALSE;

	je	$LN157@PathValid
$LN1@PathValid:
	pop	edi
	pop	esi
	pop	ebp

; 2216 : 			}
; 2217 : 		}
; 2218 : 	}
; 2219 : 
; 2220 : 	return TRUE;

	mov	eax, 1
	pop	ebx

; 2221 : }

	add	esp, 72					; 00000048H
	ret	0
?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; PathValid
_TEXT	ENDS
PUBLIC	?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathAdd
EXTRN	?movesLeft@CvUnit@@QBEHXZ:PROC			; CvUnit::movesLeft
; Function compile flags: /Ogtpy
;	COMDAT ?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_iMoves$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_iTurns$ = 16						; size = 4
_data$ = 16						; size = 4
$T223876 = 20						; size = 4
_pointer$ = 20						; size = 4
$T223873 = 24						; size = 4
$T223870 = 24						; size = 4
_finder$ = 24						; size = 4
?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; PathAdd, COMDAT

; 2228 : {

	push	ecx

; 2229 : 	int iMoves = MAX_INT;
; 2230 : 	CvUnit* pUnit = ((CvUnit*)pointer);
; 2231 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());
; 2232 : 
; 2233 : 	int iTurns;
; 2234 : 
; 2235 : 	if(data == ASNC_INITIALADD)

	cmp	DWORD PTR _data$[esp], 0
	mov	DWORD PTR _iMoves$[esp+4], 2147483647	; 7fffffffH
	jne	SHORT $LN6@PathAdd

; 2236 : 	{
; 2237 : 		iTurns = 1;
; 2238 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2239 : 		iMoves = pUnit->movesLeft();
; 2240 : #else
; 2241 : 		iMoves = std::min(iMoves, pUnit->movesLeft());

	mov	ecx, DWORD PTR _pointer$[esp]
	mov	DWORD PTR _iTurns$[esp], 1
	call	?movesLeft@CvUnit@@QBEHXZ		; CvUnit::movesLeft
	mov	DWORD PTR $T223870[esp], eax
	cmp	eax, 2147483647				; 7fffffffH
	lea	eax, DWORD PTR $T223870[esp]
	jl	SHORT $LN18@PathAdd
	lea	eax, DWORD PTR _iMoves$[esp+4]
$LN18@PathAdd:
	mov	eax, DWORD PTR [eax]

; 2286 : 		}
; 2287 : #endif
; 2288 : 	}
; 2289 : 
; 2290 : 	FAssertMsg(iMoves >= 0, "iMoves is expected to be non-negative (invalid Index)");
; 2291 : 
; 2292 : 	node->m_iData1 = iMoves;

	mov	ecx, DWORD PTR _node$[esp]

; 2293 : 	node->m_iData2 = iTurns;

	mov	edx, DWORD PTR _iTurns$[esp]
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], edx

; 2294 : 
; 2295 : 	return 1;

	mov	eax, 1

; 2296 : }

	pop	ecx
	ret	0
$LN6@PathAdd:

; 2242 : #endif
; 2243 : 	}
; 2244 : 	else
; 2245 : 	{
; 2246 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 2247 : 		const CvPlot* pFromPlot = parent->m_pPlot;
; 2248 : 		const CvPlot* pToPlot = node->m_pPlot;
; 2249 : #else
; 2250 : 		CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 2251 : 		CvPlot* pFromPlot = kMap.plotUnchecked(parent->m_iX, parent->m_iY);

	mov	ecx, DWORD PTR [eax+4020]
	mov	edx, DWORD PTR [eax+4068]
	mov	eax, DWORD PTR _parent$[esp]
	push	ebx

; 2252 : 		CvPlot* pToPlot = kMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	ebx, DWORD PTR _node$[esp+4]
	push	ebp
	push	esi
	movsx	esi, WORD PTR [eax+80]
	push	edi
	movsx	edi, WORD PTR [eax+82]
	imul	edi, ecx
	add	edi, esi
	movsx	esi, WORD PTR [ebx+82]
	imul	edi, 484				; 000001e4H

; 2253 : #endif
; 2254 : 
; 2255 : 		int iStartMoves = parent->m_iData1;

	mov	ebp, DWORD PTR [eax+12]
	imul	esi, ecx
	movsx	ecx, WORD PTR [ebx+80]
	add	esi, ecx
	imul	esi, 484				; 000001e4H
	add	edi, edx
	add	esi, edx

; 2256 : 		iTurns = parent->m_iData2;

	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR _iTurns$[esp+16], edx

; 2257 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2258 : 		int iBaseMoves = pCacheData->baseMoves(((pFromPlot->isWater() && !pFromPlot->IsAllowsWalkWater()) || pCacheData->isEmbarked()) ? DOMAIN_SEA : pCacheData->getDomainType());
; 2259 : #endif
; 2260 : 
; 2261 : 		if(iStartMoves == 0)

	test	ebp, ebp
	jne	SHORT $LN4@PathAdd

; 2262 : 		{
; 2263 : 			iTurns++;

	inc	DWORD PTR _iTurns$[esp+16]

; 2264 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2265 : 			iStartMoves = iBaseMoves * GC.getMOVE_DENOMINATOR();
; 2266 : #else
; 2267 : 			iStartMoves = pCacheData->baseMoves((pToPlot->isWater() && !pToPlot->IsAllowsWalkWater()) ? DOMAIN_SEA : DOMAIN_LAND) * GC.getMOVE_DENOMINATOR();

	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN9@PathAdd
	mov	ecx, esi
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	test	al, al
	jne	SHORT $LN9@PathAdd
	xor	eax, eax
	jmp	SHORT $LN10@PathAdd
$LN9@PathAdd:
	mov	eax, 2
$LN10@PathAdd:
	mov	ecx, DWORD PTR _finder$[esp+16]
	mov	ebp, DWORD PTR [ecx+eax*4+116]
	imul	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
$LN4@PathAdd:

; 2268 : #endif
; 2269 : 		}
; 2270 : 
; 2271 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2272 : 		// We can just set maxMoves to the maximum integer value and use it for increased portability and no redundant checks, iMoves gets set to 0 anyway if it's negative
; 2273 : 		iMoves = iStartMoves - CvUnitMovement::MovementCost(pUnit, pFromPlot, pToPlot, iBaseMoves, MAX_INT, iStartMoves);
; 2274 : 		if (iMoves < 0)
; 2275 : 			iMoves = 0;
; 2276 : #else
; 2277 : 		// We can't use maxMoves, because that checks where the unit is currently, and we're plotting a path so we have to see
; 2278 : 		// what the max moves would be like if the unit was already at the desired location.
; 2279 : 		if (CvUnitMovement::ConsumesAllMoves(pUnit, pFromPlot, pToPlot) || CvUnitMovement::IsSlowedByZOC(pUnit, pFromPlot, pToPlot))

	mov	ebx, DWORD PTR _pointer$[esp+16]
	push	esi
	push	edi
	push	ebx
	call	?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::ConsumesAllMoves
	add	esp, 12					; 0000000cH
	test	al, al
	jne	SHORT $LN2@PathAdd
	push	esi
	push	edi
	push	ebx
	call	?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::IsSlowedByZOC
	add	esp, 12					; 0000000cH
	test	al, al
	jne	SHORT $LN2@PathAdd

; 2282 : 		}
; 2283 : 		else
; 2284 : 		{
; 2285 : 			iMoves = std::min(iMoves, std::max(0, iStartMoves - CvUnitMovement::MovementCost(pUnit, pFromPlot, pToPlot, pCacheData->baseMoves((pToPlot->isWater() || pCacheData->isEmbarked())?DOMAIN_SEA:pCacheData->getDomainType()), pCacheData->maxMoves(), iStartMoves)));

	cmp	BYTE PTR [esi+5], 3
	mov	edx, DWORD PTR _finder$[esp+16]
	je	SHORT $LN11@PathAdd
	cmp	BYTE PTR [edx+157], al
	jne	SHORT $LN11@PathAdd
	mov	ecx, DWORD PTR [edx+148]
	jmp	SHORT $LN12@PathAdd
$LN11@PathAdd:
	xor	ecx, ecx
$LN12@PathAdd:
	mov	eax, DWORD PTR [edx+136]
	mov	ecx, DWORD PTR [edx+ecx*4+116]
	push	ebp
	push	eax
	push	ecx
	push	esi
	push	edi
	push	ebx
	call	?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCost
	sub	ebp, eax
	add	esp, 24					; 00000018H
	mov	DWORD PTR $T223873[esp+16], ebp
	mov	DWORD PTR $T223876[esp+16], 0
	test	ebp, ebp
	jle	SHORT $LN51@PathAdd
	cmp	ebp, 2147483647				; 7fffffffH
	lea	eax, DWORD PTR $T223873[esp+16]
	jl	SHORT $LN56@PathAdd
	lea	eax, DWORD PTR _iMoves$[esp+20]
$LN56@PathAdd:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN59@PathAdd
$LN51@PathAdd:
	lea	eax, DWORD PTR $T223876[esp+16]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN59@PathAdd
$LN2@PathAdd:

; 2280 : 		{
; 2281 : 			iMoves = 0;

	xor	eax, eax
$LN59@PathAdd:

; 2286 : 		}
; 2287 : #endif
; 2288 : 	}
; 2289 : 
; 2290 : 	FAssertMsg(iMoves >= 0, "iMoves is expected to be non-negative (invalid Index)");
; 2291 : 
; 2292 : 	node->m_iData1 = iMoves;

	mov	ecx, DWORD PTR _node$[esp+16]

; 2293 : 	node->m_iData2 = iTurns;

	mov	edx, DWORD PTR _iTurns$[esp+16]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+12], eax
	pop	ebx
	mov	DWORD PTR [ecx+16], edx

; 2294 : 
; 2295 : 	return 1;

	mov	eax, 1

; 2296 : }

	pop	ecx
	ret	0
?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; PathAdd
_TEXT	ENDS
PUBLIC	?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathNodeAdd
; Function compile flags: /Ogtpy
;	COMDAT ?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; PathNodeAdd, COMDAT

; 2302 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 2303 : 	CvAStarNode* pNode;
; 2304 : #endif
; 2305 : 
; 2306 : 	if(data == ASNL_ADDOPEN || data == ASNL_STARTOPEN)

	mov	eax, DWORD PTR _data$[esp-4]
	test	eax, eax
	je	SHORT $LN3@PathNodeAd
	cmp	eax, 1
	jne	$LN27@PathNodeAd
$LN3@PathNodeAd:
	push	esi

; 2307 : 	{
; 2308 : 		// Are there movement points left and we're worried about stacking or mountains?
; 2309 : #if defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES)
; 2310 : 		if (node->m_iData1 > 0 && !finder->IsPathDest(node->m_iX, node->m_iY) && (!(finder->GetInfo() & MOVE_IGNORE_STACKING) || node->m_pPlot->isMountain()))
; 2311 : #else
; 2312 : 		if(node->m_iData1 > 0 && !finder->IsPathDest(node->m_iX, node->m_iY) && (!(finder->GetInfo() & MOVE_IGNORE_STACKING) || GC.getMap().plotUnchecked(node->m_iX, node->m_iY)->isMountain()))

	mov	esi, DWORD PTR _node$[esp]
	cmp	DWORD PTR [esi+12], 0
	jle	$LN25@PathNodeAd
	movsx	ecx, WORD PTR [esi+82]
	movsx	edx, WORD PTR [esi+80]
	push	edi
	mov	edi, DWORD PTR _finder$[esp+4]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN7@PathNodeAd
	push	ebp
	mov	ebp, DWORD PTR [edi+44]
	push	edi
	push	ebp
	push	ecx
	push	edx
	call	eax
	add	esp, 16					; 00000010H
	pop	ebp
	test	eax, eax
	jne	$LN28@PathNodeAd
$LN7@PathNodeAd:
	test	BYTE PTR [edi+72], 4
	je	SHORT $LN1@PathNodeAd
	movsx	eax, WORD PTR [esi+82]
	movsx	edx, WORD PTR [esi+80]
	mov	ecx, eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, DWORD PTR [eax+4020]
	mov	eax, DWORD PTR [eax+4068]
	add	ecx, edx
	imul	ecx, 484				; 000001e4H
	cmp	BYTE PTR [ecx+eax+5], 0
	jne	SHORT $LN28@PathNodeAd
$LN1@PathNodeAd:

; 2313 : #endif
; 2314 : 		{
; 2315 : 			// Retrieve another node
; 2316 : #if defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 2317 : 			CvTwoLayerPathFinder* twoLayerFinder = static_cast<CvTwoLayerPathFinder*>(finder);
; 2318 : 			CvAStarNode* pNode = twoLayerFinder->GetPartialMoveNode(node->m_iX, node->m_iY);
; 2319 : #else
; 2320 : 			CvTwoLayerPathFinder* twoLayerFinder = static_cast<CvTwoLayerPathFinder*>(finder);
; 2321 : 			pNode = twoLayerFinder->GetPartialMoveNode(node->m_iX, node->m_iY);

	movsx	eax, WORD PTR [esi+82]
	movsx	ecx, WORD PTR [esi+80]
	mov	edx, DWORD PTR [edi+628]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 5
	add	eax, DWORD PTR [edx+ecx*4]

; 2322 : #endif
; 2323 : 			pNode->m_iData1 = 0;   // Zero out movement

	mov	DWORD PTR [eax+12], 0

; 2324 : 			pNode->m_iData2 = node->m_iData2;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], ecx

; 2325 : 			pNode->m_iHeuristicCost = node->m_iHeuristicCost;

	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx

; 2326 : 			pNode->m_iKnownCost = node->m_iKnownCost + (PATH_MOVEMENT_WEIGHT * node->m_iData1);

	mov	ecx, DWORD PTR [esi+12]
	imul	ecx, 1000				; 000003e8H
	add	ecx, DWORD PTR [esi+4]

; 2327 : 			pNode->m_iTotalCost = node->m_iTotalCost;
; 2328 : 			pNode->m_iX = node->m_iX;
; 2329 : 			pNode->m_iY = node->m_iY;
; 2330 : 			pNode->m_pParent = node->m_pParent;
; 2331 : 			pNode->m_eCvAStarListType = CVASTARLIST_OPEN;
; 2332 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2333 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2334 : 			pNode->bIsCalculated = node->bIsCalculated;
; 2335 : #endif
; 2336 : 			pNode->bPlotVisibleToTeam = node->bPlotVisibleToTeam;
; 2337 : 			pNode->bIsMountain = node->bIsMountain;
; 2338 : 			pNode->bIsWater = node->bIsWater;
; 2339 : 			pNode->bCanEnterTerrain = node->bCanEnterTerrain;
; 2340 : 			pNode->bIsRevealedToTeam = node->bIsRevealedToTeam;
; 2341 : 			pNode->bContainsOtherFriendlyTeamCity = node->bContainsOtherFriendlyTeamCity;
; 2342 : 			pNode->bContainsEnemyCity = node->bContainsEnemyCity;
; 2343 : 			pNode->bContainsVisibleEnemy = node->bContainsVisibleEnemy;
; 2344 : 			pNode->bContainsVisibleEnemyDefender = node->bContainsVisibleEnemyDefender;
; 2345 : #else
; 2346 : 			pNode->m_kCostCacheData = node->m_kCostCacheData;
; 2347 : #endif
; 2348 : 			finder->AddToOpen(pNode);

	push	eax
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	mov	cx, WORD PTR [esi+80]
	mov	WORD PTR [eax+80], cx
	mov	dx, WORD PTR [esi+82]
	mov	WORD PTR [eax+82], dx
	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+20], 0
	mov	edx, DWORD PTR [esi+88]
	mov	DWORD PTR [eax+88], edx
	mov	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [eax+92], ecx
	mov	ecx, edi
	call	?AddToOpen@CvAStar@@QAEXPAVCvAStarNode@@@Z ; CvAStar::AddToOpen
$LN28@PathNodeAd:
	pop	edi
$LN25@PathNodeAd:
	pop	esi
$LN27@PathNodeAd:

; 2349 : 		}
; 2350 : 	}
; 2351 : 
; 2352 : 	return 1;

	mov	eax, 1

; 2353 : }

	ret	0
?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; PathNodeAdd
_TEXT	ENDS
PUBLIC	?IgnoreUnitsDestValid@@YAHHHPBXPAVCvAStar@@@Z	; IgnoreUnitsDestValid
EXTRN	?canEnterTerritory@CvUnit@@QBE_NW4TeamTypes@@_N11@Z:PROC ; CvUnit::canEnterTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?IgnoreUnitsDestValid@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?IgnoreUnitsDestValid@@YAHHHPBXPAVCvAStar@@@Z PROC	; IgnoreUnitsDestValid, COMDAT

; 2363 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2364 : 	CvPlot* pToPlot = GC.getMap().plotUnchecked(iToX, iToY);
; 2365 : 	CvUnit* pUnit = ((CvUnit*)pointer);
; 2366 : #else
; 2367 : 	CvUnit* pUnit;
; 2368 : 	CvPlot* pToPlot;
; 2369 : 	bool bAIControl;
; 2370 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 2371 : 
; 2372 : 	pToPlot = kMap.plotUnchecked(iToX, iToY);

	mov	ecx, DWORD PTR [eax+4020]
	mov	eax, DWORD PTR [eax+4068]
	push	ebx

; 2373 : 
; 2374 : 	pUnit = ((CvUnit*)pointer);
; 2375 : #endif
; 2376 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());
; 2377 : 
; 2378 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2379 : 	CvPlot* pUnitPlot = pUnit->plot();
; 2380 : #else
; 2381 : 	CvPlot* pUnitPlot = kMap.plotUnchecked(pUnit->getX(), pUnit->getY());
; 2382 : #endif
; 2383 : 	if(pUnitPlot == pToPlot)

	mov	ebx, DWORD PTR _pointer$[esp]
	mov	edx, DWORD PTR [ebx+88]
	push	ebp
	imul	edx, ecx
	add	edx, DWORD PTR [ebx+76]
	push	esi
	mov	ebp, DWORD PTR _finder$[esp+8]
	imul	edx, 484				; 000001e4H
	mov	esi, ecx
	imul	esi, DWORD PTR _iToY$[esp+8]
	add	esi, DWORD PTR _iToX$[esp+8]
	add	edx, eax
	imul	esi, 484				; 000001e4H
	add	esi, eax
	cmp	edx, esi
	jne	SHORT $LN8@IgnoreUnit
	pop	esi
	pop	ebp

; 2384 : 	{
; 2385 : 		return TRUE;

	mov	eax, 1
	pop	ebx

; 2453 : }

	ret	0
$LN8@IgnoreUnit:

; 2386 : 	}
; 2387 : 
; 2388 : 	if(pCacheData->IsImmobile())

	cmp	BYTE PTR [ebp+154], 0
	je	SHORT $LN7@IgnoreUnit
$LN54@IgnoreUnit:
	pop	esi
	pop	ebp

; 2389 : 	{
; 2390 : 		return FALSE;

	xor	eax, eax
	pop	ebx

; 2453 : }

	ret	0
$LN7@IgnoreUnit:

; 2391 : 	}
; 2392 : 
; 2393 : #ifndef ASTAR_AI_CONTROL_FIX_RADAR
; 2394 : 	if(pToPlot->isMountain() && (!pCacheData->isHuman() || pCacheData->IsAutomated()))
; 2395 : 	{
; 2396 : 		return FALSE;
; 2397 : 	}
; 2398 : #endif
; 2399 : 
; 2400 : 	if ((finder->GetInfo() & CvUnit::MOVEFLAG_STAY_ON_LAND) && (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater()))

	test	DWORD PTR [ebp+72], 256			; 00000100H
	je	SHORT $LN6@IgnoreUnit
	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN6@IgnoreUnit
	mov	ecx, esi
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	test	al, al

; 2401 : 	{
; 2402 : 		return FALSE;

	je	SHORT $LN54@IgnoreUnit
$LN6@IgnoreUnit:
	push	edi

; 2403 : 	}
; 2404 : 
; 2405 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2406 : 	bool bAIControl = pCacheData->IsAutomated();
; 2407 : #else
; 2408 : 	bAIControl = pCacheData->IsAutomated();
; 2409 : #endif
; 2410 : #ifndef ASTAR_AI_CONTROL_FIX_RADAR
; 2411 : 	if(bAIControl)
; 2412 : 	{
; 2413 : 		if(pCacheData->getDomainType() == DOMAIN_LAND)
; 2414 : 		{
; 2415 : 			int iGroupAreaID = pUnit->area()->GetID();
; 2416 : 			if(pToPlot->getArea() != iGroupAreaID)
; 2417 : 			{
; 2418 : 				if(!(pToPlot->isAdjacentToArea(iGroupAreaID)))
; 2419 : 				{
; 2420 : 					return FALSE;
; 2421 : 				}
; 2422 : 			}
; 2423 : 		}
; 2424 : 	}
; 2425 : #endif
; 2426 : 
; 2427 : 	TeamTypes eUnitTeam = pUnit->getTeam();

	mov	ecx, ebx
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	edi, eax

; 2428 : 
; 2429 : 	if(!pToPlot->isRevealed(eUnitTeam))

	shr	eax, 5
	mov	ecx, eax
	shl	ecx, 5
	mov	edx, ecx
	mov	ecx, edi
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [esi+eax*4+8]
	jne	SHORT $LN4@IgnoreUnit

; 2430 : 	{
; 2431 : 		if(pCacheData->isNoRevealMap())

	cmp	BYTE PTR [ebp+155], 0

; 2432 : 		{
; 2433 : 			return FALSE;

	jne	SHORT $LN1@IgnoreUnit
$LN4@IgnoreUnit:

; 2434 : 		}
; 2435 : 	}
; 2436 : 
; 2437 : #ifdef ASTAR_AI_CONTROL_FIX_RADAR
; 2438 : 	if(pToPlot->isRevealed(eUnitTeam))

	mov	ecx, eax
	shl	ecx, 5
	mov	edx, ecx
	mov	ecx, edi
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [esi+eax*4+8]
	je	SHORT $LN2@IgnoreUnit

; 2439 : #else
; 2440 : 	if(bAIControl || pToPlot->isRevealed(eUnitTeam))
; 2441 : #endif
; 2442 : 	{
; 2443 : #ifdef AUI_ASTAR_FIX_IGNORE_UNITS_PATHFINDER_TERRITORY_CHECK
; 2444 : 		if (!pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE) || !pUnit->canEnterTerritory(pToPlot->getTeam(), false, false, pUnit->IsDeclareWar() || (finder->GetInfo() & MOVE_DECLARE_WAR)))
; 2445 : #else
; 2446 : 		if(!pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE) || !pUnit->canEnterTerritory(eUnitTeam))

	push	128					; 00000080H
	push	esi
	mov	ecx, ebx
	call	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canEnterTerrain
	test	al, al
	je	SHORT $LN1@IgnoreUnit
	push	0
	push	0
	push	0
	push	edi
	mov	ecx, ebx
	call	?canEnterTerritory@CvUnit@@QBE_NW4TeamTypes@@_N11@Z ; CvUnit::canEnterTerritory
	test	al, al
	jne	SHORT $LN2@IgnoreUnit
$LN1@IgnoreUnit:
	pop	edi
	pop	esi
	pop	ebp

; 2447 : #endif
; 2448 : 		{
; 2449 : 			return FALSE;

	xor	eax, eax
	pop	ebx

; 2453 : }

	ret	0
$LN2@IgnoreUnit:
	pop	edi
	pop	esi
	pop	ebp

; 2450 : 		}
; 2451 : 	}
; 2452 : 	return TRUE;

	mov	eax, 1
	pop	ebx

; 2453 : }

	ret	0
?IgnoreUnitsDestValid@@YAHHHPBXPAVCvAStar@@@Z ENDP	; IgnoreUnitsDestValid
_TEXT	ENDS
PUBLIC	?IgnoreUnitsCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; IgnoreUnitsCost
EXTRN	?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z:PROC ; CvUnitMovement::MovementCostNoZOC
; Function compile flags: /Ogtpy
;	COMDAT ?IgnoreUnitsCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_iMovesLeft$ = -4					; size = 4
$T224138 = 8						; size = 4
$T224134 = 8						; size = 4
_iCost$ = 8						; size = 4
_parent$ = 8						; size = 4
_eUnitTeam$ = 12					; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
$T224139 = 20						; size = 4
_pointer$ = 20						; size = 4
$T224142 = 24						; size = 4
$T224135 = 24						; size = 4
$T224133 = 24						; size = 4
_finder$ = 24						; size = 4
?IgnoreUnitsCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; IgnoreUnitsCost, COMDAT

; 2459 : {

	push	ecx

; 2460 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 2461 : 	CvUnit* pUnit;
; 2462 : 	int iCost;
; 2463 : #endif
; 2464 : 	int iMax;
; 2465 : 
; 2466 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 2467 : 	const CvPlot* pFromPlot = parent->m_pPlot;
; 2468 : 	const CvPlot* pToPlot = node->m_pPlot;
; 2469 : #else
; 2470 : 	CvMap& kMap = GC.getMap();
; 2471 : 	int iFromPlotX = parent->m_iX;
; 2472 : 	int iFromPlotY = parent->m_iY;
; 2473 : 	CvPlot* pFromPlot = kMap.plotUnchecked(iFromPlotX, iFromPlotY);

	mov	edx, DWORD PTR _parent$[esp]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [eax+4020]
	push	ebx

; 2474 : 
; 2475 : 	int iToPlotX = node->m_iX;
; 2476 : 	int iToPlotY = node->m_iY;
; 2477 : 	CvPlot* pToPlot = kMap.plotUnchecked(iToPlotX, iToPlotY);

	mov	ebx, DWORD PTR _node$[esp+4]
	push	ebp
	push	esi
	movsx	esi, WORD PTR [edx+80]
	push	edi
	movsx	edi, WORD PTR [edx+82]
	imul	edi, ecx
	add	edi, esi
	movsx	esi, WORD PTR [ebx+82]
	imul	edi, 484				; 000001e4H
	mov	eax, DWORD PTR [eax+4068]
	imul	esi, ecx
	movsx	ecx, WORD PTR [ebx+80]

; 2478 : #endif
; 2479 : 
; 2480 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2481 : 	CvUnit* pUnit = ((CvUnit*)pointer);
; 2482 : #else
; 2483 : 	pUnit = ((CvUnit*)pointer);
; 2484 : #endif
; 2485 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());
; 2486 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2487 : 	bool bIsAIControl = !pCacheData->isHuman() || pCacheData->IsAutomated();
; 2488 : #endif
; 2489 : 
; 2490 : 	CvAssertMsg(pUnit->getDomainType() != DOMAIN_AIR, "pUnit->getDomainType() is not expected to be equal with DOMAIN_AIR");
; 2491 : 
; 2492 : #if defined(AUI_ASTAR_MINOR_OPTIMIZATION) || defined (AUI_UNIT_FIX_HOVERING_EMBARK) || defined(AUI_UNIT_MOVEMENT_FIX_BAD_ALLOWS_WATER_WALK_CHECK)
; 2493 : 	bool bToPlotIsWater = !pToPlot->IsAllowsWalkWater();
; 2494 : 	bool bFromPlotIsWater = !pFromPlot->IsAllowsWalkWater();
; 2495 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 2496 : 	if (pUnit->IsHoveringUnit())
; 2497 : 	{
; 2498 : 		bToPlotIsWater = bToPlotIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 2499 : 		bFromPlotIsWater = bFromPlotIsWater && pFromPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 2500 : 	}
; 2501 : 	else
; 2502 : #endif
; 2503 : 	{
; 2504 : 		bToPlotIsWater = bToPlotIsWater && pToPlot->isWater();
; 2505 : 		bFromPlotIsWater = bFromPlotIsWater && pFromPlot->isWater();
; 2506 : 	}
; 2507 : 	int iBaseMoves = pCacheData->baseMoves(bFromPlotIsWater || pCacheData->isEmbarked() ? DOMAIN_SEA : pCacheData->getDomainType());
; 2508 : 	int iMaxMoves = iBaseMoves * GC.getMOVE_DENOMINATOR();
; 2509 : #endif
; 2510 : 
; 2511 : 	if(parent->m_iData1 > 0)

	mov	edx, DWORD PTR [edx+12]
	add	esi, ecx
	imul	esi, 484				; 000001e4H
	add	edi, eax
	add	esi, eax
	test	edx, edx
	jle	SHORT $LN26@IgnoreUnit@2

; 2512 : 	{
; 2513 : 		iMax = parent->m_iData1;
; 2514 : 	}
; 2515 : 	else

	mov	ecx, DWORD PTR _finder$[esp+16]
	mov	ebx, edx
	jmp	SHORT $LN25@IgnoreUnit@2
$LN26@IgnoreUnit@2:

; 2516 : 	{
; 2517 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2518 : 		iMax = iMaxMoves;
; 2519 : #else
; 2520 : 		iMax = pCacheData->baseMoves((pToPlot->isWater() && !pToPlot->IsAllowsWalkWater()) ? DOMAIN_SEA : DOMAIN_LAND) * GC.getMOVE_DENOMINATOR();

	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN29@IgnoreUnit@2
	mov	ecx, esi
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	test	al, al
	jne	SHORT $LN29@IgnoreUnit@2
	xor	eax, eax
	jmp	SHORT $LN30@IgnoreUnit@2
$LN29@IgnoreUnit@2:
	mov	eax, 2
$LN30@IgnoreUnit@2:
	mov	ecx, DWORD PTR _finder$[esp+16]
	mov	ebx, DWORD PTR [ecx+eax*4+116]
	imul	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
$LN25@IgnoreUnit@2:

; 2521 : #endif
; 2522 : 	}
; 2523 : 
; 2524 : 	// Get the cost of moving to the new plot, passing in our max moves or the moves we have left, in case the movementCost 
; 2525 : 	// method wants to burn all our remaining moves.  This is needed because our remaining moves for this segment of the path
; 2526 : 	// may be larger or smaller than the baseMoves if some moves have already been used or if the starting domain (LAND/SEA)
; 2527 : 	// of the path segment is different from the destination plot.
; 2528 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2529 : 	int iCost = CvUnitMovement::MovementCostNoZOC(pUnit, pFromPlot, pToPlot, iBaseMoves, iMaxMoves, iMax);
; 2530 : #else
; 2531 : 	iCost = CvUnitMovement::MovementCostNoZOC(pUnit, pFromPlot, pToPlot, pCacheData->baseMoves((pToPlot->isWater() || pCacheData->isEmbarked())?DOMAIN_SEA:pCacheData->getDomainType()), pCacheData->maxMoves(), iMax);

	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN31@IgnoreUnit@2
	cmp	BYTE PTR [ecx+157], 0
	jne	SHORT $LN31@IgnoreUnit@2
	mov	edx, DWORD PTR [ecx+148]
	jmp	SHORT $LN32@IgnoreUnit@2
$LN31@IgnoreUnit@2:
	xor	edx, edx
$LN32@IgnoreUnit@2:
	mov	eax, DWORD PTR [ecx+136]
	mov	ecx, DWORD PTR [ecx+edx*4+116]
	mov	edx, DWORD PTR _pointer$[esp+16]
	push	ebx
	push	eax
	push	ecx
	push	esi
	push	edi
	push	edx
	call	?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCostNoZOC

; 2532 : #endif
; 2533 : 
; 2534 : 	TeamTypes eUnitTeam = pUnit->getTeam();

	mov	ecx, DWORD PTR _pointer$[esp+40]
	add	esp, 24					; 00000018H
	mov	ebp, eax
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR _eUnitTeam$[esp+16], eax

; 2535 : 
; 2536 : 	int iMovesLeft = iMax - iCost;

	mov	eax, ebx
	sub	eax, ebp
	mov	DWORD PTR _iMovesLeft$[esp+20], eax

; 2537 : 	// Is the cost greater than our max?
; 2538 : 	if (iMovesLeft < 0)

	jns	SHORT $LN24@IgnoreUnit@2

; 2539 : 	{
; 2540 : 		// Yes, we will still let the move happen, but that is the end of the turn.
; 2541 : 		iCost = iMax;

	mov	ebp, ebx

; 2542 : 		iMovesLeft = 0;

	mov	DWORD PTR _iMovesLeft$[esp+20], 0

; 2543 : 	}
; 2544 : 
; 2545 : 	if(iMovesLeft == 0)

	jmp	SHORT $LN158@IgnoreUnit@2
$LN24@IgnoreUnit@2:
	test	eax, eax
	jne	$LN23@IgnoreUnit@2
$LN158@IgnoreUnit@2:

; 2546 : 	{
; 2547 : 		iCost = (PATH_MOVEMENT_WEIGHT * iCost);

	imul	ebp, 1000				; 000003e8H

; 2548 : 
; 2549 : #ifdef AUI_UNIT_MOVEMENT_FIX_BAD_ALLOWS_WATER_WALK_CHECK
; 2550 : 		if (pUnit->getDomainType() == DOMAIN_LAND && !bFromPlotIsWater && bToPlotIsWater && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))
; 2551 : #else
; 2552 : 		if(!pFromPlot->isWater() && pToPlot->isWater() && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))

	cmp	BYTE PTR [edi+5], 3
	mov	ebx, ebp
	mov	DWORD PTR _iCost$[esp+16], ebx
	je	SHORT $LN160@IgnoreUnit@2
	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN160@IgnoreUnit@2
	mov	ecx, DWORD PTR _pointer$[esp+16]
	push	0
	push	1
	push	esi
	push	edi
	call	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z ; CvUnit::canEmbarkOnto
	test	al, al
	jne	SHORT $LN160@IgnoreUnit@2

; 2553 : #endif
; 2554 : 		{
; 2555 : 			iCost += PATH_INCORRECT_EMBARKING_WEIGHT;

	add	ebx, 1000000				; 000f4240H
	mov	DWORD PTR _iCost$[esp+16], ebx
$LN160@IgnoreUnit@2:

; 2556 : 		}
; 2557 : 
; 2558 : 		if(pToPlot->getTeam() != eUnitTeam)

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN74@IgnoreUnit@2
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN74@IgnoreUnit@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN73@IgnoreUnit@2
$LN74@IgnoreUnit@2:
	or	eax, -1
$LN73@IgnoreUnit@2:
	cmp	eax, DWORD PTR _eUnitTeam$[esp+16]
	je	SHORT $LN21@IgnoreUnit@2

; 2559 : 		{
; 2560 : 			iCost += PATH_TERRITORY_WEIGHT;

	add	ebx, 3
	mov	DWORD PTR _iCost$[esp+16], ebx
$LN21@IgnoreUnit@2:

; 2561 : 		}
; 2562 : 
; 2563 : #ifdef AUI_ASTAR_EXPLORE_UNITAITYPE_ALWAYS_MAXIMIZES_EXPLORE
; 2564 : 		if (finder->GetInfo() & MOVE_MAXIMIZE_EXPLORE || pUnit->AI_getUnitAIType() == UNITAI_EXPLORE || pUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA)
; 2565 : #else
; 2566 : 		if(finder->GetInfo() & MOVE_MAXIMIZE_EXPLORE)

	mov	ebp, DWORD PTR _finder$[esp+16]
	test	BYTE PTR [ebp+72], -128			; ffffff80H
	je	SHORT $LN19@IgnoreUnit@2

; 2567 : #endif
; 2568 : 		{
; 2569 : #ifdef AUI_ASTAR_FIX_MAXIMIZE_EXPLORE_UNHARDCODE_HILL_PREFERENCE
; 2570 : 			iCost += PATH_EXPLORE_NON_HILL_WEIGHT * pToPlot->seeFromLevel(eUnitTeam);
; 2571 : #else
; 2572 : 			if(!pToPlot->isHills())

	cmp	BYTE PTR [esi+5], 1
	je	SHORT $LN19@IgnoreUnit@2

; 2573 : 			{
; 2574 : 				iCost += PATH_EXPLORE_NON_HILL_WEIGHT;

	add	ebx, 300				; 0000012cH
	mov	DWORD PTR _iCost$[esp+16], ebx
$LN19@IgnoreUnit@2:

; 2575 : 			}
; 2576 : #endif
; 2577 : 		}
; 2578 : 
; 2579 : 		// Damage caused by features (mods)
; 2580 : 		if(0 != GC.getPATH_DAMAGE_WEIGHT())

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6944, 0
	je	SHORT $LN162@IgnoreUnit@2

; 2581 : 		{
; 2582 : 			if(pToPlot->getFeatureType() != NO_FEATURE)

	mov	al, BYTE PTR [esi+432]
	cmp	al, -1
	je	SHORT $LN17@IgnoreUnit@2

; 2583 : 			{
; 2584 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2585 : 				iCost += (GC.getPATH_DAMAGE_WEIGHT() * MAX(0, GC.getFeatureInfo(pToPlot->getFeatureType())->getTurnDamage())) / GC.getMAX_HIT_POINTS();
; 2586 : #else
; 2587 : 				iCost += (GC.getPATH_DAMAGE_WEIGHT() * std::max(0, GC.getFeatureInfo(pToPlot->getFeatureType())->getTurnDamage())) / GC.getMAX_HIT_POINTS();

	movsx	eax, al
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getTurnDamage@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getTurnDamage
	mov	DWORD PTR $T224133[esp+16], eax
	test	eax, eax
	mov	DWORD PTR $T224134[esp+16], 0
	lea	eax, DWORD PTR $T224133[esp+16]
	jg	SHORT $LN105@IgnoreUnit@2
	lea	eax, DWORD PTR $T224134[esp+16]
$LN105@IgnoreUnit@2:
	mov	eax, DWORD PTR [eax]
	imul	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6944
	cdq
	idiv	DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	add	ebx, eax
	mov	DWORD PTR _iCost$[esp+16], ebx
$LN17@IgnoreUnit@2:

; 2588 : #endif
; 2589 : 			}
; 2590 : 
; 2591 : 			if(pToPlot->getExtraMovePathCost() > 0)

	mov	ecx, esi
	call	?getExtraMovePathCost@CvPlot@@QBEHXZ	; CvPlot::getExtraMovePathCost
	test	eax, eax
	jle	SHORT $LN162@IgnoreUnit@2

; 2592 : 			{
; 2593 : 				iCost += (PATH_MOVEMENT_WEIGHT * pToPlot->getExtraMovePathCost());

	mov	ecx, esi
	call	?getExtraMovePathCost@CvPlot@@QBEHXZ	; CvPlot::getExtraMovePathCost
	imul	eax, 1000				; 000003e8H
	add	ebx, eax
	mov	DWORD PTR _iCost$[esp+16], ebx
$LN162@IgnoreUnit@2:

; 2594 : 			}
; 2595 : 		}
; 2596 : 
; 2597 : 		if(pToPlot->getPlotCity() && !(pToPlot->getX() == finder->GetDestX() && pToPlot->getY() == finder->GetDestY()))

	mov	ecx, DWORD PTR [esi+104]
	test	ecx, ecx
	jl	SHORT $LN13@IgnoreUnit@2
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN13@IgnoreUnit@2
	mov	edx, DWORD PTR [esi+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 2598 : 		{
; 2599 : 			iCost += PATH_CITY_AVOID_WEIGHT; // slewis - this should be zeroed out currently
; 2600 : 		}
; 2601 : 	}
; 2602 : 	else

	jmp	SHORT $LN13@IgnoreUnit@2
$LN23@IgnoreUnit@2:

; 2603 : 	{
; 2604 : 		iCost = (PATH_MOVEMENT_WEIGHT * iCost);

	imul	ebp, 1000				; 000003e8H
	mov	ebx, ebp
	mov	ebp, DWORD PTR _finder$[esp+16]
	mov	DWORD PTR _iCost$[esp+16], ebx
$LN13@IgnoreUnit@2:

; 2605 : 	}
; 2606 : 
; 2607 : #ifdef AUI_ASTAR_EXPLORE_UNITAITYPE_ALWAYS_MAXIMIZES_EXPLORE
; 2608 : 	if (finder->GetInfo() & MOVE_MAXIMIZE_EXPLORE || pUnit->AI_getUnitAIType() == UNITAI_EXPLORE || pUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA)
; 2609 : #else
; 2610 : 	if(finder->GetInfo() & MOVE_MAXIMIZE_EXPLORE)

	test	BYTE PTR [ebp+72], -128			; ffffff80H
	je	SHORT $LN12@IgnoreUnit@2

; 2611 : #endif
; 2612 : 	{
; 2613 : #ifdef AUI_ASTAR_FIX_MAXIMIZE_EXPLORE_CONSIDER_2ND_RING_NONREVEALED
; 2614 : 		int iUnseenPlots = pToPlot->getNumNonrevealedInRange(eUnitTeam, pToPlot->seeFromLevel(eUnitTeam));
; 2615 : #else
; 2616 : 		int iUnseenPlots = pToPlot->getNumAdjacentNonrevealed(eUnitTeam);

	mov	eax, DWORD PTR _eUnitTeam$[esp+16]
	push	eax
	mov	ecx, esi
	call	?getNumAdjacentNonrevealed@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::getNumAdjacentNonrevealed

; 2617 : #endif
; 2618 : 		if(!pToPlot->isRevealed(eUnitTeam))

	mov	ecx, DWORD PTR _eUnitTeam$[esp+16]
	mov	edx, ecx
	shr	edx, 5
	mov	ebx, edx
	shl	ebx, 5
	sub	ecx, ebx
	mov	ebx, 1
	shl	ebx, cl
	test	ebx, DWORD PTR [esi+edx*4+8]
	jne	SHORT $LN11@IgnoreUnit@2

; 2619 : 		{
; 2620 : 			iUnseenPlots += 1;

	inc	eax
$LN11@IgnoreUnit@2:

; 2621 : 		}
; 2622 : 
; 2623 : 		iCost += (7 - iUnseenPlots) * PATH_EXPLORE_NON_REVEAL_WEIGHT;

	mov	edx, DWORD PTR _iCost$[esp+16]
	mov	ecx, 7
	sub	ecx, eax
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	ebx, DWORD PTR [edx+ecx*2]
$LN12@IgnoreUnit@2:

; 2624 : 	}
; 2625 : 
; 2626 : 	// If we are a land unit and we are moving through the water, make the cost a little higher so that
; 2627 : 	// we favor staying on land or getting back to land as quickly as possible because it is dangerous to
; 2628 : 	// be on the water.  Don't add this penalty if the unit is human controlled however, we will assume they want
; 2629 : 	// the best path, rather than the safest.
; 2630 : #ifdef AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT
; 2631 : 	if (pCacheData->getDomainType() == DOMAIN_LAND && (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater()))
; 2632 : 	{
; 2633 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2634 : 		if (bIsAIControl)
; 2635 : #else
; 2636 : 		if (!pCacheData->isHuman() || pCacheData->IsAutomated())
; 2637 : #endif
; 2638 : 		{
; 2639 : 			iCost += PATH_THROUGH_WATER;
; 2640 : 		}
; 2641 : 		else
; 2642 : 		{
; 2643 : 			iCost += AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT + PATH_TERRITORY_WEIGHT;
; 2644 : 		}
; 2645 : 	}
; 2646 : #else
; 2647 : 	if(pCacheData->getDomainType() == DOMAIN_LAND && (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater()) && (!pCacheData->isHuman() || pUnit->IsAutomated()))

	cmp	DWORD PTR [ebp+148], 2
	jne	SHORT $LN163@IgnoreUnit@2
	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN163@IgnoreUnit@2
	mov	ecx, esi
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	test	al, al
	jne	SHORT $LN163@IgnoreUnit@2
	cmp	BYTE PTR [ebp+152], al
	je	SHORT $LN9@IgnoreUnit@2
	mov	ecx, DWORD PTR _pointer$[esp+16]
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	test	al, al
	je	SHORT $LN163@IgnoreUnit@2
$LN9@IgnoreUnit@2:

; 2648 : 	{
; 2649 : 		iCost += PATH_THROUGH_WATER;

	add	ebx, 1000				; 000003e8H
$LN163@IgnoreUnit@2:

; 2650 : 	}
; 2651 : #endif
; 2652 : 
; 2653 : 	if(pUnit->IsCombatUnit())

	mov	ecx, DWORD PTR _pointer$[esp+16]
	cmp	DWORD PTR [ecx+1044], 0
	jle	$LN1@IgnoreUnit@2

; 2654 : 	{
; 2655 : #if defined(AUI_ASTAR_AVOID_RIVER_CROSSING_WHEN_ATTACKING) || defined(AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING)
; 2656 : 		bool bToPlotHasEnemy = pToPlot->isVisibleEnemyDefender(pUnit) || pToPlot->isEnemyCity(*pUnit);
; 2657 : 		if (iMovesLeft == 0 && !bToPlotHasEnemy)
; 2658 : #else
; 2659 : 		if(iMovesLeft == 0)

	cmp	DWORD PTR _iMovesLeft$[esp+20], 0
	jne	SHORT $LN7@IgnoreUnit@2

; 2660 : #endif
; 2661 : 		{
; 2662 : #ifdef AUI_ASTAR_FIX_DEFENSE_PENALTIES_CONSIDERED_FOR_UNITS_WITHOUT_DEFENSE_BONUS
; 2663 : 			int iDefenseBonus = pToPlot->defenseModifier(eUnitTeam, false);
; 2664 : 			if (iDefenseBonus > 0)
; 2665 : 			{
; 2666 : 				if (pUnit->noDefensiveBonus())
; 2667 : 					iDefenseBonus = 0;
; 2668 : 				else if (iDefenseBonus > 200)
; 2669 : 					iDefenseBonus = 200;
; 2670 : 			}
; 2671 : 			iCost += PATH_DEFENSE_WEIGHT * (200 - iDefenseBonus);
; 2672 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 2673 : 			iCost += (PATH_DEFENSE_WEIGHT * MAX(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pToPlot->defenseModifier(eUnitTeam, false)))));
; 2674 : #else
; 2675 : 			iCost += (PATH_DEFENSE_WEIGHT * std::max(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pToPlot->defenseModifier(eUnitTeam, false)))));

	call	?noDefensiveBonus@CvUnit@@QBE_NXZ	; CvUnit::noDefensiveBonus
	test	al, al
	je	SHORT $LN33@IgnoreUnit@2
	xor	eax, eax
	jmp	SHORT $LN34@IgnoreUnit@2
$LN33@IgnoreUnit@2:
	mov	eax, DWORD PTR _eUnitTeam$[esp+16]
	push	0
	push	0
	push	eax
	mov	ecx, esi
	call	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ; CvPlot::defenseModifier
$LN34@IgnoreUnit@2:
	mov	ecx, 200				; 000000c8H
	sub	ecx, eax
	mov	DWORD PTR $T224135[esp+16], ecx
	mov	DWORD PTR $T224138[esp+16], 0
	lea	eax, DWORD PTR $T224135[esp+16]
	test	ecx, ecx
	jg	SHORT $LN140@IgnoreUnit@2
	lea	eax, DWORD PTR $T224138[esp+16]
$LN140@IgnoreUnit@2:
	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [eax+eax*4]
	lea	ebx, DWORD PTR [ebx+ecx*2]
$LN7@IgnoreUnit@2:

; 2676 : #endif
; 2677 : 		}
; 2678 : 
; 2679 : #if !defined(AUI_ASTAR_AVOID_RIVER_CROSSING_WHEN_ATTACKING) && !defined(AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING)
; 2680 : 		if(pCacheData->IsAutomated())

	cmp	BYTE PTR [ebp+153], 0
	je	$LN1@IgnoreUnit@2

; 2681 : #endif
; 2682 : 		{
; 2683 : 			if(pCacheData->IsCanAttack())

	cmp	BYTE PTR [ebp+158], 0
	je	$LN1@IgnoreUnit@2

; 2684 : 			{
; 2685 : 				if(finder->IsPathDest(pToPlot->getX(), pToPlot->getY()))

	mov	eax, DWORD PTR [ebp]
	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	test	eax, eax
	je	$LN1@IgnoreUnit@2
	push	ebp
	mov	ebp, DWORD PTR [ebp+44]
	push	ebp
	push	ecx
	push	edx
	call	eax
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN1@IgnoreUnit@2

; 2686 : 				{
; 2687 : #if defined(AUI_ASTAR_AVOID_RIVER_CROSSING_WHEN_ATTACKING) || defined(AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING)
; 2688 : 					if (bToPlotHasEnemy)
; 2689 : #else
; 2690 : 					if(pToPlot->isVisibleEnemyDefender(pUnit))

	mov	ebp, DWORD PTR _pointer$[esp+16]
	push	ebp
	mov	ecx, esi
	call	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyDefender
	test	al, al
	je	SHORT $LN1@IgnoreUnit@2

; 2691 : #endif
; 2692 : 					{
; 2693 : #ifdef AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING
; 2694 : 						int iDealtDamage = 0;
; 2695 : 						int iSelfDamage = 0;
; 2696 : 						CvCity* pCity = pToPlot->getPlotCity();
; 2697 : 						if (pCity)
; 2698 : 						{
; 2699 : 							int iAttackerStrength = pUnit->GetMaxAttackStrength(pFromPlot, pToPlot, NULL);
; 2700 : 							int iDefenderStrength = pCity->getStrengthValue();
; 2701 : 
; 2702 : 							iDealtDamage = pUnit->getCombatDamage(iAttackerStrength, iDefenderStrength, pUnit->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ true);
; 2703 : 							iSelfDamage = pUnit->getCombatDamage(iDefenderStrength, iAttackerStrength, pCity->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ true, /*bDefenderIsCity*/ false);
; 2704 : 
; 2705 : 							// Will both the attacker die, and the city fall? If so, the unit wins
; 2706 : 							if (iDealtDamage + pCity->getDamage() >= pCity->GetMaxHitPoints())
; 2707 : 							{
; 2708 : 								if (pUnit->isNoCapture())
; 2709 : 									iDealtDamage = pCity->GetMaxHitPoints() - pCity->getDamage() - 1;
; 2710 : 								if (iSelfDamage >= pUnit->GetCurrHitPoints())
; 2711 : 									iSelfDamage = pUnit->GetCurrHitPoints() - 1;
; 2712 : 							}
; 2713 : 						}
; 2714 : 						else
; 2715 : 						{
; 2716 : 							CvUnit* pDefender = pToPlot->getVisibleEnemyDefender(pUnit);
; 2717 : 							if (pDefender && pDefender->IsCanDefend())
; 2718 : 							{
; 2719 : 								// handle the Zulu special thrown spear first attack
; 2720 : 								if (pUnit->isRangedSupportFire() && pUnit->canEverRangeStrikeAt(pToPlot->getX(), pToPlot->getY()))
; 2721 : 									iDealtDamage = pUnit->GetRangeCombatDamage(pDefender, /*pCity*/ NULL, /*bIncludeRand*/ false);
; 2722 : 
; 2723 : 								if (iDealtDamage < pDefender->GetCurrHitPoints())
; 2724 : 								{
; 2725 : 									int iAttackerStrength = pUnit->GetMaxAttackStrength(pFromPlot, pToPlot, pDefender);
; 2726 : 									int iDefenderStrength = pDefender->GetMaxDefenseStrength(pToPlot, pUnit);
; 2727 : 
; 2728 : #ifdef NQ_HEAVY_CHARGE_DOWNHILL
; 2729 : 									bool isAttackingFromHigherElevation = 
; 2730 : 										((pUnit->plot()->isMountain() && !pDefender->plot()->isMountain()) || // attacking from mountain to non-mountain
; 2731 : 										(pUnit->plot()->isHills() && pDefender->plot()->isFlatlands())); // attacking from hills to flatlands
; 2732 : 									if ((pUnit->IsCanHeavyCharge() || (pUnit->GetHeavyChargeDownhill() > 0 && isAttackingFromHigherElevation))
; 2733 : 										&& !pDefender->CanFallBackFromMelee(*pUnit))
; 2734 : #else
; 2735 : 									if (pUnit->IsCanHeavyCharge() && !pDefender->CanFallBackFromMelee(*pUnit))
; 2736 : #endif
; 2737 : 										iAttackerStrength = (iAttackerStrength * 150) / 100;
; 2738 : 									iSelfDamage = pDefender->getCombatDamage(iDefenderStrength, iAttackerStrength, pDefender->getDamage() + iDealtDamage, /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);
; 2739 : 									iDealtDamage = pUnit->getCombatDamage(iAttackerStrength, iDefenderStrength, pUnit->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);
; 2740 : 
; 2741 : 									// Will both units be killed by this? :o If so, take drastic corrective measures
; 2742 : 									if (iDealtDamage >= pDefender->GetCurrHitPoints() && iSelfDamage >= pUnit->GetCurrHitPoints())
; 2743 : 									{
; 2744 : 										// He who hath the least amount of damage survives with 1 HP left
; 2745 : 										if (iDealtDamage + pDefender->getDamage() > iSelfDamage + pUnit->getDamage())
; 2746 : 											iSelfDamage = pUnit->GetCurrHitPoints() - 1;
; 2747 : 										else
; 2748 : 											iDealtDamage = pDefender->GetCurrHitPoints() - 1;
; 2749 : 									}
; 2750 : 								}
; 2751 : 							}
; 2752 : 						}
; 2753 : 						if (iSelfDamage > pUnit->GetCurrHitPoints())
; 2754 : 							iSelfDamage = pUnit->GetMaxHitPoints();
; 2755 : 						if (iDealtDamage > GC.getMAX_HIT_POINTS())
; 2756 : 							iDealtDamage = GC.getMAX_HIT_POINTS();
; 2757 : 						iCost += iSelfDamage * PATH_DAMAGE_WEIGHT * pUnit->GetMaxHitPoints() / 100 + (GC.getMAX_HIT_POINTS() - iDealtDamage) * PATH_DAMAGE_WEIGHT / 10;
; 2758 : #else
; 2759 : #ifdef AUI_ASTAR_FIX_DEFENSE_PENALTIES_CONSIDERED_FOR_UNITS_WITHOUT_DEFENSE_BONUS
; 2760 : 						int iDefenseBonus = pFromPlot->defenseModifier(eUnitTeam, false);
; 2761 : 						if (iDefenseBonus > 0)
; 2762 : 						{
; 2763 : 							if (pUnit->noDefensiveBonus())
; 2764 : 								iDefenseBonus = 0;
; 2765 : 							else if (iDefenseBonus > 200)
; 2766 : 								iDefenseBonus = 200;
; 2767 : 						}
; 2768 : 						iCost += PATH_DEFENSE_WEIGHT * (200 - iDefenseBonus);
; 2769 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 2770 : 						iCost += (PATH_DEFENSE_WEIGHT * MAX(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pFromPlot->defenseModifier(eUnitTeam, false)))));
; 2771 : #else
; 2772 : 						iCost += (PATH_DEFENSE_WEIGHT * std::max(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pFromPlot->defenseModifier(eUnitTeam, false)))));

	mov	ecx, ebp
	call	?noDefensiveBonus@CvUnit@@QBE_NXZ	; CvUnit::noDefensiveBonus
	test	al, al
	je	SHORT $LN35@IgnoreUnit@2
	xor	eax, eax
	jmp	SHORT $LN36@IgnoreUnit@2
$LN35@IgnoreUnit@2:
	mov	edx, DWORD PTR _eUnitTeam$[esp+16]
	push	0
	push	0
	push	edx
	mov	ecx, edi
	call	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ; CvPlot::defenseModifier
$LN36@IgnoreUnit@2:
	mov	ecx, 200				; 000000c8H
	sub	ecx, eax
	mov	DWORD PTR $T224139[esp+16], ecx
	mov	DWORD PTR $T224142[esp+16], 0
	lea	eax, DWORD PTR $T224139[esp+16]
	test	ecx, ecx
	jg	SHORT $LN155@IgnoreUnit@2
	lea	eax, DWORD PTR $T224142[esp+16]
$LN155@IgnoreUnit@2:
	mov	eax, DWORD PTR [eax]
	lea	eax, DWORD PTR [eax+eax*4]

; 2773 : #endif
; 2774 : 
; 2775 : 						// I guess we may as well be the garrison
; 2776 : #if PATH_CITY_WEIGHT != 0
; 2777 : 						if(!(pFromPlot->isCity()))
; 2778 : 						{
; 2779 : 							iCost += PATH_CITY_WEIGHT;
; 2780 : 						}
; 2781 : #endif
; 2782 : 
; 2783 : 						if(!(pUnit->isRiverCrossingNoPenalty()))

	mov	ecx, ebp
	lea	ebx, DWORD PTR [ebx+eax*2]
	call	?isRiverCrossingNoPenalty@CvUnit@@QBE_NXZ ; CvUnit::isRiverCrossingNoPenalty
	test	al, al
	jne	SHORT $LN1@IgnoreUnit@2

; 2784 : 						{
; 2785 : 							if(pFromPlot->isRiverCrossing(directionXY(pFromPlot, pToPlot)))

	push	esi
	push	edi
	call	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
	add	esp, 8
	push	eax
	mov	ecx, edi
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	test	al, al
	je	SHORT $LN1@IgnoreUnit@2

; 2786 : 							{
; 2787 : 								iCost += (PATH_RIVER_WEIGHT * -(GC.getRIVER_ATTACK_MODIFIER()));
; 2788 : 								iCost += (PATH_MOVEMENT_WEIGHT * iMovesLeft);

	mov	eax, DWORD PTR _iMovesLeft$[esp+20]
	lea	ecx, DWORD PTR [eax+eax*4]
	add	ecx, ecx
	sub	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7388
	imul	ecx, 100				; 00000064H
	add	ebx, ecx
$LN1@IgnoreUnit@2:
	pop	edi
	pop	esi
	pop	ebp

; 2789 : 							}
; 2790 : 						}
; 2791 : #endif
; 2792 : 					}
; 2793 : 				}
; 2794 : 			}
; 2795 : 		}
; 2796 : 	}
; 2797 : 
; 2798 : 	FAssert(iCost != MAX_INT);
; 2799 : 
; 2800 : 	iCost += PATH_STEP_WEIGHT;

	lea	eax, DWORD PTR [ebx+2]
	pop	ebx

; 2801 : 
; 2802 : 	FAssert(iCost > 0);
; 2803 : 
; 2804 : 	return iCost;
; 2805 : }

	pop	ecx
	ret	0
?IgnoreUnitsCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; IgnoreUnitsCost
_TEXT	ENDS
PUBLIC	?IgnoreUnitsValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; IgnoreUnitsValid
; Function compile flags: /Ogtpy
;	COMDAT ?IgnoreUnitsValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?IgnoreUnitsValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; IgnoreUnitsValid, COMDAT

; 2812 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2813 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());
; 2814 : 	CvUnit* pUnit = ((CvUnit*)pointer);
; 2815 : 	TeamTypes eUnitTeam = pCacheData->getTeam();
; 2816 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 2817 : 	CvPlot* pToPlot = node->m_pPlot;
; 2818 : 	if (!pToPlot)
; 2819 : 		return FALSE;
; 2820 : #else
; 2821 : 	CvPlot* pToPlot = theMap.plotUnchecked(node->m_iX, node->m_iY);
; 2822 : #endif
; 2823 : 	bool bIsAIControl = !pCacheData->isHuman() || pCacheData->IsAutomated();
; 2824 : #else
; 2825 : 	CvUnit* pUnit;
; 2826 : 	CvPlot* pFromPlot;
; 2827 : 	CvPlot* pToPlot;
; 2828 : 	bool bAIControl;
; 2829 : #endif
; 2830 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2831 : 	PlayerTypes unit_owner = pUnit->getOwner();
; 2832 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2833 : 	CvAStarNode& kToNodeCacheData = *node;
; 2834 : #else
; 2835 : 	CvPathNodeCacheData& kToNodeCacheData = node->m_kCostCacheData;
; 2836 : #endif
; 2837 : #endif
; 2838 : 
; 2839 : 	if(parent == NULL)

	mov	edx, DWORD PTR _parent$[esp-4]
	test	edx, edx
	jne	SHORT $LN15@IgnoreUnit@3

; 2840 : 	{
; 2841 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2842 : 		// Cache values for this node that we will use when the node is checked again in the future
; 2843 : 		if (!kToNodeCacheData.bIsCalculated)
; 2844 : 		{
; 2845 : 			kToNodeCacheData.bIsCalculated = true;
; 2846 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 2847 : 			kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 2848 : 			if (pUnit->IsHoveringUnit())
; 2849 : 				kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 2850 : 			else
; 2851 : 				kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 2852 : #else
; 2853 : 			kToNodeCacheData.bIsWater = (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater());
; 2854 : #endif
; 2855 : 			kToNodeCacheData.bIsMountain = true;
; 2856 : 			kToNodeCacheData.bIsRevealedToTeam = true;
; 2857 : 			kToNodeCacheData.bCanEnterTerrain = true;
; 2858 : 		}
; 2859 : #endif
; 2860 : 		return TRUE;

	lea	eax, DWORD PTR [edx+1]

; 3013 : }

	ret	0
$LN15@IgnoreUnit@3:

; 2861 : 	}
; 2862 : 
; 2863 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2864 : 	// Cache values for this node that we will use when the node is checked again in the future
; 2865 : 	if (!kToNodeCacheData.bIsCalculated)
; 2866 : 	{
; 2867 : 		kToNodeCacheData.bIsCalculated = true;
; 2868 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 2869 : 		kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 2870 : 		if (pUnit->IsHoveringUnit())
; 2871 : 			kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 2872 : 		else
; 2873 : 			kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 2874 : #else
; 2875 : 		kToNodeCacheData.bIsWater = (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater());
; 2876 : #endif
; 2877 : 		// Recycling bIsMountain for Borders check (only for IgnoreUnits Pathfinder!)
; 2878 : #ifdef AUI_ASTAR_FIX_IGNORE_UNITS_PATHFINDER_TERRITORY_CHECK
; 2879 : 		kToNodeCacheData.bIsMountain = pUnit->canEnterTerritory(pToPlot->getTeam(), false, false, pUnit->IsDeclareWar() || (finder->GetInfo() & MOVE_DECLARE_WAR));
; 2880 : #else
; 2881 : 		kToNodeCacheData.bIsMountain = pUnit->canEnterTerritory(eUnitTeam);
; 2882 : #endif
; 2883 : 		kToNodeCacheData.bIsRevealedToTeam = pToPlot->isRevealed(eUnitTeam);
; 2884 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2885 : 		if (bIsAIControl || kToNodeCacheData.bIsRevealedToTeam)
; 2886 : #else
; 2887 : 		if (bAIControl || kToNodeCacheData.bIsRevealedToTeam || !bIsHuman)
; 2888 : #endif
; 2889 : 			kToNodeCacheData.bCanEnterTerrain = pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE);
; 2890 : 		else
; 2891 : 			kToNodeCacheData.bCanEnterTerrain = true;
; 2892 : 	}
; 2893 : 
; 2894 : #endif
; 2895 : 
; 2896 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2897 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 2898 : 	CvPlot* pFromPlot = parent->m_pPlot;
; 2899 : 	if (!pFromPlot)
; 2900 : 		return FALSE;
; 2901 : #else
; 2902 : 	CvPlot* pFromPlot = theMap.plotUnchecked(parent->m_iX, parent->m_iY);
; 2903 : #endif
; 2904 : 	CvPlot* pUnitPlot = pUnit->plot();
; 2905 : #else
; 2906 : 	CvMap& theMap = GC.getMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 2907 : 
; 2908 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 2909 : 	pFromPlot = parent->m_pPlot;
; 2910 : 	pToPlot = node->m_pPlot;
; 2911 : #else
; 2912 : 	pFromPlot = theMap.plotUnchecked(parent->m_iX, parent->m_iY);

	mov	eax, DWORD PTR [ecx+4020]
	push	ebx
	push	ebp
	push	esi
	movsx	esi, WORD PTR [edx+82]
	movsx	edx, WORD PTR [edx+80]
	imul	esi, eax
	mov	ecx, DWORD PTR [ecx+4068]
	add	esi, edx

; 2913 : 	pToPlot = theMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	edx, DWORD PTR _node$[esp+8]
	imul	esi, 484				; 000001e4H
	movsx	ebp, WORD PTR [edx+82]
	movsx	edx, WORD PTR [edx+80]
	imul	ebp, eax
	push	edi

; 2914 : #endif
; 2915 : 
; 2916 : 	pUnit = ((CvUnit*)pointer);
; 2917 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());
; 2918 : 
; 2919 : 	TeamTypes eUnitTeam = pCacheData->getTeam();
; 2920 : 
; 2921 : 	CvPlot* pUnitPlot = theMap.plotUnchecked(pUnit->getX(), pUnit->getY());

	mov	edi, DWORD PTR _pointer$[esp+12]
	mov	edi, DWORD PTR [edi+88]
	imul	edi, eax
	mov	eax, DWORD PTR _pointer$[esp+12]
	add	edi, DWORD PTR [eax+76]
	add	ebp, edx
	mov	edx, DWORD PTR _finder$[esp+12]
	imul	ebp, 484				; 000001e4H
	imul	edi, 484				; 000001e4H
	mov	ebx, DWORD PTR [edx+144]
	add	esi, ecx
	add	ebp, ecx
	add	edi, ecx

; 2922 : #endif
; 2923 : 
; 2924 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2925 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2926 : 	CvAStarNode& kFromNodeCacheData = *parent;
; 2927 : #else
; 2928 : 	CvPathNodeCacheData& kFromNodeCacheData = parent->m_kCostCacheData;
; 2929 : #endif
; 2930 : #endif
; 2931 : 
; 2932 : 	// slewis - moved this up so units can't move directly into the water. Not 100% sure this is the right solution.
; 2933 : 	if(pCacheData->getDomainType() == DOMAIN_LAND)

	cmp	DWORD PTR [edx+148], 2
	jne	SHORT $LN76@IgnoreUnit@3

; 2934 : 	{
; 2935 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2936 : 		if (!kFromNodeCacheData.bIsWater && kToNodeCacheData.bIsWater && kToNodeCacheData.bIsRevealedToTeam && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))
; 2937 : #else
; 2938 : 		if(!pFromPlot->isWater() && pToPlot->isWater() && pToPlot->isRevealed(eUnitTeam) && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))

	mov	al, 3
	cmp	BYTE PTR [esi+5], al
	je	SHORT $LN76@IgnoreUnit@3
	cmp	BYTE PTR [ebp+5], al
	jne	SHORT $LN76@IgnoreUnit@3
	mov	eax, ebx
	shr	eax, 5
	mov	ecx, eax
	shl	ecx, 5
	mov	edx, ecx
	mov	ecx, ebx
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [ebp+eax*4+8]
	je	SHORT $LN76@IgnoreUnit@3
	mov	ecx, DWORD PTR _pointer$[esp+12]
	push	0
	push	1
	push	ebp
	push	esi
	call	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z ; CvUnit::canEmbarkOnto
	test	al, al

; 2939 : #endif
; 2940 : 		{
; 2941 : 			return FALSE;

	je	$LN1@IgnoreUnit@3
$LN76@IgnoreUnit@3:

; 2942 : 		}
; 2943 : 	}
; 2944 : 
; 2945 : 	if(pUnitPlot == pFromPlot)

	cmp	edi, esi

; 2946 : 	{
; 2947 : 		return TRUE;

	je	$LN2@IgnoreUnit@3

; 2948 : 	}
; 2949 : 
; 2950 : 	if(finder->GetInfo() & MOVE_TERRITORY_NO_UNEXPLORED)

	mov	eax, DWORD PTR _finder$[esp+12]
	test	BYTE PTR [eax+72], 1
	je	SHORT $LN79@IgnoreUnit@3

; 2951 : 	{
; 2952 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2953 : 		if (!kFromNodeCacheData.bIsRevealedToTeam)
; 2954 : #else
; 2955 : 		if(!(pFromPlot->isRevealed(eUnitTeam)))

	mov	eax, ebx
	shr	eax, 5
	mov	ecx, eax
	shl	ecx, 5
	mov	edx, ecx
	mov	ecx, ebx
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [esi+eax*4+8]

; 2956 : #endif
; 2957 : 		{
; 2958 : 			return FALSE;

	je	$LN1@IgnoreUnit@3

; 2959 : 		}
; 2960 : 
; 2961 : 		if(pFromPlot->isOwned())

	mov	ecx, esi
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	test	al, al
	je	SHORT $LN79@IgnoreUnit@3

; 2962 : 		{
; 2963 : 			if(pFromPlot->getTeam() != eUnitTeam)

	mov	ecx, esi
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	cmp	eax, ebx

; 2964 : 			{
; 2965 : 				return FALSE;

	jne	$LN1@IgnoreUnit@3
$LN79@IgnoreUnit@3:

; 2966 : 			}
; 2967 : 		}
; 2968 : 	}
; 2969 : 
; 2970 : 	if(finder->GetInfo() & MOVE_TERRITORY_NO_ENEMY)

	mov	eax, DWORD PTR _finder$[esp+12]
	test	BYTE PTR [eax+72], 2
	je	SHORT $LN80@IgnoreUnit@3

; 2971 : 	{
; 2972 : 		if(pFromPlot->isOwned())

	mov	ecx, esi
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	test	al, al
	je	SHORT $LN80@IgnoreUnit@3

; 2973 : 		{
; 2974 : 			if(atWar(pFromPlot->getTeam(), eUnitTeam))

	push	ebx
	mov	ecx, esi
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al

; 2975 : 			{
; 2976 : 				return FALSE;

	jne	SHORT $LN1@IgnoreUnit@3
$LN80@IgnoreUnit@3:

; 2977 : 			}
; 2978 : 		}
; 2979 : 	}
; 2980 : 
; 2981 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 2982 : 	bAIControl = pUnit->IsAutomated();

	mov	ecx, DWORD PTR _pointer$[esp+12]
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated

; 2983 : #endif
; 2984 : 
; 2985 : 	// slewis - added AI check and embark check to prevent units from moving into unexplored areas
; 2986 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2987 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2988 : 	if (bIsAIControl || kFromNodeCacheData.bIsRevealedToTeam || pCacheData->isEmbarked())
; 2989 : #else
; 2990 : 	if (bAIControl || !bIsHuman || kFromNodeCacheData.bIsRevealedToTeam || pCacheData->isEmbarked())
; 2991 : #endif
; 2992 : 	{
; 2993 : 		if (!kToNodeCacheData.bCanEnterTerrain || !kToNodeCacheData.bIsMountain) // Recycling bIsMountain for Borders check (only for IgnoreUnits Pathfinder!)
; 2994 : #else
; 2995 : #ifdef ASTAR_AI_CONTROL_FIX_RADAR
; 2996 : 	if((pFromPlot->isRevealed(eUnitTeam) || pCacheData->isEmbarked()) || !pCacheData->isHuman())

	mov	eax, ebx
	shr	eax, 5
	mov	ecx, eax
	shl	ecx, 5
	mov	edx, ecx
	mov	ecx, ebx
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [esi+eax*4+8]
	jne	SHORT $LN3@IgnoreUnit@3
	mov	eax, DWORD PTR _finder$[esp+12]
	cmp	BYTE PTR [eax+157], 0
	jne	SHORT $LN3@IgnoreUnit@3
	cmp	BYTE PTR [eax+152], 0
	jne	SHORT $LN2@IgnoreUnit@3
$LN3@IgnoreUnit@3:

; 2997 : #else
; 2998 : 	if(bAIControl || (pFromPlot->isRevealed(eUnitTeam) || pCacheData->isEmbarked()) || !pCacheData->isHuman())
; 2999 : #endif
; 3000 : 	{
; 3001 : #ifdef AUI_ASTAR_FIX_IGNORE_UNITS_PATHFINDER_TERRITORY_CHECK
; 3002 : 		if (!pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE) || !pUnit->canEnterTerritory(pToPlot->getTeam(), false, false, pUnit->IsDeclareWar() || (GetInfo() & MOVE_DECLARE_WAR)))
; 3003 : #else
; 3004 : 		if(!pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE) || !pUnit->canEnterTerritory(eUnitTeam))

	mov	esi, DWORD PTR _pointer$[esp+12]
	push	128					; 00000080H
	push	ebp
	mov	ecx, esi
	call	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canEnterTerrain
	test	al, al
	je	SHORT $LN1@IgnoreUnit@3
	push	0
	push	0
	push	0
	push	ebx
	mov	ecx, esi
	call	?canEnterTerritory@CvUnit@@QBE_NW4TeamTypes@@_N11@Z ; CvUnit::canEnterTerritory
	test	al, al
	je	SHORT $LN1@IgnoreUnit@3
$LN2@IgnoreUnit@3:
	pop	edi
	pop	esi
	pop	ebp

; 3009 : 		}
; 3010 : 	}
; 3011 : 
; 3012 : 	return TRUE;

	mov	eax, 1
	pop	ebx

; 3013 : }

	ret	0
$LN1@IgnoreUnit@3:
	pop	edi
	pop	esi
	pop	ebp

; 3005 : #endif
; 3006 : #endif
; 3007 : 		{
; 3008 : 			return FALSE;

	xor	eax, eax
	pop	ebx

; 3013 : }

	ret	0
?IgnoreUnitsValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; IgnoreUnitsValid
_TEXT	ENDS
PUBLIC	?IgnoreUnitsPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; IgnoreUnitsPathAdd
; Function compile flags: /Ogtpy
;	COMDAT ?IgnoreUnitsPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_iMoves$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
$T224562 = 16						; size = 4
_data$ = 16						; size = 4
$T224559 = 20						; size = 4
$T224556 = 20						; size = 4
_pointer$ = 20						; size = 4
_iTurns$ = 24						; size = 4
_finder$ = 24						; size = 4
?IgnoreUnitsPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; IgnoreUnitsPathAdd, COMDAT

; 3018 : {

	push	ecx

; 3019 : 	int iTurns;
; 3020 : 
; 3021 : 	CvUnit* pUnit = ((CvUnit*)pointer);
; 3022 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());
; 3023 : 	int iMoves = MAX_INT;
; 3024 : 
; 3025 : 	if(data == ASNC_INITIALADD)

	cmp	DWORD PTR _data$[esp], 0
	push	ebx
	mov	ebx, DWORD PTR _finder$[esp+4]
	push	esi
	mov	DWORD PTR _iMoves$[esp+12], 2147483647	; 7fffffffH
	jne	SHORT $LN3@IgnoreUnit@4

; 3026 : 	{
; 3027 : 		iTurns = 1;
; 3028 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3029 : 		iMoves = pUnit->movesLeft();
; 3030 : #else
; 3031 : 		iMoves = std::min(iMoves, pUnit->movesLeft());

	mov	ecx, DWORD PTR _pointer$[esp+8]
	mov	esi, 1
	call	?movesLeft@CvUnit@@QBEHXZ		; CvUnit::movesLeft
	mov	DWORD PTR $T224556[esp+8], eax
	cmp	eax, 2147483647				; 7fffffffH
	lea	eax, DWORD PTR $T224556[esp+8]
	jl	$LN15@IgnoreUnit@4

; 3069 : #endif
; 3070 : 	}
; 3071 : 
; 3072 : 	FAssertMsg(iMoves >= 0, "iMoves is expected to be non-negative (invalid Index)");
; 3073 : 
; 3074 : 	node->m_iData1 = iMoves;

	mov	ecx, DWORD PTR _node$[esp+8]
	lea	eax, DWORD PTR _iMoves$[esp+12]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+12], eax

; 3075 : 	node->m_iData2 = iTurns;

	mov	DWORD PTR [ecx+16], esi

; 3076 : 
; 3077 : 	return 1;

	mov	eax, esi
	pop	esi
	pop	ebx

; 3078 : }

	pop	ecx
	ret	0
$LN3@IgnoreUnit@4:

; 3032 : #endif
; 3033 : 	}
; 3034 : 	else
; 3035 : 	{
; 3036 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3037 : 		CvPlot* pFromPlot = parent->m_pPlot;
; 3038 : 		CvPlot* pToPlot = node->m_pPlot;
; 3039 : #else
; 3040 : 		CvPlot* pFromPlot = GC.getMap().plotUnchecked(parent->m_iX, parent->m_iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [eax+4020]
	mov	edx, DWORD PTR [eax+4068]
	mov	eax, DWORD PTR _parent$[esp+8]
	movsx	esi, WORD PTR [eax+80]
	push	ebp

; 3041 : 		CvPlot* pToPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);

	mov	ebp, DWORD PTR _node$[esp+12]
	push	edi
	movsx	edi, WORD PTR [eax+82]
	imul	edi, ecx
	add	edi, esi
	movsx	esi, WORD PTR [ebp+82]
	imul	edi, 484				; 000001e4H
	imul	esi, ecx
	movsx	ecx, WORD PTR [ebp+80]

; 3042 : #endif
; 3043 : 
; 3044 : 		int iStartMoves = parent->m_iData1;

	mov	ebp, DWORD PTR [eax+12]
	add	esi, ecx
	imul	esi, 484				; 000001e4H
	add	edi, edx
	add	esi, edx

; 3045 : 		iTurns = parent->m_iData2;

	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR _iTurns$[esp+16], edx

; 3046 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3047 : 		int iBaseMoves = pCacheData->baseMoves(((pFromPlot->isWater() && !pFromPlot->IsAllowsWalkWater()) || pCacheData->isEmbarked()) ? DOMAIN_SEA : pCacheData->getDomainType());
; 3048 : #endif
; 3049 : 
; 3050 : 		if(iStartMoves == 0)

	test	ebp, ebp
	jne	SHORT $LN1@IgnoreUnit@4

; 3051 : 		{
; 3052 : 			iTurns++;

	inc	DWORD PTR _iTurns$[esp+16]

; 3053 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3054 : 			iStartMoves = iBaseMoves * GC.getMOVE_DENOMINATOR();
; 3055 : #else
; 3056 : 			iStartMoves = pCacheData->baseMoves((pToPlot->isWater() && !pToPlot->IsAllowsWalkWater()) ? DOMAIN_SEA : DOMAIN_LAND) * GC.getMOVE_DENOMINATOR();

	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN57@IgnoreUnit@4
	mov	ecx, esi
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	test	al, al
	jne	SHORT $LN57@IgnoreUnit@4
	xor	eax, eax
	jmp	SHORT $LN7@IgnoreUnit@4
$LN57@IgnoreUnit@4:
	mov	eax, 2
$LN7@IgnoreUnit@4:
	mov	ebp, DWORD PTR [ebx+eax*4+116]
	imul	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
$LN1@IgnoreUnit@4:

; 3057 : #endif
; 3058 : 		}
; 3059 : 
; 3060 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3061 : 		// We can just set maxMoves to the maximum integer value and use it for increased portability and no redundant checks, iMoves gets set to 0 anyway if it's negative
; 3062 : 		iMoves = iStartMoves - CvUnitMovement::MovementCostNoZOC(pUnit, pFromPlot, pToPlot, iBaseMoves, MAX_INT, iStartMoves);
; 3063 : 		if (iMoves < 0)
; 3064 : 			iMoves = 0;
; 3065 : #else
; 3066 : 		// We can't use maxMoves, because that checks where the unit is currently, and we're plotting a path so we have to see
; 3067 : 		// what the max moves would be like if the unit was already at the desired location.
; 3068 : 		iMoves = std::min(iMoves, std::max(0, iStartMoves - CvUnitMovement::MovementCostNoZOC(pUnit, pFromPlot, pToPlot, pCacheData->baseMoves((pToPlot->isWater() || pCacheData->isEmbarked())?DOMAIN_SEA:pCacheData->getDomainType()), pCacheData->maxMoves())));

	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN8@IgnoreUnit@4
	cmp	BYTE PTR [ebx+157], 0
	jne	SHORT $LN8@IgnoreUnit@4
	mov	ecx, DWORD PTR [ebx+148]
	jmp	SHORT $LN9@IgnoreUnit@4
$LN8@IgnoreUnit@4:
	xor	ecx, ecx
$LN9@IgnoreUnit@4:
	mov	eax, DWORD PTR [ebx+136]
	mov	ecx, DWORD PTR [ebx+ecx*4+116]
	push	0
	push	eax
	mov	eax, DWORD PTR _pointer$[esp+24]
	push	ecx
	push	esi
	push	edi
	push	eax
	call	?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCostNoZOC
	sub	ebp, eax
	add	esp, 24					; 00000018H
	mov	DWORD PTR $T224559[esp+16], ebp
	mov	DWORD PTR $T224562[esp+16], 0
	test	ebp, ebp
	jle	SHORT $LN50@IgnoreUnit@4
	cmp	ebp, 2147483647				; 7fffffffH
	lea	eax, DWORD PTR $T224559[esp+16]
	jl	SHORT $LN55@IgnoreUnit@4
	lea	eax, DWORD PTR _iMoves$[esp+20]
$LN55@IgnoreUnit@4:
	mov	esi, DWORD PTR _iTurns$[esp+16]
	pop	edi
	pop	ebp
$LN15@IgnoreUnit@4:

; 3069 : #endif
; 3070 : 	}
; 3071 : 
; 3072 : 	FAssertMsg(iMoves >= 0, "iMoves is expected to be non-negative (invalid Index)");
; 3073 : 
; 3074 : 	node->m_iData1 = iMoves;

	mov	ecx, DWORD PTR _node$[esp+8]
	mov	eax, DWORD PTR [eax]

; 3075 : 	node->m_iData2 = iTurns;

	mov	DWORD PTR [ecx+16], esi
	pop	esi
	mov	DWORD PTR [ecx+12], eax

; 3076 : 
; 3077 : 	return 1;

	mov	eax, 1
	pop	ebx

; 3078 : }

	pop	ecx
	ret	0

; 3057 : #endif
; 3058 : 		}
; 3059 : 
; 3060 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3061 : 		// We can just set maxMoves to the maximum integer value and use it for increased portability and no redundant checks, iMoves gets set to 0 anyway if it's negative
; 3062 : 		iMoves = iStartMoves - CvUnitMovement::MovementCostNoZOC(pUnit, pFromPlot, pToPlot, iBaseMoves, MAX_INT, iStartMoves);
; 3063 : 		if (iMoves < 0)
; 3064 : 			iMoves = 0;
; 3065 : #else
; 3066 : 		// We can't use maxMoves, because that checks where the unit is currently, and we're plotting a path so we have to see
; 3067 : 		// what the max moves would be like if the unit was already at the desired location.
; 3068 : 		iMoves = std::min(iMoves, std::max(0, iStartMoves - CvUnitMovement::MovementCostNoZOC(pUnit, pFromPlot, pToPlot, pCacheData->baseMoves((pToPlot->isWater() || pCacheData->isEmbarked())?DOMAIN_SEA:pCacheData->getDomainType()), pCacheData->maxMoves())));

$LN50@IgnoreUnit@4:
	lea	eax, DWORD PTR $T224562[esp+16]
	jmp	SHORT $LN55@IgnoreUnit@4
?IgnoreUnitsPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; IgnoreUnitsPathAdd
_TEXT	ENDS
PUBLIC	?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z		; StepDestValid
; Function compile flags: /Ogtpy
;	COMDAT ?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z PROC		; StepDestValid, COMDAT

; 3089 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 3090 : 	CvPlot* pFromPlot;
; 3091 : 	CvPlot* pToPlot;
; 3092 : #endif
; 3093 : 
; 3094 : 	CvMap& kMap = GC.getMap();
; 3095 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3096 : 	CvPlot* pFromPlot = kMap.plotUnchecked(finder->GetStartX(), finder->GetStartY());
; 3097 : 	CvPlot* pToPlot = kMap.plotUnchecked(iToX, iToY);
; 3098 : #else
; 3099 : 	pFromPlot = kMap.plotUnchecked(finder->GetStartX(), finder->GetStartY());
; 3100 : 	pToPlot = kMap.plotUnchecked(iToX, iToY);
; 3101 : #endif
; 3102 : 
; 3103 : 	if(pFromPlot->getArea() != pToPlot->getArea())

	mov	edx, DWORD PTR _finder$[esp-4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [ecx+4020]
	mov	ecx, DWORD PTR [ecx+4068]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [edx+60]
	imul	esi, eax
	imul	eax, DWORD PTR _iToY$[esp+4]
	add	esi, DWORD PTR [edx+56]
	add	eax, DWORD PTR _iToX$[esp+4]
	imul	esi, 484				; 000001e4H
	mov	edx, DWORD PTR [esi+ecx+356]
	imul	eax, 484				; 000001e4H
	xor	ebx, ebx
	cmp	edx, DWORD PTR [eax+ecx+356]
	pop	esi
	sete	bl
	mov	eax, ebx
	pop	ebx

; 3104 : 	{
; 3105 : 		return FALSE;
; 3106 : 	}
; 3107 : 
; 3108 : 	return TRUE;
; 3109 : }

	ret	0
?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z ENDP		; StepDestValid
_TEXT	ENDS
PUBLIC	?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepValid
EXTRN	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsFriendlyTerritory
EXTRN	?getEmbarkedAllWaterPassage@CvTeam@@QBEHXZ:PROC	; CvTeam::getEmbarkedAllWaterPassage
; Function compile flags: /Ogtpy
;	COMDAT ?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_eEnemy$ = 8						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; StepValid, COMDAT

; 3132 : 	if(parent == NULL)

	mov	edx, DWORD PTR _parent$[esp-4]
	test	edx, edx
	jne	SHORT $LN9@StepValid

; 3133 : 	{
; 3134 : 		return TRUE;

	lea	eax, DWORD PTR [edx+1]

; 3196 : }

	ret	0
$LN9@StepValid:

; 3135 : 	}
; 3136 : 
; 3137 : 	int iFlags = finder->GetInfo();
; 3138 : 	PlayerTypes ePlayer = (PlayerTypes)(iFlags & 0xFF);

	mov	eax, DWORD PTR _finder$[esp-4]

; 3139 : 
; 3140 : 	PlayerTypes eEnemy = *(PlayerTypes*)pointer;

	mov	ecx, DWORD PTR _pointer$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR [eax+72]
	mov	eax, DWORD PTR [ecx]
	push	ebp

; 3141 : 
; 3142 : 	CvPlayer& thisPlayer = GET_PLAYER(ePlayer);
; 3143 : 
; 3144 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3145 : 	CvPlot* pNewPlot = node->m_pPlot;
; 3146 : 	if (!pNewPlot)
; 3147 : 		return FALSE;
; 3148 : 	if (parent->m_pPlot && parent->m_pPlot->getArea() != pNewPlot->getArea())
; 3149 : #else
; 3150 : 	CvMap& kMap = GC.getMap();
; 3151 : 	CvPlot* pNewPlot = kMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	ebp, DWORD PTR _node$[esp+4]
	push	esi
	movsx	esi, WORD PTR [ebp+82]
	movsx	ebp, WORD PTR [ebp+80]
	mov	DWORD PTR _eEnemy$[esp+8], eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [eax+4020]
	imul	esi, ecx
	mov	eax, DWORD PTR [eax+4068]
	add	esi, ebp

; 3152 : 
; 3153 : 	if(kMap.plotUnchecked(parent->m_iX, parent->m_iY)->getArea() != pNewPlot->getArea())

	movsx	ebp, WORD PTR [edx+82]
	imul	esi, 484				; 000001e4H
	imul	ebp, ecx
	movsx	ecx, WORD PTR [edx+80]
	push	edi
	and	ebx, 255				; 000000ffH
	add	ebp, ecx
	mov	edi, ebx
	imul	ebp, 484				; 000001e4H
	mov	edx, DWORD PTR [eax+ebp+356]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	esi, eax
	cmp	edx, DWORD PTR [esi+356]

; 3154 : #endif
; 3155 : 	{
; 3156 : 		return FALSE;

	jne	$LN6@StepValid

; 3157 : 	}
; 3158 : 
; 3159 : #ifdef AUI_ASTAR_FIX_STEP_VALID_CONSIDERS_MOUNTAINS
; 3160 : 	if (pNewPlot->isImpassable())
; 3161 : #else
; 3162 : 	if(pNewPlot->isImpassable() || pNewPlot->isMountain())

	test	BYTE PTR [esi+462], 128			; 00000080H
	jne	$LN6@StepValid
	cmp	BYTE PTR [esi+5], 0
	je	$LN6@StepValid

; 3166 : 	}
; 3167 : 
; 3168 : 	// Ocean hex and team can't navigate on oceans?
; 3169 : 	if (!GET_TEAM(thisPlayer.getTeam()).getEmbarkedAllWaterPassage())

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN42@StepValid
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN43@StepValid
$LN42@StepValid:
	or	eax, -1
$LN43@StepValid:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?getEmbarkedAllWaterPassage@CvTeam@@QBEHXZ ; CvTeam::getEmbarkedAllWaterPassage
	test	eax, eax
	jne	SHORT $LN4@StepValid

; 3170 : 	{
; 3171 : 		if (pNewPlot->getTerrainType() == TERRAIN_OCEAN)

	cmp	BYTE PTR [esi+6], 6

; 3172 : 		{
; 3173 : 			return FALSE;

	je	SHORT $LN6@StepValid
$LN4@StepValid:

; 3174 : 		}
; 3175 : 	}
; 3176 : 
; 3177 : 	PlayerTypes ePlotOwnerPlayer = pNewPlot->getOwner();

	movsx	ebp, BYTE PTR [esi+4]

; 3178 : 	if (ePlotOwnerPlayer != NO_PLAYER && ePlotOwnerPlayer != eEnemy && !pNewPlot->IsFriendlyTerritory(ePlayer))

	cmp	ebp, -1
	je	SHORT $LN1@StepValid
	cmp	ebp, DWORD PTR _eEnemy$[esp+12]
	je	SHORT $LN1@StepValid
	push	ebx
	mov	ecx, esi
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	test	al, al
	jne	SHORT $LN1@StepValid

; 3179 : 	{
; 3180 : 		CvPlayer& plotOwnerPlayer = GET_PLAYER(ePlotOwnerPlayer);

	imul	ebp, 63236				; 0000f704H
	add	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3181 : 		bool bPlotOwnerIsMinor = plotOwnerPlayer.isMinorCiv();

	mov	ecx, ebp
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv

; 3182 : 
; 3183 : 		if(!bPlotOwnerIsMinor)

	test	al, al
	jne	SHORT $LN1@StepValid

; 3184 : 		{
; 3185 : 			TeamTypes eMyTeam = thisPlayer.getTeam();

	mov	ecx, edi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam

; 3186 : 			TeamTypes ePlotOwnerTeam = plotOwnerPlayer.getTeam();

	mov	ecx, ebp
	mov	esi, eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam

; 3187 : 
; 3188 : 			if(!atWar(eMyTeam, ePlotOwnerTeam))

	push	eax
	push	esi
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al

; 3189 : 			{
; 3190 : 				return FALSE;

	je	SHORT $LN6@StepValid
$LN1@StepValid:
	pop	edi
	pop	esi
	pop	ebp

; 3191 : 			}
; 3192 : 		}
; 3193 : 	}
; 3194 : 
; 3195 : 	return TRUE;

	mov	eax, 1
	pop	ebx

; 3196 : }

	ret	0
$LN6@StepValid:
	pop	edi
	pop	esi
	pop	ebp

; 3163 : #endif
; 3164 : 	{
; 3165 : 		return FALSE;

	xor	eax, eax
	pop	ebx

; 3196 : }

	ret	0
?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; StepValid
_TEXT	ENDS
PUBLIC	?StepValidAnyArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepValidAnyArea
; Function compile flags: /Ogtpy
;	COMDAT ?StepValidAnyArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_eEnemy$ = 8						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?StepValidAnyArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; StepValidAnyArea, COMDAT

; 3203 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[esp-4], 0
	jne	SHORT $LN7@StepValidA

; 3204 : 	{
; 3205 : 		return TRUE;

	mov	eax, 1

; 3262 : }

	ret	0
$LN7@StepValidA:

; 3206 : 	}
; 3207 : 
; 3208 : 	int iFlags = finder->GetInfo();
; 3209 : 	PlayerTypes ePlayer = (PlayerTypes)(iFlags & 0xFF);
; 3210 : 
; 3211 : 	PlayerTypes eEnemy = *(PlayerTypes*)pointer;

	mov	ecx, DWORD PTR _pointer$[esp-4]
	mov	edx, DWORD PTR [ecx]

; 3212 : 
; 3213 : 	CvPlayer& thisPlayer = GET_PLAYER(ePlayer);
; 3214 : 
; 3215 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3216 : 	CvPlot* pNewPlot = node->m_pPlot;
; 3217 : 	if (!pNewPlot)
; 3218 : 		return FALSE;
; 3219 : #else
; 3220 : 	CvMap& kMap = GC.getMap();
; 3221 : 	CvPlot* pNewPlot = kMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR _node$[esp-4]
	mov	eax, DWORD PTR _finder$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR [eax+72]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	esi
	movsx	esi, WORD PTR [ecx+82]
	imul	esi, DWORD PTR [eax+4020]
	movsx	ecx, WORD PTR [ecx+80]
	add	esi, ecx
	push	edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [eax+4068]
	and	ebx, 255				; 000000ffH
	mov	edi, ebx
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3222 : #endif
; 3223 : 
; 3224 : 	//if(kMap.plotUnchecked(parent->m_iX, parent->m_iY)->getArea() != pNewPlot->getArea())
; 3225 : 	//{
; 3226 : 	//	return FALSE;
; 3227 : 	//}
; 3228 : 
; 3229 : 	if(pNewPlot->isImpassable())

	test	BYTE PTR [esi+462], 128			; 00000080H
	mov	DWORD PTR _eEnemy$[esp+8], edx

; 3230 : 	{
; 3231 : 		return FALSE;

	jne	SHORT $LN45@StepValidA

; 3232 : 	}
; 3233 : 
; 3234 : 	// Ocean hex and team can't navigate on oceans?
; 3235 : 	if (!GET_TEAM(thisPlayer.getTeam()).getEmbarkedAllWaterPassage())

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN28@StepValidA
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN29@StepValidA
$LN28@StepValidA:
	or	eax, -1
$LN29@StepValidA:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?getEmbarkedAllWaterPassage@CvTeam@@QBEHXZ ; CvTeam::getEmbarkedAllWaterPassage
	test	eax, eax
	jne	SHORT $LN4@StepValidA

; 3236 : 	{
; 3237 : 		if (pNewPlot->getTerrainType() == TERRAIN_OCEAN)

	cmp	BYTE PTR [esi+6], 6
	jne	SHORT $LN4@StepValidA
$LN45@StepValidA:
	pop	edi
	pop	esi

; 3238 : 		{
; 3239 : 			return FALSE;

	xor	eax, eax
	pop	ebx

; 3262 : }

	ret	0
$LN4@StepValidA:
	push	ebp

; 3240 : 		}
; 3241 : 	}
; 3242 : 
; 3243 : 	PlayerTypes ePlotOwnerPlayer = pNewPlot->getOwner();

	movsx	ebp, BYTE PTR [esi+4]

; 3244 : 	if (ePlotOwnerPlayer != NO_PLAYER && ePlotOwnerPlayer != eEnemy && !pNewPlot->IsFriendlyTerritory(ePlayer))

	cmp	ebp, -1
	je	SHORT $LN1@StepValidA
	cmp	ebp, DWORD PTR _eEnemy$[esp+12]
	je	SHORT $LN1@StepValidA
	push	ebx
	mov	ecx, esi
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	test	al, al
	jne	SHORT $LN1@StepValidA

; 3245 : 	{
; 3246 : 		CvPlayer& plotOwnerPlayer = GET_PLAYER(ePlotOwnerPlayer);

	imul	ebp, 63236				; 0000f704H
	add	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3247 : 		bool bPlotOwnerIsMinor = plotOwnerPlayer.isMinorCiv();

	mov	ecx, ebp
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv

; 3248 : 
; 3249 : 		if(!bPlotOwnerIsMinor)

	test	al, al
	jne	SHORT $LN1@StepValidA

; 3250 : 		{
; 3251 : 			TeamTypes eMyTeam = thisPlayer.getTeam();

	mov	ecx, edi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam

; 3252 : 			TeamTypes ePlotOwnerTeam = plotOwnerPlayer.getTeam();

	mov	ecx, ebp
	mov	esi, eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam

; 3253 : 
; 3254 : 			if(!atWar(eMyTeam, ePlotOwnerTeam))

	push	eax
	push	esi
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	jne	SHORT $LN1@StepValidA
	pop	ebp
	pop	edi
	pop	esi

; 3255 : 			{
; 3256 : 				return FALSE;

	xor	eax, eax
	pop	ebx

; 3262 : }

	ret	0
$LN1@StepValidA:
	pop	ebp
	pop	edi
	pop	esi

; 3257 : 			}
; 3258 : 		}
; 3259 : 	}
; 3260 : 
; 3261 : 	return TRUE;

	mov	eax, 1
	pop	ebx

; 3262 : }

	ret	0
?StepValidAnyArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; StepValidAnyArea
_TEXT	ENDS
PUBLIC	?InfluenceDestValid@@YAHHHPBXPAVCvAStar@@@Z	; InfluenceDestValid
; Function compile flags: /Ogtpy
;	COMDAT ?InfluenceDestValid@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?InfluenceDestValid@@YAHHHPBXPAVCvAStar@@@Z PROC	; InfluenceDestValid, COMDAT

; 3292 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 3293 : 	CvPlot* pFromPlot;
; 3294 : 	CvPlot* pToPlot;
; 3295 : #endif
; 3296 : 
; 3297 : 	CvMap& kMap = GC.getMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 3298 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3299 : 	CvPlot* pFromPlot = kMap.plotUnchecked(finder->GetStartX(), finder->GetStartY());
; 3300 : 	CvPlot* pToPlot = kMap.plotUnchecked(iToX, iToY);
; 3301 : #else
; 3302 : 	pFromPlot = kMap.plotUnchecked(finder->GetStartX(), finder->GetStartY());

	mov	eax, DWORD PTR [ecx+4020]
	mov	edx, DWORD PTR [ecx+4068]
	push	esi
	mov	esi, DWORD PTR _finder$[esp]
	mov	ecx, DWORD PTR [esi+60]
	imul	ecx, eax

; 3303 : 	pToPlot = kMap.plotUnchecked(iToX, iToY);

	imul	eax, DWORD PTR _iToY$[esp]
	add	ecx, DWORD PTR [esi+56]
	add	eax, DWORD PTR _iToX$[esp]

; 3304 : #endif
; 3305 : 
; 3306 : 	if(pointer)

	mov	esi, DWORD PTR _pointer$[esp]
	imul	ecx, 484				; 000001e4H
	imul	eax, 484				; 000001e4H
	add	ecx, edx
	add	eax, edx
	test	esi, esi
	je	SHORT $LN1@InfluenceD

; 3307 : 	{
; 3308 : 		int iRange = abs(*(int*)pointer);
; 3309 : 		if(plotDistance(pFromPlot->getX(),pFromPlot->getY(),pToPlot->getX(),pToPlot->getY()) > iRange)

	movsx	edx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	edx
	movsx	edx, WORD PTR [ecx+2]
	push	eax
	movsx	eax, WORD PTR [ecx]
	push	edx
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	mov	ecx, eax
	mov	eax, DWORD PTR [esi]
	cdq
	xor	eax, edx
	sub	eax, edx
	add	esp, 16					; 00000010H
	cmp	ecx, eax
	jle	SHORT $LN1@InfluenceD

; 3310 : 		{
; 3311 : 			return FALSE;

	xor	eax, eax
	pop	esi

; 3316 : }

	ret	0
$LN1@InfluenceD:

; 3312 : 		}
; 3313 : 	}
; 3314 : 
; 3315 : 	return TRUE;

	mov	eax, 1
	pop	esi

; 3316 : }

	ret	0
?InfluenceDestValid@@YAHHHPBXPAVCvAStar@@@Z ENDP	; InfluenceDestValid
_TEXT	ENDS
PUBLIC	?InfluenceCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; InfluenceCost
EXTRN	?getInfluenceCost@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getInfluenceCost
EXTRN	?getInfluenceCost@CvTerrainInfo@@QBEHXZ:PROC	; CvTerrainInfo::getInfluenceCost
EXTRN	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z:PROC ; CvGlobals::getTerrainInfo
; Function compile flags: /Ogtpy
;	COMDAT ?InfluenceCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_bDifferentOwner$ = -5					; size = 1
$T224957 = -4						; size = 4
$T224956 = -4						; size = 4
_iCost$ = 8						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?InfluenceCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; InfluenceCost, COMDAT

; 3329 : {

	sub	esp, 8
	push	ebx
	push	esi

; 3330 : 	int iCost = 0;
; 3331 : 	bool bDifferentOwner = false;
; 3332 : 	if(parent->m_pParent || GC.getUSE_FIRST_RING_INFLUENCE_TERRAIN_COST())

	mov	esi, DWORD PTR _parent$[esp+12]
	xor	ebx, ebx
	mov	BYTE PTR _bDifferentOwner$[esp+16], bl
	cmp	DWORD PTR [esi+24], ebx
	jne	SHORT $LN10@InfluenceC
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+7012, ebx
	jne	SHORT $LN10@InfluenceC

; 3370 : 		}
; 3371 : 	}
; 3372 : 	else
; 3373 : 	{
; 3374 : 		iCost = 1;

	mov	ebx, 1
	jmp	$LN90@InfluenceC
$LN10@InfluenceC:

; 3333 : 	{
; 3334 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3335 : 		const CvPlot* pFromPlot = parent->m_pPlot;
; 3336 : 		const CvPlot* pToPlot = node->m_pPlot;
; 3337 : 		const CvPlot* pSourcePlot = GC.getMap().plotUnchecked(finder->GetStartX(), finder->GetStartY());
; 3338 : #else
; 3339 : 		CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 3340 : 		CvPlot* pFromPlot = kMap.plotUnchecked(parent->m_iX, parent->m_iY);

	mov	ecx, DWORD PTR [eax+4020]
	mov	edx, DWORD PTR [eax+4068]
	movsx	eax, WORD PTR [esi+80]
	push	ebp
	push	edi
	movsx	edi, WORD PTR [esi+82]

; 3341 : 		CvPlot* pToPlot = kMap.plotUnchecked(node->m_iX, node->m_iY);
; 3342 : 		CvPlot* pSourcePlot = kMap.plotUnchecked(finder->GetStartX(), finder->GetStartY());

	mov	ebp, DWORD PTR _finder$[esp+20]
	imul	edi, ecx
	add	edi, eax
	mov	eax, DWORD PTR _node$[esp+20]
	imul	edi, 484				; 000001e4H
	movsx	esi, WORD PTR [eax+82]
	movsx	eax, WORD PTR [eax+80]
	imul	esi, ecx
	add	esi, eax
	mov	eax, DWORD PTR [ebp+60]
	imul	esi, 484				; 000001e4H
	imul	eax, ecx
	add	eax, DWORD PTR [ebp+56]

; 3343 : #endif
; 3344 : 
; 3345 : 		int iRange = 0;
; 3346 : 		if(pointer)

	mov	ecx, DWORD PTR _pointer$[esp+20]
	imul	eax, 484				; 000001e4H
	add	edi, edx
	add	esi, edx
	add	eax, edx
	test	ecx, ecx
	je	SHORT $LN88@InfluenceC

; 3347 : 		{
; 3348 : 			iRange = *(int*)pointer;
; 3349 : 		}
; 3350 : 		if(iRange >= 0)

	cmp	DWORD PTR [ecx], ebx
	jl	SHORT $LN7@InfluenceC
$LN88@InfluenceC:

; 3351 : 		{
; 3352 : 			if(pToPlot->getOwner() != NO_PLAYER && pSourcePlot->getOwner() != NO_PLAYER && pToPlot->getOwner() != pSourcePlot->getOwner())

	mov	cl, BYTE PTR [esi+4]
	cmp	cl, -1
	je	SHORT $LN7@InfluenceC
	mov	al, BYTE PTR [eax+4]
	cmp	al, -1
	je	SHORT $LN7@InfluenceC
	cmp	cl, al
	je	SHORT $LN7@InfluenceC

; 3353 : 				bDifferentOwner = true;

	mov	BYTE PTR _bDifferentOwner$[esp+24], 1
$LN7@InfluenceC:

; 3354 : 		}
; 3355 : 
; 3356 : 		if(pFromPlot->isRiverCrossing(directionXY(pFromPlot, pToPlot)))

	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	movsx	eax, WORD PTR [edi+2]
	push	ecx
	movsx	ecx, WORD PTR [edi]
	push	edx
	push	eax
	push	ecx
	call	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ; directionXY
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, edi
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	pop	edi
	pop	ebp
	test	al, al
	je	SHORT $LN6@InfluenceC

; 3357 : 			iCost += GC.getINFLUENCE_RIVER_COST();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7008
$LN6@InfluenceC:

; 3358 : 
; 3359 : 		// Mountain Cost
; 3360 : 		if(pToPlot->isMountain())

	mov	al, BYTE PTR [esi+5]
	test	al, al
	jne	SHORT $LN5@InfluenceC

; 3361 : 			iCost += GC.getINFLUENCE_MOUNTAIN_COST();

	add	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7000

; 3362 : 		// Not a mountain - use the terrain cost
; 3363 : 		else

	jmp	SHORT $LN90@InfluenceC
$LN5@InfluenceC:

; 3364 : 		{
; 3365 : 			// Hill cost
; 3366 : 			if(pToPlot->isHills())

	cmp	al, 1
	jne	SHORT $LN3@InfluenceC

; 3367 : 				iCost += GC.getINFLUENCE_HILL_COST();

	add	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7004
$LN3@InfluenceC:

; 3368 : 			iCost += GC.getTerrainInfo(pToPlot->getTerrainType())->getInfluenceCost();

	movsx	eax, BYTE PTR [esi+6]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getInfluenceCost@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getInfluenceCost
	add	ebx, eax

; 3369 : 			iCost += ((pToPlot->getFeatureType() == NO_FEATURE) ? 0 : GC.getFeatureInfo(pToPlot->getFeatureType())->getInfluenceCost());

	mov	al, BYTE PTR [esi+432]
	cmp	al, -1
	jne	SHORT $LN14@InfluenceC
	xor	eax, eax
	jmp	SHORT $LN15@InfluenceC
$LN14@InfluenceC:
	movsx	edx, al
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getInfluenceCost@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getInfluenceCost
$LN15@InfluenceC:
	add	ebx, eax
$LN90@InfluenceC:
	pop	esi
	mov	DWORD PTR _iCost$[esp+8], ebx

; 3375 : 	}
; 3376 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3377 : 	iCost = MAX(1, iCost);
; 3378 : 	iCost = MIN(3, iCost);
; 3379 : #else
; 3380 : 	iCost = std::max(1,iCost);

	cmp	ebx, 1
	mov	DWORD PTR $T224956[esp+12], 1
	pop	ebx
	lea	eax, DWORD PTR _iCost$[esp+4]
	jg	SHORT $LN83@InfluenceC
	lea	eax, DWORD PTR $T224956[esp+8]
$LN83@InfluenceC:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _iCost$[esp+4], eax

; 3381 : 	iCost = std::min(3,iCost);

	cmp	eax, 3
	mov	DWORD PTR $T224957[esp+8], 3
	lea	eax, DWORD PTR _iCost$[esp+4]
	jl	SHORT $LN87@InfluenceC
	lea	eax, DWORD PTR $T224957[esp+8]
$LN87@InfluenceC:

; 3382 : #endif
; 3383 : 	if (bDifferentOwner)

	cmp	BYTE PTR _bDifferentOwner$[esp+8], 0
	mov	eax, DWORD PTR [eax]
	je	SHORT $LN1@InfluenceC

; 3384 : 	{
; 3385 : 		iCost += 15;

	add	eax, 15					; 0000000fH
$LN1@InfluenceC:

; 3386 : 	}
; 3387 : 	return iCost;
; 3388 : }

	add	esp, 8
	ret	0
?InfluenceCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; InfluenceCost
_TEXT	ENDS
PUBLIC	?InfluenceValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; InfluenceValid
; Function compile flags: /Ogtpy
;	COMDAT ?InfluenceValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?InfluenceValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; InfluenceValid, COMDAT

; 3395 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 3396 : 	CvPlot* pNewPlot;
; 3397 : #endif
; 3398 : 
; 3399 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[esp-4], 0

; 3400 : 	{
; 3401 : 		return TRUE;

	je	SHORT $LN1@InfluenceV

; 3402 : 	}
; 3403 : 
; 3404 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3405 : 	if (!node->m_pPlot)
; 3406 : 	{
; 3407 : 		return FALSE;
; 3408 : 	}
; 3409 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 3410 : 	if (!GC.getMap().isPlot(node->m_iX, node->m_iY))
; 3411 : 	{
; 3412 : 		return FALSE;
; 3413 : 	}
; 3414 : #else
; 3415 : 	pNewPlot = GC.getMap().plotCheckInvalid(node->m_iX, node->m_iY);

	mov	eax, DWORD PTR _node$[esp-4]
	movsx	ecx, WORD PTR [eax+80]
	movsx	edx, WORD PTR [eax+82]
	cmp	ecx, -2147483647			; 80000001H
	je	SHORT $LN15@InfluenceV
	cmp	edx, -2147483647			; 80000001H
	je	SHORT $LN15@InfluenceV
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [esi+4020]
	imul	eax, edx
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [esi+4068]
	pop	esi

; 3416 : 
; 3417 : 	if(pNewPlot == NULL)

	jne	SHORT $LN1@InfluenceV
$LN15@InfluenceV:

; 3418 : 	{
; 3419 : 		return FALSE;

	xor	eax, eax

; 3426 : }

	ret	0
$LN1@InfluenceV:

; 3420 : 	}
; 3421 : #endif
; 3422 : 
; 3423 : 	// todo: a check to see if we are within the theoretical influence range would be great
; 3424 : 
; 3425 : 	return TRUE;

	mov	eax, 1

; 3426 : }

	ret	0
?InfluenceValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; InfluenceValid
_TEXT	ENDS
PUBLIC	?RouteGetExtraChild@@YAHPAVCvAStarNode@@HAAH1PAVCvAStar@@@Z ; RouteGetExtraChild
EXTRN	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z:PROC ; CvCityConnections::GetCityFromIndex
EXTRN	?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z:PROC ; CvCityConnections::GetRouteInfo
EXTRN	?GetIndexFromCity@CvCityConnections@@QAEIPAVCvCity@@@Z:PROC ; CvCityConnections::GetIndexFromCity
EXTRN	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ:PROC ; CvPlayer::GetCityConnections
; Function compile flags: /Ogtpy
;	COMDAT ?RouteGetExtraChild@@YAHPAVCvAStarNode@@HAAH1PAVCvAStar@@@Z
_TEXT	SEGMENT
_pRouteInfo$220260 = 8					; size = 4
_node$ = 8						; size = 4
_iIndex$ = 12						; size = 4
_iX$ = 16						; size = 4
_iY$ = 20						; size = 4
_iValidCount$ = 24					; size = 4
_finder$ = 24						; size = 4
?RouteGetExtraChild@@YAHPAVCvAStarNode@@HAAH1PAVCvAStar@@@Z PROC ; RouteGetExtraChild, COMDAT

; 3452 : 	iX = -1;

	mov	eax, DWORD PTR _iX$[esp-4]

; 3453 : 	iY = -1;

	mov	ecx, DWORD PTR _iY$[esp-4]

; 3454 : 
; 3455 : 	PlayerTypes ePlayer = ((PlayerTypes)(finder->GetInfo() & 0xFF));

	mov	edx, DWORD PTR _finder$[esp-4]
	push	ebx
	mov	DWORD PTR [eax], -1
	push	ebp
	push	esi
	mov	DWORD PTR [ecx], -1
	mov	esi, DWORD PTR [edx+72]

; 3456 : 	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	and	esi, 255				; 000000ffH
	imul	esi, 63236				; 0000f704H

; 3457 : 	TeamTypes eTeam = kPlayer.getTeam();

	mov	eax, DWORD PTR [esi+ebx+44]
	add	esi, ebx
	push	edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN23@RouteGetEx
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ebp, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN24@RouteGetEx
$LN23@RouteGetEx:
	or	ebp, -1
$LN24@RouteGetEx:

; 3458 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3459 : 	const CvPlot* pPlot = node->m_pPlot;
; 3460 : #else
; 3461 : 	CvPlot* pPlot = GC.getMap().plotCheckInvalid(node->m_iX, node->m_iY);

	mov	eax, DWORD PTR _node$[esp+12]
	movsx	ecx, WORD PTR [eax+80]
	movsx	edx, WORD PTR [eax+82]
	cmp	ecx, -2147483647			; 80000001H
	je	$LN10@RouteGetEx
	cmp	edx, -2147483647			; 80000001H
	je	$LN10@RouteGetEx
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [edi+4020]
	imul	eax, edx
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [edi+4068]

; 3462 : #endif
; 3463 : 
; 3464 : 	if(!pPlot)
; 3465 : 	{
; 3466 : 		return 0;

	je	$LN10@RouteGetEx

; 3467 : 	}
; 3468 : 
; 3469 : 	CvCity* pCity = pPlot->getPlotCity();

	mov	ecx, DWORD PTR [eax+104]
	test	ecx, ecx
	jl	$LN10@RouteGetEx
	cmp	ecx, 64					; 00000040H
	jge	$LN10@RouteGetEx
	mov	eax, DWORD PTR [eax+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, ebx
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	edi, eax

; 3470 : 
; 3471 : 	// if there isn't a city there or the city isn't on our team
; 3472 : 	if(!pCity || pCity->getTeam() != eTeam)

	test	edi, edi
	je	SHORT $LN10@RouteGetEx
	mov	ecx, edi
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	cmp	eax, ebp
	jne	SHORT $LN10@RouteGetEx

; 3475 : 	}
; 3476 : 
; 3477 : 	int iValidCount = 0;
; 3478 : 	CvCityConnections* pCityConnections = kPlayer.GetCityConnections();

	mov	ecx, esi
	mov	DWORD PTR _iValidCount$[esp+12], 0
	call	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ ; CvPlayer::GetCityConnections
	mov	esi, eax

; 3479 : 
; 3480 : 	uint uiFirstCityIndex = pCityConnections->GetIndexFromCity(pCity);

	push	edi
	mov	ecx, esi
	call	?GetIndexFromCity@CvCityConnections@@QAEIPAVCvCity@@@Z ; CvCityConnections::GetIndexFromCity

; 3481 : 	for(uint uiSecondCityIndex = 0; uiSecondCityIndex < pCityConnections->m_aiCityPlotIDs.size(); uiSecondCityIndex++)

	xor	edi, edi
	mov	ebp, eax
	cmp	DWORD PTR [esi+16], edi
	jbe	SHORT $LN10@RouteGetEx
	npad	4
$LL59@RouteGetEx:

; 3482 : 	{
; 3483 : 		if(uiFirstCityIndex == uiSecondCityIndex)

	cmp	ebp, edi
	je	SHORT $LN8@RouteGetEx

; 3484 : 		{
; 3485 : 			continue;
; 3486 : 		}
; 3487 : 
; 3488 : 		CvCityConnections::RouteInfo* pRouteInfo = pCityConnections->GetRouteInfo(uiFirstCityIndex, uiSecondCityIndex);

	push	edi
	push	ebp
	mov	ecx, esi
	call	?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z ; CvCityConnections::GetRouteInfo
	mov	DWORD PTR _pRouteInfo$220260[esp+12], eax

; 3489 : 		if(!pRouteInfo)

	test	eax, eax
	je	SHORT $LN8@RouteGetEx

; 3490 : 		{
; 3491 : 			continue;
; 3492 : 		}
; 3493 : 
; 3494 : 		// get the two cities
; 3495 : 		CvCity* pFirstCity  = pCityConnections->GetCityFromIndex(uiFirstCityIndex);

	push	ebp
	mov	ecx, esi
	call	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z ; CvCityConnections::GetCityFromIndex

; 3496 : 		CvCity* pSecondCity = pCityConnections->GetCityFromIndex(uiSecondCityIndex);

	push	edi
	mov	ecx, esi
	mov	ebx, eax
	call	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z ; CvCityConnections::GetCityFromIndex

; 3497 : 
; 3498 : 		if(!pFirstCity || !pSecondCity)

	test	ebx, ebx
	je	SHORT $LN8@RouteGetEx
	test	eax, eax
	je	SHORT $LN8@RouteGetEx

; 3499 : 		{
; 3500 : 			continue;
; 3501 : 		}
; 3502 : 
; 3503 : 		if(pRouteInfo->m_cRouteState & CvCityConnections::HAS_WATER_ROUTE)

	mov	ecx, DWORD PTR _pRouteInfo$220260[esp+12]
	test	BYTE PTR [ecx], 2
	je	SHORT $LN8@RouteGetEx

; 3504 : 		{
; 3505 : 			if(iValidCount == iIndex)

	mov	edx, DWORD PTR _iValidCount$[esp+12]
	cmp	edx, DWORD PTR _iIndex$[esp+12]
	je	SHORT $LN54@RouteGetEx

; 3510 : 			}
; 3511 : 			iValidCount++;

	inc	DWORD PTR _iValidCount$[esp+12]
$LN8@RouteGetEx:

; 3481 : 	for(uint uiSecondCityIndex = 0; uiSecondCityIndex < pCityConnections->m_aiCityPlotIDs.size(); uiSecondCityIndex++)

	inc	edi
	cmp	edi, DWORD PTR [esi+16]
	jb	SHORT $LL59@RouteGetEx
$LN10@RouteGetEx:
	pop	edi
	pop	esi
	pop	ebp

; 3473 : 	{
; 3474 : 		return 0;

	xor	eax, eax
	pop	ebx

; 3512 : 		}
; 3513 : 	}
; 3514 : 
; 3515 : 	return 0;
; 3516 : }

	ret	0
$LN54@RouteGetEx:

; 3506 : 			{
; 3507 : 				iX = pSecondCity->getX();

	mov	ecx, DWORD PTR [eax+96]
	mov	edx, DWORD PTR _iX$[esp+12]
	pop	edi
	mov	DWORD PTR [edx], ecx

; 3508 : 				iY = pSecondCity->getY();

	mov	eax, DWORD PTR [eax+108]
	mov	ecx, DWORD PTR _iY$[esp+8]
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx], eax

; 3509 : 				return 1;

	mov	eax, 1
	pop	ebx

; 3512 : 		}
; 3513 : 	}
; 3514 : 
; 3515 : 	return 0;
; 3516 : }

	ret	0
?RouteGetExtraChild@@YAHPAVCvAStarNode@@HAAH1PAVCvAStar@@@Z ENDP ; RouteGetExtraChild
_TEXT	ENDS
PUBLIC	?RouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; RouteValid
EXTRN	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z:PROC ; CvPlayer::getBestRoute
EXTRN	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z:PROC ; CvMinorCivAI::IsActiveQuestForPlayer
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?IsRoutePillaged@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsRoutePillaged
EXTRN	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ:PROC ; CvPlot::getRouteType
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
; Function compile flags: /Ogtpy
;	COMDAT ?RouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_eRouteType$ = -4					; size = 4
_ePlotOwnerPlayer$220290 = 8				; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?RouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; RouteValid, COMDAT

; 3522 : {

	push	ecx

; 3523 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 3524 : 	CvPlot* pNewPlot;
; 3525 : #endif
; 3526 : 
; 3527 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[esp], 0
	jne	SHORT $LN20@RouteValid

; 3528 : 	{
; 3529 : 		return TRUE;

	mov	eax, 1

; 3626 : 		{
; 3627 : 			return TRUE;
; 3628 : 		}
; 3629 : 	}
; 3630 : 
; 3631 : 	return FALSE;
; 3632 : }

	pop	ecx
	ret	0
$LN20@RouteValid:

; 3530 : 	}
; 3531 : 
; 3532 : 	int iFlags = finder->GetInfo();

	mov	eax, DWORD PTR _finder$[esp]

; 3533 : 	PlayerTypes ePlayer = (PlayerTypes)(iFlags & 0xFF);
; 3534 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3535 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3536 : 	const CvPlot* pNewPlot = node->m_pPlot;
; 3537 : #else
; 3538 : 	pNewPlot = node->m_pPlot;
; 3539 : #endif
; 3540 : 	if (!pNewPlot)
; 3541 : 		return FALSE;
; 3542 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 3543 : 	CvPlot* pNewPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);
; 3544 : #else
; 3545 : 	pNewPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR [eax+72]
	mov	eax, DWORD PTR _node$[esp+8]
	movsx	edx, WORD PTR [eax+80]
	push	esi
	movsx	esi, WORD PTR [eax+82]
	imul	esi, DWORD PTR [ecx+4020]
	mov	ebx, ebp
	push	edi
	and	ebx, 255				; 000000ffH
	add	esi, edx

; 3546 : #endif
; 3547 : 
; 3548 : 	CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	mov	edi, ebx
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3549 : 	if((iFlags & MOVE_ROUTE_ALLOW_UNEXPLORED) == 0 && !(pNewPlot->isRevealed(kPlayer.getTeam())))

	test	ebp, 1073741824				; 40000000H
	jne	SHORT $LN68@RouteValid
	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN39@RouteValid
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN40@RouteValid
$LN39@RouteValid:
	or	ecx, -1
$LN40@RouteValid:
	mov	eax, ecx
	shr	eax, 5
	mov	edx, eax
	shl	edx, 5
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [esi+eax*4+8]

; 3550 : 	{
; 3551 : 		return FALSE;

	je	$LN8@RouteValid
$LN68@RouteValid:

; 3552 : 	}
; 3553 : 
; 3554 : 	if(kPlayer.GetPlayerTraits()->IsMoveFriendlyWoodsAsRoad())

	mov	ecx, edi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+325], 0
	je	SHORT $LN16@RouteValid

; 3555 : 	{
; 3556 : 		if(pNewPlot->getOwner() == ePlayer)

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, ebx
	jne	SHORT $LN16@RouteValid

; 3557 : 		{
; 3558 : 			if(pNewPlot->getFeatureType() == FEATURE_FOREST || pNewPlot->getFeatureType() == FEATURE_JUNGLE)

	mov	al, BYTE PTR [esi+432]
	cmp	al, 5
	je	SHORT $LN15@RouteValid
	cmp	al, 1
	jne	SHORT $LN16@RouteValid
$LN15@RouteValid:
	pop	edi
	pop	esi
	pop	ebp

; 3559 : 			{
; 3560 : 				return TRUE;

	mov	eax, 1
	pop	ebx

; 3626 : 		{
; 3627 : 			return TRUE;
; 3628 : 		}
; 3629 : 	}
; 3630 : 
; 3631 : 	return FALSE;
; 3632 : }

	pop	ecx
	ret	0
$LN16@RouteValid:

; 3561 : 			}
; 3562 : 		}
; 3563 : 	}
; 3564 : 
; 3565 : 	RouteTypes eRouteType = pNewPlot->getRouteType();

	mov	ecx, esi
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	mov	DWORD PTR _eRouteType$[esp+20], eax

; 3566 : 	if(eRouteType == NO_ROUTE)

	cmp	eax, -1

; 3567 : 	{
; 3568 : 		return FALSE;

	je	$LN8@RouteValid

; 3569 : 	}
; 3570 : 
; 3571 : 	if(pNewPlot->IsRoutePillaged())

	mov	ecx, esi
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	test	al, al

; 3572 : 	{
; 3573 : 		return FALSE;

	jne	SHORT $LN8@RouteValid

; 3574 : 	}
; 3575 : 
; 3576 : 	if(!pNewPlot->IsFriendlyTerritory(ePlayer))

	push	ebx
	mov	ecx, esi
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	test	al, al
	jne	SHORT $LN69@RouteValid

; 3577 : 	{
; 3578 : 		PlayerTypes ePlotOwnerPlayer = pNewPlot->getOwner();

	movsx	esi, BYTE PTR [esi+4]
	mov	DWORD PTR _ePlotOwnerPlayer$220290[esp+16], esi

; 3579 : 		if(ePlotOwnerPlayer != NO_PLAYER)

	cmp	esi, -1
	je	SHORT $LN69@RouteValid

; 3580 : 		{
; 3581 : 			PlayerTypes eMajorPlayer = NO_PLAYER;
; 3582 : 			PlayerTypes eMinorPlayer = NO_PLAYER;
; 3583 : 			CvPlayer& kPlotOwner = GET_PLAYER(ePlotOwnerPlayer);

	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3584 : 			if(kPlayer.isMinorCiv() && !kPlotOwner.isMinorCiv())

	mov	ecx, edi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN10@RouteValid
	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN10@RouteValid

; 3585 : 			{
; 3586 : 				eMajorPlayer = ePlotOwnerPlayer;

	mov	eax, DWORD PTR _ePlotOwnerPlayer$220290[esp+16]

; 3587 : 				eMinorPlayer = ePlayer;

	jmp	SHORT $LN7@RouteValid
$LN10@RouteValid:

; 3588 : 			}
; 3589 : 			else if(kPlotOwner.isMinorCiv() && !kPlayer.isMinorCiv())

	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN8@RouteValid
	mov	ecx, edi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN8@RouteValid

; 3590 : 			{
; 3591 : 				eMajorPlayer = ePlayer;

	mov	eax, ebx

; 3592 : 				eMinorPlayer = ePlotOwnerPlayer;

	mov	ebx, DWORD PTR _ePlotOwnerPlayer$220290[esp+16]
$LN7@RouteValid:

; 3593 : 			}
; 3594 : 			else
; 3595 : 			{
; 3596 : 				return FALSE;
; 3597 : 			}
; 3598 : 
; 3599 : 			if(!GET_PLAYER(eMinorPlayer).GetMinorCivAI()->IsActiveQuestForPlayer(eMajorPlayer, MINOR_CIV_QUEST_ROUTE))

	imul	ebx, 63236				; 0000f704H
	add	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	eax
	mov	ecx, ebx
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsActiveQuestForPlayer
	test	al, al
	jne	SHORT $LN69@RouteValid
$LN8@RouteValid:
	pop	edi
	pop	esi
	pop	ebp

; 3600 : 			{
; 3601 : 				return FALSE;

	xor	eax, eax
	pop	ebx

; 3626 : 		{
; 3627 : 			return TRUE;
; 3628 : 		}
; 3629 : 	}
; 3630 : 
; 3631 : 	return FALSE;
; 3632 : }

	pop	ecx
	ret	0
$LN69@RouteValid:

; 3602 : 			}
; 3603 : 		}
; 3604 : 	}
; 3605 : 
; 3606 : 	if(finder->GetInfo() & MOVE_ANY_ROUTE)

	mov	ecx, DWORD PTR _finder$[esp+16]
	test	DWORD PTR [ecx+72], -2147483648		; 80000000H
	je	SHORT $LN5@RouteValid

; 3607 : 	{
; 3608 : 		// if the player can't build
; 3609 : 		if(kPlayer.getBestRoute() == NO_ROUTE)

	push	0
	mov	ecx, edi
	call	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z ; CvPlayer::getBestRoute
	xor	edx, edx
	cmp	eax, -1
	setne	dl
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	eax, edx

; 3626 : 		{
; 3627 : 			return TRUE;
; 3628 : 		}
; 3629 : 	}
; 3630 : 
; 3631 : 	return FALSE;
; 3632 : }

	pop	ecx
	ret	0
$LN5@RouteValid:

; 3610 : 		{
; 3611 : 			return FALSE;
; 3612 : 		}
; 3613 : 
; 3614 : 		if(eRouteType != NO_ROUTE)
; 3615 : 		{
; 3616 : 			return TRUE;
; 3617 : 		}
; 3618 : 	}
; 3619 : 	else
; 3620 : 	{
; 3621 : 		int iRoute = iFlags & 0xFF00;
; 3622 : 		iRoute = iRoute >> 8;
; 3623 : 		iRoute = iRoute - 1;
; 3624 : 		RouteTypes eRequiredRoute = (RouteTypes)(iRoute);
; 3625 : 		if(eRouteType == eRequiredRoute)

	sar	ebp, 8
	and	ebp, 255				; 000000ffH
	pop	edi
	dec	ebp
	xor	eax, eax
	cmp	DWORD PTR _eRouteType$[esp+16], ebp
	pop	esi
	pop	ebp
	sete	al
	pop	ebx

; 3626 : 		{
; 3627 : 			return TRUE;
; 3628 : 		}
; 3629 : 	}
; 3630 : 
; 3631 : 	return FALSE;
; 3632 : }

	pop	ecx
	ret	0
?RouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; RouteValid
_TEXT	ENDS
PUBLIC	?RouteGetNumExtraChildren@@YAHPAVCvAStarNode@@PAVCvAStar@@@Z ; RouteGetNumExtraChildren
EXTRN	?IsEmpty@CvCityConnections@@QAE_NXZ:PROC	; CvCityConnections::IsEmpty
; Function compile flags: /Ogtpy
;	COMDAT ?RouteGetNumExtraChildren@@YAHPAVCvAStarNode@@PAVCvAStar@@@Z
_TEXT	SEGMENT
_pRouteInfo$220332 = 8					; size = 4
_node$ = 8						; size = 4
_iResultNum$ = 12					; size = 4
_finder$ = 12						; size = 4
?RouteGetNumExtraChildren@@YAHPAVCvAStarNode@@PAVCvAStar@@@Z PROC ; RouteGetNumExtraChildren, COMDAT

; 3639 : 	PlayerTypes ePlayer = ((PlayerTypes)(finder->GetInfo() & 0xFF));

	mov	eax, DWORD PTR _finder$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+72]
	and	edi, 255				; 000000ffH

; 3640 : 	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3641 : 	TeamTypes eTeam = kPlayer.getTeam();

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN25@RouteGetNu
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN26@RouteGetNu
$LN25@RouteGetNu:
	or	ebx, -1
$LN26@RouteGetNu:

; 3642 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3643 : 	const CvPlot* pPlot = node->m_pPlot;
; 3644 : #else
; 3645 : 	CvPlot* pPlot = GC.getMap().plotCheckInvalid(node->m_iX, node->m_iY);

	mov	eax, DWORD PTR _node$[esp+8]
	movsx	ecx, WORD PTR [eax+82]
	movsx	eax, WORD PTR [eax+80]
	cmp	eax, -2147483647			; 80000001H
	je	SHORT $LN51@RouteGetNu
	cmp	ecx, -2147483647			; 80000001H
	je	SHORT $LN51@RouteGetNu
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [edx+4020]
	imul	esi, ecx
	add	esi, eax
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [edx+4068]

; 3646 : #endif
; 3647 : 
; 3648 : 	if(!pPlot)

	jne	SHORT $LN14@RouteGetNu
$LN51@RouteGetNu:
	pop	edi
	pop	esi

; 3649 : 	{
; 3650 : 		return 0;

	xor	eax, eax
	pop	ebx

; 3711 : }

	ret	0
$LN14@RouteGetNu:

; 3651 : 	}
; 3652 : 
; 3653 : 	// slewis - don't allow the minor civ to use harbors
; 3654 : 	if(kPlayer.isMinorCiv())

	mov	ecx, edi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al

; 3655 : 	{
; 3656 : 		return 0;

	jne	SHORT $LN51@RouteGetNu

; 3657 : 	}
; 3658 : 
; 3659 : 	CvCityConnections* pCityConnections = kPlayer.GetCityConnections();

	mov	ecx, edi
	call	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ ; CvPlayer::GetCityConnections
	mov	edi, eax

; 3660 : 	if(pCityConnections->IsEmpty())

	mov	ecx, edi
	call	?IsEmpty@CvCityConnections@@QAE_NXZ	; CvCityConnections::IsEmpty
	test	al, al

; 3661 : 	{
; 3662 : 		return 0;

	jne	SHORT $LN51@RouteGetNu

; 3663 : 	}
; 3664 : 
; 3665 : 	int iResultNum = 0;
; 3666 : 
; 3667 : 	CvCity* pCity = pPlot->getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR _iResultNum$[esp+8], 0
	test	eax, eax
	jl	SHORT $LN51@RouteGetNu
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN51@RouteGetNu
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax

; 3668 : 
; 3669 : 	// if there isn't a city there or the city isn't on our team
; 3670 : 	if(!pCity || pCity->getTeam() != eTeam)

	test	esi, esi
	je	SHORT $LN51@RouteGetNu
	mov	ecx, esi
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	cmp	eax, ebx
	jne	SHORT $LN51@RouteGetNu
	push	ebp

; 3671 : 	{
; 3672 : 		return 0;
; 3673 : 	}
; 3674 : 
; 3675 : 	uint uiFirstCityIndex = pCityConnections->GetIndexFromCity(pCity);

	push	esi
	mov	ecx, edi
	call	?GetIndexFromCity@CvCityConnections@@QAEIPAVCvCity@@@Z ; CvCityConnections::GetIndexFromCity
	mov	ebp, eax

; 3676 : 	if(uiFirstCityIndex >= pCityConnections->m_aiCityPlotIDs.size())

	mov	eax, DWORD PTR [edi+16]
	cmp	ebp, eax
	jb	SHORT $LN9@RouteGetNu
	pop	ebp
	pop	edi
	pop	esi

; 3677 : 	{
; 3678 : 		CvAssertMsg(false, "City index out of bounds");
; 3679 : 		return 0;

	xor	eax, eax
	pop	ebx

; 3711 : }

	ret	0
$LN9@RouteGetNu:

; 3680 : 	}
; 3681 : 
; 3682 : 	for(uint uiSecondCityIndex = 0; uiSecondCityIndex < pCityConnections->m_aiCityPlotIDs.size(); uiSecondCityIndex++)

	xor	esi, esi
	test	eax, eax
	jbe	SHORT $LN6@RouteGetNu
	npad	1
$LL54@RouteGetNu:

; 3683 : 	{
; 3684 : 		if(uiFirstCityIndex == uiSecondCityIndex)

	cmp	ebp, esi
	je	SHORT $LN7@RouteGetNu

; 3685 : 		{
; 3686 : 			continue;
; 3687 : 		}
; 3688 : 
; 3689 : 		CvCityConnections::RouteInfo* pRouteInfo = pCityConnections->GetRouteInfo(uiFirstCityIndex, uiSecondCityIndex);

	push	esi
	push	ebp
	mov	ecx, edi
	call	?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z ; CvCityConnections::GetRouteInfo
	mov	DWORD PTR _pRouteInfo$220332[esp+12], eax

; 3690 : 		if(!pRouteInfo)

	test	eax, eax
	je	SHORT $LN7@RouteGetNu

; 3691 : 		{
; 3692 : 			continue;
; 3693 : 		}
; 3694 : 
; 3695 : 		// get the two cities
; 3696 : 		CvCity* pFirstCity  = pCityConnections->GetCityFromIndex(uiFirstCityIndex);

	push	ebp
	mov	ecx, edi
	call	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z ; CvCityConnections::GetCityFromIndex

; 3697 : 		CvCity* pSecondCity = pCityConnections->GetCityFromIndex(uiSecondCityIndex);

	push	esi
	mov	ecx, edi
	mov	ebx, eax
	call	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z ; CvCityConnections::GetCityFromIndex

; 3698 : 
; 3699 : 		if(!pFirstCity || !pSecondCity)

	test	ebx, ebx
	je	SHORT $LN7@RouteGetNu
	test	eax, eax
	je	SHORT $LN7@RouteGetNu

; 3700 : 		{
; 3701 : 			continue;
; 3702 : 		}
; 3703 : 
; 3704 : 		if(pRouteInfo->m_cRouteState & CvCityConnections::HAS_WATER_ROUTE)

	mov	edx, DWORD PTR _pRouteInfo$220332[esp+12]
	test	BYTE PTR [edx], 2
	je	SHORT $LN7@RouteGetNu

; 3705 : 		{
; 3706 : 			iResultNum++;

	inc	DWORD PTR _iResultNum$[esp+12]
$LN7@RouteGetNu:

; 3680 : 	}
; 3681 : 
; 3682 : 	for(uint uiSecondCityIndex = 0; uiSecondCityIndex < pCityConnections->m_aiCityPlotIDs.size(); uiSecondCityIndex++)

	inc	esi
	cmp	esi, DWORD PTR [edi+16]
	jb	SHORT $LL54@RouteGetNu
$LN6@RouteGetNu:

; 3707 : 		}
; 3708 : 	}
; 3709 : 
; 3710 : 	return iResultNum;

	mov	eax, DWORD PTR _iResultNum$[esp+12]
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 3711 : }

	ret	0
?RouteGetNumExtraChildren@@YAHPAVCvAStarNode@@PAVCvAStar@@@Z ENDP ; RouteGetNumExtraChildren
_TEXT	ENDS
PUBLIC	?WaterRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; WaterRouteValid
; Function compile flags: /Ogtpy
;	COMDAT ?WaterRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?WaterRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; WaterRouteValid, COMDAT

; 3717 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 3718 : 	CvPlot* pNewPlot;
; 3719 : #endif
; 3720 : 
; 3721 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[esp-4], 0
	jne	SHORT $LN4@WaterRoute

; 3722 : 	{
; 3723 : 		return TRUE;

	mov	eax, 1

; 3755 : 	{
; 3756 : 		return TRUE;
; 3757 : 	}
; 3758 : 
; 3759 : 	return FALSE;
; 3760 : }

	ret	0
$LN4@WaterRoute:

; 3724 : 	}
; 3725 : 
; 3726 : 	PlayerTypes ePlayer = (PlayerTypes)(finder->GetInfo());
; 3727 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR _finder$[esp-4]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ecx, 63236				; 0000f704H
	mov	eax, DWORD PTR [ecx+edx+44]
	push	edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN15@WaterRoute
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN16@WaterRoute
$LN15@WaterRoute:
	or	edi, -1
$LN16@WaterRoute:

; 3728 : 
; 3729 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3730 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3731 : 	const CvPlot* pNewPlot = node->m_pPlot;
; 3732 : #else
; 3733 : 	pNewPlot = node->m_pPlot;
; 3734 : #endif
; 3735 : 	if (!pNewPlot)
; 3736 : 		return FALSE;
; 3737 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 3738 : 	CvPlot* pNewPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);
; 3739 : #else
; 3740 : 	pNewPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);

	mov	eax, DWORD PTR _node$[esp]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	esi
	movsx	esi, WORD PTR [eax+82]
	imul	esi, DWORD PTR [ecx+4020]
	movsx	eax, WORD PTR [eax+80]
	add	esi, eax
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]

; 3741 : #endif
; 3742 : 
; 3743 : 	if(!(pNewPlot->isRevealed(eTeam)))

	mov	eax, edi
	shr	eax, 5
	mov	ecx, eax
	shl	ecx, 5
	mov	ebx, ecx
	mov	ecx, edi
	sub	ecx, ebx
	mov	ebx, 1
	shl	ebx, cl
	test	ebx, DWORD PTR [esi+eax*4+8]
	jne	SHORT $LN3@WaterRoute
	pop	esi
	pop	ebx

; 3744 : 	{
; 3745 : 		return FALSE;

	xor	eax, eax
	pop	edi

; 3755 : 	{
; 3756 : 		return TRUE;
; 3757 : 	}
; 3758 : 
; 3759 : 	return FALSE;
; 3760 : }

	ret	0
$LN3@WaterRoute:

; 3746 : 	}
; 3747 : 
; 3748 : 	CvCity* pCity = pNewPlot->getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN2@WaterRoute
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN2@WaterRoute
	imul	eax, 63236				; 0000f704H
	add	eax, edx
	mov	edx, DWORD PTR [esi+108]
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 3749 : 	if(pCity && pCity->getTeam() == eTeam)

	test	eax, eax
	je	SHORT $LN2@WaterRoute
	mov	ecx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	cmp	eax, edi
	jne	SHORT $LN2@WaterRoute
	pop	esi
	pop	ebx

; 3750 : 	{
; 3751 : 		return TRUE;

	mov	eax, 1
	pop	edi

; 3755 : 	{
; 3756 : 		return TRUE;
; 3757 : 	}
; 3758 : 
; 3759 : 	return FALSE;
; 3760 : }

	ret	0
$LN2@WaterRoute:

; 3752 : 	}
; 3753 : 
; 3754 : 	if(pNewPlot->isWater())

	xor	eax, eax
	cmp	BYTE PTR [esi+5], 3
	pop	esi
	pop	ebx
	sete	al
	pop	edi

; 3755 : 	{
; 3756 : 		return TRUE;
; 3757 : 	}
; 3758 : 
; 3759 : 	return FALSE;
; 3760 : }

	ret	0
?WaterRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; WaterRouteValid
_TEXT	ENDS
PUBLIC	__real@3f000000
PUBLIC	?BuildRouteCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; BuildRouteCost
EXTRN	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ:PROC ; CvPlot::GetBuilderAIScratchPadPlayer
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ:PROC	; CvPlot::GetBuilderAIScratchPadTurn
EXTRN	?getMovementCost@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getMovementCost
EXTRN	?getMovementCost@CvTerrainInfo@@QBEHXZ:PROC	; CvTerrainInfo::getMovementCost
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse_excpt:PROC
;	COMDAT __real@3f000000
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
CONST	ENDS
;	COMDAT ?BuildRouteCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_iMaxValue$ = 12					; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
tv152 = 24						; size = 4
_finder$ = 24						; size = 4
?BuildRouteCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; BuildRouteCost, COMDAT

; 3766 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3767 : 	const CvPlot* pPlot = node->m_pPlot;
; 3768 : #else
; 3769 : 	CvPlot* pPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);

	mov	eax, DWORD PTR _node$[esp-4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	esi
	movsx	esi, WORD PTR [eax+82]
	imul	esi, DWORD PTR [ecx+4020]
	movsx	eax, WORD PTR [eax+80]
	add	esi, eax
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]

; 3770 : #endif
; 3771 : 	int iFlags = finder->GetInfo();

	mov	ecx, DWORD PTR _finder$[esp+4]
	push	edi
	mov	edi, DWORD PTR [ecx+72]

; 3772 : 	PlayerTypes ePlayer = (PlayerTypes)(iFlags & 0xFF);

	mov	ebx, edi

; 3773 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();
; 3774 : 
; 3775 : 	int iRoute = iFlags & 0xFF00;
; 3776 : 	iRoute = iRoute >> 8;
; 3777 : 	iRoute = iRoute - 1;
; 3778 : 	RouteTypes eRoute = (RouteTypes)(iRoute);
; 3779 : 
; 3780 : 	if(pPlot->getRouteType() != NO_ROUTE)

	mov	ecx, esi
	and	ebx, 255				; 000000ffH
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	SHORT $LN4@BuildRoute

; 3781 : 	{
; 3782 : 		int iReturnValue = PATH_BUILD_ROUTE_EXISTING_ROUTE_WEIGHT;
; 3783 : 		if(pPlot->getRouteType() == eRoute)

	mov	ecx, esi
	mov	ebx, 10					; 0000000aH
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	sar	edi, 8
	and	edi, 255				; 000000ffH
	dec	edi
	cmp	eax, edi
	jne	SHORT $LN3@BuildRoute

; 3784 : 		{
; 3785 : 			iReturnValue = 1;

	mov	ebx, 1
$LN3@BuildRoute:
	pop	edi
	pop	esi

; 3786 : 		}
; 3787 : 		return iReturnValue;

	mov	eax, ebx
	pop	ebx

; 3823 : }

	ret	0
$LN4@BuildRoute:

; 3788 : 	}
; 3789 : 
; 3790 : 	int iMaxValue = 1500;
; 3791 : 
; 3792 : 	// if the plot is on a removable feature, it tends to be a good idea to build a road here
; 3793 : 	int iMovementCost = ((pPlot->getFeatureType() == NO_FEATURE) ? GC.getTerrainInfo(pPlot->getTerrainType())->getMovementCost() : GC.getFeatureInfo(pPlot->getFeatureType())->getMovementCost());

	mov	al, BYTE PTR [esi+432]
	mov	edi, 1500				; 000005dcH
	mov	DWORD PTR _iMaxValue$[esp+8], edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	cmp	al, -1
	jne	SHORT $LN7@BuildRoute
	movsx	eax, BYTE PTR [esi+6]
	push	eax
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getMovementCost@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getMovementCost
	jmp	SHORT $LN8@BuildRoute
$LN7@BuildRoute:
	movsx	edx, al
	push	edx
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getMovementCost@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getMovementCost
$LN8@BuildRoute:

; 3794 : 
; 3795 : #ifdef AUI_ASTAR_FIX_BUILD_ROUTE_COST_CONSIDER_HILLS_MOVEMENT
; 3796 : 	// Hill cost, except for when a City is present here, then it just counts as flat land
; 3797 : 	if ((PlotTypes)pPlot->getPlotType() == PLOT_HILLS && !pPlot->isCity())
; 3798 : 	{
; 3799 : 		iMovementCost += GC.getHILLS_EXTRA_MOVEMENT();
; 3800 : 	}
; 3801 : #endif
; 3802 : 
; 3803 : 	// calculate the max value based on how much of a movement increase we get
; 3804 : 	if(iMovementCost + 1 != 0)

	lea	ecx, DWORD PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN2@BuildRoute

; 3805 : 	{
; 3806 : 		iMaxValue = iMaxValue / 2 + iMaxValue / (iMovementCost + 1);

	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, eax
	add	edi, 750				; 000002eeH
	mov	DWORD PTR _iMaxValue$[esp+8], edi
$LN2@BuildRoute:
	push	ebp

; 3807 : 	}
; 3808 : 
; 3809 : 	// if the tile already been tagged for building a road, then provide a discount
; 3810 : 	if(pPlot->GetBuilderAIScratchPadTurn() == GC.getGame().getGameTurn() && pPlot->GetBuilderAIScratchPadPlayer() == ePlayer)

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ecx, esi
	call	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ ; CvPlot::GetBuilderAIScratchPadTurn
	cwde
	mov	ecx, ebp
	mov	DWORD PTR tv152[esp+12], eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	pop	ebp
	cmp	DWORD PTR tv152[esp+8], eax
	jne	SHORT $LN1@BuildRoute
	mov	ecx, esi
	call	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetBuilderAIScratchPadPlayer
	cmp	eax, ebx
	jne	SHORT $LN1@BuildRoute

; 3811 : 	{
; 3812 : 		iMaxValue = (int)(iMaxValue * PATH_BUILD_ROUTE_ALREADY_FLAGGED_DISCOUNT);

	fild	DWORD PTR _iMaxValue$[esp+8]
	fmul	DWORD PTR __real@3f000000
	call	__ftol2_sse_excpt
	mov	edi, eax
$LN1@BuildRoute:

; 3813 : 	}
; 3814 : 
; 3815 : #ifdef AUI_WORKER_INCA_HILLS
; 3816 : 	if (GET_PLAYER(ePlayer).GetPlayerTraits()->IsNoHillsImprovementMaintenance() && pPlot->isHills())
; 3817 : 	{
; 3818 : 		iMaxValue /= 2;
; 3819 : 	}
; 3820 : #endif
; 3821 : 
; 3822 : 	return iMaxValue;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3823 : }

	ret	0
?BuildRouteCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; BuildRouteCost
_TEXT	ENDS
PUBLIC	?BuildRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; BuildRouteValid
; Function compile flags: /Ogtpy
;	COMDAT ?BuildRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?BuildRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; BuildRouteValid, COMDAT

; 3829 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 3830 : 	CvPlot* pNewPlot;
; 3831 : #endif
; 3832 : 
; 3833 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[esp-4], 0
	jne	SHORT $LN11@BuildRoute@2

; 3834 : 	{
; 3835 : 		return TRUE;

	mov	eax, 1

; 3904 : }

	ret	0
$LN11@BuildRoute@2:

; 3836 : 	}
; 3837 : 
; 3838 : 	int iFlags = finder->GetInfo();
; 3839 : 	PlayerTypes ePlayer = (PlayerTypes)(iFlags & 0xFF);

	mov	eax, DWORD PTR _finder$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+72]
	and	edi, 255				; 000000ffH

; 3840 : 
; 3841 : 	CvPlayer& thisPlayer = GET_PLAYER(ePlayer);

	mov	esi, edi
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 3842 : 	bool bThisPlayerIsMinor = thisPlayer.isMinorCiv();

	mov	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv

; 3843 : 
; 3844 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3845 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3846 : 	const CvPlot* pNewPlot = node->m_pPlot;
; 3847 : #else
; 3848 : 	pNewPlot = node->m_pPlot;
; 3849 : #endif
; 3850 : 	if (!pNewPlot)
; 3851 : 		return FALSE;
; 3852 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 3853 : 	CvPlot* pNewPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);
; 3854 : #else
; 3855 : 	pNewPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR _node$[esp+8]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	bl, al
	movsx	eax, WORD PTR [ecx+82]
	imul	eax, DWORD PTR [edx+4020]
	movsx	ecx, WORD PTR [ecx+80]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [edx+4068]

; 3856 : #endif
; 3857 : 	if(!bThisPlayerIsMinor && !(pNewPlot->isRevealed(thisPlayer.getTeam())))

	test	bl, bl
	jne	SHORT $LN10@BuildRoute@2
	mov	esi, DWORD PTR [esi+44]
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN30@BuildRoute@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+esi*4]
	jmp	SHORT $LN31@BuildRoute@2
$LN30@BuildRoute@2:
	or	ecx, -1
$LN31@BuildRoute@2:
	mov	edx, ecx
	shr	edx, 5
	mov	esi, edx
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [eax+edx*4+8]

; 3858 : 	{
; 3859 : 		return FALSE;

	je	SHORT $LN7@BuildRoute@2
$LN10@BuildRoute@2:

; 3860 : 	}
; 3861 : 
; 3862 : 	if(pNewPlot->isWater())

	mov	cl, BYTE PTR [eax+5]
	cmp	cl, 3

; 3863 : 	{
; 3864 : 		return FALSE;

	je	SHORT $LN7@BuildRoute@2

; 3865 : 	}
; 3866 : 
; 3867 : #ifdef AUI_ASTAR_FIX_STEP_VALID_CONSIDERS_MOUNTAINS
; 3868 : 	if (pNewPlot->isImpassable())
; 3869 : #else
; 3870 : 	if(pNewPlot->isImpassable() || pNewPlot->isMountain())

	test	BYTE PTR [eax+462], 128			; 00000080H
	jne	SHORT $LN7@BuildRoute@2
	test	cl, cl
	je	SHORT $LN7@BuildRoute@2

; 3874 : 	}
; 3875 : 
; 3876 : 	PlayerTypes ePlotOwnerPlayer = pNewPlot->getOwner();

	movsx	esi, BYTE PTR [eax+4]

; 3877 : 	if(ePlotOwnerPlayer != NO_PLAYER && !pNewPlot->IsFriendlyTerritory(ePlayer))

	cmp	esi, -1
	je	SHORT $LN1@BuildRoute@2
	push	edi
	mov	ecx, eax
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	test	al, al
	jne	SHORT $LN1@BuildRoute@2

; 3878 : 	{
; 3879 : 		PlayerTypes eMajorPlayer = NO_PLAYER;
; 3880 : 		PlayerTypes eMinorPlayer = NO_PLAYER;
; 3881 : 		bool bPlotOwnerIsMinor = GET_PLAYER(ePlotOwnerPlayer).isMinorCiv();

	mov	ecx, esi
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv

; 3882 : 		if(bThisPlayerIsMinor && !bPlotOwnerIsMinor)

	test	bl, bl
	je	SHORT $LN5@BuildRoute@2
	test	al, al
	jne	SHORT $LN7@BuildRoute@2

; 3883 : 		{
; 3884 : 			eMajorPlayer = ePlotOwnerPlayer;

	mov	eax, esi

; 3885 : 			eMinorPlayer = ePlayer;

	jmp	SHORT $LN2@BuildRoute@2
$LN5@BuildRoute@2:

; 3886 : 		}
; 3887 : 		else if(bPlotOwnerIsMinor && !bThisPlayerIsMinor)

	test	al, al
	je	SHORT $LN7@BuildRoute@2

; 3888 : 		{
; 3889 : 			eMajorPlayer = ePlayer;

	mov	eax, edi

; 3890 : 			eMinorPlayer = ePlotOwnerPlayer;

	mov	edi, esi
$LN2@BuildRoute@2:

; 3891 : 		}
; 3892 : 		else
; 3893 : 		{
; 3894 : 			return FALSE;
; 3895 : 		}
; 3896 : 
; 3897 : 		if(!GET_PLAYER(eMinorPlayer).GetMinorCivAI()->IsActiveQuestForPlayer(eMajorPlayer, MINOR_CIV_QUEST_ROUTE))

	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	eax
	mov	ecx, edi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsActiveQuestForPlayer
	test	al, al

; 3898 : 		{
; 3899 : 			return FALSE;

	je	SHORT $LN7@BuildRoute@2
$LN1@BuildRoute@2:
	pop	edi
	pop	esi

; 3900 : 		}
; 3901 : 	}
; 3902 : 
; 3903 : 	return TRUE;

	mov	eax, 1
	pop	ebx

; 3904 : }

	ret	0
$LN7@BuildRoute@2:
	pop	edi
	pop	esi

; 3871 : #endif
; 3872 : 	{
; 3873 : 		return FALSE;

	xor	eax, eax
	pop	ebx

; 3904 : }

	ret	0
?BuildRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; BuildRouteValid
_TEXT	ENDS
PUBLIC	?AreaValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; AreaValid
; Function compile flags: /Ogtpy
;	COMDAT ?AreaValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
tv250 = 8						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?AreaValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; AreaValid, COMDAT

; 3911 : 	if(parent == NULL)

	mov	edx, DWORD PTR _parent$[esp-4]
	test	edx, edx
	jne	SHORT $LN2@AreaValid

; 3912 : 	{
; 3913 : 		return TRUE;

	lea	eax, DWORD PTR [edx+1]

; 3937 : #endif
; 3938 : }

	ret	0
$LN2@AreaValid:

; 3914 : 	}
; 3915 : 
; 3916 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3917 : 	const CvPlot* pOldPlot = parent->m_pPlot;
; 3918 : 	const CvPlot* pNewPlot = node->m_pPlot;
; 3919 : 	if (!pOldPlot || !pNewPlot)
; 3920 : 	{
; 3921 : 		return FALSE;
; 3922 : 	}
; 3923 : 	if (pOldPlot->isImpassable() != pNewPlot->isImpassable())
; 3924 : 	{
; 3925 : 		return FALSE;
; 3926 : 	}
; 3927 : 
; 3928 : 	return (pOldPlot->isWater() == pNewPlot->isWater() ? TRUE : FALSE);
; 3929 : #else
; 3930 : 	CvMap& kMap = GC.getMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 3931 : 	if(kMap.plotUnchecked(parent->m_iX, parent->m_iY)->isImpassable() != kMap.plotUnchecked(node->m_iX, node->m_iY)->isImpassable())

	mov	eax, DWORD PTR [ecx+4020]
	push	ebx
	push	ebp
	movsx	ebp, WORD PTR [edx+80]
	push	esi
	mov	esi, DWORD PTR [ecx+4068]
	push	edi
	movsx	edi, WORD PTR [edx+82]
	mov	edx, DWORD PTR _node$[esp+12]
	movsx	ebx, WORD PTR [edx+82]
	movsx	edx, WORD PTR [edx+80]
	mov	DWORD PTR tv250[esp+12], ebx
	imul	ebx, eax
	imul	eax, edi
	add	ebx, edx
	imul	ebx, 484				; 000001e4H
	mov	bl, BYTE PTR [ebx+esi+462]
	add	eax, ebp
	imul	eax, 484				; 000001e4H
	xor	bl, BYTE PTR [eax+esi+462]
	test	bl, bl
	jns	SHORT $LN1@AreaValid
	pop	edi
	pop	esi
	pop	ebp

; 3932 : 	{
; 3933 : 		return FALSE;

	xor	eax, eax
	pop	ebx

; 3937 : #endif
; 3938 : }

	ret	0
$LN1@AreaValid:

; 3934 : 	}
; 3935 : 
; 3936 : 	return ((kMap.plotUnchecked(parent->m_iX, parent->m_iY)->isWater() == kMap.plotUnchecked(node->m_iX, node->m_iY)->isWater()) ? TRUE : FALSE);

	mov	eax, DWORD PTR [ecx+4020]
	mov	ecx, esi
	mov	esi, eax
	imul	esi, DWORD PTR tv250[esp+12]
	add	esi, edx
	imul	esi, 484				; 000001e4H
	mov	dl, 3
	cmp	BYTE PTR [esi+ecx+5], dl
	sete	bl
	imul	eax, edi
	add	eax, ebp
	imul	eax, 484				; 000001e4H
	cmp	BYTE PTR [eax+ecx+5], dl
	pop	edi
	sete	al
	xor	ecx, ecx
	cmp	al, bl
	sete	cl
	pop	esi
	pop	ebp
	pop	ebx
	mov	eax, ecx

; 3937 : #endif
; 3938 : }

	ret	0
?AreaValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; AreaValid
_TEXT	ENDS
PUBLIC	?JoinArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; JoinArea
EXTRN	?setArea@CvPlot@@QAEXH@Z:PROC			; CvPlot::setArea
; Function compile flags: /Ogtpy
;	COMDAT ?JoinArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?JoinArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; JoinArea, COMDAT

; 3945 : 	if(data == ASNL_ADDCLOSED)

	cmp	DWORD PTR _data$[esp-4], 3
	jne	SHORT $LN14@JoinArea

; 3946 : 	{
; 3947 : #if defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES)
; 3948 : 		node->m_pPlot->setArea(finder->GetInfo());
; 3949 : #else
; 3950 : 		GC.getMap().plotUnchecked(node->m_iX, node->m_iY)->setArea(finder->GetInfo());

	mov	eax, DWORD PTR _finder$[esp-4]
	mov	ecx, DWORD PTR [eax+72]
	mov	eax, DWORD PTR _node$[esp-4]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ecx
	movsx	ecx, WORD PTR [eax+82]
	imul	ecx, DWORD PTR [edx+4020]
	movsx	eax, WORD PTR [eax+80]
	add	ecx, eax
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	call	?setArea@CvPlot@@QAEXH@Z		; CvPlot::setArea
$LN14@JoinArea:

; 3951 : #endif
; 3952 : 	}
; 3953 : 
; 3954 : 	return 1;

	mov	eax, 1

; 3955 : }

	ret	0
?JoinArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; JoinArea
_TEXT	ENDS
PUBLIC	?LandmassValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; LandmassValid
; Function compile flags: /Ogtpy
;	COMDAT ?LandmassValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?LandmassValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; LandmassValid, COMDAT

; 3962 : 	if(parent == NULL)

	mov	edx, DWORD PTR _parent$[esp-4]
	test	edx, edx
	jne	SHORT $LN1@LandmassVa

; 3963 : 	{
; 3964 : 		return TRUE;

	lea	eax, DWORD PTR [edx+1]

; 3972 : #endif
; 3973 : }

	ret	0
$LN1@LandmassVa:

; 3965 : 	}
; 3966 : 
; 3967 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3968 : 	return (parent->m_pPlot && node->m_pPlot && parent->m_pPlot->isWater() == node->m_pPlot->isWater() ? TRUE : FALSE);
; 3969 : #else
; 3970 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 3971 : 	return ((kMap.plotUnchecked(parent->m_iX, parent->m_iY)->isWater() == kMap.plotUnchecked(node->m_iX, node->m_iY)->isWater()) ? TRUE : FALSE);

	mov	ecx, DWORD PTR [eax+4020]
	mov	eax, DWORD PTR [eax+4068]
	push	ebx
	push	esi
	movsx	esi, WORD PTR [edx+82]
	movsx	edx, WORD PTR [edx+80]
	imul	esi, ecx
	add	esi, edx
	imul	esi, 484				; 000001e4H
	push	edi
	mov	dl, 3
	cmp	BYTE PTR [esi+eax+5], dl
	mov	esi, DWORD PTR _node$[esp+8]
	movsx	edi, WORD PTR [esi+82]
	sete	bl
	imul	edi, ecx
	movsx	ecx, WORD PTR [esi+80]
	add	edi, ecx
	imul	edi, 484				; 000001e4H
	cmp	BYTE PTR [edi+eax+5], dl
	pop	edi
	sete	dl
	xor	eax, eax
	cmp	bl, dl
	pop	esi
	sete	al
	pop	ebx

; 3972 : #endif
; 3973 : }

	ret	0
?LandmassValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; LandmassValid
_TEXT	ENDS
PUBLIC	?JoinLandmass@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; JoinLandmass
EXTRN	?setLandmass@CvPlot@@QAEXH@Z:PROC		; CvPlot::setLandmass
; Function compile flags: /Ogtpy
;	COMDAT ?JoinLandmass@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?JoinLandmass@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; JoinLandmass, COMDAT

; 3980 : 	if(data == ASNL_ADDCLOSED)

	cmp	DWORD PTR _data$[esp-4], 3
	jne	SHORT $LN14@JoinLandma

; 3981 : 	{
; 3982 : #if defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES)
; 3983 : 		node->m_pPlot->setLandmass(finder->GetInfo());
; 3984 : #else
; 3985 : 		GC.getMap().plotUnchecked(node->m_iX, node->m_iY)->setLandmass(finder->GetInfo());

	mov	eax, DWORD PTR _finder$[esp-4]
	mov	ecx, DWORD PTR [eax+72]
	mov	eax, DWORD PTR _node$[esp-4]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ecx
	movsx	ecx, WORD PTR [eax+82]
	imul	ecx, DWORD PTR [edx+4020]
	movsx	eax, WORD PTR [eax+80]
	add	ecx, eax
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	call	?setLandmass@CvPlot@@QAEXH@Z		; CvPlot::setLandmass
$LN14@JoinLandma:

; 3986 : #endif
; 3987 : 	}
; 3988 : 
; 3989 : 	return 1;

	mov	eax, 1

; 3990 : }

	ret	0
?JoinLandmass@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; JoinLandmass
_TEXT	ENDS
PUBLIC	?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ ; CvTwoLayerPathFinder::GetPathEndTurnPlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ PROC ; CvTwoLayerPathFinder::GetPathEndTurnPlot, COMDAT
; _this$ = ecx

; 4073 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4074 : 	CvAStarNode* pNode = m_pBest;
; 4075 : #else
; 4076 : 	CvAStarNode* pNode;
; 4077 : 
; 4078 : 	pNode = m_pBest;

	mov	ecx, DWORD PTR [ecx+96]

; 4079 : #endif
; 4080 : 
; 4081 : 	if(NULL != pNode)

	test	ecx, ecx
	je	SHORT $LN2@GetPathEnd

; 4082 : 	{
; 4083 : 		if((pNode->m_pParent == NULL) || (pNode->m_iData2 == 1))

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LN4@GetPathEnd
	mov	edx, 1
	cmp	DWORD PTR [ecx+16], edx
	je	SHORT $LN4@GetPathEnd
$LL3@GetPathEnd:

; 4084 : 		{
; 4085 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4086 : 			return pNode->m_pPlot;
; 4087 : #else
; 4088 : 			return GC.getMap().plotUnchecked(pNode->m_iX, pNode->m_iY);
; 4089 : #endif
; 4090 : 		}
; 4091 : 
; 4092 : 		while(pNode->m_pParent != NULL)
; 4093 : 		{
; 4094 : 			if(pNode->m_pParent->m_iData2 == 1)

	cmp	DWORD PTR [eax+16], edx
	je	SHORT $LN26@GetPathEnd

; 4100 : #endif
; 4101 : 			}
; 4102 : 
; 4103 : 			pNode = pNode->m_pParent;

	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LL3@GetPathEnd
$LN2@GetPathEnd:

; 4104 : 		}
; 4105 : 	}
; 4106 : 
; 4107 : 	FAssert(false);
; 4108 : 
; 4109 : 	return NULL;

	xor	eax, eax

; 4110 : }

	ret	0
$LN26@GetPathEnd:

; 4095 : 			{
; 4096 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4097 : 				return pNode->m_pParent->m_pPlot;
; 4098 : #else
; 4099 : 				return GC.getMap().plotUnchecked(pNode->m_pParent->m_iX, pNode->m_pParent->m_iY);

	mov	ecx, DWORD PTR [ecx+24]
$LN4@GetPathEnd:
	movsx	eax, WORD PTR [ecx+82]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	eax, DWORD PTR [edx+4020]
	movsx	ecx, WORD PTR [ecx+80]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [edx+4068]

; 4110 : }

	ret	0
?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ ENDP ; CvTwoLayerPathFinder::GetPathEndTurnPlot
_TEXT	ENDS
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z$2
__ehfuncinfo$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
xdata$x	ENDS
;	COMDAT ?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z
_TEXT	SEGMENT
_strBaseString$220529 = -96				; size = 28
_strOutBuf$220528 = -68					; size = 28
$T225927 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pkUnit$ = 8						; size = 4
_strMsg$ = 12						; size = 4
?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z PROC	; LogPathGeneration, COMDAT

; 4115 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 84					; 00000054H
	push	ebp
	mov	ebp, DWORD PTR _pkUnit$[esp+96]

; 4116 : 	if(GC.getLogging() && GC.getAILogging() && pkUnit)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogPathGen
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogPathGen
	test	ebp, ebp
	je	$LN1@LogPathGen
	push	esi
	push	edi

; 4117 : 	{
; 4118 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$220528[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4119 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$220529[esp+108]
	mov	DWORD PTR __$EHRec$[esp+116], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4120 : 
; 4121 : 		CvPlayer& kPlayer = GET_PLAYER(pkUnit->getOwner());

	mov	eax, DWORD PTR [ebp+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+116], 1

; 4122 : 		const char* pszPlayerName = kPlayer.getCivilizationShortDescription();

	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription

; 4123 : 		FILogFile* pLog = LOGFILEMGR.GetLog((gDLL->IsGameCoreThread())?"AStar_GC.log":"AStar_APP.log", FILogFile::kDontTimeStamp, "Game Turn, Player, Unit, From X, From Y, To X, To Y, Info, Checksum");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edi, eax
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+928]
	call	edx
	mov	esi, OFFSET $SG220534
	test	al, al
	jne	SHORT $LN5@LogPathGen
	mov	esi, OFFSET $SG220535
$LN5@LogPathGen:
	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	edx, DWORD PTR [eax]
	push	OFFSET $SG220533
	push	1
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+12]
	push	esi
	call	eax
	mov	esi, eax

; 4124 : 
; 4125 : 		// Get the leading info for this line
; 4126 : 		strBaseString.Format("%03d, %s, UnitID: %d, ", GC.getGame().getElapsedGameTurns(), (pszPlayerName)?pszPlayerName:"?", pkUnit->GetID());

	test	edi, edi
	jne	SHORT $LN7@LogPathGen
	mov	edi, OFFSET $SG220536
$LN7@LogPathGen:
	mov	eax, DWORD PTR [ebp+100]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	push	edi
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$220529[esp+120]
	push	OFFSET $SG220537
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4127 : 		strOutBuf = strBaseString + strMsg;

	mov	edx, DWORD PTR _strMsg$[esp+124]
	push	edx
	lea	eax, DWORD PTR _strBaseString$220529[esp+132]
	push	eax
	lea	ecx, DWORD PTR $T225927[esp+136]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 32					; 00000020H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+116], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$220528[esp+112]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T225927[esp+108]
	mov	BYTE PTR __$EHRec$[esp+116], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4128 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$220528[esp+108]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	esi
	call	eax
	add	esp, 8

; 4129 : 	}

	lea	ecx, DWORD PTR _strBaseString$220529[esp+108]
	mov	BYTE PTR __$EHRec$[esp+116], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$220528[esp+108]
	mov	DWORD PTR __$EHRec$[esp+116], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
$LN1@LogPathGen:

; 4130 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 96					; 00000060H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$220528[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$220529[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z$2:
	lea	ecx, DWORD PTR $T225927[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z ENDP	; LogPathGeneration
PUBLIC	?GetPathFirstPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ ; CvIgnoreUnitsPathFinder::GetPathFirstPlot
EXTRN	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ:PROC ; CvGlobals::getIgnoreUnitsPathFinder
; Function compile flags: /Ogtpy
;	COMDAT ?GetPathFirstPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
?GetPathFirstPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ PROC ; CvIgnoreUnitsPathFinder::GetPathFirstPlot, COMDAT
; _this$ = ecx

; 4468 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4469 : 	CvAStarNode* pNode = GetLastNode();
; 4470 : #else
; 4471 : 	CvAStarNode* pNode;
; 4472 : 
; 4473 : 	pNode = GC.getIgnoreUnitsPathFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	ecx, DWORD PTR [eax+96]

; 4474 : #endif
; 4475 : 
; 4476 : #ifndef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4477 : 	CvMap& kMap = GC.getMap();
; 4478 : #endif
; 4479 : 	if(pNode->m_pParent == NULL)

	cmp	DWORD PTR [ecx+24], 0
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jne	SHORT $LL3@GetPathFir
$LN24@GetPathFir:

; 4480 : 	{
; 4481 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4482 : 		return pNode->m_pPlot;
; 4483 : #else
; 4484 : 		return kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);

	movsx	eax, WORD PTR [ecx+82]
	imul	eax, DWORD PTR [edx+4020]
	movsx	ecx, WORD PTR [ecx+80]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [edx+4068]

; 4500 : 	}
; 4501 : 
; 4502 : 	FAssert(false);
; 4503 : 
; 4504 : 	return NULL;
; 4505 : }

	ret	0
$LL3@GetPathFir:

; 4485 : #endif
; 4486 : 	}
; 4487 : 
; 4488 : 	while(pNode != NULL)
; 4489 : 	{
; 4490 : 		if(pNode->m_pParent->m_pParent == NULL)

	mov	eax, DWORD PTR [ecx+24]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN24@GetPathFir

; 4491 : 		{
; 4492 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4493 : 			return pNode->m_pPlot;
; 4494 : #else
; 4495 : 			return kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);
; 4496 : #endif
; 4497 : 		}
; 4498 : 
; 4499 : 		pNode = pNode->m_pParent;

	mov	ecx, eax
	test	ecx, ecx
	jne	SHORT $LL3@GetPathFir

; 4500 : 	}
; 4501 : 
; 4502 : 	FAssert(false);
; 4503 : 
; 4504 : 	return NULL;
; 4505 : }

	ret	0
?GetPathFirstPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ ENDP ; CvIgnoreUnitsPathFinder::GetPathFirstPlot
_TEXT	ENDS
PUBLIC	?GetPathEndTurnPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ ; CvIgnoreUnitsPathFinder::GetPathEndTurnPlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetPathEndTurnPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
?GetPathEndTurnPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ PROC ; CvIgnoreUnitsPathFinder::GetPathEndTurnPlot, COMDAT
; _this$ = ecx

; 4511 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4512 : 	CvAStarNode* pNode = GetLastNode();
; 4513 : #else
; 4514 : 	CvAStarNode* pNode;
; 4515 : 
; 4516 : 	pNode = GC.getIgnoreUnitsPathFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	ecx, DWORD PTR [eax+96]

; 4517 : #endif
; 4518 : 
; 4519 : 	if(NULL != pNode)

	test	ecx, ecx
	je	SHORT $LN2@GetPathEnd@2

; 4520 : 	{
; 4521 : #ifndef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4522 : 		CvMap& kMap = GC.getMap();
; 4523 : #endif
; 4524 : 		if((pNode->m_pParent == NULL) || (pNode->m_iData2 == 1))

	mov	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	test	eax, eax
	je	SHORT $LN4@GetPathEnd@2
	cmp	DWORD PTR [ecx+16], 1
	je	SHORT $LN4@GetPathEnd@2
$LL3@GetPathEnd@2:

; 4525 : 		{
; 4526 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4527 : 			return pNode->m_pPlot;
; 4528 : #else
; 4529 : 			return kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);
; 4530 : #endif
; 4531 : 		}
; 4532 : 
; 4533 : 		while(pNode->m_pParent != NULL)
; 4534 : 		{
; 4535 : 			if(pNode->m_pParent->m_iData2 == 1)

	cmp	DWORD PTR [eax+16], 1
	je	SHORT $LN26@GetPathEnd@2

; 4541 : #endif
; 4542 : 			}
; 4543 : 
; 4544 : 			pNode = pNode->m_pParent;

	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LL3@GetPathEnd@2
$LN2@GetPathEnd@2:

; 4545 : 		}
; 4546 : 	}
; 4547 : 
; 4548 : 	FAssert(false);
; 4549 : 
; 4550 : 	return NULL;

	xor	eax, eax

; 4551 : }

	ret	0
$LN26@GetPathEnd@2:

; 4536 : 			{
; 4537 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4538 : 				return pNode->m_pParent->m_pPlot;
; 4539 : #else
; 4540 : 				return kMap.plotUnchecked(pNode->m_pParent->m_iX, pNode->m_pParent->m_iY);

	mov	ecx, DWORD PTR [ecx+24]
$LN4@GetPathEnd@2:
	movsx	eax, WORD PTR [ecx+82]
	imul	eax, DWORD PTR [edx+4020]
	movsx	ecx, WORD PTR [ecx+80]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [edx+4068]

; 4551 : }

	ret	0
?GetPathEndTurnPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ ENDP ; CvIgnoreUnitsPathFinder::GetPathEndTurnPlot
_TEXT	ENDS
PUBLIC	?GetLastPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ ; CvIgnoreUnitsPathFinder::GetLastPlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetLastPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_pNode$ = -8						; size = 4
_this$ = -4						; size = 4
?GetLastPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ PROC ; CvIgnoreUnitsPathFinder::GetLastPlot, COMDAT
; _this$ = ecx

; 4556 : {

	sub	esp, 8
	mov	DWORD PTR _this$[esp+8], ecx
	push	esi

; 4557 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4558 : 	CvAStarNode* pNode = GetLastNode();
; 4559 : 	if (pNode != NULL)
; 4560 : 	{
; 4561 : 		// Save off node for future calls to GetPreviousPlot()
; 4562 : 		m_pCurNode = pNode;
; 4563 : 
; 4564 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4565 : 		return pNode->m_pPlot;
; 4566 : #else
; 4567 : 		return GC.getMap().plot(pNode->m_iX, pNode->m_iY);
; 4568 : #endif
; 4569 : 	}
; 4570 : 
; 4571 : 	return NULL;
; 4572 : #else
; 4573 : 	CvPlot* pPlot = NULL;
; 4574 : 
; 4575 : 	CvAStarNode* pNode = GC.getIgnoreUnitsPathFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pNode$[esp+12], ecx

; 4576 : 	if(pNode != NULL)

	test	ecx, ecx
	je	$LN47@GetLastPlo

; 4577 : 	{
; 4578 : 		pPlot = GC.getMap().plot(pNode->m_iX, pNode->m_iY);

	movsx	eax, WORD PTR [ecx+80]
	push	ebx
	movsx	ebx, WORD PTR [ecx+82]
	push	ebp
	push	edi
	cmp	eax, -2147483647			; 80000001H
	je	$LN8@GetLastPlo
	cmp	ebx, -2147483647			; 80000001H
	je	$LN8@GetLastPlo
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN18@GetLastPlo
	test	eax, eax
	jge	SHORT $LN20@GetLastPlo
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN22@GetLastPlo
$LN20@GetLastPlo:
	cmp	eax, ecx
	jl	SHORT $LN18@GetLastPlo
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN22@GetLastPlo
$LN18@GetLastPlo:
	mov	esi, eax
$LN22@GetLastPlo:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN48@GetLastPlo
	test	ebx, ebx
	jge	SHORT $LN30@GetLastPlo
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN32@GetLastPlo
$LN30@GetLastPlo:
	cmp	ebx, edi
	jl	SHORT $LN48@GetLastPlo
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN32@GetLastPlo
$LN48@GetLastPlo:
	mov	edx, ebx
$LN32@GetLastPlo:
	test	esi, esi
	jl	SHORT $LN12@GetLastPlo
	cmp	esi, ecx
	jge	SHORT $LN12@GetLastPlo
	test	edx, edx
	jl	SHORT $LN12@GetLastPlo
	cmp	edx, edi
	jge	SHORT $LN12@GetLastPlo
	imul	ecx, edx

; 4579 : 
; 4580 : 		// Save off node for future calls to GetPreviousPlot()
; 4581 : 		m_pCurNode = pNode;

	mov	edx, DWORD PTR _this$[esp+24]
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	ebp
	mov	eax, ecx
	mov	ecx, DWORD PTR _pNode$[esp+16]
	pop	ebx
	mov	DWORD PTR [edx+628], ecx
	pop	esi

; 4585 : #endif
; 4586 : }

	add	esp, 8
	ret	0

; 4577 : 	{
; 4578 : 		pPlot = GC.getMap().plot(pNode->m_iX, pNode->m_iY);

$LN12@GetLastPlo:
	mov	ecx, DWORD PTR _pNode$[esp+24]
$LN8@GetLastPlo:

; 4579 : 
; 4580 : 		// Save off node for future calls to GetPreviousPlot()
; 4581 : 		m_pCurNode = pNode;

	mov	edx, DWORD PTR _this$[esp+24]
	pop	edi
	pop	ebp
	pop	ebx
	xor	eax, eax
	mov	DWORD PTR [edx+628], ecx
	pop	esi

; 4585 : #endif
; 4586 : }

	add	esp, 8
	ret	0
$LN47@GetLastPlo:

; 4582 : 	}
; 4583 : 
; 4584 : 	return pPlot;

	mov	eax, esi
	pop	esi

; 4585 : #endif
; 4586 : }

	add	esp, 8
	ret	0
?GetLastPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ ENDP ; CvIgnoreUnitsPathFinder::GetLastPlot
_TEXT	ENDS
PUBLIC	?GetPreviousPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ ; CvIgnoreUnitsPathFinder::GetPreviousPlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetPreviousPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ
_TEXT	SEGMENT
?GetPreviousPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ PROC ; CvIgnoreUnitsPathFinder::GetPreviousPlot, COMDAT
; _this$ = ecx

; 4592 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 4593 : 	CvPlot* pPlot = NULL;
; 4594 : #endif
; 4595 : 
; 4596 : 	if(m_pCurNode != NULL)

	mov	edx, DWORD PTR [ecx+628]
	xor	eax, eax
	test	edx, edx
	je	$LN9@GetPreviou

; 4597 : 	{
; 4598 : 		m_pCurNode = m_pCurNode->m_pParent;

	mov	edx, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+628], edx

; 4599 : 
; 4600 : 		if(m_pCurNode != NULL)

	test	edx, edx
	je	$LN9@GetPreviou

; 4601 : 		{
; 4602 : #if defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES) && defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4603 : 			return m_pCurNode->m_pPlot;
; 4604 : #elif defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES)
; 4605 : 			pPlot = m_pCurNode->m_pPlot;
; 4606 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4607 : 			return GC.getMap().plot(m_pCurNode->m_iX, m_pCurNode->m_iY);
; 4608 : #else
; 4609 : 			pPlot = GC.getMap().plot(m_pCurNode->m_iX, m_pCurNode->m_iY);

	movsx	eax, WORD PTR [edx+80]
	push	ebx
	movsx	ebx, WORD PTR [edx+82]
	cmp	eax, -2147483647			; 80000001H
	je	$LN7@GetPreviou
	cmp	ebx, -2147483647			; 80000001H
	je	$LN7@GetPreviou
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	push	esi
	je	SHORT $LN17@GetPreviou
	test	eax, eax
	jge	SHORT $LN19@GetPreviou
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@GetPreviou
$LN19@GetPreviou:
	cmp	eax, ecx
	jl	SHORT $LN17@GetPreviou
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@GetPreviou
$LN17@GetPreviou:
	mov	esi, eax
$LN21@GetPreviou:
	cmp	BYTE PTR [ebp+4057], 0
	push	edi
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN48@GetPreviou
	test	ebx, ebx
	jge	SHORT $LN29@GetPreviou
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@GetPreviou
$LN29@GetPreviou:
	cmp	ebx, edi
	jl	SHORT $LN48@GetPreviou
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@GetPreviou
$LN48@GetPreviou:
	mov	edx, ebx
$LN31@GetPreviou:
	test	esi, esi
	jl	SHORT $LN11@GetPreviou
	cmp	esi, ecx
	jge	SHORT $LN11@GetPreviou
	test	edx, edx
	jl	SHORT $LN11@GetPreviou
	cmp	edx, edi
	jge	SHORT $LN11@GetPreviou
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx
$LN9@GetPreviou:

; 4610 : #endif
; 4611 : 		}
; 4612 : 	}
; 4613 : 
; 4614 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4615 : 	return NULL;
; 4616 : #else
; 4617 : 	return pPlot;
; 4618 : #endif
; 4619 : }

	ret	0

; 4601 : 		{
; 4602 : #if defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES) && defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4603 : 			return m_pCurNode->m_pPlot;
; 4604 : #elif defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES)
; 4605 : 			pPlot = m_pCurNode->m_pPlot;
; 4606 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4607 : 			return GC.getMap().plot(m_pCurNode->m_iX, m_pCurNode->m_iY);
; 4608 : #else
; 4609 : 			pPlot = GC.getMap().plot(m_pCurNode->m_iX, m_pCurNode->m_iY);

$LN11@GetPreviou:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 4610 : #endif
; 4611 : 		}
; 4612 : 	}
; 4613 : 
; 4614 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4615 : 	return NULL;
; 4616 : #else
; 4617 : 	return pPlot;
; 4618 : #endif
; 4619 : }

	ret	0

; 4601 : 		{
; 4602 : #if defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES) && defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4603 : 			return m_pCurNode->m_pPlot;
; 4604 : #elif defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES)
; 4605 : 			pPlot = m_pCurNode->m_pPlot;
; 4606 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4607 : 			return GC.getMap().plot(m_pCurNode->m_iX, m_pCurNode->m_iY);
; 4608 : #else
; 4609 : 			pPlot = GC.getMap().plot(m_pCurNode->m_iX, m_pCurNode->m_iY);

$LN7@GetPreviou:
	xor	eax, eax
	pop	ebx

; 4610 : #endif
; 4611 : 		}
; 4612 : 	}
; 4613 : 
; 4614 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4615 : 	return NULL;
; 4616 : #else
; 4617 : 	return pPlot;
; 4618 : #endif
; 4619 : }

	ret	0
?GetPreviousPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ ENDP ; CvIgnoreUnitsPathFinder::GetPreviousPlot
_TEXT	ENDS
PUBLIC	?UIPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; UIPathValid
EXTRN	?isAdjacentToArea@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isAdjacentToArea
EXTRN	?getArea@CvUnit@@QBEHXZ:PROC			; CvUnit::getArea
EXTRN	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z:PROC	; CvUnit::canMoveInto
EXTRN	?getNoRevealMapCount@CvUnit@@QBEHXZ:PROC	; CvUnit::getNoRevealMapCount
; Function compile flags: /Ogtpy
;	COMDAT ?UIPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
tv281 = 8						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?UIPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; UIPathValid, COMDAT

; 4624 : {

	push	ebp

; 4625 : 	if (parent == NULL)

	mov	ebp, DWORD PTR _parent$[esp]
	test	ebp, ebp
	jne	SHORT $LN12@UIPathVali

; 4626 : 	{
; 4627 : 		return TRUE;

	lea	eax, DWORD PTR [ebp+1]
	pop	ebp

; 4696 : 	{
; 4697 : 		return FALSE;
; 4698 : 	}
; 4699 : 
; 4700 : 	return TRUE;
; 4701 : }

	ret	0
$LN12@UIPathVali:
	push	ebx

; 4628 : 	}
; 4629 : 
; 4630 : 	if(node->m_iData2 > 3)

	mov	ebx, DWORD PTR _node$[esp+4]
	cmp	DWORD PTR [ebx+16], 3
	jle	SHORT $LN11@UIPathVali
	pop	ebx

; 4631 : 	{
; 4632 : 		return FALSE;

	xor	eax, eax
	pop	ebp

; 4696 : 	{
; 4697 : 		return FALSE;
; 4698 : 	}
; 4699 : 
; 4700 : 	return TRUE;
; 4701 : }

	ret	0
$LN11@UIPathVali:

; 4633 : 	}
; 4634 : 
; 4635 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4636 : 	const CvPlot* pToPlot = node->m_pPlot;
; 4637 : #else
; 4638 : 	CvPlot* pToPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	movsx	ecx, WORD PTR [ebx+80]
	push	esi
	movsx	esi, WORD PTR [ebx+82]
	imul	esi, DWORD PTR [eax+4020]
	add	esi, ecx
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [eax+4068]
	push	edi

; 4639 : #endif
; 4640 : 
; 4641 : 	CvUnit* pUnit = ((CvUnit*)pointer);
; 4642 : 
; 4643 : 	if(!pToPlot->isRevealed(pUnit->getTeam()))

	mov	edi, DWORD PTR _pointer$[esp+12]
	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	DWORD PTR tv281[esp+12], ecx
	mov	ecx, eax
	mov	eax, DWORD PTR tv281[esp+12]
	sub	ecx, eax
	mov	eax, 1
	shl	eax, cl
	test	eax, DWORD PTR [esi+edx*4+8]
	jne	SHORT $LN9@UIPathVali

; 4644 : 	{
; 4645 : 		if(pUnit->getNoRevealMapCount() > 0)

	mov	ecx, edi
	call	?getNoRevealMapCount@CvUnit@@QBEHXZ	; CvUnit::getNoRevealMapCount
	test	eax, eax

; 4646 : 		{
; 4647 : 			return FALSE;

	jg	SHORT $LN37@UIPathVali
$LN9@UIPathVali:

; 4648 : 		}
; 4649 : 	}
; 4650 : 
; 4651 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 4652 : 	if(pToPlot->isVisible(pUnit->getTeam()) && pToPlot->isVisibleEnemyUnit(pUnit))

	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, -1
	je	SHORT $LN7@UIPathVali
	mov	ecx, DWORD PTR [esi+156]
	cmp	WORD PTR [ecx+eax*2], 0
	setg	al
	test	al, al
	je	SHORT $LN7@UIPathVali
	push	edi
	mov	ecx, esi
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	test	al, al
	je	SHORT $LN7@UIPathVali

; 4653 : 	{
; 4654 : 		if (!pUnit->canMoveInto(*pToPlot, CvUnit::MOVEFLAG_ATTACK))

	push	1
	push	esi
	mov	ecx, edi
	call	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveInto
	test	al, al

; 4655 : 			return FALSE;

	je	SHORT $LN37@UIPathVali
$LN7@UIPathVali:

; 4656 : 	}
; 4657 : #endif
; 4658 : 
; 4659 : 	if(pUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN3@UIPathVali

; 4660 : 	{
; 4661 : 		int iGroupAreaID = pUnit->getArea();

	mov	ecx, edi
	call	?getArea@CvUnit@@QBEHXZ			; CvUnit::getArea

; 4662 : 		if(pToPlot->getArea() != iGroupAreaID)

	cmp	DWORD PTR [esi+356], eax
	je	SHORT $LN3@UIPathVali

; 4663 : 		{
; 4664 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 4665 : 			if (!pUnit->canMoveAllTerrain() && !pUnit->IsHoveringUnit() && !pToPlot->isAdjacentToArea(iGroupAreaID))
; 4666 : #else
; 4667 : 			if(!(pToPlot->isAdjacentToArea(iGroupAreaID)))

	push	eax
	mov	ecx, esi
	call	?isAdjacentToArea@CvPlot@@QBE_NH@Z	; CvPlot::isAdjacentToArea
	test	al, al
	jne	SHORT $LN3@UIPathVali

; 4668 : #endif
; 4669 : 			{
; 4670 : 				// antonjs: Added for Smoky Skies scenario. Allows move range to show correctly for airships,
; 4671 : 				// which move over land and sea plots equally (canMoveAllTerrain)
; 4672 : #ifndef AUI_UNIT_FIX_HOVERING_EMBARK		
; 4673 : 				if (!pUnit->canMoveAllTerrain())

	mov	ecx, edi
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	test	al, al

; 4674 : #endif
; 4675 : 				{
; 4676 : 					return FALSE;

	je	SHORT $LN37@UIPathVali
$LN3@UIPathVali:

; 4677 : 				}
; 4678 : 			}
; 4679 : 		}
; 4680 : 	}
; 4681 : 
; 4682 : 	if(!pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_ATTACK))

	push	1
	push	esi
	mov	ecx, edi
	call	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canEnterTerrain
	test	al, al
	jne	SHORT $LN2@UIPathVali
$LN37@UIPathVali:
	pop	edi
	pop	esi
	pop	ebx

; 4683 : 	{
; 4684 : 		return FALSE;

	xor	eax, eax
	pop	ebp

; 4696 : 	{
; 4697 : 		return FALSE;
; 4698 : 	}
; 4699 : 
; 4700 : 	return TRUE;
; 4701 : }

	ret	0
$LN2@UIPathVali:

; 4685 : 	}
; 4686 : 
; 4687 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 4688 : 	if (pToPlot->isVisible(pUnit->getTeam()) && pToPlot->isVisibleEnemyUnit(pUnit))
; 4689 : 	{
; 4690 : 		if (!pUnit->canMoveInto(*pToPlot, CvUnit::MOVEFLAG_ATTACK, true, true))
; 4691 : 			return FALSE;
; 4692 : 	}
; 4693 : #endif
; 4694 : 
; 4695 : 	if(!PathValid(parent,node,data,pointer,finder))

	mov	edx, DWORD PTR _finder$[esp+12]
	mov	eax, DWORD PTR _data$[esp+12]
	push	edx
	push	edi
	push	eax
	push	ebx
	push	ebp
	call	?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathValid
	add	esp, 20					; 00000014H
	pop	edi
	neg	eax
	pop	esi
	sbb	eax, eax
	pop	ebx
	neg	eax
	pop	ebp

; 4696 : 	{
; 4697 : 		return FALSE;
; 4698 : 	}
; 4699 : 
; 4700 : 	return TRUE;
; 4701 : }

	ret	0
?UIPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; UIPathValid
_TEXT	ENDS
PUBLIC	?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; UIPathAdd
EXTRN	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z:PROC ; CvGlobals::WrapPlotPointer
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z$1
__ehfuncinfo$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
xdata$x	ENDS
;	COMDAT ?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_pDllPlot$220769 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_parent$ = 8						; size = 4
$T226373 = 12						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; UIPathAdd, COMDAT

; 4706 : {

	push	-1
	push	__ehhandler$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 4707 : 	PathAdd(parent, node, data, pointer, finder);

	mov	eax, DWORD PTR _finder$[esp+12]
	mov	ecx, DWORD PTR _pointer$[esp+12]
	mov	edx, DWORD PTR _data$[esp+12]
	push	esi
	mov	esi, DWORD PTR _node$[esp+16]
	push	eax
	mov	eax, DWORD PTR _parent$[esp+20]
	push	ecx
	push	edx
	push	esi
	push	eax
	call	?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathAdd
	add	esp, 20					; 00000014H

; 4708 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 4709 : 	if(node)

	test	esi, esi
	je	$LN65@UIPathAdd

; 4710 : #endif
; 4711 : 	{
; 4712 : 		if(node->m_iData2 < 2 /*&& node->m_eCvAStarListType == NO_CVASTARLIST*/)

	cmp	DWORD PTR [esi+16], 2
	jge	$LN65@UIPathAdd

; 4713 : 		{
; 4714 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4715 : 			CvPlot* pPlot = node->m_pPlot;
; 4716 : #else
; 4717 : 			CvPlot* pPlot = GC.getMap().plot(node->m_iX, node->m_iY);

	movsx	eax, WORD PTR [esi+80]
	push	ebx
	movsx	ebx, WORD PTR [esi+82]
	cmp	eax, -2147483647			; 80000001H
	je	$LN71@UIPathAdd
	cmp	ebx, -2147483647			; 80000001H
	je	$LN71@UIPathAdd
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	dl, dl
	je	SHORT $LN20@UIPathAdd
	test	eax, eax
	jge	SHORT $LN22@UIPathAdd
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN24@UIPathAdd
$LN22@UIPathAdd:
	cmp	eax, ecx
	jl	SHORT $LN20@UIPathAdd
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN24@UIPathAdd
$LN20@UIPathAdd:
	mov	esi, eax
$LN24@UIPathAdd:
	mov	al, BYTE PTR [ebp+4057]
	push	edi
	mov	edi, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN69@UIPathAdd
	test	ebx, ebx
	jge	SHORT $LN32@UIPathAdd
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN34@UIPathAdd
$LN32@UIPathAdd:
	cmp	ebx, edi
	jl	SHORT $LN69@UIPathAdd
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN34@UIPathAdd
$LN69@UIPathAdd:
	mov	edx, ebx
$LN34@UIPathAdd:
	test	esi, esi
	jl	SHORT $LN73@UIPathAdd
	cmp	esi, ecx
	jge	SHORT $LN73@UIPathAdd
	test	edx, edx
	jl	SHORT $LN73@UIPathAdd
	cmp	edx, edi
	jge	SHORT $LN73@UIPathAdd
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]

; 4718 : #endif
; 4719 : 			if(pPlot)

	test	ecx, ecx
	je	SHORT $LN73@UIPathAdd

; 4720 : 			{
; 4721 : 				auto_ptr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(pPlot);

	push	ecx
	lea	ecx, DWORD PTR $T226373[esp+32]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pDllPlot$220769[esp+32], esi
	mov	eax, DWORD PTR $T226373[esp+28]
	mov	DWORD PTR __$EHRec$[esp+40], 0
	test	eax, eax
	je	SHORT $LN56@UIPathAdd
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN56@UIPathAdd:

; 4722 : 				GC.GetEngineUserInterface()->AddHexToUIRange(pDllPlot.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+444]
	push	esi
	call	eax

; 4723 : 			}

	mov	DWORD PTR __$EHRec$[esp+40], -1
	test	esi, esi
	je	SHORT $LN73@UIPathAdd
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	call	edx
$LN73@UIPathAdd:
	pop	edi
	pop	ebp
$LN71@UIPathAdd:
	pop	ebx
$LN65@UIPathAdd:

; 4724 : 		}
; 4725 : 	}
; 4726 : 
; 4727 : 	return 1;
; 4728 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z$1:
	lea	ecx, DWORD PTR _pDllPlot$220769[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__ehhandler$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; UIPathAdd
PUBLIC	?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; AttackPathAdd
EXTRN	?UnwrapUnitPointer@CvGlobals@@QAEPAVCvUnit@@PAVICvUnit1@@@Z:PROC ; CvGlobals::UnwrapUnitPointer
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z$2
__ehfuncinfo$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
xdata$x	ENDS
;	COMDAT ?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_pDllUnit$220845 = -20					; size = 4
_pDllPlot$220860 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_parent$ = 8						; size = 4
$T226549 = 12						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; AttackPathAdd, COMDAT

; 4732 : {

	mov	eax, DWORD PTR fs:0

; 4733 : 	PathAdd(parent, node, data, pointer, finder);

	mov	ecx, DWORD PTR _pointer$[esp-4]
	mov	edx, DWORD PTR _data$[esp-4]
	push	-1
	push	__ehhandler$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
	push	eax
	mov	eax, DWORD PTR _finder$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	mov	esi, DWORD PTR _node$[esp+20]
	push	eax
	mov	eax, DWORD PTR _parent$[esp+24]
	push	ecx
	push	edx
	push	esi
	push	eax
	call	?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathAdd
	add	esp, 20					; 00000014H

; 4734 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4735 : 	if (node->m_iData2 < 2)
; 4736 : #else
; 4737 : 	if(node && node->m_iData2 < 2)

	test	esi, esi
	je	$LN83@AttackPath
	cmp	DWORD PTR [esi+16], 2
	jge	$LN83@AttackPath

; 4738 : #endif
; 4739 : 	{
; 4740 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4741 : 		CvPlot* pPlot = node->m_pPlot;
; 4742 : #else
; 4743 : 		CvPlot* pPlot = GC.getMap().plot(node->m_iX, node->m_iY);

	movsx	eax, WORD PTR [esi+80]
	push	ebx
	push	ebp
	movsx	ebp, WORD PTR [esi+82]
	push	edi
	cmp	eax, -2147483647			; 80000001H
	je	$LN12@AttackPath
	cmp	ebp, -2147483647			; 80000001H
	je	SHORT $LN12@AttackPath
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN22@AttackPath
	test	eax, eax
	jge	SHORT $LN24@AttackPath
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN26@AttackPath
$LN24@AttackPath:
	cmp	eax, ecx
	jl	SHORT $LN22@AttackPath
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN26@AttackPath
$LN22@AttackPath:
	mov	esi, eax
$LN26@AttackPath:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN85@AttackPath
	test	ebp, ebp
	jge	SHORT $LN34@AttackPath
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN36@AttackPath
$LN34@AttackPath:
	cmp	ebp, edi
	jl	SHORT $LN85@AttackPath
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN36@AttackPath
$LN85@AttackPath:
	mov	edx, ebp
$LN36@AttackPath:
	test	esi, esi
	jl	SHORT $LN12@AttackPath
	cmp	esi, ecx
	jge	SHORT $LN12@AttackPath
	test	edx, edx
	jl	SHORT $LN12@AttackPath
	cmp	edx, edi
	jge	SHORT $LN12@AttackPath
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	esi, ecx
	jmp	SHORT $LN14@AttackPath
$LN12@AttackPath:
	xor	esi, esi
$LN14@AttackPath:

; 4744 : #endif
; 4745 : 
; 4746 : 		auto_ptr<ICvUnit1> pDllUnit(GC.GetEngineUserInterface()->GetHeadSelectedUnit());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	mov	ebp, eax
	mov	DWORD PTR _pDllUnit$220845[esp+36], ebp

; 4747 : 		CvUnit* pUnit = GC.UnwrapUnitPointer(pDllUnit.get());

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+48], 0
	call	?UnwrapUnitPointer@CvGlobals@@QAEPAVCvUnit@@PAVICvUnit1@@@Z ; CvGlobals::UnwrapUnitPointer
	mov	edi, eax

; 4748 : 		CvAssertMsg(pUnit, "pUnit should be a value");
; 4749 : 
; 4750 : 		if(pUnit && pPlot)

	test	edi, edi
	je	$LN73@AttackPath
	test	esi, esi
	je	SHORT $LN73@AttackPath

; 4751 : 		{
; 4752 : 			if(pPlot->isVisible(pUnit->getTeam()) && (pPlot->isVisibleEnemyUnit(pUnit) || pPlot->isEnemyCity(*pUnit)))

	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, esi
	call	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isVisible
	test	al, al
	je	SHORT $LN73@AttackPath
	push	edi
	mov	ecx, esi
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	test	al, al
	jne	SHORT $LN1@AttackPath
	push	edi
	mov	ecx, esi
	call	?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z	; CvPlot::isEnemyCity
	test	al, al
	je	SHORT $LN73@AttackPath
$LN1@AttackPath:

; 4753 : 			{
; 4754 : 				auto_ptr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(pPlot);

	push	esi
	lea	ecx, DWORD PTR $T226549[esp+36]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pDllPlot$220860[esp+36], esi
	mov	eax, DWORD PTR $T226549[esp+32]
	mov	BYTE PTR __$EHRec$[esp+44], 1
	test	eax, eax
	je	SHORT $LN64@AttackPath
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN64@AttackPath:

; 4755 : 				GC.GetEngineUserInterface()->AddHexToUIRange(pDllPlot.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+444]
	push	esi
	call	eax

; 4756 : 			}

	mov	BYTE PTR __$EHRec$[esp+44], 0
	test	esi, esi
	je	SHORT $LN73@AttackPath
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	call	edx
$LN73@AttackPath:

; 4757 : 		}
; 4758 : 	}

	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	ebp, ebp
	je	SHORT $LN82@AttackPath
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ebp
	call	ecx
$LN82@AttackPath:
	pop	edi
	pop	ebp
	pop	ebx

; 4759 : 
; 4760 : 	return 1;

	mov	eax, 1
	pop	esi

; 4761 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
$LN83@AttackPath:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z$0:
	lea	ecx, DWORD PTR _pDllUnit$220845[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z$2:
	lea	ecx, DWORD PTR _pDllPlot$220860[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__ehhandler$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; AttackPathAdd
PUBLIC	?AttackPathDestEval@@YAHHHPBXPAVCvAStar@@_N2@Z	; AttackPathDestEval
EXTRN	?IsFortifiedThisTurn@CvUnit@@QBE_NXZ:PROC	; CvUnit::IsFortifiedThisTurn
EXTRN	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z:PROC ; CvPlot::getVisibleEnemyDefender
; Function compile flags: /Ogtpy
;	COMDAT ?AttackPathDestEval@@YAHHHPBXPAVCvAStar@@_N2@Z
_TEXT	SEGMENT
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
_bOnlyFortified$ = 24					; size = 1
_bOnlyCity$ = 28					; size = 1
?AttackPathDestEval@@YAHHHPBXPAVCvAStar@@_N2@Z PROC	; AttackPathDestEval, COMDAT

; 4770 : 	CvUnit* pUnit = ((CvUnit*)pointer);
; 4771 : 	CvAssertMsg(pUnit, "pUnit should be a value");
; 4772 : 	CvPlot* pPlot = GC.getMap().plot(iToX, iToY);

	mov	eax, DWORD PTR _iToX$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	eax, -2147483647			; 80000001H
	je	$LN14@AttackPath@2
	mov	ebx, DWORD PTR _iToY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	SHORT $LN14@AttackPath@2
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN64@AttackPath@2
	test	eax, eax
	jge	SHORT $LN26@AttackPath@2
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN28@AttackPath@2
$LN26@AttackPath@2:
	cmp	eax, ecx
	jl	SHORT $LN64@AttackPath@2
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN28@AttackPath@2
$LN64@AttackPath@2:
	mov	esi, eax
$LN28@AttackPath@2:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN65@AttackPath@2
	test	ebx, ebx
	jge	SHORT $LN36@AttackPath@2
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN38@AttackPath@2
$LN36@AttackPath@2:
	cmp	ebx, edi
	jl	SHORT $LN65@AttackPath@2
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN38@AttackPath@2
$LN65@AttackPath@2:
	mov	edx, ebx
$LN38@AttackPath@2:
	test	esi, esi
	jl	SHORT $LN14@AttackPath@2
	cmp	esi, ecx
	jge	SHORT $LN14@AttackPath@2
	test	edx, edx
	jl	SHORT $LN14@AttackPath@2
	cmp	edx, edi
	jge	SHORT $LN14@AttackPath@2
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	esi, ecx
	jmp	SHORT $LN16@AttackPath@2
$LN14@AttackPath@2:
	xor	esi, esi
$LN16@AttackPath@2:

; 4773 : 	CvAStarNode* pNode = finder->GetLastNode();

	mov	eax, DWORD PTR _finder$[esp+12]

; 4774 : 
; 4775 : 	if(pPlot->isVisible(pUnit->getTeam()) && (pPlot->isVisibleEnemyUnit(pUnit) || pPlot->isEnemyCity(*pUnit)) && pNode && pNode->m_iData2 < 2)

	mov	edi, DWORD PTR _pointer$[esp+12]
	mov	ebx, DWORD PTR [eax+96]
	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, -1
	je	$LN1@AttackPath@2
	mov	ecx, DWORD PTR [esi+156]
	cmp	WORD PTR [ecx+eax*2], 0
	setg	al
	test	al, al
	je	SHORT $LN1@AttackPath@2
	push	edi
	mov	ecx, esi
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	test	al, al
	jne	SHORT $LN8@AttackPath@2
	push	edi
	mov	ecx, esi
	call	?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z	; CvPlot::isEnemyCity
	test	al, al
	je	SHORT $LN1@AttackPath@2
$LN8@AttackPath@2:
	test	ebx, ebx
	je	SHORT $LN1@AttackPath@2
	cmp	DWORD PTR [ebx+16], 2
	jge	SHORT $LN1@AttackPath@2

; 4776 : 	{
; 4777 : 		if (pUnit->canMoveInto(*pPlot, CvUnit::MOVEFLAG_ATTACK))

	push	1
	push	esi
	mov	ecx, edi
	call	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveInto
	test	al, al
	je	SHORT $LN1@AttackPath@2

; 4778 : 		{
; 4779 : 			if(bOnlyFortified)

	cmp	BYTE PTR _bOnlyFortified$[esp+12], 0
	je	SHORT $LN6@AttackPath@2

; 4780 : 			{
; 4781 : 				CvUnit* pEnemyUnit = pPlot->getVisibleEnemyDefender(pUnit->getOwner());

	mov	edi, DWORD PTR [edi+40]
	push	edi
	mov	ecx, esi
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender

; 4782 : 				if(pEnemyUnit && pEnemyUnit->IsFortifiedThisTurn())

	test	eax, eax
	je	SHORT $LN1@AttackPath@2
	mov	ecx, eax
	call	?IsFortifiedThisTurn@CvUnit@@QBE_NXZ	; CvUnit::IsFortifiedThisTurn
	test	al, al
	je	SHORT $LN1@AttackPath@2
$LN3@AttackPath@2:
	pop	edi
	pop	esi
	pop	ebp

; 4783 : 				{
; 4784 : 					return TRUE;

	mov	eax, 1
	pop	ebx

; 4802 : }

	ret	0
$LN6@AttackPath@2:

; 4785 : 				}
; 4786 : 			}
; 4787 : 			else if(bOnlyCity)

	cmp	BYTE PTR _bOnlyCity$[esp+12], 0
	je	SHORT $LN3@AttackPath@2

; 4788 : 			{
; 4789 : 				if(pPlot->isEnemyCity(*pUnit))

	push	edi
	mov	ecx, esi
	call	?isEnemyCity@CvPlot@@QBE_NABVCvUnit@@@Z	; CvPlot::isEnemyCity
	test	al, al
	je	SHORT $LN1@AttackPath@2
	pop	edi
	pop	esi
	pop	ebp

; 4790 : 				{
; 4791 : 					return TRUE;

	mov	eax, 1
	pop	ebx

; 4802 : }

	ret	0
$LN1@AttackPath@2:
	pop	edi
	pop	esi
	pop	ebp

; 4792 : 				}
; 4793 : 			}
; 4794 : 			else
; 4795 : 			{
; 4796 : 				return TRUE;
; 4797 : 			}
; 4798 : 		}
; 4799 : 	}
; 4800 : 
; 4801 : 	return FALSE;

	xor	eax, eax
	pop	ebx

; 4802 : }

	ret	0
?AttackPathDestEval@@YAHHHPBXPAVCvAStar@@_N2@Z ENDP	; AttackPathDestEval
_TEXT	ENDS
PUBLIC	?AttackPathDest@@YAHHHPBXPAVCvAStar@@@Z		; AttackPathDest
; Function compile flags: /Ogtpy
;	COMDAT ?AttackPathDest@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?AttackPathDest@@YAHHHPBXPAVCvAStar@@@Z PROC		; AttackPathDest, COMDAT

; 4812 : 	return AttackPathDestEval(iToX, iToY, pointer, finder, false, false);

	mov	eax, DWORD PTR _finder$[esp-4]
	mov	ecx, DWORD PTR _pointer$[esp-4]
	mov	edx, DWORD PTR _iToY$[esp-4]
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR _iToX$[esp+8]
	push	ecx
	push	edx
	push	eax
	call	?AttackPathDestEval@@YAHHHPBXPAVCvAStar@@_N2@Z ; AttackPathDestEval
	add	esp, 24					; 00000018H

; 4813 : }

	ret	0
?AttackPathDest@@YAHHHPBXPAVCvAStar@@@Z ENDP		; AttackPathDest
_TEXT	ENDS
PUBLIC	?AttackFortifiedPathDest@@YAHHHPBXPAVCvAStar@@@Z ; AttackFortifiedPathDest
; Function compile flags: /Ogtpy
;	COMDAT ?AttackFortifiedPathDest@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?AttackFortifiedPathDest@@YAHHHPBXPAVCvAStar@@@Z PROC	; AttackFortifiedPathDest, COMDAT

; 4823 : 	return AttackPathDestEval(iToX, iToY, pointer, finder, true, false);

	mov	eax, DWORD PTR _finder$[esp-4]
	mov	ecx, DWORD PTR _pointer$[esp-4]
	mov	edx, DWORD PTR _iToY$[esp-4]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR _iToX$[esp+8]
	push	ecx
	push	edx
	push	eax
	call	?AttackPathDestEval@@YAHHHPBXPAVCvAStar@@_N2@Z ; AttackPathDestEval
	add	esp, 24					; 00000018H

; 4824 : }

	ret	0
?AttackFortifiedPathDest@@YAHHHPBXPAVCvAStar@@@Z ENDP	; AttackFortifiedPathDest
_TEXT	ENDS
PUBLIC	?AttackCityPathDest@@YAHHHPBXPAVCvAStar@@@Z	; AttackCityPathDest
; Function compile flags: /Ogtpy
;	COMDAT ?AttackCityPathDest@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?AttackCityPathDest@@YAHHHPBXPAVCvAStar@@@Z PROC	; AttackCityPathDest, COMDAT

; 4834 : 	return AttackPathDestEval(iToX, iToY, pointer, finder, false, true);

	mov	eax, DWORD PTR _finder$[esp-4]
	mov	ecx, DWORD PTR _pointer$[esp-4]
	mov	edx, DWORD PTR _iToY$[esp-4]
	push	1
	push	0
	push	eax
	mov	eax, DWORD PTR _iToX$[esp+8]
	push	ecx
	push	edx
	push	eax
	call	?AttackPathDestEval@@YAHHHPBXPAVCvAStar@@_N2@Z ; AttackPathDestEval
	add	esp, 24					; 00000018H

; 4835 : }

	ret	0
?AttackCityPathDest@@YAHHHPBXPAVCvAStar@@@Z ENDP	; AttackCityPathDest
_TEXT	ENDS
PUBLIC	?TacticalAnalysisMapPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TacticalAnalysisMapPathValid
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ:PROC ; CvGame::GetTacticalAnalysisMap
; Function compile flags: /Ogtpy
;	COMDAT ?TacticalAnalysisMapPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_bFirstRun$ = -68					; size = 1
_bFromPlotOwned$ = -67					; size = 1
_bIsHuman$ = -66					; size = 1
_bAIControl$ = -65					; size = 1
_iNumTurns$ = -64					; size = 4
_iFinderIgnoreStacking$ = -60				; size = 4
_eUnitTeam$ = -56					; size = 4
_iNodeY$ = -52						; size = 4
_eFromPlotTeam$ = -48					; size = 4
_iNodeX$ = -44						; size = 4
_iUnitPlotLimit$ = -40					; size = 4
_pUnitPlot$ = -36					; size = 4
_pTAMap$ = -36						; size = 4
_iFinderInfo$ = -32					; size = 4
_theMap$ = -32						; size = 4
_iDestX$ = -28						; size = 4
_iDestY$ = -24						; size = 4
_iUnitX$ = -20						; size = 4
_iUnitY$ = -16						; size = 4
tv893 = -12						; size = 4
_unit_domain_type$ = -8					; size = 4
$T226896 = -8						; size = 8
_parent$ = 8						; size = 4
_bPreviousNodeHostile$ = 12				; size = 1
_unit_owner$ = 12					; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?TacticalAnalysisMapPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; TacticalAnalysisMapPathValid, COMDAT

; 4839 : {

	sub	esp, 68					; 00000044H

; 4840 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4841 : 	CvPlot* pToPlot = node->m_pPlot;
; 4842 : 	if (!pToPlot)
; 4843 : 		return FALSE;
; 4844 : #else
; 4845 : 	CvMap& theMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	ebp
	push	esi

; 4846 : 
; 4847 : 	CvPlot* pToPlot = theMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	esi, DWORD PTR _node$[esp+76]
	movsx	ebx, WORD PTR [esi+82]
	imul	ebx, DWORD PTR [eax+4020]
	movsx	ecx, WORD PTR [esi+80]
	add	ebx, ecx

; 4848 : #endif
; 4849 : 	PREFETCH_FASTAR_CVPLOT(reinterpret_cast<char*>(pToPlot));
; 4850 : 
; 4851 : 	CvUnit* pUnit = ((CvUnit *)pointer);
; 4852 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());

	mov	ecx, DWORD PTR _finder$[esp+76]
	imul	ebx, 484				; 000001e4H
	add	ebx, DWORD PTR [eax+4068]

; 4853 : 
; 4854 : 	TeamTypes eUnitTeam = pCacheData->getTeam();
; 4855 : 	PlayerTypes unit_owner = pCacheData->getOwner();

	mov	edx, DWORD PTR [ecx+140]
	prefetcht0 BYTE PTR [ebx]
	prefetcht0 BYTE PTR [ebx+64]
	mov	DWORD PTR _theMap$[esp+80], eax
	mov	eax, DWORD PTR [ecx+144]
	push	edi
	mov	DWORD PTR _eUnitTeam$[esp+84], eax
	mov	DWORD PTR _unit_owner$[esp+80], edx

; 4856 : 	CvAssertMsg(eUnitTeam != NO_TEAM, "The unit's team should be a vaild value");
; 4857 : 	if (eUnitTeam == NO_TEAM)

	cmp	eax, -1
	jne	SHORT $LN49@TacticalAn

; 4858 : 	{
; 4859 : 		eUnitTeam = GC.getGame().getActiveTeam();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR _eUnitTeam$[esp+84], eax
$LN49@TacticalAn:

; 4860 : 	}
; 4861 : 
; 4862 : 	CvTeam& kUnitTeam = GET_TEAM(eUnitTeam);

	mov	ebp, DWORD PTR _eUnitTeam$[esp+84]

; 4863 : 
; 4864 : 	CvTacticalAnalysisMap* pTAMap = GC.getGame().GetTacticalAnalysisMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	imul	ebp, 2980				; 00000ba4H
	add	ebp, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	edi, eax

; 4865 : 	FAssert(pTAMap != NULL);
; 4866 : 	CvTacticalAnalysisCell* pToPlotCell = pTAMap->GetCell(pToPlot->GetPlotIndex());

	mov	ecx, ebx
	mov	DWORD PTR _pTAMap$[esp+84], edi
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [edi+12]

; 4867 : 	FAssert(pToPlotCell != NULL);
; 4868 : 
; 4869 : #ifdef AUI_ASTAR_FIX_PARENT_NODE_ALWAYS_VALID_OPTIMIZATION
; 4870 : 	// If this is the first node in the path, it is always valid (starting location)
; 4871 : 	if (parent == NULL)
; 4872 : 	{
; 4873 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 4874 : 		// Cache values for this node that we will use in the loop
; 4875 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4876 : 		CvAStarNode& kToNodeCacheData = *node;
; 4877 : #else
; 4878 : 		CvPathNodeCacheData& kToNodeCacheData = node->m_kCostCacheData;
; 4879 : #endif
; 4880 : 		if (!kToNodeCacheData.bIsCalculated)
; 4881 : 		{
; 4882 : 			kToNodeCacheData.bIsCalculated = true;
; 4883 : 			kToNodeCacheData.bPlotVisibleToTeam = true;
; 4884 : 			kToNodeCacheData.iNumFriendlyUnitsOfType = pToPlot->getNumFriendlyUnitsOfType(pUnit);
; 4885 : 			kToNodeCacheData.bIsMountain = pToPlot->isMountain();
; 4886 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 4887 : 			kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 4888 : 			if (pUnit->IsHoveringUnit())
; 4889 : 				kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 4890 : 			else
; 4891 : 				kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 4892 : #else
; 4893 : 			kToNodeCacheData.bIsWater = pToPlotCell->IsWater();
; 4894 : #endif
; 4895 : 			kToNodeCacheData.bCanEnterTerrain = true;
; 4896 : 			kToNodeCacheData.bIsRevealedToTeam = true;
; 4897 : 			kToNodeCacheData.bContainsOtherFriendlyTeamCity = false;
; 4898 : 			CvCity* pCity = pToPlot->getPlotCity();
; 4899 : 			if (pCity)
; 4900 : 			{
; 4901 : 				if (unit_owner != pCity->getOwner() && !kUnitTeam.isAtWar(pCity->getTeam()))
; 4902 : 					kToNodeCacheData.bContainsOtherFriendlyTeamCity = true;
; 4903 : 			}
; 4904 : 			kToNodeCacheData.bContainsEnemyCity = pToPlot->isEnemyCity(*pUnit);
; 4905 : 			if (kToNodeCacheData.bPlotVisibleToTeam)
; 4906 : 			{
; 4907 : 				kToNodeCacheData.bContainsVisibleEnemy = pToPlotCell->GetEnemyMilitaryUnit() != NULL;
; 4908 : 				kToNodeCacheData.bContainsVisibleEnemyDefender = pToPlot->getBestDefender(NO_PLAYER, unit_owner, pUnit).pointer() != NULL;
; 4909 : 			}
; 4910 : 			else
; 4911 : 			{
; 4912 : 				kToNodeCacheData.bContainsVisibleEnemy = false;
; 4913 : 				kToNodeCacheData.bContainsVisibleEnemyDefender = false;
; 4914 : 			}
; 4915 : 		}
; 4916 : #endif
; 4917 : 		return TRUE;
; 4918 : 	}
; 4919 : #endif
; 4920 : 
; 4921 : 	// Cache the data for the node
; 4922 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4923 : 	CvAStarNode& kToNodeCacheData = *node;
; 4924 : #else
; 4925 : 	CvPathNodeCacheData& kToNodeCacheData = node->m_kCostCacheData;
; 4926 : #endif
; 4927 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 4928 : 	if (!kToNodeCacheData.bIsCalculated)
; 4929 : 	{
; 4930 : 		kToNodeCacheData.bPlotVisibleToTeam = pToPlotCell->IsVisible();
; 4931 : 		kToNodeCacheData.iNumFriendlyUnitsOfType = pToPlot->getNumFriendlyUnitsOfType(pUnit);
; 4932 : 		kToNodeCacheData.bIsMountain = pToPlot->isMountain();
; 4933 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 4934 : 		kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 4935 : 		if (pUnit->IsHoveringUnit())
; 4936 : 			kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 4937 : 		else
; 4938 : 			kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 4939 : #else
; 4940 : 		kToNodeCacheData.bIsWater = pToPlotCell->IsWater();
; 4941 : #endif
; 4942 : 		kToNodeCacheData.bIsRevealedToTeam = pToPlotCell->IsRevealed();
; 4943 : 		kToNodeCacheData.bContainsOtherFriendlyTeamCity = false;
; 4944 : 		if (pToPlotCell->IsCity())
; 4945 : 		{
; 4946 : 			CvCity* pCity = pToPlot->getPlotCity();
; 4947 : 			if (pCity)
; 4948 : 			{
; 4949 : 				if (unit_owner != pCity->getOwner() && !kUnitTeam.isAtWar(pCity->getTeam()))
; 4950 : 					kToNodeCacheData.bContainsOtherFriendlyTeamCity = true;
; 4951 : 			}
; 4952 : 		}
; 4953 : 		kToNodeCacheData.bContainsEnemyCity = pToPlotCell->IsEnemyCity();
; 4954 : 		if (kToNodeCacheData.bPlotVisibleToTeam)
; 4955 : 		{
; 4956 : 			kToNodeCacheData.bContainsVisibleEnemy = pToPlotCell->GetEnemyMilitaryUnit() != NULL;
; 4957 : 			kToNodeCacheData.bContainsVisibleEnemyDefender = pToPlot->getBestDefender(NO_PLAYER, unit_owner, pUnit).pointer() != NULL;
; 4958 : 		}
; 4959 : 		else
; 4960 : 		{
; 4961 : 			kToNodeCacheData.bContainsVisibleEnemy = false;
; 4962 : 			kToNodeCacheData.bContainsVisibleEnemyDefender = false;
; 4963 : 		}
; 4964 : 	}
; 4965 : #else
; 4966 : 	kToNodeCacheData.bPlotVisibleToTeam = pToPlotCell->IsVisible();
; 4967 : 	kToNodeCacheData.iNumFriendlyUnitsOfType = pToPlot->getNumFriendlyUnitsOfType(pUnit);

	mov	ecx, DWORD PTR _pointer$[esp+80]
	mov	edi, eax
	mov	eax, DWORD PTR [edi]
	shr	eax, 1
	xor	al, BYTE PTR [esi+88]
	push	1
	and	al, 1
	xor	BYTE PTR [esi+88], al
	push	ecx
	mov	ecx, ebx
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	mov	DWORD PTR [esi+92], eax

; 4968 : 	kToNodeCacheData.bIsMountain = pToPlot->isMountain();

	cmp	BYTE PTR [ebx+5], 0

; 4969 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 4970 : 	kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 4971 : 	if (pUnit->IsHoveringUnit())
; 4972 : 		kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 4973 : 	else
; 4974 : 		kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 4975 : #else
; 4976 : 	kToNodeCacheData.bIsWater = pToPlotCell->IsWater();
; 4977 : #endif
; 4978 : 	kToNodeCacheData.bCanEnterTerrain = pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE);

	push	128					; 00000080H
	sete	dl
	add	dl, dl
	xor	dl, BYTE PTR [esi+88]
	push	ebx
	and	dl, 2
	xor	BYTE PTR [esi+88], dl
	mov	ecx, DWORD PTR [edi]
	mov	al, BYTE PTR [esi+88]
	shr	ecx, 11					; 0000000bH
	add	cl, cl
	add	cl, cl
	xor	cl, al
	and	cl, 4
	xor	cl, al
	mov	BYTE PTR [esi+88], cl
	mov	ecx, DWORD PTR _pointer$[esp+88]
	call	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canEnterTerrain
	add	al, al
	add	al, al
	add	al, al
	xor	al, BYTE PTR [esi+88]
	and	al, 8
	xor	BYTE PTR [esi+88], al

; 4979 : 	kToNodeCacheData.bIsRevealedToTeam = pToPlotCell->IsRevealed();
; 4980 : 	kToNodeCacheData.bContainsOtherFriendlyTeamCity = false;

	mov	dl, BYTE PTR [edi]
	mov	al, BYTE PTR [esi+88]
	and	dl, 1
	and	al, 207					; 000000cfH
	shl	dl, 4
	or	dl, al
	mov	BYTE PTR [esi+88], dl

; 4981 : 	if(pToPlotCell->IsCity())

	mov	eax, DWORD PTR [edi]
	mov	ecx, eax
	shr	ecx, 8
	test	cl, 1
	jne	SHORT $LN91@TacticalAn
	mov	edx, eax
	shr	edx, 9
	test	dl, 1
	jne	SHORT $LN91@TacticalAn
	shr	eax, 10					; 0000000aH
	test	al, 1
	je	SHORT $LN46@TacticalAn
$LN91@TacticalAn:

; 4982 : 	{
; 4983 : 		CvCity* pCity = pToPlot->getPlotCity();

	mov	eax, DWORD PTR [ebx+104]
	test	eax, eax
	jl	SHORT $LN46@TacticalAn
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN46@TacticalAn
	mov	ecx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 4984 : 		if(pCity)

	test	eax, eax
	je	SHORT $LN46@TacticalAn

; 4985 : 		{
; 4986 : 			if(unit_owner != pCity->getOwner() && !kUnitTeam.isAtWar(pCity->getTeam()))

	mov	edx, DWORD PTR _unit_owner$[esp+80]
	cmp	edx, DWORD PTR [eax+84]
	je	SHORT $LN46@TacticalAn
	mov	ecx, eax
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, ebp
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	SHORT $LN46@TacticalAn

; 4987 : 				kToNodeCacheData.bContainsOtherFriendlyTeamCity = true;

	or	BYTE PTR [esi+88], 32			; 00000020H
$LN46@TacticalAn:

; 4988 : 		}
; 4989 : 	}
; 4990 : 	kToNodeCacheData.bContainsEnemyCity = pToPlotCell->IsEnemyCity();

	mov	eax, DWORD PTR [edi]

; 4991 : 	kToNodeCacheData.bContainsVisibleEnemy = pToPlotCell->GetEnemyMilitaryUnit() != NULL;
; 4992 : 	kToNodeCacheData.bContainsVisibleEnemyDefender = pToPlot->getBestDefender(NO_PLAYER, unit_owner, pUnit).pointer() != NULL;

	mov	edx, DWORD PTR _pointer$[esp+80]
	shr	eax, 9
	shl	al, 6
	xor	al, BYTE PTR [esi+88]
	push	0
	and	al, 64					; 00000040H
	xor	BYTE PTR [esi+88], al
	cmp	DWORD PTR [edi+4], 0
	mov	al, BYTE PTR [esi+88]
	push	0
	setne	cl
	push	0
	shl	cl, 7
	push	0
	and	al, 127					; 0000007fH
	or	cl, al
	mov	eax, DWORD PTR _unit_owner$[esp+96]
	push	edx
	push	eax
	mov	BYTE PTR [esi+88], cl
	push	-1
	lea	ecx, DWORD PTR $T226896[esp+112]
	push	ecx
	mov	ecx, ebx
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	cmp	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T226896[esp+84]
	setne	dl
	xor	dl, BYTE PTR [esi+89]
	and	dl, 1
	xor	BYTE PTR [esi+89], dl
	test	ecx, ecx
	je	SHORT $LN125@TacticalAn
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN125@TacticalAn:

; 4993 : #endif
; 4994 : 
; 4995 : #ifndef AUI_ASTAR_FIX_PARENT_NODE_ALWAYS_VALID_OPTIMIZATION
; 4996 : 	// If this is the first node in the path, it is always valid (starting location)
; 4997 : 	if (parent == NULL)

	cmp	DWORD PTR _parent$[esp+80], 0

; 4998 : 	{
; 4999 : 		return TRUE;

	je	$LN1@TacticalAn

; 5000 : 	}
; 5001 : #endif
; 5002 : 
; 5003 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5004 : 	CvPlot* pFromPlot = parent->m_pPlot;
; 5005 : 	if (!pFromPlot)
; 5006 : 		return FALSE;
; 5007 : #else
; 5008 : 	CvPlot* pFromPlot = theMap.plotUnchecked(parent->m_iX, parent->m_iY);

	mov	ecx, DWORD PTR _parent$[esp+80]
	movsx	edi, WORD PTR [ecx+82]
	mov	eax, DWORD PTR _theMap$[esp+84]
	imul	edi, DWORD PTR [eax+4020]
	movsx	ecx, WORD PTR [ecx+80]
	add	edi, ecx
	imul	edi, 484				; 000001e4H
	add	edi, DWORD PTR [eax+4068]

; 5009 : #endif
; 5010 : 	PREFETCH_FASTAR_CVPLOT(reinterpret_cast<char*>(pFromPlot));

	prefetcht0 BYTE PTR [edi]
	prefetcht0 BYTE PTR [edi+64]

; 5011 : 
; 5012 : 	CvTacticalAnalysisCell* pFromPlotCell = pTAMap->GetCell(pFromPlot->GetPlotIndex());

	mov	ecx, edi
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	imul	eax, 44					; 0000002cH
	mov	edx, DWORD PTR _pTAMap$[esp+84]
	add	eax, DWORD PTR [edx+12]

; 5013 : 	FAssert(pFromPlotCell != NULL);
; 5014 : 
; 5015 : 	bool bAIControl = pUnit->IsAutomated();

	mov	ecx, DWORD PTR _pointer$[esp+80]
	mov	ebp, eax
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated

; 5016 : 
; 5017 : 	// pulling invariants out of the loop
; 5018 : 	int iUnitX = pUnit->getX();

	mov	ecx, DWORD PTR _pointer$[esp+80]

; 5019 : 	int iUnitY = pUnit->getY();

	mov	edx, DWORD PTR [ecx+88]
	mov	BYTE PTR _bAIControl$[esp+84], al
	mov	eax, DWORD PTR [ecx+76]
	mov	DWORD PTR _iUnitX$[esp+84], eax

; 5020 : 	DomainTypes unit_domain_type = pCacheData->getDomainType();

	mov	eax, DWORD PTR _finder$[esp+80]
	mov	DWORD PTR _iUnitY$[esp+84], edx
	mov	edx, DWORD PTR [eax+148]
	mov	DWORD PTR _unit_domain_type$[esp+84], edx

; 5021 : 	bool bUnitIsCombat           = pUnit->IsCombatUnit();
; 5022 : 	bool bIsHuman				 = pCacheData->isHuman();

	mov	dl, BYTE PTR [eax+152]

; 5023 : 	int iFinderInfo              = finder->GetInfo();

	mov	eax, DWORD PTR [eax+72]
	mov	BYTE PTR _bIsHuman$[esp+84], dl
	mov	DWORD PTR _iFinderInfo$[esp+84], eax

; 5024 : 	CvPlot* pUnitPlot            = pUnit->plot();

	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 5025 : 	int iFinderIgnoreStacking    = iFinderInfo & MOVE_IGNORE_STACKING;
; 5026 : 	int iUnitPlotLimit           = GC.getPLOT_UNIT_LIMIT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7356
	mov	DWORD PTR _pUnitPlot$[esp+84], eax
	mov	eax, DWORD PTR _iFinderInfo$[esp+84]
	and	eax, 4
	mov	DWORD PTR _iFinderIgnoreStacking$[esp+84], eax

; 5027 : 	bool bFromPlotOwned          = !pFromPlotCell->IsUnclaimedTerritory();

	mov	al, BYTE PTR [ebp+2]
	not	al
	and	al, 1
	mov	BYTE PTR _bFromPlotOwned$[esp+84], al

; 5028 : 	TeamTypes eFromPlotTeam      = pFromPlot->getTeam();

	movsx	eax, BYTE PTR [edi+4]
	mov	DWORD PTR _iUnitPlotLimit$[esp+84], ecx
	cmp	eax, -1
	je	SHORT $LN160@TacticalAn
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN167@TacticalAn
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _eFromPlotTeam$[esp+84], eax
	jmp	SHORT $LN159@TacticalAn
$LN167@TacticalAn:
	or	eax, -1
	mov	DWORD PTR _eFromPlotTeam$[esp+84], eax
	jmp	SHORT $LN159@TacticalAn
$LN160@TacticalAn:
	mov	DWORD PTR _eFromPlotTeam$[esp+84], -1
$LN159@TacticalAn:

; 5029 : 
; 5030 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 5031 : 	if (!kToNodeCacheData.bIsCalculated)
; 5032 : 	{
; 5033 : 		if (bAIControl || !bIsHuman || kToNodeCacheData.bIsRevealedToTeam)
; 5034 : 			kToNodeCacheData.bCanEnterTerrain = pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE);
; 5035 : 		else
; 5036 : 			kToNodeCacheData.bCanEnterTerrain = true;
; 5037 : 		kToNodeCacheData.bIsCalculated = true;
; 5038 : 	}
; 5039 : #endif
; 5040 : 
; 5041 : 	// We have determined that this node is not the origin above (parent == NULL)
; 5042 : 	CvAStarNode* pNode = node;
; 5043 : 	bool bPreviousNodeHostile = false;
; 5044 : 	int iDestX = finder->GetDestX();

	mov	ecx, DWORD PTR _finder$[esp+80]
	mov	edx, DWORD PTR [ecx+64]

; 5045 : 	int iDestY = finder->GetDestY();

	mov	ecx, DWORD PTR [ecx+68]

; 5046 : 	int iNodeX = node->m_iX;

	movsx	ebp, WORD PTR [esi+80]
	mov	DWORD PTR _iDestX$[esp+84], edx

; 5047 : 	int iNodeY = node->m_iY;

	movsx	edx, WORD PTR [esi+82]
	mov	DWORD PTR _iDestY$[esp+84], ecx

; 5048 : 	int iOldNumTurns = -1;
; 5049 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 5050 : 	int iNumTurns;
; 5051 : #endif
; 5052 : 	TeamTypes eTeam = eUnitTeam; // this may get modified later is eTEam == NO_TEAM
; 5053 : 
; 5054 : 	// First run special case for checking "node" since it doesn't have a parent set yet
; 5055 : 	bool bFirstRun = true;
; 5056 : 
; 5057 : 	// Have to calculate this specially because the node passed into this function doesn't yet have data stored it in (hasn't reached pathAdd yet)
; 5058 : 	int iStartMoves = parent->m_iData1;
; 5059 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 5060 : 	int iNumTurns = parent->m_iData2;
; 5061 : #else
; 5062 : 	iNumTurns = parent->m_iData2;

	mov	ecx, DWORD PTR _parent$[esp+80]

; 5063 : #endif
; 5064 : #if defined(AUI_ASTAR_TURN_LIMITER)
; 5065 : 	int iMaxTurns = finder->GetMaxTurns();
; 5066 : #endif
; 5067 : 
; 5068 : 	if(iStartMoves == 0)

	cmp	DWORD PTR [ecx+12], 0
	mov	DWORD PTR _iNodeY$[esp+84], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, esi
	mov	BYTE PTR _bPreviousNodeHostile$[esp+80], 0
	mov	DWORD PTR _iNodeX$[esp+84], ebp
	mov	BYTE PTR _bFirstRun$[esp+84], 1
	mov	DWORD PTR _iNumTurns$[esp+84], edx
	jne	SHORT $LN188@TacticalAn

; 5069 : 	{
; 5070 : 		iNumTurns++;

	inc	DWORD PTR _iNumTurns$[esp+84]
$LN188@TacticalAn:

; 5071 : 	}
; 5072 : 
; 5073 : 	iOldNumTurns = -1;

	or	ecx, -1
$LL43@TacticalAn:

; 5074 : 
; 5075 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 5076 : 	CvAStarNode& kFromNodeCacheData = *parent;
; 5077 : #else
; 5078 : 	CvPlot* pPlot = NULL;
; 5079 : 
; 5080 : 	// Get a reference to the parent node cache data
; 5081 : 	CvPathNodeCacheData& kFromNodeCacheData = parent->m_kCostCacheData;
; 5082 : #endif
; 5083 : 
; 5084 : 	// Loop through the current path until we find the path origin.
; 5085 : 	// This validates the path with the inclusion of the new path node.  We must do this because of the rules of where a unit can finish a turn.
; 5086 : 	// Please note that this can be an expensive loop as the path gets longer and longer, do as little work as possible in validating each node.  
; 5087 : 	// If there is an invariant value that needs to be fetched from the plot or unit for the node, please do the calculation and put it in the node's data cache.
; 5088 : 	while(pNode != NULL)
; 5089 : 	{
; 5090 : #ifdef AUI_ASTAR_TURN_LIMITER
; 5091 : 		if (iNumTurns > iMaxTurns)
; 5092 : 		{
; 5093 : 			return FALSE; // Path is too long, terminate now
; 5094 : 		}
; 5095 : #endif
; 5096 : 
; 5097 : 		PREFETCH_FASTAR_NODE(pNode->m_pParent);

	mov	edx, DWORD PTR [eax+24]
	prefetcht0 BYTE PTR [edx]
	prefetcht0 BYTE PTR [edx+64]
	add	edx, 64					; 00000040H

; 5098 : 
; 5099 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 5100 : 		CvAStarNode& kNodeCacheData = *pNode;
; 5101 : #else
; 5102 : 		CvPathNodeCacheData& kNodeCacheData = pNode->m_kCostCacheData;
; 5103 : #endif
; 5104 : 		// This is a safeguard against the algorithm believing a plot to be impassable before actually knowing it (mid-search)
; 5105 : 		if(iOldNumTurns != -1 || (iDestX == iNodeX && iDestY == iNodeY))

	cmp	ecx, -1
	jne	SHORT $LN195@TacticalAn
	cmp	DWORD PTR _iDestX$[esp+84], ebp
	jne	$LN193@TacticalAn
	mov	edx, DWORD PTR _iDestY$[esp+84]
	cmp	edx, DWORD PTR _iNodeY$[esp+84]
	jne	$LN193@TacticalAn
	mov	ebp, DWORD PTR _iNodeX$[esp+84]
$LN195@TacticalAn:

; 5106 : 		{
; 5107 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 5108 : 			if (!kNodeCacheData.bCanEnterTerrain)	// since this gets cached for each node anyway during buildup, it should be used whereever possible
; 5109 : 			{
; 5110 : 				return FALSE;
; 5111 : 			}
; 5112 : #endif
; 5113 : 			// This plot is of greater distance than previously, so we know the unit is ending its turn here (pNode), or it's trying to attack through a unit (and might end up on this tile if an attack fails to kill the enemy)
; 5114 : 			if(iNumTurns != iOldNumTurns || bPreviousNodeHostile)

	cmp	DWORD PTR _iNumTurns$[esp+84], ecx
	jne	SHORT $LN38@TacticalAn
	cmp	BYTE PTR _bPreviousNodeHostile$[esp+80], 0
	je	$LN193@TacticalAn
$LN38@TacticalAn:

; 5115 : 			{
; 5116 : 				// Don't count origin, or else a unit will block its own movement!
; 5117 : 				if(iNodeX != iUnitX || iNodeY != iUnitY)

	cmp	ebp, DWORD PTR _iUnitX$[esp+84]
	jne	SHORT $LN36@TacticalAn
	mov	ecx, DWORD PTR _iNodeY$[esp+84]
	cmp	ecx, DWORD PTR _iUnitY$[esp+84]
	je	SHORT $LN193@TacticalAn
$LN36@TacticalAn:

; 5118 : 				{
; 5119 : 					// PREFETCH_FASTAR_CVPLOT(reinterpret_cast<char*>(pPlot));
; 5120 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 5121 : 					if (kNodeCacheData.bIsRevealedToTeam)
; 5122 : #else
; 5123 : 					if(kNodeCacheData.bPlotVisibleToTeam)

	mov	cl, BYTE PTR [eax+88]
	test	cl, 1
	je	SHORT $LN197@TacticalAn

; 5124 : #endif
; 5125 : 					{
; 5126 : 						// Check to see if any units are present at this full-turn move plot... if the player can see what's there
; 5127 : 						if(kNodeCacheData.iNumFriendlyUnitsOfType >= iUnitPlotLimit && !(iFinderIgnoreStacking))

	mov	edx, DWORD PTR _iUnitPlotLimit$[esp+84]
	cmp	DWORD PTR [eax+92], edx
	jl	SHORT $LN34@TacticalAn
	cmp	DWORD PTR _iFinderIgnoreStacking$[esp+84], 0
	je	$LN181@TacticalAn
$LN34@TacticalAn:

; 5128 : 						{
; 5129 : 							return FALSE;
; 5130 : 						}
; 5131 : 
; 5132 : #ifndef AUI_ASTAR_FIX_PATH_VALID_PATH_PEAKS_FOR_NONHUMAN
; 5133 : 						if (kNodeCacheData.bIsMountain && !(iFinderIgnoreStacking) && (!bIsHuman || bAIControl))

	shr	cl, 1
	and	cl, 1
	je	SHORT $LN196@TacticalAn
	cmp	DWORD PTR _iFinderIgnoreStacking$[esp+84], 0
	jne	SHORT $LN196@TacticalAn
	cmp	BYTE PTR _bIsHuman$[esp+84], 0
	je	$LN181@TacticalAn
	cmp	BYTE PTR _bAIControl$[esp+84], 0
	jne	$LN181@TacticalAn
$LN196@TacticalAn:

; 5134 : 						{
; 5135 : 							return FALSE;
; 5136 : 						}
; 5137 : #endif
; 5138 : 
; 5139 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 5140 : 						if(kNodeCacheData.bIsMountain && !kNodeCacheData.bCanEnterTerrain)	// only doing canEnterTerrain on mountain plots because it is expensive, though it probably should always be called and some other checks in this loop could be removed.

	test	cl, cl
	je	SHORT $LN31@TacticalAn
	test	BYTE PTR [eax+88], 8
	je	$LN181@TacticalAn
$LN31@TacticalAn:

; 5141 : 						{
; 5142 : 							return FALSE;
; 5143 : 						}
; 5144 : #endif
; 5145 : 
; 5146 : 						if ((finder->GetInfo() & CvUnit::MOVEFLAG_STAY_ON_LAND) && kNodeCacheData.bIsWater)

	mov	ecx, DWORD PTR _finder$[esp+80]
	test	DWORD PTR [ecx+72], 256			; 00000100H
	je	SHORT $LN197@TacticalAn
	test	BYTE PTR [eax+88], 4
	jne	$LN181@TacticalAn
$LN197@TacticalAn:

; 5147 : 						{
; 5148 : 							return FALSE;
; 5149 : 						}
; 5150 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 5151 : 					}
; 5152 : 
; 5153 : 					if(kNodeCacheData.bIsRevealedToTeam)

	mov	cl, BYTE PTR [eax+88]
	test	cl, 16					; 00000010H
	je	SHORT $LN193@TacticalAn

; 5154 : 					{
; 5155 : #endif
; 5156 : 						if (kNodeCacheData.bContainsOtherFriendlyTeamCity && !(iFinderIgnoreStacking))

	test	cl, 32					; 00000020H
	je	SHORT $LN193@TacticalAn
	cmp	DWORD PTR _iFinderIgnoreStacking$[esp+84], 0
	je	$LN181@TacticalAn
$LN193@TacticalAn:

; 5157 : 							return FALSE;
; 5158 : 					}
; 5159 : 				}
; 5160 : 			}
; 5161 : 		}
; 5162 : 
; 5163 : 		bPreviousNodeHostile = false;
; 5164 : 		if(kNodeCacheData.bContainsEnemyCity)

	mov	cl, BYTE PTR [eax+88]
	mov	BYTE PTR _bPreviousNodeHostile$[esp+80], 0
	test	cl, 64					; 00000040H

; 5165 : 		{
; 5166 : 			bPreviousNodeHostile = true;

	jne	SHORT $LN199@TacticalAn

; 5167 : 		}
; 5168 : 		// Prevents units from passing through one another on its way to attack another unit
; 5169 : 		else if(kNodeCacheData.bContainsVisibleEnemy)

	test	cl, cl
	jns	SHORT $LN24@TacticalAn

; 5170 : 		{
; 5171 : 			// except when attacking an unguarded civilian unit
; 5172 : 			if(kNodeCacheData.bContainsVisibleEnemyDefender)

	test	BYTE PTR [eax+89], 1
	je	SHORT $LN24@TacticalAn
$LN199@TacticalAn:

; 5173 : 			{
; 5174 : 				bPreviousNodeHostile = true;

	mov	BYTE PTR _bPreviousNodeHostile$[esp+80], 1
$LN24@TacticalAn:

; 5175 : 			}
; 5176 : 		}
; 5177 : 
; 5178 : 		// JON - Special case for the original node passed into this function because it's not yet linked to any parent
; 5179 : 		if(pNode == node && bFirstRun)

	cmp	eax, esi
	jne	SHORT $LN23@TacticalAn
	cmp	BYTE PTR _bFirstRun$[esp+84], 0
	je	SHORT $LN23@TacticalAn

; 5180 : 		{
; 5181 : 			pNode = parent;

	mov	eax, DWORD PTR _parent$[esp+80]

; 5182 : 			bFirstRun = false;

	mov	BYTE PTR _bFirstRun$[esp+84], 0

; 5183 : 		}
; 5184 : 		else

	jmp	SHORT $LN22@TacticalAn
$LN23@TacticalAn:

; 5185 : 		{
; 5186 : 			pNode = pNode->m_pParent;

	mov	eax, DWORD PTR [eax+24]
$LN22@TacticalAn:

; 5187 : 		}
; 5188 : 
; 5189 : 		if(pNode != NULL)

	test	eax, eax
	je	SHORT $LN42@TacticalAn

; 5190 : 		{
; 5191 : 
; 5192 : 			iNodeX = pNode->m_iX;
; 5193 : 			iNodeY = pNode->m_iY;

	movsx	edx, WORD PTR [eax+82]
	movsx	ebp, WORD PTR [eax+80]

; 5194 : 			iOldNumTurns = iNumTurns;

	mov	ecx, DWORD PTR _iNumTurns$[esp+84]
	mov	DWORD PTR _iNodeY$[esp+84], edx

; 5195 : 			iNumTurns = pNode->m_iData2;

	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR _iNodeX$[esp+84], ebp
	mov	DWORD PTR _iNumTurns$[esp+84], edx
	jmp	$LL43@TacticalAn
$LN42@TacticalAn:

; 5196 : 		}
; 5197 : 	}
; 5198 : 
; 5199 : 	// slewis - moved this up so units can't move directly into the water. Not 100% sure this is the right solution.
; 5200 : 	if(unit_domain_type == DOMAIN_LAND)

	mov	eax, DWORD PTR _unit_domain_type$[esp+84]
	cmp	eax, 2
	jne	SHORT $LN18@TacticalAn

; 5201 : 	{
; 5202 : 		if(!kFromNodeCacheData.bIsWater && kToNodeCacheData.bIsWater && kToNodeCacheData.bIsRevealedToTeam && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))

	mov	eax, DWORD PTR _parent$[esp+80]
	test	BYTE PTR [eax+88], 4
	jne	SHORT $LN191@TacticalAn
	mov	al, BYTE PTR [esi+88]
	test	al, 4
	je	SHORT $LN191@TacticalAn
	test	al, 16					; 00000010H
	je	SHORT $LN191@TacticalAn
	mov	ebp, DWORD PTR _pointer$[esp+80]
	push	0
	push	1
	push	ebx
	push	edi
	mov	ecx, ebp
	call	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z ; CvUnit::canEmbarkOnto
	test	al, al
	jne	SHORT $LN187@TacticalAn

; 5203 : 		{
; 5204 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 5205 : 			if (!pUnit->canMoveAllTerrain())
; 5206 : #else
; 5207 : 			if(!pUnit->IsHoveringUnit() && !pUnit->canMoveAllTerrain() && !pToPlot->IsAllowsWalkWater())

	mov	ecx, ebp
	call	?IsHoveringUnit@CvUnit@@QBE_NXZ		; CvUnit::IsHoveringUnit
	test	al, al
	jne	SHORT $LN187@TacticalAn
	mov	ecx, ebp
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	test	al, al
	jne	SHORT $LN187@TacticalAn
	mov	ecx, ebx
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	test	al, al
	jne	SHORT $LN187@TacticalAn
$LN181@TacticalAn:
	pop	edi
	pop	esi
	pop	ebp

; 5208 : #endif
; 5209 : 			{
; 5210 : 				return FALSE;

	xor	eax, eax
	pop	ebx

; 5347 : }

	add	esp, 68					; 00000044H
	ret	0
$LN18@TacticalAn:

; 5211 : 			}
; 5212 : 		}
; 5213 : 	}
; 5214 : 
; 5215 : #ifndef AUI_ASTAR_FIX_RADAR
; 5216 : 	if(!bUnitIsCombat && unit_domain_type != DOMAIN_AIR)
; 5217 : 	{
; 5218 : 		const PlayerTypes eUnitPlayer = unit_owner;
; 5219 : 		const int iUnitCount = pToPlot->getNumUnits();
; 5220 : 		for(int iUnit = 0; iUnit < iUnitCount; ++iUnit)
; 5221 : 		{
; 5222 : 			const CvUnit* pToPlotUnit = pToPlot->getUnitByIndex(iUnit);
; 5223 : 			if(pToPlotUnit != NULL && pToPlotUnit->getOwner() != eUnitPlayer)
; 5224 : 			{
; 5225 : 				return FALSE; // Plot occupied by another player
; 5226 : 			}
; 5227 : 		}
; 5228 : 	}
; 5229 : #endif
; 5230 : 
; 5231 : 	// slewis - Added to catch when the unit is adjacent to an enemy unit while it is stacked with a friendly unit.
; 5232 : 	//          The logic above (with bPreviousNodeHostile) catches this problem with a path that's longer than one step
; 5233 : 	//          but does not catch when the path is only one step.
; 5234 : #ifdef AUI_ASTAR_FIX_RADAR
; 5235 : 	if (unit_domain_type != DOMAIN_AIR && pUnitPlot->isAdjacent(pToPlot) && kToNodeCacheData.bContainsVisibleEnemy && !(iFinderIgnoreStacking))

	cmp	eax, 1
	je	SHORT $LN192@TacticalAn
$LN191@TacticalAn:
	mov	ebp, DWORD PTR _pointer$[esp+80]
$LN187@TacticalAn:
	push	ebx
	mov	ebx, DWORD PTR _pUnitPlot$[esp+88]
	mov	ecx, ebx
	call	?isAdjacent@CvPlot@@QBE_NPBV1@@Z	; CvPlot::isAdjacent
	test	al, al
	je	SHORT $LN15@TacticalAn
	test	BYTE PTR [esi+88], 128			; 00000080H
	je	SHORT $LN15@TacticalAn
	cmp	DWORD PTR _iFinderIgnoreStacking$[esp+84], 0
	jne	SHORT $LN15@TacticalAn

; 5236 : #else
; 5237 : 	if(bUnitIsCombat && unit_domain_type != DOMAIN_AIR && pUnitPlot->isAdjacent(pToPlot) && kToNodeCacheData.bContainsVisibleEnemy && !(iFinderIgnoreStacking))
; 5238 : #endif
; 5239 : 	{
; 5240 : 		if(kToNodeCacheData.bContainsVisibleEnemyDefender)

	test	BYTE PTR [esi+89], 1
	je	SHORT $LN15@TacticalAn

; 5241 : 		{
; 5242 : 			if(pUnitPlot->getNumFriendlyUnitsOfType(pUnit) > iUnitPlotLimit)

	push	1
	push	ebp
	mov	ecx, ebx
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	cmp	eax, DWORD PTR _iUnitPlotLimit$[esp+84]
	jle	SHORT $LN15@TacticalAn
	pop	edi
	pop	esi
	pop	ebp

; 5243 : 			{
; 5244 : 				return FALSE;

	xor	eax, eax
	pop	ebx

; 5347 : }

	add	esp, 68					; 00000044H
	ret	0
$LN192@TacticalAn:

; 5241 : 		{
; 5242 : 			if(pUnitPlot->getNumFriendlyUnitsOfType(pUnit) > iUnitPlotLimit)

	mov	ebp, DWORD PTR _pointer$[esp+80]
	mov	ebx, DWORD PTR _pUnitPlot$[esp+84]
$LN15@TacticalAn:

; 5245 : 			}
; 5246 : 		}
; 5247 : 	}
; 5248 : 
; 5249 : 	if(pUnitPlot == pFromPlot)

	cmp	ebx, edi

; 5250 : 	{
; 5251 : 		return TRUE;

	je	$LN1@TacticalAn

; 5252 : 	}
; 5253 : 
; 5254 : 	if(iFinderInfo & MOVE_TERRITORY_NO_UNEXPLORED)

	mov	bl, BYTE PTR _iFinderInfo$[esp+84]
	test	bl, 1
	je	SHORT $LN189@TacticalAn

; 5255 : 	{
; 5256 : 		if(!kFromNodeCacheData.bIsRevealedToTeam)

	mov	ecx, DWORD PTR _parent$[esp+80]
	test	BYTE PTR [ecx+88], 16			; 00000010H

; 5257 : 		{
; 5258 : 			return FALSE;

	je	SHORT $LN181@TacticalAn

; 5259 : 		}
; 5260 : 
; 5261 : 		if(bFromPlotOwned)

	cmp	BYTE PTR _bFromPlotOwned$[esp+84], 0
	je	SHORT $LN189@TacticalAn

; 5262 : 		{
; 5263 : 			if(eFromPlotTeam != eUnitTeam)

	mov	edx, DWORD PTR _eFromPlotTeam$[esp+84]
	cmp	edx, DWORD PTR _eUnitTeam$[esp+84]

; 5264 : 			{
; 5265 : 				return FALSE;

	jne	$LN181@TacticalAn
$LN189@TacticalAn:

; 5266 : 			}
; 5267 : 		}
; 5268 : 	}
; 5269 : 
; 5270 : 	if(iFinderInfo & MOVE_TERRITORY_NO_ENEMY)

	test	bl, 2
	je	SHORT $LN7@TacticalAn

; 5271 : 	{
; 5272 : 		if(bFromPlotOwned)

	cmp	BYTE PTR _bFromPlotOwned$[esp+84], 0
	je	SHORT $LN7@TacticalAn

; 5273 : 		{
; 5274 : 			if(atWar(eFromPlotTeam, eUnitTeam))

	mov	eax, DWORD PTR _eUnitTeam$[esp+84]
	mov	ecx, DWORD PTR _eFromPlotTeam$[esp+84]
	push	eax
	push	ecx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al

; 5275 : 			{
; 5276 : 				return FALSE;

	jne	$LN181@TacticalAn
$LN7@TacticalAn:

; 5277 : 			}
; 5278 : 		}
; 5279 : 	}
; 5280 : #ifndef ASTAR_AI_CONTROL_FIX_RADAR
; 5281 : 	if(bAIControl)
; 5282 : 	{
; 5283 : 		if((parent->m_iData2 > 1) || (parent->m_iData1 == 0))
; 5284 : 		{
; 5285 : 			if(!(iFinderInfo & MOVE_UNITS_IGNORE_DANGER))
; 5286 : 			{
; 5287 : 				if(!bUnitIsCombat || pUnit->getArmyID() == FFreeList::INVALID_INDEX)
; 5288 : 				{
; 5289 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_USES_TO_PLOT_NOT_FROM_PLOT
; 5290 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH
; 5291 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_ONLY_POSITIVE_DANGER_DELTA
; 5292 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pToPlot) > pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH &&
; 5293 : 						GET_PLAYER(unit_owner).GetPlotDanger(*pFromPlot) <= pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 5294 : #else
; 5295 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pToPlot) > pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 5296 : #endif
; 5297 : #elif defined(AUI_ASTAR_FIX_CONSIDER_DANGER_ONLY_POSITIVE_DANGER_DELTA)
; 5298 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pToPlot) > 0 && GET_PLAYER(pUnit->getOwner()).GetPlotDanger(*pFromPlot) <= 0)
; 5299 : #else
; 5300 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pToPlot) > 0)
; 5301 : #endif
; 5302 : #elif defined(AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 5303 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pFromPlot) > pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 5304 : #else
; 5305 : 					if(GET_PLAYER(unit_owner).GetPlotDanger(*pFromPlot) > 0)
; 5306 : #endif
; 5307 : 					{
; 5308 : 						return FALSE;
; 5309 : 					}
; 5310 : 				}
; 5311 : 			}
; 5312 : 		}
; 5313 : 	}
; 5314 : #endif
; 5315 : 	// slewis - added AI check and embark check to prevent units from moving into unexplored areas
; 5316 : #ifdef ASTAR_AI_CONTROL_FIX_RADAR
; 5317 : 	if(!bIsHuman || kFromNodeCacheData.bIsRevealedToTeam || pCacheData->isEmbarked())

	cmp	BYTE PTR _bIsHuman$[esp+84], 0
	je	SHORT $LN5@TacticalAn
	mov	edx, DWORD PTR _parent$[esp+80]
	test	BYTE PTR [edx+88], 16			; 00000010H
	jne	SHORT $LN5@TacticalAn
	mov	eax, DWORD PTR _finder$[esp+80]
	cmp	BYTE PTR [eax+157], 0
	je	SHORT $LN1@TacticalAn
$LN5@TacticalAn:

; 5318 : #else
; 5319 : 	if(bAIControl || !bIsHuman || kFromNodeCacheData.bIsRevealedToTeam || pCacheData->isEmbarked())
; 5320 : #endif
; 5321 : 	{
; 5322 : 		if(iFinderInfo & MOVE_UNITS_THROUGH_ENEMY)
; 5323 : 		{
; 5324 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 5325 : 			if (!(pUnit->canMoveOrAttackInto(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE, kFromNodeCacheData.bCanEnterTerrain, true)))
; 5326 : #else
; 5327 : 			if(!(pUnit->canMoveOrAttackInto(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE)))

	push	128					; 00000080H
	mov	ecx, ebp
	push	edi
	test	bl, 16					; 00000010H
	je	SHORT $LN4@TacticalAn
	call	?canMoveOrAttackInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveOrAttackInto
	test	al, al
	jne	SHORT $LN1@TacticalAn
	pop	edi
	pop	esi
	pop	ebp

; 5328 : #endif
; 5329 : 			{
; 5330 : 				return FALSE;

	xor	eax, eax
	pop	ebx

; 5347 : }

	add	esp, 68					; 00000044H
	ret	0
$LN4@TacticalAn:

; 5331 : 			}
; 5332 : 		}
; 5333 : 		else
; 5334 : 		{
; 5335 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 5336 : 			if (!(pUnit->canMoveThrough(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE, kFromNodeCacheData.bCanEnterTerrain, true)))
; 5337 : #else
; 5338 : 			if(!(pUnit->canMoveThrough(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE)))

	call	?canMoveThrough@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveThrough
	test	al, al

; 5339 : #endif
; 5340 : 			{
; 5341 : 				return FALSE;

	je	$LN181@TacticalAn
$LN1@TacticalAn:
	pop	edi
	pop	esi
	pop	ebp

; 5342 : 			}
; 5343 : 		}
; 5344 : 	}
; 5345 : 
; 5346 : 	return TRUE;

	mov	eax, 1
	pop	ebx

; 5347 : }

	add	esp, 68					; 00000044H
	ret	0
?TacticalAnalysisMapPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; TacticalAnalysisMapPathValid
_TEXT	ENDS
PUBLIC	?FindValidDestinationDest@@YAHHHPBXPAVCvAStar@@@Z ; FindValidDestinationDest
EXTRN	?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z:PROC ; CvPlot::getNumVisibleEnemyDefenders
; Function compile flags: /Ogtpy
;	COMDAT ?FindValidDestinationDest@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?FindValidDestinationDest@@YAHHHPBXPAVCvAStar@@@Z PROC	; FindValidDestinationDest, COMDAT

; 5356 : 	CvUnit* pUnit = ((CvUnit*)pointer);
; 5357 : 	CvPlot* pToPlot = GC.getMap().plotUnchecked(iToX, iToY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	esi
	mov	esi, DWORD PTR [eax+4020]
	imul	esi, DWORD PTR _iToY$[esp+4]
	add	esi, DWORD PTR _iToX$[esp+4]

; 5358 : 
; 5359 : 	if(pToPlot->getNumFriendlyUnitsOfType(pUnit) >= GC.getPLOT_UNIT_LIMIT())

	mov	ebx, DWORD PTR _pointer$[esp+4]
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [eax+4068]
	push	edi
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7356
	push	1
	push	ebx
	mov	ecx, esi
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	cmp	eax, edi
	jl	SHORT $LN3@FindValidD
$LN20@FindValidD:
	pop	edi
	pop	esi

; 5360 : 	{
; 5361 : #ifdef AUI_WARNING_FIXES
; 5362 : 		return FALSE;
; 5363 : #else
; 5364 : 		return false;

	xor	eax, eax
	pop	ebx

; 5390 : #endif
; 5391 : }

	ret	0
$LN3@FindValidD:

; 5365 : #endif
; 5366 : 	}
; 5367 : 
; 5368 : 	if(pToPlot->getNumVisibleEnemyDefenders(pUnit) > 0)

	push	ebx
	mov	ecx, esi
	call	?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ; CvPlot::getNumVisibleEnemyDefenders
	test	eax, eax

; 5369 : 	{
; 5370 : #ifdef AUI_WARNING_FIXES
; 5371 : 		return FALSE;
; 5372 : #else
; 5373 : 		return false;

	jg	SHORT $LN20@FindValidD

; 5374 : #endif
; 5375 : 	}
; 5376 : 
; 5377 : 	// can't capture the unit with a non-combat unit
; 5378 : 	if(!pUnit->IsCombatUnit() && pToPlot->isVisibleEnemyUnit(pUnit))

	cmp	DWORD PTR [ebx+1044], 0
	jg	SHORT $LN1@FindValidD
	push	ebx
	mov	ecx, esi
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	test	al, al

; 5379 : 	{
; 5380 : #ifdef AUI_WARNING_FIXES
; 5381 : 		return FALSE;
; 5382 : 	}
; 5383 : 
; 5384 : 	return TRUE;
; 5385 : #else
; 5386 : 		return false;

	jne	SHORT $LN20@FindValidD
$LN1@FindValidD:
	pop	edi
	pop	esi

; 5387 : 	}
; 5388 : 
; 5389 : 	return true;

	mov	eax, 1
	pop	ebx

; 5390 : #endif
; 5391 : }

	ret	0
?FindValidDestinationDest@@YAHHHPBXPAVCvAStar@@@Z ENDP	; FindValidDestinationDest
_TEXT	ENDS
PUBLIC	?FindValidDestinationPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; FindValidDestinationPathValid
; Function compile flags: /Ogtpy
;	COMDAT ?FindValidDestinationPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?FindValidDestinationPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; FindValidDestinationPathValid, COMDAT

; 5396 : 	CvUnit* pUnit = ((CvUnit*)pointer);
; 5397 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5398 : 	const CvPlot* pToPlot = node->m_pPlot;
; 5399 : 	if (!pToPlot)
; 5400 : 		return FALSE;
; 5401 : #else
; 5402 : 	CvPlot* pToPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	esi
	mov	esi, DWORD PTR _node$[esp]
	movsx	eax, WORD PTR [esi+82]
	imul	eax, DWORD PTR [ecx+4020]
	movsx	edx, WORD PTR [esi+80]
	add	eax, edx
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	push	edi

; 5403 : #endif
; 5404 : 
; 5405 : #ifdef AUI_ASTAR_FIX_FASTER_CHECKS
; 5406 : 	if (node->m_iData2 > 3)
; 5407 : 	{
; 5408 : 		return FALSE;
; 5409 : 	}
; 5410 : #endif
; 5411 : 
; 5412 : 	if(!pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE))

	mov	edi, DWORD PTR _pointer$[esp+4]
	push	128					; 00000080H
	push	eax
	mov	ecx, edi
	call	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canEnterTerrain
	test	al, al
	jne	SHORT $LN3@FindValidD@2
$LN14@FindValidD@2:
	pop	edi

; 5413 : 	{
; 5414 : 		return FALSE;

	xor	eax, eax
	pop	esi

; 5424 : 	{
; 5425 : 		return FALSE;
; 5426 : 	}
; 5427 : #endif
; 5428 : 
; 5429 : 	return TRUE;
; 5430 : }

	ret	0
$LN3@FindValidD@2:

; 5415 : 	}
; 5416 : 
; 5417 : 	if(!PathValid(parent,node,data,pointer,finder))

	mov	eax, DWORD PTR _finder$[esp+4]
	mov	ecx, DWORD PTR _data$[esp+4]
	mov	edx, DWORD PTR _parent$[esp+4]
	push	eax
	push	edi
	push	ecx
	push	esi
	push	edx
	call	?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathValid
	add	esp, 20					; 00000014H
	test	eax, eax

; 5418 : 	{
; 5419 : 		return FALSE;

	je	SHORT $LN14@FindValidD@2

; 5420 : 	}
; 5421 : 
; 5422 : #ifndef AUI_ASTAR_FIX_FASTER_CHECKS
; 5423 : 	if(node->m_iData2 > 3)

	xor	eax, eax
	cmp	DWORD PTR [esi+16], 3
	pop	edi
	setle	al
	pop	esi

; 5424 : 	{
; 5425 : 		return FALSE;
; 5426 : 	}
; 5427 : #endif
; 5428 : 
; 5429 : 	return TRUE;
; 5430 : }

	ret	0
?FindValidDestinationPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; FindValidDestinationPathValid
_TEXT	ENDS
PUBLIC	?TradePathInitialize@@YAXPBXPAVCvAStar@@@Z	; TradePathInitialize
EXTRN	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ:PROC	; CvTeam::canEmbarkAllWaterPassage
; Function compile flags: /Ogtpy
;	COMDAT ?TradePathInitialize@@YAXPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_pointer$ = 8						; size = 4
_finder$ = 12						; size = 4
?TradePathInitialize@@YAXPBXPAVCvAStar@@@Z PROC		; TradePathInitialize, COMDAT

; 5708 : {

	push	esi

; 5709 : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 5710 : 	PlayerTypes ePlayer = PlayerTypes(finder->GetInfo() & 0x7f);
; 5711 : 	PlayerTypes eToPlayer = (PlayerTypes)(finder->GetInfo() >> 8);
; 5712 : #else
; 5713 : 	PlayerTypes ePlayer = (PlayerTypes)finder->GetInfo();
; 5714 : #endif
; 5715 : 
; 5716 : 	TradePathCacheData* pCacheData = reinterpret_cast<TradePathCacheData*>(finder->GetScratchBuffer());

	mov	esi, DWORD PTR _finder$[esp]
	push	edi

; 5717 : 
; 5718 : 	CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	mov	edi, DWORD PTR [esi+72]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 5719 : 	TeamTypes eTeam = kPlayer.getTeam();

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN15@TradePathI
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN16@TradePathI
$LN15@TradePathI:
	or	eax, -1
$LN16@TradePathI:

; 5720 : 	pCacheData->m_pTeam = &GET_TEAM(eTeam);

	mov	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	eax, 2980				; 00000ba4H
	add	ecx, eax
	mov	DWORD PTR [esi+116], ecx

; 5721 : 	pCacheData->m_bCanEmbarkAllWaterPassage = pCacheData->m_pTeam->canEmbarkAllWaterPassage();

	call	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ ; CvTeam::canEmbarkAllWaterPassage

; 5722 : 
; 5723 : 	CvPlayerTraits* pPlayerTraits = kPlayer.GetPlayerTraits();

	mov	ecx, edi
	mov	BYTE PTR [esi+120], al
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits

; 5724 : 	if (pPlayerTraits)

	xor	ecx, ecx
	cmp	eax, ecx
	je	SHORT $LN2@TradePathI

; 5725 : 	{
; 5726 : 		pCacheData->m_bIsRiverTradeRoad = pPlayerTraits->IsRiverTradeRoad();

	mov	dl, BYTE PTR [eax+346]
	mov	BYTE PTR [esi+121], dl

; 5727 : 		pCacheData->m_bIsMoveFriendlyWoodsAsRoad = pPlayerTraits->IsMoveFriendlyWoodsAsRoad();

	mov	al, BYTE PTR [eax+325]
	pop	edi
	mov	BYTE PTR [esi+122], al
	pop	esi

; 5733 : 	}
; 5734 : 
; 5735 : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 5736 : 	pCacheData->m_pToPlayer = &GET_PLAYER(eToPlayer);
; 5737 : #endif
; 5738 : }

	ret	0
$LN2@TradePathI:
	pop	edi

; 5728 : 	}
; 5729 : 	else
; 5730 : 	{
; 5731 : 		pCacheData->m_bIsRiverTradeRoad = false;

	mov	BYTE PTR [esi+121], cl

; 5732 : 		pCacheData->m_bIsMoveFriendlyWoodsAsRoad = false;

	mov	BYTE PTR [esi+122], cl
	pop	esi

; 5733 : 	}
; 5734 : 
; 5735 : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 5736 : 	pCacheData->m_pToPlayer = &GET_PLAYER(eToPlayer);
; 5737 : #endif
; 5738 : }

	ret	0
?TradePathInitialize@@YAXPBXPAVCvAStar@@@Z ENDP		; TradePathInitialize
_TEXT	ENDS
PUBLIC	?TradeRouteLandPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteLandPathCost
; Function compile flags: /Ogtpy
;	COMDAT ?TradeRouteLandPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?TradeRouteLandPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; TradeRouteLandPathCost, COMDAT

; 5755 : 	PlayerTypes ePlayer = (PlayerTypes)finder->GetInfo();
; 5756 : 
; 5757 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5758 : 	const CvPlot* pFromPlot = parent->m_pPlot;
; 5759 : 	const CvPlot* pToPlot = node->m_pPlot;
; 5760 : #else
; 5761 : 	CvMap& kMap = GC.getMap();
; 5762 : 	int iFromPlotX = parent->m_iX;
; 5763 : 	int iFromPlotY = parent->m_iY;
; 5764 : 	CvPlot* pFromPlot = kMap.plotUnchecked(iFromPlotX, iFromPlotY);

	mov	edx, DWORD PTR _parent$[esp-4]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [eax+4020]
	push	ebx
	push	ebp
	push	esi
	movsx	esi, WORD PTR [edx+82]
	movsx	edx, WORD PTR [edx+80]
	imul	esi, ecx
	mov	eax, DWORD PTR [eax+4068]
	push	edi
	add	esi, edx

; 5765 : 
; 5766 : 	int iToPlotX = node->m_iX;
; 5767 : 	int iToPlotY = node->m_iY;
; 5768 : 	CvPlot* pToPlot = kMap.plotUnchecked(iToPlotX, iToPlotY);

	mov	edx, DWORD PTR _node$[esp+12]
	imul	esi, 484				; 000001e4H
	movsx	edi, WORD PTR [edx+82]
	imul	edi, ecx
	movsx	ecx, WORD PTR [edx+80]
	add	edi, ecx
	imul	edi, 484				; 000001e4H

; 5769 : #endif
; 5770 : 
; 5771 : 	int iBaseCost = 100;
; 5772 : 	int iCost = iBaseCost;
; 5773 : 
; 5774 : 	const TradePathCacheData* pCacheData = reinterpret_cast<const TradePathCacheData*>(finder->GetScratchBuffer());
; 5775 : 	FeatureTypes eFeature = pToPlot->getFeatureType();

	movsx	ebx, BYTE PTR [edi+eax+432]
	add	esi, eax
	add	edi, eax

; 5776 : 
; 5777 : 	// super duper low costs for moving along routes
; 5778 : 	if (pFromPlot->getRouteType() != NO_ROUTE && pToPlot->getRouteType() != NO_ROUTE)

	mov	ecx, esi
	mov	ebp, 100				; 00000064H
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	SHORT $LN15@TradeRoute
	mov	ecx, edi
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	SHORT $LN15@TradeRoute

; 5779 : 	{
; 5780 : 		iCost = iCost / 2;

	mov	ebp, 50					; 00000032H
	jmp	SHORT $LN4@TradeRoute
$LN15@TradeRoute:

; 5781 : 	}
; 5782 : 	//// super low costs for moving along rivers
; 5783 : 	else if (pCacheData->IsRiverTradeRoad() && pFromPlot->isRiver() && pToPlot->isRiver())

	mov	eax, DWORD PTR _finder$[esp+12]
	cmp	BYTE PTR [eax+121], 0
	je	SHORT $LN13@TradeRoute
	cmp	BYTE PTR [esi+457], 0
	jle	SHORT $LN13@TradeRoute
	cmp	BYTE PTR [edi+457], 0
	jle	SHORT $LN13@TradeRoute

; 5784 : 	{
; 5785 : 		iCost = iCost / 2;

	mov	ebp, 50					; 00000032H
	jmp	SHORT $LN4@TradeRoute
$LN13@TradeRoute:

; 5786 : 	}
; 5787 : 	// Iroquios ability
; 5788 : 	else if ((eFeature == FEATURE_FOREST || eFeature == FEATURE_JUNGLE) && pCacheData->IsMoveFriendlyWoodsAsRoad())

	cmp	ebx, 5
	je	SHORT $LN10@TradeRoute
	cmp	ebx, 1
	jne	SHORT $LN11@TradeRoute
$LN10@TradeRoute:
	cmp	BYTE PTR [eax+122], 0
	je	SHORT $LN11@TradeRoute

; 5789 : 	{
; 5790 : 		iCost = iCost / 2;

	mov	ebp, 50					; 00000032H

; 5791 : 	}
; 5792 : 	else

	jmp	SHORT $LN4@TradeRoute
$LN11@TradeRoute:

; 5793 : 	{
; 5794 : 		bool bFeaturePenalty = false;

	xor	al, al

; 5795 : 		if (eFeature == FEATURE_FOREST || eFeature == FEATURE_JUNGLE || eFeature == FEATURE_ICE)

	cmp	ebx, 5
	je	SHORT $LN7@TradeRoute
	cmp	ebx, 1
	je	SHORT $LN7@TradeRoute
	test	ebx, ebx
	jne	SHORT $LN8@TradeRoute
$LN7@TradeRoute:

; 5796 : 		{
; 5797 : 			bFeaturePenalty = true;

	mov	al, 1
$LN8@TradeRoute:

; 5798 : 		}
; 5799 : 
; 5800 : 		if (pToPlot->isHills() || bFeaturePenalty)

	cmp	BYTE PTR [edi+5], 1
	je	SHORT $LN5@TradeRoute
	test	al, al
	je	SHORT $LN6@TradeRoute
$LN5@TradeRoute:

; 5801 : 		{
; 5802 : 			iCost += 1;

	mov	ebp, 101				; 00000065H
$LN6@TradeRoute:

; 5803 : 		}
; 5804 : 
; 5805 : 		// extra cost for not going to an oasis! (this encourages routes to go through oasis)
; 5806 : 		if (eFeature != FEATURE_OASIS)

	cmp	ebx, 3
	je	SHORT $LN4@TradeRoute

; 5807 : 		{
; 5808 : 			iCost += 1;

	inc	ebp
$LN4@TradeRoute:

; 5809 : 		}
; 5810 : 	}
; 5811 : 
; 5812 : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 5813 : 	if (pToPlot->isOwned())
; 5814 : 	{
; 5815 : 		if (pToPlot->getTeam() == pCacheData->getToPlayer().getTeam() || pToPlot->getTeam() == pCacheData->getTeam().GetID())
; 5816 : 		{
; 5817 : 			iCost /= 2;
; 5818 : 		}
; 5819 : 		else
; 5820 : 		{
; 5821 : 			iCost *= 2;
; 5822 : 			iCost += 1;
; 5823 : 		}
; 5824 : 	}
; 5825 : #endif
; 5826 : 
; 5827 : 	if (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater())

	cmp	BYTE PTR [edi+5], 3
	jne	SHORT $LN3@TradeRoute
	mov	ecx, edi
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	test	al, al
	jne	SHORT $LN3@TradeRoute

; 5828 : 	{
; 5829 : 		iCost += 1000;

	add	ebp, 1000				; 000003e8H
$LN3@TradeRoute:

; 5830 : 	}
; 5831 : 	
; 5832 : 	// Penalty for ending a turn on a mountain
; 5833 : 	if(pToPlot->isImpassable() || pToPlot->isMountain())

	test	BYTE PTR [edi+462], 128			; 00000080H
	jne	SHORT $LN1@TradeRoute
	cmp	BYTE PTR [edi+5], 0
	jne	SHORT $LN56@TradeRoute
$LN1@TradeRoute:

; 5834 : 	{
; 5835 : 		iCost += 1000;

	add	ebp, 1000				; 000003e8H
$LN56@TradeRoute:
	pop	edi
	pop	esi

; 5836 : 	}
; 5837 : 
; 5838 : 	FAssert(iCost != MAX_INT);
; 5839 : 	FAssert(iCost > 0);
; 5840 : 
; 5841 : 	return iCost;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 5842 : }

	ret	0
?TradeRouteLandPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; TradeRouteLandPathCost
_TEXT	ENDS
PUBLIC	?TradeRouteLandValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteLandValid
; Function compile flags: /Ogtpy
;	COMDAT ?TradeRouteLandValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?TradeRouteLandValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; TradeRouteLandValid, COMDAT

; 5846 : {

	push	esi

; 5847 : 	if(parent == NULL)

	mov	esi, DWORD PTR _parent$[esp]
	test	esi, esi
	jne	SHORT $LN5@TradeRoute@2
$LN32@TradeRoute@2:

; 5848 : 	{
; 5849 : 		return TRUE;

	mov	eax, 1
	pop	esi

; 5884 : }

	ret	0
$LN5@TradeRoute@2:

; 5850 : 	}
; 5851 : 
; 5852 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5853 : 	const CvPlot* pOldPlot = parent->m_pPlot;
; 5854 : 	const CvPlot* pNewPlot = node->m_pPlot;
; 5855 : 	if (!pOldPlot || !pNewPlot)
; 5856 : 		return FALSE;
; 5857 : 
; 5858 : 	if (pOldPlot->getArea() != pNewPlot->getArea())
; 5859 : #else
; 5860 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 5861 : 	CvPlot* pNewPlot = kMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR [eax+4020]
	mov	edx, DWORD PTR [eax+4068]
	push	edi
	mov	edi, DWORD PTR _node$[esp+4]
	movsx	eax, WORD PTR [edi+82]
	movsx	edi, WORD PTR [edi+80]
	imul	eax, ecx
	add	eax, edi

; 5862 : 
; 5863 : 	if(kMap.plotUnchecked(parent->m_iX, parent->m_iY)->getArea() != pNewPlot->getArea())

	movsx	edi, WORD PTR [esi+82]
	imul	eax, 484				; 000001e4H
	imul	edi, ecx
	movsx	ecx, WORD PTR [esi+80]
	add	edi, ecx
	imul	edi, 484				; 000001e4H
	add	eax, edx
	mov	edx, DWORD PTR [edi+edx+356]
	pop	edi
	cmp	edx, DWORD PTR [eax+356]

; 5864 : #endif
; 5865 : 	{
; 5866 : 		return FALSE;

	jne	SHORT $LN1@TradeRoute@2

; 5867 : 	}
; 5868 : 
; 5869 : 	if (pNewPlot->isWater())

	mov	cl, BYTE PTR [eax+5]
	cmp	cl, 3

; 5870 : 	{
; 5871 : 		return FALSE;

	je	SHORT $LN1@TradeRoute@2

; 5872 : 	}
; 5873 : 
; 5874 : #ifdef AUI_ASTAR_FIX_STEP_VALID_CONSIDERS_MOUNTAINS
; 5875 : 	if (pNewPlot->isImpassable())
; 5876 : #else
; 5877 : 	if(pNewPlot->isMountain() || pNewPlot->isImpassable())

	test	cl, cl
	je	SHORT $LN1@TradeRoute@2
	test	BYTE PTR [eax+462], 128			; 00000080H

; 5881 : 	}
; 5882 : 
; 5883 : 	return TRUE;

	je	SHORT $LN32@TradeRoute@2
$LN1@TradeRoute@2:

; 5878 : #endif
; 5879 : 	{
; 5880 : 		return FALSE;

	xor	eax, eax
	pop	esi

; 5884 : }

	ret	0
?TradeRouteLandValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; TradeRouteLandValid
_TEXT	ENDS
PUBLIC	?TradeRouteWaterPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteWaterPathCost
; Function compile flags: /Ogtpy
;	COMDAT ?TradeRouteWaterPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?TradeRouteWaterPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; TradeRouteWaterPathCost, COMDAT

; 5890 : #ifndef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5891 : 	CvMap& kMap = GC.getMap();
; 5892 : #endif
; 5893 : 	const TradePathCacheData* pCacheData = reinterpret_cast<const TradePathCacheData*>(finder->GetScratchBuffer());
; 5894 : 
; 5895 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5896 : 	const CvPlot* pFromPlot = parent->m_pPlot;
; 5897 : 	const CvPlot* pToPlot = node->m_pPlot;
; 5898 : #else
; 5899 : 	int iFromPlotX = parent->m_iX;
; 5900 : 	int iFromPlotY = parent->m_iY;
; 5901 : 	CvPlot* pFromPlot = kMap.plotUnchecked(iFromPlotX, iFromPlotY);

	mov	edx, DWORD PTR _parent$[esp-4]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [eax+4020]
	push	ebp
	push	esi
	push	edi
	movsx	edi, WORD PTR [edx+82]
	movsx	edx, WORD PTR [edx+80]
	imul	edi, ecx
	mov	eax, DWORD PTR [eax+4068]
	add	edi, edx

; 5902 : 
; 5903 : 	int iToPlotX = node->m_iX;
; 5904 : 	int iToPlotY = node->m_iY;
; 5905 : 	CvPlot* pToPlot = kMap.plotUnchecked(iToPlotX, iToPlotY);

	mov	edx, DWORD PTR _node$[esp+8]
	imul	edi, 484				; 000001e4H
	movsx	esi, WORD PTR [edx+82]
	imul	esi, ecx
	movsx	ecx, WORD PTR [edx+80]
	add	esi, ecx
	imul	esi, 484				; 000001e4H
	add	esi, eax
	add	edi, eax

; 5906 : #endif
; 5907 : 
; 5908 : 	int iBaseCost = 100;
; 5909 : 	int iCost = iBaseCost;
; 5910 : 
; 5911 : 	if (!pToPlot->isCity())

	mov	eax, DWORD PTR [esi+104]
	mov	ebp, 100				; 00000064H
	test	eax, eax
	jl	SHORT $LN63@TradeRoute@3
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN63@TradeRoute@3
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	SHORT $LN66@TradeRoute@3
$LN63@TradeRoute@3:

; 5912 : 	{
; 5913 : 		bool bIsAdjacentToLand = pFromPlot->isAdjacentToLand_Cached() && pToPlot->isAdjacentToLand_Cached();

	test	BYTE PTR [edi+462], 64			; 00000040H
	je	SHORT $LN11@TradeRoute@3
	test	BYTE PTR [esi+462], 64			; 00000040H
	jne	SHORT $LN7@TradeRoute@3
$LN11@TradeRoute@3:

; 5914 : 		if (!bIsAdjacentToLand)
; 5915 : 		{
; 5916 : 			iCost += 1;

	mov	ebp, 101				; 00000065H
$LN7@TradeRoute@3:

; 5917 : 		}
; 5918 : 
; 5919 : 		// if is enemy tile, avoid
; 5920 : 		TeamTypes eToPlotTeam = pToPlot->getTeam();

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN67@TradeRoute@3
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN67@TradeRoute@3
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 5921 : 		if (eToPlotTeam != NO_TEAM && pCacheData->getTeam().isAtWar(eToPlotTeam))

	cmp	eax, -1
	je	SHORT $LN67@TradeRoute@3
	mov	ecx, DWORD PTR _finder$[esp+8]
	mov	ecx, DWORD PTR [ecx+116]
	push	eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN67@TradeRoute@3

; 5922 : 		{
; 5923 : 			iCost += 1000; // slewis - is this too prohibitive? Too cheap?

	add	ebp, 1000				; 000003e8H
$LN67@TradeRoute@3:

; 5924 : 		}
; 5925 : 
; 5926 : 		if (!pToPlot->isWater())

	cmp	BYTE PTR [esi+5], 3

; 5927 : 		{
; 5928 : 			iCost += 1000;
; 5929 : 		}
; 5930 : 		else

	jne	SHORT $LN68@TradeRoute@3

; 5931 : 		{
; 5932 : 			if (pToPlot->getTerrainType() != (TerrainTypes) GC.getSHALLOW_WATER_TERRAIN())	// Quicker isShallowWater test, since we already know the plot is water

	movsx	edx, BYTE PTR [esi+6]
	cmp	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	je	SHORT $LN2@TradeRoute@3

; 5933 : 			{
; 5934 : 				if (!pCacheData->CanEmbarkAllWaterPassage())

	mov	eax, DWORD PTR _finder$[esp+8]
	cmp	BYTE PTR [eax+120], 0
	jne	SHORT $LN2@TradeRoute@3
$LN68@TradeRoute@3:

; 5935 : 				{
; 5936 : 					iCost += 1000;

	add	ebp, 1000				; 000003e8H
$LN2@TradeRoute@3:

; 5937 : 				}
; 5938 : 			}
; 5939 : 		}
; 5940 : 
; 5941 : 		if(pToPlot->isImpassable())

	test	BYTE PTR [esi+462], 128			; 00000080H
	je	SHORT $LN66@TradeRoute@3

; 5942 : 		{
; 5943 : 			iCost += 1000;

	add	ebp, 1000				; 000003e8H
$LN66@TradeRoute@3:
	pop	edi
	pop	esi

; 5944 : 		}
; 5945 : 	}
; 5946 : 
; 5947 : 	FAssert(iCost != MAX_INT);
; 5948 : 	FAssert(iCost > 0);
; 5949 : 
; 5950 : 	return iCost;

	mov	eax, ebp
	pop	ebp

; 5951 : }

	ret	0
?TradeRouteWaterPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; TradeRouteWaterPathCost
_TEXT	ENDS
PUBLIC	?TradeRouteWaterValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteWaterValid
; Function compile flags: /Ogtpy
;	COMDAT ?TradeRouteWaterValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?TradeRouteWaterValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; TradeRouteWaterValid, COMDAT

; 5955 : {

	push	ebp

; 5956 : 	if(parent == NULL)

	mov	ebp, DWORD PTR _parent$[esp]
	test	ebp, ebp
	jne	SHORT $LN8@TradeRoute@4

; 5957 : 	{
; 5958 : 		return TRUE;

	lea	eax, DWORD PTR [ebp+1]
	pop	ebp

; 6009 : }

	ret	0
$LN8@TradeRoute@4:

; 5959 : 	}
; 5960 : 
; 5961 : 	const TradePathCacheData* pCacheData = reinterpret_cast<const TradePathCacheData*>(finder->GetScratchBuffer());
; 5962 : 
; 5963 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5964 : 	const CvPlot* pNewPlot = node->m_pPlot;
; 5965 : 	if (!pNewPlot)
; 5966 : 		return FALSE;
; 5967 : #else
; 5968 : 	CvMap& kMap = GC.getMap();
; 5969 : 	CvPlot* pNewPlot = kMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	eax, DWORD PTR _node$[esp]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	esi
	movsx	esi, WORD PTR [eax+82]
	imul	esi, DWORD PTR [ebx+4020]
	movsx	eax, WORD PTR [eax+80]
	add	esi, eax
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ebx+4068]
	push	edi

; 5970 : #endif
; 5971 : 
; 5972 : 	if (!pNewPlot->isCity())

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN46@TradeRoute@4
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN46@TradeRoute@4
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	jne	SHORT $LN1@TradeRoute@4
$LN46@TradeRoute@4:

; 5973 : 	{
; 5974 : 		if (!pNewPlot->isWater())

	cmp	BYTE PTR [esi+5], 3

; 5975 : 		{
; 5976 : 			return FALSE;

	jne	SHORT $LN50@TradeRoute@4

; 5977 : 		}
; 5978 : 
; 5979 : 		if (pNewPlot->getTerrainType() != (TerrainTypes) GC.getSHALLOW_WATER_TERRAIN())	// Quicker shallow water test since we know that the plot is water already

	movsx	edx, BYTE PTR [esi+6]
	cmp	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	je	SHORT $LN4@TradeRoute@4

; 5980 : 		{
; 5981 : 			if (!pCacheData->CanEmbarkAllWaterPassage())

	mov	eax, DWORD PTR _finder$[esp+12]
	cmp	BYTE PTR [eax+120], 0

; 5982 : 			{
; 5983 : 				return FALSE;

	je	SHORT $LN50@TradeRoute@4
$LN4@TradeRoute@4:

; 5984 : 			}
; 5985 : 		}
; 5986 : 
; 5987 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5988 : 		const CvPlot* pParentPlot = parent->m_pPlot;
; 5989 : 		if (!pParentPlot)
; 5990 : 			return FALSE;
; 5991 : #else
; 5992 : 		CvPlot* pParentPlot = kMap.plotUnchecked(parent->m_iX, parent->m_iY);

	movsx	edi, WORD PTR [ebp+82]
	imul	edi, DWORD PTR [ebx+4020]
	movsx	ecx, WORD PTR [ebp+80]
	add	edi, ecx
	imul	edi, 484				; 000001e4H
	add	edi, DWORD PTR [ebx+4068]

; 5993 : #endif
; 5994 : 		if (!pParentPlot->isCity())

	mov	ecx, edi
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	test	al, al
	jne	SHORT $LN2@TradeRoute@4

; 5995 : 		{
; 5996 : 			if(pParentPlot->getArea() != pNewPlot->getArea())

	mov	edx, DWORD PTR [edi+356]
	cmp	edx, DWORD PTR [esi+356]

; 5997 : 			{
; 5998 : 				return FALSE;

	jne	SHORT $LN50@TradeRoute@4
$LN2@TradeRoute@4:

; 5999 : 			}
; 6000 : 		}
; 6001 : 
; 6002 : 		if(pNewPlot->isImpassable())

	test	BYTE PTR [esi+462], 128			; 00000080H
	je	SHORT $LN1@TradeRoute@4
$LN50@TradeRoute@4:
	pop	edi
	pop	esi
	pop	ebx

; 6003 : 		{
; 6004 : 			return FALSE;

	xor	eax, eax
	pop	ebp

; 6009 : }

	ret	0
$LN1@TradeRoute@4:
	pop	edi
	pop	esi
	pop	ebx

; 6005 : 		}
; 6006 : 	}
; 6007 : 
; 6008 : 	return TRUE;

	mov	eax, 1
	pop	ebp

; 6009 : }

	ret	0
?TradeRouteWaterValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; TradeRouteWaterValid
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvAStarNode *,6,1,297,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvAStarNode *,6,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 6
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 6
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+36], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvAStarNode *,6,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?SetSize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXI@Z ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::SetSize
; Function compile flags: /Ogtpy
;	COMDAT ?SetSize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXI@Z
_TEXT	SEGMENT
_nOld$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?SetSize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXI@Z PROC ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::SetSize, COMDAT
; _this$ = ecx

; 468  : 	void SetSize(unsigned int uiFit){

	push	ecx
	push	ebx

; 469  : 
; 470  : 		unsigned int nOld = m_uiCurrSize;
; 471  : 
; 472  : 		m_uiCurrSize = MIN( m_uiCurrSize, uiFit );

	mov	ebx, DWORD PTR _uiFit$[esp+4]
	push	ebp
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	push	edi
	lea	edi, DWORD PTR [esi+4]
	mov	DWORD PTR _nOld$[esp+20], eax
	cmp	ebx, eax
	lea	eax, DWORD PTR _uiFit$[esp+16]
	jb	SHORT $LN17@SetSize
	mov	eax, edi
$LN17@SetSize:
	mov	ecx, DWORD PTR [eax]

; 473  : 
; 474  : 		T* pTemp = NULL;

	xor	ebp, ebp
	mov	DWORD PTR [edi], ecx

; 475  : 		if( uiFit > 0 ){

	cmp	ebx, ebp
	jbe	SHORT $LN9@SetSize

; 476  : 			pTemp = Alloc(uiFit);

	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	mov	edx, ebx
	shl	edx, 4
	push	4
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], ebx
	mov	ebp, eax

; 477  : 			if (pTemp)

	test	eax, eax
	je	SHORT $LN8@SetSize

; 478  : 			{
; 479  : 				if( bPODType ){
; 480  : 					memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [esi]
	shl	ecx, 4
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 481  : 				}else{
; 482  : 					for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 483  : 						new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 484  : 				}
; 485  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], ebx

; 491  : 				return;
; 492  : 			}
; 493  : 		}
; 494  : 		else

	jmp	SHORT $LN1@SetSize
$LN8@SetSize:

; 486  : 			}
; 487  : 			else
; 488  : 			{
; 489  : 				FAssertMsg2(0, "Failed to set array size from %u to %u", nOld, uiFit);
; 490  : 				m_uiCurrSize = nOld;

	mov	eax, DWORD PTR _nOld$[esp+20]
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 500  : 	};

	pop	ecx
	ret	4
$LN9@SetSize:

; 495  : 		{
; 496  : 			m_uiCurrMaxSize = 0;

	mov	DWORD PTR [esi+8], ebp
$LN1@SetSize:

; 497  : 		}
; 498  : 		Free(m_pData, nOld);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	pop	edi

; 499  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 500  : 	};

	pop	ecx
	ret	4
?SetSize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXI@Z ENDP ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::SetSize
_TEXT	ENDS
PUBLIC	?clear@CvAStarNode@@QAEXXZ			; CvAStarNode::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastarnode.h
;	COMDAT ?clear@CvAStarNode@@QAEXXZ
_TEXT	SEGMENT
?clear@CvAStarNode@@QAEXXZ PROC				; CvAStarNode::clear, COMDAT
; _this$ = ecx

; 119  : 		m_iTotalCost = 0;

	xor	eax, eax

; 120  : 		m_iKnownCost = 0;
; 121  : 		m_iHeuristicCost = 0;
; 122  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 123  : 		bPlotVisibleToTeam = false;
; 124  : 		bIsMountain = false;
; 125  : 		bIsWater = false;
; 126  : 		bCanEnterTerrain = false;
; 127  : 		bIsRevealedToTeam = false;
; 128  : 		bContainsOtherFriendlyTeamCity = false;
; 129  : 		bContainsEnemyCity = false;
; 130  : 		bContainsVisibleEnemy = false;
; 131  : 		bContainsVisibleEnemyDefender = false;
; 132  : #else
; 133  : 		m_iNumChildren = 0;

	xor	edx, edx
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	WORD PTR [ecx+84], dx

; 134  : #endif
; 135  : 		m_iData1 = 0;

	mov	DWORD PTR [ecx+12], eax

; 136  : 		m_iData2 = 0;

	mov	DWORD PTR [ecx+16], eax

; 137  : 
; 138  : 		m_bOnStack = false;

	mov	BYTE PTR [ecx+86], al

; 139  : 
; 140  : 		m_eCvAStarListType = NO_CVASTARLIST;

	mov	DWORD PTR [ecx+20], -1

; 141  : 
; 142  : 		m_pParent = NULL;

	mov	DWORD PTR [ecx+24], eax

; 143  : 		m_pNext = NULL;

	mov	DWORD PTR [ecx+28], eax

; 144  : 		m_pPrev = NULL;

	mov	DWORD PTR [ecx+32], eax

; 145  : 		m_pStack = NULL;

	mov	DWORD PTR [ecx+36], eax

; 146  : 
; 147  : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 148  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 149  : 		bIsCalculated = false;
; 150  : #else
; 151  : 		m_kCostCacheData.bIsCalculated = false;
; 152  : #endif
; 153  : #endif
; 154  : 
; 155  : 		m_apChildren.clear();

	mov	DWORD PTR [ecx+44], eax

; 156  : 	}

	ret	0
?clear@CvAStarNode@@QAEXXZ ENDP				; CvAStarNode::clear
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,6,1,297,0>::~FStaticVector<CvAStarNode *,6,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvAStarNode *,6,1,297,0>::~FStaticVector<CvAStarNode *,6,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvAStarNode *,6,1,297,0>::~FStaticVector<CvAStarNode *,6,1,297,0>
_TEXT	ENDS
PUBLIC	??1CvAStarNode@@QAE@XZ				; CvAStarNode::~CvAStarNode
; Function compile flags: /Ogtpy
;	COMDAT ??1CvAStarNode@@QAE@XZ
_TEXT	SEGMENT
??1CvAStarNode@@QAE@XZ PROC				; CvAStarNode::~CvAStarNode, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR [ecx+40]
	add	ecx, 52					; 00000034H
	cmp	eax, ecx
	je	SHORT $LN6@CvAStarNod
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvAStarNod:
	ret	0
??1CvAStarNode@@QAE@XZ ENDP				; CvAStarNode::~CvAStarNode
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z ; FStaticVector<CvAStarNode *,6,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z PROC ; FStaticVector<CvAStarNode *,6,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+36], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvAStarNode *,6,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z ENDP ; FStaticVector<CvAStarNode *,6,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?setsize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@QAEXI@Z ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::setsize
; Function compile flags: /Ogtpy
;	COMDAT ?setsize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?setsize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@QAEXI@Z PROC ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::setsize, COMDAT
; _this$ = ecx

; 342  : 	void setsize( unsigned int uiNewSize ){

	push	esi
	push	edi

; 343  : 		SetSize(uiNewSize);

	mov	edi, DWORD PTR _uiNewSize$[esp+4]
	push	edi
	mov	esi, ecx
	call	?SetSize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXI@Z ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::SetSize

; 344  : 		m_uiCurrSize = MIN(uiNewSize, m_uiCurrMaxSize);

	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN5@setsize
	mov	eax, DWORD PTR [esi+8]
	pop	edi
	mov	DWORD PTR [esi+4], eax
	pop	esi

; 345  : 	}

	ret	4

; 344  : 		m_uiCurrSize = MIN(uiNewSize, m_uiCurrMaxSize);

$LN5@setsize:
	lea	eax, DWORD PTR _uiNewSize$[esp+4]
	mov	ecx, DWORD PTR [eax]
	pop	edi
	mov	DWORD PTR [esi+4], ecx
	pop	esi

; 345  : 	}

	ret	4
?setsize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@QAEXI@Z ENDP ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::setsize
_TEXT	ENDS
PUBLIC	??0CvAStarNode@@QAE@XZ				; CvAStarNode::CvAStarNode
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastarnode.h
;	COMDAT ??0CvAStarNode@@QAE@XZ
_TEXT	SEGMENT
??0CvAStarNode@@QAE@XZ PROC				; CvAStarNode::CvAStarNode, COMDAT
; _this$ = ecx

; 83   : 	CvAStarNode()

	mov	eax, ecx
	mov	DWORD PTR [eax+48], 6
	xor	ecx, ecx
	mov	DWORD PTR [eax+44], ecx
	lea	edx, DWORD PTR [eax+52]
	mov	DWORD PTR [eax+40], edx

; 84   : 	{
; 85   : 		m_iX = -1;

	or	edx, -1
	mov	WORD PTR [eax+80], dx

; 86   : 		m_iY = -1;

	or	edx, edx
	mov	WORD PTR [eax+82], dx

; 87   : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 88   : 		m_pPlot = NULL;
; 89   : #endif
; 90   : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 91   : 		clear();
; 92   : #else
; 93   : 		m_iTotalCost = 0;
; 94   : 		m_iKnownCost = 0;
; 95   : 		m_iHeuristicCost = 0;
; 96   : 		m_iNumChildren = 0;

	xor	edx, edx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	WORD PTR [eax+84], dx

; 97   : 		m_iData1 = 0;

	mov	DWORD PTR [eax+12], ecx

; 98   : 		m_iData2 = 0;

	mov	DWORD PTR [eax+16], ecx

; 99   : 
; 100  : 		m_bOnStack = false;

	mov	BYTE PTR [eax+86], cl

; 101  : 
; 102  : 		m_eCvAStarListType = NO_CVASTARLIST;

	mov	DWORD PTR [eax+20], -1

; 103  : 
; 104  : 		m_pParent = NULL;

	mov	DWORD PTR [eax+24], ecx

; 105  : 		m_pNext = NULL;

	mov	DWORD PTR [eax+28], ecx

; 106  : 		m_pPrev = NULL;

	mov	DWORD PTR [eax+32], ecx

; 107  : 		m_pStack = NULL;

	mov	DWORD PTR [eax+36], ecx

; 108  : #endif
; 109  : #ifdef AUI_ASTAR_PRECALCULATE_NEIGHBORS_ON_INITIALIZE
; 110  : 		for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
; 111  : 		{
; 112  : 			m_apNeighbors[iI] = NULL;
; 113  : 		}
; 114  : #endif
; 115  : 	}

	ret	0
??0CvAStarNode@@QAE@XZ ENDP				; CvAStarNode::CvAStarNode
_TEXT	ENDS
PUBLIC	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z$0
__ehfuncinfo$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
xdata$x	ENDS
;	COMDAT ?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z
_TEXT	SEGMENT
$T227883 = -28						; size = 4
_iI$ = -24						; size = 4
_iJ$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_iColumns$ = 8						; size = 4
_iRows$ = 12						; size = 4
_bWrapX$ = 16						; size = 1
_bWrapY$ = 20						; size = 1
_IsPathDestFunc$ = 24					; size = 4
_DestValidFunc$ = 28					; size = 4
_HeuristicFunc$ = 32					; size = 4
_CostFunc$ = 36						; size = 4
_ValidFunc$ = 40					; size = 4
_NotifyChildFunc$ = 44					; size = 4
_NotifyListFunc$ = 48					; size = 4
_NumExtraChildrenFunc$ = 52				; size = 4
_GetExtraChildFunc$ = 56				; size = 4
_InitializeFunc$ = 60					; size = 4
_UninitializeFunc$ = 64					; size = 4
_pData$ = 68						; size = 4
?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z PROC ; CvAStar::Initialize, COMDAT
; _this$ = ecx

; 171  : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 172  : 	int iI, iJ;
; 173  : 
; 174  : 	DeInit();	// free old memory just in case

	call	?DeInit@CvAStar@@QAEXXZ			; CvAStar::DeInit

; 175  : 
; 176  : 	udIsPathDest = IsPathDestFunc;
; 177  : 	udDestValid = DestValidFunc;
; 178  : 	udHeuristic = HeuristicFunc;

	mov	edx, DWORD PTR _HeuristicFunc$[esp+40]
	mov	eax, DWORD PTR _IsPathDestFunc$[esp+40]
	mov	ecx, DWORD PTR _DestValidFunc$[esp+40]
	mov	DWORD PTR [esi+8], edx

; 179  : 	udCost = CostFunc;
; 180  : 	udValid = ValidFunc;
; 181  : 	udNotifyChild = NotifyChildFunc;

	mov	edx, DWORD PTR _NotifyChildFunc$[esp+40]
	mov	DWORD PTR [esi+4], ecx
	mov	ecx, DWORD PTR _ValidFunc$[esp+40]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _CostFunc$[esp+40]
	mov	DWORD PTR [esi+20], edx

; 182  : 	udNotifyList = NotifyListFunc;
; 183  : 	udNumExtraChildrenFunc = NumExtraChildrenFunc;
; 184  : 	udGetExtraChildFunc = GetExtraChildFunc;

	mov	edx, DWORD PTR _GetExtraChildFunc$[esp+40]
	mov	DWORD PTR [esi+16], ecx
	mov	ecx, DWORD PTR _NumExtraChildrenFunc$[esp+40]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR _NotifyListFunc$[esp+40]
	mov	DWORD PTR [esi+32], edx

; 185  : 	udInitializeFunc = InitializeFunc;
; 186  : 	udUninitializeFunc = UninitializeFunc;
; 187  : 
; 188  : 	m_pData = pData;

	mov	edx, DWORD PTR _pData$[esp+40]
	mov	DWORD PTR [esi+28], ecx
	mov	ecx, DWORD PTR _UninitializeFunc$[esp+40]
	mov	DWORD PTR [esi+24], eax
	mov	eax, DWORD PTR _InitializeFunc$[esp+40]
	mov	DWORD PTR [esi+44], edx

; 189  : 
; 190  : 	m_iColumns = iColumns;
; 191  : 	m_iRows = iRows;
; 192  : 
; 193  : 	m_iXstart = -1;
; 194  : 	m_iYstart = -1;
; 195  : 	m_iXdest = -1;
; 196  : 	m_iYdest = -1;
; 197  : 	m_iInfo = 0;
; 198  : 
; 199  : 	m_bWrapX = bWrapX;

	mov	dl, BYTE PTR _bWrapX$[esp+40]

; 200  : 	m_bWrapY = bWrapY;
; 201  : 	m_bForceReset = false;
; 202  : 
; 203  : 	m_pOpen = NULL;
; 204  : 	m_pOpenTail = NULL;
; 205  : 	m_pClosed = NULL;
; 206  : 	m_pBest = NULL;
; 207  : 	m_pStackHead = NULL;
; 208  : 
; 209  : #ifdef AUI_ASTAR_REMOVE_MALLOC
; 210  : 	m_ppaaNodes = FNEW(CvAStarNode*[m_iColumns], c_eCiv5GameplayDLL, 0);
; 211  : #else
; 212  : 	m_ppaaNodes = reinterpret_cast<CvAStarNode**>(FMALLOCALIGNED(sizeof(CvAStarNode*)*m_iColumns, 64, c_eCiv5GameplayDLL, 0));

	push	212					; 000000d4H
	mov	DWORD PTR [esi+40], ecx
	mov	ecx, DWORD PTR _iRows$[esp+44]
	xor	ebx, ebx
	mov	DWORD PTR [esi+36], eax
	mov	eax, DWORD PTR _iColumns$[esp+44]
	push	OFFSET $SG219413
	or	ebp, -1
	mov	BYTE PTR [esi+76], dl
	mov	DWORD PTR [esi+52], ecx
	mov	cl, BYTE PTR _bWrapY$[esp+48]
	lea	edx, DWORD PTR [eax*4]
	push	64					; 00000040H
	push	edx
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR [esi+56], ebp
	mov	DWORD PTR [esi+60], ebp
	mov	DWORD PTR [esi+64], ebp
	mov	DWORD PTR [esi+68], ebp
	mov	DWORD PTR [esi+72], ebx
	mov	BYTE PTR [esi+77], cl
	mov	BYTE PTR [esi+78], bl
	mov	DWORD PTR [esi+84], ebx
	mov	DWORD PTR [esi+88], ebx
	mov	DWORD PTR [esi+92], ebx
	mov	DWORD PTR [esi+96], ebx
	mov	DWORD PTR [esi+100], ebx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 213  : #endif
; 214  : 	for(iI = 0; iI < m_iColumns; iI++)

	xor	edi, edi
	cmp	DWORD PTR [esi+48], ebx
	mov	DWORD PTR [esi+104], eax
	jle	$LN4@Initialize
$LL6@Initialize:

; 215  : 	{
; 216  : #ifdef AUI_ASTAR_REMOVE_MALLOC
; 217  : 		m_ppaaNodes[iI] = FNEW(CvAStarNode[m_iRows], c_eCiv5GameplayDLL, 0);
; 218  : #else
; 219  : 		m_ppaaNodes[iI] = reinterpret_cast<CvAStarNode*>(FMALLOCALIGNED(sizeof(CvAStarNode)*m_iRows, 64, c_eCiv5GameplayDLL, 0));

	mov	eax, DWORD PTR [esi+52]
	push	219					; 000000dbH
	push	OFFSET $SG219419
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 5
	push	64					; 00000040H
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	ecx, DWORD PTR [esi+104]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx+edi*4], eax

; 220  : #endif
; 221  : 		for(iJ = 0; iJ < m_iRows; iJ++)

	xor	edx, edx
	cmp	DWORD PTR [esi+52], ebx
	jle	SHORT $LN5@Initialize

; 215  : 	{
; 216  : #ifdef AUI_ASTAR_REMOVE_MALLOC
; 217  : 		m_ppaaNodes[iI] = FNEW(CvAStarNode[m_iRows], c_eCiv5GameplayDLL, 0);
; 218  : #else
; 219  : 		m_ppaaNodes[iI] = reinterpret_cast<CvAStarNode*>(FMALLOCALIGNED(sizeof(CvAStarNode)*m_iRows, 64, c_eCiv5GameplayDLL, 0));

	xor	ecx, ecx
	npad	1
$LL3@Initialize:

; 222  : 		{
; 223  : #ifndef AUI_ASTAR_REMOVE_MALLOC
; 224  : 			new(&m_ppaaNodes[iI][iJ]) CvAStarNode();

	mov	eax, DWORD PTR [esi+104]
	mov	eax, DWORD PTR [eax+edi*4]
	add	eax, ecx
	je	SHORT $LN9@Initialize
	mov	DWORD PTR [eax+44], ebx
	mov	DWORD PTR [eax+48], 6
	lea	ebp, DWORD PTR [eax+52]
	mov	DWORD PTR [eax+40], ebp
	or	ebp, -1
	mov	WORD PTR [eax+80], bp
	or	ebp, ebp
	mov	WORD PTR [eax+82], bp
	xor	ebp, ebp
	mov	WORD PTR [eax+84], bp
	or	ebp, -1
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ebx
	mov	BYTE PTR [eax+86], bl
	mov	DWORD PTR [eax+20], ebp
	mov	DWORD PTR [eax+24], ebx
	mov	DWORD PTR [eax+28], ebx
	mov	DWORD PTR [eax+32], ebx
	mov	DWORD PTR [eax+36], ebx
$LN9@Initialize:

; 225  : #endif
; 226  : 			m_ppaaNodes[iI][iJ].m_iX = iI;

	mov	eax, DWORD PTR [esi+104]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	WORD PTR [eax+ecx+80], di

; 227  : 			m_ppaaNodes[iI][iJ].m_iY = iJ;

	mov	eax, DWORD PTR [esi+104]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	WORD PTR [eax+ecx+82], dx
	inc	edx
	add	ecx, 96					; 00000060H
	cmp	edx, DWORD PTR [esi+52]
	mov	DWORD PTR __$EHRec$[esp+52], ebp
	jl	SHORT $LL3@Initialize
$LN5@Initialize:

; 213  : #endif
; 214  : 	for(iI = 0; iI < m_iColumns; iI++)

	inc	edi
	cmp	edi, DWORD PTR [esi+48]
	jl	$LL6@Initialize
$LN4@Initialize:

; 228  : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 229  : 			m_ppaaNodes[iI][iJ].m_pPlot = GC.getMap().plot(iI, iJ);
; 230  : #endif
; 231  : 		}
; 232  : 	}
; 233  : 
; 234  : #ifdef AUI_ASTAR_PRECALCULATE_NEIGHBORS_ON_INITIALIZE
; 235  : 	for (iI = 0; iI < m_iColumns; iI++)
; 236  : 		for (iJ = 0; iJ < m_iRows; iJ++)
; 237  : 			PrecalcNeighbors(&(m_ppaaNodes[iI][iJ]));
; 238  : #endif
; 239  : 
; 240  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 241  : 	m_bIsMultiplayer = GC.getGame().isNetworkMultiPlayer();
; 242  : #endif
; 243  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	64					; 00000040H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z$0:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _iJ$[ebp]
	imul	edx, 96					; 00000060H
	mov	eax, DWORD PTR _iI$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR $T227883[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z:
	mov	eax, OFFSET __ehfuncinfo$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ENDP ; CvAStar::Initialize
PUBLIC	?LinkChild@CvAStar@@IAEXPAVCvAStarNode@@0@Z	; CvAStar::LinkChild
; Function compile flags: /Ogtpy
;	COMDAT ?LinkChild@CvAStar@@IAEXPAVCvAStarNode@@0@Z
_TEXT	SEGMENT
_node$ = 8						; size = 4
_check$ = 12						; size = 4
?LinkChild@CvAStar@@IAEXPAVCvAStarNode@@0@Z PROC	; CvAStar::LinkChild, COMDAT
; _this$ = ecx

; 607  : {

	push	ebx
	push	ebp

; 608  : #if defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 609  : 	int iKnownCost = node->m_iKnownCost + udFunc(udCost, node, check, 0, m_pData);
; 610  : #else
; 611  : 	int iKnownCost;
; 612  : 
; 613  : 	iKnownCost = node->m_iKnownCost + udFunc(udCost, node, check, 0, m_pData);

	mov	ebp, DWORD PTR _node$[esp+4]
	push	esi
	mov	esi, DWORD PTR _check$[esp+8]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi+44]
	test	eax, eax
	je	SHORT $LN13@LinkChild
	push	edi
	push	ecx
	push	0
	push	esi
	push	ebp
	call	eax
	add	esp, 20					; 00000014H
	jmp	SHORT $LN14@LinkChild
$LN13@LinkChild:
	mov	eax, 1
$LN14@LinkChild:
	mov	ebx, DWORD PTR [ebp+4]
	add	ebx, eax

; 614  : #endif
; 615  : 
; 616  : 	if(check->m_eCvAStarListType == CVASTARLIST_OPEN)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	jne	SHORT $LN8@LinkChild

; 617  : 	{
; 618  : 		node->m_apChildren.push_back(check);

	lea	ecx, DWORD PTR [ebp+40]
	mov	BYTE PTR [ecx+36], al
	mov	eax, DWORD PTR [ecx+8]
	cmp	DWORD PTR [ecx+4], eax
	jne	SHORT $LN15@LinkChild
	push	eax
	call	?GrowSize@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvAStarNode *,6,1,297,0>::GrowSize
$LN15@LinkChild:
	mov	eax, DWORD PTR [ebp+44]
	mov	ecx, DWORD PTR [ebp+40]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN18@LinkChild
	mov	DWORD PTR [eax], esi
$LN18@LinkChild:
	mov	eax, 1
	add	DWORD PTR [ebp+44], eax

; 619  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 620  : 		node->m_iNumChildren++;

	add	WORD PTR [ebp+84], ax

; 621  : #endif
; 622  : 
; 623  : 		if(iKnownCost < check->m_iKnownCost)

	cmp	ebx, DWORD PTR [esi+4]
	jge	$LN3@LinkChild

; 624  : 		{
; 625  : 			FAssert(node->m_pParent != check);
; 626  : 
; 627  : 			check->m_pParent = node;
; 628  : 			check->m_iKnownCost = iKnownCost;
; 629  : 			check->m_iTotalCost = iKnownCost + check->m_iHeuristicCost;

	mov	edx, DWORD PTR [esi+8]
	add	edx, ebx

; 630  : 
; 631  : 			UpdateOpenNode(check);

	push	esi
	mov	ecx, edi
	mov	DWORD PTR [esi+24], ebp
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi], edx
	call	?UpdateOpenNode@CvAStar@@IAEXPAVCvAStarNode@@@Z ; CvAStar::UpdateOpenNode

; 632  : 			udFunc(udNotifyChild, node, check, ASNC_OPENADD_UP, m_pData);

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	$LN3@LinkChild
	mov	ecx, DWORD PTR [edi+44]
	push	edi
	push	ecx
	push	1
	push	esi
	push	ebp
	call	eax
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 676  : #endif
; 677  : 	}
; 678  : }

	ret	8
$LN8@LinkChild:

; 633  : 		}
; 634  : 	}
; 635  : 	else if(check->m_eCvAStarListType == CVASTARLIST_CLOSED)

	cmp	eax, 1
	jne	SHORT $LN5@LinkChild

; 636  : 	{
; 637  : 		node->m_apChildren.push_back(check);

	mov	eax, DWORD PTR [ebp+48]
	lea	ecx, DWORD PTR [ebp+40]
	mov	BYTE PTR [ecx+36], 0
	cmp	DWORD PTR [ecx+4], eax
	jne	SHORT $LN26@LinkChild
	push	eax
	call	?GrowSize@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvAStarNode *,6,1,297,0>::GrowSize
$LN26@LinkChild:
	mov	edx, DWORD PTR [ebp+44]
	mov	eax, DWORD PTR [ebp+40]
	lea	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	je	SHORT $LN29@LinkChild
	mov	DWORD PTR [eax], esi
$LN29@LinkChild:
	mov	eax, 1
	add	DWORD PTR [ebp+44], eax

; 638  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 639  : 		node->m_iNumChildren++;

	add	WORD PTR [ebp+84], ax

; 640  : #endif
; 641  : 
; 642  : 		if(iKnownCost < check->m_iKnownCost)

	cmp	ebx, DWORD PTR [esi+4]
	jge	$LN3@LinkChild

; 643  : 		{
; 644  : 			FAssert(node->m_pParent != check);
; 645  : 			check->m_pParent = node;
; 646  : 			check->m_iKnownCost = iKnownCost;
; 647  : 			check->m_iTotalCost = iKnownCost + check->m_iHeuristicCost;

	mov	ecx, DWORD PTR [esi+8]
	add	ecx, ebx
	mov	DWORD PTR [esi+24], ebp
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi], ecx

; 648  : 			udFunc(udNotifyChild, node, check, ASNC_CLOSEDADD_UP, m_pData);

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN35@LinkChild
	mov	edx, DWORD PTR [edi+44]
	push	edi
	push	edx
	push	2
	push	esi
	push	ebp
	call	eax
	add	esp, 20					; 00000014H
$LN35@LinkChild:

; 649  : 
; 650  : 			UpdateParents(check);

	push	esi
	mov	ecx, edi
	call	?UpdateParents@CvAStar@@IAEXPAVCvAStarNode@@@Z ; CvAStar::UpdateParents
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 676  : #endif
; 677  : 	}
; 678  : }

	ret	8
$LN5@LinkChild:

; 651  : 		}
; 652  : 	}
; 653  : 	else
; 654  : 	{
; 655  : 		FAssert(check->m_eCvAStarListType == NO_CVASTARLIST);
; 656  : 		FAssert(node->m_pParent != check);
; 657  : 		check->m_pParent = node;

	mov	DWORD PTR [esi+24], ebp

; 658  : 		check->m_iKnownCost = iKnownCost;

	mov	DWORD PTR [esi+4], ebx

; 659  : 		if(udHeuristic == NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	jne	SHORT $LN2@LinkChild

; 660  : 		{
; 661  : 			check->m_iHeuristicCost = 0;

	mov	DWORD PTR [esi+8], eax

; 662  : 		}
; 663  : 		else

	jmp	SHORT $LN1@LinkChild
$LN2@LinkChild:

; 664  : 		{
; 665  : 			check->m_iHeuristicCost = udHeuristic(check->m_iX, check->m_iY, m_iXdest, m_iYdest);

	mov	ecx, DWORD PTR [edi+68]
	mov	edx, DWORD PTR [edi+64]
	push	ecx
	movsx	ecx, WORD PTR [esi+82]
	push	edx
	movsx	edx, WORD PTR [esi+80]
	push	ecx
	push	edx
	call	eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], eax
$LN1@LinkChild:

; 666  : 		}
; 667  : 		check->m_iTotalCost = check->m_iKnownCost + check->m_iHeuristicCost;

	mov	eax, DWORD PTR [esi+8]
	add	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax

; 668  : 
; 669  : 		udFunc(udNotifyChild, node, check, ASNC_NEWADD, m_pData);

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN39@LinkChild
	mov	ecx, DWORD PTR [edi+44]
	push	edi
	push	ecx
	push	4
	push	esi
	push	ebp
	call	eax
	add	esp, 20					; 00000014H
$LN39@LinkChild:

; 670  : 
; 671  : 		AddToOpen(check);

	push	esi
	mov	ecx, edi
	call	?AddToOpen@CvAStar@@QAEXPAVCvAStarNode@@@Z ; CvAStar::AddToOpen

; 672  : 
; 673  : 		node->m_apChildren.push_back(check);

	mov	eax, DWORD PTR [ebp+48]
	lea	edi, DWORD PTR [ebp+40]
	mov	BYTE PTR [edi+36], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN41@LinkChild
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvAStarNode *,6,1,297,0>::GrowSize
$LN41@LinkChild:
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	je	SHORT $LN44@LinkChild
	mov	DWORD PTR [eax], esi
$LN44@LinkChild:
	mov	eax, 1
	add	DWORD PTR [edi+4], eax

; 674  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 675  : 		node->m_iNumChildren++;

	add	WORD PTR [ebp+84], ax
$LN3@LinkChild:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 676  : #endif
; 677  : 	}
; 678  : }

	ret	8
?LinkChild@CvAStar@@IAEXPAVCvAStarNode@@0@Z ENDP	; CvAStar::LinkChild
_TEXT	ENDS
PUBLIC	??_ECvAStarNode@@QAEPAXI@Z			; CvAStarNode::`vector deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_ECvAStarNode@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECvAStarNode@@QAEPAXI@Z PROC				; CvAStarNode::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1CvAStarNode@@QAE@XZ
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	96					; 00000060H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector:
	mov	eax, DWORD PTR [esi+40]
	lea	ecx, DWORD PTR [esi+52]
	cmp	eax, ecx
	je	SHORT $LN11@vector
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN11@vector:
	test	bl, 1
	je	SHORT $LN1@vector
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_ECvAStarNode@@QAEPAXI@Z ENDP				; CvAStarNode::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?CopyPath@CvAStar@@SAXPBVCvAStarNode@@AAVCvPathNodeArray@@@Z ; CvAStar::CopyPath
; Function compile flags: /Ogtpy
;	COMDAT ?CopyPath@CvAStar@@SAXPBVCvAStarNode@@AAVCvPathNodeArray@@@Z
_TEXT	SEGMENT
$T228110 = 8						; size = 4
_pkEndNode$ = 8						; size = 4
_kPathArray$ = 12					; size = 4
?CopyPath@CvAStar@@SAXPBVCvAStarNode@@AAVCvPathNodeArray@@@Z PROC ; CvAStar::CopyPath, COMDAT

; 6016 : {

	push	ebp
	push	esi

; 6017 : 	if(pkEndNode != NULL)

	mov	esi, DWORD PTR _pkEndNode$[esp+4]
	xor	ebp, ebp
	cmp	esi, ebp
	je	$LN6@CopyPath

; 6018 : 	{
; 6019 : 		const CvAStarNode* pkNode = pkEndNode;
; 6020 : 
; 6021 : 		// Count the number of nodes
; 6022 : 		uint uiNodeCount = 1;
; 6023 : 
; 6024 : 		while(pkNode->m_pParent != NULL)

	mov	eax, DWORD PTR [esi+24]
	push	ebx
	push	edi
	lea	ebx, DWORD PTR [ebp+1]
	cmp	eax, ebp
	je	SHORT $LN4@CopyPath
	npad	4
$LL5@CopyPath:
	mov	eax, DWORD PTR [eax+24]

; 6025 : 		{
; 6026 : 			++uiNodeCount;

	inc	ebx
	cmp	eax, ebp
	jne	SHORT $LL5@CopyPath
$LN4@CopyPath:

; 6027 : 			pkNode = pkNode->m_pParent;
; 6028 : 		}
; 6029 : 
; 6030 : 		kPathArray.setsize(uiNodeCount);

	mov	edi, DWORD PTR _kPathArray$[esp+12]
	push	ebx
	mov	ecx, edi
	mov	DWORD PTR $T228110[esp+16], ebx
	call	?SetSize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXI@Z ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::SetSize
	cmp	DWORD PTR [edi+8], ebx
	lea	eax, DWORD PTR [edi+8]
	jb	SHORT $LN14@CopyPath
	lea	eax, DWORD PTR $T228110[esp+12]
$LN14@CopyPath:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edi+4], eax

; 6031 : 
; 6032 : 		pkNode = pkEndNode;
; 6033 : 		kPathArray[0] = *pkNode;

	mov	cx, WORD PTR [esi+80]
	mov	eax, DWORD PTR [edi]
	mov	WORD PTR [eax+12], cx
	mov	dx, WORD PTR [esi+82]
	mov	WORD PTR [eax+14], dx
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ebp

; 6034 : 
; 6035 : 		uint uiIndex = 1;
; 6036 : 		while(pkNode->m_pParent != NULL)

	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, ebp
	je	SHORT $LN33@CopyPath

; 6027 : 			pkNode = pkNode->m_pParent;
; 6028 : 		}
; 6029 : 
; 6030 : 		kPathArray.setsize(uiNodeCount);

	mov	edx, 16					; 00000010H
$LL3@CopyPath:

; 6037 : 		{
; 6038 : 			pkNode = pkNode->m_pParent;
; 6039 : 			kPathArray[uiIndex++] = *pkNode;

	movzx	esi, WORD PTR [ecx+80]
	mov	eax, DWORD PTR [edi]
	add	eax, edx
	mov	WORD PTR [eax+12], si
	movzx	esi, WORD PTR [ecx+82]
	mov	WORD PTR [eax+14], si
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], ebp
	mov	ecx, DWORD PTR [ecx+24]
	add	edx, 16					; 00000010H
	cmp	ecx, ebp
	jne	SHORT $LL3@CopyPath
$LN33@CopyPath:
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 6044 : }

	ret	0
$LN6@CopyPath:

; 6040 : 		}
; 6041 : 	}
; 6042 : 	else
; 6043 : 		kPathArray.setsize(0);	// Setting the size to 0 rather than clearing so that the array data is not deleted.  Helps with memory thrashing.

	mov	esi, DWORD PTR _kPathArray$[esp+4]
	push	ebp
	mov	ecx, esi
	call	?SetSize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXI@Z ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::SetSize
	mov	DWORD PTR [esi+4], ebp
	pop	esi
	pop	ebp

; 6044 : }

	ret	0
?CopyPath@CvAStar@@SAXPBVCvAStarNode@@AAVCvPathNodeArray@@@Z ENDP ; CvAStar::CopyPath
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@VCvAStarNode@@@@YAXAAPAVCvAStarNode@@@Z ; SAFE_DELETE_ARRAY<CvAStarNode>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@VCvAStarNode@@@@YAXAAPAVCvAStarNode@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@VCvAStarNode@@@@YAXAAPAVCvAStarNode@@@Z PROC ; SAFE_DELETE_ARRAY<CvAStarNode>, COMDAT

; 311  : {

	push	edi

; 312  : 	delete[] pkInstanceArray;

	mov	edi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN27@SAFE_DELET
	mov	ecx, DWORD PTR [eax-4]
	push	esi
	lea	esi, DWORD PTR [eax-4]
	push	OFFSET ??1CvAStarNode@@QAE@XZ
	push	ecx
	push	96					; 00000060H
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	esi
$LN27@SAFE_DELET:

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@VCvAStarNode@@@@YAXAAPAVCvAStarNode@@@Z ENDP ; SAFE_DELETE_ARRAY<CvAStarNode>
_TEXT	ENDS
PUBLIC	?CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z	; CvAStar::CreateChildren
;	COMDAT ?s_CvAStarChildHexY@?1??CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z@4PAHA
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.h
_DATA	SEGMENT
?s_CvAStarChildHexY@?1??CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z@4PAHA DD 01H ; `CvAStar::CreateChildren'::`2'::s_CvAStarChildHexY
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	01H
_DATA	ENDS
;	COMDAT ?s_CvAStarChildHexX@?1??CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z@4PAHA
_DATA	SEGMENT
?s_CvAStarChildHexX@?1??CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z@4PAHA DD 00H ; `CvAStar::CreateChildren'::`2'::s_CvAStarChildHexX
	DD	01H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
_DATA	ENDS
;	COMDAT ?CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z
_TEXT	SEGMENT
_y$ = -8						; size = 4
_x$ = -4						; size = 4
tv515 = 8						; size = 4
_iExtraChildren$219510 = 8				; size = 4
_node$ = 8						; size = 4
?CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z PROC	; CvAStar::CreateChildren, COMDAT
; _this$ = ecx

; 553  : {

	sub	esp, 8
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _node$[esp+12]
	push	esi

; 554  : 	CvAStarNode* check;
; 555  : 	int range = 6;
; 556  : 	int x, y;
; 557  : 	int i;
; 558  : 
; 559  : 	static int s_CvAStarChildHexX[6] = { 0, 1,  1,  0, -1, -1, };
; 560  : 	static int s_CvAStarChildHexY[6] = { 1, 0, -1, -1,  0,  1, };
; 561  : 
; 562  : 	for(i = 0; i < range; i++)

	xor	ebx, ebx
	push	edi
	mov	esi, ecx
	mov	DWORD PTR tv515[esp+20], ebx
	jmp	SHORT $LN11@CreateChil
$LL62@CreateChil:
	mov	ebx, DWORD PTR tv515[esp+20]
$LN11@CreateChil:

; 563  : 	{
; 564  : 		x = node->m_iX - ((node->m_iY >= 0) ? (node->m_iY>>1) : ((node->m_iY - 1)/2));

	movzx	eax, WORD PTR [ebp+82]
	movsx	edi, ax
	test	ax, ax
	jl	SHORT $LN14@CreateChil
	mov	eax, edi
	jmp	SHORT $LN63@CreateChil
$LN14@CreateChil:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN63@CreateChil:

; 565  : 		x += s_CvAStarChildHexX[i];

	movsx	edx, WORD PTR [ebp+80]
	mov	ecx, DWORD PTR ?s_CvAStarChildHexX@?1??CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z@4PAHA[ebx]
	sar	eax, 1
	add	ecx, edx
	sub	ecx, eax

; 566  : 		y = yRange(node->m_iY + s_CvAStarChildHexY[i]);

	mov	eax, DWORD PTR ?s_CvAStarChildHexY@?1??CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z@4PAHA[ebx]
	add	eax, edi
	cmp	BYTE PTR [esi+77], 0
	je	SHORT $LN23@CreateChil
	test	eax, eax
	jge	SHORT $LN22@CreateChil
	mov	ebx, DWORD PTR [esi+52]
	cdq
	idiv	ebx
	mov	edi, edx
	add	edi, ebx
	jmp	SHORT $LN18@CreateChil
$LN22@CreateChil:
	mov	edi, DWORD PTR [esi+52]
	cmp	eax, edi
	jl	SHORT $LN23@CreateChil
	cdq
	idiv	edi
	mov	edi, edx
	jmp	SHORT $LN18@CreateChil
$LN23@CreateChil:
	mov	edi, eax
$LN18@CreateChil:
	mov	DWORD PTR _y$[esp+24], edi

; 567  : 		x += ((y >= 0) ? (y>>1) : ((y - 1)/2));

	test	edi, edi
	jl	SHORT $LN16@CreateChil
	mov	eax, edi
	jmp	SHORT $LN64@CreateChil
$LN16@CreateChil:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN64@CreateChil:
	sar	eax, 1
	add	ecx, eax

; 568  : 		x = xRange(x);

	cmp	BYTE PTR [esi+76], 0
	je	SHORT $LN31@CreateChil
	mov	ebx, DWORD PTR [esi+48]
	test	ecx, ecx
	jge	SHORT $LN30@CreateChil
	mov	eax, ecx
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN26@CreateChil
$LN30@CreateChil:
	cmp	ecx, ebx
	jl	SHORT $LN31@CreateChil
	mov	eax, ecx
	cdq
	idiv	ebx
	jmp	SHORT $LN26@CreateChil
$LN31@CreateChil:
	mov	edx, ecx
$LN26@CreateChil:

; 569  : 
; 570  : 		PREFETCH_FASTAR_NODE(&(m_ppaaNodes[x][y]));

	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR _x$[esp+24], edx
	mov	eax, DWORD PTR [eax+edx*4]
	lea	ecx, DWORD PTR [edi+edi*2]
	shl	ecx, 5
	prefetcht0 BYTE PTR [eax+ecx]
	prefetcht0 BYTE PTR [eax+ecx+64]
	lea	ebx, DWORD PTR [eax+ecx]

; 571  : 		if(isValid(x, y))

	test	edx, edx
	jl	SHORT $LN10@CreateChil
	cmp	edx, DWORD PTR [esi+48]
	jge	SHORT $LN10@CreateChil
	test	edi, edi
	jl	SHORT $LN10@CreateChil
	cmp	edi, DWORD PTR [esi+52]
	jge	SHORT $LN10@CreateChil

; 572  : 		{
; 573  : 			check = &(m_ppaaNodes[x][y]);
; 574  : 
; 575  : 			if(udFunc(udValid, node, check, 0, m_pData))

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN59@CreateChil
	push	esi
	push	ecx
	push	0
	push	ebx
	push	ebp
	call	eax
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN10@CreateChil
$LN59@CreateChil:

; 576  : 			{
; 577  : 				LinkChild(node, check);

	push	ebx
	push	ebp
	mov	ecx, esi
	call	?LinkChild@CvAStar@@IAEXPAVCvAStarNode@@0@Z ; CvAStar::LinkChild
$LN10@CreateChil:
	mov	eax, DWORD PTR tv515[esp+20]
	add	eax, 4
	cmp	eax, 24					; 00000018H
	mov	DWORD PTR tv515[esp+20], eax
	jl	$LL62@CreateChil

; 578  : 			}
; 579  : 		}
; 580  : 	}
; 581  : 
; 582  : 	if(udNumExtraChildrenFunc && udGetExtraChildFunc)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	$LN3@CreateChil
	cmp	DWORD PTR [esi+32], 0
	je	$LN3@CreateChil

; 583  : 	{
; 584  : 		int iExtraChildren = udNumExtraChildrenFunc(node, this);

	push	esi
	push	ebp
	call	eax
	add	esp, 8

; 585  : 		for(int i = 0; i < iExtraChildren; i++)

	xor	ebx, ebx
	mov	DWORD PTR _iExtraChildren$219510[esp+20], eax
	test	eax, eax
	jle	SHORT $LN3@CreateChil
$LL5@CreateChil:

; 586  : 		{
; 587  : 			udGetExtraChildFunc(node, i, x, y, this);

	mov	eax, DWORD PTR [esi+32]
	push	esi
	lea	ecx, DWORD PTR _y$[esp+28]
	push	ecx
	lea	edx, DWORD PTR _x$[esp+32]
	push	edx
	push	ebx
	push	ebp
	call	eax

; 588  : 			PREFETCH_FASTAR_NODE(&(m_ppaaNodes[x][y]));

	mov	eax, DWORD PTR _y$[esp+44]
	mov	ecx, DWORD PTR _x$[esp+44]
	mov	edx, DWORD PTR [esi+104]
	mov	edx, DWORD PTR [edx+ecx*4]
	lea	edi, DWORD PTR [eax+eax*2]
	shl	edi, 5
	prefetcht0 BYTE PTR [edi+edx]
	prefetcht0 BYTE PTR [edi+edx+64]
	add	edi, edx
	add	esp, 20					; 00000014H

; 589  : 
; 590  : 			if(isValid(x, y))

	test	ecx, ecx
	jl	SHORT $LN4@CreateChil
	cmp	ecx, DWORD PTR [esi+48]
	jge	SHORT $LN4@CreateChil
	test	eax, eax
	jl	SHORT $LN4@CreateChil
	cmp	eax, DWORD PTR [esi+52]
	jge	SHORT $LN4@CreateChil

; 591  : 			{
; 592  : 				check = &(m_ppaaNodes[x][y]);
; 593  : 
; 594  : 				if(udFunc(udValid, node, check, 0, m_pData))

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN61@CreateChil
	push	esi
	push	ecx
	push	0
	push	edi
	push	ebp
	call	eax
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN4@CreateChil
$LN61@CreateChil:

; 595  : 				{
; 596  : 					LinkChild(node, check);

	push	edi
	push	ebp
	mov	ecx, esi
	call	?LinkChild@CvAStar@@IAEXPAVCvAStarNode@@0@Z ; CvAStar::LinkChild
$LN4@CreateChil:
	inc	ebx
	cmp	ebx, DWORD PTR _iExtraChildren$219510[esp+20]
	jl	SHORT $LL5@CreateChil
$LN3@CreateChil:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 597  : 				}
; 598  : 			}
; 599  : 		}
; 600  : 	}
; 601  : }

	add	esp, 8
	ret	4
?CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z ENDP	; CvAStar::CreateChildren
_TEXT	ENDS
PUBLIC	?DeInit@CvTwoLayerPathFinder@@QAEXXZ		; CvTwoLayerPathFinder::DeInit
; Function compile flags: /Ogtpy
;	COMDAT ?DeInit@CvTwoLayerPathFinder@@QAEXXZ
_TEXT	SEGMENT
?DeInit@CvTwoLayerPathFinder@@QAEXXZ PROC		; CvTwoLayerPathFinder::DeInit, COMDAT
; _this$ = ecx

; 4044 : {

	push	edi
	mov	edi, ecx

; 4045 : 	CvAStar::DeInit();

	call	?DeInit@CvAStar@@QAEXXZ			; CvAStar::DeInit

; 4046 : 
; 4047 : 	if(m_ppaaPartialMoveNodes != NULL)

	cmp	DWORD PTR [edi+628], 0
	je	SHORT $LN33@DeInit@2
	push	esi

; 4048 : 	{
; 4049 : 		for(int iI = 0; iI < m_iColumns; iI++)

	xor	esi, esi
	cmp	DWORD PTR [edi+48], esi
	jle	SHORT $LN1@DeInit@2
	push	ebx
	push	ebp
	npad	5
$LL3@DeInit@2:
	mov	eax, DWORD PTR [edi+628]
	lea	ebx, DWORD PTR [eax+esi*4]

; 4050 : 		{
; 4051 : 			SAFE_DELETE_ARRAY(m_ppaaPartialMoveNodes[iI]);

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN9@DeInit@2
	mov	ecx, DWORD PTR [eax-4]
	lea	ebp, DWORD PTR [eax-4]
	push	OFFSET ??1CvAStarNode@@QAE@XZ
	push	ecx
	push	96					; 00000060H
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	ebp
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN9@DeInit@2:
	inc	esi
	mov	DWORD PTR [ebx], 0
	cmp	esi, DWORD PTR [edi+48]
	jl	SHORT $LL3@DeInit@2
	pop	ebp
	pop	ebx
$LN1@DeInit@2:

; 4052 : 		}
; 4053 : 
; 4054 : 		SAFE_DELETE_ARRAY(m_ppaaPartialMoveNodes);

	mov	edx, DWORD PTR [edi+628]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [edi+628], 0
	pop	esi
$LN33@DeInit@2:
	pop	edi

; 4055 : 	}
; 4056 : }

	ret	0
?DeInit@CvTwoLayerPathFinder@@QAEXXZ ENDP		; CvTwoLayerPathFinder::DeInit
_TEXT	ENDS
PUBLIC	?Step@CvAStar@@IAEHXZ				; CvAStar::Step
; Function compile flags: /Ogtpy
;	COMDAT ?Step@CvAStar@@IAEHXZ
_TEXT	SEGMENT
?Step@CvAStar@@IAEHXZ PROC				; CvAStar::Step, COMDAT
; _this$ = ecx

; 420  : {

	push	esi
	mov	esi, ecx

; 421  : 	if((m_pBest = GetBest()) == NULL)

	call	?GetBest@CvAStar@@IAEPAVCvAStarNode@@XZ	; CvAStar::GetBest
	mov	DWORD PTR [esi+96], eax
	test	eax, eax
	jne	SHORT $LN3@Step
$LN10@Step:

; 422  : 	{
; 423  : 		return -1;

	or	eax, -1
	pop	esi

; 437  : }

	ret	0
$LN3@Step:

; 424  : 	}
; 425  : 
; 426  : 	CreateChildren(m_pBest); // needs to be done, even on the last node, to allow for re-use...

	push	eax
	mov	ecx, esi
	call	?CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z ; CvAStar::CreateChildren

; 427  : 
; 428  : 	if (m_pBest == NULL)	// There seems to be a case were this will come back NULL.

	mov	eax, DWORD PTR [esi+96]
	test	eax, eax

; 429  : 		return -1;

	je	SHORT $LN10@Step

; 430  : 
; 431  : 	if(IsPathDest(m_pBest->m_iX, m_pBest->m_iY))

	movsx	ecx, WORD PTR [eax+82]
	movsx	edx, WORD PTR [eax+80]
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@Step
	push	esi
	mov	esi, DWORD PTR [esi+44]
	push	esi
	push	ecx
	push	edx
	call	eax
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@Step

; 432  : 	{
; 433  : 		return 1;

	mov	eax, 1
	pop	esi

; 437  : }

	ret	0
$LN1@Step:

; 434  : 	}
; 435  : 
; 436  : 	return 0;

	xor	eax, eax
	pop	esi

; 437  : }

	ret	0
?Step@CvAStar@@IAEHXZ ENDP				; CvAStar::Step
_TEXT	ENDS
PUBLIC	??1CvTwoLayerPathFinder@@QAE@XZ			; CvTwoLayerPathFinder::~CvTwoLayerPathFinder
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvTwoLayerPathFinder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTwoLayerPathFinder@@QAE@XZ$0
__ehfuncinfo$??1CvTwoLayerPathFinder@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvTwoLayerPathFinder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvTwoLayerPathFinder@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTwoLayerPathFinder@@QAE@XZ PROC			; CvTwoLayerPathFinder::~CvTwoLayerPathFinder, COMDAT
; _this$ = ecx

; 4010 : {

	push	-1
	push	__ehhandler$??1CvTwoLayerPathFinder@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR __$EHRec$[esp+28], 0

; 4011 : 	CvAStar::DeInit();

	call	?DeInit@CvAStar@@QAEXXZ			; CvAStar::DeInit

; 4012 : 
; 4013 : 	DeInit();

	mov	ecx, esi
	call	?DeInit@CvTwoLayerPathFinder@@QAEXXZ	; CvTwoLayerPathFinder::DeInit

; 4014 : }

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	?DeInit@CvAStar@@QAEXXZ			; CvAStar::DeInit
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTwoLayerPathFinder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
__ehhandler$??1CvTwoLayerPathFinder@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvTwoLayerPathFinder@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTwoLayerPathFinder@@QAE@XZ ENDP			; CvTwoLayerPathFinder::~CvTwoLayerPathFinder
PUBLIC	?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z ; CvTwoLayerPathFinder::Initialize
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z$0
__ehfuncinfo$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_iColumns$ = 8						; size = 4
_iRows$ = 12						; size = 4
_bWrapX$ = 16						; size = 1
_bWrapY$ = 20						; size = 1
_IsPathDestFunc$ = 24					; size = 4
_DestValidFunc$ = 28					; size = 4
_HeuristicFunc$ = 32					; size = 4
_CostFunc$ = 36						; size = 4
_ValidFunc$ = 40					; size = 4
_NotifyChildFunc$ = 44					; size = 4
_NotifyListFunc$ = 48					; size = 4
_InitializeFunc$ = 52					; size = 4
_UninitializeFunc$ = 56					; size = 4
$T228477 = 60						; size = 4
_pData$ = 60						; size = 4
?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z PROC ; CvTwoLayerPathFinder::Initialize, COMDAT
; _this$ = ecx

; 4019 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx

; 4020 : 	int iI, iJ;
; 4021 : 
; 4022 : 	DeInit();

	call	?DeInit@CvTwoLayerPathFinder@@QAEXXZ	; CvTwoLayerPathFinder::DeInit

; 4023 : 
; 4024 : 	CvAStar::Initialize(iColumns, iRows, bWrapX, bWrapY, IsPathDestFunc, DestValidFunc, HeuristicFunc, CostFunc, ValidFunc, NotifyChildFunc, NotifyListFunc, NULL, NULL, InitializeFunc, UninitializeFunc, pData);

	mov	eax, DWORD PTR _pData$[esp+24]
	mov	ecx, DWORD PTR _UninitializeFunc$[esp+24]
	mov	edx, DWORD PTR _InitializeFunc$[esp+24]
	push	eax
	mov	eax, DWORD PTR _NotifyListFunc$[esp+28]
	push	ecx
	mov	ecx, DWORD PTR _NotifyChildFunc$[esp+32]
	push	edx
	mov	edx, DWORD PTR _ValidFunc$[esp+36]
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR _CostFunc$[esp+48]
	push	ecx
	mov	ecx, DWORD PTR _HeuristicFunc$[esp+52]
	push	edx
	mov	edx, DWORD PTR _DestValidFunc$[esp+56]
	push	eax
	mov	eax, DWORD PTR _IsPathDestFunc$[esp+60]
	push	ecx
	mov	ecx, DWORD PTR _bWrapY$[esp+64]
	push	edx
	mov	edx, DWORD PTR _bWrapX$[esp+68]
	push	eax
	mov	eax, DWORD PTR _iRows$[esp+72]
	push	ecx
	mov	ecx, DWORD PTR _iColumns$[esp+76]
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 4025 : 
; 4026 : 	m_ppaaPartialMoveNodes = FNEW(CvAStarNode*[m_iColumns], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR [esi+48]
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 4027 : 	for(iI = 0; iI < m_iColumns; iI++)

	xor	edi, edi
	add	esp, 4
	cmp	DWORD PTR [esi+48], edi
	mov	DWORD PTR [esi+628], eax
	jle	$LN4@Initialize@2
	npad	2
$LL16@Initialize@2:

; 4028 : 	{
; 4029 : 		m_ppaaPartialMoveNodes[iI] = FNEW(CvAStarNode[m_iRows], c_eCiv5GameplayDLL, 0);

	mov	ebp, DWORD PTR [esi+52]
	xor	ecx, ecx
	mov	eax, ebp
	mov	edx, 96					; 00000060H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T228477[esp+24], eax
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	cmp	eax, ebx
	je	SHORT $LN9@Initialize@2
	push	OFFSET ??1CvAStarNode@@QAE@XZ
	push	OFFSET ??0CvAStarNode@@QAE@XZ		; CvAStarNode::CvAStarNode
	push	ebp
	lea	ebx, DWORD PTR [eax+4]
	push	96					; 00000060H
	push	ebx
	mov	DWORD PTR [eax], ebp
	call	??_L@YGXPAXIHP6EX0@Z1@Z
$LN9@Initialize@2:
	mov	ecx, DWORD PTR [esi+628]

; 4030 : 		for(iJ = 0; iJ < m_iRows; iJ++)

	xor	eax, eax
	mov	DWORD PTR [ecx+edi*4], ebx
	cmp	DWORD PTR [esi+52], eax
	mov	DWORD PTR __$EHRec$[esp+36], -1
	jle	SHORT $LN5@Initialize@2

; 4028 : 	{
; 4029 : 		m_ppaaPartialMoveNodes[iI] = FNEW(CvAStarNode[m_iRows], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	npad	6
$LL3@Initialize@2:

; 4031 : 		{
; 4032 : 			m_ppaaPartialMoveNodes[iI][iJ].m_iX = iI;

	mov	edx, DWORD PTR [esi+628]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	WORD PTR [edx+ecx+80], di

; 4033 : 			m_ppaaPartialMoveNodes[iI][iJ].m_iY = iJ;

	mov	edx, DWORD PTR [esi+628]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	WORD PTR [edx+ecx+82], ax
	inc	eax
	add	ecx, 96					; 00000060H
	cmp	eax, DWORD PTR [esi+52]
	jl	SHORT $LL3@Initialize@2
$LN5@Initialize@2:

; 4027 : 	for(iI = 0; iI < m_iColumns; iI++)

	inc	edi
	cmp	edi, DWORD PTR [esi+48]
	jl	$LL16@Initialize@2
$LN4@Initialize@2:

; 4034 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4035 : 			m_ppaaPartialMoveNodes[iI][iJ].m_pPlot = GC.getMap().plot(iI, iJ);
; 4036 : #endif
; 4037 : 		}
; 4038 : 	}
; 4039 : };

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	56					; 00000038H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z$0:
	mov	eax, DWORD PTR $T228477[ebp-4]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z:
	mov	eax, OFFSET __ehfuncinfo$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z ENDP ; CvTwoLayerPathFinder::Initialize
PUBLIC	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z		; CvAStar::GeneratePath
EXTRN	?isNetworkMultiPlayer@CvGame@@QBE_NXZ:PROC	; CvGame::isNetworkMultiPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z
_TEXT	SEGMENT
_iXstart$ = 8						; size = 4
_iYstart$ = 12						; size = 4
_iXdest$ = 16						; size = 4
_iYdest$ = 20						; size = 4
_iInfo$ = 24						; size = 4
_bReuse$ = 28						; size = 1
?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z PROC		; CvAStar::GeneratePath, COMDAT
; _this$ = ecx

; 248  : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 249  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 250  : 	bool discardCacheForMPGame = m_bIsMultiplayer && !m_bIsMPCacheSafe;
; 251  : #else
; 252  : 	CvAStarNode* temp;
; 253  : 	int retval;
; 254  : 
; 255  : 	const CvGame& game = GC.getGame();
; 256  : 	bool isMultiplayer = game.isNetworkMultiPlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer

; 257  : 	bool discardCacheForMPGame = isMultiplayer && !m_bIsMPCacheSafe;

	xor	ebx, ebx
	test	al, al
	je	SHORT $LN28@GeneratePa
	cmp	BYTE PTR [esi+79], bl
	jne	SHORT $LN28@GeneratePa
	mov	cl, 1
	jmp	SHORT $LN29@GeneratePa
$LN28@GeneratePa:
	xor	cl, cl
$LN29@GeneratePa:

; 258  : #endif
; 259  : 
; 260  : 	if(m_bForceReset || (m_iXstart != iXstart) || (m_iYstart != iYstart) || (m_iInfo != iInfo) || discardCacheForMPGame)

	mov	eax, DWORD PTR _iInfo$[esp+12]
	mov	edi, DWORD PTR _iYstart$[esp+12]
	mov	ebp, DWORD PTR _iXstart$[esp+12]
	cmp	BYTE PTR [esi+78], bl
	jne	SHORT $LN24@GeneratePa
	cmp	DWORD PTR [esi+56], ebp
	jne	SHORT $LN24@GeneratePa
	cmp	DWORD PTR [esi+60], edi
	jne	SHORT $LN24@GeneratePa
	cmp	DWORD PTR [esi+72], eax
	jne	SHORT $LN24@GeneratePa
	cmp	cl, bl
	je	SHORT $LN97@GeneratePa
$LN24@GeneratePa:

; 261  : 		bReuse = false;

	mov	BYTE PTR _bReuse$[esp+12], bl
$LN97@GeneratePa:

; 262  : 
; 263  : 	m_iXdest = iXdest;

	mov	ecx, DWORD PTR _iXdest$[esp+12]

; 264  : 	m_iYdest = iYdest;
; 265  : 	m_iXstart = iXstart;
; 266  : 	m_iYstart = iYstart;
; 267  : 	m_iInfo = iInfo;

	mov	DWORD PTR [esi+72], eax

; 268  : 
; 269  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 270  : 	if (udInitializeFunc)

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+64], ecx
	mov	ecx, DWORD PTR _iYdest$[esp+12]
	mov	DWORD PTR [esi+68], ecx
	mov	DWORD PTR [esi+56], ebp
	mov	DWORD PTR [esi+60], edi
	cmp	eax, ebx
	je	SHORT $LN23@GeneratePa

; 271  : 		udInitializeFunc(m_pData, this);

	mov	edx, DWORD PTR [esi+44]
	push	esi
	push	edx
	call	eax
	mov	ecx, DWORD PTR _iYdest$[esp+20]
	add	esp, 8
$LN23@GeneratePa:

; 272  : #endif
; 273  : 
; 274  : 	if(!isValid(iXstart, iYstart))

	cmp	ebp, ebx
	jl	SHORT $LN32@GeneratePa
	cmp	ebp, DWORD PTR [esi+48]
	jge	SHORT $LN32@GeneratePa
	cmp	edi, ebx
	jl	SHORT $LN32@GeneratePa
	cmp	edi, DWORD PTR [esi+52]
	jl	SHORT $LN22@GeneratePa
$LN32@GeneratePa:

; 275  : 	{
; 276  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 277  : 		if (udUninitializeFunc)

	mov	eax, DWORD PTR [esi+40]
	cmp	eax, ebx
	je	SHORT $LN21@GeneratePa

; 278  : 			udUninitializeFunc(m_pData, this);

	mov	ecx, DWORD PTR [esi+44]
	push	esi
	push	ecx
	call	eax
	add	esp, 8
$LN21@GeneratePa:
	pop	edi
	pop	esi
	pop	ebp

; 279  : #endif
; 280  : 		return false;

	xor	al, al
	pop	ebx

; 415  : }

	ret	24					; 00000018H
$LN22@GeneratePa:

; 281  : 	}
; 282  : 
; 283  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 284  : 	if (udInitializeFunc)
; 285  : 		udInitializeFunc(m_pData, this);
; 286  : 
; 287  : 	CvAStarNode* temp;
; 288  : #else
; 289  : 	PREFETCH_FASTAR_NODE(&(m_ppaaNodes[iXdest][iYdest]));

	mov	edx, DWORD PTR [esi+104]
	lea	eax, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR _iXdest$[esp+12]
	mov	edx, DWORD PTR [edx+ecx*4]
	shl	eax, 5
	prefetcht0 BYTE PTR [eax+edx]
	add	eax, edx
	prefetcht0 BYTE PTR [eax+64]
	add	eax, 64					; 00000040H

; 290  : #endif
; 291  : 
; 292  : 	if(!bReuse)

	cmp	BYTE PTR _bReuse$[esp+12], bl
	jne	$LN99@GeneratePa

; 293  : 	{
; 294  : 		// XXX should we just be doing a memset here?
; 295  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 296  : 		for (int iI = 0; iI < m_iColumns; iI++)
; 297  : 			for (int iJ = 0; iJ < m_iRows; iJ++)
; 298  : 				m_ppaaNodes[iI][iJ].clear();
; 299  : 		m_pClosed = NULL;
; 300  : #else
; 301  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 302  : 		if(m_pOpen)

	or	edx, -1
	cmp	DWORD PTR [esi+84], ebx
	je	SHORT $LN17@GeneratePa
$LL18@GeneratePa:

; 306  : 			{
; 307  : 				temp = m_pOpen->m_pNext;

	mov	eax, DWORD PTR [esi+84]
	mov	ecx, DWORD PTR [eax+28]

; 308  : 				m_pOpen->clear();

	xor	ebp, ebp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	WORD PTR [eax+84], bp
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ebx
	mov	BYTE PTR [eax+86], bl
	mov	DWORD PTR [eax+20], edx
	mov	DWORD PTR [eax+24], ebx
	mov	DWORD PTR [eax+28], ebx
	mov	DWORD PTR [eax+32], ebx
	mov	DWORD PTR [eax+36], ebx
	mov	DWORD PTR [eax+44], ebx

; 309  : 				m_pOpen = temp;

	mov	DWORD PTR [esi+84], ecx
	cmp	ecx, ebx
	jne	SHORT $LL18@GeneratePa

; 303  : #endif
; 304  : 		{
; 305  : 			while(m_pOpen)

	mov	ebp, DWORD PTR _iXstart$[esp+12]
$LN17@GeneratePa:

; 310  : 			}
; 311  : 		}
; 312  : 
; 313  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 314  : 		if(m_pClosed)

	cmp	DWORD PTR [esi+92], ebx
	je	SHORT $LN14@GeneratePa
$LL15@GeneratePa:

; 318  : 			{
; 319  : 				temp = m_pClosed->m_pNext;

	mov	eax, DWORD PTR [esi+92]
	mov	ecx, DWORD PTR [eax+28]

; 320  : 				m_pClosed->clear();

	xor	ebp, ebp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	WORD PTR [eax+84], bp
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ebx
	mov	BYTE PTR [eax+86], bl
	mov	DWORD PTR [eax+20], edx
	mov	DWORD PTR [eax+24], ebx
	mov	DWORD PTR [eax+28], ebx
	mov	DWORD PTR [eax+32], ebx
	mov	DWORD PTR [eax+36], ebx
	mov	DWORD PTR [eax+44], ebx

; 321  : 				m_pClosed = temp;

	mov	DWORD PTR [esi+92], ecx
	cmp	ecx, ebx
	jne	SHORT $LL15@GeneratePa

; 315  : #endif
; 316  : 		{
; 317  : 			while(m_pClosed)

	mov	ebp, DWORD PTR _iXstart$[esp+12]
$LN14@GeneratePa:

; 322  : 			}
; 323  : 		}
; 324  : 
; 325  : 		PREFETCH_FASTAR_NODE(&(m_ppaaNodes[iXstart][iYstart]));

	mov	ecx, DWORD PTR [esi+104]
	mov	edx, DWORD PTR [ecx+ebp*4]
	lea	eax, DWORD PTR [edi+edi*2]
	lea	ecx, DWORD PTR [ecx+ebp*4]
	shl	eax, 5
	prefetcht0 BYTE PTR [edx+eax]
	add	edx, eax
	prefetcht0 BYTE PTR [edx+64]
	add	edx, 64					; 00000040H

; 326  : #endif
; 327  : 
; 328  : 		m_pBest = NULL;

	mov	DWORD PTR [esi+96], ebx

; 329  : 		m_pStackHead = NULL;

	mov	DWORD PTR [esi+100], ebx

; 330  : 
; 331  : 		m_bForceReset = false;

	mov	BYTE PTR [esi+78], bl

; 332  : 
; 333  : 		temp = &(m_ppaaNodes[iXstart][iYstart]);

	mov	edi, DWORD PTR [ecx]
	add	edi, eax

; 334  : 
; 335  : #ifdef AUI_ASTAR_FIX_POSSIBLE_NULL_POINTERS
; 336  : 		temp->clear();
; 337  : #else
; 338  : 		temp->m_iKnownCost = 0;

	mov	DWORD PTR [edi+4], ebx

; 339  : #endif
; 340  : 		if(udHeuristic == NULL)

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, ebx
	jne	SHORT $LN13@GeneratePa

; 341  : 		{
; 342  : 			temp->m_iHeuristicCost = 0;

	mov	DWORD PTR [edi+8], ebx

; 343  : 		}
; 344  : 		else

	jmp	SHORT $LN12@GeneratePa
$LN13@GeneratePa:

; 345  : 		{
; 346  : 			temp->m_iHeuristicCost = udHeuristic(m_iXstart, m_iYstart, m_iXdest, m_iYdest);

	mov	ecx, DWORD PTR [esi+68]
	mov	edx, DWORD PTR [esi+64]
	push	ecx
	mov	ecx, DWORD PTR [esi+60]
	push	edx
	mov	edx, DWORD PTR [esi+56]
	push	ecx
	push	edx
	call	eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [edi+8], eax
$LN12@GeneratePa:

; 347  : 		}
; 348  : 		temp->m_iTotalCost = temp->m_iKnownCost + temp->m_iHeuristicCost;

	mov	eax, DWORD PTR [edi+8]
	add	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edi], eax

; 349  : 
; 350  : 		m_pOpen = temp;
; 351  : 		m_pOpenTail = temp;
; 352  : 
; 353  : 		udFunc(udNotifyList, NULL, m_pOpen, ASNL_STARTOPEN, m_pData);

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+88], edi
	cmp	eax, ebx
	je	SHORT $LN98@GeneratePa
	mov	ecx, DWORD PTR [esi+44]
	push	esi
	push	ecx
	push	1
	push	edi
	push	ebx
	call	eax
	add	esp, 20					; 00000014H
$LN98@GeneratePa:

; 354  : 		udFunc(udValid, NULL, temp, 0, m_pData);

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, ebx
	je	SHORT $LN64@GeneratePa
	mov	edx, DWORD PTR [esi+44]
	push	esi
	push	edx
	push	ebx
	push	edi
	push	ebx
	call	eax
	add	esp, 20					; 00000014H
$LN64@GeneratePa:

; 355  : 		udFunc(udNotifyChild, NULL, temp, ASNC_INITIALADD, m_pData);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, ebx
	je	SHORT $LN99@GeneratePa
	mov	ecx, DWORD PTR [esi+44]
	push	esi
	push	ecx
	push	ebx
	push	edi
	push	ebx
	call	eax
	add	esp, 20					; 00000014H
$LN99@GeneratePa:

; 356  : 	}
; 357  : 
; 358  : 	if(udDestValid != NULL)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, ebx
	je	SHORT $LN10@GeneratePa

; 359  : 	{
; 360  : 		if(!udDestValid(iXdest, iYdest, m_pData, this))

	mov	edx, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _iYdest$[esp+12]
	push	esi
	push	edx
	mov	edx, DWORD PTR _iXdest$[esp+20]
	push	ecx
	push	edx
	call	eax
	add	esp, 16					; 00000010H
	test	eax, eax

; 361  : 		{
; 362  : 			if (udUninitializeFunc)
; 363  : 				udUninitializeFunc(m_pData, this);
; 364  : 			return false;

	je	$LN32@GeneratePa
$LN10@GeneratePa:

; 365  : 		}
; 366  : 	}
; 367  : 
; 368  : 	if(isValid(m_iXdest, m_iYdest))

	mov	ecx, DWORD PTR [esi+64]
	cmp	ecx, ebx
	mov	eax, DWORD PTR [esi+68]
	jl	SHORT $LL5@GeneratePa
	cmp	ecx, DWORD PTR [esi+48]
	jge	SHORT $LL5@GeneratePa
	cmp	eax, ebx
	jl	SHORT $LL5@GeneratePa
	cmp	eax, DWORD PTR [esi+52]
	jge	SHORT $LL5@GeneratePa

; 369  : 	{
; 370  : 		temp = &(m_ppaaNodes[m_iXdest][m_iYdest]);

	mov	edx, DWORD PTR [esi+104]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 5
	add	eax, DWORD PTR [edx+ecx*4]

; 371  : 
; 372  : 		if(temp->m_eCvAStarListType == CVASTARLIST_CLOSED)

	cmp	DWORD PTR [eax+20], 1
	jne	SHORT $LL5@GeneratePa

; 373  : 		{
; 374  : 			m_pBest = temp;

	mov	DWORD PTR [esi+96], eax
$LN3@GeneratePa:

; 408  : 	}
; 409  : 
; 410  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 411  : 	if (udUninitializeFunc)

	mov	eax, DWORD PTR [esi+40]
	cmp	eax, ebx
	je	SHORT $LN1@GeneratePa

; 412  : 		udUninitializeFunc(m_pData, this);

	mov	ecx, DWORD PTR [esi+44]
	push	esi
	push	ecx
	call	eax
	add	esp, 8
$LN1@GeneratePa:
	pop	edi
	pop	esi
	pop	ebp

; 413  : #endif
; 414  : 	return true;

	mov	al, 1
	pop	ebx

; 415  : }

	ret	24					; 00000018H
	npad	1
$LL5@GeneratePa:

; 389  : #endif
; 390  : 	{
; 391  : 		retval = Step();

	mov	ecx, esi
	call	?GetBest@CvAStar@@IAEPAVCvAStarNode@@XZ	; CvAStar::GetBest
	mov	DWORD PTR [esi+96], eax
	cmp	eax, ebx
	je	SHORT $LN92@GeneratePa
	push	eax
	mov	ecx, esi
	call	?CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z ; CvAStar::CreateChildren
	mov	eax, DWORD PTR [esi+96]
	cmp	eax, ebx
	je	SHORT $LN92@GeneratePa
	movsx	ecx, WORD PTR [eax+82]
	movsx	edx, WORD PTR [eax+80]
	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	je	SHORT $LL5@GeneratePa
	mov	edi, DWORD PTR [esi+44]
	push	esi
	push	edi
	push	ecx
	push	edx
	call	eax
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LL5@GeneratePa

; 375  : 			if (udUninitializeFunc)
; 376  : 				udUninitializeFunc(m_pData, this);
; 377  : 			return true;
; 378  : 		}
; 379  : 	}
; 380  : 
; 381  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 382  : 	int retval = 0;
; 383  : 
; 384  : 	do
; 385  : #else
; 386  : 	retval = 0;
; 387  : 
; 388  : 	while(retval == 0)

	jmp	SHORT $LN3@GeneratePa
$LN92@GeneratePa:

; 392  : 	}
; 393  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 394  : 	while (retval == 0);
; 395  : 
; 396  : 	if (udUninitializeFunc)
; 397  : 		udUninitializeFunc(m_pData, this);
; 398  : #endif
; 399  : 
; 400  : 	if(retval == -1)
; 401  : 	{
; 402  : 		assert(m_pBest == NULL);
; 403  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 404  : 		if (udUninitializeFunc)

	mov	eax, DWORD PTR [esi+40]
	cmp	eax, ebx
	je	$LN21@GeneratePa

; 405  : 			udUninitializeFunc(m_pData, this);

	mov	edx, DWORD PTR [esi+44]
	push	esi
	push	edx
	call	eax
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 406  : #endif
; 407  : 		return false;

	xor	al, al
	pop	ebx

; 415  : }

	ret	24					; 00000018H
?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z ENDP		; CvAStar::GeneratePath
_TEXT	ENDS
PUBLIC	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath
EXTRN	?Calc@FCRC@@QBEKPBXHK@Z:PROC			; FCRC::Calc
EXTRN	?g_CRC32@@3VFCRC@@A:BYTE			; g_CRC32
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z$0
__ehfuncinfo$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
xdata$x	ENDS
;	COMDAT ?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z
_TEXT	SEGMENT
_strLogString$220552 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_bResult$220550 = 8					; size = 1
_pkUnit$ = 8						; size = 4
_iXstart$ = 12						; size = 4
_iYstart$ = 16						; size = 4
_iXdest$ = 20						; size = 4
_iYdest$ = 24						; size = 4
_iInfo$ = 28						; size = 4
_bReuse$ = 32						; size = 1
?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z PROC ; CvTwoLayerPathFinder::GenerateUnitPath, COMDAT
; _this$ = ecx

; 4139 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi
	push	edi

; 4140 : 	if (pkUnit)

	mov	edi, DWORD PTR _pkUnit$[esp+44]
	mov	esi, ecx
	test	edi, edi
	je	$LN4@GenerateUn

; 4141 : 	{
; 4142 : 		CvAssert(gDLL->IsGameCoreThread() || !gDLL->IsGameCoreExecuting());
; 4143 : #ifdef AUI_ASTAR_TURN_LIMITER
; 4144 : 		SetData(pkUnit, iTargetTurns);
; 4145 : #else
; 4146 : 		SetData(pkUnit);

	cmp	BYTE PTR [esi+80], 0
	je	SHORT $LN8@GenerateUn
	cmp	DWORD PTR [esi+44], edi
	je	SHORT $LN8@GenerateUn
	mov	BYTE PTR [esi+78], 1
$LN8@GenerateUn:

; 4147 : #endif
; 4148 : 		bool bResult = GeneratePath(iXstart, iYstart, iXdest, iYdest, iInfo, bReuse);

	mov	eax, DWORD PTR _bReuse$[esp+44]
	mov	ecx, DWORD PTR _iXdest$[esp+44]
	mov	edx, DWORD PTR _iYstart$[esp+44]
	push	ebx
	mov	ebx, DWORD PTR _iYdest$[esp+48]
	push	ebp
	mov	ebp, DWORD PTR _iInfo$[esp+52]
	push	eax
	mov	eax, DWORD PTR _iXstart$[esp+56]
	push	ebp
	push	ebx
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [esi+44], edi
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath

; 4149 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR _bResult$220550[esp+52], al
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN3@GenerateUn
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN3@GenerateUn

; 4150 : 		{
; 4151 : 			CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$220552[esp+56]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4152 : 			uint uiChecksum = CRC_INIT;
; 4153 : 			// Loop through the nodes and make a checksum
; 4154 : 			CvAStarNode* pNode = GetLastNode();

	mov	esi, DWORD PTR [esi+96]
	or	eax, -1
	mov	DWORD PTR __$EHRec$[esp+64], 0

; 4155 : 
; 4156 : 			// Starting at the end, loop until we find a plot from this owner
; 4157 : 			while(pNode != NULL)

	test	esi, esi
	je	SHORT $LN1@GenerateUn
$LL2@GenerateUn:

; 4158 : 			{
; 4159 : 				// Just do the X/Y for now
; 4160 : 				uiChecksum = g_CRC32.Calc( &pNode->m_iX, sizeof( pNode->m_iX ), uiChecksum );

	push	eax
	push	2
	lea	ecx, DWORD PTR [esi+80]
	push	ecx
	mov	ecx, OFFSET ?g_CRC32@@3VFCRC@@A		; g_CRC32
	call	?Calc@FCRC@@QBEKPBXHK@Z			; FCRC::Calc

; 4161 : 				uiChecksum = g_CRC32.Calc( &pNode->m_iY, sizeof( pNode->m_iY ), uiChecksum );

	push	eax
	push	2
	lea	edx, DWORD PTR [esi+82]
	push	edx
	mov	ecx, OFFSET ?g_CRC32@@3VFCRC@@A		; g_CRC32
	call	?Calc@FCRC@@QBEKPBXHK@Z			; FCRC::Calc

; 4162 : 		
; 4163 : 				pNode = pNode->m_pParent;

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL2@GenerateUn
$LN1@GenerateUn:

; 4164 : 			}
; 4165 : 
; 4166 : 			strLogString.Format("%d, %d, %d, %d, %d, %8x", iXstart, iYstart, iXdest, iYdest, iInfo, uiChecksum);

	mov	ecx, DWORD PTR _iYstart$[esp+52]
	mov	edx, DWORD PTR _iXstart$[esp+52]
	push	eax
	mov	eax, DWORD PTR _iXdest$[esp+56]
	push	ebp
	push	ebx
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strLogString$220552[esp+80]
	push	OFFSET $SG220559
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4167 : 			LogPathGeneration(pkUnit, strLogString);

	lea	ecx, DWORD PTR _strLogString$220552[esp+88]
	push	ecx
	push	edi
	call	?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z ; LogPathGeneration
	add	esp, 40					; 00000028H

; 4168 : 		}

	lea	ecx, DWORD PTR _strLogString$220552[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@GenerateUn:

; 4169 : 		return bResult;

	mov	al, BYTE PTR _bResult$220550[esp+52]
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 4170 : 	}
; 4171 : 	return false;
; 4172 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	28					; 0000001cH
$LN4@GenerateUn:
	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	xor	al, al
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z$0:
	lea	ecx, DWORD PTR _strLogString$220552[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ENDP ; CvTwoLayerPathFinder::GenerateUnitPath
PUBLIC	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints
; Function compile flags: /Ogtpy
;	COMDAT ?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eEnemy$ = 12						; size = 4
_pStartPlot$ = 16					; size = 4
_pEndPlot$ = 20						; size = 4
?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z PROC ; CvStepPathFinder::GetStepDistanceBetweenPoints, COMDAT
; _this$ = ecx

; 4181 : {

	push	esi
	mov	esi, ecx

; 4182 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 4183 : 	CvAStarNode* pPathfinderNode;
; 4184 : #endif
; 4185 : 
; 4186 : 	if(pStartPlot == NULL || pEndPlot == NULL || pStartPlot->getArea() != pEndPlot->getArea())

	mov	ecx, DWORD PTR _pStartPlot$[esp]
	test	ecx, ecx
	je	SHORT $LN3@GetStepDis
	mov	eax, DWORD PTR _pEndPlot$[esp]
	test	eax, eax
	je	SHORT $LN3@GetStepDis
	mov	edx, DWORD PTR [ecx+356]
	cmp	edx, DWORD PTR [eax+356]
	jne	SHORT $LN3@GetStepDis

; 4189 : 	}
; 4190 : 
; 4191 : 	SetData(&eEnemy);

	cmp	BYTE PTR [esi+80], 0
	je	SHORT $LN11@GetStepDis
	lea	edx, DWORD PTR _eEnemy$[esp]
	cmp	DWORD PTR [esi+44], edx
	je	SHORT $LN11@GetStepDis
	mov	BYTE PTR [esi+78], 1
$LN11@GetStepDis:
	push	ebx

; 4192 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4193 : 	if (GeneratePath(pStartPlot->getX(), pStartPlot->getY(), pEndPlot->getX(), pEndPlot->getY(), ePlayer, false))
; 4194 : 	{
; 4195 : 		CvAStarNode* pPathfinderNode = GetLastNode();
; 4196 : #else
; 4197 : 	bool bPathfinderSuccess = GeneratePath(pStartPlot->getX(), pStartPlot->getY(), pEndPlot->getX(), pEndPlot->getY(), ePlayer, false);

	mov	ebx, DWORD PTR _ePlayer$[esp+4]
	push	edi
	push	0
	lea	edx, DWORD PTR _eEnemy$[esp+12]
	mov	DWORD PTR [esi+44], edx
	movsx	edx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	movsx	edi, WORD PTR [ecx+2]
	movsx	ecx, WORD PTR [ecx]
	push	ebx
	push	edx
	push	eax
	push	edi
	push	ecx
	mov	ecx, esi
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	pop	edi
	pop	ebx

; 4198 : 	if(bPathfinderSuccess)

	test	al, al
	je	SHORT $LN3@GetStepDis

; 4199 : 	{
; 4200 : 		pPathfinderNode = GetLastNode();

	mov	esi, DWORD PTR [esi+96]

; 4201 : #endif
; 4202 : 
; 4203 : 		if(pPathfinderNode != NULL)

	test	esi, esi
	je	SHORT $LN3@GetStepDis

; 4204 : 		{
; 4205 : 			return pPathfinderNode->m_iData1;

	mov	eax, DWORD PTR [esi+12]
	pop	esi

; 4206 : 		}
; 4207 : 	}
; 4208 : 
; 4209 : 	return -1;
; 4210 : }

	ret	16					; 00000010H
$LN3@GetStepDis:

; 4187 : 	{
; 4188 : 		return -1;

	or	eax, -1
	pop	esi

; 4206 : 		}
; 4207 : 	}
; 4208 : 
; 4209 : 	return -1;
; 4210 : }

	ret	16					; 00000010H
?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ENDP ; CvStepPathFinder::GetStepDistanceBetweenPoints
_TEXT	ENDS
PUBLIC	?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::DoesPathExist
; Function compile flags: /Ogtpy
;	COMDAT ?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eEnemy$ = 12						; size = 4
_pStartPlot$ = 16					; size = 4
_pEndPlot$ = 20						; size = 4
?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z PROC ; CvStepPathFinder::DoesPathExist, COMDAT
; _this$ = ecx

; 4216 : 	if(pStartPlot == NULL || pEndPlot == NULL || pStartPlot->getArea() != pEndPlot->getArea())

	mov	edx, DWORD PTR _pStartPlot$[esp-4]
	push	esi
	test	edx, edx
	je	SHORT $LN1@DoesPathEx
	mov	eax, DWORD PTR _pEndPlot$[esp]
	test	eax, eax
	je	SHORT $LN1@DoesPathEx
	mov	esi, DWORD PTR [edx+356]
	cmp	esi, DWORD PTR [eax+356]
	jne	SHORT $LN1@DoesPathEx

; 4219 : 	}
; 4220 : 
; 4221 : 	SetData(&eEnemy);

	cmp	BYTE PTR [ecx+80], 0
	je	SHORT $LN9@DoesPathEx
	lea	esi, DWORD PTR _eEnemy$[esp]
	cmp	DWORD PTR [ecx+44], esi
	je	SHORT $LN9@DoesPathEx
	mov	BYTE PTR [ecx+78], 1
$LN9@DoesPathEx:
	push	ebx

; 4222 : 	return GeneratePath(pStartPlot->getX(), pStartPlot->getY(), pEndPlot->getX(), pEndPlot->getY(), ePlayer, false);

	mov	ebx, DWORD PTR _ePlayer$[esp+4]
	push	edi
	push	0
	lea	esi, DWORD PTR _eEnemy$[esp+12]
	mov	DWORD PTR [ecx+44], esi
	movsx	esi, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	movsx	edi, WORD PTR [edx+2]
	movsx	edx, WORD PTR [edx]
	push	ebx
	push	esi
	push	eax
	push	edi
	push	edx
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	pop	edi
	pop	ebx
	pop	esi

; 4223 : }

	ret	16					; 00000010H
$LN1@DoesPathEx:

; 4217 : 	{
; 4218 : 		return false;

	xor	al, al
	pop	esi

; 4223 : }

	ret	16					; 00000010H
?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z ENDP ; CvStepPathFinder::DoesPathExist
_TEXT	ENDS
PUBLIC	?GetLastOwnedPlot@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1@Z ; CvStepPathFinder::GetLastOwnedPlot
EXTRN	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ:PROC ; CvGlobals::getStepFinder
; Function compile flags: /Ogtpy
;	COMDAT ?GetLastOwnedPlot@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eEnemy$ = 12						; size = 4
_pStartPlot$ = 16					; size = 4
_pEndPlot$ = 20						; size = 4
?GetLastOwnedPlot@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1@Z PROC ; CvStepPathFinder::GetLastOwnedPlot, COMDAT
; _this$ = ecx

; 4229 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4230 : 	if (GC.getStepFinder().GetStepDistanceBetweenPoints(ePlayer, eEnemy, pStartPlot, pEndPlot) != -1)
; 4231 : #else
; 4232 : 	CvAStarNode* pNode;
; 4233 : 	int iNumSteps;
; 4234 : 
; 4235 : 	// Generate step path
; 4236 : 	iNumSteps = GC.getStepFinder().GetStepDistanceBetweenPoints(ePlayer, eEnemy, pStartPlot, pEndPlot);

	mov	eax, DWORD PTR _pEndPlot$[esp-4]
	mov	ecx, DWORD PTR _pStartPlot$[esp-4]
	mov	edx, DWORD PTR _eEnemy$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _ePlayer$[esp+8]
	push	eax
	push	ecx
	push	edx
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints

; 4237 : 	if(iNumSteps != -1)

	cmp	eax, -1
	je	SHORT $LN2@GetLastOwn

; 4238 : #endif
; 4239 : 	{
; 4240 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4241 : 		CvAStarNode* pNode = GetLastNode();
; 4242 : #else
; 4243 : 		pNode = GC.getStepFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, DWORD PTR [eax+96]

; 4244 : #endif
; 4245 : 
; 4246 : 		// Starting at the end, loop until we find a plot from this owner
; 4247 : #ifndef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4248 : 		CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 4249 : #endif
; 4250 : 		while(pNode != NULL)

	test	ecx, ecx
	je	SHORT $LN2@GetLastOwn
	mov	edx, DWORD PTR [eax+4020]
	mov	esi, DWORD PTR [eax+4068]
	npad	1
$LL3@GetLastOwn:

; 4251 : 		{
; 4252 : #if defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES) && defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4253 : 			CvPlot* currentPlot = pNode->m_pPlot;
; 4254 : #elif defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES)
; 4255 : 			CvPlot* currentPlot;
; 4256 : 			currentPlot = pNode->m_pPlot;
; 4257 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4258 : 			CvPlot* currentPlot = kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);
; 4259 : #else
; 4260 : 			CvPlot* currentPlot;
; 4261 : 			currentPlot = kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);

	movsx	eax, WORD PTR [ecx+82]
	movsx	ebx, WORD PTR [ecx+80]
	imul	eax, edx
	add	eax, ebx
	imul	eax, 484				; 000001e4H

; 4262 : #endif
; 4263 : 
; 4264 : 			// Check and see if this plot has the right owner
; 4265 : 			if(currentPlot->getOwner() == ePlayer)

	movsx	ebx, BYTE PTR [eax+esi+4]
	add	eax, esi
	cmp	ebx, edi
	je	SHORT $LN5@GetLastOwn

; 4266 : 			{
; 4267 : 				return currentPlot;
; 4268 : 			}
; 4269 : 
; 4270 : 			// Move to the previous plot on the path
; 4271 : 			pNode = pNode->m_pParent;

	mov	ecx, DWORD PTR [ecx+24]
	test	ecx, ecx
	jne	SHORT $LL3@GetLastOwn
$LN2@GetLastOwn:

; 4272 : 		}
; 4273 : 	}
; 4274 : 
; 4275 : 	return NULL;

	xor	eax, eax
$LN5@GetLastOwn:
	pop	edi
	pop	esi
	pop	ebx

; 4276 : }

	ret	16					; 00000010H
?GetLastOwnedPlot@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1@Z ENDP ; CvStepPathFinder::GetLastOwnedPlot
_TEXT	ENDS
PUBLIC	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd
; Function compile flags: /Ogtpy
;	COMDAT ?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
_eEnemy$ = 12						; size = 4
_pStartPlot$ = 16					; size = 4
_iPathLen$ = 20						; size = 4
_pEndPlot$ = 20						; size = 4
_iPlotsFromEnd$ = 24					; size = 4
$T228828 = 28						; size = 4
_bLeaveEnemyTerritory$ = 28				; size = 1
?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z PROC ; CvStepPathFinder::GetXPlotsFromEnd, COMDAT
; _this$ = ecx

; 4282 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 4283 : 	CvAStarNode* pNode;
; 4284 : #endif
; 4285 : 	CvPlot* currentPlot = NULL;
; 4286 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4287 : 	// Generate step path
; 4288 : 	int iPathLen = GC.getStepFinder().GetStepDistanceBetweenPoints(ePlayer, eEnemy, pStartPlot, pEndPlot);
; 4289 : 	int iNumSteps = MIN(iPlotsFromEnd, iPathLen);
; 4290 : #else
; 4291 : 	int iNumSteps;
; 4292 : 	int iPathLen;
; 4293 : 
; 4294 : 	// Generate step path
; 4295 : 	iPathLen = GC.getStepFinder().GetStepDistanceBetweenPoints(ePlayer, eEnemy, pStartPlot, pEndPlot);

	mov	eax, DWORD PTR _pEndPlot$[esp-4]
	mov	ecx, DWORD PTR _pStartPlot$[esp-4]
	mov	edx, DWORD PTR _eEnemy$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	eax
	mov	eax, DWORD PTR _ePlayer$[esp+12]
	push	ecx
	push	edx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints
	mov	ebx, eax

; 4296 : 	iNumSteps = ::min(iPlotsFromEnd, iPathLen);

	cmp	ebx, DWORD PTR _iPlotsFromEnd$[esp+8]
	mov	DWORD PTR _iPathLen$[esp+8], ebx
	lea	eax, DWORD PTR _iPathLen$[esp+8]
	jl	SHORT $LN18@GetXPlotsF
	lea	eax, DWORD PTR _iPlotsFromEnd$[esp+8]
$LN18@GetXPlotsF:
	mov	ebp, DWORD PTR [eax]

; 4297 : #endif
; 4298 : 
; 4299 : 	if(iNumSteps != -1)

	cmp	ebp, -1
	je	$LN46@GetXPlotsF

; 4300 : 	{
; 4301 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4302 : 		CvAStarNode* pNode = GetLastNode();
; 4303 : #else
; 4304 : 		pNode = GC.getStepFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, DWORD PTR [eax+96]

; 4305 : #endif
; 4306 : 
; 4307 : 		if(pNode != NULL)

	test	ecx, ecx
	je	$LN46@GetXPlotsF

; 4308 : 		{
; 4309 : 			// Starting at the end, loop the correct number of times back
; 4310 : 			for(int i = 0; i < iNumSteps; i++)

	test	ebp, ebp
	jle	SHORT $LN8@GetXPlotsF
	mov	edx, ebp
$LL10@GetXPlotsF:

; 4311 : 			{
; 4312 : 				if(pNode->m_pParent != NULL)

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LN9@GetXPlotsF

; 4313 : 				{
; 4314 : 					// Move to the previous plot on the path
; 4315 : 					pNode = pNode->m_pParent;

	mov	ecx, eax
$LN9@GetXPlotsF:

; 4308 : 		{
; 4309 : 			// Starting at the end, loop the correct number of times back
; 4310 : 			for(int i = 0; i < iNumSteps; i++)

	sub	edx, 1
	jne	SHORT $LL10@GetXPlotsF
$LN8@GetXPlotsF:

; 4316 : 				}
; 4317 : 			}
; 4318 : 
; 4319 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4320 : 			currentPlot = pNode->m_pPlot;
; 4321 : #else
; 4322 : 			CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 4323 : 			currentPlot = kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);

	mov	esi, DWORD PTR [eax+4020]
	movsx	edx, WORD PTR [ecx+80]
	push	edi
	mov	edi, DWORD PTR [eax+4068]
	movsx	eax, WORD PTR [ecx+82]
	imul	eax, esi
	add	eax, edx
	imul	eax, 484				; 000001e4H
	add	eax, edi

; 4324 : #endif
; 4325 : 
; 4326 : 			// Was an enemy specified and we don't want this plot to be in enemy territory?
; 4327 : 			if (eEnemy != NO_PLAYER && bLeaveEnemyTerritory)

	cmp	DWORD PTR _eEnemy$[esp+12], -1
	je	SHORT $LN48@GetXPlotsF
	cmp	BYTE PTR _bLeaveEnemyTerritory$[esp+12], 0
	je	SHORT $LN48@GetXPlotsF

; 4328 : 			{
; 4329 : 				// Loop until we leave enemy territory
; 4330 : 				for (int i = 0; i < (iPathLen - iNumSteps) && currentPlot->getOwner() == eEnemy; i++)

	sub	ebx, ebp
	xor	edx, edx

; 4333 : 					{
; 4334 : 						// Move to the previous plot on the path
; 4335 : 						pNode = pNode->m_pParent;

	mov	DWORD PTR $T228828[esp+12], ebx
	test	ebx, ebx
	jle	SHORT $LN48@GetXPlotsF

; 4328 : 			{
; 4329 : 				// Loop until we leave enemy territory
; 4330 : 				for (int i = 0; i < (iPathLen - iNumSteps) && currentPlot->getOwner() == eEnemy; i++)

	mov	ebx, DWORD PTR _eEnemy$[esp+12]
$LL5@GetXPlotsF:
	movsx	ebp, BYTE PTR [eax+4]
	cmp	ebp, ebx
	jne	SHORT $LN48@GetXPlotsF

; 4331 : 				{
; 4332 : 					if (pNode->m_pParent != NULL)

	mov	ecx, DWORD PTR [ecx+24]
	test	ecx, ecx
	je	SHORT $LN48@GetXPlotsF

; 4336 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4337 : 						currentPlot = pNode->m_pPlot;
; 4338 : #else
; 4339 : 						currentPlot = kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);

	movsx	eax, WORD PTR [ecx+82]
	movsx	ebp, WORD PTR [ecx+80]
	imul	eax, esi
	add	eax, ebp
	imul	eax, 484				; 000001e4H
	inc	edx
	add	eax, edi
	cmp	edx, DWORD PTR $T228828[esp+12]
	jl	SHORT $LL5@GetXPlotsF
$LN48@GetXPlotsF:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 4352 : }

	ret	24					; 00000018H
$LN46@GetXPlotsF:

; 4340 : #endif
; 4341 : 					}
; 4342 : 					else
; 4343 : 					{
; 4344 : 						break;
; 4345 : 					}
; 4346 : 				}
; 4347 : 			}
; 4348 : 		}
; 4349 : 	}
; 4350 : 
; 4351 : 	return currentPlot;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 4352 : }

	ret	24					; 00000018H
?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ENDP ; CvStepPathFinder::GetXPlotsFromEnd
_TEXT	ENDS
PUBLIC	?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z ; CvIgnoreUnitsPathFinder::DoesPathExist
; Function compile flags: /Ogtpy
;	COMDAT ?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z
_TEXT	SEGMENT
_unit$ = 8						; size = 4
_pStartPlot$ = 12					; size = 4
_pEndPlot$ = 16						; size = 4
?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z PROC ; CvIgnoreUnitsPathFinder::DoesPathExist, COMDAT
; _this$ = ecx

; 4365 : {

	push	edi

; 4366 : 	m_pCurNode = NULL;
; 4367 : 
; 4368 : 	if(pStartPlot == NULL || pEndPlot == NULL)

	mov	edi, DWORD PTR _pStartPlot$[esp]
	mov	DWORD PTR [ecx+628], 0
	test	edi, edi
	je	SHORT $LN1@DoesPathEx@2
	mov	edx, DWORD PTR _pEndPlot$[esp]
	test	edx, edx
	je	SHORT $LN1@DoesPathEx@2

; 4371 : 	}
; 4372 : 
; 4373 : #if defined(AUI_ASTAR_TURN_LIMITER) && defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4374 : 	SetData(pUnit, iMaxTurns);
; 4375 : #elif defined(AUI_ASTAR_TURN_LIMITER)
; 4376 : 	SetData(&unit, iMaxTurns);
; 4377 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4378 : 	SetData(pUnit);
; 4379 : #else
; 4380 : 	SetData(&unit);

	cmp	BYTE PTR [ecx+80], 0
	mov	eax, DWORD PTR _unit$[esp]
	je	SHORT $LN5@DoesPathEx@2
	cmp	DWORD PTR [ecx+44], eax
	je	SHORT $LN5@DoesPathEx@2
	mov	BYTE PTR [ecx+78], 1
$LN5@DoesPathEx@2:
	push	esi
	mov	DWORD PTR [ecx+44], eax

; 4381 : #endif
; 4382 : 	return GeneratePath(pStartPlot->getX(), pStartPlot->getY(), pEndPlot->getX(), pEndPlot->getY(), 0, true /*bReuse*/);

	movsx	eax, WORD PTR [edx+2]
	movsx	edx, WORD PTR [edx]
	movsx	esi, WORD PTR [edi+2]
	movsx	edi, WORD PTR [edi]
	push	1
	push	0
	push	eax
	push	edx
	push	esi
	push	edi
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	pop	esi
	pop	edi

; 4383 : }

	ret	12					; 0000000cH
$LN1@DoesPathEx@2:

; 4369 : 	{
; 4370 : 		return false;

	xor	al, al
	pop	edi

; 4383 : }

	ret	12					; 0000000cH
?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z ENDP ; CvIgnoreUnitsPathFinder::DoesPathExist
_TEXT	ENDS
PUBLIC	?GetLastOwnedPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@PAV2@0W4PlayerTypes@@@Z ; CvIgnoreUnitsPathFinder::GetLastOwnedPlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetLastOwnedPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@PAV2@0W4PlayerTypes@@@Z
_TEXT	SEGMENT
_pStartPlot$ = 8					; size = 4
_pEndPlot$ = 12						; size = 4
_iOwner$ = 16						; size = 4
?GetLastOwnedPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@PAV2@0W4PlayerTypes@@@Z PROC ; CvIgnoreUnitsPathFinder::GetLastOwnedPlot, COMDAT
; _this$ = ecx

; 4418 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4419 : 	// Generate path
; 4420 : 	if (GC.getIgnoreUnitsPathFinder().GeneratePath(pStartPlot->getX(), pStartPlot->getX(), pEndPlot->getX(), pEndPlot->getX(), 0, false))
; 4421 : 	{
; 4422 : 		CvAStarNode* pNode = GC.getIgnoreUnitsPathFinder().GetLastNode();
; 4423 : #else
; 4424 : 	CvAStarNode* pNode;
; 4425 : 
; 4426 : 	// Generate path
; 4427 : 	if(GC.getIgnoreUnitsPathFinder().GeneratePath(pStartPlot->getX(), pStartPlot->getX(), pEndPlot->getX(), pEndPlot->getX(), 0, false))

	mov	eax, DWORD PTR _pEndPlot$[esp-4]
	movsx	eax, WORD PTR [eax]
	mov	ecx, DWORD PTR _pStartPlot$[esp-4]
	movsx	ecx, WORD PTR [ecx]
	push	ebx
	push	esi
	push	edi
	push	0
	push	0
	push	eax
	push	eax
	push	ecx
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	test	al, al
	je	SHORT $LN2@GetLastOwn@2

; 4428 : 	{
; 4429 : 		pNode = GC.getIgnoreUnitsPathFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	ecx, DWORD PTR [eax+96]

; 4430 : #endif
; 4431 : 
; 4432 : 		// Starting at the end, loop until we find a plot from this owner
; 4433 : #ifndef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4434 : 		CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 4435 : #endif
; 4436 : 		while(pNode != NULL)

	test	ecx, ecx
	je	SHORT $LN2@GetLastOwn@2
	mov	edx, DWORD PTR [eax+4020]
	mov	esi, DWORD PTR [eax+4068]
	mov	edi, DWORD PTR _iOwner$[esp+8]
$LL3@GetLastOwn@2:

; 4437 : 		{
; 4438 : #if defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES) && defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4439 : 			CvPlot* currentPlot = pNode->m_pPlot;
; 4440 : #elif defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES)
; 4441 : 			CvPlot* currentPlot;
; 4442 : 			currentPlot = pNode->m_pPlot;
; 4443 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4444 : 			CvPlot* currentPlot = kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);
; 4445 : #else
; 4446 : 			CvPlot* currentPlot;
; 4447 : 			currentPlot = kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);

	movsx	eax, WORD PTR [ecx+82]
	movsx	ebx, WORD PTR [ecx+80]
	imul	eax, edx
	add	eax, ebx
	imul	eax, 484				; 000001e4H

; 4448 : #endif
; 4449 : 
; 4450 : 			// Check and see if this plot has the right owner
; 4451 : 			if(currentPlot->getOwner() == iOwner)

	movsx	ebx, BYTE PTR [eax+esi+4]
	add	eax, esi
	cmp	ebx, edi
	je	SHORT $LN5@GetLastOwn@2

; 4452 : 			{
; 4453 : 				return currentPlot;
; 4454 : 			}
; 4455 : 
; 4456 : 			// Move to the previous plot on the path
; 4457 : 			pNode = pNode->m_pParent;

	mov	ecx, DWORD PTR [ecx+24]
	test	ecx, ecx
	jne	SHORT $LL3@GetLastOwn@2
$LN2@GetLastOwn@2:

; 4458 : 		}
; 4459 : 	}
; 4460 : 
; 4461 : 	return NULL;

	xor	eax, eax
$LN5@GetLastOwn@2:
	pop	edi
	pop	esi
	pop	ebx

; 4462 : }

	ret	12					; 0000000cH
?GetLastOwnedPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@PAV2@0W4PlayerTypes@@@Z ENDP ; CvIgnoreUnitsPathFinder::GetLastOwnedPlot
_TEXT	ENDS
PUBLIC	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
EXTRN	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::GetTacticalAnalysisMapFinder
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z$0
__ehfuncinfo$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
xdata$x	ENDS
;	COMDAT ?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_pTarget$ = 16						; size = 4
_bReusePaths$ = 20					; size = 1
_bIgnoreUnits$ = 24					; size = 1
_bIgnoreStacking$ = 28					; size = 1
?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z PROC ; TurnsToReachTarget, COMDAT

; 5563 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	ebp
	push	esi
	push	edi

; 5564 : 	int rtnValue = MAX_INT;
; 5565 : 	CvAStarNode* pNode = NULL;
; 5566 : 
; 5567 : 	if(pTarget == pUnit->plot())

	mov	ecx, DWORD PTR _pUnit$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	ebx, 2147483647				; 7fffffffH
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, DWORD PTR _pTarget$[esp+24]

; 5568 : 	{
; 5569 : 		return 0;

	mov	ecx, DWORD PTR _pUnit$[esp+24]
	cmp	esi, eax
	jne	SHORT $LN11@TurnsToRea
	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	ecx, ecx
	je	SHORT $LN20@TurnsToRea
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN20@TurnsToRea:
	xor	eax, eax

; 5683 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
$LN11@TurnsToRea:

; 5570 : 	}
; 5571 : 
; 5572 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 5573 : 	if (pUnit && pTarget)
; 5574 : #else
; 5575 : 	if(pUnit)

	test	ecx, ecx
	je	$LN1@TurnsToRea

; 5576 : #endif
; 5577 : 	{
; 5578 : #ifdef PATH_FINDER_LOGGING
; 5579 : 		CvString strBaseString;
; 5580 : 		cvStopWatch kTimer(strBaseString, "Pathfinder.csv");
; 5581 : #endif
; 5582 : 
; 5583 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 5584 : 		int iFlags = 0;
; 5585 : 		if (bIgnoreStacking)
; 5586 : 		{
; 5587 : 			iFlags |= MOVE_IGNORE_STACKING;
; 5588 : 		}
; 5589 : 
; 5590 : 		CvAStar* pPathfinder = &GC.GetTacticalAnalysisMapFinder();
; 5591 : 		if (bIgnoreUnits)
; 5592 : 		{
; 5593 : 			pPathfinder = &GC.getIgnoreUnitsPathFinder();
; 5594 : 			iFlags |= MOVE_UNITS_IGNORE_DANGER;
; 5595 : 		}
; 5596 : #ifdef AUI_DANGER_PLOTS_REMADE
; 5597 : 		if (bForDanger)
; 5598 : 		{
; 5599 : 			pPathfinder = &GC.getDangerPathFinder();
; 5600 : 			iFlags |= MOVE_UNITS_IGNORE_DANGER;
; 5601 : 		}
; 5602 : #endif
; 5603 : 
; 5604 : #ifdef AUI_ASTAR_TURN_LIMITER
; 5605 : 		if (!pFromPlot)
; 5606 : 			pFromPlot = pUnit->plot();
; 5607 : 		pPathfinder->SetData(pUnit.pointer(), iTargetTurns);
; 5608 : #else
; 5609 : 		pPathfinder->SetData(pUnit.pointer());
; 5610 : #endif
; 5611 : 		if (pPathfinder->GeneratePath(pFromPlot->getX(), pFromPlot->getY(), pTarget->getX(), pTarget->getY(), iFlags, bReusePaths))
; 5612 : 		{
; 5613 : 			pNode = pPathfinder->GetLastNode();
; 5614 : 		}
; 5615 : #else
; 5616 : 		if(bIgnoreUnits)

	cmp	BYTE PTR _bIgnoreUnits$[esp+24], 0
	je	SHORT $LN9@TurnsToRea

; 5617 : 		{
; 5618 : #ifdef AUI_ASTAR_TURN_LIMITER
; 5619 : 			if (!pFromPlot)
; 5620 : 				pFromPlot = pUnit->plot();
; 5621 : 			GC.getIgnoreUnitsPathFinder().SetData(pUnit.pointer(), iTargetTurns);
; 5622 : 			if (GC.getIgnoreUnitsPathFinder().GeneratePath(pFromPlot->getX(), pFromPlot->getY(), pTarget->getX(), pTarget->getY(), 0, bReusePaths))
; 5623 : #else
; 5624 : 			GC.getIgnoreUnitsPathFinder().SetData(pUnit.pointer());

	mov	edi, ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	cmp	BYTE PTR [eax+80], 0
	je	SHORT $LN26@TurnsToRea
	cmp	DWORD PTR [eax+44], edi
	je	SHORT $LN26@TurnsToRea
	mov	BYTE PTR [eax+78], 1
$LN26@TurnsToRea:
	mov	DWORD PTR [eax+44], edi

; 5625 : 			if (GC.getIgnoreUnitsPathFinder().GeneratePath(pUnit->getX(), pUnit->getY(), pTarget->getX(), pTarget->getY(), 0, bReusePaths))

	movsx	eax, WORD PTR [esi+2]
	mov	edi, DWORD PTR _bReusePaths$[esp+24]
	movsx	ecx, WORD PTR [esi]
	mov	edx, DWORD PTR _pUnit$[esp+24]
	mov	esi, DWORD PTR [edx+88]
	mov	edx, DWORD PTR [edx+76]
	push	edi
	push	0
	push	eax
	push	ecx
	push	esi
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	test	al, al
	je	$LN78@TurnsToRea

; 5626 : #endif
; 5627 : 			{
; 5628 : 				pNode = GC.getIgnoreUnitsPathFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder

; 5629 : 			}
; 5630 : 		}
; 5631 : 		else

	jmp	$LN80@TurnsToRea
$LN9@TurnsToRea:

; 5632 : 		{
; 5633 : 			int iFlags = MOVE_UNITS_IGNORE_DANGER;
; 5634 : 			if(bIgnoreStacking)

	cmp	BYTE PTR _bIgnoreStacking$[esp+24], 0
	mov	edi, 8
	je	SHORT $LN6@TurnsToRea

; 5635 : 			{
; 5636 : 				iFlags |= MOVE_IGNORE_STACKING;

	mov	edi, 12					; 0000000cH
$LN6@TurnsToRea:

; 5637 : 			}
; 5638 : 
; 5639 : 			CvAssertMsg(pTarget != NULL, "Passed in a NULL destination to GeneratePath");
; 5640 : 			if(pTarget == NULL)

	test	esi, esi
	jne	SHORT $LN5@TurnsToRea

; 5641 : 			{
; 5642 : 				return false;

	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	xor	eax, eax

; 5683 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
$LN5@TurnsToRea:

; 5643 : 			}
; 5644 : 
; 5645 : 			bool bSuccess;
; 5646 : 
; 5647 : #ifdef AUI_ASTAR_TURN_LIMITER
; 5648 : 			if (!pFromPlot)
; 5649 : 				pFromPlot = pUnit->plot();
; 5650 : 			GC.GetTacticalAnalysisMapFinder().SetData(pUnit.pointer(), iTargetTurns);
; 5651 : 			bSuccess = GC.GetTacticalAnalysisMapFinder().GeneratePath(pFromPlot->getX(), pFromPlot->getY(), pTarget->getX(), pTarget->getY(), iFlags, bReusePaths);
; 5652 : #else
; 5653 : 			GC.GetTacticalAnalysisMapFinder().SetData(pUnit.pointer());

	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::GetTacticalAnalysisMapFinder
	mov	ecx, eax
	call	?SetData@CvAStar@@QAEXPBX@Z		; CvAStar::SetData

; 5654 : 			bSuccess = GC.GetTacticalAnalysisMapFinder().GeneratePath(pUnit->getX(), pUnit->getY(), pTarget->getX(), pTarget->getY(), iFlags, bReusePaths);

	movsx	eax, WORD PTR [esi+2]
	mov	ebp, DWORD PTR _bReusePaths$[esp+24]
	movsx	ecx, WORD PTR [esi]
	mov	edx, DWORD PTR _pUnit$[esp+24]
	mov	esi, DWORD PTR [edx+88]
	mov	edx, DWORD PTR [edx+76]
	push	ebp
	push	edi
	push	eax
	push	ecx
	push	esi
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::GetTacticalAnalysisMapFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath

; 5655 : #endif
; 5656 : 			if(bSuccess)

	test	al, al
	je	SHORT $LN78@TurnsToRea

; 5657 : 			{
; 5658 : 				pNode = GC.GetTacticalAnalysisMapFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::GetTacticalAnalysisMapFinder
$LN80@TurnsToRea:
	mov	eax, DWORD PTR [eax+96]

; 5659 : 			}
; 5660 : 		}
; 5661 : #endif
; 5662 : 
; 5663 : 		if(pNode)

	test	eax, eax
	je	SHORT $LN78@TurnsToRea

; 5664 : 		{
; 5665 : 			rtnValue = pNode->m_iData2;

	mov	ebx, DWORD PTR [eax+16]

; 5666 : 			if(rtnValue == 1)

	cmp	ebx, 1
	jne	SHORT $LN78@TurnsToRea

; 5667 : 			{
; 5668 : 				if(pNode->m_iData1 > 0)

	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN78@TurnsToRea

; 5669 : 				{
; 5670 : 					rtnValue = 0;

	xor	ebx, ebx
$LN78@TurnsToRea:
	mov	ecx, DWORD PTR _pUnit$[esp+24]
$LN1@TurnsToRea:

; 5671 : 				}
; 5672 : 			}
; 5673 : 		}
; 5674 : 
; 5675 : #ifdef PATH_FINDER_LOGGING
; 5676 : 		// NOTE: because I'm creating the string after the cvStopWatch, the time it takes to create the string will be in the timer.
; 5677 : 		strBaseString.Format("TurnsToReachTarget, Turn %03d, Player: %d, Unit: %d, From X: %d, Y: %d, To X: %d, Y: %d, reuse=%d, ignoreUnits=%d, ignoreStacking=%d, turns=%d", GC.getGame().getElapsedGameTurns(), (int)pUnit->getOwner(), pUnit->GetID(), pUnit->getX(), pUnit->getY(), pTarget->getX(), pTarget->getY(), bReusePaths?1:0, bIgnoreUnits?1:0, bIgnoreStacking?1:0, rtnValue);
; 5678 : 		kTimer.SetText(strBaseString);
; 5679 : #endif
; 5680 : 	}
; 5681 : 
; 5682 : 	return rtnValue;

	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	ecx, ecx
	je	SHORT $LN75@TurnsToRea
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN75@TurnsToRea:

; 5683 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:
	mov	eax, OFFSET __ehfuncinfo$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ENDP ; TurnsToReachTarget
PUBLIC	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ; CanReachInXTurns
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z$0
__ehfuncinfo$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
xdata$x	ENDS
;	COMDAT ?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
$T229053 = 16						; size = 4
_pTarget$ = 16						; size = 4
_iTurns$ = 20						; size = 4
_bIgnoreUnits$ = 24					; size = 1
_piTurns$ = 28						; size = 4
?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z PROC ; CanReachInXTurns, COMDAT

; 5499 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	ebp
	push	esi
	push	edi

; 5500 : 	int iDistance;
; 5501 : 
; 5502 : 	if(!pTarget)

	mov	edi, DWORD PTR _pTarget$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	test	edi, edi

; 5503 : 	{
; 5504 : 		return false;

	je	SHORT $LN64@CanReachIn

; 5505 : 	}
; 5506 : 
; 5507 : 	// Compare distance to movement rate
; 5508 : 	iDistance = plotDistance(pUnit->getX(), pUnit->getY(), pTarget->getX(), pTarget->getY());

	movsx	edx, WORD PTR [edi+2]
	mov	esi, DWORD PTR _pUnit$[esp+24]
	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	edx
	movsx	edx, WORD PTR [edi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance

; 5509 : 	// KWG: If the unit is a land unit that can embark, baseMoves() is only going to give correct value if the starting and ending locations
; 5510 : 	//		are in the same domain (LAND vs. SEA) and no transition occurs.
; 5511 : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 5512 : 	int iBaseMoves = GetIncreasedMoveRangeForRoads(pUnit.pointer(), pUnit->baseMoves());
; 5513 : 	if (iTurns == 0 && iDistance >= iBaseMoves)
; 5514 : 	{
; 5515 : 		return false;
; 5516 : 	}
; 5517 : 
; 5518 : 	else if (iTurns > 0 && iDistance > (iBaseMoves * iTurns))
; 5519 : #else
; 5520 : 	if(iTurns == 0 && iDistance >= pUnit->baseMoves())

	mov	ebp, DWORD PTR _iTurns$[esp+40]
	add	esp, 16					; 00000010H
	mov	ebx, eax
	test	ebp, ebp
	jne	SHORT $LN63@CanReachIn
	push	-1
	mov	ecx, esi
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves
	cmp	ebx, eax
	jl	SHORT $LN61@CanReachIn
$LN64@CanReachIn:

; 5521 : 	{
; 5522 : 		return false;

	mov	ecx, DWORD PTR _pUnit$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	ecx, ecx
	je	SHORT $LN14@CanReachIn
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 5503 : 	{
; 5504 : 		return false;

$LN14@CanReachIn:

; 5521 : 	{
; 5522 : 		return false;

	xor	al, al

; 5542 : 	}
; 5543 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
$LN63@CanReachIn:

; 5523 : 	}
; 5524 : 
; 5525 : 	else if(iTurns > 0 && iDistance > (pUnit->baseMoves() * iTurns))

	jle	SHORT $LN3@CanReachIn
	push	-1
	mov	ecx, esi
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves
	imul	eax, ebp
	cmp	ebx, eax

; 5526 : #endif
; 5527 : 	{
; 5528 : 		return false;

	jg	SHORT $LN64@CanReachIn
$LN61@CanReachIn:
	mov	esi, DWORD PTR _pUnit$[esp+24]
$LN3@CanReachIn:

; 5529 : 	}
; 5530 : 
; 5531 : 	// Distance not too far, now use pathfinder
; 5532 : 	else
; 5533 : 	{
; 5534 : #ifdef AUI_ASTAR_TURN_LIMITER
; 5535 : 		int iTurnsCalculated = TurnsToReachTarget(pUnit, pTarget, true /*bReusePaths*/, bIgnoreUnits, false, iTurns);
; 5536 : #else
; 5537 : 		int iTurnsCalculated = TurnsToReachTarget(pUnit, pTarget, false /*bReusePaths*/, bIgnoreUnits);

	mov	eax, DWORD PTR _bIgnoreUnits$[esp+24]
	push	0
	push	eax
	push	0
	push	edi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	cl, BYTE PTR _pUnit$[esp+52]
	mov	BYTE PTR [eax+4], cl
	mov	eax, esi
	mov	DWORD PTR $T229053[esp+48], esp
	test	eax, eax
	je	SHORT $LN49@CanReachIn
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN49@CanReachIn:
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget

; 5538 : #endif
; 5539 : 		if (piTurns)

	mov	ecx, DWORD PTR _piTurns$[esp+48]
	add	esp, 24					; 00000018H
	test	ecx, ecx
	je	SHORT $LN1@CanReachIn

; 5540 : 			*piTurns = iTurnsCalculated;

	mov	DWORD PTR [ecx], eax
$LN1@CanReachIn:

; 5541 : 		return (iTurnsCalculated <= iTurns);

	mov	ecx, DWORD PTR _pUnit$[esp+24]
	cmp	eax, ebp
	setle	bl
	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	ecx, ecx
	je	SHORT $LN54@CanReachIn
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN54@CanReachIn:

; 5542 : 	}
; 5543 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	mov	al, bl
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z:
	mov	eax, OFFSET __ehfuncinfo$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ENDP ; CanReachInXTurns
END
