; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvInfos.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG218616 DB	'ID', 00H
$SG218809 DB	00H
$SG218617 DB	'Type', 00H
$SG219059 DB	00H
$SG219555 DB	00H
$SG219560 DB	00H
$SG218618 DB	'Text', 00H
$SG219565 DB	00H
$SG219570 DB	00H
$SG219575 DB	00H
$SG218619 DB	'Civilopedia', 00H
$SG218620 DB	'Strategy', 00H
$SG219638 DB	00H
$SG219643 DB	00H
$SG220307 DB	00H
$SG218621 DB	'Help', 00H
$SG220308 DB	00H
	ORG $+2
$SG218622 DB	'DisabledHelp', 00H
	ORG $+3
$SG218626 DB	'Description', 00H
$SG218686 DB	'KB_ESCAPE', 00H
	ORG $+2
$SG218687 DB	'KB_0', 00H
	ORG $+3
$SG218688 DB	'KB_1', 00H
	ORG $+3
$SG218689 DB	'KB_2', 00H
	ORG $+3
$SG218690 DB	'KB_3', 00H
	ORG $+3
$SG218691 DB	'KB_4', 00H
	ORG $+3
$SG218692 DB	'KB_5', 00H
	ORG $+3
$SG218693 DB	'KB_6', 00H
	ORG $+3
$SG218694 DB	'KB_7', 00H
	ORG $+3
$SG218695 DB	'KB_8', 00H
	ORG $+3
$SG218696 DB	'KB_9', 00H
	ORG $+3
$SG218697 DB	'KB_MINUS', 00H
	ORG $+3
$SG218698 DB	'KB_A', 00H
	ORG $+3
$SG218699 DB	'KB_B', 00H
	ORG $+3
$SG218700 DB	'KB_C', 00H
	ORG $+3
$SG218701 DB	'KB_D', 00H
	ORG $+3
$SG218702 DB	'KB_E', 00H
	ORG $+3
$SG218703 DB	'KB_F', 00H
	ORG $+3
$SG218704 DB	'KB_G', 00H
	ORG $+3
$SG218705 DB	'KB_H', 00H
	ORG $+3
$SG218706 DB	'KB_I', 00H
	ORG $+3
$SG218707 DB	'KB_J', 00H
	ORG $+3
$SG218708 DB	'KB_K', 00H
	ORG $+3
$SG218709 DB	'KB_L', 00H
	ORG $+3
$SG218710 DB	'KB_M', 00H
	ORG $+3
$SG218711 DB	'KB_N', 00H
	ORG $+3
$SG218712 DB	'KB_O', 00H
	ORG $+3
$SG218713 DB	'KB_P', 00H
	ORG $+3
$SG218714 DB	'KB_Q', 00H
	ORG $+3
$SG218715 DB	'KB_R', 00H
	ORG $+3
$SG218716 DB	'KB_S', 00H
	ORG $+3
$SG218717 DB	'KB_T', 00H
	ORG $+3
$SG218718 DB	'KB_U', 00H
	ORG $+3
$SG218719 DB	'KB_V', 00H
	ORG $+3
$SG218720 DB	'KB_W', 00H
	ORG $+3
$SG218721 DB	'KB_X', 00H
	ORG $+3
$SG218722 DB	'KB_Y', 00H
	ORG $+3
$SG218723 DB	'KB_Z', 00H
	ORG $+3
$SG218724 DB	'KB_EQUALS', 00H
	ORG $+2
$SG218725 DB	'KB_BACKSPACE', 00H
	ORG $+3
$SG218726 DB	'KB_TAB', 00H
	ORG $+1
$SG218727 DB	'KB_LBRACKET', 00H
$SG218728 DB	'KB_RBRACKET', 00H
$SG218729 DB	'KB_RETURN', 00H
	ORG $+2
$SG218730 DB	'KB_LCONTROL', 00H
$SG218731 DB	'KB_SEMICOLON', 00H
	ORG $+3
$SG218732 DB	'KB_APOSTROPHE', 00H
	ORG $+2
$SG218733 DB	'KB_GRAVE', 00H
	ORG $+3
$SG218734 DB	'KB_LSHIFT', 00H
	ORG $+2
$SG218735 DB	'KB_BACKSLASH', 00H
	ORG $+3
$SG218736 DB	'KB_COMMA', 00H
	ORG $+3
$SG218737 DB	'KB_PERIOD', 00H
	ORG $+2
$SG218738 DB	'KB_SLASH', 00H
	ORG $+3
$SG218739 DB	'KB_RSHIFT', 00H
	ORG $+2
$SG218740 DB	'KB_NUMPADSTAR', 00H
	ORG $+2
$SG218741 DB	'KB_LALT', 00H
$SG218742 DB	'KB_SPACE', 00H
	ORG $+3
$SG218743 DB	'KB_CAPSLOCK', 00H
$SG218744 DB	'KB_F1', 00H
	ORG $+2
$SG218745 DB	'KB_F2', 00H
	ORG $+2
$SG218746 DB	'KB_F3', 00H
	ORG $+2
$SG218747 DB	'KB_F4', 00H
	ORG $+2
$SG218748 DB	'KB_F5', 00H
	ORG $+2
$SG218749 DB	'KB_F6', 00H
	ORG $+2
$SG218750 DB	'KB_F7', 00H
	ORG $+2
$SG218751 DB	'KB_F8', 00H
	ORG $+2
$SG218752 DB	'KB_F9', 00H
	ORG $+2
$SG218753 DB	'KB_F10', 00H
	ORG $+1
$SG218754 DB	'KB_NUMLOCK', 00H
	ORG $+1
$SG218755 DB	'KB_SCROLL', 00H
	ORG $+2
$SG218756 DB	'KB_NUMPAD7', 00H
	ORG $+1
$SG218757 DB	'KB_NUMPAD8', 00H
	ORG $+1
$SG218758 DB	'KB_NUMPAD9', 00H
	ORG $+1
$SG218759 DB	'KB_NUMPADMINUS', 00H
	ORG $+1
$SG218760 DB	'KB_NUMPAD4', 00H
	ORG $+1
$SG218761 DB	'KB_NUMPAD5', 00H
	ORG $+1
$SG218762 DB	'KB_NUMPAD6', 00H
	ORG $+1
$SG218763 DB	'KB_NUMPADPLUS', 00H
	ORG $+2
$SG218764 DB	'KB_NUMPAD1', 00H
	ORG $+1
$SG218765 DB	'KB_NUMPAD2', 00H
	ORG $+1
$SG218766 DB	'KB_NUMPAD3', 00H
	ORG $+1
$SG218767 DB	'KB_NUMPAD0', 00H
	ORG $+1
$SG218768 DB	'KB_NUMPADPERIOD', 00H
$SG218769 DB	'KB_F11', 00H
	ORG $+1
$SG218770 DB	'KB_F12', 00H
	ORG $+1
$SG218771 DB	'KB_NUMPADEQUALS', 00H
$SG218772 DB	'KB_AT', 00H
	ORG $+2
$SG218773 DB	'KB_UNDERLINE', 00H
	ORG $+3
$SG218774 DB	'KB_COLON', 00H
	ORG $+3
$SG218775 DB	'KB_NUMPADENTER', 00H
	ORG $+1
$SG218776 DB	'KB_RCONTROL', 00H
$SG218777 DB	'KB_VOLUMEDOWN', 00H
	ORG $+2
$SG218778 DB	'KB_VOLUMEUP', 00H
$SG218779 DB	'KB_NUMPADCOMMA', 00H
	ORG $+1
$SG218780 DB	'KB_NUMPADSLASH', 00H
	ORG $+1
$SG218781 DB	'KB_SYSRQ', 00H
	ORG $+3
$SG218782 DB	'KB_RALT', 00H
$SG218783 DB	'KB_PAUSE', 00H
	ORG $+3
$SG218784 DB	'KB_HOME', 00H
$SG218785 DB	'KB_UP', 00H
	ORG $+2
$SG218786 DB	'KB_PGUP', 00H
$SG218787 DB	'KB_LEFT', 00H
$SG218788 DB	'KB_RIGHT', 00H
	ORG $+3
$SG218789 DB	'KB_END', 00H
	ORG $+1
$SG218790 DB	'KB_DOWN', 00H
$SG218791 DB	'KB_PGDN', 00H
$SG218792 DB	'KB_INSERT', 00H
	ORG $+2
$SG218793 DB	'KB_DELETE', 00H
	ORG $+2
$SG218812 DB	'TXT_KEY_SHIFT', 00H
	ORG $+2
$SG218815 DB	'TXT_KEY_ALT', 00H
$SG218818 DB	'TXT_KEY_CTRL', 00H
	ORG $+3
$SG218835 DB	'KB_ESCAPE', 00H
	ORG $+2
$SG218836 DB	'TXT_KEY_KEYBOARD_ESCAPE', 00H
$SG218837 DB	'KB_0', 00H
	ORG $+3
$SG218838 DB	'0', 00H
	ORG $+2
$SG218839 DB	'KB_1', 00H
	ORG $+3
$SG218840 DB	'1', 00H
	ORG $+2
$SG218841 DB	'KB_2', 00H
	ORG $+3
$SG218842 DB	'2', 00H
	ORG $+2
$SG218843 DB	'KB_3', 00H
	ORG $+3
$SG218844 DB	'3', 00H
	ORG $+2
$SG218845 DB	'KB_4', 00H
	ORG $+3
$SG218846 DB	'4', 00H
	ORG $+2
$SG218847 DB	'KB_5', 00H
	ORG $+3
$SG218848 DB	'5', 00H
	ORG $+2
$SG218849 DB	'KB_6', 00H
	ORG $+3
$SG218850 DB	'6', 00H
	ORG $+2
$SG218851 DB	'KB_7', 00H
	ORG $+3
$SG218852 DB	'7', 00H
	ORG $+2
$SG218853 DB	'KB_8', 00H
	ORG $+3
$SG218854 DB	'8', 00H
	ORG $+2
$SG218855 DB	'KB_9', 00H
	ORG $+3
$SG218856 DB	'9', 00H
	ORG $+2
$SG218857 DB	'KB_MINUS', 00H
	ORG $+3
$SG218858 DB	'-', 00H
	ORG $+2
$SG218859 DB	'KB_A', 00H
	ORG $+3
$SG218860 DB	'A', 00H
	ORG $+2
$SG218861 DB	'KB_B', 00H
	ORG $+3
$SG218862 DB	'B', 00H
	ORG $+2
$SG218863 DB	'KB_C', 00H
	ORG $+3
$SG218864 DB	'C', 00H
	ORG $+2
$SG218865 DB	'KB_D', 00H
	ORG $+3
$SG218866 DB	'D', 00H
	ORG $+2
$SG218867 DB	'KB_E', 00H
	ORG $+3
$SG218868 DB	'E', 00H
	ORG $+2
$SG218869 DB	'KB_F', 00H
	ORG $+3
$SG218870 DB	'F', 00H
	ORG $+2
$SG218871 DB	'KB_G', 00H
	ORG $+3
$SG218872 DB	'G', 00H
	ORG $+2
$SG218873 DB	'KB_H', 00H
	ORG $+3
$SG218874 DB	'H', 00H
	ORG $+2
$SG218875 DB	'KB_I', 00H
	ORG $+3
$SG218876 DB	'I', 00H
	ORG $+2
$SG218877 DB	'KB_J', 00H
	ORG $+3
$SG218878 DB	'J', 00H
	ORG $+2
$SG218879 DB	'KB_K', 00H
	ORG $+3
$SG218880 DB	'K', 00H
	ORG $+2
$SG218881 DB	'KB_L', 00H
	ORG $+3
$SG218882 DB	'L', 00H
	ORG $+2
$SG218883 DB	'KB_M', 00H
	ORG $+3
$SG218884 DB	'M', 00H
	ORG $+2
$SG218885 DB	'KB_N', 00H
	ORG $+3
$SG218886 DB	'N', 00H
	ORG $+2
$SG218887 DB	'KB_O', 00H
	ORG $+3
$SG218888 DB	'O', 00H
	ORG $+2
$SG218889 DB	'KB_P', 00H
	ORG $+3
$SG218890 DB	'P', 00H
	ORG $+2
$SG218891 DB	'KB_Q', 00H
	ORG $+3
$SG218892 DB	'Q', 00H
	ORG $+2
$SG218893 DB	'KB_R', 00H
	ORG $+3
$SG218894 DB	'R', 00H
	ORG $+2
$SG218895 DB	'KB_S', 00H
	ORG $+3
$SG218896 DB	'S', 00H
	ORG $+2
$SG218897 DB	'KB_T', 00H
	ORG $+3
$SG218898 DB	'T', 00H
	ORG $+2
$SG218899 DB	'KB_U', 00H
	ORG $+3
$SG218900 DB	'U', 00H
	ORG $+2
$SG218901 DB	'KB_V', 00H
	ORG $+3
$SG218902 DB	'V', 00H
	ORG $+2
$SG218903 DB	'KB_W', 00H
	ORG $+3
$SG218904 DB	'W', 00H
	ORG $+2
$SG218905 DB	'KB_X', 00H
	ORG $+3
$SG218906 DB	'X', 00H
	ORG $+2
$SG218907 DB	'KB_Y', 00H
	ORG $+3
$SG218908 DB	'Y', 00H
	ORG $+2
$SG218909 DB	'KB_Z', 00H
	ORG $+3
$SG218910 DB	'Z', 00H
	ORG $+2
$SG218911 DB	'KB_EQUALS', 00H
	ORG $+2
$SG218912 DB	'=', 00H
	ORG $+2
$SG218913 DB	'KB_BACKSPACE', 00H
	ORG $+3
$SG218914 DB	'TXT_KEY_KEYBOARD_BACKSPACE', 00H
	ORG $+1
$SG218915 DB	'KB_TAB', 00H
	ORG $+1
$SG218916 DB	'TAB', 00H
$SG218917 DB	'KB_LBRACKET', 00H
$SG218918 DB	'[', 00H
	ORG $+2
$SG218919 DB	'KB_RBRACKET', 00H
$SG218920 DB	']', 00H
	ORG $+2
$SG218921 DB	'KB_RETURN', 00H
	ORG $+2
$SG218922 DB	'TXT_KEY_KEYBOARD_ENTER', 00H
	ORG $+1
$SG218923 DB	'KB_LCONTROL', 00H
$SG218924 DB	'TXT_KEY_KEYBOARD_LEFT_CONTROL_KEY', 00H
	ORG $+2
$SG218925 DB	'KB_SEMICOLON', 00H
	ORG $+3
$SG218926 DB	';', 00H
	ORG $+2
$SG218927 DB	'KB_APOSTROPHE', 00H
	ORG $+2
$SG218928 DB	'''', 00H
	ORG $+2
$SG218929 DB	'KB_GRAVE', 00H
	ORG $+3
$SG218930 DB	'`', 00H
	ORG $+2
$SG218931 DB	'KB_LSHIFT', 00H
	ORG $+2
$SG218932 DB	'TXT_KEY_KEYBOARD_LEFT_SHIFT_KEY', 00H
$SG218933 DB	'KB_BACKSLASH', 00H
	ORG $+3
$SG218934 DB	'\', 00H
	ORG $+2
$SG218935 DB	'KB_COMMA', 00H
	ORG $+3
$SG218936 DB	',', 00H
	ORG $+2
$SG218937 DB	'KB_PERIOD', 00H
	ORG $+2
$SG218938 DB	'.', 00H
	ORG $+2
$SG218939 DB	'KB_SLASH', 00H
	ORG $+3
$SG218940 DB	'/', 00H
	ORG $+2
$SG218941 DB	'KB_RSHIFT', 00H
	ORG $+2
$SG218942 DB	'TXT_KEY_KEYBOARD_RIGHT_SHIFT_KEY', 00H
	ORG $+3
$SG218943 DB	'KB_NUMPADSTAR', 00H
	ORG $+2
$SG218944 DB	'TXT_KEY_KEYBOARD_NUM_PAD_STAR', 00H
	ORG $+2
$SG218945 DB	'KB_LALT', 00H
$SG218946 DB	'TXT_KEY_KEYBOARD_LEFT_ALT_KEY', 00H
	ORG $+2
$SG218947 DB	'KB_SPACE', 00H
	ORG $+3
$SG218948 DB	'TXT_KEY_KEYBOARD_SPACE_KEY', 00H
	ORG $+1
$SG218949 DB	'KB_CAPSLOCK', 00H
$SG218950 DB	'TXT_KEY_KEYBOARD_CAPS_LOCK', 00H
	ORG $+1
$SG218951 DB	'KB_F1', 00H
	ORG $+2
$SG218952 DB	'F1', 00H
	ORG $+1
$SG218953 DB	'KB_F2', 00H
	ORG $+2
$SG218954 DB	'F2', 00H
	ORG $+1
$SG218955 DB	'KB_F3', 00H
	ORG $+2
$SG218956 DB	'F3', 00H
	ORG $+1
$SG218957 DB	'KB_F4', 00H
	ORG $+2
$SG218958 DB	'F4', 00H
	ORG $+1
$SG218959 DB	'KB_F5', 00H
	ORG $+2
$SG218960 DB	'F5', 00H
	ORG $+1
$SG218961 DB	'KB_F6', 00H
	ORG $+2
$SG218962 DB	'F6', 00H
	ORG $+1
$SG218963 DB	'KB_F7', 00H
	ORG $+2
$SG218964 DB	'F7', 00H
	ORG $+1
$SG218965 DB	'KB_F8', 00H
	ORG $+2
$SG218966 DB	'F8', 00H
	ORG $+1
$SG218967 DB	'KB_F9', 00H
	ORG $+2
$SG218968 DB	'F9', 00H
	ORG $+1
$SG218969 DB	'KB_F10', 00H
	ORG $+1
$SG218970 DB	'F10', 00H
$SG218971 DB	'KB_NUMLOCK', 00H
	ORG $+1
$SG218972 DB	'TXT_KEY_KEYBOARD_NUM_LOCK', 00H
	ORG $+2
$SG218973 DB	'KB_SCROLL', 00H
	ORG $+2
$SG218974 DB	'TXT_KEY_KEYBOARD_SCROLL_KEY', 00H
$SG218975 DB	'KB_NUMPAD7', 00H
	ORG $+1
$SG218976 DB	'TXT_KEY_KEYBOARD_NUMPAD_NUMBER7', 00H
$SG218977 DB	'KB_NUMPAD8', 00H
	ORG $+1
$SG218978 DB	'TXT_KEY_KEYBOARD_NUMPAD_NUMBER8', 00H
$SG218979 DB	'KB_NUMPAD9', 00H
	ORG $+1
$SG218980 DB	'TXT_KEY_KEYBOARD_NUMPAD_NUMBER9', 00H
$SG218981 DB	'KB_NUMPADMINUS', 00H
	ORG $+1
$SG218982 DB	'TXT_KEY_KEYBOARD_NUMPAD_MINUS', 00H
	ORG $+2
$SG218983 DB	'KB_NUMPAD4', 00H
	ORG $+1
$SG218984 DB	'TXT_KEY_KEYBOARD_NUMPAD_NUMBER4', 00H
$SG218985 DB	'KB_NUMPAD5', 00H
	ORG $+1
$SG218986 DB	'TXT_KEY_KEYBOARD_NUMPAD_NUMBER5', 00H
$SG218987 DB	'KB_NUMPAD6', 00H
	ORG $+1
$SG218988 DB	'TXT_KEY_KEYBOARD_NUMPAD_NUMBER6', 00H
$SG218989 DB	'KB_NUMPADPLUS', 00H
	ORG $+2
$SG218990 DB	'TXT_KEY_KEYBOARD_NUMPAD_PLUS', 00H
	ORG $+3
$SG218991 DB	'KB_NUMPAD1', 00H
	ORG $+1
$SG218992 DB	'TXT_KEY_KEYBOARD_NUMPAD_NUMBER1', 00H
$SG218993 DB	'KB_NUMPAD2', 00H
	ORG $+1
$SG218994 DB	'TXT_KEY_KEYBOARD_NUMPAD_NUMBER2', 00H
$SG218995 DB	'KB_NUMPAD3', 00H
	ORG $+1
$SG218996 DB	'TXT_KEY_KEYBOARD_NUMPAD_NUMBER3', 00H
$SG218997 DB	'KB_NUMPAD0', 00H
	ORG $+1
$SG218998 DB	'TXT_KEY_KEYBOARD_NUMPAD_NUMBER0', 00H
$SG218999 DB	'KB_NUMPADPERIOD', 00H
$SG219000 DB	'TXT_KEY_KEYBOARD_NUMPAD_PERIOD', 00H
	ORG $+1
$SG219001 DB	'KB_F11', 00H
	ORG $+1
$SG219002 DB	'F11', 00H
$SG219003 DB	'KB_F12', 00H
	ORG $+1
$SG219004 DB	'F12', 00H
$SG219005 DB	'KB_NUMPADEQUALS', 00H
$SG219006 DB	'TXT_KEY_KEYBOARD_NUMPAD_EQUALS', 00H
	ORG $+1
$SG219007 DB	'KB_AT', 00H
	ORG $+2
$SG219008 DB	'@', 00H
	ORG $+2
$SG219009 DB	'KB_UNDERLINE', 00H
	ORG $+3
$SG219010 DB	'_', 00H
	ORG $+2
$SG219011 DB	'KB_COLON', 00H
	ORG $+3
$SG219012 DB	':', 00H
	ORG $+2
$SG219013 DB	'KB_NUMPADENTER', 00H
	ORG $+1
$SG219014 DB	'TXT_KEY_KEYBOARD_NUMPAD_ENTER_KEY', 00H
	ORG $+2
$SG219015 DB	'KB_RCONTROL', 00H
$SG219016 DB	'TXT_KEY_KEYBOARD_RIGHT_CONTROL_KEY', 00H
	ORG $+1
$SG219017 DB	'KB_VOLUMEDOWN', 00H
	ORG $+2
$SG219018 DB	'TXT_KEY_KEYBOARD_VOLUME_DOWN', 00H
	ORG $+3
$SG219019 DB	'KB_VOLUMEUP', 00H
$SG219020 DB	'TXT_KEY_KEYBOARD_VOLUME_UP', 00H
	ORG $+1
$SG219021 DB	'KB_NUMPADCOMMA', 00H
	ORG $+1
$SG219022 DB	'TXT_KEY_KEYBOARD_NUMPAD_COMMA', 00H
	ORG $+2
$SG219023 DB	'KB_NUMPADSLASH', 00H
	ORG $+1
$SG219024 DB	'TXT_KEY_KEYBOARD_NUMPAD_SLASH', 00H
	ORG $+2
$SG219025 DB	'KB_SYSRQ', 00H
	ORG $+3
$SG219026 DB	'TXT_KEY_KEYBOARD_SYSRQ', 00H
	ORG $+1
$SG219027 DB	'KB_RALT', 00H
$SG219028 DB	'TXT_KEY_KEYBOARD_RIGHT_ALT_KEY', 00H
	ORG $+1
$SG219029 DB	'KB_PAUSE', 00H
	ORG $+3
$SG219030 DB	'TXT_KEY_KEYBOARD_PAUSE_KEY', 00H
	ORG $+1
$SG219031 DB	'KB_HOME', 00H
$SG219032 DB	'TXT_KEY_KEYBOARD_HOME_KEY', 00H
	ORG $+2
$SG219033 DB	'KB_UP', 00H
	ORG $+2
$SG219034 DB	'TXT_KEY_KEYBOARD_UP_ARROW', 00H
	ORG $+2
$SG219035 DB	'KB_PGUP', 00H
$SG219036 DB	'TXT_KEY_KEYBOARD_PAGE_UP', 00H
	ORG $+3
$SG219037 DB	'KB_LEFT', 00H
$SG219038 DB	'TXT_KEY_KEYBOARD_LEFT_ARROW', 00H
$SG219039 DB	'KB_RIGHT', 00H
	ORG $+3
$SG219040 DB	'TXT_KEY_KEYBOARD_RIGHT_ARROW', 00H
	ORG $+3
$SG219041 DB	'KB_END', 00H
	ORG $+1
$SG219042 DB	'TXT_KEY_KEYBOARD_END_KEY', 00H
	ORG $+3
$SG219043 DB	'KB_DOWN', 00H
$SG219044 DB	'TXT_KEY_KEYBOARD_DOWN_ARROW', 00H
$SG219045 DB	'KB_PGDN', 00H
$SG219046 DB	'TXT_KEY_KEYBOARD_PAGE_DOWN', 00H
	ORG $+1
$SG219047 DB	'KB_INSERT', 00H
	ORG $+2
$SG219048 DB	'TXT_KEY_KEYBOARD_INSERT_KEY', 00H
$SG219049 DB	'KB_DELETE', 00H
	ORG $+2
$SG219050 DB	'TXT_KEY_KEYBOARD_DELETE_KEY', 00H
$SG219066 DB	'HotKey', 00H
	ORG $+1
$SG219068 DB	'HotKey', 00H
	ORG $+1
$SG219069 DB	'HotKeyPriority', 00H
	ORG $+1
$SG219071 DB	'HotKeyAlt', 00H
	ORG $+2
$SG219072 DB	'HotKeyPriorityAlt', 00H
	ORG $+2
$SG219073 DB	'AltDown', 00H
$SG219074 DB	'AltDownAlt', 00H
	ORG $+1
$SG219075 DB	'ShiftDown', 00H
	ORG $+2
$SG219076 DB	'ShiftDownAlt', 00H
	ORG $+3
$SG219077 DB	'CtrlDown', 00H
	ORG $+3
$SG219078 DB	'CtrlDownAlt', 00H
$SG219079 DB	'OrderPriority', 00H
	ORG $+2
$SG219081 DB	'Help', 00H
	ORG $+3
$SG219084 DB	'DisabledHelp', 00H
	ORG $+3
$SG219191 DB	'{1: textkey} ({2: textkey})', 00H
$SG219276 DB	'Visible', 00H
$SG219277 DB	'Cost', 00H
	ORG $+3
$SG219278 DB	'Experience', 00H
	ORG $+1
$SG219279 DB	'GreatPeopleRateChange', 00H
	ORG $+2
$SG219280 DB	'CulturePerTurn', 00H
	ORG $+1
$SG219281 DB	'Texture', 00H
$SG219283 DB	'GreatPeopleUnitClass', 00H
	ORG $+3
$SG219285 DB	'SpecialistType', 00H
	ORG $+1
$SG219286 DB	'SpecialistFlavors', 00H
	ORG $+2
$SG219287 DB	'SpecialistType', 00H
	ORG $+1
$SG219288 DB	'SpecialistYields', 00H
	ORG $+3
$SG219319 DB	'Waypoint', 00H
	ORG $+3
$SG219320 DB	'Time', 00H
	ORG $+3
$SG219321 DB	'Sound', 00H
	ORG $+2
$SG219322 DB	'Target', 00H
	ORG $+1
$SG219323 DB	'Build', 00H
	ORG $+2
$SG219324 DB	'Visible', 00H
$SG219326 DB	'EntityEventType', 00H
$SG219356 DB	'Automate', 00H
	ORG $+3
$SG219358 DB	'ConfirmCommand', 00H
	ORG $+1
$SG219359 DB	'Visible', 00H
$SG219360 DB	'All', 00H
$SG219391 DB	'Command', 00H
$SG219393 DB	'Automate', 00H
	ORG $+3
$SG219394 DB	'ConfirmCommand', 00H
	ORG $+1
$SG219395 DB	'Visible', 00H
$SG219667 DB	'Name', 00H
	ORG $+3
$SG219668 DB	'RequiresNavalUnitConsistency', 00H
	ORG $+3
$SG219671 DB	'MultiUnitFormationType', 00H
	ORG $+1
$SG219672 DB	'MultiUnitFormation_SlotEntries', 00H
	ORG $+1
$SG219677 DB	'RequiredSlot', 00H
	ORG $+3
$SG219679 DB	'MultiUnitPositionType', 00H
	ORG $+2
$SG219681 DB	'PrimaryUnitType', 00H
$SG219682 DB	'SecondaryUnitType', 00H
	ORG $+2
$SG219717 DB	'Valid', 00H
	ORG $+2
$SG219718 DB	'CityLoad', 00H
	ORG $+3
$SG219720 DB	'SpecialUnitType', 00H
$SG219721 DB	'UnitAIType', 00H
	ORG $+1
$SG219722 DB	'SpecialUnit_CarrierUnitAI', 00H
	ORG $+2
$SG219723 DB	'UnitAIInfos', 00H
$SG219724 DB	'Trait', 00H
	ORG $+2
$SG219725 DB	'SpecialUnitType', 00H
$SG219726 DB	'TraitType', 00H
	ORG $+2
$SG219727 DB	'SpecialUnit_ProductionTraits', 00H
	ORG $+3
$SG219728 DB	'Traits', 00H
	ORG $+1
$SG219757 DB	'MaxGlobalInstances', 00H
	ORG $+1
$SG219758 DB	'MaxTeamInstances', 00H
	ORG $+3
$SG219759 DB	'MaxPlayerInstances', 00H
	ORG $+1
$SG219760 DB	'InstanceCostModifier', 00H
	ORG $+3
$SG219761 DB	'DefaultUnit', 00H
$SG219807 DB	'MaxGlobalInstances', 00H
	ORG $+1
$SG219808 DB	'MaxTeamInstances', 00H
	ORG $+3
$SG219809 DB	'MaxPlayerInstances', 00H
	ORG $+1
$SG219810 DB	'ExtraPlayerInstances', 00H
	ORG $+3
$SG219811 DB	'NoLimit', 00H
$SG219812 DB	'Monument', 00H
	ORG $+3
$SG219814 DB	'DefaultBuilding', 00H
$SG219815 DB	'Threshold', 00H
	ORG $+2
$SG219816 DB	'BuildingClassType', 00H
	ORG $+2
$SG219817 DB	'VictoryType', 00H
$SG219818 DB	'BuildingClass_VictoryThresholds', 00H
$SG219819 DB	'Victories', 00H
	ORG $+2
$SG219836 DB	'LOAD ERROR: Building Class Type not found', 00H
	ORG $+2
$SG219870 DB	'LOAD ERROR: Unit Class Type not found', 00H
	ORG $+2
$SG219926 DB	'Playable', 00H
	ORG $+3
$SG219927 DB	'AIPlayable', 00H
	ORG $+1
$SG219928 DB	'ShortDescription', 00H
	ORG $+3
$SG219929 DB	'PackageID', 00H
	ORG $+2
$SG219951 DB	'BuildingClasses', 00H
$SG219953 DB	'InitBuildingDefaults', 00H
	ORG $+7
$SG219956 DB	'select BuildingClasses.ID, Buildings.ID as BuildingID fr'
	DB	'om BuildingClasses inner join Buildings on Buildings.Type = D'
	DB	'efaultBuilding', 00H
$SG219967 DB	'UnitClasses', 00H
$SG219969 DB	'InitUnitDefaults', 00H
	ORG $+7
$SG219972 DB	'select UnitClasses.ID, Units.ID as UnitID from UnitClass'
	DB	'es inner join Units on Units.Type = DefaultUnit', 00H
$SG220104 DB	'UnitClasses', 00H
$SG220106 DB	'BuildingClasses', 00H
$SG220108 DB	'Adjective', 00H
	ORG $+2
$SG220109 DB	'DefaultPlayerColor', 00H
	ORG $+1
$SG220110 DB	'ArtDefineTag', 00H
	ORG $+3
$SG220111 DB	'ArtStyleType', 00H
	ORG $+3
$SG220112 DB	'ArtStylePrefix', 00H
	ORG $+1
$SG220113 DB	'ArtStyleSuffix', 00H
	ORG $+1
$SG220114 DB	'DawnOfManAudio', 00H
	ORG $+1
$SG220115 DB	'SoundtrackTag', 00H
	ORG $+2
$SG220118 DB	'Civilization_Start_Along_Ocean', 00H
	ORG $+5
$SG220121 DB	'select StartAlongOcean from Civilization_Start_Along_Oce'
	DB	'an where CivilizationType = ?', 00H
	ORG $+2
$SG220126 DB	'Civilization_Start_Place_First', 00H
	ORG $+1
$SG220129 DB	'select PlaceFirst from Civilization_Start_Place_First_Al'
	DB	'ong_Ocean where CivilizationType = ?', 00H
	ORG $+3
$SG220134 DB	'Civilization - CityNames', 00H
	ORG $+7
$SG220137 DB	'select CityName from Civilization_CityNames where Civili'
	DB	'zationType = ?', 00H
	ORG $+1
$SG220143 DB	'Civilization_BuildingClassOverrides', 00H
$SG220165 DB	'Civilizations - FreeUnits', 00H
	ORG $+2
$SG220146 DB	'select BuildingClasses.ID, coalesce(Buildings.ID, -1) fr'
	DB	'om Civilization_BuildingClassOverrides inner join BuildingCla'
	DB	'sses on BuildingClassType = BuildingClasses.Type left outer j'
	DB	'oin Buildings on BuildingType = Buildings.Type where Civiliza'
	DB	'tionType = ?', 00H
$SG220154 DB	'Civilization_UnitClassOverrides', 00H
$SG220175 DB	'CivilizationType', 00H
	ORG $+3
$SG220157 DB	'select UnitClasses.ID, coalesce(Units.ID, -1) from Civil'
	DB	'ization_UnitClassOverrides inner join UnitClasses on UnitClas'
	DB	'sType = UnitClasses.Type left outer join Units on UnitType = '
	DB	'Units.Type where CivilizationType = ?', 00H
$SG220168 DB	'select UnitClasses.ID as UnitClassID, UnitAIInfos.ID as '
	DB	'UnitAITypeID, Count from Civilization_FreeUnits inner join Un'
	DB	'itClasses on UnitClassType = UnitClasses.Type inner join Unit'
	DB	'AIInfos on UnitAIType = UnitAIInfos.Type where CivilizationTy'
	DB	'pe = ?', 00H
	ORG $+2
$SG220176 DB	'BuildingClassType', 00H
	ORG $+2
$SG220177 DB	'Civilization_FreeBuildingClasses', 00H
	ORG $+3
$SG220178 DB	'BuildingClasses', 00H
$SG220179 DB	'CivilizationType', 00H
	ORG $+3
$SG220180 DB	'TechType', 00H
	ORG $+3
$SG220181 DB	'Civilization_FreeTechs', 00H
	ORG $+1
$SG220182 DB	'Technologies', 00H
	ORG $+3
$SG220183 DB	'CivilizationType', 00H
	ORG $+3
$SG220184 DB	'TechType', 00H
	ORG $+3
$SG220185 DB	'Civilization_DisableTechs', 00H
	ORG $+2
$SG220186 DB	'Technologies', 00H
	ORG $+3
$SG220187 DB	'CivilizationType', 00H
	ORG $+3
$SG220188 DB	'LeaderheadType', 00H
	ORG $+1
$SG220189 DB	'Civilization_Leaders', 00H
	ORG $+3
$SG220190 DB	'Leaders', 00H
$SG220191 DB	'CivilizationType', 00H
	ORG $+3
$SG220192 DB	'ReligionType', 00H
	ORG $+3
$SG220193 DB	'Civilization_Religions', 00H
	ORG $+1
$SG220194 DB	'Religions', 00H
	ORG $+2
$SG220196 DB	'Civilization - SpyNames', 00H
$SG220199 DB	'select SpyName from Civilization_SpyNames where Civiliza'
	DB	'tionType = ?', 00H
	ORG $+3
$SG220275 DB	'WinsGame', 00H
	ORG $+3
$SG220276 DB	'TargetScore', 00H
$SG220277 DB	'EndScore', 00H
	ORG $+3
$SG220278 DB	'Conquest', 00H
	ORG $+3
$SG220279 DB	'Influential', 00H
$SG220280 DB	'DiploVote', 00H
	ORG $+2
$SG220281 DB	'Permanent', 00H
	ORG $+2
$SG220282 DB	'ReligionInAllCities', 00H
$SG220283 DB	'FindAllNaturalWonders', 00H
	ORG $+2
$SG220284 DB	'PopulationPercentLead', 00H
	ORG $+2
$SG220285 DB	'LandPercent', 00H
$SG220286 DB	'MinLandPercent', 00H
	ORG $+1
$SG220287 DB	'NumCultureCities', 00H
	ORG $+3
$SG220288 DB	'TotalCultureRatio', 00H
	ORG $+2
$SG220289 DB	'VictoryDelayTurns', 00H
	ORG $+2
$SG220290 DB	'VictoryMovie', 00H
	ORG $+3
$SG220292 DB	'CityCulture', 00H
$SG220296 DB	'CvVictoryInfo_VictoryPointAwards', 00H
	ORG $+3
$SG220299 DB	'select VictoryPoints from VictoryPointAwards where Victo'
	DB	'ryType == ? order by VictoryPoints desc;', 00H
	ORG $+3
$SG220339 DB	'Notification', 00H
	ORG $+3
$SG220340 DB	'TeamNotification', 00H
	ORG $+3
$SG220341 DB	'NumVictoryPoints', 00H
	ORG $+3
$SG220342 DB	'NumCities', 00H
	ORG $+2
$SG220343 DB	'CityPopulation', 00H
	ORG $+1
$SG220368 DB	'GoldPerProduction', 00H
	ORG $+2
$SG220369 DB	'ProductionPerPopulation', 00H
$SG220370 DB	'GoldPerBeaker', 00H
	ORG $+2
$SG220371 DB	'GoldPerCulture', 00H
	ORG $+1
$SG220373 DB	'PolicyPrereq', 00H
	ORG $+3
$SG220582 DB	'StartingLocPercent', 00H
	ORG $+1
$SG220583 DB	'AdvancedStartPointsMod', 00H
	ORG $+1
$SG220584 DB	'StartingPolicyPoints', 00H
	ORG $+3
$SG220585 DB	'HappinessDefault', 00H
	ORG $+3
$SG220586 DB	'ExtraHappinessPerLuxury', 00H
$SG220587 DB	'NumCitiesUnhappinessMod', 00H
$SG220588 DB	'PopulationUnhappinessMod', 00H
	ORG $+3
$SG220589 DB	'Gold', 00H
	ORG $+3
$SG220590 DB	'GoldFreeUnits', 00H
	ORG $+2
$SG220591 DB	'ProductionFreeUnits', 00H
$SG220592 DB	'ProductionFreeUnitsPerCity', 00H
	ORG $+1
$SG220593 DB	'ProductionFreeUnitsPopulationPercent', 00H
	ORG $+3
$SG220594 DB	'RouteCostPercent', 00H
	ORG $+3
$SG220595 DB	'UnitCostPercent', 00H
$SG220596 DB	'BuildingCostPercent', 00H
$SG220597 DB	'ResearchPercent', 00H
$SG220598 DB	'PolicyPercent', 00H
	ORG $+2
$SG220599 DB	'ImprovementCostPercent', 00H
	ORG $+1
$SG220600 DB	'CityProductionNumOptionsConsidered', 00H
	ORG $+1
$SG220601 DB	'TechNumOptionsConsidered', 00H
	ORG $+3
$SG220602 DB	'PolicyNumOptionsConsidered', 00H
	ORG $+1
$SG220603 DB	'InflationPercent', 00H
	ORG $+3
$SG220604 DB	'FreeCulturePerTurn', 00H
	ORG $+1
$SG220605 DB	'AttitudeChange', 00H
	ORG $+1
$SG220606 DB	'NoTechTradeModifier', 00H
$SG220607 DB	'TechTradeKnownModifier', 00H
	ORG $+1
$SG220608 DB	'BarbCampGold', 00H
	ORG $+3
$SG220609 DB	'BarbSpawnMod', 00H
	ORG $+3
$SG220610 DB	'BarbarianBonus', 00H
	ORG $+1
$SG220611 DB	'AIBarbarianBonus', 00H
	ORG $+3
$SG220612 DB	'EarliestBarbarianReleaseTurn', 00H
	ORG $+3
$SG220613 DB	'BarbarianLandTargetRange', 00H
	ORG $+3
$SG220614 DB	'BarbarianSeaTargetRange', 00H
$SG220615 DB	'StartingDefenseUnits', 00H
	ORG $+3
$SG220616 DB	'StartingWorkerUnits', 00H
$SG220617 DB	'StartingExploreUnits', 00H
	ORG $+3
$SG220618 DB	'AIStartingUnitMultiplier', 00H
	ORG $+3
$SG220619 DB	'AIStartingDefenseUnits', 00H
	ORG $+1
$SG220620 DB	'AIStartingWorkerUnits', 00H
	ORG $+2
$SG220621 DB	'AIStartingExploreUnits', 00H
	ORG $+1
$SG220622 DB	'AIDeclareWarProb', 00H
	ORG $+3
$SG220623 DB	'AIWorkRateModifier', 00H
	ORG $+1
$SG220624 DB	'AIUnhappinessPercent', 00H
	ORG $+3
$SG220625 DB	'AIGrowthPercent', 00H
$SG220626 DB	'AITrainPercent', 00H
	ORG $+1
$SG220627 DB	'AIWorldTrainPercent', 00H
$SG220628 DB	'AIConstructPercent', 00H
	ORG $+1
$SG220629 DB	'AIWorldConstructPercent', 00H
$SG220630 DB	'AICreatePercent', 00H
$SG220631 DB	'AIWorldCreatePercent', 00H
	ORG $+3
$SG220632 DB	'AIBuildingCostPercent', 00H
	ORG $+2
$SG220633 DB	'AIUnitCostPercent', 00H
	ORG $+2
$SG220634 DB	'AIUnitSupplyPercent', 00H
$SG220635 DB	'AIUnitUpgradePercent', 00H
	ORG $+3
$SG220636 DB	'AIInflationPercent', 00H
	ORG $+1
$SG220637 DB	'AIPerEraModifier', 00H
	ORG $+3
$SG220638 DB	'AIAdvancedStartPercent', 00H
	ORG $+1
$SG220639 DB	'AIFreeXP', 00H
	ORG $+3
$SG220640 DB	'AIFreeXPPercent', 00H
$SG220643 DB	'count(*)', 00H
	ORG $+3
$SG220645 DB	'HandicapType', 00H
	ORG $+3
$SG220646 DB	'HandicapInfo_Goodies', 00H
	ORG $+3
$SG220656 DB	'select GoodyHuts.ID from HandicapInfo_Goodies inner join'
	DB	' GoodyHuts on GoodyType = GoodyHuts.Type where HandicapType ='
	DB	' ''%s'';', 00H
$SG220662 DB	'HandicapType', 00H
	ORG $+3
$SG220663 DB	'TechType', 00H
	ORG $+3
$SG220664 DB	'HandicapInfo_FreeTechs', 00H
	ORG $+1
$SG220665 DB	'Technologies', 00H
	ORG $+3
$SG220666 DB	'HandicapType', 00H
	ORG $+3
$SG220667 DB	'TechType', 00H
	ORG $+3
$SG220668 DB	'HandicapInfo_AIFreeTechs', 00H
	ORG $+3
$SG220669 DB	'Technologies', 00H
	ORG $+3
$SG220795 DB	'DealDuration', 00H
	ORG $+3
$SG220796 DB	'GrowthPercent', 00H
	ORG $+2
$SG220797 DB	'TrainPercent', 00H
	ORG $+3
$SG220798 DB	'ConstructPercent', 00H
	ORG $+3
$SG220799 DB	'CreatePercent', 00H
	ORG $+2
$SG220800 DB	'ResearchPercent', 00H
$SG220801 DB	'GoldPercent', 00H
$SG220802 DB	'GoldGiftMod', 00H
$SG220803 DB	'BuildPercent', 00H
	ORG $+3
$SG220804 DB	'ImprovementPercent', 00H
	ORG $+1
$SG220805 DB	'GreatPeoplePercent', 00H
	ORG $+1
$SG220806 DB	'CulturePercent', 00H
	ORG $+1
$SG220807 DB	'FaithPercent', 00H
	ORG $+3
$SG220808 DB	'BarbPercent', 00H
$SG220809 DB	'FeatureProductionPercent', 00H
	ORG $+3
$SG220810 DB	'UnitDiscoverPercent', 00H
$SG220811 DB	'UnitHurryPercent', 00H
	ORG $+3
$SG220812 DB	'UnitTradePercent', 00H
	ORG $+3
$SG220813 DB	'GoldenAgePercent', 00H
	ORG $+3
$SG220814 DB	'HurryPercent', 00H
	ORG $+3
$SG220815 DB	'InflationOffset', 00H
$SG220816 DB	'InflationPercent', 00H
	ORG $+3
$SG220817 DB	'ReligiousPressureAdjacentCity', 00H
	ORG $+2
$SG220818 DB	'VictoryDelayPercent', 00H
$SG220819 DB	'MinorCivElectionFreqMod', 00H
$SG220820 DB	'OpinionDurationPercent', 00H
	ORG $+1
$SG220821 DB	'SpyRatePercent', 00H
	ORG $+1
$SG220822 DB	'PeaceDealDuration', 00H
	ORG $+2
$SG220823 DB	'RelationshipDuration', 00H
	ORG $+3
$SG220824 DB	'LeaguePercent', 00H
	ORG $+2
$SG220832 DB	'select count(*) from GameSpeed_Turns where GameSpeedType'
	DB	' = ''%s''', 00H
$SG220836 DB	'select * from GameSpeed_Turns where GameSpeedType = ''%s'
	DB	'''', 00H
	ORG $+3
$SG220844 DB	'MonthIncrement', 00H
	ORG $+1
$SG220845 DB	'TurnsPerIncrement', 00H
	ORG $+2
$SG220867 DB	'BaseTime', 00H
	ORG $+3
$SG220868 DB	'CityResource', 00H
	ORG $+3
$SG220869 DB	'UnitResource', 00H
	ORG $+3
$SG220870 DB	'FirstTurnMultiplier', 00H
$SG220990 DB	'Time', 00H
	ORG $+3
$SG220991 DB	'Cost', 00H
	ORG $+3
$SG220992 DB	'CostIncreasePerImprovement', 00H
	ORG $+1
$SG220993 DB	'Kill', 00H
	ORG $+3
$SG220994 DB	'Repair', 00H
	ORG $+1
$SG220995 DB	'RemoveRoute', 00H
$SG220996 DB	'Water', 00H
	ORG $+2
$SG220997 DB	'CanBeEmbarked', 00H
	ORG $+2
$SG220998 DB	'SpecificCivRequired', 00H
$SG221000 DB	'CivilizationType', 00H
	ORG $+3
$SG221003 DB	'PrereqTech', 00H
	ORG $+1
$SG221005 DB	'ImprovementType', 00H
$SG221007 DB	'RouteType', 00H
	ORG $+2
$SG221009 DB	'EntityEvent', 00H
$SG221011 DB	'Features', 00H
	ORG $+3
$SG221012 DB	'Features', 00H
	ORG $+3
$SG221013 DB	'Features', 00H
	ORG $+3
$SG221014 DB	'Features', 00H
	ORG $+3
$SG221015 DB	'Features', 00H
	ORG $+3
$SG221021 DB	'Features', 00H
	ORG $+3
$SG221024 DB	'select * from BuildFeatures where BuildType = ''%s''', 00H
	ORG $+1
$SG221031 DB	'FeatureType', 00H
$SG221034 DB	'PrereqTech', 00H
	ORG $+1
$SG221035 DB	'Time', 00H
	ORG $+3
$SG221036 DB	'Production', 00H
	ORG $+1
$SG221037 DB	'Food', 00H
	ORG $+3
$SG221038 DB	'Cost', 00H
	ORG $+3
$SG221039 DB	'Remove', 00H
	ORG $+1
$SG221041 DB	'TimeChange', 00H
	ORG $+1
$SG221042 DB	'BuildType', 00H
	ORG $+2
$SG221043 DB	'TechType', 00H
	ORG $+3
$SG221044 DB	'Build_TechTimeChanges', 00H
	ORG $+2
$SG221045 DB	'Technologies', 00H
	ORG $+3
$SG221065 DB	'LOAD ERROR: Build Type not found', 00H
	ORG $+3
$SG221184 DB	'ChooseDescription', 00H
	ORG $+2
$SG221187 DB	'Sound', 00H
	ORG $+2
$SG221189 DB	'Gold', 00H
	ORG $+3
$SG221190 DB	'NumGoldRandRolls', 00H
	ORG $+3
$SG221191 DB	'GoldRandAmount', 00H
	ORG $+1
$SG221192 DB	'MapOffset', 00H
	ORG $+2
$SG221193 DB	'MapRange', 00H
	ORG $+3
$SG221194 DB	'MapProb', 00H
$SG221195 DB	'Experience', 00H
	ORG $+1
$SG221196 DB	'Healing', 00H
$SG221197 DB	'DamagePrereq', 00H
	ORG $+3
$SG221198 DB	'Population', 00H
	ORG $+1
$SG221199 DB	'Culture', 00H
$SG221200 DB	'Faith', 00H
	ORG $+2
$SG221201 DB	'ProphetPercent', 00H
	ORG $+1
$SG221202 DB	'RevealNearbyBarbariansRange', 00H
$SG221203 DB	'BarbarianUnitProb', 00H
	ORG $+2
$SG221204 DB	'MinBarbarians', 00H
	ORG $+2
$SG221205 DB	'Tech', 00H
	ORG $+3
$SG221206 DB	'Bad', 00H
$SG221207 DB	'RevealUnknownResource', 00H
	ORG $+2
$SG221208 DB	'UpgradeUnit', 00H
$SG221209 DB	'PantheonFaith', 00H
	ORG $+2
$SG221210 DB	'UnitClass', 00H
	ORG $+2
$SG221211 DB	'BarbarianUnitClass', 00H
	ORG $+1
$SG221258 DB	'GoldMaintenance', 00H
$SG221259 DB	'AdvancedStartCost', 00H
	ORG $+2
$SG221260 DB	'Value', 00H
	ORG $+2
$SG221261 DB	'Movement', 00H
	ORG $+3
$SG221262 DB	'FlatMovement', 00H
	ORG $+3
$SG221263 DB	'Industrial', 00H
	ORG $+1
$SG221265 DB	'RouteType', 00H
	ORG $+2
$SG221266 DB	'Route_Yields', 00H
	ORG $+3
$SG221267 DB	'MovementChange', 00H
	ORG $+1
$SG221268 DB	'RouteType', 00H
	ORG $+2
$SG221269 DB	'TechType', 00H
	ORG $+3
$SG221270 DB	'Route_TechMovementChanges', 00H
	ORG $+2
$SG221271 DB	'Technologies', 00H
	ORG $+3
$SG221272 DB	'Cost', 00H
	ORG $+3
$SG221273 DB	'RouteType', 00H
	ORG $+2
$SG221274 DB	'ResourceType', 00H
	ORG $+3
$SG221275 DB	'Route_ResourceQuantityRequirements', 00H
	ORG $+1
$SG221276 DB	'Resources', 00H
	ORG $+2
$SG221289 DB	'UniqueRange', 00H
$SG221818 DB	'StartingResourceQuantity', 00H
	ORG $+3
$SG221819 DB	'AITradeModifier', 00H
$SG221820 DB	'AIObjective', 00H
$SG221821 DB	'Happiness', 00H
	ORG $+2
$SG221822 DB	'WonderProductionMod', 00H
$SG221824 DB	'WonderProductionModObsoleteEra', 00H
	ORG $+1
$SG221826 DB	'MinAreaSize', 00H
$SG221827 DB	'MinLatitude', 00H
$SG221828 DB	'MaxLatitude', 00H
$SG221829 DB	'PlacementOrder', 00H
	ORG $+1
$SG221830 DB	'ConstAppearance', 00H
$SG221831 DB	'Player', 00H
	ORG $+1
$SG221832 DB	'TilesPer', 00H
	ORG $+3
$SG221833 DB	'MinLandPercent', 00H
	ORG $+1
$SG221834 DB	'Unique', 00H
	ORG $+1
$SG221835 DB	'GroupRange', 00H
	ORG $+1
$SG221836 DB	'GroupRand', 00H
	ORG $+2
$SG221837 DB	'PresentOnAllValidPlots', 00H
	ORG $+1
$SG221838 DB	'Area', 00H
	ORG $+3
$SG221839 DB	'Hills', 00H
	ORG $+2
$SG221840 DB	'Flatlands', 00H
	ORG $+2
$SG221841 DB	'NoRiverSide', 00H
$SG221842 DB	'Normalize', 00H
	ORG $+2
$SG221843 DB	'OnlyMinorCivs', 00H
	ORG $+2
$SG221845 DB	'CivilizationType', 00H
	ORG $+3
$SG221847 DB	'RandApp1', 00H
	ORG $+3
$SG221848 DB	'RandApp2', 00H
	ORG $+3
$SG221849 DB	'RandApp3', 00H
	ORG $+3
$SG221850 DB	'RandApp4', 00H
	ORG $+3
$SG221852 DB	'ResourceUsage', 00H
	ORG $+2
$SG221854 DB	'ResourceClassType', 00H
	ORG $+2
$SG221856 DB	'IconString', 00H
	ORG $+1
$SG221858 DB	'ArtDefineTag', 00H
	ORG $+3
$SG221860 DB	'ArtDefineTagHeavy', 00H
	ORG $+2
$SG221862 DB	'AltArtDefineTag', 00H
$SG221864 DB	'AltArtDefineTagHeavy', 00H
	ORG $+3
$SG221866 DB	'TechReveal', 00H
	ORG $+1
$SG221868 DB	'PolicyReveal', 00H
	ORG $+3
$SG221870 DB	'TechCityTrade', 00H
	ORG $+2
$SG221872 DB	'TechObsolete', 00H
	ORG $+3
$SG221874 DB	'AIStopTradingEra', 00H
	ORG $+3
$SG221876 DB	'ResourceType', 00H
	ORG $+3
$SG221877 DB	'Resource_YieldChanges', 00H
	ORG $+2
$SG221878 DB	'ResourceType', 00H
	ORG $+3
$SG221879 DB	'Resource_Flavors', 00H
	ORG $+3
$SG221880 DB	'ResourceType', 00H
	ORG $+3
$SG221881 DB	'TerrainType', 00H
$SG221882 DB	'Resource_TerrainBooleans', 00H
	ORG $+3
$SG221883 DB	'Terrains', 00H
	ORG $+3
$SG221884 DB	'ResourceType', 00H
	ORG $+3
$SG221885 DB	'FeatureType', 00H
$SG221886 DB	'Resource_FeatureBooleans', 00H
	ORG $+3
$SG221887 DB	'Features', 00H
	ORG $+3
$SG221888 DB	'ResourceType', 00H
	ORG $+3
$SG221889 DB	'TerrainType', 00H
$SG221890 DB	'Resource_FeatureTerrainBooleans', 00H
$SG221891 DB	'Terrains', 00H
	ORG $+3
$SG221895 DB	'select Quantity from Resource_QuantityTypes where Resour'
	DB	'ceType = ''%s'';', 00H
	ORG $+1
$SG221903 DB	'Resource_UnitCombatProductionCostModifiersLocal', 00H
$SG221907 DB	'select UnitCombatInfos.ID as UnitCombatInfosID, Required'
	DB	'Era, ObsoleteEra, CostModifier from Resource_UnitCombatProduc'
	DB	'tionCostModifiersLocal inner join UnitCombatInfos on UnitComb'
	DB	'atType = UnitCombatInfos.Type where ResourceType = ?', 00H
	ORG $+1
$SG221935 DB	'Resource_BuildingProductionCostModifiersLocal', 00H
	ORG $+2
$SG221939 DB	'select RequiredEra, ObsoleteEra, CostModifier from Resou'
	DB	'rce_BuildingProductionCostModifiersLocal where ResourceType ='
	DB	' ?', 00H
$SG222100 DB	'ArtDefineTag', 00H
	ORG $+3
$SG222101 DB	'StartingLocationWeight', 00H
	ORG $+1
$SG222102 DB	'Movement', 00H
	ORG $+3
$SG222103 DB	'SeeThrough', 00H
	ORG $+1
$SG222104 DB	'Defense', 00H
$SG222105 DB	'InfluenceCost', 00H
	ORG $+2
$SG222106 DB	'AdvancedStartRemoveCost', 00H
$SG222107 DB	'TurnDamage', 00H
	ORG $+1
$SG222108 DB	'AppearanceProbability', 00H
	ORG $+2
$SG222109 DB	'DisappearanceProbability', 00H
	ORG $+3
$SG222110 DB	'Growth', 00H
	ORG $+1
$SG222111 DB	'FirstFinderGold', 00H
$SG222112 DB	'InBorderHappiness', 00H
	ORG $+2
$SG222113 DB	'OccurrenceFrequency', 00H
$SG222115 DB	'AdjacentUnitFreePromotion', 00H
	ORG $+2
$SG222117 DB	'GrowthTerrainType', 00H
	ORG $+2
$SG222119 DB	'EffectProbability', 00H
	ORG $+2
$SG222120 DB	'YieldNotAdditive', 00H
	ORG $+3
$SG222121 DB	'NoCoast', 00H
$SG222122 DB	'NoRiver', 00H
$SG222123 DB	'NoAdjacent', 00H
	ORG $+1
$SG222124 DB	'RequiresFlatlands', 00H
	ORG $+2
$SG222125 DB	'RequiresRiver', 00H
	ORG $+2
$SG222126 DB	'AddsFreshWater', 00H
	ORG $+1
$SG222127 DB	'Impassable', 00H
	ORG $+1
$SG222128 DB	'NoCity', 00H
	ORG $+1
$SG222129 DB	'NoImprovement', 00H
	ORG $+2
$SG222130 DB	'VisibleAlways', 00H
	ORG $+2
$SG222131 DB	'NukeImmune', 00H
	ORG $+1
$SG222132 DB	'Rough', 00H
	ORG $+2
$SG222133 DB	'NaturalWonder', 00H
	ORG $+2
$SG222134 DB	'EffectType', 00H
	ORG $+1
$SG222135 DB	'EffectTypeTag', 00H
	ORG $+2
$SG222137 DB	'WorldSoundscapeAudioScript', 00H
	ORG $+1
$SG222140 DB	'Warning: Missing soundscape definition in XML for featur'
	DB	'e: ''%s''', 00H
$SG222142 DB	'FeatureType', 00H
$SG222143 DB	'Feature_YieldChanges', 00H
	ORG $+3
$SG222144 DB	'FeatureType', 00H
$SG222145 DB	'Feature_RiverYieldChanges', 00H
	ORG $+2
$SG222146 DB	'FeatureType', 00H
$SG222147 DB	'Feature_HillsYieldChanges', 00H
	ORG $+2
$SG222148 DB	'FeatureType', 00H
$SG222149 DB	'TerrainType', 00H
$SG222150 DB	'Feature_TerrainBooleans', 00H
$SG222151 DB	'Terrains', 00H
	ORG $+3
$SG222197 DB	'HillsChange', 00H
$SG222198 DB	'MountainChange', 00H
	ORG $+1
$SG222199 DB	'LakeChange', 00H
	ORG $+1
$SG222200 DB	'CityChange', 00H
	ORG $+1
$SG222201 DB	'PopulationChangeOffset', 00H
	ORG $+1
$SG222202 DB	'PopulationChangeDivisor', 00H
$SG222203 DB	'MinCity', 00H
$SG222204 DB	'MinCityOnHillsAdjust', 00H
	ORG $+3
$SG222205 DB	'GoldenAgeYield', 00H
	ORG $+1
$SG222206 DB	'GoldenAgeYieldThreshold', 00H
$SG222207 DB	'GoldenAgeYieldMod', 00H
	ORG $+2
$SG222208 DB	'AIWeightPercent', 00H
$SG222287 DB	'ArtDefineTag', 00H
	ORG $+3
$SG222288 DB	'Water', 00H
	ORG $+2
$SG222289 DB	'Impassable', 00H
	ORG $+1
$SG222290 DB	'Found', 00H
	ORG $+2
$SG222291 DB	'FoundCoast', 00H
	ORG $+1
$SG222292 DB	'FoundFreshWater', 00H
$SG222293 DB	'Movement', 00H
	ORG $+3
$SG222294 DB	'SeeFrom', 00H
$SG222295 DB	'SeeThrough', 00H
	ORG $+1
$SG222296 DB	'BuildModifier', 00H
	ORG $+2
$SG222297 DB	'Defense', 00H
$SG222298 DB	'InfluenceCost', 00H
	ORG $+2
$SG222300 DB	'WorldSoundscapeAudioScript', 00H
	ORG $+5
$SG222303 DB	'Warning: Missing soundscape definition in XML for featur'
	DB	'e: ''%s''', 00H
$SG222305 DB	'TerrainType', 00H
$SG222306 DB	'Terrain_Yields', 00H
	ORG $+1
$SG222307 DB	'TerrainType', 00H
$SG222308 DB	'Terrain_RiverYieldChanges', 00H
	ORG $+2
$SG222309 DB	'TerrainType', 00H
$SG222310 DB	'Terrain_HillsYieldChanges', 00H
	ORG $+2
$SG222311 DB	'EffectTypeTag', 00H
	ORG $+2
$SG222340 DB	'CursorType', 00H
	ORG $+1
$SG222342 DB	'Mission', 00H
$SG222343 DB	'Visible', 00H
$SG222344 DB	'HighlightPlot', 00H
	ORG $+2
$SG222345 DB	'SelectType', 00H
	ORG $+1
$SG222346 DB	'SelectAll', 00H
	ORG $+2
$SG222429 DB	'ArtDefineTag', 00H
	ORG $+3
$SG222430 DB	'VictoryCompetitiveness', 00H
	ORG $+1
$SG222431 DB	'WonderCompetitiveness', 00H
	ORG $+2
$SG222432 DB	'MinorCivCompetitiveness', 00H
$SG222433 DB	'Boldness', 00H
	ORG $+3
$SG222434 DB	'DiploBalance', 00H
	ORG $+3
$SG222435 DB	'WarmongerHate', 00H
	ORG $+2
$SG222436 DB	'DenounceWillingness', 00H
$SG222437 DB	'DoFWillingness', 00H
	ORG $+1
$SG222438 DB	'Loyalty', 00H
$SG222439 DB	'Neediness', 00H
	ORG $+2
$SG222440 DB	'Forgiveness', 00H
$SG222441 DB	'Chattiness', 00H
	ORG $+1
$SG222442 DB	'Meanness', 00H
	ORG $+3
$SG222444 DB	'LeaderType', 00H
	ORG $+1
$SG222445 DB	'Leader_Flavors', 00H
	ORG $+1
$SG222446 DB	'Bias', 00H
	ORG $+3
$SG222447 DB	'LeaderType', 00H
	ORG $+1
$SG222448 DB	'MajorCivApproachType', 00H
	ORG $+3
$SG222449 DB	'Leader_MajorCivApproachBiases', 00H
	ORG $+2
$SG222450 DB	'MajorCivApproachTypes', 00H
	ORG $+2
$SG222451 DB	'Bias', 00H
	ORG $+3
$SG222452 DB	'LeaderType', 00H
	ORG $+1
$SG222453 DB	'MinorCivApproachType', 00H
	ORG $+3
$SG222454 DB	'Leader_MinorCivApproachBiases', 00H
	ORG $+2
$SG222455 DB	'MinorCivApproachTypes', 00H
	ORG $+2
$SG222456 DB	'LeaderType', 00H
	ORG $+1
$SG222457 DB	'TraitType', 00H
	ORG $+2
$SG222458 DB	'Leader_Traits', 00H
	ORG $+2
$SG222459 DB	'Traits', 00H
	ORG $+1
$SG222500 DB	'GAMEOPTION_ALLOW_EXTRA_RELIGIONS', 00H
	ORG $+3
$SG222555 DB	'DefaultPlayers', 00H
	ORG $+1
$SG222556 DB	'DefaultMinorCivs', 00H
	ORG $+3
$SG222557 DB	'FogTilesPerBarbarianCamp', 00H
	ORG $+3
$SG222558 DB	'NumNaturalWonders', 00H
	ORG $+2
$SG222559 DB	'UnitNameModifier', 00H
	ORG $+3
$SG222560 DB	'TargetNumCities', 00H
$SG222561 DB	'NumFreeBuildingResources', 00H
	ORG $+3
$SG222562 DB	'BuildingClassPrereqModifier', 00H
$SG222563 DB	'MaxConscriptModifier', 00H
	ORG $+3
$SG222564 DB	'GridWidth', 00H
	ORG $+2
$SG222565 DB	'GridHeight', 00H
	ORG $+1
$SG222566 DB	'MaxActiveReligions', 00H
	ORG $+1
$SG222567 DB	'TerrainGrainChange', 00H
	ORG $+1
$SG222568 DB	'FeatureGrainChange', 00H
	ORG $+1
$SG222569 DB	'ResearchPercent', 00H
$SG222570 DB	'AdvancedStartPointsMod', 00H
	ORG $+1
$SG222571 DB	'NumCitiesUnhappinessPercent', 00H
$SG222572 DB	'NumCitiesPolicyCostMod', 00H
	ORG $+1
$SG222573 DB	'NumCitiesTechCostMod', 00H
	ORG $+3
$SG222574 DB	'EstimatedNumCities', 00H
	ORG $+1
$SG222637 DB	'DesertPercentChange', 00H
$SG222638 DB	'JungleLatitude', 00H
	ORG $+1
$SG222639 DB	'HillRange', 00H
	ORG $+2
$SG222640 DB	'MountainPercent', 00H
$SG222641 DB	'SnowLatitudeChange', 00H
	ORG $+1
$SG222642 DB	'TundraLatitudeChange', 00H
	ORG $+3
$SG222643 DB	'GrassLatitudeChange', 00H
$SG222644 DB	'DesertBottomLatitudeChange', 00H
	ORG $+1
$SG222645 DB	'DesertTopLatitudeChange', 00H
$SG222646 DB	'IceLatitude', 00H
$SG222647 DB	'RandIceLatitude', 00H
$SG222684 DB	'SeaLevelChange', 00H
	ORG $+1
$SG222729 DB	'TechPrereq', 00H
	ORG $+1
$SG222731 DB	'ProcessType', 00H
$SG222732 DB	'Process_ProductionYields', 00H
	ORG $+3
$SG222733 DB	'ProcessType', 00H
$SG222734 DB	'Process_Flavors', 00H
$SG222794 DB	'PopulationThreshold', 00H
$SG222795 DB	'MinVoters', 00H
	ORG $+2
$SG222796 DB	'SecretaryGeneral', 00H
	ORG $+3
$SG222797 DB	'Victory', 00H
$SG222798 DB	'NoNukes', 00H
$SG222799 DB	'CityVoting', 00H
	ORG $+1
$SG222800 DB	'CivVoting', 00H
	ORG $+2
$SG222801 DB	'DefensivePact', 00H
	ORG $+2
$SG222802 DB	'OpenBorders', 00H
$SG222803 DB	'ForcePeace', 00H
	ORG $+1
$SG222804 DB	'ForceNoTrade', 00H
	ORG $+3
$SG222805 DB	'ForceWar', 00H
	ORG $+3
$SG222806 DB	'AssignCity', 00H
	ORG $+1
$SG222808 DB	'VoteType', 00H
	ORG $+3
$SG222809 DB	'DiploVoteType', 00H
	ORG $+2
$SG222810 DB	'Vote_DiploVotes', 00H
$SG222811 DB	'VoteSources', 00H
$SG222821 DB	'UpdateFormation', 00H
$SG222824 DB	'EntityEventInfo - AnimationPaths', 00H
	ORG $+7
$SG222827 DB	'select AnimationPaths.ID from EntityEvent_AnimationPaths'
	DB	' inner join AnimationPaths on AnimationPathType = AnimationPa'
	DB	'ths.Type where EntityEventType = ?', 00H
$SG222987 DB	'NoGoodies', 00H
	ORG $+2
$SG222988 DB	'NoBarbUnits', 00H
$SG222989 DB	'NoReligion', 00H
	ORG $+1
$SG222990 DB	'StartingUnitMultiplier', 00H
	ORG $+1
$SG222991 DB	'StartingDefenseUnits', 00H
	ORG $+3
$SG222992 DB	'StartingWorkerUnits', 00H
$SG222993 DB	'StartingExploreUnits', 00H
	ORG $+3
$SG222994 DB	'ResearchAgreementCost', 00H
	ORG $+2
$SG222995 DB	'EmbarkedUnitDefense', 00H
$SG222996 DB	'StartingGold', 00H
	ORG $+3
$SG222997 DB	'StartingCulture', 00H
$SG222998 DB	'FreePopulation', 00H
	ORG $+1
$SG222999 DB	'LaterEraBuildingConstructMod', 00H
	ORG $+3
$SG223000 DB	'StartPercent', 00H
	ORG $+3
$SG223001 DB	'BuildingMaintenancePercent', 00H
	ORG $+1
$SG223002 DB	'GrowthPercent', 00H
	ORG $+2
$SG223003 DB	'TrainPercent', 00H
	ORG $+3
$SG223004 DB	'ConstructPercent', 00H
	ORG $+3
$SG223005 DB	'CreatePercent', 00H
	ORG $+2
$SG223006 DB	'ResearchPercent', 00H
$SG223007 DB	'BuildPercent', 00H
	ORG $+3
$SG223008 DB	'ImprovementPercent', 00H
	ORG $+1
$SG223009 DB	'GreatPeoplePercent', 00H
	ORG $+1
$SG223010 DB	'EventChancePerTurn', 00H
	ORG $+1
$SG223011 DB	'SpiesGrantedForPlayer', 00H
	ORG $+2
$SG223012 DB	'SpiesGrantedForEveryone', 00H
$SG223013 DB	'FaithCostMultiplier', 00H
$SG223014 DB	'DiploEmphasisReligion', 00H
	ORG $+2
$SG223015 DB	'DiploEmphasisLatePolicies', 00H
	ORG $+2
$SG223016 DB	'TradeRouteFoodBonusTimes100', 00H
$SG223017 DB	'TradeRouteProductionBonusTimes100', 00H
	ORG $+2
$SG223018 DB	'LeaguePercent', 00H
	ORG $+2
$SG223019 DB	'WarmongerPercent', 00H
	ORG $+3
$SG223020 DB	'CityBombardEffectTag', 00H
	ORG $+3
$SG223021 DB	'AudioUnitVictoryScript', 00H
	ORG $+1
$SG223022 DB	'AudioUnitDefeatScript', 00H
	ORG $+2
$SG223023 DB	'ArtPrefix', 00H
	ORG $+2
$SG223024 DB	'ShortDescription', 00H
	ORG $+3
$SG223025 DB	'Abbreviation', 00H
	ORG $+3
$SG223027 DB	'Era - NewEraVOs', 00H
$SG223030 DB	'select VOScript from Era_NewEraVOs where EraType = ?', 00H
	ORG $+3
$SG223045 DB	'Alpha', 00H
	ORG $+2
$SG223046 DB	'Blue', 00H
	ORG $+3
$SG223047 DB	'Green', 00H
	ORG $+2
$SG223048 DB	'Red', 00H
$SG223068 DB	'select PrimaryColor.ID, SecondaryColor.ID, TextColor.ID '
	DB	'FROM PlayerColors INNER JOIN Colors As PrimaryColor ON Player'
	DB	'Colors.PrimaryColor = PrimaryColor.Type, Colors AS SecondaryC'
	DB	'olor ON PlayerColors.SecondaryColor = SecondaryColor.Type, Co'
	DB	'lors AS TextColor ON PlayerColors.TextColor = TextColor.Type '
	DB	'where PlayerColors.ID = ? LIMIT 1; ', 00H
$SG223070 DB	'ColorsLookup', 00H
	ORG $+3
$SG223092 DB	'Default', 00H
$SG223093 DB	'Visible', 00H
$SG223106 DB	'Default', 00H
$SG223119 DB	'Default', 00H
$SG223151 DB	'VoteInterval', 00H
	ORG $+3
$SG223153 DB	'PopupText', 00H
	ORG $+2
$SG223155 DB	'SecretaryGeneralText', 00H
	ORG $+3
$SG223158 DB	'FreeSpecialist', 00H
	ORG $+1
$SG223160 DB	'Policy', 00H
CONST	ENDS
PUBLIC	?Remark@@YA_NHPBDZZ				; Remark
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
;	COMDAT ?Remark@@YA_NHPBDZZ
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?Remark@@YA_NHPBDZZ PROC				; Remark, COMDAT

; 32   : REMARK_GROUP("CvInfos");

	xor	al, al
	ret	0
?Remark@@YA_NHPBDZZ ENDP				; Remark
_TEXT	ENDS
PUBLIC	?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z ; CvBaseInfo::CacheResult
EXTRN	??1CvDatabaseUtility@@QAE@XZ:PROC		; CvDatabaseUtility::~CvDatabaseUtility
EXTRN	??0CvDatabaseUtility@@QAE@XZ:PROC		; CvDatabaseUtility::CvDatabaseUtility
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z$0
__ehfuncinfo$?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z
_TEXT	SEGMENT
_kUtility$ = -56					; size = 44
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z PROC ; CvBaseInfo::CacheResult, COMDAT
; _this$ = ecx

; 42   : {

	push	-1
	push	__ehhandler$?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	mov	esi, ecx

; 43   : 	CvDatabaseUtility kUtility;

	lea	ecx, DWORD PTR _kUtility$[esp+64]
	call	??0CvDatabaseUtility@@QAE@XZ		; CvDatabaseUtility::CvDatabaseUtility

; 44   : 	return CacheResults(kResults, kUtility);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR _kResults$[esp+60]
	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR _kUtility$[esp+64]
	push	ecx
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+80], 0
	call	eax
	lea	ecx, DWORD PTR _kUtility$[esp+64]
	mov	bl, al
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	??1CvDatabaseUtility@@QAE@XZ		; CvDatabaseUtility::~CvDatabaseUtility

; 45   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	pop	esi
	mov	al, bl
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 56					; 00000038H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z$0:
	lea	ecx, DWORD PTR _kUtility$[ebp]
	jmp	??1CvDatabaseUtility@@QAE@XZ		; CvDatabaseUtility::~CvDatabaseUtility
__ehhandler$?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z ENDP ; CvBaseInfo::CacheResult
PUBLIC	?GetText@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetText
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	__imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetText@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetText@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetText, COMDAT
; _this$ = ecx

; 79   : {

	push	esi

; 80   : 	return (m_strText.empty())? NULL : m_strText.c_str();

	lea	esi, DWORD PTR [ecx+232]
	mov	ecx, esi
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN3@GetText
	xor	eax, eax
	pop	esi

; 81   : }

	ret	0
$LN3@GetText:

; 80   : 	return (m_strText.empty())? NULL : m_strText.c_str();

	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetText@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetText
_TEXT	ENDS
PUBLIC	?GetTextKey@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetTextKey
; Function compile flags: /Ogtpy
;	COMDAT ?GetTextKey@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetTextKey@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetTextKey, COMDAT
; _this$ = ecx

; 84   : {

	push	esi

; 85   : 	return (m_strTextKey.empty())? NULL : m_strTextKey.c_str();

	lea	esi, DWORD PTR [ecx+204]
	mov	ecx, esi
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN3@GetTextKey
	xor	eax, eax
	pop	esi

; 86   : }

	ret	0
$LN3@GetTextKey:

; 85   : 	return (m_strTextKey.empty())? NULL : m_strTextKey.c_str();

	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetTextKey@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetTextKey
_TEXT	ENDS
PUBLIC	??8CvBaseInfo@@UBE_NABV0@@Z			; CvBaseInfo::operator==
EXTRN	__imp_??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??8CvBaseInfo@@UBE_NABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??8CvBaseInfo@@UBE_NABV0@@Z PROC			; CvBaseInfo::operator==, COMDAT
; _this$ = ecx

; 89   : {

	push	esi
	push	edi

; 90   : 	if(this == &rhs) return true;

	mov	edi, DWORD PTR _rhs$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	jne	SHORT $LN10@operator
	pop	edi
	mov	al, 1
	pop	esi

; 100  : 	return true;
; 101  : }

	ret	4
$LN10@operator:

; 91   : 	if(m_iID != rhs.m_iID) return false;

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [edi+4]
	je	SHORT $LN9@operator
	pop	edi
	xor	al, al
	pop	esi

; 100  : 	return true;
; 101  : }

	ret	4
$LN9@operator:
	push	ebx

; 92   : 	if(m_strCivilopedia != rhs.m_strCivilopedia) return false;

	mov	ebx, DWORD PTR __imp_??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	lea	edx, DWORD PTR [esi+8]
	push	edx
	call	ebx
	add	esp, 8
	test	al, al
	jne	SHORT $LN14@operator

; 93   : 	if(m_strDescription != rhs.m_strDescription) return false;

	lea	eax, DWORD PTR [edi+36]
	push	eax
	lea	ecx, DWORD PTR [esi+36]
	push	ecx
	call	ebx
	add	esp, 8
	test	al, al
	jne	SHORT $LN14@operator

; 94   : 	if(m_strHelp != rhs.m_strHelp) return false;

	lea	edx, DWORD PTR [edi+92]
	push	edx
	lea	eax, DWORD PTR [esi+92]
	push	eax
	call	ebx
	add	esp, 8
	test	al, al
	jne	SHORT $LN14@operator

; 95   : 	if(m_strDisabledHelp != rhs.m_strDisabledHelp) return false;

	lea	ecx, DWORD PTR [edi+120]
	push	ecx
	lea	edx, DWORD PTR [esi+120]
	push	edx
	call	ebx
	add	esp, 8
	test	al, al
	jne	SHORT $LN14@operator

; 96   : 	if(m_strStrategy != rhs.m_strStrategy) return false;

	lea	eax, DWORD PTR [edi+148]
	push	eax
	lea	ecx, DWORD PTR [esi+148]
	push	ecx
	call	ebx
	add	esp, 8
	test	al, al
	jne	SHORT $LN14@operator

; 97   : 	if(m_strType != rhs.m_strType) return false;

	lea	edx, DWORD PTR [edi+176]
	push	edx
	lea	eax, DWORD PTR [esi+176]
	push	eax
	call	ebx
	add	esp, 8
	test	al, al
	jne	SHORT $LN14@operator

; 98   : 	if(m_strTextKey != rhs.m_strTextKey) return false;

	lea	ecx, DWORD PTR [edi+204]
	push	ecx
	lea	edx, DWORD PTR [esi+204]
	push	edx
	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN2@operator
$LN14@operator:
	pop	ebx
	pop	edi
	xor	al, al
	pop	esi

; 100  : 	return true;
; 101  : }

	ret	4
$LN2@operator:

; 99   : 	if(m_strText != rhs.m_strText) return false;

	add	edi, 232				; 000000e8H
	push	edi
	add	esi, 232				; 000000e8H
	push	esi
	call	ebx
	add	esp, 8
	pop	ebx
	test	al, al
	pop	edi
	sete	al
	pop	esi

; 100  : 	return true;
; 101  : }

	ret	4
??8CvBaseInfo@@UBE_NABV0@@Z ENDP			; CvBaseInfo::operator==
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvBaseInfo@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvBaseInfo@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvBaseInfo@@@Z PROC	; operator<<, COMDAT

; 131  : 	readFrom.writeTo(saveTo);

	mov	ecx, DWORD PTR _readFrom$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	push	esi
	call	edx

; 132  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 133  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvBaseInfo@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvBaseInfo@@@Z	; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvBaseInfo@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvBaseInfo@@@Z PROC	; operator>>, COMDAT

; 137  : 	writeTo.readFrom(loadFrom);

	mov	ecx, DWORD PTR _writeTo$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	esi
	call	edx

; 138  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 139  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvBaseInfo@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	?GetHotKeyInt@CvHotKeyInfo@@IAEHPBD@Z		; CvHotKeyInfo::GetHotKeyInt
; Function compile flags: /Ogtpy
;	COMDAT ?GetHotKeyInt@CvHotKeyInfo@@IAEHPBD@Z
_TEXT	SEGMENT
_asCvKeyBoardMapping$ = -3456				; size = 3456
_pszHotKeyVal$ = 8					; size = 4
?GetHotKeyInt@CvHotKeyInfo@@IAEHPBD@Z PROC		; CvHotKeyInfo::GetHotKeyInt, COMDAT
; _this$ = ecx

; 169  : {

	sub	esp, 3456				; 00000d80H

; 186  : 		{"KB_4",FKBInputDevice::KB_4},

	push	ebx

; 187  : 		{"KB_5",FKBInputDevice::KB_5},

	push	esi

; 188  : 		{"KB_6",FKBInputDevice::KB_6},

	push	edi

; 170  : 	// SPEEDUP
; 171  : 	struct CvKeyBoardMapping
; 172  : 	{
; 173  : 		char szDefineString[25];
; 174  : 		int iIntVal;
; 175  : 	};
; 176  : 
; 177  : 
; 178  : 	const int iNumKeyBoardMappings=108;
; 179  : 	const CvKeyBoardMapping asCvKeyBoardMapping[iNumKeyBoardMappings] =
; 180  : 	{
; 181  : 		{"KB_ESCAPE",FKBInputDevice::KB_ESCAPE},

	mov	eax, DWORD PTR $SG218686
	movzx	edx, WORD PTR $SG218686+8
	mov	ecx, DWORD PTR $SG218686+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3468], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3478], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3482], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3486], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+3490], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3492], al

; 182  : 		{"KB_0",FKBInputDevice::KB_0},

	mov	eax, DWORD PTR $SG218687
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3500], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3505], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3509], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3513], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3517], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3521], eax

; 183  : 		{"KB_1",FKBInputDevice::KB_1},

	movzx	eax, BYTE PTR $SG218688+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3536], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3472], ecx
	movzx	ecx, BYTE PTR $SG218687+4
	mov	WORD PTR _asCvKeyBoardMapping$[esp+3476], dx
	mov	edx, DWORD PTR $SG218688
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3537], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3541], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3545], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3549], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3553], eax

; 184  : 		{"KB_2",FKBInputDevice::KB_2},

	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3569], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3573], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3577], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3581], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3585], eax

; 185  : 		{"KB_3",FKBInputDevice::KB_3},

	mov	eax, DWORD PTR $SG218690
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3532], edx
	movzx	edx, BYTE PTR $SG218689+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3596], eax
	xor	eax, eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3504], cl
	mov	ecx, DWORD PTR $SG218689
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3601], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3605], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3609], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3613], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3617], eax

; 186  : 		{"KB_4",FKBInputDevice::KB_4},

	movzx	eax, BYTE PTR $SG218691+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3564], ecx
	movzx	ecx, BYTE PTR $SG218690+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3568], dl
	mov	edx, DWORD PTR $SG218691
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3628], edx

; 187  : 		{"KB_5",FKBInputDevice::KB_5},

	movzx	edx, BYTE PTR $SG218692+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3632], al
	xor	eax, eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3600], cl
	mov	ecx, DWORD PTR $SG218692
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3633], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3637], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3641], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3645], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3649], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3665], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3669], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3673], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3677], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3681], eax

; 188  : 		{"KB_6",FKBInputDevice::KB_6},

	mov	eax, DWORD PTR $SG218693
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3496], 1
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3528], 2
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3560], 3
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3592], 4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3624], 5
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3656], 6
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3660], ecx
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3664], dl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3688], 7
	movzx	ecx, BYTE PTR $SG218693+4

; 189  : 		{"KB_7",FKBInputDevice::KB_7},

	mov	edx, DWORD PTR $SG218694
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3692], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3697], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3701], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3705], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3709], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3713], eax
	movzx	eax, BYTE PTR $SG218694+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3728], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3729], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3733], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3737], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3741], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3745], eax

; 190  : 		{"KB_8",FKBInputDevice::KB_8},

	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3761], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3765], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3769], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3773], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3777], eax

; 191  : 		{"KB_9",FKBInputDevice::KB_9},

	mov	eax, DWORD PTR $SG218696
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3788], eax
	xor	eax, eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3696], cl
	mov	ecx, DWORD PTR $SG218695
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3793], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3797], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3801], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3805], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3809], eax

; 192  : 		{"KB_MINUS",FKBInputDevice::KB_MINUS},	    /* - on main keyboard */

	mov	eax, DWORD PTR $SG218697+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3756], ecx
	movzx	ecx, BYTE PTR $SG218696+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3824], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3724], edx
	movzx	edx, BYTE PTR $SG218695+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3829], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3833], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3837], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3841], eax

; 193  : 		{"KB_A",FKBInputDevice::KB_A},

	movzx	eax, BYTE PTR $SG218698+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3792], cl
	movzx	ecx, BYTE PTR $SG218697+8
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3760], dl
	mov	edx, DWORD PTR $SG218697
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3856], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3820], edx
	mov	edx, DWORD PTR $SG218698
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3828], cl

; 194  : 		{"KB_B",FKBInputDevice::KB_B},

	mov	ecx, DWORD PTR $SG218699
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3857], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3861], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3865], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3869], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3873], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3889], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3893], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3897], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3901], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3905], eax

; 195  : 		{"KB_C",FKBInputDevice::KB_C},

	mov	eax, DWORD PTR $SG218700
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3852], edx
	movzx	edx, BYTE PTR $SG218699+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3884], ecx
	movzx	ecx, BYTE PTR $SG218700+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3916], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3720], 8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3752], 9
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3784], 10 ; 0000000aH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3816], 11 ; 0000000bH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3848], 12 ; 0000000cH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3880], 13 ; 0000000dH
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3888], dl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3912], 14 ; 0000000eH
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3920], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3921], eax

; 196  : 		{"KB_D",FKBInputDevice::KB_D},

	mov	edx, DWORD PTR $SG218701

; 197  : 		{"KB_E",FKBInputDevice::KB_E},

	mov	ecx, DWORD PTR $SG218702
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3925], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3929], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3933], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3937], eax
	movzx	eax, BYTE PTR $SG218701+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3952], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3953], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3957], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3961], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3965], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3969], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3985], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3989], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3993], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3997], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4001], eax

; 198  : 		{"KB_F",FKBInputDevice::KB_F},

	mov	eax, DWORD PTR $SG218703
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4012], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4017], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4021], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4025], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4029], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4033], eax

; 199  : 		{"KB_G",FKBInputDevice::KB_G},

	movzx	eax, BYTE PTR $SG218704+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4048], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3948], edx
	movzx	edx, BYTE PTR $SG218702+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3980], ecx
	movzx	ecx, BYTE PTR $SG218703+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4049], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4053], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4057], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4061], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4065], eax

; 200  : 		{"KB_H",FKBInputDevice::KB_H},

	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4081], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4085], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4089], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4093], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4097], eax

; 201  : 		{"KB_I",FKBInputDevice::KB_I},

	mov	eax, DWORD PTR $SG218706
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+3984], dl
	mov	edx, DWORD PTR $SG218704
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4108], eax
	xor	eax, eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4016], cl
	mov	ecx, DWORD PTR $SG218705
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4044], edx
	movzx	edx, BYTE PTR $SG218705+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4113], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4117], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4121], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4125], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4129], eax

; 202  : 		{"KB_J",FKBInputDevice::KB_J},

	movzx	eax, BYTE PTR $SG218707+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4076], ecx
	movzx	ecx, BYTE PTR $SG218706+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4080], dl
	mov	edx, DWORD PTR $SG218707
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4144], al
	xor	eax, eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4112], cl

; 203  : 		{"KB_K",FKBInputDevice::KB_K},

	mov	ecx, DWORD PTR $SG218708
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3944], 15 ; 0000000fH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+3976], 16 ; 00000010H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4008], 17 ; 00000011H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4040], 18 ; 00000012H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4072], 19 ; 00000013H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4104], 20 ; 00000014H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4136], 21 ; 00000015H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4140], edx
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4145], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4149], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4153], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4157], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4161], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4168], 22 ; 00000016H
	movzx	edx, BYTE PTR $SG218708+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4177], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4181], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4185], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4189], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4193], eax

; 204  : 		{"KB_L",FKBInputDevice::KB_L},

	mov	eax, DWORD PTR $SG218709
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4204], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4209], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4213], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4217], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4221], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4225], eax

; 205  : 		{"KB_M",FKBInputDevice::KB_M},

	movzx	eax, BYTE PTR $SG218710+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4240], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4172], ecx
	movzx	ecx, BYTE PTR $SG218709+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4241], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4245], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4249], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4253], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4257], eax

; 206  : 		{"KB_N",FKBInputDevice::KB_N},

	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4273], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4277], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4281], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4285], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4289], eax

; 207  : 		{"KB_O",FKBInputDevice::KB_O},

	mov	eax, DWORD PTR $SG218712
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4300], eax
	xor	eax, eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4176], dl
	mov	edx, DWORD PTR $SG218710
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4208], cl
	mov	ecx, DWORD PTR $SG218711
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4305], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4309], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4313], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4317], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4321], eax

; 208  : 		{"KB_P",FKBInputDevice::KB_P},

	movzx	eax, BYTE PTR $SG218713+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4236], edx
	movzx	edx, BYTE PTR $SG218711+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4268], ecx
	movzx	ecx, BYTE PTR $SG218712+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4336], al
	xor	eax, eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4272], dl
	mov	edx, DWORD PTR $SG218713
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4304], cl

; 209  : 		{"KB_Q",FKBInputDevice::KB_Q},

	mov	ecx, DWORD PTR $SG218714
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4337], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4341], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4345], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4349], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4353], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4369], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4373], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4377], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4381], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4385], eax

; 210  : 		{"KB_R",FKBInputDevice::KB_R},

	mov	eax, DWORD PTR $SG218715
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4332], edx
	movzx	edx, BYTE PTR $SG218714+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4364], ecx
	movzx	ecx, BYTE PTR $SG218715+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4396], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4200], 23 ; 00000017H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4232], 24 ; 00000018H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4264], 25 ; 00000019H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4296], 26 ; 0000001aH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4328], 27 ; 0000001bH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4360], 28 ; 0000001cH
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4368], dl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4392], 29 ; 0000001dH
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4400], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4401], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4405], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4409], eax

; 211  : 		{"KB_S",FKBInputDevice::KB_S},

	mov	edx, DWORD PTR $SG218716

; 212  : 		{"KB_T",FKBInputDevice::KB_T},

	mov	ecx, DWORD PTR $SG218717
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4413], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4417], eax
	movzx	eax, BYTE PTR $SG218716+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4432], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4433], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4437], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4441], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4445], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4449], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4465], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4469], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4473], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4477], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4481], eax

; 213  : 		{"KB_U",FKBInputDevice::KB_U},

	mov	eax, DWORD PTR $SG218718
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4492], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4497], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4501], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4505], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4509], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4513], eax

; 214  : 		{"KB_V",FKBInputDevice::KB_V},

	movzx	eax, BYTE PTR $SG218719+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4428], edx
	movzx	edx, BYTE PTR $SG218717+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4528], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4460], ecx
	movzx	ecx, BYTE PTR $SG218718+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4529], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4533], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4537], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4541], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4545], eax

; 215  : 		{"KB_W",FKBInputDevice::KB_W},

	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4561], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4565], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4569], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4573], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4577], eax

; 216  : 		{"KB_X",FKBInputDevice::KB_X},

	mov	eax, DWORD PTR $SG218721
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4464], dl
	mov	edx, DWORD PTR $SG218719
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4496], cl
	mov	ecx, DWORD PTR $SG218720
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4588], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4524], edx
	movzx	edx, BYTE PTR $SG218720+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4556], ecx
	movzx	ecx, BYTE PTR $SG218721+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4593], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4597], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4601], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4605], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4609], eax

; 217  : 		{"KB_Y",FKBInputDevice::KB_Y},

	movzx	eax, BYTE PTR $SG218722+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4560], dl
	mov	edx, DWORD PTR $SG218722
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4592], cl

; 218  : 		{"KB_Z",FKBInputDevice::KB_Z},

	mov	ecx, DWORD PTR $SG218723
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4624], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4620], edx
	movzx	edx, BYTE PTR $SG218723+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4424], 30 ; 0000001eH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4456], 31 ; 0000001fH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4488], 32 ; 00000020H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4520], 33 ; 00000021H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4552], 34 ; 00000022H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4584], 35 ; 00000023H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4616], 36 ; 00000024H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4625], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4629], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4633], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4637], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4641], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4648], 37 ; 00000025H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4652], ecx
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4657], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4661], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4665], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4669], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4673], eax

; 219  : 		{"KB_EQUALS",FKBInputDevice::KB_EQUALS},

	mov	eax, DWORD PTR $SG218724
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4684], eax
	xor	eax, eax
	mov	ecx, DWORD PTR $SG218724+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4694], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4698], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4702], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+4706], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4708], al

; 220  : 		{"KB_BACKSPACE",FKBInputDevice::KB_BACKSPACE},

	mov	eax, DWORD PTR $SG218725
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4716], eax
	movzx	eax, BYTE PTR $SG218725+12
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4728], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4729], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4733], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4737], eax

; 221  : 		{"KB_TAB",FKBInputDevice::KB_TAB},

	movzx	eax, BYTE PTR $SG218726+6
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4754], al
	xor	eax, eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4656], dl
	movzx	edx, WORD PTR $SG218724+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4755], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4759], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4763], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4767], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+4771], ax

; 222  : 		{"KB_LBRACKET",FKBInputDevice::KB_LBRACKET},

	mov	eax, DWORD PTR $SG218727+8
	mov	WORD PTR _asCvKeyBoardMapping$[esp+4692], dx
	mov	edx, DWORD PTR $SG218725+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4788], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4688], ecx
	mov	ecx, DWORD PTR $SG218725+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4724], edx
	movzx	edx, WORD PTR $SG218726+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4792], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4796], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4800], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4804], al

; 223  : 		{"KB_RBRACKET",FKBInputDevice::KB_RBRACKET},

	mov	eax, DWORD PTR $SG218728+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4720], ecx
	mov	ecx, DWORD PTR $SG218726
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4820], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4748], ecx
	mov	ecx, DWORD PTR $SG218727
	mov	WORD PTR _asCvKeyBoardMapping$[esp+4752], dx
	mov	edx, DWORD PTR $SG218727+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4824], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4828], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4832], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4836], al

; 224  : 		{"KB_RETURN",FKBInputDevice::KB_RETURN},		/* Enter on main keyboard */

	movzx	eax, WORD PTR $SG218729+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4780], ecx
	mov	ecx, DWORD PTR $SG218728
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4784], edx
	mov	edx, DWORD PTR $SG218728+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4812], ecx
	mov	ecx, DWORD PTR $SG218729
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4816], edx
	mov	edx, DWORD PTR $SG218729+4
	mov	WORD PTR _asCvKeyBoardMapping$[esp+4852], ax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4680], 38 ; 00000026H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4712], 39 ; 00000027H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4744], 40 ; 00000028H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4776], 41 ; 00000029H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4808], 42 ; 0000002aH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4840], 43 ; 0000002bH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4844], ecx
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4848], edx
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4854], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4858], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4862], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+4866], ax

; 225  : 		{"KB_LCONTROL",FKBInputDevice::KB_LCONTROL},

	mov	edx, DWORD PTR $SG218730+4
	mov	ecx, DWORD PTR $SG218730
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4868], al
	mov	eax, DWORD PTR $SG218730+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4884], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4888], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4892], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4896], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4900], al

; 226  : 		{"KB_SEMICOLON",FKBInputDevice::KB_SEMICOLON},

	mov	eax, DWORD PTR $SG218731+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4916], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4921], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4925], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4929], eax

; 227  : 		{"KB_APOSTROPHE",FKBInputDevice::KB_APOSTROPHE},

	mov	eax, DWORD PTR $SG218732+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4944], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4876], ecx
	mov	ecx, DWORD PTR $SG218731
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4880], edx
	mov	edx, DWORD PTR $SG218731+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4954], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4958], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+4962], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4964], al

; 228  : 		{"KB_GRAVE",FKBInputDevice::KB_GRAVE},		/* accent grave */

	mov	eax, DWORD PTR $SG218733
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4908], ecx
	movzx	ecx, BYTE PTR $SG218731+12
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4912], edx
	mov	edx, DWORD PTR $SG218732
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4972], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4940], edx
	movzx	edx, WORD PTR $SG218732+12
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4981], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4985], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4989], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4993], eax

; 229  : 		{"KB_LSHIFT",FKBInputDevice::KB_LSHIFT},

	mov	eax, DWORD PTR $SG218734
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4920], cl
	mov	ecx, DWORD PTR $SG218732+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5004], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4948], ecx
	mov	ecx, DWORD PTR $SG218733+4
	mov	WORD PTR _asCvKeyBoardMapping$[esp+4952], dx
	movzx	edx, BYTE PTR $SG218733+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5014], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5018], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5022], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5026], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5028], al

; 230  : 		{"KB_BACKSLASH",FKBInputDevice::KB_BACKSLASH},

	mov	eax, DWORD PTR $SG218735
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4976], ecx
	mov	ecx, DWORD PTR $SG218734+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+4980], dl
	movzx	edx, WORD PTR $SG218734+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5036], eax
	movzx	eax, BYTE PTR $SG218735+12
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5008], ecx
	mov	ecx, DWORD PTR $SG218735+4
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5012], dx
	mov	edx, DWORD PTR $SG218735+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5040], ecx

; 231  : 		{"KB_COMMA",FKBInputDevice::KB_COMMA},

	mov	ecx, DWORD PTR $SG218736
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5048], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4872], 44 ; 0000002cH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4904], 45 ; 0000002dH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4936], 46 ; 0000002eH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+4968], 47 ; 0000002fH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5000], 48 ; 00000030H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5032], 49 ; 00000031H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5044], edx
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5049], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5053], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5057], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5064], 50 ; 00000032H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5068], ecx
	movzx	eax, BYTE PTR $SG218736+8
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5076], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5077], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5081], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5085], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5089], eax

; 232  : 		{"KB_PERIOD",FKBInputDevice::KB_PERIOD},

	movzx	eax, WORD PTR $SG218737+8
	mov	edx, DWORD PTR $SG218736+4
	mov	ecx, DWORD PTR $SG218737
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5108], ax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5110], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5114], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5118], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5122], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5124], al

; 233  : 		{"KB_SLASH",FKBInputDevice::KB_SLASH},

	movzx	eax, BYTE PTR $SG218738+8
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5140], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5141], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5145], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5149], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5153], eax

; 234  : 		{"KB_RSHIFT",FKBInputDevice::KB_RSHIFT},

	movzx	eax, WORD PTR $SG218739+8
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5172], ax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5174], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5178], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5182], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5186], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5188], al

; 235  : 		{"KB_NUMPADSTAR",FKBInputDevice::KB_NUMPADSTAR},

	mov	eax, DWORD PTR $SG218740+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5072], edx
	mov	edx, DWORD PTR $SG218737+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5100], ecx
	mov	ecx, DWORD PTR $SG218738
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5204], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5104], edx
	mov	edx, DWORD PTR $SG218738+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5132], ecx
	mov	ecx, DWORD PTR $SG218739
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5210], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5214], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5218], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5220], al

; 236  : 		{"KB_LALT",FKBInputDevice::KB_LALT},

	mov	eax, DWORD PTR $SG218741+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5136], edx
	mov	edx, DWORD PTR $SG218739+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5164], ecx
	mov	ecx, DWORD PTR $SG218740
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5232], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5168], edx
	mov	edx, DWORD PTR $SG218740+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5196], ecx
	movzx	ecx, WORD PTR $SG218740+12
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5236], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5240], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5244], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5248], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5252], al

; 237  : 		{"KB_SPACE",FKBInputDevice::KB_SPACE},

	movzx	eax, BYTE PTR $SG218742+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5200], edx
	mov	edx, DWORD PTR $SG218741
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5208], cx
	mov	ecx, DWORD PTR $SG218742
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5228], edx
	mov	edx, DWORD PTR $SG218742+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5268], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5096], 51 ; 00000033H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5128], 52 ; 00000034H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5160], 53 ; 00000035H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5192], 54 ; 00000036H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5224], 55 ; 00000037H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5256], 56 ; 00000038H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5260], ecx
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5264], edx
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5269], eax

; 238  : 		{"KB_CAPSLOCK",FKBInputDevice::KB_CAPSLOCK},

	mov	ecx, DWORD PTR $SG218743
	mov	edx, DWORD PTR $SG218743+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5273], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5277], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5281], eax
	mov	eax, DWORD PTR $SG218743+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5300], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5304], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5308], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5312], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5316], al

; 239  : 		{"KB_F1",FKBInputDevice::KB_F1},

	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5330], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5334], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5338], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5342], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5346], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5348], al

; 240  : 		{"KB_F2",FKBInputDevice::KB_F2},

	mov	eax, DWORD PTR $SG218745
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5356], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5362], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5366], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5370], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5374], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5378], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5380], al

; 241  : 		{"KB_F3",FKBInputDevice::KB_F3},

	movzx	eax, WORD PTR $SG218746+4
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5392], ax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5292], ecx
	mov	ecx, DWORD PTR $SG218744
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5296], edx
	movzx	edx, WORD PTR $SG218744+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5394], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5398], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5402], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5406], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5410], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5412], al

; 242  : 		{"KB_F4",FKBInputDevice::KB_F4},

	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5426], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5430], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5434], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5438], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5442], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5444], al

; 243  : 		{"KB_F5",FKBInputDevice::KB_F5},

	mov	eax, DWORD PTR $SG218748
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5324], ecx
	movzx	ecx, WORD PTR $SG218745+4
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5328], dx
	mov	edx, DWORD PTR $SG218746
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5452], eax
	xor	eax, eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5360], cx
	mov	ecx, DWORD PTR $SG218747
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5388], edx
	movzx	edx, WORD PTR $SG218747+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5458], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5462], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5466], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5470], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5474], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5476], al

; 244  : 		{"KB_F6",FKBInputDevice::KB_F6},

	movzx	eax, WORD PTR $SG218749+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5420], ecx
	movzx	ecx, WORD PTR $SG218748+4
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5424], dx
	mov	edx, DWORD PTR $SG218749
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5488], ax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5288], 57 ; 00000039H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5320], 58 ; 0000003aH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5352], 59 ; 0000003bH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5384], 60 ; 0000003cH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5416], 61 ; 0000003dH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5448], 62 ; 0000003eH
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5456], cx
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5480], 63 ; 0000003fH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5484], edx
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5490], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5494], eax

; 245  : 		{"KB_F7",FKBInputDevice::KB_F7},

	mov	ecx, DWORD PTR $SG218750
	movzx	edx, WORD PTR $SG218750+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5498], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5502], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5506], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5508], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5522], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5526], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5530], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5534], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5538], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5540], al

; 246  : 		{"KB_F8",FKBInputDevice::KB_F8},

	mov	eax, DWORD PTR $SG218751
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5548], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5554], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5558], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5562], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5566], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5570], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5572], al

; 247  : 		{"KB_F9",FKBInputDevice::KB_F9},

	movzx	eax, WORD PTR $SG218752+4
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5584], ax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5586], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5590], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5594], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5598], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5602], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5604], al

; 248  : 		{"KB_F10",FKBInputDevice::KB_F10},

	movzx	eax, BYTE PTR $SG218753+6
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5516], ecx
	movzx	ecx, WORD PTR $SG218751+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5618], al
	xor	eax, eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5520], dx
	mov	edx, DWORD PTR $SG218752
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5552], cx
	mov	ecx, DWORD PTR $SG218753
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5619], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5623], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5627], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5631], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5635], ax

; 249  : 		{"KB_NUMLOCK",FKBInputDevice::KB_NUMLOCK},

	movzx	eax, WORD PTR $SG218754+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5580], edx
	movzx	edx, WORD PTR $SG218753+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5612], ecx
	mov	ecx, DWORD PTR $SG218754
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5644], ecx
	movzx	ecx, BYTE PTR $SG218754+10
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5652], ax
	xor	eax, eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5616], dx
	mov	edx, DWORD PTR $SG218754+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5655], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5659], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5663], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5667], ax

; 250  : 		{"KB_SCROLL",FKBInputDevice::KB_SCROLL},

	mov	eax, DWORD PTR $SG218755+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5648], edx
	mov	edx, DWORD PTR $SG218755
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5654], cl
	movzx	ecx, WORD PTR $SG218755+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5680], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5676], edx

; 251  : 		{"KB_NUMPAD7",FKBInputDevice::KB_NUMPAD7},

	mov	edx, DWORD PTR $SG218756
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5512], 64 ; 00000040H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5544], 65 ; 00000041H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5576], 66 ; 00000042H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5608], 67 ; 00000043H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5640], 68 ; 00000044H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5672], 71 ; 00000047H
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5684], cx
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5686], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5690], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5694], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5698], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5700], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5704], 72 ; 00000048H
	mov	eax, DWORD PTR $SG218756+4
	movzx	ecx, WORD PTR $SG218756+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5712], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5719], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5723], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5727], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5731], ax

; 252  : 		{"KB_NUMPAD8",FKBInputDevice::KB_NUMPAD8},

	mov	eax, DWORD PTR $SG218757
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5740], eax
	movzx	eax, BYTE PTR $SG218757+10
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5750], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5751], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5755], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5759], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5763], ax

; 253  : 		{"KB_NUMPAD9",FKBInputDevice::KB_NUMPAD9},

	movzx	eax, WORD PTR $SG218758+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5708], edx
	movzx	edx, BYTE PTR $SG218756+10
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5780], ax
	xor	eax, eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5716], cx
	mov	ecx, DWORD PTR $SG218757+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5718], dl
	movzx	edx, WORD PTR $SG218757+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5783], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5787], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5791], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5795], ax

; 254  : 		{"KB_NUMPADMINUS",FKBInputDevice::KB_NUMPADMINUS},

	mov	eax, DWORD PTR $SG218759+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5744], ecx
	mov	ecx, DWORD PTR $SG218758
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5748], dx
	mov	edx, DWORD PTR $SG218758+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5808], eax
	movzx	eax, BYTE PTR $SG218759+14
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5772], ecx
	movzx	ecx, BYTE PTR $SG218758+10
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5776], edx
	mov	edx, DWORD PTR $SG218759
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5818], al
	xor	eax, eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5782], cl
	mov	ecx, DWORD PTR $SG218759+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5804], edx
	movzx	edx, WORD PTR $SG218759+12
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5819], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5823], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5827], ax

; 255  : 		{"KB_NUMPAD4",FKBInputDevice::KB_NUMPAD4},

	movzx	eax, WORD PTR $SG218760+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5812], ecx
	mov	ecx, DWORD PTR $SG218760
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5816], dx
	mov	edx, DWORD PTR $SG218760+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5836], ecx
	movzx	ecx, BYTE PTR $SG218760+10
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5844], ax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5840], edx

; 256  : 		{"KB_NUMPAD5",FKBInputDevice::KB_NUMPAD5},

	mov	edx, DWORD PTR $SG218761
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5847], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5851], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5855], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5859], ax
	mov	eax, DWORD PTR $SG218761+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5846], cl
	movzx	ecx, WORD PTR $SG218761+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5868], edx
	movzx	edx, BYTE PTR $SG218761+10
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5872], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5736], 80 ; 00000050H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5768], 81 ; 00000051H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5800], 82 ; 00000052H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5832], 83 ; 00000053H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5864], 77 ; 0000004dH
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5876], cx
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5878], dl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5879], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5883], eax

; 257  : 		{"KB_NUMPAD6",FKBInputDevice::KB_NUMPAD6},

	mov	ecx, DWORD PTR $SG218762+4
	movzx	edx, WORD PTR $SG218762+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5887], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5891], ax
	mov	eax, DWORD PTR $SG218762
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5900], eax
	movzx	eax, BYTE PTR $SG218762+10
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5910], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5911], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5915], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5919], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5923], ax

; 258  : 		{"KB_NUMPADPLUS",FKBInputDevice::KB_NUMPADPLUS},

	mov	eax, DWORD PTR $SG218763+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5940], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5904], ecx
	mov	ecx, DWORD PTR $SG218763
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5946], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5950], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5954], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5956], al

; 259  : 		{"KB_NUMPAD1",FKBInputDevice::KB_NUMPAD1},

	mov	eax, DWORD PTR $SG218764+4
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5908], dx
	mov	edx, DWORD PTR $SG218763+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5932], ecx
	movzx	ecx, WORD PTR $SG218763+12
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5968], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5936], edx
	mov	edx, DWORD PTR $SG218764
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5975], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5979], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5983], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5987], ax

; 260  : 		{"KB_NUMPAD2",FKBInputDevice::KB_NUMPAD2},

	mov	eax, DWORD PTR $SG218765
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5944], cx
	movzx	ecx, WORD PTR $SG218764+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5964], edx
	movzx	edx, BYTE PTR $SG218764+10
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5996], eax
	movzx	eax, BYTE PTR $SG218765+10
	mov	WORD PTR _asCvKeyBoardMapping$[esp+5972], cx
	mov	ecx, DWORD PTR $SG218765+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+5974], dl
	movzx	edx, WORD PTR $SG218765+8
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6006], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6000], ecx

; 261  : 		{"KB_NUMPAD3",FKBInputDevice::KB_NUMPAD3},

	mov	ecx, DWORD PTR $SG218766
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6004], dx
	mov	edx, DWORD PTR $SG218766+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6007], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6011], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6015], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6019], ax
	movzx	eax, WORD PTR $SG218766+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6028], ecx
	movzx	ecx, BYTE PTR $SG218766+10
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6032], edx

; 262  : 		{"KB_NUMPAD0",FKBInputDevice::KB_NUMPAD0},

	mov	edx, DWORD PTR $SG218767
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6036], ax
	xor	eax, eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6038], cl
	movzx	ecx, WORD PTR $SG218767+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6060], edx
	movzx	edx, BYTE PTR $SG218767+10
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6039], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6043], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6047], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6051], ax
	mov	eax, DWORD PTR $SG218767+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5896], 78 ; 0000004eH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5928], 79 ; 0000004fH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5960], 84 ; 00000054H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+5992], 74 ; 0000004aH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6024], 75 ; 0000004bH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6056], 76 ; 0000004cH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6064], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6068], cx
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6070], dl
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6071], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6075], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6079], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6083], ax

; 263  : 		{"KB_NUMPADPERIOD",FKBInputDevice::KB_NUMPADPERIOD},

	mov	eax, DWORD PTR $SG218768
	mov	ecx, DWORD PTR $SG218768+4
	mov	edx, DWORD PTR $SG218768+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6092], eax
	mov	eax, DWORD PTR $SG218768+12
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6104], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6108], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6112], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6116], al

; 264  : 		{"KB_F11",FKBInputDevice::KB_F11},

	movzx	eax, BYTE PTR $SG218769+6
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6130], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6131], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6135], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6139], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6143], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6147], ax

; 265  : 		{"KB_F12",FKBInputDevice::KB_F12},

	movzx	eax, BYTE PTR $SG218770+6
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6162], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6096], ecx
	mov	ecx, DWORD PTR $SG218769
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6163], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6167], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6171], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6175], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6179], ax

; 266  : 		{"KB_NUMPADEQUALS",FKBInputDevice::KB_NUMPADEQUALS},

	mov	eax, DWORD PTR $SG218771+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6100], edx
	movzx	edx, WORD PTR $SG218769+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6124], ecx
	mov	ecx, DWORD PTR $SG218770
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6196], eax
	xor	eax, eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6128], dx
	movzx	edx, WORD PTR $SG218770+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6156], ecx
	mov	ecx, DWORD PTR $SG218771
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6204], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6208], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6212], al

; 267  : 		{"KB_AT",FKBInputDevice::KB_AT},

	movzx	eax, WORD PTR $SG218772+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6188], ecx
	mov	ecx, DWORD PTR $SG218771+12
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6160], dx
	mov	edx, DWORD PTR $SG218771+4
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6224], ax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6200], ecx

; 268  : 		{"KB_UNDERLINE",FKBInputDevice::KB_UNDERLINE},

	mov	ecx, DWORD PTR $SG218773
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6192], edx
	mov	edx, DWORD PTR $SG218772
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6226], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6230], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6234], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6238], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6242], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6244], al
	mov	eax, DWORD PTR $SG218773+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6252], ecx
	movzx	ecx, BYTE PTR $SG218773+12
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6220], edx
	mov	edx, DWORD PTR $SG218773+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6260], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6088], 73 ; 00000049H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6120], 85 ; 00000055H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6152], 69 ; 00000045H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6184], 70 ; 00000046H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6216], 86 ; 00000056H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6248], 87 ; 00000057H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6256], edx
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6264], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6265], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6269], eax

; 269  : 		{"KB_COLON",FKBInputDevice::KB_COLON},

	mov	edx, DWORD PTR $SG218774
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6273], eax
	mov	eax, DWORD PTR $SG218774+4
	movzx	ecx, BYTE PTR $SG218774+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6288], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6293], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6297], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6301], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6305], eax

; 270  : 		{"KB_NUMPADENTER",FKBInputDevice::KB_NUMPADENTER},

	mov	eax, DWORD PTR $SG218775+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6320], eax
	movzx	eax, BYTE PTR $SG218775+14
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6330], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6331], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6335], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6339], ax

; 271  : 		{"KB_RCONTROL",FKBInputDevice::KB_RCONTROL},

	mov	eax, DWORD PTR $SG218776+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6356], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6284], edx
	mov	edx, DWORD PTR $SG218775
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6360], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6364], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6368], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6372], al

; 272  : 		{"KB_VOLUMEDOWN",FKBInputDevice::KB_VOLUMEDOWN},

	mov	eax, DWORD PTR $SG218777+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6316], edx
	movzx	edx, WORD PTR $SG218775+12
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6292], cl
	mov	ecx, DWORD PTR $SG218775+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6388], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6324], ecx
	mov	ecx, DWORD PTR $SG218776
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6328], dx
	mov	edx, DWORD PTR $SG218776+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6394], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6398], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6402], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6404], al

; 273  : 		{"KB_VOLUMEUP",FKBInputDevice::KB_VOLUMEUP},

	mov	eax, DWORD PTR $SG218778+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6348], ecx
	mov	ecx, DWORD PTR $SG218777
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6352], edx
	mov	edx, DWORD PTR $SG218777+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6416], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6380], ecx
	movzx	ecx, WORD PTR $SG218777+12
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6384], edx
	mov	edx, DWORD PTR $SG218778
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6424], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6428], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6432], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6436], al

; 274  : 		{"KB_NUMPADCOMMA",FKBInputDevice::KB_NUMPADCOMMA},

	mov	eax, DWORD PTR $SG218779+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6412], edx
	mov	edx, DWORD PTR $SG218779
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6448], eax
	movzx	eax, BYTE PTR $SG218779+14
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6392], cx
	mov	ecx, DWORD PTR $SG218778+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6444], edx
	movzx	edx, WORD PTR $SG218779+12
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6420], ecx
	mov	ecx, DWORD PTR $SG218779+8
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6458], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6280], 88 ; 00000058H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6312], 89 ; 00000059H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6344], 90 ; 0000005aH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6376], 91 ; 0000005bH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6408], 92 ; 0000005cH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6440], 93 ; 0000005dH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6452], ecx
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6456], dx
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6459], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6463], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6467], ax

; 275  : 		{"KB_NUMPADSLASH",FKBInputDevice::KB_NUMPADSLASH},

	mov	eax, DWORD PTR $SG218780+8
	mov	ecx, DWORD PTR $SG218780
	mov	edx, DWORD PTR $SG218780+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6484], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6491], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6495], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6499], ax

; 276  : 		{"KB_SYSRQ",FKBInputDevice::KB_SYSRQ},

	mov	eax, DWORD PTR $SG218781
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6508], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6517], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6521], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6525], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6529], eax

; 277  : 		{"KB_RALT",FKBInputDevice::KB_RALT},

	mov	eax, DWORD PTR $SG218782
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6476], ecx
	movzx	ecx, WORD PTR $SG218780+12
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6540], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6480], edx
	movzx	edx, BYTE PTR $SG218780+14
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6548], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6552], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6556], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6560], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6564], al

; 278  : 		{"KB_PAUSE",FKBInputDevice::KB_PAUSE},

	mov	eax, DWORD PTR $SG218783+4
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6488], cx
	mov	ecx, DWORD PTR $SG218781+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6490], dl
	movzx	edx, BYTE PTR $SG218781+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6576], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6512], ecx
	mov	ecx, DWORD PTR $SG218782+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6581], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6585], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6589], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6593], eax

; 279  : 		{"KB_HOME",FKBInputDevice::KB_HOME},

	mov	eax, DWORD PTR $SG218784+4
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6516], dl
	mov	edx, DWORD PTR $SG218783
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6544], ecx
	movzx	ecx, BYTE PTR $SG218783+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6608], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6572], edx
	mov	edx, DWORD PTR $SG218784
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6580], cl

; 280  : 		{"KB_UP",FKBInputDevice::KB_UP},

	mov	ecx, DWORD PTR $SG218785
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6612], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6616], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6620], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6624], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6628], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6642], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6646], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6650], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6654], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6658], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6660], al

; 281  : 		{"KB_PGUP",FKBInputDevice::KB_PGUP},

	mov	eax, DWORD PTR $SG218786
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6604], edx
	movzx	edx, WORD PTR $SG218785+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6636], ecx
	mov	ecx, DWORD PTR $SG218786+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6668], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6472], 94 ; 0000005eH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6504], 95 ; 0000005fH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6536], 96 ; 00000060H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6568], 97 ; 00000061H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6600], 98 ; 00000062H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6632], 99 ; 00000063H
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6640], dx
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6664], 100 ; 00000064H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6672], ecx
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6676], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6680], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6684], eax

; 282  : 		{"KB_LEFT",FKBInputDevice::KB_LEFT},
; 283  : 		{"KB_RIGHT",FKBInputDevice::KB_RIGHT},

	mov	ecx, DWORD PTR $SG218788
	mov	edx, DWORD PTR $SG218787
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6688], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6692], al
	mov	eax, DWORD PTR $SG218787+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6704], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6708], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6712], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6716], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6720], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6724], al
	movzx	eax, BYTE PTR $SG218788+8
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6740], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6741], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6745], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6749], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6753], eax

; 284  : 		{"KB_END",FKBInputDevice::KB_END},

	movzx	eax, BYTE PTR $SG218789+6
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6770], al
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6732], ecx
	mov	ecx, DWORD PTR $SG218789
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6771], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6775], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6779], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6783], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6787], ax

; 285  : 		{"KB_DOWN",FKBInputDevice::KB_DOWN},

	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6804], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6808], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6812], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6816], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6820], al

; 286  : 		{"KB_PGDN",FKBInputDevice::KB_PGDN},

	mov	eax, DWORD PTR $SG218791
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6700], edx
	mov	edx, DWORD PTR $SG218788+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6764], ecx
	mov	ecx, DWORD PTR $SG218790
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6828], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6736], edx
	movzx	edx, WORD PTR $SG218789+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6796], ecx
	mov	ecx, DWORD PTR $SG218791+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6836], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6840], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6844], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6848], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6852], al

; 287  : 		{"KB_INSERT",FKBInputDevice::KB_INSERT},

	mov	eax, DWORD PTR $SG218792+4
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6768], dx
	mov	edx, DWORD PTR $SG218790+4
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6832], ecx
	movzx	ecx, WORD PTR $SG218792+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6864], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6800], edx
	mov	edx, DWORD PTR $SG218792
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6870], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6874], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6878], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6882], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6884], al

; 288  : 		{"KB_DELETE",FKBInputDevice::KB_DELETE},

	mov	eax, DWORD PTR $SG218793+4
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6868], cx
	movzx	ecx, WORD PTR $SG218793+8
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6860], edx
	mov	edx, DWORD PTR $SG218793
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6896], eax
	xor	eax, eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6696], 101 ; 00000065H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6728], 102 ; 00000066H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6760], 103 ; 00000067H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6792], 104 ; 00000068H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6824], 105 ; 00000069H
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6856], 106 ; 0000006aH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6888], 107 ; 0000006bH
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6892], edx
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6900], cx
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6902], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6906], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6910], eax
	mov	WORD PTR _asCvKeyBoardMapping$[esp+6914], ax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+6916], al

; 289  : 	};
; 290  : 
; 291  : 	if(pszHotKeyVal)

	mov	eax, DWORD PTR _pszHotKeyVal$[esp+3464]
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+6920], 108 ; 0000006cH
	test	eax, eax
	je	SHORT $LN2@GetHotKeyI

; 292  : 	{
; 293  : 		for(int i = 0; i < iNumKeyBoardMappings; ++i)

	xor	edi, edi
	lea	ebx, DWORD PTR _asCvKeyBoardMapping$[esp+3468]
$LL4@GetHotKeyI:

; 294  : 		{
; 295  : 			if(strcmp(asCvKeyBoardMapping [i].szDefineString, pszHotKeyVal) == 0)

	mov	esi, eax
	mov	ecx, ebx
	npad	6
$LL11@GetHotKeyI:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [esi]
	jne	SHORT $LN12@GetHotKeyI
	test	dl, dl
	je	SHORT $LN13@GetHotKeyI
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [esi+1]
	jne	SHORT $LN12@GetHotKeyI
	add	ecx, 2
	add	esi, 2
	test	dl, dl
	jne	SHORT $LL11@GetHotKeyI
$LN13@GetHotKeyI:
	xor	ecx, ecx
	jmp	SHORT $LN14@GetHotKeyI
$LN12@GetHotKeyI:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN14@GetHotKeyI:
	test	ecx, ecx
	je	SHORT $LN9@GetHotKeyI
	inc	edi
	add	ebx, 32					; 00000020H
	cmp	edi, 108				; 0000006cH
	jl	SHORT $LL4@GetHotKeyI
$LN2@GetHotKeyI:
	pop	edi
	pop	esi

; 298  : 			}
; 299  : 		}
; 300  : 	}
; 301  : 
; 302  : 
; 303  : 	return -1;

	or	eax, -1
	pop	ebx

; 304  : }

	add	esp, 3456				; 00000d80H
	ret	4
$LN9@GetHotKeyI:

; 296  : 			{
; 297  : 				return asCvKeyBoardMapping[i].iIntVal;

	shl	edi, 5
	mov	eax, DWORD PTR _asCvKeyBoardMapping$[esp+edi+3496]
	pop	edi
	pop	esi
	pop	ebx

; 304  : }

	add	esp, 3456				; 00000d80H
	ret	4
?GetHotKeyInt@CvHotKeyInfo@@IAEHPBD@Z ENDP		; CvHotKeyInfo::GetHotKeyInt
_TEXT	ENDS
PUBLIC	?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z	; std::_Container_base::_Swap_aux
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z PROC	; std::_Container_base::_Swap_aux, COMDAT
; _this$ = ecx

; 602  : 		// Do nothing: we don't have an aux object.
; 603  : 		}

	ret	4
?_Swap_aux@_Container_base@std@@QAEXAAV12@@Z ENDP	; std::_Container_base::_Swap_aux
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 129  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@

; 130  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 134  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?getActionInfoIndex@CvHotKeyInfo@@QBEHXZ	; CvHotKeyInfo::getActionInfoIndex
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
;	COMDAT ?getActionInfoIndex@CvHotKeyInfo@@QBEHXZ
_TEXT	SEGMENT
?getActionInfoIndex@CvHotKeyInfo@@QBEHXZ PROC		; CvHotKeyInfo::getActionInfoIndex, COMDAT
; _this$ = ecx

; 532  : 	return m_iActionInfoIndex;

	mov	eax, DWORD PTR [ecx+260]

; 533  : }

	ret	0
?getActionInfoIndex@CvHotKeyInfo@@QBEHXZ ENDP		; CvHotKeyInfo::getActionInfoIndex
_TEXT	ENDS
PUBLIC	?setActionInfoIndex@CvHotKeyInfo@@QAEXH@Z	; CvHotKeyInfo::setActionInfoIndex
; Function compile flags: /Ogtpy
;	COMDAT ?setActionInfoIndex@CvHotKeyInfo@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?setActionInfoIndex@CvHotKeyInfo@@QAEXH@Z PROC		; CvHotKeyInfo::setActionInfoIndex, COMDAT
; _this$ = ecx

; 537  : 	m_iActionInfoIndex = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+260], eax

; 538  : }

	ret	4
?setActionInfoIndex@CvHotKeyInfo@@QAEXH@Z ENDP		; CvHotKeyInfo::setActionInfoIndex
_TEXT	ENDS
PUBLIC	?getHotKeyVal@CvHotKeyInfo@@QBEHXZ		; CvHotKeyInfo::getHotKeyVal
; Function compile flags: /Ogtpy
;	COMDAT ?getHotKeyVal@CvHotKeyInfo@@QBEHXZ
_TEXT	SEGMENT
?getHotKeyVal@CvHotKeyInfo@@QBEHXZ PROC			; CvHotKeyInfo::getHotKeyVal, COMDAT
; _this$ = ecx

; 542  : 	return m_iHotKeyVal;

	mov	eax, DWORD PTR [ecx+264]

; 543  : }

	ret	0
?getHotKeyVal@CvHotKeyInfo@@QBEHXZ ENDP			; CvHotKeyInfo::getHotKeyVal
_TEXT	ENDS
PUBLIC	?setHotKeyVal@CvHotKeyInfo@@QAEXH@Z		; CvHotKeyInfo::setHotKeyVal
; Function compile flags: /Ogtpy
;	COMDAT ?setHotKeyVal@CvHotKeyInfo@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?setHotKeyVal@CvHotKeyInfo@@QAEXH@Z PROC		; CvHotKeyInfo::setHotKeyVal, COMDAT
; _this$ = ecx

; 547  : 	m_iHotKeyVal = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+264], eax

; 548  : }

	ret	4
?setHotKeyVal@CvHotKeyInfo@@QAEXH@Z ENDP		; CvHotKeyInfo::setHotKeyVal
_TEXT	ENDS
PUBLIC	?getHotKeyPriority@CvHotKeyInfo@@QBEHXZ		; CvHotKeyInfo::getHotKeyPriority
; Function compile flags: /Ogtpy
;	COMDAT ?getHotKeyPriority@CvHotKeyInfo@@QBEHXZ
_TEXT	SEGMENT
?getHotKeyPriority@CvHotKeyInfo@@QBEHXZ PROC		; CvHotKeyInfo::getHotKeyPriority, COMDAT
; _this$ = ecx

; 552  : 	return m_iHotKeyPriority;

	mov	eax, DWORD PTR [ecx+268]

; 553  : }

	ret	0
?getHotKeyPriority@CvHotKeyInfo@@QBEHXZ ENDP		; CvHotKeyInfo::getHotKeyPriority
_TEXT	ENDS
PUBLIC	?setHotKeyPriority@CvHotKeyInfo@@QAEXH@Z	; CvHotKeyInfo::setHotKeyPriority
; Function compile flags: /Ogtpy
;	COMDAT ?setHotKeyPriority@CvHotKeyInfo@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?setHotKeyPriority@CvHotKeyInfo@@QAEXH@Z PROC		; CvHotKeyInfo::setHotKeyPriority, COMDAT
; _this$ = ecx

; 557  : 	m_iHotKeyPriority = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+268], eax

; 558  : }

	ret	4
?setHotKeyPriority@CvHotKeyInfo@@QAEXH@Z ENDP		; CvHotKeyInfo::setHotKeyPriority
_TEXT	ENDS
PUBLIC	?getHotKeyValAlt@CvHotKeyInfo@@QBEHXZ		; CvHotKeyInfo::getHotKeyValAlt
; Function compile flags: /Ogtpy
;	COMDAT ?getHotKeyValAlt@CvHotKeyInfo@@QBEHXZ
_TEXT	SEGMENT
?getHotKeyValAlt@CvHotKeyInfo@@QBEHXZ PROC		; CvHotKeyInfo::getHotKeyValAlt, COMDAT
; _this$ = ecx

; 562  : 	return m_iHotKeyValAlt;

	mov	eax, DWORD PTR [ecx+272]

; 563  : }

	ret	0
?getHotKeyValAlt@CvHotKeyInfo@@QBEHXZ ENDP		; CvHotKeyInfo::getHotKeyValAlt
_TEXT	ENDS
PUBLIC	?setHotKeyValAlt@CvHotKeyInfo@@QAEXH@Z		; CvHotKeyInfo::setHotKeyValAlt
; Function compile flags: /Ogtpy
;	COMDAT ?setHotKeyValAlt@CvHotKeyInfo@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?setHotKeyValAlt@CvHotKeyInfo@@QAEXH@Z PROC		; CvHotKeyInfo::setHotKeyValAlt, COMDAT
; _this$ = ecx

; 567  : 	m_iHotKeyValAlt = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+272], eax

; 568  : }

	ret	4
?setHotKeyValAlt@CvHotKeyInfo@@QAEXH@Z ENDP		; CvHotKeyInfo::setHotKeyValAlt
_TEXT	ENDS
PUBLIC	?getHotKeyPriorityAlt@CvHotKeyInfo@@QBEHXZ	; CvHotKeyInfo::getHotKeyPriorityAlt
; Function compile flags: /Ogtpy
;	COMDAT ?getHotKeyPriorityAlt@CvHotKeyInfo@@QBEHXZ
_TEXT	SEGMENT
?getHotKeyPriorityAlt@CvHotKeyInfo@@QBEHXZ PROC		; CvHotKeyInfo::getHotKeyPriorityAlt, COMDAT
; _this$ = ecx

; 572  : 	return m_iHotKeyPriorityAlt;

	mov	eax, DWORD PTR [ecx+276]

; 573  : }

	ret	0
?getHotKeyPriorityAlt@CvHotKeyInfo@@QBEHXZ ENDP		; CvHotKeyInfo::getHotKeyPriorityAlt
_TEXT	ENDS
PUBLIC	?setHotKeyPriorityAlt@CvHotKeyInfo@@QAEXH@Z	; CvHotKeyInfo::setHotKeyPriorityAlt
; Function compile flags: /Ogtpy
;	COMDAT ?setHotKeyPriorityAlt@CvHotKeyInfo@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?setHotKeyPriorityAlt@CvHotKeyInfo@@QAEXH@Z PROC	; CvHotKeyInfo::setHotKeyPriorityAlt, COMDAT
; _this$ = ecx

; 577  : 	m_iHotKeyPriorityAlt = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+276], eax

; 578  : }

	ret	4
?setHotKeyPriorityAlt@CvHotKeyInfo@@QAEXH@Z ENDP	; CvHotKeyInfo::setHotKeyPriorityAlt
_TEXT	ENDS
PUBLIC	?getOrderPriority@CvHotKeyInfo@@QBEHXZ		; CvHotKeyInfo::getOrderPriority
; Function compile flags: /Ogtpy
;	COMDAT ?getOrderPriority@CvHotKeyInfo@@QBEHXZ
_TEXT	SEGMENT
?getOrderPriority@CvHotKeyInfo@@QBEHXZ PROC		; CvHotKeyInfo::getOrderPriority, COMDAT
; _this$ = ecx

; 582  : 	return m_iOrderPriority;

	mov	eax, DWORD PTR [ecx+280]

; 583  : }

	ret	0
?getOrderPriority@CvHotKeyInfo@@QBEHXZ ENDP		; CvHotKeyInfo::getOrderPriority
_TEXT	ENDS
PUBLIC	?setOrderPriority@CvHotKeyInfo@@QAEXH@Z		; CvHotKeyInfo::setOrderPriority
; Function compile flags: /Ogtpy
;	COMDAT ?setOrderPriority@CvHotKeyInfo@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?setOrderPriority@CvHotKeyInfo@@QAEXH@Z PROC		; CvHotKeyInfo::setOrderPriority, COMDAT
; _this$ = ecx

; 587  : 	m_iOrderPriority = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+280], eax

; 588  : }

	ret	4
?setOrderPriority@CvHotKeyInfo@@QAEXH@Z ENDP		; CvHotKeyInfo::setOrderPriority
_TEXT	ENDS
PUBLIC	?isAltDown@CvHotKeyInfo@@QBE_NXZ		; CvHotKeyInfo::isAltDown
; Function compile flags: /Ogtpy
;	COMDAT ?isAltDown@CvHotKeyInfo@@QBE_NXZ
_TEXT	SEGMENT
?isAltDown@CvHotKeyInfo@@QBE_NXZ PROC			; CvHotKeyInfo::isAltDown, COMDAT
; _this$ = ecx

; 592  : 	return m_bAltDown;

	mov	al, BYTE PTR [ecx+284]

; 593  : }

	ret	0
?isAltDown@CvHotKeyInfo@@QBE_NXZ ENDP			; CvHotKeyInfo::isAltDown
_TEXT	ENDS
PUBLIC	?setAltDown@CvHotKeyInfo@@QAEX_N@Z		; CvHotKeyInfo::setAltDown
; Function compile flags: /Ogtpy
;	COMDAT ?setAltDown@CvHotKeyInfo@@QAEX_N@Z
_TEXT	SEGMENT
_b$ = 8							; size = 1
?setAltDown@CvHotKeyInfo@@QAEX_N@Z PROC			; CvHotKeyInfo::setAltDown, COMDAT
; _this$ = ecx

; 597  : 	m_bAltDown = b;

	mov	al, BYTE PTR _b$[esp-4]
	mov	BYTE PTR [ecx+284], al

; 598  : }

	ret	4
?setAltDown@CvHotKeyInfo@@QAEX_N@Z ENDP			; CvHotKeyInfo::setAltDown
_TEXT	ENDS
PUBLIC	?isShiftDown@CvHotKeyInfo@@QBE_NXZ		; CvHotKeyInfo::isShiftDown
; Function compile flags: /Ogtpy
;	COMDAT ?isShiftDown@CvHotKeyInfo@@QBE_NXZ
_TEXT	SEGMENT
?isShiftDown@CvHotKeyInfo@@QBE_NXZ PROC			; CvHotKeyInfo::isShiftDown, COMDAT
; _this$ = ecx

; 602  : 	return m_bShiftDown;

	mov	al, BYTE PTR [ecx+285]

; 603  : }

	ret	0
?isShiftDown@CvHotKeyInfo@@QBE_NXZ ENDP			; CvHotKeyInfo::isShiftDown
_TEXT	ENDS
PUBLIC	?setShiftDown@CvHotKeyInfo@@QAEX_N@Z		; CvHotKeyInfo::setShiftDown
; Function compile flags: /Ogtpy
;	COMDAT ?setShiftDown@CvHotKeyInfo@@QAEX_N@Z
_TEXT	SEGMENT
_b$ = 8							; size = 1
?setShiftDown@CvHotKeyInfo@@QAEX_N@Z PROC		; CvHotKeyInfo::setShiftDown, COMDAT
; _this$ = ecx

; 607  : 	m_bShiftDown = b;

	mov	al, BYTE PTR _b$[esp-4]
	mov	BYTE PTR [ecx+285], al

; 608  : }

	ret	4
?setShiftDown@CvHotKeyInfo@@QAEX_N@Z ENDP		; CvHotKeyInfo::setShiftDown
_TEXT	ENDS
PUBLIC	?isCtrlDown@CvHotKeyInfo@@QBE_NXZ		; CvHotKeyInfo::isCtrlDown
; Function compile flags: /Ogtpy
;	COMDAT ?isCtrlDown@CvHotKeyInfo@@QBE_NXZ
_TEXT	SEGMENT
?isCtrlDown@CvHotKeyInfo@@QBE_NXZ PROC			; CvHotKeyInfo::isCtrlDown, COMDAT
; _this$ = ecx

; 612  : 	return m_bCtrlDown;

	mov	al, BYTE PTR [ecx+286]

; 613  : }

	ret	0
?isCtrlDown@CvHotKeyInfo@@QBE_NXZ ENDP			; CvHotKeyInfo::isCtrlDown
_TEXT	ENDS
PUBLIC	?setCtrlDown@CvHotKeyInfo@@QAEX_N@Z		; CvHotKeyInfo::setCtrlDown
; Function compile flags: /Ogtpy
;	COMDAT ?setCtrlDown@CvHotKeyInfo@@QAEX_N@Z
_TEXT	SEGMENT
_b$ = 8							; size = 1
?setCtrlDown@CvHotKeyInfo@@QAEX_N@Z PROC		; CvHotKeyInfo::setCtrlDown, COMDAT
; _this$ = ecx

; 617  : 	m_bCtrlDown = b;

	mov	al, BYTE PTR _b$[esp-4]
	mov	BYTE PTR [ecx+286], al

; 618  : }

	ret	4
?setCtrlDown@CvHotKeyInfo@@QAEX_N@Z ENDP		; CvHotKeyInfo::setCtrlDown
_TEXT	ENDS
PUBLIC	?isAltDownAlt@CvHotKeyInfo@@QBE_NXZ		; CvHotKeyInfo::isAltDownAlt
; Function compile flags: /Ogtpy
;	COMDAT ?isAltDownAlt@CvHotKeyInfo@@QBE_NXZ
_TEXT	SEGMENT
?isAltDownAlt@CvHotKeyInfo@@QBE_NXZ PROC		; CvHotKeyInfo::isAltDownAlt, COMDAT
; _this$ = ecx

; 622  : 	return m_bAltDownAlt;

	mov	al, BYTE PTR [ecx+287]

; 623  : }

	ret	0
?isAltDownAlt@CvHotKeyInfo@@QBE_NXZ ENDP		; CvHotKeyInfo::isAltDownAlt
_TEXT	ENDS
PUBLIC	?setAltDownAlt@CvHotKeyInfo@@QAEX_N@Z		; CvHotKeyInfo::setAltDownAlt
; Function compile flags: /Ogtpy
;	COMDAT ?setAltDownAlt@CvHotKeyInfo@@QAEX_N@Z
_TEXT	SEGMENT
_b$ = 8							; size = 1
?setAltDownAlt@CvHotKeyInfo@@QAEX_N@Z PROC		; CvHotKeyInfo::setAltDownAlt, COMDAT
; _this$ = ecx

; 627  : 	m_bAltDownAlt = b;

	mov	al, BYTE PTR _b$[esp-4]
	mov	BYTE PTR [ecx+287], al

; 628  : }

	ret	4
?setAltDownAlt@CvHotKeyInfo@@QAEX_N@Z ENDP		; CvHotKeyInfo::setAltDownAlt
_TEXT	ENDS
PUBLIC	?isShiftDownAlt@CvHotKeyInfo@@QBE_NXZ		; CvHotKeyInfo::isShiftDownAlt
; Function compile flags: /Ogtpy
;	COMDAT ?isShiftDownAlt@CvHotKeyInfo@@QBE_NXZ
_TEXT	SEGMENT
?isShiftDownAlt@CvHotKeyInfo@@QBE_NXZ PROC		; CvHotKeyInfo::isShiftDownAlt, COMDAT
; _this$ = ecx

; 632  : 	return m_bShiftDownAlt;

	mov	al, BYTE PTR [ecx+288]

; 633  : }

	ret	0
?isShiftDownAlt@CvHotKeyInfo@@QBE_NXZ ENDP		; CvHotKeyInfo::isShiftDownAlt
_TEXT	ENDS
PUBLIC	?setShiftDownAlt@CvHotKeyInfo@@QAEX_N@Z		; CvHotKeyInfo::setShiftDownAlt
; Function compile flags: /Ogtpy
;	COMDAT ?setShiftDownAlt@CvHotKeyInfo@@QAEX_N@Z
_TEXT	SEGMENT
_b$ = 8							; size = 1
?setShiftDownAlt@CvHotKeyInfo@@QAEX_N@Z PROC		; CvHotKeyInfo::setShiftDownAlt, COMDAT
; _this$ = ecx

; 637  : 	m_bShiftDownAlt = b;

	mov	al, BYTE PTR _b$[esp-4]
	mov	BYTE PTR [ecx+288], al

; 638  : }

	ret	4
?setShiftDownAlt@CvHotKeyInfo@@QAEX_N@Z ENDP		; CvHotKeyInfo::setShiftDownAlt
_TEXT	ENDS
PUBLIC	?isCtrlDownAlt@CvHotKeyInfo@@QBE_NXZ		; CvHotKeyInfo::isCtrlDownAlt
; Function compile flags: /Ogtpy
;	COMDAT ?isCtrlDownAlt@CvHotKeyInfo@@QBE_NXZ
_TEXT	SEGMENT
?isCtrlDownAlt@CvHotKeyInfo@@QBE_NXZ PROC		; CvHotKeyInfo::isCtrlDownAlt, COMDAT
; _this$ = ecx

; 642  : 	return m_bCtrlDownAlt;

	mov	al, BYTE PTR [ecx+289]

; 643  : }

	ret	0
?isCtrlDownAlt@CvHotKeyInfo@@QBE_NXZ ENDP		; CvHotKeyInfo::isCtrlDownAlt
_TEXT	ENDS
PUBLIC	?setCtrlDownAlt@CvHotKeyInfo@@QAEX_N@Z		; CvHotKeyInfo::setCtrlDownAlt
; Function compile flags: /Ogtpy
;	COMDAT ?setCtrlDownAlt@CvHotKeyInfo@@QAEX_N@Z
_TEXT	SEGMENT
_b$ = 8							; size = 1
?setCtrlDownAlt@CvHotKeyInfo@@QAEX_N@Z PROC		; CvHotKeyInfo::setCtrlDownAlt, COMDAT
; _this$ = ecx

; 647  : 	m_bCtrlDownAlt = b;

	mov	al, BYTE PTR _b$[esp-4]
	mov	BYTE PTR [ecx+289], al

; 648  : }

	ret	4
?setCtrlDownAlt@CvHotKeyInfo@@QAEX_N@Z ENDP		; CvHotKeyInfo::setCtrlDownAlt
_TEXT	ENDS
PUBLIC	?getHelp@CvHotKeyInfo@@QBEPBDXZ			; CvHotKeyInfo::getHelp
; Function compile flags: /Ogtpy
;	COMDAT ?getHelp@CvHotKeyInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getHelp@CvHotKeyInfo@@QBEPBDXZ PROC			; CvHotKeyInfo::getHelp, COMDAT
; _this$ = ecx

; 662  : 	return m_strHelp.c_str();

	add	ecx, 404				; 00000194H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getHelp@CvHotKeyInfo@@QBEPBDXZ ENDP			; CvHotKeyInfo::getHelp
_TEXT	ENDS
PUBLIC	?getDisabledHelp@CvHotKeyInfo@@QBEPBDXZ		; CvHotKeyInfo::getDisabledHelp
; Function compile flags: /Ogtpy
;	COMDAT ?getDisabledHelp@CvHotKeyInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getDisabledHelp@CvHotKeyInfo@@QBEPBDXZ PROC		; CvHotKeyInfo::getDisabledHelp, COMDAT
; _this$ = ecx

; 667  : 	return m_strDisabledHelp.c_str();

	add	ecx, 432				; 000001b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getDisabledHelp@CvHotKeyInfo@@QBEPBDXZ ENDP		; CvHotKeyInfo::getDisabledHelp
_TEXT	ENDS
PUBLIC	?getHotKeyString@CvHotKeyInfo@@QBEPBDXZ		; CvHotKeyInfo::getHotKeyString
; Function compile flags: /Ogtpy
;	COMDAT ?getHotKeyString@CvHotKeyInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getHotKeyString@CvHotKeyInfo@@QBEPBDXZ PROC		; CvHotKeyInfo::getHotKeyString, COMDAT
; _this$ = ecx

; 697  : 	return m_strHotKeyString.c_str();

	add	ecx, 376				; 00000178H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getHotKeyString@CvHotKeyInfo@@QBEPBDXZ ENDP		; CvHotKeyInfo::getHotKeyString
_TEXT	ENDS
PUBLIC	?getCost@CvSpecialistInfo@@QBEHXZ		; CvSpecialistInfo::getCost
; Function compile flags: /Ogtpy
;	COMDAT ?getCost@CvSpecialistInfo@@QBEHXZ
_TEXT	SEGMENT
?getCost@CvSpecialistInfo@@QBEHXZ PROC			; CvSpecialistInfo::getCost, COMDAT
; _this$ = ecx

; 732  : 	return m_iCost;

	mov	eax, DWORD PTR [ecx+460]

; 733  : }

	ret	0
?getCost@CvSpecialistInfo@@QBEHXZ ENDP			; CvSpecialistInfo::getCost
_TEXT	ENDS
PUBLIC	?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleUnitClass
; Function compile flags: /Ogtpy
;	COMDAT ?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ
_TEXT	SEGMENT
?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ PROC	; CvSpecialistInfo::getGreatPeopleUnitClass, COMDAT
; _this$ = ecx

; 737  : 	return m_iGreatPeopleUnitClass;

	mov	eax, DWORD PTR [ecx+464]

; 738  : }

	ret	0
?getGreatPeopleUnitClass@CvSpecialistInfo@@QBEHXZ ENDP	; CvSpecialistInfo::getGreatPeopleUnitClass
_TEXT	ENDS
PUBLIC	?getGreatPeopleRateChange@CvSpecialistInfo@@QBEHXZ ; CvSpecialistInfo::getGreatPeopleRateChange
; Function compile flags: /Ogtpy
;	COMDAT ?getGreatPeopleRateChange@CvSpecialistInfo@@QBEHXZ
_TEXT	SEGMENT
?getGreatPeopleRateChange@CvSpecialistInfo@@QBEHXZ PROC	; CvSpecialistInfo::getGreatPeopleRateChange, COMDAT
; _this$ = ecx

; 742  : 	return m_iGreatPeopleRateChange;

	mov	eax, DWORD PTR [ecx+468]

; 743  : }

	ret	0
?getGreatPeopleRateChange@CvSpecialistInfo@@QBEHXZ ENDP	; CvSpecialistInfo::getGreatPeopleRateChange
_TEXT	ENDS
PUBLIC	?getCulturePerTurn@CvSpecialistInfo@@QBEHXZ	; CvSpecialistInfo::getCulturePerTurn
; Function compile flags: /Ogtpy
;	COMDAT ?getCulturePerTurn@CvSpecialistInfo@@QBEHXZ
_TEXT	SEGMENT
?getCulturePerTurn@CvSpecialistInfo@@QBEHXZ PROC	; CvSpecialistInfo::getCulturePerTurn, COMDAT
; _this$ = ecx

; 747  : 	return m_iCulturePerTurn;

	mov	eax, DWORD PTR [ecx+472]

; 748  : }

	ret	0
?getCulturePerTurn@CvSpecialistInfo@@QBEHXZ ENDP	; CvSpecialistInfo::getCulturePerTurn
_TEXT	ENDS
PUBLIC	?getMissionType@CvSpecialistInfo@@QBEHXZ	; CvSpecialistInfo::getMissionType
; Function compile flags: /Ogtpy
;	COMDAT ?getMissionType@CvSpecialistInfo@@QBEHXZ
_TEXT	SEGMENT
?getMissionType@CvSpecialistInfo@@QBEHXZ PROC		; CvSpecialistInfo::getMissionType, COMDAT
; _this$ = ecx

; 752  : 	return m_iMissionType;

	mov	eax, DWORD PTR [ecx+476]

; 753  : }

	ret	0
?getMissionType@CvSpecialistInfo@@QBEHXZ ENDP		; CvSpecialistInfo::getMissionType
_TEXT	ENDS
PUBLIC	?setMissionType@CvSpecialistInfo@@QAEXH@Z	; CvSpecialistInfo::setMissionType
; Function compile flags: /Ogtpy
;	COMDAT ?setMissionType@CvSpecialistInfo@@QAEXH@Z
_TEXT	SEGMENT
_iNewType$ = 8						; size = 4
?setMissionType@CvSpecialistInfo@@QAEXH@Z PROC		; CvSpecialistInfo::setMissionType, COMDAT
; _this$ = ecx

; 757  : 	m_iMissionType = iNewType;

	mov	eax, DWORD PTR _iNewType$[esp-4]
	mov	DWORD PTR [ecx+476], eax

; 758  : }

	ret	4
?setMissionType@CvSpecialistInfo@@QAEXH@Z ENDP		; CvSpecialistInfo::setMissionType
_TEXT	ENDS
PUBLIC	?isVisible@CvSpecialistInfo@@QBE_NXZ		; CvSpecialistInfo::isVisible
; Function compile flags: /Ogtpy
;	COMDAT ?isVisible@CvSpecialistInfo@@QBE_NXZ
_TEXT	SEGMENT
?isVisible@CvSpecialistInfo@@QBE_NXZ PROC		; CvSpecialistInfo::isVisible, COMDAT
; _this$ = ecx

; 762  : 	return m_bVisible;

	mov	al, BYTE PTR [ecx+484]

; 763  : }

	ret	0
?isVisible@CvSpecialistInfo@@QBE_NXZ ENDP		; CvSpecialistInfo::isVisible
_TEXT	ENDS
PUBLIC	?getExperience@CvSpecialistInfo@@QBEHXZ		; CvSpecialistInfo::getExperience
; Function compile flags: /Ogtpy
;	COMDAT ?getExperience@CvSpecialistInfo@@QBEHXZ
_TEXT	SEGMENT
?getExperience@CvSpecialistInfo@@QBEHXZ PROC		; CvSpecialistInfo::getExperience, COMDAT
; _this$ = ecx

; 767  : 	return m_iExperience;

	mov	eax, DWORD PTR [ecx+480]

; 768  : }

	ret	0
?getExperience@CvSpecialistInfo@@QBEHXZ ENDP		; CvSpecialistInfo::getExperience
_TEXT	ENDS
PUBLIC	?getYieldChange@CvSpecialistInfo@@QBEHH@Z	; CvSpecialistInfo::getYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?getYieldChange@CvSpecialistInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getYieldChange@CvSpecialistInfo@@QBEHH@Z PROC		; CvSpecialistInfo::getYieldChange, COMDAT
; _this$ = ecx

; 772  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 773  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 774  : 	return m_piYieldChange ? m_piYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+516]
	test	eax, eax
	je	SHORT $LN3@getYieldCh
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 775  : }

	ret	4
$LN3@getYieldCh:

; 772  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 773  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 774  : 	return m_piYieldChange ? m_piYieldChange[i] : -1;

	or	eax, -1

; 775  : }

	ret	4
?getYieldChange@CvSpecialistInfo@@QBEHH@Z ENDP		; CvSpecialistInfo::getYieldChange
_TEXT	ENDS
PUBLIC	?getYieldChangeArray@CvSpecialistInfo@@QBEPBHXZ	; CvSpecialistInfo::getYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?getYieldChangeArray@CvSpecialistInfo@@QBEPBHXZ
_TEXT	SEGMENT
?getYieldChangeArray@CvSpecialistInfo@@QBEPBHXZ PROC	; CvSpecialistInfo::getYieldChangeArray, COMDAT
; _this$ = ecx

; 779  : 	return m_piYieldChange;

	mov	eax, DWORD PTR [ecx+516]

; 780  : }

	ret	0
?getYieldChangeArray@CvSpecialistInfo@@QBEPBHXZ ENDP	; CvSpecialistInfo::getYieldChangeArray
_TEXT	ENDS
PUBLIC	?getFlavorValue@CvSpecialistInfo@@QBEHH@Z	; CvSpecialistInfo::getFlavorValue
; Function compile flags: /Ogtpy
;	COMDAT ?getFlavorValue@CvSpecialistInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getFlavorValue@CvSpecialistInfo@@QBEHH@Z PROC		; CvSpecialistInfo::getFlavorValue, COMDAT
; _this$ = ecx

; 784  : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 785  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 786  : 	return m_piFlavorValue ? m_piFlavorValue[i] : 0;

	mov	eax, DWORD PTR [ecx+520]
	test	eax, eax
	je	SHORT $LN3@getFlavorV
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 787  : }

	ret	4
$LN3@getFlavorV:

; 784  : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 785  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 786  : 	return m_piFlavorValue ? m_piFlavorValue[i] : 0;

	xor	eax, eax

; 787  : }

	ret	4
?getFlavorValue@CvSpecialistInfo@@QBEHH@Z ENDP		; CvSpecialistInfo::getFlavorValue
_TEXT	ENDS
PUBLIC	?getTime@CvMissionInfo@@QBEHXZ			; CvMissionInfo::getTime
; Function compile flags: /Ogtpy
;	COMDAT ?getTime@CvMissionInfo@@QBEHXZ
_TEXT	SEGMENT
?getTime@CvMissionInfo@@QBEHXZ PROC			; CvMissionInfo::getTime, COMDAT
; _this$ = ecx

; 838  : 	return m_iTime;

	mov	eax, DWORD PTR [ecx+460]

; 839  : }

	ret	0
?getTime@CvMissionInfo@@QBEHXZ ENDP			; CvMissionInfo::getTime
_TEXT	ENDS
PUBLIC	?isSound@CvMissionInfo@@QBE_NXZ			; CvMissionInfo::isSound
; Function compile flags: /Ogtpy
;	COMDAT ?isSound@CvMissionInfo@@QBE_NXZ
_TEXT	SEGMENT
?isSound@CvMissionInfo@@QBE_NXZ PROC			; CvMissionInfo::isSound, COMDAT
; _this$ = ecx

; 843  : 	return m_bSound;

	mov	al, BYTE PTR [ecx+464]

; 844  : }

	ret	0
?isSound@CvMissionInfo@@QBE_NXZ ENDP			; CvMissionInfo::isSound
_TEXT	ENDS
PUBLIC	?isTarget@CvMissionInfo@@QBE_NXZ		; CvMissionInfo::isTarget
; Function compile flags: /Ogtpy
;	COMDAT ?isTarget@CvMissionInfo@@QBE_NXZ
_TEXT	SEGMENT
?isTarget@CvMissionInfo@@QBE_NXZ PROC			; CvMissionInfo::isTarget, COMDAT
; _this$ = ecx

; 848  : 	return m_bTarget;

	mov	al, BYTE PTR [ecx+465]

; 849  : }

	ret	0
?isTarget@CvMissionInfo@@QBE_NXZ ENDP			; CvMissionInfo::isTarget
_TEXT	ENDS
PUBLIC	?isBuild@CvMissionInfo@@QBE_NXZ			; CvMissionInfo::isBuild
; Function compile flags: /Ogtpy
;	COMDAT ?isBuild@CvMissionInfo@@QBE_NXZ
_TEXT	SEGMENT
?isBuild@CvMissionInfo@@QBE_NXZ PROC			; CvMissionInfo::isBuild, COMDAT
; _this$ = ecx

; 853  : 	return m_bBuild;

	mov	al, BYTE PTR [ecx+466]

; 854  : }

	ret	0
?isBuild@CvMissionInfo@@QBE_NXZ ENDP			; CvMissionInfo::isBuild
_TEXT	ENDS
PUBLIC	?getVisible@CvMissionInfo@@QBE_NXZ		; CvMissionInfo::getVisible
; Function compile flags: /Ogtpy
;	COMDAT ?getVisible@CvMissionInfo@@QBE_NXZ
_TEXT	SEGMENT
?getVisible@CvMissionInfo@@QBE_NXZ PROC			; CvMissionInfo::getVisible, COMDAT
; _this$ = ecx

; 858  : 	return m_bVisible;

	mov	al, BYTE PTR [ecx+467]

; 859  : }

	ret	0
?getVisible@CvMissionInfo@@QBE_NXZ ENDP			; CvMissionInfo::getVisible
_TEXT	ENDS
PUBLIC	?getEntityEvent@CvMissionInfo@@QBE?AW4EntityEventTypes@@XZ ; CvMissionInfo::getEntityEvent
; Function compile flags: /Ogtpy
;	COMDAT ?getEntityEvent@CvMissionInfo@@QBE?AW4EntityEventTypes@@XZ
_TEXT	SEGMENT
?getEntityEvent@CvMissionInfo@@QBE?AW4EntityEventTypes@@XZ PROC ; CvMissionInfo::getEntityEvent, COMDAT
; _this$ = ecx

; 868  : 	return m_eEntityEvent;

	mov	eax, DWORD PTR [ecx+468]

; 869  : }

	ret	0
?getEntityEvent@CvMissionInfo@@QBE?AW4EntityEventTypes@@XZ ENDP ; CvMissionInfo::getEntityEvent
_TEXT	ENDS
PUBLIC	?getAutomate@CvCommandInfo@@QBEHXZ		; CvCommandInfo::getAutomate
; Function compile flags: /Ogtpy
;	COMDAT ?getAutomate@CvCommandInfo@@QBEHXZ
_TEXT	SEGMENT
?getAutomate@CvCommandInfo@@QBEHXZ PROC			; CvCommandInfo::getAutomate, COMDAT
; _this$ = ecx

; 909  : 	return m_iAutomate;

	mov	eax, DWORD PTR [ecx+460]

; 910  : }

	ret	0
?getAutomate@CvCommandInfo@@QBEHXZ ENDP			; CvCommandInfo::getAutomate
_TEXT	ENDS
PUBLIC	?setAutomate@CvCommandInfo@@QAEXH@Z		; CvCommandInfo::setAutomate
; Function compile flags: /Ogtpy
;	COMDAT ?setAutomate@CvCommandInfo@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?setAutomate@CvCommandInfo@@QAEXH@Z PROC		; CvCommandInfo::setAutomate, COMDAT
; _this$ = ecx

; 914  : 	m_iAutomate = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+460], eax

; 915  : }

	ret	4
?setAutomate@CvCommandInfo@@QAEXH@Z ENDP		; CvCommandInfo::setAutomate
_TEXT	ENDS
PUBLIC	?getConfirmCommand@CvCommandInfo@@QBE_NXZ	; CvCommandInfo::getConfirmCommand
; Function compile flags: /Ogtpy
;	COMDAT ?getConfirmCommand@CvCommandInfo@@QBE_NXZ
_TEXT	SEGMENT
?getConfirmCommand@CvCommandInfo@@QBE_NXZ PROC		; CvCommandInfo::getConfirmCommand, COMDAT
; _this$ = ecx

; 919  : 	return m_bConfirmCommand;

	mov	al, BYTE PTR [ecx+464]

; 920  : }

	ret	0
?getConfirmCommand@CvCommandInfo@@QBE_NXZ ENDP		; CvCommandInfo::getConfirmCommand
_TEXT	ENDS
PUBLIC	?getVisible@CvCommandInfo@@QBE_NXZ		; CvCommandInfo::getVisible
; Function compile flags: /Ogtpy
;	COMDAT ?getVisible@CvCommandInfo@@QBE_NXZ
_TEXT	SEGMENT
?getVisible@CvCommandInfo@@QBE_NXZ PROC			; CvCommandInfo::getVisible, COMDAT
; _this$ = ecx

; 924  : 	return m_bVisible;

	mov	al, BYTE PTR [ecx+465]

; 925  : }

	ret	0
?getVisible@CvCommandInfo@@QBE_NXZ ENDP			; CvCommandInfo::getVisible
_TEXT	ENDS
PUBLIC	?getAll@CvCommandInfo@@QBE_NXZ			; CvCommandInfo::getAll
; Function compile flags: /Ogtpy
;	COMDAT ?getAll@CvCommandInfo@@QBE_NXZ
_TEXT	SEGMENT
?getAll@CvCommandInfo@@QBE_NXZ PROC			; CvCommandInfo::getAll, COMDAT
; _this$ = ecx

; 929  : 	return m_bAll;

	mov	al, BYTE PTR [ecx+466]

; 930  : }

	ret	0
?getAll@CvCommandInfo@@QBE_NXZ ENDP			; CvCommandInfo::getAll
_TEXT	ENDS
PUBLIC	?getCommand@CvAutomateInfo@@QBEHXZ		; CvAutomateInfo::getCommand
; Function compile flags: /Ogtpy
;	COMDAT ?getCommand@CvAutomateInfo@@QBEHXZ
_TEXT	SEGMENT
?getCommand@CvAutomateInfo@@QBEHXZ PROC			; CvAutomateInfo::getCommand, COMDAT
; _this$ = ecx

; 961  : 	return m_iCommand;

	mov	eax, DWORD PTR [ecx+460]

; 962  : }

	ret	0
?getCommand@CvAutomateInfo@@QBEHXZ ENDP			; CvAutomateInfo::getCommand
_TEXT	ENDS
PUBLIC	?setCommand@CvAutomateInfo@@QAEXH@Z		; CvAutomateInfo::setCommand
; Function compile flags: /Ogtpy
;	COMDAT ?setCommand@CvAutomateInfo@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?setCommand@CvAutomateInfo@@QAEXH@Z PROC		; CvAutomateInfo::setCommand, COMDAT
; _this$ = ecx

; 966  : 	m_iCommand = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+460], eax

; 967  : }

	ret	4
?setCommand@CvAutomateInfo@@QAEXH@Z ENDP		; CvAutomateInfo::setCommand
_TEXT	ENDS
PUBLIC	?getAutomate@CvAutomateInfo@@QBEHXZ		; CvAutomateInfo::getAutomate
; Function compile flags: /Ogtpy
;	COMDAT ?getAutomate@CvAutomateInfo@@QBEHXZ
_TEXT	SEGMENT
?getAutomate@CvAutomateInfo@@QBEHXZ PROC		; CvAutomateInfo::getAutomate, COMDAT
; _this$ = ecx

; 971  : 	return m_iAutomate;

	mov	eax, DWORD PTR [ecx+464]

; 972  : }

	ret	0
?getAutomate@CvAutomateInfo@@QBEHXZ ENDP		; CvAutomateInfo::getAutomate
_TEXT	ENDS
PUBLIC	?setAutomate@CvAutomateInfo@@QAEXH@Z		; CvAutomateInfo::setAutomate
; Function compile flags: /Ogtpy
;	COMDAT ?setAutomate@CvAutomateInfo@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?setAutomate@CvAutomateInfo@@QAEXH@Z PROC		; CvAutomateInfo::setAutomate, COMDAT
; _this$ = ecx

; 976  : 	m_iAutomate = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+464], eax

; 977  : }

	ret	4
?setAutomate@CvAutomateInfo@@QAEXH@Z ENDP		; CvAutomateInfo::setAutomate
_TEXT	ENDS
PUBLIC	?getConfirmCommand@CvAutomateInfo@@QBE_NXZ	; CvAutomateInfo::getConfirmCommand
; Function compile flags: /Ogtpy
;	COMDAT ?getConfirmCommand@CvAutomateInfo@@QBE_NXZ
_TEXT	SEGMENT
?getConfirmCommand@CvAutomateInfo@@QBE_NXZ PROC		; CvAutomateInfo::getConfirmCommand, COMDAT
; _this$ = ecx

; 981  : 	return m_bConfirmCommand;

	mov	al, BYTE PTR [ecx+468]

; 982  : }

	ret	0
?getConfirmCommand@CvAutomateInfo@@QBE_NXZ ENDP		; CvAutomateInfo::getConfirmCommand
_TEXT	ENDS
PUBLIC	?getVisible@CvAutomateInfo@@QBE_NXZ		; CvAutomateInfo::getVisible
; Function compile flags: /Ogtpy
;	COMDAT ?getVisible@CvAutomateInfo@@QBE_NXZ
_TEXT	SEGMENT
?getVisible@CvAutomateInfo@@QBE_NXZ PROC		; CvAutomateInfo::getVisible, COMDAT
; _this$ = ecx

; 986  : 	return m_bVisible;

	mov	al, BYTE PTR [ecx+469]

; 987  : }

	ret	0
?getVisible@CvAutomateInfo@@QBE_NXZ ENDP		; CvAutomateInfo::getVisible
_TEXT	ENDS
PUBLIC	??0CvActionInfo@@QAE@XZ				; CvActionInfo::CvActionInfo
; Function compile flags: /Ogtpy
;	COMDAT ??0CvActionInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvActionInfo@@QAE@XZ PROC				; CvActionInfo::CvActionInfo, COMDAT
; _this$ = ecx

; 1012 : {

	mov	eax, ecx
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1

; 1013 : }

	ret	0
??0CvActionInfo@@QAE@XZ ENDP				; CvActionInfo::CvActionInfo
_TEXT	ENDS
PUBLIC	?getMissionData@CvActionInfo@@QBEHXZ		; CvActionInfo::getMissionData
; Function compile flags: /Ogtpy
;	COMDAT ?getMissionData@CvActionInfo@@QBEHXZ
_TEXT	SEGMENT
?getMissionData@CvActionInfo@@QBEHXZ PROC		; CvActionInfo::getMissionData, COMDAT
; _this$ = ecx

; 1017 : 
; 1018 : 	if(
; 1019 : 	    (ACTIONSUBTYPE_BUILD == m_eSubType)			||
; 1020 : 	    (ACTIONSUBTYPE_SPECIALIST == m_eSubType)
; 1021 : 	)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 2
	je	SHORT $LN1@getMission
	cmp	eax, 4
	je	SHORT $LN1@getMission

; 1024 : 	}
; 1025 : 
; 1026 : 	return -1;

	or	eax, -1

; 1027 : }

	ret	0
$LN1@getMission:

; 1022 : 	{
; 1023 : 		return m_iOriginalIndex;

	mov	eax, DWORD PTR [ecx]

; 1027 : }

	ret	0
?getMissionData@CvActionInfo@@QBEHXZ ENDP		; CvActionInfo::getMissionData
_TEXT	ENDS
PUBLIC	?getCommandData@CvActionInfo@@QBEHXZ		; CvActionInfo::getCommandData
EXTRN	?getAutomateInfo@CvGlobals@@QAEPAVCvAutomateInfo@@H@Z:PROC ; CvGlobals::getAutomateInfo
EXTRN	?getCommandInfo@CvGlobals@@QAEPAVCvCommandInfo@@W4CommandTypes@@@Z:PROC ; CvGlobals::getCommandInfo
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?getCommandData@CvActionInfo@@QBEHXZ
_TEXT	SEGMENT
?getCommandData@CvActionInfo@@QBEHXZ PROC		; CvActionInfo::getCommandData, COMDAT
; _this$ = ecx

; 1031 : 
; 1032 : 	if(ACTIONSUBTYPE_PROMOTION == m_eSubType)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 3
	jne	SHORT $LN5@getCommand

; 1033 : 	{
; 1034 : 		return m_iOriginalIndex;

	mov	eax, DWORD PTR [ecx]

; 1050 : #endif
; 1051 : }

	ret	0
$LN5@getCommand:

; 1035 : 	}
; 1036 : #ifdef AUI_WARNING_FIXES
; 1037 : 	else
; 1038 : 		return getAutomateType();
; 1039 : #else
; 1040 : 	else if(ACTIONSUBTYPE_COMMAND == m_eSubType)

	cmp	eax, 1
	jne	SHORT $LN3@getCommand

; 1041 : 	{
; 1042 : 		return GC.getCommandInfo((CommandTypes)m_iOriginalIndex)->getAutomate();

	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCommandInfo@CvGlobals@@QAEPAVCvCommandInfo@@W4CommandTypes@@@Z ; CvGlobals::getCommandInfo
	mov	eax, DWORD PTR [eax+460]

; 1050 : #endif
; 1051 : }

	ret	0
$LN3@getCommand:

; 1043 : 	}
; 1044 : 	else if(ACTIONSUBTYPE_AUTOMATE == m_eSubType)

	cmp	eax, 6
	jne	SHORT $LN1@getCommand

; 1045 : 	{
; 1046 : 		return GC.getAutomateInfo(m_iOriginalIndex)->getAutomate();

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAutomateInfo@CvGlobals@@QAEPAVCvAutomateInfo@@H@Z ; CvGlobals::getAutomateInfo
	mov	eax, DWORD PTR [eax+464]

; 1050 : #endif
; 1051 : }

	ret	0
$LN1@getCommand:

; 1047 : 	}
; 1048 : 
; 1049 : 	return -1;

	or	eax, -1

; 1050 : #endif
; 1051 : }

	ret	0
?getCommandData@CvActionInfo@@QBEHXZ ENDP		; CvActionInfo::getCommandData
_TEXT	ENDS
PUBLIC	?getAutomateType@CvActionInfo@@QBEHXZ		; CvActionInfo::getAutomateType
; Function compile flags: /Ogtpy
;	COMDAT ?getAutomateType@CvActionInfo@@QBEHXZ
_TEXT	SEGMENT
?getAutomateType@CvActionInfo@@QBEHXZ PROC		; CvActionInfo::getAutomateType, COMDAT
; _this$ = ecx

; 1055 : 
; 1056 : 	if(ACTIONSUBTYPE_COMMAND == m_eSubType)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 1
	jne	SHORT $LN5@getAutomat

; 1057 : 	{
; 1058 : 		CvCommandInfo* pkCommandInfo = GC.getCommandInfo((CommandTypes)m_iOriginalIndex);

	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCommandInfo@CvGlobals@@QAEPAVCvCommandInfo@@W4CommandTypes@@@Z ; CvGlobals::getCommandInfo

; 1059 : 		if(pkCommandInfo)

	test	eax, eax
	je	SHORT $LN1@getAutomat

; 1060 : 		{
; 1061 : 			return pkCommandInfo->getAutomate();

	mov	eax, DWORD PTR [eax+460]

; 1074 : }

	ret	0
$LN5@getAutomat:

; 1062 : 		}
; 1063 : 	}
; 1064 : 	else if(ACTIONSUBTYPE_AUTOMATE == m_eSubType)

	cmp	eax, 6
	jne	SHORT $LN1@getAutomat

; 1065 : 	{
; 1066 : 		CvAutomateInfo* pkAutomateInfo = GC.getAutomateInfo(m_iOriginalIndex);

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAutomateInfo@CvGlobals@@QAEPAVCvAutomateInfo@@H@Z ; CvGlobals::getAutomateInfo

; 1067 : 		if(pkAutomateInfo)

	test	eax, eax
	je	SHORT $LN1@getAutomat

; 1068 : 		{
; 1069 : 			return pkAutomateInfo->getAutomate();

	mov	eax, DWORD PTR [eax+464]

; 1074 : }

	ret	0
$LN1@getAutomat:

; 1070 : 		}
; 1071 : 	}
; 1072 : 
; 1073 : 	return NO_AUTOMATE;

	or	eax, -1

; 1074 : }

	ret	0
?getAutomateType@CvActionInfo@@QBEHXZ ENDP		; CvActionInfo::getAutomateType
_TEXT	ENDS
PUBLIC	?getInterfaceModeType@CvActionInfo@@QBEHXZ	; CvActionInfo::getInterfaceModeType
; Function compile flags: /Ogtpy
;	COMDAT ?getInterfaceModeType@CvActionInfo@@QBEHXZ
_TEXT	SEGMENT
?getInterfaceModeType@CvActionInfo@@QBEHXZ PROC		; CvActionInfo::getInterfaceModeType, COMDAT
; _this$ = ecx

; 1078 : 	if(ACTIONSUBTYPE_INTERFACEMODE == m_eSubType)

	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN1@getInterfa

; 1079 : 	{
; 1080 : 		return m_iOriginalIndex;

	mov	eax, DWORD PTR [ecx]

; 1083 : }

	ret	0
$LN1@getInterfa:

; 1081 : 	}
; 1082 : 	return NO_INTERFACEMODE;

	or	eax, -1

; 1083 : }

	ret	0
?getInterfaceModeType@CvActionInfo@@QBEHXZ ENDP		; CvActionInfo::getInterfaceModeType
_TEXT	ENDS
PUBLIC	?getCommandType@CvActionInfo@@QBEHXZ		; CvActionInfo::getCommandType
EXTRN	?GetCommandType@CvPromotionEntry@@QBEHXZ:PROC	; CvPromotionEntry::GetCommandType
EXTRN	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z:PROC ; CvGlobals::getPromotionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getCommandType@CvActionInfo@@QBEHXZ
_TEXT	SEGMENT
?getCommandType@CvActionInfo@@QBEHXZ PROC		; CvActionInfo::getCommandType, COMDAT
; _this$ = ecx

; 1109 : 	if(ACTIONSUBTYPE_COMMAND == m_eSubType)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 1
	jne	SHORT $LN7@getCommand@2

; 1110 : 	{
; 1111 : 		return m_iOriginalIndex;

	mov	eax, DWORD PTR [ecx]

; 1131 : }

	ret	0
$LN7@getCommand@2:

; 1112 : 	}
; 1113 : 	else if(ACTIONSUBTYPE_PROMOTION == m_eSubType)

	cmp	eax, 3
	jne	SHORT $LN5@getCommand@2

; 1114 : 	{
; 1115 : 		CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo((PromotionTypes)m_iOriginalIndex);

	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo

; 1116 : 		if(pkPromotionInfo)

	test	eax, eax
	je	SHORT $LN1@getCommand@2

; 1117 : 		{
; 1118 : 			return pkPromotionInfo->GetCommandType();

	mov	ecx, eax
	jmp	?GetCommandType@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetCommandType
$LN5@getCommand@2:

; 1119 : 		}
; 1120 : 	}
; 1121 : 	else if(ACTIONSUBTYPE_AUTOMATE == m_eSubType)

	cmp	eax, 6
	jne	SHORT $LN1@getCommand@2

; 1122 : 	{
; 1123 : 		CvAutomateInfo* pkAutomateInfo = GC.getAutomateInfo(m_iOriginalIndex);

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAutomateInfo@CvGlobals@@QAEPAVCvAutomateInfo@@H@Z ; CvGlobals::getAutomateInfo

; 1124 : 		if(pkAutomateInfo)

	test	eax, eax
	je	SHORT $LN1@getCommand@2

; 1125 : 		{
; 1126 : 			return pkAutomateInfo->getCommand();

	mov	eax, DWORD PTR [eax+460]

; 1131 : }

	ret	0
$LN1@getCommand@2:

; 1127 : 		}
; 1128 : 	}
; 1129 : 
; 1130 : 	return NO_COMMAND;

	or	eax, -1

; 1131 : }

	ret	0
?getCommandType@CvActionInfo@@QBEHXZ ENDP		; CvActionInfo::getCommandType
_TEXT	ENDS
PUBLIC	?getControlType@CvActionInfo@@QBEHXZ		; CvActionInfo::getControlType
; Function compile flags: /Ogtpy
;	COMDAT ?getControlType@CvActionInfo@@QBEHXZ
_TEXT	SEGMENT
?getControlType@CvActionInfo@@QBEHXZ PROC		; CvActionInfo::getControlType, COMDAT
; _this$ = ecx

; 1135 : 	if(ACTIONSUBTYPE_CONTROL == m_eSubType)

	cmp	DWORD PTR [ecx+4], 5
	jne	SHORT $LN1@getControl

; 1136 : 	{
; 1137 : 		return m_iOriginalIndex;

	mov	eax, DWORD PTR [ecx]

; 1140 : }

	ret	0
$LN1@getControl:

; 1138 : 	}
; 1139 : 	return -1;

	or	eax, -1

; 1140 : }

	ret	0
?getControlType@CvActionInfo@@QBEHXZ ENDP		; CvActionInfo::getControlType
_TEXT	ENDS
PUBLIC	?getOriginalIndex@CvActionInfo@@QBEHXZ		; CvActionInfo::getOriginalIndex
; Function compile flags: /Ogtpy
;	COMDAT ?getOriginalIndex@CvActionInfo@@QBEHXZ
_TEXT	SEGMENT
?getOriginalIndex@CvActionInfo@@QBEHXZ PROC		; CvActionInfo::getOriginalIndex, COMDAT
; _this$ = ecx

; 1144 : 	return m_iOriginalIndex;

	mov	eax, DWORD PTR [ecx]

; 1145 : }

	ret	0
?getOriginalIndex@CvActionInfo@@QBEHXZ ENDP		; CvActionInfo::getOriginalIndex
_TEXT	ENDS
PUBLIC	?setOriginalIndex@CvActionInfo@@QAEXH@Z		; CvActionInfo::setOriginalIndex
; Function compile flags: /Ogtpy
;	COMDAT ?setOriginalIndex@CvActionInfo@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?setOriginalIndex@CvActionInfo@@QAEXH@Z PROC		; CvActionInfo::setOriginalIndex, COMDAT
; _this$ = ecx

; 1149 : 	m_iOriginalIndex = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1150 : }

	ret	4
?setOriginalIndex@CvActionInfo@@QAEXH@Z ENDP		; CvActionInfo::setOriginalIndex
_TEXT	ENDS
PUBLIC	?isConfirmCommand@CvActionInfo@@QBE_NXZ		; CvActionInfo::isConfirmCommand
; Function compile flags: /Ogtpy
;	COMDAT ?isConfirmCommand@CvActionInfo@@QBE_NXZ
_TEXT	SEGMENT
?isConfirmCommand@CvActionInfo@@QBE_NXZ PROC		; CvActionInfo::isConfirmCommand, COMDAT
; _this$ = ecx

; 1154 : 	if(ACTIONSUBTYPE_COMMAND == m_eSubType)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 1
	jne	SHORT $LN5@isConfirmC

; 1155 : 	{
; 1156 : 		CvCommandInfo* pkCommandInfo = GC.getCommandInfo((CommandTypes)m_iOriginalIndex);

	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCommandInfo@CvGlobals@@QAEPAVCvCommandInfo@@W4CommandTypes@@@Z ; CvGlobals::getCommandInfo

; 1157 : 		if(pkCommandInfo)

	test	eax, eax
	je	SHORT $LN1@isConfirmC

; 1158 : 		{
; 1159 : 			return pkCommandInfo->getConfirmCommand();

	mov	al, BYTE PTR [eax+464]

; 1172 : }

	ret	0
$LN5@isConfirmC:

; 1160 : 		}
; 1161 : 	}
; 1162 : 	else if(ACTIONSUBTYPE_AUTOMATE == m_eSubType)

	cmp	eax, 6
	jne	SHORT $LN1@isConfirmC

; 1163 : 	{
; 1164 : 		CvAutomateInfo* pkAutomateInfo = GC.getAutomateInfo(m_iOriginalIndex);

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAutomateInfo@CvGlobals@@QAEPAVCvAutomateInfo@@H@Z ; CvGlobals::getAutomateInfo

; 1165 : 		if(pkAutomateInfo)

	test	eax, eax
	je	SHORT $LN1@isConfirmC

; 1166 : 		{
; 1167 : 			return pkAutomateInfo->getConfirmCommand();

	mov	al, BYTE PTR [eax+468]

; 1172 : }

	ret	0
$LN1@isConfirmC:

; 1168 : 		}
; 1169 : 	}
; 1170 : 
; 1171 : 	return false;

	xor	al, al

; 1172 : }

	ret	0
?isConfirmCommand@CvActionInfo@@QBE_NXZ ENDP		; CvActionInfo::isConfirmCommand
_TEXT	ENDS
PUBLIC	?getSubType@CvActionInfo@@QBE?AW4ActionSubTypes@@XZ ; CvActionInfo::getSubType
; Function compile flags: /Ogtpy
;	COMDAT ?getSubType@CvActionInfo@@QBE?AW4ActionSubTypes@@XZ
_TEXT	SEGMENT
?getSubType@CvActionInfo@@QBE?AW4ActionSubTypes@@XZ PROC ; CvActionInfo::getSubType, COMDAT
; _this$ = ecx

; 1218 : 	return m_eSubType;

	mov	eax, DWORD PTR [ecx+4]

; 1219 : }

	ret	0
?getSubType@CvActionInfo@@QBE?AW4ActionSubTypes@@XZ ENDP ; CvActionInfo::getSubType
_TEXT	ENDS
PUBLIC	?setSubType@CvActionInfo@@QAEXW4ActionSubTypes@@@Z ; CvActionInfo::setSubType
; Function compile flags: /Ogtpy
;	COMDAT ?setSubType@CvActionInfo@@QAEXW4ActionSubTypes@@@Z
_TEXT	SEGMENT
_eSubType$ = 8						; size = 4
?setSubType@CvActionInfo@@QAEXW4ActionSubTypes@@@Z PROC	; CvActionInfo::setSubType, COMDAT
; _this$ = ecx

; 1223 : 	m_eSubType = eSubType;

	mov	eax, DWORD PTR _eSubType$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 1224 : }

	ret	4
?setSubType@CvActionInfo@@QAEXW4ActionSubTypes@@@Z ENDP	; CvActionInfo::setSubType
_TEXT	ENDS
PUBLIC	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
EXTRN	?getMissionInfo@CvGlobals@@QAEPAVCvMissionInfo@@W4MissionTypes@@@Z:PROC ; CvGlobals::getMissionInfo
EXTRN	?getControlInfo@CvGlobals@@QAEPAVCvControlInfo@@W4ControlTypes@@@Z:PROC ; CvGlobals::getControlInfo
EXTRN	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z:PROC ; CvGlobals::getSpecialistInfo
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
EXTRN	?getInterfaceModeInfo@CvGlobals@@QAEPAVCvInterfaceModeInfo@@W4InterfaceModeTypes@@@Z:PROC ; CvGlobals::getInterfaceModeInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ
_TEXT	SEGMENT
?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ PROC ; CvActionInfo::getHotkeyInfo, COMDAT
; _this$ = ecx

; 1228 : 	switch(getSubType())

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 7
	ja	$LN1@getHotkeyI
	jmp	DWORD PTR $LN39@getHotkeyI[eax*4]
$LN16@getHotkeyI:

; 1229 : 	{
; 1230 : 	case ACTIONSUBTYPE_INTERFACEMODE:
; 1231 : 	{
; 1232 : 		CvInterfaceModeInfo* pkInterfaceModInfo = GC.getInterfaceModeInfo((InterfaceModeTypes)getOriginalIndex());

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInterfaceModeInfo@CvGlobals@@QAEPAVCvInterfaceModeInfo@@W4InterfaceModeTypes@@@Z ; CvGlobals::getInterfaceModeInfo

; 1233 : 		if(pkInterfaceModInfo)

	test	eax, eax
	je	SHORT $LN1@getHotkeyI

; 1306 : }

	ret	0
$LN14@getHotkeyI:

; 1234 : 		{
; 1235 : 			return pkInterfaceModInfo;
; 1236 : 		}
; 1237 : 	}
; 1238 : 	break;
; 1239 : 	case ACTIONSUBTYPE_COMMAND:
; 1240 : 	{
; 1241 : 		CvCommandInfo* pkCommandInfo = GC.getCommandInfo((CommandTypes)getOriginalIndex());

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCommandInfo@CvGlobals@@QAEPAVCvCommandInfo@@W4CommandTypes@@@Z ; CvGlobals::getCommandInfo

; 1242 : 		if(pkCommandInfo)

	test	eax, eax
	je	SHORT $LN1@getHotkeyI

; 1306 : }

	ret	0
$LN12@getHotkeyI:

; 1243 : 		{
; 1244 : 			return pkCommandInfo;
; 1245 : 		}
; 1246 : 	}
; 1247 : 	break;
; 1248 : 	case ACTIONSUBTYPE_BUILD:
; 1249 : 	{
; 1250 : 		CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes)getOriginalIndex());

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 1251 : 		if(pkBuildInfo)

	test	eax, eax
	je	SHORT $LN1@getHotkeyI

; 1306 : }

	ret	0
$LN10@getHotkeyI:

; 1252 : 		{
; 1253 : 			return pkBuildInfo;
; 1254 : 		}
; 1255 : 	}
; 1256 : 	break;
; 1257 : 	case ACTIONSUBTYPE_PROMOTION:
; 1258 : 	{
; 1259 : 		CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo((PromotionTypes)getOriginalIndex());

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo

; 1260 : 		if(pkPromotionInfo)

	test	eax, eax
	je	SHORT $LN1@getHotkeyI

; 1306 : }

	ret	0
$LN8@getHotkeyI:

; 1261 : 		{
; 1262 : 			return pkPromotionInfo;
; 1263 : 		}
; 1264 : 	}
; 1265 : 	break;
; 1266 : 	case ACTIONSUBTYPE_SPECIALIST:
; 1267 : 	{
; 1268 : 		CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo((SpecialistTypes)getOriginalIndex());

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo

; 1269 : 		if(pkSpecialistInfo)

	test	eax, eax
	je	SHORT $LN1@getHotkeyI

; 1306 : }

	ret	0
$LN6@getHotkeyI:

; 1270 : 		{
; 1271 : 			return pkSpecialistInfo;
; 1272 : 		}
; 1273 : 	}
; 1274 : 	break;
; 1275 : 	case ACTIONSUBTYPE_CONTROL:
; 1276 : 	{
; 1277 : 		CvControlInfo* pkControlInfo = GC.getControlInfo((ControlTypes)getOriginalIndex());

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getControlInfo@CvGlobals@@QAEPAVCvControlInfo@@W4ControlTypes@@@Z ; CvGlobals::getControlInfo

; 1278 : 		if(pkControlInfo)

	test	eax, eax
	je	SHORT $LN1@getHotkeyI

; 1306 : }

	ret	0
$LN4@getHotkeyI:

; 1279 : 		{
; 1280 : 			return pkControlInfo;
; 1281 : 		}
; 1282 : 	}
; 1283 : 	break;
; 1284 : 	case ACTIONSUBTYPE_AUTOMATE:
; 1285 : 	{
; 1286 : 		CvAutomateInfo* pkAutomateInfo = GC.getAutomateInfo((AutomateTypes)getOriginalIndex());

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAutomateInfo@CvGlobals@@QAEPAVCvAutomateInfo@@H@Z ; CvGlobals::getAutomateInfo

; 1287 : 		if(pkAutomateInfo)

	test	eax, eax
	je	SHORT $LN1@getHotkeyI

; 1306 : }

	ret	0
$LN2@getHotkeyI:

; 1288 : 		{
; 1289 : 			return pkAutomateInfo;
; 1290 : 		}
; 1291 : 	}
; 1292 : 	break;
; 1293 : 	case ACTIONSUBTYPE_MISSION:
; 1294 : 	{
; 1295 : 		CvMissionInfo* pkMissionInfo = GC.getMissionInfo((MissionTypes)getOriginalIndex());

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMissionInfo@CvGlobals@@QAEPAVCvMissionInfo@@W4MissionTypes@@@Z ; CvGlobals::getMissionInfo

; 1296 : 		if(pkMissionInfo)

	test	eax, eax

; 1297 : 		{
; 1298 : 			return pkMissionInfo;

	jne	SHORT $LN19@getHotkeyI
$LN1@getHotkeyI:

; 1299 : 		}
; 1300 : 	}
; 1301 : 	break;
; 1302 : 	}
; 1303 : 
; 1304 : 	CvAssertMsg((0) ,"Unknown Action Subtype in CvActionInfo::getHotkeyInfo");
; 1305 : 	return NULL;

	xor	eax, eax
$LN19@getHotkeyI:

; 1306 : }

	ret	0
	npad	3
$LN39@getHotkeyI:
	DD	$LN16@getHotkeyI
	DD	$LN14@getHotkeyI
	DD	$LN12@getHotkeyI
	DD	$LN10@getHotkeyI
	DD	$LN8@getHotkeyI
	DD	$LN6@getHotkeyI
	DD	$LN4@getHotkeyI
	DD	$LN2@getHotkeyI
?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ENDP ; CvActionInfo::getHotkeyInfo
_TEXT	ENDS
PUBLIC	?GetHelp@CvActionInfo@@QBEPBDXZ			; CvActionInfo::GetHelp
; Function compile flags: /Ogtpy
;	COMDAT ?GetHelp@CvActionInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetHelp@CvActionInfo@@QBEPBDXZ PROC			; CvActionInfo::GetHelp, COMDAT
; _this$ = ecx

; 1339 : {

	push	esi
	mov	esi, ecx

; 1340 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@GetHelp

; 1341 : 	{
; 1342 : 		return getHotkeyInfo()->getHelp();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	lea	ecx, DWORD PTR [eax+404]
	pop	esi
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LN1@GetHelp:

; 1343 : 	}
; 1344 : 
; 1345 : 	return "";

	mov	eax, OFFSET $SG219565
	pop	esi

; 1346 : }

	ret	0
?GetHelp@CvActionInfo@@QBEPBDXZ ENDP			; CvActionInfo::GetHelp
_TEXT	ENDS
PUBLIC	?GetDisabledHelp@CvActionInfo@@QBEPBDXZ		; CvActionInfo::GetDisabledHelp
; Function compile flags: /Ogtpy
;	COMDAT ?GetDisabledHelp@CvActionInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDisabledHelp@CvActionInfo@@QBEPBDXZ PROC		; CvActionInfo::GetDisabledHelp, COMDAT
; _this$ = ecx

; 1349 : {

	push	esi
	mov	esi, ecx

; 1350 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@GetDisable

; 1351 : 	{
; 1352 : 		return getHotkeyInfo()->getDisabledHelp();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	lea	ecx, DWORD PTR [eax+432]
	pop	esi
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LN1@GetDisable:

; 1353 : 	}
; 1354 : 
; 1355 : 	return "";

	mov	eax, OFFSET $SG219570
	pop	esi

; 1356 : }

	ret	0
?GetDisabledHelp@CvActionInfo@@QBEPBDXZ ENDP		; CvActionInfo::GetDisabledHelp
_TEXT	ENDS
PUBLIC	?GetTextKey@CvActionInfo@@QBEPBDXZ		; CvActionInfo::GetTextKey
; Function compile flags: /Ogtpy
;	COMDAT ?GetTextKey@CvActionInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetTextKey@CvActionInfo@@QBEPBDXZ PROC			; CvActionInfo::GetTextKey, COMDAT
; _this$ = ecx

; 1369 : {

	push	esi
	mov	esi, ecx

; 1370 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@GetTextKey@2

; 1371 : 	{
; 1372 : 		return getHotkeyInfo()->GetTextKey();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	lea	esi, DWORD PTR [eax+204]
	mov	ecx, esi
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	test	al, al
	jne	SHORT $LN1@GetTextKey@2
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LN1@GetTextKey@2:

; 1373 : 	}
; 1374 : 
; 1375 : 	return NULL;

	xor	eax, eax
	pop	esi

; 1376 : }

	ret	0
?GetTextKey@CvActionInfo@@QBEPBDXZ ENDP			; CvActionInfo::GetTextKey
_TEXT	ENDS
PUBLIC	?getActionInfoIndex@CvActionInfo@@QBEHXZ	; CvActionInfo::getActionInfoIndex
; Function compile flags: /Ogtpy
;	COMDAT ?getActionInfoIndex@CvActionInfo@@QBEHXZ
_TEXT	SEGMENT
?getActionInfoIndex@CvActionInfo@@QBEHXZ PROC		; CvActionInfo::getActionInfoIndex, COMDAT
; _this$ = ecx

; 1379 : {

	push	esi
	mov	esi, ecx

; 1380 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@getActionI

; 1381 : 	{
; 1382 : 		return getHotkeyInfo()->getActionInfoIndex();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	mov	eax, DWORD PTR [eax+260]
	pop	esi

; 1386 : }

	ret	0
$LN1@getActionI:

; 1383 : 	}
; 1384 : 
; 1385 : 	return -1;

	or	eax, -1
	pop	esi

; 1386 : }

	ret	0
?getActionInfoIndex@CvActionInfo@@QBEHXZ ENDP		; CvActionInfo::getActionInfoIndex
_TEXT	ENDS
PUBLIC	?getHotKeyVal@CvActionInfo@@QBEHXZ		; CvActionInfo::getHotKeyVal
; Function compile flags: /Ogtpy
;	COMDAT ?getHotKeyVal@CvActionInfo@@QBEHXZ
_TEXT	SEGMENT
?getHotKeyVal@CvActionInfo@@QBEHXZ PROC			; CvActionInfo::getHotKeyVal, COMDAT
; _this$ = ecx

; 1389 : {

	push	esi
	mov	esi, ecx

; 1390 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@getHotKeyV

; 1391 : 	{
; 1392 : 		return getHotkeyInfo()->getHotKeyVal();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	mov	eax, DWORD PTR [eax+264]
	pop	esi

; 1396 : }

	ret	0
$LN1@getHotKeyV:

; 1393 : 	}
; 1394 : 
; 1395 : 	return -1;

	or	eax, -1
	pop	esi

; 1396 : }

	ret	0
?getHotKeyVal@CvActionInfo@@QBEHXZ ENDP			; CvActionInfo::getHotKeyVal
_TEXT	ENDS
PUBLIC	?getHotKeyPriority@CvActionInfo@@QBEHXZ		; CvActionInfo::getHotKeyPriority
; Function compile flags: /Ogtpy
;	COMDAT ?getHotKeyPriority@CvActionInfo@@QBEHXZ
_TEXT	SEGMENT
?getHotKeyPriority@CvActionInfo@@QBEHXZ PROC		; CvActionInfo::getHotKeyPriority, COMDAT
; _this$ = ecx

; 1399 : {

	push	esi
	mov	esi, ecx

; 1400 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@getHotKeyP

; 1401 : 	{
; 1402 : 		return getHotkeyInfo()->getHotKeyPriority();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	mov	eax, DWORD PTR [eax+268]
	pop	esi

; 1406 : }

	ret	0
$LN1@getHotKeyP:

; 1403 : 	}
; 1404 : 
; 1405 : 	return -1;

	or	eax, -1
	pop	esi

; 1406 : }

	ret	0
?getHotKeyPriority@CvActionInfo@@QBEHXZ ENDP		; CvActionInfo::getHotKeyPriority
_TEXT	ENDS
PUBLIC	?getHotKeyValAlt@CvActionInfo@@QBEHXZ		; CvActionInfo::getHotKeyValAlt
; Function compile flags: /Ogtpy
;	COMDAT ?getHotKeyValAlt@CvActionInfo@@QBEHXZ
_TEXT	SEGMENT
?getHotKeyValAlt@CvActionInfo@@QBEHXZ PROC		; CvActionInfo::getHotKeyValAlt, COMDAT
; _this$ = ecx

; 1409 : {

	push	esi
	mov	esi, ecx

; 1410 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@getHotKeyV@2

; 1411 : 	{
; 1412 : 		return getHotkeyInfo()->getHotKeyValAlt();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	mov	eax, DWORD PTR [eax+272]
	pop	esi

; 1416 : }

	ret	0
$LN1@getHotKeyV@2:

; 1413 : 	}
; 1414 : 
; 1415 : 	return -1;

	or	eax, -1
	pop	esi

; 1416 : }

	ret	0
?getHotKeyValAlt@CvActionInfo@@QBEHXZ ENDP		; CvActionInfo::getHotKeyValAlt
_TEXT	ENDS
PUBLIC	?getHotKeyPriorityAlt@CvActionInfo@@QBEHXZ	; CvActionInfo::getHotKeyPriorityAlt
; Function compile flags: /Ogtpy
;	COMDAT ?getHotKeyPriorityAlt@CvActionInfo@@QBEHXZ
_TEXT	SEGMENT
?getHotKeyPriorityAlt@CvActionInfo@@QBEHXZ PROC		; CvActionInfo::getHotKeyPriorityAlt, COMDAT
; _this$ = ecx

; 1419 : {

	push	esi
	mov	esi, ecx

; 1420 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@getHotKeyP@2

; 1421 : 	{
; 1422 : 		return getHotkeyInfo()->getHotKeyPriorityAlt();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	mov	eax, DWORD PTR [eax+276]
	pop	esi

; 1426 : }

	ret	0
$LN1@getHotKeyP@2:

; 1423 : 	}
; 1424 : 
; 1425 : 	return -1;

	or	eax, -1
	pop	esi

; 1426 : }

	ret	0
?getHotKeyPriorityAlt@CvActionInfo@@QBEHXZ ENDP		; CvActionInfo::getHotKeyPriorityAlt
_TEXT	ENDS
PUBLIC	?getOrderPriority@CvActionInfo@@QBEHXZ		; CvActionInfo::getOrderPriority
; Function compile flags: /Ogtpy
;	COMDAT ?getOrderPriority@CvActionInfo@@QBEHXZ
_TEXT	SEGMENT
?getOrderPriority@CvActionInfo@@QBEHXZ PROC		; CvActionInfo::getOrderPriority, COMDAT
; _this$ = ecx

; 1429 : {

	push	esi
	mov	esi, ecx

; 1430 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@getOrderPr

; 1431 : 	{
; 1432 : 		return getHotkeyInfo()->getOrderPriority();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	mov	eax, DWORD PTR [eax+280]
	pop	esi

; 1436 : }

	ret	0
$LN1@getOrderPr:

; 1433 : 	}
; 1434 : 
; 1435 : 	return -1;

	or	eax, -1
	pop	esi

; 1436 : }

	ret	0
?getOrderPriority@CvActionInfo@@QBEHXZ ENDP		; CvActionInfo::getOrderPriority
_TEXT	ENDS
PUBLIC	?isAltDown@CvActionInfo@@QBE_NXZ		; CvActionInfo::isAltDown
; Function compile flags: /Ogtpy
;	COMDAT ?isAltDown@CvActionInfo@@QBE_NXZ
_TEXT	SEGMENT
?isAltDown@CvActionInfo@@QBE_NXZ PROC			; CvActionInfo::isAltDown, COMDAT
; _this$ = ecx

; 1439 : {

	push	esi
	mov	esi, ecx

; 1440 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@isAltDown

; 1441 : 	{
; 1442 : 		return getHotkeyInfo()->isAltDown();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	mov	al, BYTE PTR [eax+284]
	pop	esi

; 1446 : }

	ret	0
$LN1@isAltDown:

; 1443 : 	}
; 1444 : 
; 1445 : 	return false;

	xor	al, al
	pop	esi

; 1446 : }

	ret	0
?isAltDown@CvActionInfo@@QBE_NXZ ENDP			; CvActionInfo::isAltDown
_TEXT	ENDS
PUBLIC	?isShiftDown@CvActionInfo@@QBE_NXZ		; CvActionInfo::isShiftDown
; Function compile flags: /Ogtpy
;	COMDAT ?isShiftDown@CvActionInfo@@QBE_NXZ
_TEXT	SEGMENT
?isShiftDown@CvActionInfo@@QBE_NXZ PROC			; CvActionInfo::isShiftDown, COMDAT
; _this$ = ecx

; 1449 : {

	push	esi
	mov	esi, ecx

; 1450 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@isShiftDow

; 1451 : 	{
; 1452 : 		return getHotkeyInfo()->isShiftDown();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	mov	al, BYTE PTR [eax+285]
	pop	esi

; 1456 : }

	ret	0
$LN1@isShiftDow:

; 1453 : 	}
; 1454 : 
; 1455 : 	return false;

	xor	al, al
	pop	esi

; 1456 : }

	ret	0
?isShiftDown@CvActionInfo@@QBE_NXZ ENDP			; CvActionInfo::isShiftDown
_TEXT	ENDS
PUBLIC	?isCtrlDown@CvActionInfo@@QBE_NXZ		; CvActionInfo::isCtrlDown
; Function compile flags: /Ogtpy
;	COMDAT ?isCtrlDown@CvActionInfo@@QBE_NXZ
_TEXT	SEGMENT
?isCtrlDown@CvActionInfo@@QBE_NXZ PROC			; CvActionInfo::isCtrlDown, COMDAT
; _this$ = ecx

; 1459 : {

	push	esi
	mov	esi, ecx

; 1460 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@isCtrlDown

; 1461 : 	{
; 1462 : 		return getHotkeyInfo()->isCtrlDown();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	mov	al, BYTE PTR [eax+286]
	pop	esi

; 1466 : }

	ret	0
$LN1@isCtrlDown:

; 1463 : 	}
; 1464 : 
; 1465 : 	return false;

	xor	al, al
	pop	esi

; 1466 : }

	ret	0
?isCtrlDown@CvActionInfo@@QBE_NXZ ENDP			; CvActionInfo::isCtrlDown
_TEXT	ENDS
PUBLIC	?isAltDownAlt@CvActionInfo@@QBE_NXZ		; CvActionInfo::isAltDownAlt
; Function compile flags: /Ogtpy
;	COMDAT ?isAltDownAlt@CvActionInfo@@QBE_NXZ
_TEXT	SEGMENT
?isAltDownAlt@CvActionInfo@@QBE_NXZ PROC		; CvActionInfo::isAltDownAlt, COMDAT
; _this$ = ecx

; 1469 : {

	push	esi
	mov	esi, ecx

; 1470 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@isAltDownA

; 1471 : 	{
; 1472 : 		return getHotkeyInfo()->isAltDownAlt();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	mov	al, BYTE PTR [eax+287]
	pop	esi

; 1476 : }

	ret	0
$LN1@isAltDownA:

; 1473 : 	}
; 1474 : 
; 1475 : 	return false;

	xor	al, al
	pop	esi

; 1476 : }

	ret	0
?isAltDownAlt@CvActionInfo@@QBE_NXZ ENDP		; CvActionInfo::isAltDownAlt
_TEXT	ENDS
PUBLIC	?isShiftDownAlt@CvActionInfo@@QBE_NXZ		; CvActionInfo::isShiftDownAlt
; Function compile flags: /Ogtpy
;	COMDAT ?isShiftDownAlt@CvActionInfo@@QBE_NXZ
_TEXT	SEGMENT
?isShiftDownAlt@CvActionInfo@@QBE_NXZ PROC		; CvActionInfo::isShiftDownAlt, COMDAT
; _this$ = ecx

; 1479 : {

	push	esi
	mov	esi, ecx

; 1480 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@isShiftDow@2

; 1481 : 	{
; 1482 : 		return getHotkeyInfo()->isShiftDownAlt();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	mov	al, BYTE PTR [eax+288]
	pop	esi

; 1486 : }

	ret	0
$LN1@isShiftDow@2:

; 1483 : 	}
; 1484 : 
; 1485 : 	return false;

	xor	al, al
	pop	esi

; 1486 : }

	ret	0
?isShiftDownAlt@CvActionInfo@@QBE_NXZ ENDP		; CvActionInfo::isShiftDownAlt
_TEXT	ENDS
PUBLIC	?isCtrlDownAlt@CvActionInfo@@QBE_NXZ		; CvActionInfo::isCtrlDownAlt
; Function compile flags: /Ogtpy
;	COMDAT ?isCtrlDownAlt@CvActionInfo@@QBE_NXZ
_TEXT	SEGMENT
?isCtrlDownAlt@CvActionInfo@@QBE_NXZ PROC		; CvActionInfo::isCtrlDownAlt, COMDAT
; _this$ = ecx

; 1489 : {

	push	esi
	mov	esi, ecx

; 1490 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@isCtrlDown@2

; 1491 : 	{
; 1492 : 		return getHotkeyInfo()->isCtrlDownAlt();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	mov	al, BYTE PTR [eax+289]
	pop	esi

; 1496 : }

	ret	0
$LN1@isCtrlDown@2:

; 1493 : 	}
; 1494 : 
; 1495 : 	return false;

	xor	al, al
	pop	esi

; 1496 : }

	ret	0
?isCtrlDownAlt@CvActionInfo@@QBE_NXZ ENDP		; CvActionInfo::isCtrlDownAlt
_TEXT	ENDS
PUBLIC	?getHotKeyString@CvActionInfo@@QBEPBDXZ		; CvActionInfo::getHotKeyString
; Function compile flags: /Ogtpy
;	COMDAT ?getHotKeyString@CvActionInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getHotKeyString@CvActionInfo@@QBEPBDXZ PROC		; CvActionInfo::getHotKeyString, COMDAT
; _this$ = ecx

; 1519 : {

	push	esi
	mov	esi, ecx

; 1520 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@getHotKeyS

; 1521 : 	{
; 1522 : 		return getHotkeyInfo()->getHotKeyString();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	lea	ecx, DWORD PTR [eax+376]
	pop	esi
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LN1@getHotKeyS:

; 1523 : 	}
; 1524 : 
; 1525 : 	return "";

	mov	eax, OFFSET $SG219643
	pop	esi

; 1526 : }

	ret	0
?getHotKeyString@CvActionInfo@@QBEPBDXZ ENDP		; CvActionInfo::getHotKeyString
_TEXT	ENDS
PUBLIC	?IsRequiresNavalUnitConsistency@CvMultiUnitFormationInfo@@QBE_NXZ ; CvMultiUnitFormationInfo::IsRequiresNavalUnitConsistency
; Function compile flags: /Ogtpy
;	COMDAT ?IsRequiresNavalUnitConsistency@CvMultiUnitFormationInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsRequiresNavalUnitConsistency@CvMultiUnitFormationInfo@@QBE_NXZ PROC ; CvMultiUnitFormationInfo::IsRequiresNavalUnitConsistency, COMDAT
; _this$ = ecx

; 1543 : 	return m_bRequiresNavalUnitConsistency;

	mov	al, BYTE PTR [ecx+304]

; 1544 : }

	ret	0
?IsRequiresNavalUnitConsistency@CvMultiUnitFormationInfo@@QBE_NXZ ENDP ; CvMultiUnitFormationInfo::IsRequiresNavalUnitConsistency
_TEXT	ENDS
PUBLIC	?isValid@CvSpecialUnitInfo@@QBE_NXZ		; CvSpecialUnitInfo::isValid
; Function compile flags: /Ogtpy
;	COMDAT ?isValid@CvSpecialUnitInfo@@QBE_NXZ
_TEXT	SEGMENT
?isValid@CvSpecialUnitInfo@@QBE_NXZ PROC		; CvSpecialUnitInfo::isValid, COMDAT
; _this$ = ecx

; 1615 : 	return m_bValid;

	mov	al, BYTE PTR [ecx+260]

; 1616 : }

	ret	0
?isValid@CvSpecialUnitInfo@@QBE_NXZ ENDP		; CvSpecialUnitInfo::isValid
_TEXT	ENDS
PUBLIC	?isCityLoad@CvSpecialUnitInfo@@QBE_NXZ		; CvSpecialUnitInfo::isCityLoad
; Function compile flags: /Ogtpy
;	COMDAT ?isCityLoad@CvSpecialUnitInfo@@QBE_NXZ
_TEXT	SEGMENT
?isCityLoad@CvSpecialUnitInfo@@QBE_NXZ PROC		; CvSpecialUnitInfo::isCityLoad, COMDAT
; _this$ = ecx

; 1620 : 	return m_bCityLoad;

	mov	al, BYTE PTR [ecx+261]

; 1621 : }

	ret	0
?isCityLoad@CvSpecialUnitInfo@@QBE_NXZ ENDP		; CvSpecialUnitInfo::isCityLoad
_TEXT	ENDS
PUBLIC	?isCarrierUnitAIType@CvSpecialUnitInfo@@QBE_NH@Z ; CvSpecialUnitInfo::isCarrierUnitAIType
; Function compile flags: /Ogtpy
;	COMDAT ?isCarrierUnitAIType@CvSpecialUnitInfo@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?isCarrierUnitAIType@CvSpecialUnitInfo@@QBE_NH@Z PROC	; CvSpecialUnitInfo::isCarrierUnitAIType, COMDAT
; _this$ = ecx

; 1625 : 	CvAssertMsg(i < NUM_UNITAI_TYPES, "Index out of bounds");
; 1626 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1627 : 	return m_pbCarrierUnitAITypes ? m_pbCarrierUnitAITypes[i] : -1;

	mov	eax, DWORD PTR [ecx+264]
	test	eax, eax
	je	SHORT $LN3@isCarrierU
	mov	ecx, DWORD PTR _i$[esp-4]
	movzx	eax, BYTE PTR [eax+ecx]
	test	eax, eax
	setne	al

; 1628 : }

	ret	4
$LN3@isCarrierU:

; 1625 : 	CvAssertMsg(i < NUM_UNITAI_TYPES, "Index out of bounds");
; 1626 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1627 : 	return m_pbCarrierUnitAITypes ? m_pbCarrierUnitAITypes[i] : -1;

	or	eax, -1
	test	eax, eax
	setne	al

; 1628 : }

	ret	4
?isCarrierUnitAIType@CvSpecialUnitInfo@@QBE_NH@Z ENDP	; CvSpecialUnitInfo::isCarrierUnitAIType
_TEXT	ENDS
PUBLIC	?getProductionTraits@CvSpecialUnitInfo@@QBEHH@Z	; CvSpecialUnitInfo::getProductionTraits
; Function compile flags: /Ogtpy
;	COMDAT ?getProductionTraits@CvSpecialUnitInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getProductionTraits@CvSpecialUnitInfo@@QBEHH@Z PROC	; CvSpecialUnitInfo::getProductionTraits, COMDAT
; _this$ = ecx

; 1632 : 	CvAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
; 1633 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1634 : 	return m_piProductionTraits ? m_piProductionTraits[i] : -1;

	mov	eax, DWORD PTR [ecx+268]
	test	eax, eax
	je	SHORT $LN3@getProduct
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1635 : }

	ret	4
$LN3@getProduct:

; 1632 : 	CvAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
; 1633 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1634 : 	return m_piProductionTraits ? m_piProductionTraits[i] : -1;

	or	eax, -1

; 1635 : }

	ret	4
?getProductionTraits@CvSpecialUnitInfo@@QBEHH@Z ENDP	; CvSpecialUnitInfo::getProductionTraits
_TEXT	ENDS
PUBLIC	?getMaxGlobalInstances@CvUnitClassInfo@@QBEHXZ	; CvUnitClassInfo::getMaxGlobalInstances
; Function compile flags: /Ogtpy
;	COMDAT ?getMaxGlobalInstances@CvUnitClassInfo@@QBEHXZ
_TEXT	SEGMENT
?getMaxGlobalInstances@CvUnitClassInfo@@QBEHXZ PROC	; CvUnitClassInfo::getMaxGlobalInstances, COMDAT
; _this$ = ecx

; 1666 : 	return m_iMaxGlobalInstances;

	mov	eax, DWORD PTR [ecx+260]

; 1667 : }

	ret	0
?getMaxGlobalInstances@CvUnitClassInfo@@QBEHXZ ENDP	; CvUnitClassInfo::getMaxGlobalInstances
_TEXT	ENDS
PUBLIC	?getMaxTeamInstances@CvUnitClassInfo@@QBEHXZ	; CvUnitClassInfo::getMaxTeamInstances
; Function compile flags: /Ogtpy
;	COMDAT ?getMaxTeamInstances@CvUnitClassInfo@@QBEHXZ
_TEXT	SEGMENT
?getMaxTeamInstances@CvUnitClassInfo@@QBEHXZ PROC	; CvUnitClassInfo::getMaxTeamInstances, COMDAT
; _this$ = ecx

; 1671 : 	return m_iMaxTeamInstances;

	mov	eax, DWORD PTR [ecx+264]

; 1672 : }

	ret	0
?getMaxTeamInstances@CvUnitClassInfo@@QBEHXZ ENDP	; CvUnitClassInfo::getMaxTeamInstances
_TEXT	ENDS
PUBLIC	?getMaxPlayerInstances@CvUnitClassInfo@@QBEHXZ	; CvUnitClassInfo::getMaxPlayerInstances
; Function compile flags: /Ogtpy
;	COMDAT ?getMaxPlayerInstances@CvUnitClassInfo@@QBEHXZ
_TEXT	SEGMENT
?getMaxPlayerInstances@CvUnitClassInfo@@QBEHXZ PROC	; CvUnitClassInfo::getMaxPlayerInstances, COMDAT
; _this$ = ecx

; 1676 : 	return m_iMaxPlayerInstances;

	mov	eax, DWORD PTR [ecx+268]

; 1677 : }

	ret	0
?getMaxPlayerInstances@CvUnitClassInfo@@QBEHXZ ENDP	; CvUnitClassInfo::getMaxPlayerInstances
_TEXT	ENDS
PUBLIC	?getInstanceCostModifier@CvUnitClassInfo@@QBEHXZ ; CvUnitClassInfo::getInstanceCostModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getInstanceCostModifier@CvUnitClassInfo@@QBEHXZ
_TEXT	SEGMENT
?getInstanceCostModifier@CvUnitClassInfo@@QBEHXZ PROC	; CvUnitClassInfo::getInstanceCostModifier, COMDAT
; _this$ = ecx

; 1681 : 	return m_iInstanceCostModifier;

	mov	eax, DWORD PTR [ecx+272]

; 1682 : }

	ret	0
?getInstanceCostModifier@CvUnitClassInfo@@QBEHXZ ENDP	; CvUnitClassInfo::getInstanceCostModifier
_TEXT	ENDS
PUBLIC	?getDefaultUnitIndex@CvUnitClassInfo@@QBEHXZ	; CvUnitClassInfo::getDefaultUnitIndex
; Function compile flags: /Ogtpy
;	COMDAT ?getDefaultUnitIndex@CvUnitClassInfo@@QBEHXZ
_TEXT	SEGMENT
?getDefaultUnitIndex@CvUnitClassInfo@@QBEHXZ PROC	; CvUnitClassInfo::getDefaultUnitIndex, COMDAT
; _this$ = ecx

; 1686 : 	return m_iDefaultUnitIndex;

	mov	eax, DWORD PTR [ecx+276]

; 1687 : }

	ret	0
?getDefaultUnitIndex@CvUnitClassInfo@@QBEHXZ ENDP	; CvUnitClassInfo::getDefaultUnitIndex
_TEXT	ENDS
PUBLIC	?setDefaultUnitIndex@CvUnitClassInfo@@QAEXH@Z	; CvUnitClassInfo::setDefaultUnitIndex
; Function compile flags: /Ogtpy
;	COMDAT ?setDefaultUnitIndex@CvUnitClassInfo@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?setDefaultUnitIndex@CvUnitClassInfo@@QAEXH@Z PROC	; CvUnitClassInfo::setDefaultUnitIndex, COMDAT
; _this$ = ecx

; 1691 : 	m_iDefaultUnitIndex = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+276], eax

; 1692 : }

	ret	4
?setDefaultUnitIndex@CvUnitClassInfo@@QAEXH@Z ENDP	; CvUnitClassInfo::setDefaultUnitIndex
_TEXT	ENDS
PUBLIC	?getMaxGlobalInstances@CvBuildingClassInfo@@QBEHXZ ; CvBuildingClassInfo::getMaxGlobalInstances
; Function compile flags: /Ogtpy
;	COMDAT ?getMaxGlobalInstances@CvBuildingClassInfo@@QBEHXZ
_TEXT	SEGMENT
?getMaxGlobalInstances@CvBuildingClassInfo@@QBEHXZ PROC	; CvBuildingClassInfo::getMaxGlobalInstances, COMDAT
; _this$ = ecx

; 1731 : 	return m_iMaxGlobalInstances;

	mov	eax, DWORD PTR [ecx+260]

; 1732 : }

	ret	0
?getMaxGlobalInstances@CvBuildingClassInfo@@QBEHXZ ENDP	; CvBuildingClassInfo::getMaxGlobalInstances
_TEXT	ENDS
PUBLIC	?getMaxTeamInstances@CvBuildingClassInfo@@QBEHXZ ; CvBuildingClassInfo::getMaxTeamInstances
; Function compile flags: /Ogtpy
;	COMDAT ?getMaxTeamInstances@CvBuildingClassInfo@@QBEHXZ
_TEXT	SEGMENT
?getMaxTeamInstances@CvBuildingClassInfo@@QBEHXZ PROC	; CvBuildingClassInfo::getMaxTeamInstances, COMDAT
; _this$ = ecx

; 1736 : 	return m_iMaxTeamInstances;

	mov	eax, DWORD PTR [ecx+264]

; 1737 : }

	ret	0
?getMaxTeamInstances@CvBuildingClassInfo@@QBEHXZ ENDP	; CvBuildingClassInfo::getMaxTeamInstances
_TEXT	ENDS
PUBLIC	?getMaxPlayerInstances@CvBuildingClassInfo@@QBEHXZ ; CvBuildingClassInfo::getMaxPlayerInstances
; Function compile flags: /Ogtpy
;	COMDAT ?getMaxPlayerInstances@CvBuildingClassInfo@@QBEHXZ
_TEXT	SEGMENT
?getMaxPlayerInstances@CvBuildingClassInfo@@QBEHXZ PROC	; CvBuildingClassInfo::getMaxPlayerInstances, COMDAT
; _this$ = ecx

; 1741 : 	return m_iMaxPlayerInstances;

	mov	eax, DWORD PTR [ecx+268]

; 1742 : }

	ret	0
?getMaxPlayerInstances@CvBuildingClassInfo@@QBEHXZ ENDP	; CvBuildingClassInfo::getMaxPlayerInstances
_TEXT	ENDS
PUBLIC	?getExtraPlayerInstances@CvBuildingClassInfo@@QBEHXZ ; CvBuildingClassInfo::getExtraPlayerInstances
; Function compile flags: /Ogtpy
;	COMDAT ?getExtraPlayerInstances@CvBuildingClassInfo@@QBEHXZ
_TEXT	SEGMENT
?getExtraPlayerInstances@CvBuildingClassInfo@@QBEHXZ PROC ; CvBuildingClassInfo::getExtraPlayerInstances, COMDAT
; _this$ = ecx

; 1746 : 	return m_iExtraPlayerInstances;

	mov	eax, DWORD PTR [ecx+272]

; 1747 : }

	ret	0
?getExtraPlayerInstances@CvBuildingClassInfo@@QBEHXZ ENDP ; CvBuildingClassInfo::getExtraPlayerInstances
_TEXT	ENDS
PUBLIC	?getDefaultBuildingIndex@CvBuildingClassInfo@@QBEHXZ ; CvBuildingClassInfo::getDefaultBuildingIndex
; Function compile flags: /Ogtpy
;	COMDAT ?getDefaultBuildingIndex@CvBuildingClassInfo@@QBEHXZ
_TEXT	SEGMENT
?getDefaultBuildingIndex@CvBuildingClassInfo@@QBEHXZ PROC ; CvBuildingClassInfo::getDefaultBuildingIndex, COMDAT
; _this$ = ecx

; 1751 : 	return m_iDefaultBuildingIndex;

	mov	eax, DWORD PTR [ecx+276]

; 1752 : }

	ret	0
?getDefaultBuildingIndex@CvBuildingClassInfo@@QBEHXZ ENDP ; CvBuildingClassInfo::getDefaultBuildingIndex
_TEXT	ENDS
PUBLIC	?setDefaultBuildingIndex@CvBuildingClassInfo@@QAEXH@Z ; CvBuildingClassInfo::setDefaultBuildingIndex
; Function compile flags: /Ogtpy
;	COMDAT ?setDefaultBuildingIndex@CvBuildingClassInfo@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?setDefaultBuildingIndex@CvBuildingClassInfo@@QAEXH@Z PROC ; CvBuildingClassInfo::setDefaultBuildingIndex, COMDAT
; _this$ = ecx

; 1756 : 	m_iDefaultBuildingIndex = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+276], eax

; 1757 : }

	ret	4
?setDefaultBuildingIndex@CvBuildingClassInfo@@QAEXH@Z ENDP ; CvBuildingClassInfo::setDefaultBuildingIndex
_TEXT	ENDS
PUBLIC	?isNoLimit@CvBuildingClassInfo@@QBE_NXZ		; CvBuildingClassInfo::isNoLimit
; Function compile flags: /Ogtpy
;	COMDAT ?isNoLimit@CvBuildingClassInfo@@QBE_NXZ
_TEXT	SEGMENT
?isNoLimit@CvBuildingClassInfo@@QBE_NXZ PROC		; CvBuildingClassInfo::isNoLimit, COMDAT
; _this$ = ecx

; 1761 : 	return m_bNoLimit;

	mov	al, BYTE PTR [ecx+280]

; 1762 : }

	ret	0
?isNoLimit@CvBuildingClassInfo@@QBE_NXZ ENDP		; CvBuildingClassInfo::isNoLimit
_TEXT	ENDS
PUBLIC	?isMonument@CvBuildingClassInfo@@QBE_NXZ	; CvBuildingClassInfo::isMonument
; Function compile flags: /Ogtpy
;	COMDAT ?isMonument@CvBuildingClassInfo@@QBE_NXZ
_TEXT	SEGMENT
?isMonument@CvBuildingClassInfo@@QBE_NXZ PROC		; CvBuildingClassInfo::isMonument, COMDAT
; _this$ = ecx

; 1766 : 	return m_bMonument;

	mov	al, BYTE PTR [ecx+281]

; 1767 : }

	ret	0
?isMonument@CvBuildingClassInfo@@QBE_NXZ ENDP		; CvBuildingClassInfo::isMonument
_TEXT	ENDS
PUBLIC	?getVictoryThreshold@CvBuildingClassInfo@@QBEHH@Z ; CvBuildingClassInfo::getVictoryThreshold
; Function compile flags: /Ogtpy
;	COMDAT ?getVictoryThreshold@CvBuildingClassInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getVictoryThreshold@CvBuildingClassInfo@@QBEHH@Z PROC	; CvBuildingClassInfo::getVictoryThreshold, COMDAT
; _this$ = ecx

; 1771 : 	CvAssertMsg(i < GC.getNumVictoryInfos(), "Index out of bounds");
; 1772 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1773 : 	return m_piVictoryThreshold ? m_piVictoryThreshold[i] : -1;

	mov	eax, DWORD PTR [ecx+284]
	test	eax, eax
	je	SHORT $LN3@getVictory
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1774 : }

	ret	4
$LN3@getVictory:

; 1771 : 	CvAssertMsg(i < GC.getNumVictoryInfos(), "Index out of bounds");
; 1772 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1773 : 	return m_piVictoryThreshold ? m_piVictoryThreshold[i] : -1;

	or	eax, -1

; 1774 : }

	ret	4
?getVictoryThreshold@CvBuildingClassInfo@@QBEHH@Z ENDP	; CvBuildingClassInfo::getVictoryThreshold
_TEXT	ENDS
PUBLIC	?isAIPlayable@CvCivilizationBaseInfo@@QBE_NXZ	; CvCivilizationBaseInfo::isAIPlayable
; Function compile flags: /Ogtpy
;	COMDAT ?isAIPlayable@CvCivilizationBaseInfo@@QBE_NXZ
_TEXT	SEGMENT
?isAIPlayable@CvCivilizationBaseInfo@@QBE_NXZ PROC	; CvCivilizationBaseInfo::isAIPlayable, COMDAT
; _this$ = ecx

; 1923 : 	return m_bAIPlayable;

	mov	al, BYTE PTR [ecx+260]

; 1924 : }

	ret	0
?isAIPlayable@CvCivilizationBaseInfo@@QBE_NXZ ENDP	; CvCivilizationBaseInfo::isAIPlayable
_TEXT	ENDS
PUBLIC	?isPlayable@CvCivilizationBaseInfo@@QBE_NXZ	; CvCivilizationBaseInfo::isPlayable
; Function compile flags: /Ogtpy
;	COMDAT ?isPlayable@CvCivilizationBaseInfo@@QBE_NXZ
_TEXT	SEGMENT
?isPlayable@CvCivilizationBaseInfo@@QBE_NXZ PROC	; CvCivilizationBaseInfo::isPlayable, COMDAT
; _this$ = ecx

; 1928 : 	return m_bPlayable;

	mov	al, BYTE PTR [ecx+261]

; 1929 : }

	ret	0
?isPlayable@CvCivilizationBaseInfo@@QBE_NXZ ENDP	; CvCivilizationBaseInfo::isPlayable
_TEXT	ENDS
PUBLIC	?getShortDescription@CvCivilizationBaseInfo@@QBEPBDXZ ; CvCivilizationBaseInfo::getShortDescription
; Function compile flags: /Ogtpy
;	COMDAT ?getShortDescription@CvCivilizationBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getShortDescription@CvCivilizationBaseInfo@@QBEPBDXZ PROC ; CvCivilizationBaseInfo::getShortDescription, COMDAT
; _this$ = ecx

; 1933 : 	return m_strShortDescription.c_str();

	add	ecx, 264				; 00000108H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getShortDescription@CvCivilizationBaseInfo@@QBEPBDXZ ENDP ; CvCivilizationBaseInfo::getShortDescription
_TEXT	ENDS
PUBLIC	?getShortDescriptionKey@CvCivilizationBaseInfo@@QBEPBDXZ ; CvCivilizationBaseInfo::getShortDescriptionKey
; Function compile flags: /Ogtpy
;	COMDAT ?getShortDescriptionKey@CvCivilizationBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getShortDescriptionKey@CvCivilizationBaseInfo@@QBEPBDXZ PROC ; CvCivilizationBaseInfo::getShortDescriptionKey, COMDAT
; _this$ = ecx

; 1944 : 	return m_strShortDescriptionKey.c_str();

	add	ecx, 292				; 00000124H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getShortDescriptionKey@CvCivilizationBaseInfo@@QBEPBDXZ ENDP ; CvCivilizationBaseInfo::getShortDescriptionKey
_TEXT	ENDS
PUBLIC	?getPackageID@CvCivilizationBaseInfo@@QBEABU_GUID@@XZ ; CvCivilizationBaseInfo::getPackageID
; Function compile flags: /Ogtpy
;	COMDAT ?getPackageID@CvCivilizationBaseInfo@@QBEABU_GUID@@XZ
_TEXT	SEGMENT
?getPackageID@CvCivilizationBaseInfo@@QBEABU_GUID@@XZ PROC ; CvCivilizationBaseInfo::getPackageID, COMDAT
; _this$ = ecx

; 1949 : 	return m_kPackageID;

	lea	eax, DWORD PTR [ecx+320]

; 1950 : }

	ret	0
?getPackageID@CvCivilizationBaseInfo@@QBEABU_GUID@@XZ ENDP ; CvCivilizationBaseInfo::getPackageID
_TEXT	ENDS
PUBLIC	?getDefaultPlayerColor@CvCivilizationInfo@@QBEHXZ ; CvCivilizationInfo::getDefaultPlayerColor
; Function compile flags: /Ogtpy
;	COMDAT ?getDefaultPlayerColor@CvCivilizationInfo@@QBEHXZ
_TEXT	SEGMENT
?getDefaultPlayerColor@CvCivilizationInfo@@QBEHXZ PROC	; CvCivilizationInfo::getDefaultPlayerColor, COMDAT
; _this$ = ecx

; 2066 : 	return m_iDefaultPlayerColor;

	mov	eax, DWORD PTR [ecx+336]

; 2067 : }

	ret	0
?getDefaultPlayerColor@CvCivilizationInfo@@QBEHXZ ENDP	; CvCivilizationInfo::getDefaultPlayerColor
_TEXT	ENDS
PUBLIC	?getArtStyleType@CvCivilizationInfo@@QBEHXZ	; CvCivilizationInfo::getArtStyleType
; Function compile flags: /Ogtpy
;	COMDAT ?getArtStyleType@CvCivilizationInfo@@QBEHXZ
_TEXT	SEGMENT
?getArtStyleType@CvCivilizationInfo@@QBEHXZ PROC	; CvCivilizationInfo::getArtStyleType, COMDAT
; _this$ = ecx

; 2071 : 	return m_iArtStyleType;

	mov	eax, DWORD PTR [ecx+340]

; 2072 : }

	ret	0
?getArtStyleType@CvCivilizationInfo@@QBEHXZ ENDP	; CvCivilizationInfo::getArtStyleType
_TEXT	ENDS
PUBLIC	?getArtStyleSuffix@CvCivilizationInfo@@QBEPBDXZ	; CvCivilizationInfo::getArtStyleSuffix
; Function compile flags: /Ogtpy
;	COMDAT ?getArtStyleSuffix@CvCivilizationInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getArtStyleSuffix@CvCivilizationInfo@@QBEPBDXZ PROC	; CvCivilizationInfo::getArtStyleSuffix, COMDAT
; _this$ = ecx

; 2076 : 	return m_strArtStyleSuffix.c_str();

	add	ecx, 404				; 00000194H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getArtStyleSuffix@CvCivilizationInfo@@QBEPBDXZ ENDP	; CvCivilizationInfo::getArtStyleSuffix
_TEXT	ENDS
PUBLIC	?getArtStylePrefix@CvCivilizationInfo@@QBEPBDXZ	; CvCivilizationInfo::getArtStylePrefix
; Function compile flags: /Ogtpy
;	COMDAT ?getArtStylePrefix@CvCivilizationInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getArtStylePrefix@CvCivilizationInfo@@QBEPBDXZ PROC	; CvCivilizationInfo::getArtStylePrefix, COMDAT
; _this$ = ecx

; 2081 : 	return m_strArtStylePrefix.c_str();

	add	ecx, 376				; 00000178H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getArtStylePrefix@CvCivilizationInfo@@QBEPBDXZ ENDP	; CvCivilizationInfo::getArtStylePrefix
_TEXT	ENDS
PUBLIC	?getNumLeaders@CvCivilizationInfo@@QBEHXZ	; CvCivilizationInfo::getNumLeaders
; Function compile flags: /Ogtpy
;	COMDAT ?getNumLeaders@CvCivilizationInfo@@QBEHXZ
_TEXT	SEGMENT
?getNumLeaders@CvCivilizationInfo@@QBEHXZ PROC		; CvCivilizationInfo::getNumLeaders, COMDAT
; _this$ = ecx

; 2097 : 	// the number of leaders the Civ has, this is needed so that random leaders can be generated easily
; 2098 : 	return m_iNumLeaders;

	mov	eax, DWORD PTR [ecx+344]

; 2099 : }

	ret	0
?getNumLeaders@CvCivilizationInfo@@QBEHXZ ENDP		; CvCivilizationInfo::getNumLeaders
_TEXT	ENDS
PUBLIC	?GetDawnOfManAudio@CvCivilizationInfo@@QBEPBDXZ	; CvCivilizationInfo::GetDawnOfManAudio
; Function compile flags: /Ogtpy
;	COMDAT ?GetDawnOfManAudio@CvCivilizationInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDawnOfManAudio@CvCivilizationInfo@@QBEPBDXZ PROC	; CvCivilizationInfo::GetDawnOfManAudio, COMDAT
; _this$ = ecx

; 2103 : 	return m_strDawnOfManAudio.c_str();

	add	ecx, 488				; 000001e8H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDawnOfManAudio@CvCivilizationInfo@@QBEPBDXZ ENDP	; CvCivilizationInfo::GetDawnOfManAudio
_TEXT	ENDS
PUBLIC	?getSoundtrackKey@CvCivilizationInfo@@QBEPBDXZ	; CvCivilizationInfo::getSoundtrackKey
; Function compile flags: /Ogtpy
;	COMDAT ?getSoundtrackKey@CvCivilizationInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getSoundtrackKey@CvCivilizationInfo@@QBEPBDXZ PROC	; CvCivilizationInfo::getSoundtrackKey, COMDAT
; _this$ = ecx

; 2108 : 	return m_strSoundtrackKey.c_str();

	add	ecx, 516				; 00000204H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getSoundtrackKey@CvCivilizationInfo@@QBEPBDXZ ENDP	; CvCivilizationInfo::getSoundtrackKey
_TEXT	ENDS
PUBLIC	?getAdjective@CvCivilizationInfo@@QBEPBDXZ	; CvCivilizationInfo::getAdjective
; Function compile flags: /Ogtpy
;	COMDAT ?getAdjective@CvCivilizationInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getAdjective@CvCivilizationInfo@@QBEPBDXZ PROC		; CvCivilizationInfo::getAdjective, COMDAT
; _this$ = ecx

; 2114 : 	return m_strAdjective.c_str();

	add	ecx, 432				; 000001b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getAdjective@CvCivilizationInfo@@QBEPBDXZ ENDP		; CvCivilizationInfo::getAdjective
_TEXT	ENDS
PUBLIC	?getAdjectiveKey@CvCivilizationInfo@@QBEPBDXZ	; CvCivilizationInfo::getAdjectiveKey
; Function compile flags: /Ogtpy
;	COMDAT ?getAdjectiveKey@CvCivilizationInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getAdjectiveKey@CvCivilizationInfo@@QBEPBDXZ PROC	; CvCivilizationInfo::getAdjectiveKey, COMDAT
; _this$ = ecx

; 2125 : 	return m_strAdjectiveKey.c_str();

	add	ecx, 460				; 000001ccH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getAdjectiveKey@CvCivilizationInfo@@QBEPBDXZ ENDP	; CvCivilizationInfo::getAdjectiveKey
_TEXT	ENDS
PUBLIC	?getFlagTexture@CvCivilizationInfo@@QBEPBDXZ	; CvCivilizationInfo::getFlagTexture
; Function compile flags: /Ogtpy
;	COMDAT ?getFlagTexture@CvCivilizationInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getFlagTexture@CvCivilizationInfo@@QBEPBDXZ PROC	; CvCivilizationInfo::getFlagTexture, COMDAT
; _this$ = ecx

; 2130 : 	return NULL;

	xor	eax, eax

; 2131 : }

	ret	0
?getFlagTexture@CvCivilizationInfo@@QBEPBDXZ ENDP	; CvCivilizationInfo::getFlagTexture
_TEXT	ENDS
PUBLIC	?getArtDefineTag@CvCivilizationInfo@@QBEPBDXZ	; CvCivilizationInfo::getArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?getArtDefineTag@CvCivilizationInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getArtDefineTag@CvCivilizationInfo@@QBEPBDXZ PROC	; CvCivilizationInfo::getArtDefineTag, COMDAT
; _this$ = ecx

; 2135 : 	return m_strArtDefineTag.c_str();

	add	ecx, 348				; 0000015cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getArtDefineTag@CvCivilizationInfo@@QBEPBDXZ ENDP	; CvCivilizationInfo::getArtDefineTag
_TEXT	ENDS
PUBLIC	?GetReligion@CvCivilizationInfo@@QBE?AW4ReligionTypes@@XZ ; CvCivilizationInfo::GetReligion
EXTRN	?getNumReligionInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumReligionInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetReligion@CvCivilizationInfo@@QBE?AW4ReligionTypes@@XZ
_TEXT	SEGMENT
?GetReligion@CvCivilizationInfo@@QBE?AW4ReligionTypes@@XZ PROC ; CvCivilizationInfo::GetReligion, COMDAT
; _this$ = ecx

; 2154 : {

	push	esi
	push	edi
	mov	edi, ecx

; 2155 : 	// Only one per civ supported now
; 2156 : #ifdef AUI_WARNING_FIXES
; 2157 : 	for (uint iI = 0; iI < GC.getNumReligionInfos(); iI++)
; 2158 : #else
; 2159 : 	for(int iI = 0; iI < GC.getNumReligionInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumReligionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumReligionInfos
	test	eax, eax
	jle	SHORT $LN2@GetReligio
$LL4@GetReligio:

; 2160 : #endif
; 2161 : 	{
; 2162 : 		if(m_pbReligions[iI])

	mov	eax, DWORD PTR [edi+576]
	cmp	BYTE PTR [esi+eax], 0
	jne	SHORT $LN8@GetReligio
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumReligionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumReligionInfos
	cmp	esi, eax
	jl	SHORT $LL4@GetReligio
$LN2@GetReligio:
	pop	edi

; 2165 : 		}
; 2166 : 	}
; 2167 : 	return NO_RELIGION;

	or	eax, -1
	pop	esi

; 2168 : }

	ret	0
$LN8@GetReligio:
	pop	edi

; 2163 : 		{
; 2164 : 			return (ReligionTypes)iI;

	mov	eax, esi
	pop	esi

; 2168 : }

	ret	0
?GetReligion@CvCivilizationInfo@@QBE?AW4ReligionTypes@@XZ ENDP ; CvCivilizationInfo::GetReligion
_TEXT	ENDS
PUBLIC	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
; Function compile flags: /Ogtpy
;	COMDAT ?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z PROC ; CvCivilizationInfo::getCivilizationBuildings, COMDAT
; _this$ = ecx

; 2172 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2173 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2174 : 	return m_piCivilizationBuildings ? m_piCivilizationBuildings[i] : -1;

	mov	eax, DWORD PTR [ecx+544]
	test	eax, eax
	je	SHORT $LN3@getCiviliz
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2175 : }

	ret	4
$LN3@getCiviliz:

; 2172 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2173 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2174 : 	return m_piCivilizationBuildings ? m_piCivilizationBuildings[i] : -1;

	or	eax, -1

; 2175 : }

	ret	4
?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ENDP ; CvCivilizationInfo::getCivilizationBuildings
_TEXT	ENDS
PUBLIC	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z PROC	; CvCivilizationInfo::getCivilizationUnits, COMDAT
; _this$ = ecx

; 2179 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 2180 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2181 : 	return m_piCivilizationUnits ? m_piCivilizationUnits[i] : -1;

	mov	eax, DWORD PTR [ecx+548]
	test	eax, eax
	je	SHORT $LN3@getCiviliz@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2182 : }

	ret	4
$LN3@getCiviliz@2:

; 2179 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 2180 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2181 : 	return m_piCivilizationUnits ? m_piCivilizationUnits[i] : -1;

	or	eax, -1

; 2182 : }

	ret	4
?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z ENDP	; CvCivilizationInfo::getCivilizationUnits
_TEXT	ENDS
PUBLIC	?getCivilizationFreeUnitsClass@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationFreeUnitsClass
; Function compile flags: /Ogtpy
;	COMDAT ?getCivilizationFreeUnitsClass@CvCivilizationInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getCivilizationFreeUnitsClass@CvCivilizationInfo@@QBEHH@Z PROC ; CvCivilizationInfo::getCivilizationFreeUnitsClass, COMDAT
; _this$ = ecx

; 2200 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 2201 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2202 : 	return m_piCivilizationFreeUnitsClass ? m_piCivilizationFreeUnitsClass[i] : -1;

	mov	eax, DWORD PTR [ecx+552]
	test	eax, eax
	je	SHORT $LN3@getCiviliz@3
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2203 : }

	ret	4
$LN3@getCiviliz@3:

; 2200 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 2201 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2202 : 	return m_piCivilizationFreeUnitsClass ? m_piCivilizationFreeUnitsClass[i] : -1;

	or	eax, -1

; 2203 : }

	ret	4
?getCivilizationFreeUnitsClass@CvCivilizationInfo@@QBEHH@Z ENDP ; CvCivilizationInfo::getCivilizationFreeUnitsClass
_TEXT	ENDS
PUBLIC	?getCivilizationFreeUnitsDefaultUnitAI@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationFreeUnitsDefaultUnitAI
; Function compile flags: /Ogtpy
;	COMDAT ?getCivilizationFreeUnitsDefaultUnitAI@CvCivilizationInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getCivilizationFreeUnitsDefaultUnitAI@CvCivilizationInfo@@QBEHH@Z PROC ; CvCivilizationInfo::getCivilizationFreeUnitsDefaultUnitAI, COMDAT
; _this$ = ecx

; 2207 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 2208 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2209 : 	return m_piCivilizationFreeUnitsDefaultUnitAI ? m_piCivilizationFreeUnitsDefaultUnitAI[i] : -1;

	mov	eax, DWORD PTR [ecx+556]
	test	eax, eax
	je	SHORT $LN3@getCiviliz@4
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2210 : }

	ret	4
$LN3@getCiviliz@4:

; 2207 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 2208 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2209 : 	return m_piCivilizationFreeUnitsDefaultUnitAI ? m_piCivilizationFreeUnitsDefaultUnitAI[i] : -1;

	or	eax, -1

; 2210 : }

	ret	4
?getCivilizationFreeUnitsDefaultUnitAI@CvCivilizationInfo@@QBEHH@Z ENDP ; CvCivilizationInfo::getCivilizationFreeUnitsDefaultUnitAI
_TEXT	ENDS
PUBLIC	?isLeaders@CvCivilizationInfo@@QBE_NH@Z		; CvCivilizationInfo::isLeaders
; Function compile flags: /Ogtpy
;	COMDAT ?isLeaders@CvCivilizationInfo@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?isLeaders@CvCivilizationInfo@@QBE_NH@Z PROC		; CvCivilizationInfo::isLeaders, COMDAT
; _this$ = ecx

; 2214 : 	CvAssertMsg(i < GC.getNumLeaderHeadInfos(), "Index out of bounds");
; 2215 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2216 : 	return m_pbLeaders ? m_pbLeaders[i] : false;

	mov	eax, DWORD PTR [ecx+560]
	test	eax, eax
	je	SHORT $LN3@isLeaders
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 2217 : }

	ret	4
$LN3@isLeaders:

; 2214 : 	CvAssertMsg(i < GC.getNumLeaderHeadInfos(), "Index out of bounds");
; 2215 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2216 : 	return m_pbLeaders ? m_pbLeaders[i] : false;

	xor	al, al

; 2217 : }

	ret	4
?isLeaders@CvCivilizationInfo@@QBE_NH@Z ENDP		; CvCivilizationInfo::isLeaders
_TEXT	ENDS
PUBLIC	?isCivilizationFreeBuildingClass@CvCivilizationInfo@@QBE_NH@Z ; CvCivilizationInfo::isCivilizationFreeBuildingClass
; Function compile flags: /Ogtpy
;	COMDAT ?isCivilizationFreeBuildingClass@CvCivilizationInfo@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?isCivilizationFreeBuildingClass@CvCivilizationInfo@@QBE_NH@Z PROC ; CvCivilizationInfo::isCivilizationFreeBuildingClass, COMDAT
; _this$ = ecx

; 2221 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2222 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2223 : 	return m_pbCivilizationFreeBuildingClass ? m_pbCivilizationFreeBuildingClass[i] : false;

	mov	eax, DWORD PTR [ecx+564]
	test	eax, eax
	je	SHORT $LN3@isCiviliza
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 2224 : }

	ret	4
$LN3@isCiviliza:

; 2221 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2222 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2223 : 	return m_pbCivilizationFreeBuildingClass ? m_pbCivilizationFreeBuildingClass[i] : false;

	xor	al, al

; 2224 : }

	ret	4
?isCivilizationFreeBuildingClass@CvCivilizationInfo@@QBE_NH@Z ENDP ; CvCivilizationInfo::isCivilizationFreeBuildingClass
_TEXT	ENDS
PUBLIC	?isCivilizationFreeTechs@CvCivilizationInfo@@QBE_NH@Z ; CvCivilizationInfo::isCivilizationFreeTechs
; Function compile flags: /Ogtpy
;	COMDAT ?isCivilizationFreeTechs@CvCivilizationInfo@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?isCivilizationFreeTechs@CvCivilizationInfo@@QBE_NH@Z PROC ; CvCivilizationInfo::isCivilizationFreeTechs, COMDAT
; _this$ = ecx

; 2228 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 2229 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2230 : 	return m_pbCivilizationFreeTechs ? m_pbCivilizationFreeTechs[i] : false;

	mov	eax, DWORD PTR [ecx+568]
	test	eax, eax
	je	SHORT $LN3@isCiviliza@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 2231 : }

	ret	4
$LN3@isCiviliza@2:

; 2228 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 2229 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2230 : 	return m_pbCivilizationFreeTechs ? m_pbCivilizationFreeTechs[i] : false;

	xor	al, al

; 2231 : }

	ret	4
?isCivilizationFreeTechs@CvCivilizationInfo@@QBE_NH@Z ENDP ; CvCivilizationInfo::isCivilizationFreeTechs
_TEXT	ENDS
PUBLIC	?isCivilizationDisableTechs@CvCivilizationInfo@@QBE_NH@Z ; CvCivilizationInfo::isCivilizationDisableTechs
; Function compile flags: /Ogtpy
;	COMDAT ?isCivilizationDisableTechs@CvCivilizationInfo@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?isCivilizationDisableTechs@CvCivilizationInfo@@QBE_NH@Z PROC ; CvCivilizationInfo::isCivilizationDisableTechs, COMDAT
; _this$ = ecx

; 2235 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 2236 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2237 : 	return m_pbCivilizationDisableTechs ? m_pbCivilizationDisableTechs[i] : false;

	mov	eax, DWORD PTR [ecx+572]
	test	eax, eax
	je	SHORT $LN3@isCiviliza@3
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 2238 : }

	ret	4
$LN3@isCiviliza@3:

; 2235 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 2236 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2237 : 	return m_pbCivilizationDisableTechs ? m_pbCivilizationDisableTechs[i] : false;

	xor	al, al

; 2238 : }

	ret	4
?isCivilizationDisableTechs@CvCivilizationInfo@@QBE_NH@Z ENDP ; CvCivilizationInfo::isCivilizationDisableTechs
_TEXT	ENDS
PUBLIC	?isCoastalCiv@CvCivilizationInfo@@QBE_NXZ	; CvCivilizationInfo::isCoastalCiv
; Function compile flags: /Ogtpy
;	COMDAT ?isCoastalCiv@CvCivilizationInfo@@QBE_NXZ
_TEXT	SEGMENT
?isCoastalCiv@CvCivilizationInfo@@QBE_NXZ PROC		; CvCivilizationInfo::isCoastalCiv, COMDAT
; _this$ = ecx

; 2252 : 	return m_bCoastalCiv;

	mov	al, BYTE PTR [ecx+580]

; 2253 : }

	ret	0
?isCoastalCiv@CvCivilizationInfo@@QBE_NXZ ENDP		; CvCivilizationInfo::isCoastalCiv
_TEXT	ENDS
PUBLIC	?isFirstCoastalStart@CvCivilizationInfo@@QBE_NXZ ; CvCivilizationInfo::isFirstCoastalStart
; Function compile flags: /Ogtpy
;	COMDAT ?isFirstCoastalStart@CvCivilizationInfo@@QBE_NXZ
_TEXT	SEGMENT
?isFirstCoastalStart@CvCivilizationInfo@@QBE_NXZ PROC	; CvCivilizationInfo::isFirstCoastalStart, COMDAT
; _this$ = ecx

; 2257 : 	return m_bPlaceFirst;

	mov	al, BYTE PTR [ecx+581]

; 2258 : }

	ret	0
?isFirstCoastalStart@CvCivilizationInfo@@QBE_NXZ ENDP	; CvCivilizationInfo::isFirstCoastalStart
_TEXT	ENDS
PUBLIC	?getPopulationPercentLead@CvVictoryInfo@@QBEHXZ	; CvVictoryInfo::getPopulationPercentLead
; Function compile flags: /Ogtpy
;	COMDAT ?getPopulationPercentLead@CvVictoryInfo@@QBEHXZ
_TEXT	SEGMENT
?getPopulationPercentLead@CvVictoryInfo@@QBEHXZ PROC	; CvVictoryInfo::getPopulationPercentLead, COMDAT
; _this$ = ecx

; 2530 : 	return m_iPopulationPercentLead;

	mov	eax, DWORD PTR [ecx+260]

; 2531 : }

	ret	0
?getPopulationPercentLead@CvVictoryInfo@@QBEHXZ ENDP	; CvVictoryInfo::getPopulationPercentLead
_TEXT	ENDS
PUBLIC	?getLandPercent@CvVictoryInfo@@QBEHXZ		; CvVictoryInfo::getLandPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getLandPercent@CvVictoryInfo@@QBEHXZ
_TEXT	SEGMENT
?getLandPercent@CvVictoryInfo@@QBEHXZ PROC		; CvVictoryInfo::getLandPercent, COMDAT
; _this$ = ecx

; 2535 : 	return m_iLandPercent;

	mov	eax, DWORD PTR [ecx+264]

; 2536 : }

	ret	0
?getLandPercent@CvVictoryInfo@@QBEHXZ ENDP		; CvVictoryInfo::getLandPercent
_TEXT	ENDS
PUBLIC	?getMinLandPercent@CvVictoryInfo@@QBEHXZ	; CvVictoryInfo::getMinLandPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getMinLandPercent@CvVictoryInfo@@QBEHXZ
_TEXT	SEGMENT
?getMinLandPercent@CvVictoryInfo@@QBEHXZ PROC		; CvVictoryInfo::getMinLandPercent, COMDAT
; _this$ = ecx

; 2540 : 	return m_iMinLandPercent;

	mov	eax, DWORD PTR [ecx+268]

; 2541 : }

	ret	0
?getMinLandPercent@CvVictoryInfo@@QBEHXZ ENDP		; CvVictoryInfo::getMinLandPercent
_TEXT	ENDS
PUBLIC	?getCityCulture@CvVictoryInfo@@QBEHXZ		; CvVictoryInfo::getCityCulture
; Function compile flags: /Ogtpy
;	COMDAT ?getCityCulture@CvVictoryInfo@@QBEHXZ
_TEXT	SEGMENT
?getCityCulture@CvVictoryInfo@@QBEHXZ PROC		; CvVictoryInfo::getCityCulture, COMDAT
; _this$ = ecx

; 2545 : 	return m_iCityCulture;

	mov	eax, DWORD PTR [ecx+272]

; 2546 : }

	ret	0
?getCityCulture@CvVictoryInfo@@QBEHXZ ENDP		; CvVictoryInfo::getCityCulture
_TEXT	ENDS
PUBLIC	?getNumCultureCities@CvVictoryInfo@@QBEHXZ	; CvVictoryInfo::getNumCultureCities
; Function compile flags: /Ogtpy
;	COMDAT ?getNumCultureCities@CvVictoryInfo@@QBEHXZ
_TEXT	SEGMENT
?getNumCultureCities@CvVictoryInfo@@QBEHXZ PROC		; CvVictoryInfo::getNumCultureCities, COMDAT
; _this$ = ecx

; 2550 : 	return m_iNumCultureCities;

	mov	eax, DWORD PTR [ecx+276]

; 2551 : }

	ret	0
?getNumCultureCities@CvVictoryInfo@@QBEHXZ ENDP		; CvVictoryInfo::getNumCultureCities
_TEXT	ENDS
PUBLIC	?getTotalCultureRatio@CvVictoryInfo@@QBEHXZ	; CvVictoryInfo::getTotalCultureRatio
; Function compile flags: /Ogtpy
;	COMDAT ?getTotalCultureRatio@CvVictoryInfo@@QBEHXZ
_TEXT	SEGMENT
?getTotalCultureRatio@CvVictoryInfo@@QBEHXZ PROC	; CvVictoryInfo::getTotalCultureRatio, COMDAT
; _this$ = ecx

; 2555 : 	return m_iTotalCultureRatio;

	mov	eax, DWORD PTR [ecx+280]

; 2556 : }

	ret	0
?getTotalCultureRatio@CvVictoryInfo@@QBEHXZ ENDP	; CvVictoryInfo::getTotalCultureRatio
_TEXT	ENDS
PUBLIC	?getVictoryDelayTurns@CvVictoryInfo@@QBEHXZ	; CvVictoryInfo::getVictoryDelayTurns
; Function compile flags: /Ogtpy
;	COMDAT ?getVictoryDelayTurns@CvVictoryInfo@@QBEHXZ
_TEXT	SEGMENT
?getVictoryDelayTurns@CvVictoryInfo@@QBEHXZ PROC	; CvVictoryInfo::getVictoryDelayTurns, COMDAT
; _this$ = ecx

; 2560 : 	return m_iVictoryDelayTurns;

	mov	eax, DWORD PTR [ecx+284]

; 2561 : }

	ret	0
?getVictoryDelayTurns@CvVictoryInfo@@QBEHXZ ENDP	; CvVictoryInfo::getVictoryDelayTurns
_TEXT	ENDS
PUBLIC	?IsWinsGame@CvVictoryInfo@@QBE_NXZ		; CvVictoryInfo::IsWinsGame
; Function compile flags: /Ogtpy
;	COMDAT ?IsWinsGame@CvVictoryInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsWinsGame@CvVictoryInfo@@QBE_NXZ PROC			; CvVictoryInfo::IsWinsGame, COMDAT
; _this$ = ecx

; 2565 : 	return m_bWinsGame;

	mov	al, BYTE PTR [ecx+288]

; 2566 : }

	ret	0
?IsWinsGame@CvVictoryInfo@@QBE_NXZ ENDP			; CvVictoryInfo::IsWinsGame
_TEXT	ENDS
PUBLIC	?isTargetScore@CvVictoryInfo@@QBE_NXZ		; CvVictoryInfo::isTargetScore
; Function compile flags: /Ogtpy
;	COMDAT ?isTargetScore@CvVictoryInfo@@QBE_NXZ
_TEXT	SEGMENT
?isTargetScore@CvVictoryInfo@@QBE_NXZ PROC		; CvVictoryInfo::isTargetScore, COMDAT
; _this$ = ecx

; 2570 : 	return m_bTargetScore;

	mov	al, BYTE PTR [ecx+289]

; 2571 : }

	ret	0
?isTargetScore@CvVictoryInfo@@QBE_NXZ ENDP		; CvVictoryInfo::isTargetScore
_TEXT	ENDS
PUBLIC	?isEndScore@CvVictoryInfo@@QBE_NXZ		; CvVictoryInfo::isEndScore
; Function compile flags: /Ogtpy
;	COMDAT ?isEndScore@CvVictoryInfo@@QBE_NXZ
_TEXT	SEGMENT
?isEndScore@CvVictoryInfo@@QBE_NXZ PROC			; CvVictoryInfo::isEndScore, COMDAT
; _this$ = ecx

; 2575 : 	return m_bEndScore;

	mov	al, BYTE PTR [ecx+290]

; 2576 : }

	ret	0
?isEndScore@CvVictoryInfo@@QBE_NXZ ENDP			; CvVictoryInfo::isEndScore
_TEXT	ENDS
PUBLIC	?isConquest@CvVictoryInfo@@QBE_NXZ		; CvVictoryInfo::isConquest
; Function compile flags: /Ogtpy
;	COMDAT ?isConquest@CvVictoryInfo@@QBE_NXZ
_TEXT	SEGMENT
?isConquest@CvVictoryInfo@@QBE_NXZ PROC			; CvVictoryInfo::isConquest, COMDAT
; _this$ = ecx

; 2580 : 	return m_bConquest;

	mov	al, BYTE PTR [ecx+291]

; 2581 : }

	ret	0
?isConquest@CvVictoryInfo@@QBE_NXZ ENDP			; CvVictoryInfo::isConquest
_TEXT	ENDS
PUBLIC	?isInfluential@CvVictoryInfo@@QBE_NXZ		; CvVictoryInfo::isInfluential
; Function compile flags: /Ogtpy
;	COMDAT ?isInfluential@CvVictoryInfo@@QBE_NXZ
_TEXT	SEGMENT
?isInfluential@CvVictoryInfo@@QBE_NXZ PROC		; CvVictoryInfo::isInfluential, COMDAT
; _this$ = ecx

; 2585 : 	return m_bInfluential;

	mov	al, BYTE PTR [ecx+292]

; 2586 : }

	ret	0
?isInfluential@CvVictoryInfo@@QBE_NXZ ENDP		; CvVictoryInfo::isInfluential
_TEXT	ENDS
PUBLIC	?isDiploVote@CvVictoryInfo@@QBE_NXZ		; CvVictoryInfo::isDiploVote
; Function compile flags: /Ogtpy
;	COMDAT ?isDiploVote@CvVictoryInfo@@QBE_NXZ
_TEXT	SEGMENT
?isDiploVote@CvVictoryInfo@@QBE_NXZ PROC		; CvVictoryInfo::isDiploVote, COMDAT
; _this$ = ecx

; 2590 : 	return m_bDiploVote;

	mov	al, BYTE PTR [ecx+293]

; 2591 : }

	ret	0
?isDiploVote@CvVictoryInfo@@QBE_NXZ ENDP		; CvVictoryInfo::isDiploVote
_TEXT	ENDS
PUBLIC	?isPermanent@CvVictoryInfo@@QBE_NXZ		; CvVictoryInfo::isPermanent
; Function compile flags: /Ogtpy
;	COMDAT ?isPermanent@CvVictoryInfo@@QBE_NXZ
_TEXT	SEGMENT
?isPermanent@CvVictoryInfo@@QBE_NXZ PROC		; CvVictoryInfo::isPermanent, COMDAT
; _this$ = ecx

; 2595 : 	return m_bPermanent;

	mov	al, BYTE PTR [ecx+294]

; 2596 : }

	ret	0
?isPermanent@CvVictoryInfo@@QBE_NXZ ENDP		; CvVictoryInfo::isPermanent
_TEXT	ENDS
PUBLIC	?IsReligionInAllCities@CvVictoryInfo@@QBE_NXZ	; CvVictoryInfo::IsReligionInAllCities
; Function compile flags: /Ogtpy
;	COMDAT ?IsReligionInAllCities@CvVictoryInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsReligionInAllCities@CvVictoryInfo@@QBE_NXZ PROC	; CvVictoryInfo::IsReligionInAllCities, COMDAT
; _this$ = ecx

; 2600 : 	return m_bReligionInAllCities;

	mov	al, BYTE PTR [ecx+295]

; 2601 : }

	ret	0
?IsReligionInAllCities@CvVictoryInfo@@QBE_NXZ ENDP	; CvVictoryInfo::IsReligionInAllCities
_TEXT	ENDS
PUBLIC	?IsFindAllNaturalWonders@CvVictoryInfo@@QBE_NXZ	; CvVictoryInfo::IsFindAllNaturalWonders
; Function compile flags: /Ogtpy
;	COMDAT ?IsFindAllNaturalWonders@CvVictoryInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsFindAllNaturalWonders@CvVictoryInfo@@QBE_NXZ PROC	; CvVictoryInfo::IsFindAllNaturalWonders, COMDAT
; _this$ = ecx

; 2605 : 	return m_bFindAllNaturalWonders;

	mov	al, BYTE PTR [ecx+296]

; 2606 : }

	ret	0
?IsFindAllNaturalWonders@CvVictoryInfo@@QBE_NXZ ENDP	; CvVictoryInfo::IsFindAllNaturalWonders
_TEXT	ENDS
PUBLIC	?getMovie@CvVictoryInfo@@QBEPBDXZ		; CvVictoryInfo::getMovie
; Function compile flags: /Ogtpy
;	COMDAT ?getMovie@CvVictoryInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getMovie@CvVictoryInfo@@QBEPBDXZ PROC			; CvVictoryInfo::getMovie, COMDAT
; _this$ = ecx

; 2610 : 	return m_strMovie.c_str();

	add	ecx, 300				; 0000012cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getMovie@CvVictoryInfo@@QBEPBDXZ ENDP			; CvVictoryInfo::getMovie
_TEXT	ENDS
PUBLIC	?GetVictoryPointAward@CvVictoryInfo@@QBEHH@Z	; CvVictoryInfo::GetVictoryPointAward
; Function compile flags: /Ogtpy
;	COMDAT ?GetVictoryPointAward@CvVictoryInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetVictoryPointAward@CvVictoryInfo@@QBEHH@Z PROC	; CvVictoryInfo::GetVictoryPointAward, COMDAT
; _this$ = ecx

; 2615 : 	return m_piVictoryPointAwards[i];

	mov	eax, DWORD PTR [ecx+328]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2616 : }

	ret	4
?GetVictoryPointAward@CvVictoryInfo@@QBEHH@Z ENDP	; CvVictoryInfo::GetVictoryPointAward
_TEXT	ENDS
PUBLIC	?GetNumVictoryPoints@CvSmallAwardInfo@@QBEHXZ	; CvSmallAwardInfo::GetNumVictoryPoints
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumVictoryPoints@CvSmallAwardInfo@@QBEHXZ
_TEXT	SEGMENT
?GetNumVictoryPoints@CvSmallAwardInfo@@QBEHXZ PROC	; CvSmallAwardInfo::GetNumVictoryPoints, COMDAT
; _this$ = ecx

; 2694 : 	return m_iNumVictoryPoints;

	mov	eax, DWORD PTR [ecx+316]

; 2695 : }

	ret	0
?GetNumVictoryPoints@CvSmallAwardInfo@@QBEHXZ ENDP	; CvSmallAwardInfo::GetNumVictoryPoints
_TEXT	ENDS
PUBLIC	?GetNumCities@CvSmallAwardInfo@@QBEHXZ		; CvSmallAwardInfo::GetNumCities
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCities@CvSmallAwardInfo@@QBEHXZ
_TEXT	SEGMENT
?GetNumCities@CvSmallAwardInfo@@QBEHXZ PROC		; CvSmallAwardInfo::GetNumCities, COMDAT
; _this$ = ecx

; 2709 : 	return m_iNumCities;

	mov	eax, DWORD PTR [ecx+320]

; 2710 : }

	ret	0
?GetNumCities@CvSmallAwardInfo@@QBEHXZ ENDP		; CvSmallAwardInfo::GetNumCities
_TEXT	ENDS
PUBLIC	?GetCityPopulation@CvSmallAwardInfo@@QBEHXZ	; CvSmallAwardInfo::GetCityPopulation
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityPopulation@CvSmallAwardInfo@@QBEHXZ
_TEXT	SEGMENT
?GetCityPopulation@CvSmallAwardInfo@@QBEHXZ PROC	; CvSmallAwardInfo::GetCityPopulation, COMDAT
; _this$ = ecx

; 2714 : 	return m_iCityPopulation;

	mov	eax, DWORD PTR [ecx+324]

; 2715 : }

	ret	0
?GetCityPopulation@CvSmallAwardInfo@@QBEHXZ ENDP	; CvSmallAwardInfo::GetCityPopulation
_TEXT	ENDS
PUBLIC	?getPolicyPrereq@CvHurryInfo@@QBEHXZ		; CvHurryInfo::getPolicyPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?getPolicyPrereq@CvHurryInfo@@QBEHXZ
_TEXT	SEGMENT
?getPolicyPrereq@CvHurryInfo@@QBEHXZ PROC		; CvHurryInfo::getPolicyPrereq, COMDAT
; _this$ = ecx

; 2747 : 	return m_iPolicyPrereq;

	mov	eax, DWORD PTR [ecx+260]

; 2748 : }

	ret	0
?getPolicyPrereq@CvHurryInfo@@QBEHXZ ENDP		; CvHurryInfo::getPolicyPrereq
_TEXT	ENDS
PUBLIC	?getGoldPerProduction@CvHurryInfo@@QBEHXZ	; CvHurryInfo::getGoldPerProduction
; Function compile flags: /Ogtpy
;	COMDAT ?getGoldPerProduction@CvHurryInfo@@QBEHXZ
_TEXT	SEGMENT
?getGoldPerProduction@CvHurryInfo@@QBEHXZ PROC		; CvHurryInfo::getGoldPerProduction, COMDAT
; _this$ = ecx

; 2752 : 	return m_iGoldPerProduction;

	mov	eax, DWORD PTR [ecx+264]

; 2753 : }

	ret	0
?getGoldPerProduction@CvHurryInfo@@QBEHXZ ENDP		; CvHurryInfo::getGoldPerProduction
_TEXT	ENDS
PUBLIC	?getProductionPerPopulation@CvHurryInfo@@QBEHXZ	; CvHurryInfo::getProductionPerPopulation
; Function compile flags: /Ogtpy
;	COMDAT ?getProductionPerPopulation@CvHurryInfo@@QBEHXZ
_TEXT	SEGMENT
?getProductionPerPopulation@CvHurryInfo@@QBEHXZ PROC	; CvHurryInfo::getProductionPerPopulation, COMDAT
; _this$ = ecx

; 2757 : 	return m_iProductionPerPopulation;

	mov	eax, DWORD PTR [ecx+268]

; 2758 : }

	ret	0
?getProductionPerPopulation@CvHurryInfo@@QBEHXZ ENDP	; CvHurryInfo::getProductionPerPopulation
_TEXT	ENDS
PUBLIC	?getGoldPerBeaker@CvHurryInfo@@QBEHXZ		; CvHurryInfo::getGoldPerBeaker
; Function compile flags: /Ogtpy
;	COMDAT ?getGoldPerBeaker@CvHurryInfo@@QBEHXZ
_TEXT	SEGMENT
?getGoldPerBeaker@CvHurryInfo@@QBEHXZ PROC		; CvHurryInfo::getGoldPerBeaker, COMDAT
; _this$ = ecx

; 2762 : 	return m_iGoldPerBeaker;

	mov	eax, DWORD PTR [ecx+272]

; 2763 : }

	ret	0
?getGoldPerBeaker@CvHurryInfo@@QBEHXZ ENDP		; CvHurryInfo::getGoldPerBeaker
_TEXT	ENDS
PUBLIC	?getGoldPerCulture@CvHurryInfo@@QBEHXZ		; CvHurryInfo::getGoldPerCulture
; Function compile flags: /Ogtpy
;	COMDAT ?getGoldPerCulture@CvHurryInfo@@QBEHXZ
_TEXT	SEGMENT
?getGoldPerCulture@CvHurryInfo@@QBEHXZ PROC		; CvHurryInfo::getGoldPerCulture, COMDAT
; _this$ = ecx

; 2767 : 	return m_iGoldPerCulture;

	mov	eax, DWORD PTR [ecx+276]

; 2768 : }

	ret	0
?getGoldPerCulture@CvHurryInfo@@QBEHXZ ENDP		; CvHurryInfo::getGoldPerCulture
_TEXT	ENDS
PUBLIC	?getStartingLocationPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getStartingLocationPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getStartingLocationPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartingLocationPercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getStartingLocationPercent, COMDAT
; _this$ = ecx

; 2866 : 	return m_iStartingLocationPercent;

	mov	eax, DWORD PTR [ecx+260]

; 2867 : }

	ret	0
?getStartingLocationPercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getStartingLocationPercent
_TEXT	ENDS
PUBLIC	?getAdvancedStartPointsMod@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAdvancedStartPointsMod
; Function compile flags: /Ogtpy
;	COMDAT ?getAdvancedStartPointsMod@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAdvancedStartPointsMod@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAdvancedStartPointsMod, COMDAT
; _this$ = ecx

; 2871 : 	return m_iAdvancedStartPointsMod;

	mov	eax, DWORD PTR [ecx+264]

; 2872 : }

	ret	0
?getAdvancedStartPointsMod@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAdvancedStartPointsMod
_TEXT	ENDS
PUBLIC	?getStartingPolicyPoints@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getStartingPolicyPoints
; Function compile flags: /Ogtpy
;	COMDAT ?getStartingPolicyPoints@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartingPolicyPoints@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getStartingPolicyPoints, COMDAT
; _this$ = ecx

; 2876 : 	return m_iStartingPolicyPoints;

	mov	eax, DWORD PTR [ecx+268]

; 2877 : }

	ret	0
?getStartingPolicyPoints@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getStartingPolicyPoints
_TEXT	ENDS
PUBLIC	?getHappinessDefault@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getHappinessDefault
; Function compile flags: /Ogtpy
;	COMDAT ?getHappinessDefault@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getHappinessDefault@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getHappinessDefault, COMDAT
; _this$ = ecx

; 2881 : 	return m_iHappinessDefault;

	mov	eax, DWORD PTR [ecx+272]

; 2882 : }

	ret	0
?getHappinessDefault@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getHappinessDefault
_TEXT	ENDS
PUBLIC	?getExtraHappinessPerLuxury@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getExtraHappinessPerLuxury
; Function compile flags: /Ogtpy
;	COMDAT ?getExtraHappinessPerLuxury@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getExtraHappinessPerLuxury@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getExtraHappinessPerLuxury, COMDAT
; _this$ = ecx

; 2886 : 	return m_iExtraHappinessPerLuxury;

	mov	eax, DWORD PTR [ecx+276]

; 2887 : }

	ret	0
?getExtraHappinessPerLuxury@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getExtraHappinessPerLuxury
_TEXT	ENDS
PUBLIC	?getNumCitiesUnhappinessMod@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getNumCitiesUnhappinessMod
; Function compile flags: /Ogtpy
;	COMDAT ?getNumCitiesUnhappinessMod@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getNumCitiesUnhappinessMod@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getNumCitiesUnhappinessMod, COMDAT
; _this$ = ecx

; 2891 : 	return m_iNumCitiesUnhappinessMod;

	mov	eax, DWORD PTR [ecx+280]

; 2892 : }

	ret	0
?getNumCitiesUnhappinessMod@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getNumCitiesUnhappinessMod
_TEXT	ENDS
PUBLIC	?getPopulationUnhappinessMod@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getPopulationUnhappinessMod
; Function compile flags: /Ogtpy
;	COMDAT ?getPopulationUnhappinessMod@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getPopulationUnhappinessMod@CvHandicapInfo@@QBEHXZ PROC ; CvHandicapInfo::getPopulationUnhappinessMod, COMDAT
; _this$ = ecx

; 2896 : 	return m_iPopulationUnhappinessMod;

	mov	eax, DWORD PTR [ecx+284]

; 2897 : }

	ret	0
?getPopulationUnhappinessMod@CvHandicapInfo@@QBEHXZ ENDP ; CvHandicapInfo::getPopulationUnhappinessMod
_TEXT	ENDS
PUBLIC	?getStartingGold@CvHandicapInfo@@QBEHXZ		; CvHandicapInfo::getStartingGold
; Function compile flags: /Ogtpy
;	COMDAT ?getStartingGold@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartingGold@CvHandicapInfo@@QBEHXZ PROC		; CvHandicapInfo::getStartingGold, COMDAT
; _this$ = ecx

; 2901 : 	return m_iStartingGold;

	mov	eax, DWORD PTR [ecx+288]

; 2902 : }

	ret	0
?getStartingGold@CvHandicapInfo@@QBEHXZ ENDP		; CvHandicapInfo::getStartingGold
_TEXT	ENDS
PUBLIC	?getGoldFreeUnits@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getGoldFreeUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getGoldFreeUnits@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getGoldFreeUnits@CvHandicapInfo@@QBEHXZ PROC		; CvHandicapInfo::getGoldFreeUnits, COMDAT
; _this$ = ecx

; 2906 : 	return m_iGoldFreeUnits;

	mov	eax, DWORD PTR [ecx+292]

; 2907 : }

	ret	0
?getGoldFreeUnits@CvHandicapInfo@@QBEHXZ ENDP		; CvHandicapInfo::getGoldFreeUnits
_TEXT	ENDS
PUBLIC	?getProductionFreeUnits@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getProductionFreeUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getProductionFreeUnits@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getProductionFreeUnits@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getProductionFreeUnits, COMDAT
; _this$ = ecx

; 2911 : 	return m_iProductionFreeUnits;

	mov	eax, DWORD PTR [ecx+296]

; 2912 : }

	ret	0
?getProductionFreeUnits@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getProductionFreeUnits
_TEXT	ENDS
PUBLIC	?getProductionFreeUnitsPerCity@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getProductionFreeUnitsPerCity
; Function compile flags: /Ogtpy
;	COMDAT ?getProductionFreeUnitsPerCity@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getProductionFreeUnitsPerCity@CvHandicapInfo@@QBEHXZ PROC ; CvHandicapInfo::getProductionFreeUnitsPerCity, COMDAT
; _this$ = ecx

; 2916 : 	return m_iProductionFreeUnitsPerCity;

	mov	eax, DWORD PTR [ecx+300]

; 2917 : }

	ret	0
?getProductionFreeUnitsPerCity@CvHandicapInfo@@QBEHXZ ENDP ; CvHandicapInfo::getProductionFreeUnitsPerCity
_TEXT	ENDS
PUBLIC	?getProductionFreeUnitsPopulationPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getProductionFreeUnitsPopulationPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getProductionFreeUnitsPopulationPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getProductionFreeUnitsPopulationPercent@CvHandicapInfo@@QBEHXZ PROC ; CvHandicapInfo::getProductionFreeUnitsPopulationPercent, COMDAT
; _this$ = ecx

; 2921 : 	return m_iProductionFreeUnitsPopulationPercent;

	mov	eax, DWORD PTR [ecx+304]

; 2922 : }

	ret	0
?getProductionFreeUnitsPopulationPercent@CvHandicapInfo@@QBEHXZ ENDP ; CvHandicapInfo::getProductionFreeUnitsPopulationPercent
_TEXT	ENDS
PUBLIC	?getUnitCostPercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getUnitCostPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitCostPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getUnitCostPercent@CvHandicapInfo@@QBEHXZ PROC		; CvHandicapInfo::getUnitCostPercent, COMDAT
; _this$ = ecx

; 2926 : 	return m_iUnitCostPercent;

	mov	eax, DWORD PTR [ecx+312]

; 2927 : }

	ret	0
?getUnitCostPercent@CvHandicapInfo@@QBEHXZ ENDP		; CvHandicapInfo::getUnitCostPercent
_TEXT	ENDS
PUBLIC	?getRouteCostPercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getRouteCostPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getRouteCostPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getRouteCostPercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getRouteCostPercent, COMDAT
; _this$ = ecx

; 2931 : 	return m_iRouteCostPercent;

	mov	eax, DWORD PTR [ecx+308]

; 2932 : }

	ret	0
?getRouteCostPercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getRouteCostPercent
_TEXT	ENDS
PUBLIC	?getBuildingCostPercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getBuildingCostPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildingCostPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getBuildingCostPercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getBuildingCostPercent, COMDAT
; _this$ = ecx

; 2936 : 	return m_iBuildingCostPercent;

	mov	eax, DWORD PTR [ecx+316]

; 2937 : }

	ret	0
?getBuildingCostPercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getBuildingCostPercent
_TEXT	ENDS
PUBLIC	?getResearchPercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getResearchPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getResearchPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getResearchPercent@CvHandicapInfo@@QBEHXZ PROC		; CvHandicapInfo::getResearchPercent, COMDAT
; _this$ = ecx

; 2941 : 	return m_iResearchPercent;

	mov	eax, DWORD PTR [ecx+320]

; 2942 : }

	ret	0
?getResearchPercent@CvHandicapInfo@@QBEHXZ ENDP		; CvHandicapInfo::getResearchPercent
_TEXT	ENDS
PUBLIC	?getPolicyPercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getPolicyPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getPolicyPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getPolicyPercent@CvHandicapInfo@@QBEHXZ PROC		; CvHandicapInfo::getPolicyPercent, COMDAT
; _this$ = ecx

; 2946 : 	return m_iPolicyPercent;

	mov	eax, DWORD PTR [ecx+324]

; 2947 : }

	ret	0
?getPolicyPercent@CvHandicapInfo@@QBEHXZ ENDP		; CvHandicapInfo::getPolicyPercent
_TEXT	ENDS
PUBLIC	?getImprovementCostPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getImprovementCostPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getImprovementCostPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getImprovementCostPercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getImprovementCostPercent, COMDAT
; _this$ = ecx

; 2951 : 	return m_iImprovementCostPercent;

	mov	eax, DWORD PTR [ecx+328]

; 2952 : }

	ret	0
?getImprovementCostPercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getImprovementCostPercent
_TEXT	ENDS
PUBLIC	?GetCityProductionNumOptions@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::GetCityProductionNumOptions
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityProductionNumOptions@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?GetCityProductionNumOptions@CvHandicapInfo@@QBEHXZ PROC ; CvHandicapInfo::GetCityProductionNumOptions, COMDAT
; _this$ = ecx

; 2956 : 	return m_iCityProductionNumOptions;

	mov	eax, DWORD PTR [ecx+332]

; 2957 : }

	ret	0
?GetCityProductionNumOptions@CvHandicapInfo@@QBEHXZ ENDP ; CvHandicapInfo::GetCityProductionNumOptions
_TEXT	ENDS
PUBLIC	?GetTechNumOptions@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::GetTechNumOptions
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechNumOptions@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?GetTechNumOptions@CvHandicapInfo@@QBEHXZ PROC		; CvHandicapInfo::GetTechNumOptions, COMDAT
; _this$ = ecx

; 2961 : 	return m_iTechNumOptions;

	mov	eax, DWORD PTR [ecx+336]

; 2962 : }

	ret	0
?GetTechNumOptions@CvHandicapInfo@@QBEHXZ ENDP		; CvHandicapInfo::GetTechNumOptions
_TEXT	ENDS
PUBLIC	?GetPolicyNumOptions@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::GetPolicyNumOptions
; Function compile flags: /Ogtpy
;	COMDAT ?GetPolicyNumOptions@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?GetPolicyNumOptions@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::GetPolicyNumOptions, COMDAT
; _this$ = ecx

; 2966 : 	return m_iPolicyNumOptions;

	mov	eax, DWORD PTR [ecx+340]

; 2967 : }

	ret	0
?GetPolicyNumOptions@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::GetPolicyNumOptions
_TEXT	ENDS
PUBLIC	?getInflationPercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getInflationPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getInflationPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getInflationPercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getInflationPercent, COMDAT
; _this$ = ecx

; 2971 : 	return m_iInflationPercent;

	mov	eax, DWORD PTR [ecx+344]

; 2972 : }

	ret	0
?getInflationPercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getInflationPercent
_TEXT	ENDS
PUBLIC	?getFreeCulturePerTurn@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getFreeCulturePerTurn
; Function compile flags: /Ogtpy
;	COMDAT ?getFreeCulturePerTurn@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getFreeCulturePerTurn@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getFreeCulturePerTurn, COMDAT
; _this$ = ecx

; 2976 : 	return m_iFreeCulturePerTurn;

	mov	eax, DWORD PTR [ecx+348]

; 2977 : }

	ret	0
?getFreeCulturePerTurn@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getFreeCulturePerTurn
_TEXT	ENDS
PUBLIC	?getAttitudeChange@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAttitudeChange
; Function compile flags: /Ogtpy
;	COMDAT ?getAttitudeChange@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAttitudeChange@CvHandicapInfo@@QBEHXZ PROC		; CvHandicapInfo::getAttitudeChange, COMDAT
; _this$ = ecx

; 2981 : 	return m_iAttitudeChange;

	mov	eax, DWORD PTR [ecx+352]

; 2982 : }

	ret	0
?getAttitudeChange@CvHandicapInfo@@QBEHXZ ENDP		; CvHandicapInfo::getAttitudeChange
_TEXT	ENDS
PUBLIC	?getNoTechTradeModifier@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getNoTechTradeModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getNoTechTradeModifier@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getNoTechTradeModifier@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getNoTechTradeModifier, COMDAT
; _this$ = ecx

; 2986 : 	return m_iNoTechTradeModifier;

	mov	eax, DWORD PTR [ecx+356]

; 2987 : }

	ret	0
?getNoTechTradeModifier@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getNoTechTradeModifier
_TEXT	ENDS
PUBLIC	?getTechTradeKnownModifier@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getTechTradeKnownModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getTechTradeKnownModifier@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getTechTradeKnownModifier@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getTechTradeKnownModifier, COMDAT
; _this$ = ecx

; 2991 : 	return m_iTechTradeKnownModifier;

	mov	eax, DWORD PTR [ecx+360]

; 2992 : }

	ret	0
?getTechTradeKnownModifier@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getTechTradeKnownModifier
_TEXT	ENDS
PUBLIC	?getBarbCampGold@CvHandicapInfo@@QBEHXZ		; CvHandicapInfo::getBarbCampGold
; Function compile flags: /Ogtpy
;	COMDAT ?getBarbCampGold@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getBarbCampGold@CvHandicapInfo@@QBEHXZ PROC		; CvHandicapInfo::getBarbCampGold, COMDAT
; _this$ = ecx

; 2996 : 	return m_iBarbCampGold;

	mov	eax, DWORD PTR [ecx+364]

; 2997 : }

	ret	0
?getBarbCampGold@CvHandicapInfo@@QBEHXZ ENDP		; CvHandicapInfo::getBarbCampGold
_TEXT	ENDS
PUBLIC	?getBarbSpawnMod@CvHandicapInfo@@QBEHXZ		; CvHandicapInfo::getBarbSpawnMod
; Function compile flags: /Ogtpy
;	COMDAT ?getBarbSpawnMod@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getBarbSpawnMod@CvHandicapInfo@@QBEHXZ PROC		; CvHandicapInfo::getBarbSpawnMod, COMDAT
; _this$ = ecx

; 3001 : 	return m_iBarbSpawnMod;

	mov	eax, DWORD PTR [ecx+368]

; 3002 : }

	ret	0
?getBarbSpawnMod@CvHandicapInfo@@QBEHXZ ENDP		; CvHandicapInfo::getBarbSpawnMod
_TEXT	ENDS
PUBLIC	?getBarbarianCombatModifier@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getBarbarianCombatModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getBarbarianCombatModifier@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getBarbarianCombatModifier@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getBarbarianCombatModifier, COMDAT
; _this$ = ecx

; 3006 : 	return m_iBarbarianCombatModifier;

	mov	eax, DWORD PTR [ecx+372]

; 3007 : }

	ret	0
?getBarbarianCombatModifier@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getBarbarianCombatModifier
_TEXT	ENDS
PUBLIC	?getAIBarbarianCombatModifier@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIBarbarianCombatModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getAIBarbarianCombatModifier@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIBarbarianCombatModifier@CvHandicapInfo@@QBEHXZ PROC ; CvHandicapInfo::getAIBarbarianCombatModifier, COMDAT
; _this$ = ecx

; 3011 : 	return m_iAIBarbarianCombatModifier;

	mov	eax, DWORD PTR [ecx+376]

; 3012 : }

	ret	0
?getAIBarbarianCombatModifier@CvHandicapInfo@@QBEHXZ ENDP ; CvHandicapInfo::getAIBarbarianCombatModifier
_TEXT	ENDS
PUBLIC	?getEarliestBarbarianReleaseTurn@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getEarliestBarbarianReleaseTurn
; Function compile flags: /Ogtpy
;	COMDAT ?getEarliestBarbarianReleaseTurn@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getEarliestBarbarianReleaseTurn@CvHandicapInfo@@QBEHXZ PROC ; CvHandicapInfo::getEarliestBarbarianReleaseTurn, COMDAT
; _this$ = ecx

; 3016 : 	return m_iEarliestBarbarianReleaseTurn;

	mov	eax, DWORD PTR [ecx+380]

; 3017 : }

	ret	0
?getEarliestBarbarianReleaseTurn@CvHandicapInfo@@QBEHXZ ENDP ; CvHandicapInfo::getEarliestBarbarianReleaseTurn
_TEXT	ENDS
PUBLIC	?getBarbarianLandTargetRange@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getBarbarianLandTargetRange
; Function compile flags: /Ogtpy
;	COMDAT ?getBarbarianLandTargetRange@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getBarbarianLandTargetRange@CvHandicapInfo@@QBEHXZ PROC ; CvHandicapInfo::getBarbarianLandTargetRange, COMDAT
; _this$ = ecx

; 3021 : 	return m_iBarbarianLandTargetRange;

	mov	eax, DWORD PTR [ecx+384]

; 3022 : }

	ret	0
?getBarbarianLandTargetRange@CvHandicapInfo@@QBEHXZ ENDP ; CvHandicapInfo::getBarbarianLandTargetRange
_TEXT	ENDS
PUBLIC	?getBarbarianSeaTargetRange@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getBarbarianSeaTargetRange
; Function compile flags: /Ogtpy
;	COMDAT ?getBarbarianSeaTargetRange@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getBarbarianSeaTargetRange@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getBarbarianSeaTargetRange, COMDAT
; _this$ = ecx

; 3026 : 	return m_iBarbarianSeaTargetRange;

	mov	eax, DWORD PTR [ecx+388]

; 3027 : }

	ret	0
?getBarbarianSeaTargetRange@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getBarbarianSeaTargetRange
_TEXT	ENDS
PUBLIC	?getStartingDefenseUnits@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getStartingDefenseUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getStartingDefenseUnits@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartingDefenseUnits@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getStartingDefenseUnits, COMDAT
; _this$ = ecx

; 3031 : 	return m_iStartingDefenseUnits;

	mov	eax, DWORD PTR [ecx+392]

; 3032 : }

	ret	0
?getStartingDefenseUnits@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getStartingDefenseUnits
_TEXT	ENDS
PUBLIC	?getStartingWorkerUnits@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getStartingWorkerUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getStartingWorkerUnits@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartingWorkerUnits@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getStartingWorkerUnits, COMDAT
; _this$ = ecx

; 3036 : 	return m_iStartingWorkerUnits;

	mov	eax, DWORD PTR [ecx+396]

; 3037 : }

	ret	0
?getStartingWorkerUnits@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getStartingWorkerUnits
_TEXT	ENDS
PUBLIC	?getStartingExploreUnits@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getStartingExploreUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getStartingExploreUnits@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartingExploreUnits@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getStartingExploreUnits, COMDAT
; _this$ = ecx

; 3041 : 	return m_iStartingExploreUnits;

	mov	eax, DWORD PTR [ecx+400]

; 3042 : }

	ret	0
?getStartingExploreUnits@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getStartingExploreUnits
_TEXT	ENDS
PUBLIC	?getAIStartingUnitMultiplier@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIStartingUnitMultiplier
; Function compile flags: /Ogtpy
;	COMDAT ?getAIStartingUnitMultiplier@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIStartingUnitMultiplier@CvHandicapInfo@@QBEHXZ PROC ; CvHandicapInfo::getAIStartingUnitMultiplier, COMDAT
; _this$ = ecx

; 3046 : 	return m_iAIStartingUnitMultiplier;

	mov	eax, DWORD PTR [ecx+404]

; 3047 : }

	ret	0
?getAIStartingUnitMultiplier@CvHandicapInfo@@QBEHXZ ENDP ; CvHandicapInfo::getAIStartingUnitMultiplier
_TEXT	ENDS
PUBLIC	?getAIStartingDefenseUnits@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIStartingDefenseUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getAIStartingDefenseUnits@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIStartingDefenseUnits@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIStartingDefenseUnits, COMDAT
; _this$ = ecx

; 3051 : 	return m_iAIStartingDefenseUnits;

	mov	eax, DWORD PTR [ecx+408]

; 3052 : }

	ret	0
?getAIStartingDefenseUnits@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIStartingDefenseUnits
_TEXT	ENDS
PUBLIC	?getAIStartingWorkerUnits@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIStartingWorkerUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getAIStartingWorkerUnits@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIStartingWorkerUnits@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIStartingWorkerUnits, COMDAT
; _this$ = ecx

; 3056 : 	return m_iAIStartingWorkerUnits;

	mov	eax, DWORD PTR [ecx+412]

; 3057 : }

	ret	0
?getAIStartingWorkerUnits@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIStartingWorkerUnits
_TEXT	ENDS
PUBLIC	?getAIStartingExploreUnits@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIStartingExploreUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getAIStartingExploreUnits@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIStartingExploreUnits@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIStartingExploreUnits, COMDAT
; _this$ = ecx

; 3061 : 	return m_iAIStartingExploreUnits;

	mov	eax, DWORD PTR [ecx+416]

; 3062 : }

	ret	0
?getAIStartingExploreUnits@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIStartingExploreUnits
_TEXT	ENDS
PUBLIC	?getAIDeclareWarProb@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAIDeclareWarProb
; Function compile flags: /Ogtpy
;	COMDAT ?getAIDeclareWarProb@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIDeclareWarProb@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIDeclareWarProb, COMDAT
; _this$ = ecx

; 3066 : 	return m_iAIDeclareWarProb;

	mov	eax, DWORD PTR [ecx+420]

; 3067 : }

	ret	0
?getAIDeclareWarProb@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIDeclareWarProb
_TEXT	ENDS
PUBLIC	?getAIWorkRateModifier@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAIWorkRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getAIWorkRateModifier@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIWorkRateModifier@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIWorkRateModifier, COMDAT
; _this$ = ecx

; 3071 : 	return m_iAIWorkRateModifier;

	mov	eax, DWORD PTR [ecx+424]

; 3072 : }

	ret	0
?getAIWorkRateModifier@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIWorkRateModifier
_TEXT	ENDS
PUBLIC	?getAIUnhappinessPercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAIUnhappinessPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAIUnhappinessPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIUnhappinessPercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIUnhappinessPercent, COMDAT
; _this$ = ecx

; 3076 : 	return m_iAIUnhappinessPercent;

	mov	eax, DWORD PTR [ecx+428]

; 3077 : }

	ret	0
?getAIUnhappinessPercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIUnhappinessPercent
_TEXT	ENDS
PUBLIC	?getAIGrowthPercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAIGrowthPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAIGrowthPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIGrowthPercent@CvHandicapInfo@@QBEHXZ PROC		; CvHandicapInfo::getAIGrowthPercent, COMDAT
; _this$ = ecx

; 3081 : 	return m_iAIGrowthPercent;

	mov	eax, DWORD PTR [ecx+432]

; 3082 : }

	ret	0
?getAIGrowthPercent@CvHandicapInfo@@QBEHXZ ENDP		; CvHandicapInfo::getAIGrowthPercent
_TEXT	ENDS
PUBLIC	?getAITrainPercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAITrainPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAITrainPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAITrainPercent@CvHandicapInfo@@QBEHXZ PROC		; CvHandicapInfo::getAITrainPercent, COMDAT
; _this$ = ecx

; 3086 : 	return m_iAITrainPercent;

	mov	eax, DWORD PTR [ecx+436]

; 3087 : }

	ret	0
?getAITrainPercent@CvHandicapInfo@@QBEHXZ ENDP		; CvHandicapInfo::getAITrainPercent
_TEXT	ENDS
PUBLIC	?getAIWorldTrainPercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAIWorldTrainPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAIWorldTrainPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIWorldTrainPercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIWorldTrainPercent, COMDAT
; _this$ = ecx

; 3091 : 	return m_iAIWorldTrainPercent;

	mov	eax, DWORD PTR [ecx+440]

; 3092 : }

	ret	0
?getAIWorldTrainPercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIWorldTrainPercent
_TEXT	ENDS
PUBLIC	?getAIConstructPercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAIConstructPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAIConstructPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIConstructPercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIConstructPercent, COMDAT
; _this$ = ecx

; 3096 : 	return m_iAIConstructPercent;

	mov	eax, DWORD PTR [ecx+444]

; 3097 : }

	ret	0
?getAIConstructPercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIConstructPercent
_TEXT	ENDS
PUBLIC	?getAIWorldConstructPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIWorldConstructPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAIWorldConstructPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIWorldConstructPercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIWorldConstructPercent, COMDAT
; _this$ = ecx

; 3101 : 	return m_iAIWorldConstructPercent;

	mov	eax, DWORD PTR [ecx+448]

; 3102 : }

	ret	0
?getAIWorldConstructPercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIWorldConstructPercent
_TEXT	ENDS
PUBLIC	?getAICreatePercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAICreatePercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAICreatePercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAICreatePercent@CvHandicapInfo@@QBEHXZ PROC		; CvHandicapInfo::getAICreatePercent, COMDAT
; _this$ = ecx

; 3106 : 	return m_iAICreatePercent;

	mov	eax, DWORD PTR [ecx+452]

; 3107 : }

	ret	0
?getAICreatePercent@CvHandicapInfo@@QBEHXZ ENDP		; CvHandicapInfo::getAICreatePercent
_TEXT	ENDS
PUBLIC	?getAIWorldCreatePercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAIWorldCreatePercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAIWorldCreatePercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIWorldCreatePercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIWorldCreatePercent, COMDAT
; _this$ = ecx

; 3111 : 	return m_iAIWorldCreatePercent;

	mov	eax, DWORD PTR [ecx+456]

; 3112 : }

	ret	0
?getAIWorldCreatePercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIWorldCreatePercent
_TEXT	ENDS
PUBLIC	?getAIBuildingCostPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIBuildingCostPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAIBuildingCostPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIBuildingCostPercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIBuildingCostPercent, COMDAT
; _this$ = ecx

; 3116 : 	return m_iAIBuildingCostPercent;

	mov	eax, DWORD PTR [ecx+460]

; 3117 : }

	ret	0
?getAIBuildingCostPercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIBuildingCostPercent
_TEXT	ENDS
PUBLIC	?getAIUnitCostPercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAIUnitCostPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAIUnitCostPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIUnitCostPercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIUnitCostPercent, COMDAT
; _this$ = ecx

; 3121 : 	return m_iAIUnitCostPercent;

	mov	eax, DWORD PTR [ecx+464]

; 3122 : }

	ret	0
?getAIUnitCostPercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIUnitCostPercent
_TEXT	ENDS
PUBLIC	?getAIUnitSupplyPercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAIUnitSupplyPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAIUnitSupplyPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIUnitSupplyPercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIUnitSupplyPercent, COMDAT
; _this$ = ecx

; 3126 : 	return m_iAIUnitSupplyPercent;

	mov	eax, DWORD PTR [ecx+468]

; 3127 : }

	ret	0
?getAIUnitSupplyPercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIUnitSupplyPercent
_TEXT	ENDS
PUBLIC	?getAIUnitUpgradePercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAIUnitUpgradePercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAIUnitUpgradePercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIUnitUpgradePercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIUnitUpgradePercent, COMDAT
; _this$ = ecx

; 3131 : 	return m_iAIUnitUpgradePercent;

	mov	eax, DWORD PTR [ecx+472]

; 3132 : }

	ret	0
?getAIUnitUpgradePercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIUnitUpgradePercent
_TEXT	ENDS
PUBLIC	?getAIInflationPercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAIInflationPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAIInflationPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIInflationPercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIInflationPercent, COMDAT
; _this$ = ecx

; 3136 : 	return m_iAIInflationPercent;

	mov	eax, DWORD PTR [ecx+476]

; 3137 : }

	ret	0
?getAIInflationPercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIInflationPercent
_TEXT	ENDS
PUBLIC	?getAIPerEraModifier@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAIPerEraModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getAIPerEraModifier@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIPerEraModifier@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIPerEraModifier, COMDAT
; _this$ = ecx

; 3141 : 	return m_iAIPerEraModifier;

	mov	eax, DWORD PTR [ecx+480]

; 3142 : }

	ret	0
?getAIPerEraModifier@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIPerEraModifier
_TEXT	ENDS
PUBLIC	?getAIAdvancedStartPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIAdvancedStartPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAIAdvancedStartPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIAdvancedStartPercent@CvHandicapInfo@@QBEHXZ PROC	; CvHandicapInfo::getAIAdvancedStartPercent, COMDAT
; _this$ = ecx

; 3146 : 	return m_iAIAdvancedStartPercent;

	mov	eax, DWORD PTR [ecx+484]

; 3147 : }

	ret	0
?getAIAdvancedStartPercent@CvHandicapInfo@@QBEHXZ ENDP	; CvHandicapInfo::getAIAdvancedStartPercent
_TEXT	ENDS
PUBLIC	?getAIFreeXP@CvHandicapInfo@@QBEHXZ		; CvHandicapInfo::getAIFreeXP
; Function compile flags: /Ogtpy
;	COMDAT ?getAIFreeXP@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIFreeXP@CvHandicapInfo@@QBEHXZ PROC		; CvHandicapInfo::getAIFreeXP, COMDAT
; _this$ = ecx

; 3151 : 	return m_iAIFreeXP;

	mov	eax, DWORD PTR [ecx+488]

; 3152 : }

	ret	0
?getAIFreeXP@CvHandicapInfo@@QBEHXZ ENDP		; CvHandicapInfo::getAIFreeXP
_TEXT	ENDS
PUBLIC	?getAIFreeXPPercent@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getAIFreeXPPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAIFreeXPPercent@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIFreeXPPercent@CvHandicapInfo@@QBEHXZ PROC		; CvHandicapInfo::getAIFreeXPPercent, COMDAT
; _this$ = ecx

; 3156 : 	return m_iAIFreeXPPercent;

	mov	eax, DWORD PTR [ecx+492]

; 3157 : }

	ret	0
?getAIFreeXPPercent@CvHandicapInfo@@QBEHXZ ENDP		; CvHandicapInfo::getAIFreeXPPercent
_TEXT	ENDS
PUBLIC	?getNumGoodies@CvHandicapInfo@@QBEHXZ		; CvHandicapInfo::getNumGoodies
; Function compile flags: /Ogtpy
;	COMDAT ?getNumGoodies@CvHandicapInfo@@QBEHXZ
_TEXT	SEGMENT
?getNumGoodies@CvHandicapInfo@@QBEHXZ PROC		; CvHandicapInfo::getNumGoodies, COMDAT
; _this$ = ecx

; 3161 : 	return m_iNumGoodies;

	mov	eax, DWORD PTR [ecx+496]

; 3162 : }

	ret	0
?getNumGoodies@CvHandicapInfo@@QBEHXZ ENDP		; CvHandicapInfo::getNumGoodies
_TEXT	ENDS
PUBLIC	?getGoodies@CvHandicapInfo@@QBEHH@Z		; CvHandicapInfo::getGoodies
; Function compile flags: /Ogtpy
;	COMDAT ?getGoodies@CvHandicapInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getGoodies@CvHandicapInfo@@QBEHH@Z PROC		; CvHandicapInfo::getGoodies, COMDAT
; _this$ = ecx

; 3166 : 	CvAssertMsg(i < getNumGoodies(), "Index out of bounds");
; 3167 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3168 : 	return m_piGoodies[i];

	mov	eax, DWORD PTR [ecx+528]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3169 : }

	ret	4
?getGoodies@CvHandicapInfo@@QBEHH@Z ENDP		; CvHandicapInfo::getGoodies
_TEXT	ENDS
PUBLIC	?isFreeTechs@CvHandicapInfo@@QBEHH@Z		; CvHandicapInfo::isFreeTechs
; Function compile flags: /Ogtpy
;	COMDAT ?isFreeTechs@CvHandicapInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?isFreeTechs@CvHandicapInfo@@QBEHH@Z PROC		; CvHandicapInfo::isFreeTechs, COMDAT
; _this$ = ecx

; 3173 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 3174 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3175 : 	return m_pbFreeTechs[i];

	mov	eax, DWORD PTR [ecx+532]
	mov	ecx, DWORD PTR _i$[esp-4]
	movzx	eax, BYTE PTR [eax+ecx]

; 3176 : }

	ret	4
?isFreeTechs@CvHandicapInfo@@QBEHH@Z ENDP		; CvHandicapInfo::isFreeTechs
_TEXT	ENDS
PUBLIC	?isAIFreeTechs@CvHandicapInfo@@QBEHH@Z		; CvHandicapInfo::isAIFreeTechs
; Function compile flags: /Ogtpy
;	COMDAT ?isAIFreeTechs@CvHandicapInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?isAIFreeTechs@CvHandicapInfo@@QBEHH@Z PROC		; CvHandicapInfo::isAIFreeTechs, COMDAT
; _this$ = ecx

; 3180 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 3181 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3182 : 	return m_pbAIFreeTechs[i];

	mov	eax, DWORD PTR [ecx+536]
	mov	ecx, DWORD PTR _i$[esp-4]
	movzx	eax, BYTE PTR [eax+ecx]

; 3183 : }

	ret	4
?isAIFreeTechs@CvHandicapInfo@@QBEHH@Z ENDP		; CvHandicapInfo::isAIFreeTechs
_TEXT	ENDS
PUBLIC	??1SingleResult@Database@@UAE@XZ		; Database::SingleResult::~SingleResult
EXTRN	__imp_??1Results@Database@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1SingleResult@Database@@UAE@XZ
_TEXT	SEGMENT
??1SingleResult@Database@@UAE@XZ PROC			; Database::SingleResult::~SingleResult, COMDAT
; _this$ = ecx
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
??1SingleResult@Database@@UAE@XZ ENDP			; Database::SingleResult::~SingleResult
_TEXT	ENDS
PUBLIC	?GetDealDuration@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::GetDealDuration
; Function compile flags: /Ogtpy
;	COMDAT ?GetDealDuration@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?GetDealDuration@CvGameSpeedInfo@@QBEHXZ PROC		; CvGameSpeedInfo::GetDealDuration, COMDAT
; _this$ = ecx

; 3336 : 	return m_iDealDuration;

	mov	eax, DWORD PTR [ecx+260]

; 3337 : }

	ret	0
?GetDealDuration@CvGameSpeedInfo@@QBEHXZ ENDP		; CvGameSpeedInfo::GetDealDuration
_TEXT	ENDS
PUBLIC	?getGrowthPercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getGrowthPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getGrowthPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getGrowthPercent@CvGameSpeedInfo@@QBEHXZ PROC		; CvGameSpeedInfo::getGrowthPercent, COMDAT
; _this$ = ecx

; 3341 : 	return m_iGrowthPercent;

	mov	eax, DWORD PTR [ecx+264]

; 3342 : }

	ret	0
?getGrowthPercent@CvGameSpeedInfo@@QBEHXZ ENDP		; CvGameSpeedInfo::getGrowthPercent
_TEXT	ENDS
PUBLIC	?getTrainPercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getTrainPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getTrainPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getTrainPercent@CvGameSpeedInfo@@QBEHXZ PROC		; CvGameSpeedInfo::getTrainPercent, COMDAT
; _this$ = ecx

; 3346 : 	return m_iTrainPercent;

	mov	eax, DWORD PTR [ecx+268]

; 3347 : }

	ret	0
?getTrainPercent@CvGameSpeedInfo@@QBEHXZ ENDP		; CvGameSpeedInfo::getTrainPercent
_TEXT	ENDS
PUBLIC	?getConstructPercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getConstructPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getConstructPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getConstructPercent@CvGameSpeedInfo@@QBEHXZ PROC	; CvGameSpeedInfo::getConstructPercent, COMDAT
; _this$ = ecx

; 3351 : 	return m_iConstructPercent;

	mov	eax, DWORD PTR [ecx+272]

; 3352 : }

	ret	0
?getConstructPercent@CvGameSpeedInfo@@QBEHXZ ENDP	; CvGameSpeedInfo::getConstructPercent
_TEXT	ENDS
PUBLIC	?getCreatePercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getCreatePercent
; Function compile flags: /Ogtpy
;	COMDAT ?getCreatePercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getCreatePercent@CvGameSpeedInfo@@QBEHXZ PROC		; CvGameSpeedInfo::getCreatePercent, COMDAT
; _this$ = ecx

; 3356 : 	return m_iCreatePercent;

	mov	eax, DWORD PTR [ecx+276]

; 3357 : }

	ret	0
?getCreatePercent@CvGameSpeedInfo@@QBEHXZ ENDP		; CvGameSpeedInfo::getCreatePercent
_TEXT	ENDS
PUBLIC	?getResearchPercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getResearchPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getResearchPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getResearchPercent@CvGameSpeedInfo@@QBEHXZ PROC	; CvGameSpeedInfo::getResearchPercent, COMDAT
; _this$ = ecx

; 3361 : 	return m_iResearchPercent;

	mov	eax, DWORD PTR [ecx+280]

; 3362 : }

	ret	0
?getResearchPercent@CvGameSpeedInfo@@QBEHXZ ENDP	; CvGameSpeedInfo::getResearchPercent
_TEXT	ENDS
PUBLIC	?getGoldPercent@CvGameSpeedInfo@@QBEHXZ		; CvGameSpeedInfo::getGoldPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getGoldPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getGoldPercent@CvGameSpeedInfo@@QBEHXZ PROC		; CvGameSpeedInfo::getGoldPercent, COMDAT
; _this$ = ecx

; 3366 : 	return m_iGoldPercent;

	mov	eax, DWORD PTR [ecx+284]

; 3367 : }

	ret	0
?getGoldPercent@CvGameSpeedInfo@@QBEHXZ ENDP		; CvGameSpeedInfo::getGoldPercent
_TEXT	ENDS
PUBLIC	?getGoldGiftMod@CvGameSpeedInfo@@QBEHXZ		; CvGameSpeedInfo::getGoldGiftMod
; Function compile flags: /Ogtpy
;	COMDAT ?getGoldGiftMod@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getGoldGiftMod@CvGameSpeedInfo@@QBEHXZ PROC		; CvGameSpeedInfo::getGoldGiftMod, COMDAT
; _this$ = ecx

; 3371 : 	return m_iGoldGiftMod;

	mov	eax, DWORD PTR [ecx+288]

; 3372 : }

	ret	0
?getGoldGiftMod@CvGameSpeedInfo@@QBEHXZ ENDP		; CvGameSpeedInfo::getGoldGiftMod
_TEXT	ENDS
PUBLIC	?getBuildPercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getBuildPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getBuildPercent@CvGameSpeedInfo@@QBEHXZ PROC		; CvGameSpeedInfo::getBuildPercent, COMDAT
; _this$ = ecx

; 3376 : 	return m_iBuildPercent;

	mov	eax, DWORD PTR [ecx+292]

; 3377 : }

	ret	0
?getBuildPercent@CvGameSpeedInfo@@QBEHXZ ENDP		; CvGameSpeedInfo::getBuildPercent
_TEXT	ENDS
PUBLIC	?getImprovementPercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getImprovementPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getImprovementPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getImprovementPercent@CvGameSpeedInfo@@QBEHXZ PROC	; CvGameSpeedInfo::getImprovementPercent, COMDAT
; _this$ = ecx

; 3381 : 	return m_iImprovementPercent;

	mov	eax, DWORD PTR [ecx+296]

; 3382 : }

	ret	0
?getImprovementPercent@CvGameSpeedInfo@@QBEHXZ ENDP	; CvGameSpeedInfo::getImprovementPercent
_TEXT	ENDS
PUBLIC	?getGreatPeoplePercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getGreatPeoplePercent
; Function compile flags: /Ogtpy
;	COMDAT ?getGreatPeoplePercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getGreatPeoplePercent@CvGameSpeedInfo@@QBEHXZ PROC	; CvGameSpeedInfo::getGreatPeoplePercent, COMDAT
; _this$ = ecx

; 3386 : 	return m_iGreatPeoplePercent;

	mov	eax, DWORD PTR [ecx+300]

; 3387 : }

	ret	0
?getGreatPeoplePercent@CvGameSpeedInfo@@QBEHXZ ENDP	; CvGameSpeedInfo::getGreatPeoplePercent
_TEXT	ENDS
PUBLIC	?getCulturePercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getCulturePercent
; Function compile flags: /Ogtpy
;	COMDAT ?getCulturePercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getCulturePercent@CvGameSpeedInfo@@QBEHXZ PROC		; CvGameSpeedInfo::getCulturePercent, COMDAT
; _this$ = ecx

; 3391 : 	return m_iCulturePercent;

	mov	eax, DWORD PTR [ecx+304]

; 3392 : }

	ret	0
?getCulturePercent@CvGameSpeedInfo@@QBEHXZ ENDP		; CvGameSpeedInfo::getCulturePercent
_TEXT	ENDS
PUBLIC	?getFaithPercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getFaithPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getFaithPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getFaithPercent@CvGameSpeedInfo@@QBEHXZ PROC		; CvGameSpeedInfo::getFaithPercent, COMDAT
; _this$ = ecx

; 3396 : 	return m_iFaithPercent;

	mov	eax, DWORD PTR [ecx+308]

; 3397 : }

	ret	0
?getFaithPercent@CvGameSpeedInfo@@QBEHXZ ENDP		; CvGameSpeedInfo::getFaithPercent
_TEXT	ENDS
PUBLIC	?getBarbPercent@CvGameSpeedInfo@@QBEHXZ		; CvGameSpeedInfo::getBarbPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getBarbPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getBarbPercent@CvGameSpeedInfo@@QBEHXZ PROC		; CvGameSpeedInfo::getBarbPercent, COMDAT
; _this$ = ecx

; 3401 : 	return m_iBarbPercent;

	mov	eax, DWORD PTR [ecx+312]

; 3402 : }

	ret	0
?getBarbPercent@CvGameSpeedInfo@@QBEHXZ ENDP		; CvGameSpeedInfo::getBarbPercent
_TEXT	ENDS
PUBLIC	?getFeatureProductionPercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getFeatureProductionPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureProductionPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getFeatureProductionPercent@CvGameSpeedInfo@@QBEHXZ PROC ; CvGameSpeedInfo::getFeatureProductionPercent, COMDAT
; _this$ = ecx

; 3406 : 	return m_iFeatureProductionPercent;

	mov	eax, DWORD PTR [ecx+316]

; 3407 : }

	ret	0
?getFeatureProductionPercent@CvGameSpeedInfo@@QBEHXZ ENDP ; CvGameSpeedInfo::getFeatureProductionPercent
_TEXT	ENDS
PUBLIC	?getUnitDiscoverPercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getUnitDiscoverPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitDiscoverPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getUnitDiscoverPercent@CvGameSpeedInfo@@QBEHXZ PROC	; CvGameSpeedInfo::getUnitDiscoverPercent, COMDAT
; _this$ = ecx

; 3411 : 	return m_iUnitDiscoverPercent;

	mov	eax, DWORD PTR [ecx+320]

; 3412 : }

	ret	0
?getUnitDiscoverPercent@CvGameSpeedInfo@@QBEHXZ ENDP	; CvGameSpeedInfo::getUnitDiscoverPercent
_TEXT	ENDS
PUBLIC	?getUnitHurryPercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getUnitHurryPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitHurryPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getUnitHurryPercent@CvGameSpeedInfo@@QBEHXZ PROC	; CvGameSpeedInfo::getUnitHurryPercent, COMDAT
; _this$ = ecx

; 3416 : 	return m_iUnitHurryPercent;

	mov	eax, DWORD PTR [ecx+324]

; 3417 : }

	ret	0
?getUnitHurryPercent@CvGameSpeedInfo@@QBEHXZ ENDP	; CvGameSpeedInfo::getUnitHurryPercent
_TEXT	ENDS
PUBLIC	?getUnitTradePercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getUnitTradePercent
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitTradePercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getUnitTradePercent@CvGameSpeedInfo@@QBEHXZ PROC	; CvGameSpeedInfo::getUnitTradePercent, COMDAT
; _this$ = ecx

; 3421 : 	return m_iUnitTradePercent;

	mov	eax, DWORD PTR [ecx+328]

; 3422 : }

	ret	0
?getUnitTradePercent@CvGameSpeedInfo@@QBEHXZ ENDP	; CvGameSpeedInfo::getUnitTradePercent
_TEXT	ENDS
PUBLIC	?getGoldenAgePercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getGoldenAgePercent
; Function compile flags: /Ogtpy
;	COMDAT ?getGoldenAgePercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getGoldenAgePercent@CvGameSpeedInfo@@QBEHXZ PROC	; CvGameSpeedInfo::getGoldenAgePercent, COMDAT
; _this$ = ecx

; 3426 : 	return m_iGoldenAgePercent;

	mov	eax, DWORD PTR [ecx+332]

; 3427 : }

	ret	0
?getGoldenAgePercent@CvGameSpeedInfo@@QBEHXZ ENDP	; CvGameSpeedInfo::getGoldenAgePercent
_TEXT	ENDS
PUBLIC	?getHurryPercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getHurryPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getHurryPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getHurryPercent@CvGameSpeedInfo@@QBEHXZ PROC		; CvGameSpeedInfo::getHurryPercent, COMDAT
; _this$ = ecx

; 3431 : 	return m_iHurryPercent;

	mov	eax, DWORD PTR [ecx+336]

; 3432 : }

	ret	0
?getHurryPercent@CvGameSpeedInfo@@QBEHXZ ENDP		; CvGameSpeedInfo::getHurryPercent
_TEXT	ENDS
PUBLIC	?getInflationOffset@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getInflationOffset
; Function compile flags: /Ogtpy
;	COMDAT ?getInflationOffset@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getInflationOffset@CvGameSpeedInfo@@QBEHXZ PROC	; CvGameSpeedInfo::getInflationOffset, COMDAT
; _this$ = ecx

; 3436 : 	return m_iInflationOffset;

	mov	eax, DWORD PTR [ecx+340]

; 3437 : }

	ret	0
?getInflationOffset@CvGameSpeedInfo@@QBEHXZ ENDP	; CvGameSpeedInfo::getInflationOffset
_TEXT	ENDS
PUBLIC	?getReligiousPressureAdjacentCity@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getReligiousPressureAdjacentCity
; Function compile flags: /Ogtpy
;	COMDAT ?getReligiousPressureAdjacentCity@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getReligiousPressureAdjacentCity@CvGameSpeedInfo@@QBEHXZ PROC ; CvGameSpeedInfo::getReligiousPressureAdjacentCity, COMDAT
; _this$ = ecx

; 3441 : 	return m_iReligiousPressureAdjacentCity;

	mov	eax, DWORD PTR [ecx+344]

; 3442 : }

	ret	0
?getReligiousPressureAdjacentCity@CvGameSpeedInfo@@QBEHXZ ENDP ; CvGameSpeedInfo::getReligiousPressureAdjacentCity
_TEXT	ENDS
PUBLIC	?getInflationPercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getInflationPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getInflationPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getInflationPercent@CvGameSpeedInfo@@QBEHXZ PROC	; CvGameSpeedInfo::getInflationPercent, COMDAT
; _this$ = ecx

; 3446 : 	return m_iInflationPercent;

	mov	eax, DWORD PTR [ecx+348]

; 3447 : }

	ret	0
?getInflationPercent@CvGameSpeedInfo@@QBEHXZ ENDP	; CvGameSpeedInfo::getInflationPercent
_TEXT	ENDS
PUBLIC	?getVictoryDelayPercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getVictoryDelayPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getVictoryDelayPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getVictoryDelayPercent@CvGameSpeedInfo@@QBEHXZ PROC	; CvGameSpeedInfo::getVictoryDelayPercent, COMDAT
; _this$ = ecx

; 3451 : 	return m_iVictoryDelayPercent;

	mov	eax, DWORD PTR [ecx+352]

; 3452 : }

	ret	0
?getVictoryDelayPercent@CvGameSpeedInfo@@QBEHXZ ENDP	; CvGameSpeedInfo::getVictoryDelayPercent
_TEXT	ENDS
PUBLIC	?getMinorCivElectionFreqMod@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getMinorCivElectionFreqMod
; Function compile flags: /Ogtpy
;	COMDAT ?getMinorCivElectionFreqMod@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getMinorCivElectionFreqMod@CvGameSpeedInfo@@QBEHXZ PROC ; CvGameSpeedInfo::getMinorCivElectionFreqMod, COMDAT
; _this$ = ecx

; 3456 : 	return m_iMinorCivElectionFreqMod;

	mov	eax, DWORD PTR [ecx+356]

; 3457 : }

	ret	0
?getMinorCivElectionFreqMod@CvGameSpeedInfo@@QBEHXZ ENDP ; CvGameSpeedInfo::getMinorCivElectionFreqMod
_TEXT	ENDS
PUBLIC	?getOpinionDurationPercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getOpinionDurationPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getOpinionDurationPercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getOpinionDurationPercent@CvGameSpeedInfo@@QBEHXZ PROC	; CvGameSpeedInfo::getOpinionDurationPercent, COMDAT
; _this$ = ecx

; 3461 : 	return m_iOpinionDurationPercent;

	mov	eax, DWORD PTR [ecx+360]

; 3462 : }

	ret	0
?getOpinionDurationPercent@CvGameSpeedInfo@@QBEHXZ ENDP	; CvGameSpeedInfo::getOpinionDurationPercent
_TEXT	ENDS
PUBLIC	?getSpyRatePercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getSpyRatePercent
; Function compile flags: /Ogtpy
;	COMDAT ?getSpyRatePercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getSpyRatePercent@CvGameSpeedInfo@@QBEHXZ PROC		; CvGameSpeedInfo::getSpyRatePercent, COMDAT
; _this$ = ecx

; 3466 : 	return m_iSpyRatePercent;

	mov	eax, DWORD PTR [ecx+364]

; 3467 : }

	ret	0
?getSpyRatePercent@CvGameSpeedInfo@@QBEHXZ ENDP		; CvGameSpeedInfo::getSpyRatePercent
_TEXT	ENDS
PUBLIC	?getPeaceDealDuration@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getPeaceDealDuration
; Function compile flags: /Ogtpy
;	COMDAT ?getPeaceDealDuration@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getPeaceDealDuration@CvGameSpeedInfo@@QBEHXZ PROC	; CvGameSpeedInfo::getPeaceDealDuration, COMDAT
; _this$ = ecx

; 3471 : 	return m_iPeaceDealDuration;

	mov	eax, DWORD PTR [ecx+368]

; 3472 : }

	ret	0
?getPeaceDealDuration@CvGameSpeedInfo@@QBEHXZ ENDP	; CvGameSpeedInfo::getPeaceDealDuration
_TEXT	ENDS
PUBLIC	?getRelationshipDuration@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getRelationshipDuration
; Function compile flags: /Ogtpy
;	COMDAT ?getRelationshipDuration@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getRelationshipDuration@CvGameSpeedInfo@@QBEHXZ PROC	; CvGameSpeedInfo::getRelationshipDuration, COMDAT
; _this$ = ecx

; 3476 : 	return m_iRelationshipDuration;

	mov	eax, DWORD PTR [ecx+372]

; 3477 : }

	ret	0
?getRelationshipDuration@CvGameSpeedInfo@@QBEHXZ ENDP	; CvGameSpeedInfo::getRelationshipDuration
_TEXT	ENDS
PUBLIC	?getLeaguePercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getLeaguePercent
; Function compile flags: /Ogtpy
;	COMDAT ?getLeaguePercent@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getLeaguePercent@CvGameSpeedInfo@@QBEHXZ PROC		; CvGameSpeedInfo::getLeaguePercent, COMDAT
; _this$ = ecx

; 3481 : 	return m_iLeaguePercent;

	mov	eax, DWORD PTR [ecx+376]

; 3482 : }

	ret	0
?getLeaguePercent@CvGameSpeedInfo@@QBEHXZ ENDP		; CvGameSpeedInfo::getLeaguePercent
_TEXT	ENDS
PUBLIC	?getNumTurnIncrements@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getNumTurnIncrements
; Function compile flags: /Ogtpy
;	COMDAT ?getNumTurnIncrements@CvGameSpeedInfo@@QBEHXZ
_TEXT	SEGMENT
?getNumTurnIncrements@CvGameSpeedInfo@@QBEHXZ PROC	; CvGameSpeedInfo::getNumTurnIncrements, COMDAT
; _this$ = ecx

; 3486 : 	return m_iNumTurnIncrements;

	mov	eax, DWORD PTR [ecx+380]

; 3487 : }

	ret	0
?getNumTurnIncrements@CvGameSpeedInfo@@QBEHXZ ENDP	; CvGameSpeedInfo::getNumTurnIncrements
_TEXT	ENDS
PUBLIC	?getGameTurnInfo@CvGameSpeedInfo@@QBEAAUGameTurnInfo@@H@Z ; CvGameSpeedInfo::getGameTurnInfo
; Function compile flags: /Ogtpy
;	COMDAT ?getGameTurnInfo@CvGameSpeedInfo@@QBEAAUGameTurnInfo@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?getGameTurnInfo@CvGameSpeedInfo@@QBEAAUGameTurnInfo@@H@Z PROC ; CvGameSpeedInfo::getGameTurnInfo, COMDAT
; _this$ = ecx

; 3491 : 	return m_pGameTurnInfo[iIndex];

	mov	eax, DWORD PTR [ecx+412]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 3492 : }

	ret	4
?getGameTurnInfo@CvGameSpeedInfo@@QBEAAUGameTurnInfo@@H@Z ENDP ; CvGameSpeedInfo::getGameTurnInfo
_TEXT	ENDS
PUBLIC	?allocateGameTurnInfos@CvGameSpeedInfo@@QAEXH@Z	; CvGameSpeedInfo::allocateGameTurnInfos
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
; Function compile flags: /Ogtpy
;	COMDAT ?allocateGameTurnInfos@CvGameSpeedInfo@@QAEXH@Z
_TEXT	SEGMENT
_iSize$ = 8						; size = 4
?allocateGameTurnInfos@CvGameSpeedInfo@@QAEXH@Z PROC	; CvGameSpeedInfo::allocateGameTurnInfos, COMDAT
; _this$ = ecx

; 3496 : 	m_pGameTurnInfo = FNEW(GameTurnInfo[iSize], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _iSize$[esp-4]
	push	esi
	mov	esi, ecx
	xor	ecx, ecx
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+412], eax
	pop	esi

; 3497 : }

	ret	4
?allocateGameTurnInfos@CvGameSpeedInfo@@QAEXH@Z ENDP	; CvGameSpeedInfo::allocateGameTurnInfos
_TEXT	ENDS
PUBLIC	?getBaseTime@CvTurnTimerInfo@@QBEHXZ		; CvTurnTimerInfo::getBaseTime
; Function compile flags: /Ogtpy
;	COMDAT ?getBaseTime@CvTurnTimerInfo@@QBEHXZ
_TEXT	SEGMENT
?getBaseTime@CvTurnTimerInfo@@QBEHXZ PROC		; CvTurnTimerInfo::getBaseTime, COMDAT
; _this$ = ecx

; 3581 : 	return m_iBaseTime;

	mov	eax, DWORD PTR [ecx+260]

; 3582 : }

	ret	0
?getBaseTime@CvTurnTimerInfo@@QBEHXZ ENDP		; CvTurnTimerInfo::getBaseTime
_TEXT	ENDS
PUBLIC	?getCityResource@CvTurnTimerInfo@@QBEHXZ	; CvTurnTimerInfo::getCityResource
; Function compile flags: /Ogtpy
;	COMDAT ?getCityResource@CvTurnTimerInfo@@QBEHXZ
_TEXT	SEGMENT
?getCityResource@CvTurnTimerInfo@@QBEHXZ PROC		; CvTurnTimerInfo::getCityResource, COMDAT
; _this$ = ecx

; 3586 : 	return m_iCityResource;

	mov	eax, DWORD PTR [ecx+264]

; 3587 : }

	ret	0
?getCityResource@CvTurnTimerInfo@@QBEHXZ ENDP		; CvTurnTimerInfo::getCityResource
_TEXT	ENDS
PUBLIC	?getUnitResource@CvTurnTimerInfo@@QBEHXZ	; CvTurnTimerInfo::getUnitResource
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitResource@CvTurnTimerInfo@@QBEHXZ
_TEXT	SEGMENT
?getUnitResource@CvTurnTimerInfo@@QBEHXZ PROC		; CvTurnTimerInfo::getUnitResource, COMDAT
; _this$ = ecx

; 3591 : 	return m_iUnitResource;

	mov	eax, DWORD PTR [ecx+268]

; 3592 : }

	ret	0
?getUnitResource@CvTurnTimerInfo@@QBEHXZ ENDP		; CvTurnTimerInfo::getUnitResource
_TEXT	ENDS
PUBLIC	?getFirstTurnMultiplier@CvTurnTimerInfo@@QBEHXZ	; CvTurnTimerInfo::getFirstTurnMultiplier
; Function compile flags: /Ogtpy
;	COMDAT ?getFirstTurnMultiplier@CvTurnTimerInfo@@QBEHXZ
_TEXT	SEGMENT
?getFirstTurnMultiplier@CvTurnTimerInfo@@QBEHXZ PROC	; CvTurnTimerInfo::getFirstTurnMultiplier, COMDAT
; _this$ = ecx

; 3596 : 	return m_iFirstTurnMultiplier;

	mov	eax, DWORD PTR [ecx+272]

; 3597 : }

	ret	0
?getFirstTurnMultiplier@CvTurnTimerInfo@@QBEHXZ ENDP	; CvTurnTimerInfo::getFirstTurnMultiplier
_TEXT	ENDS
PUBLIC	??8CvTurnTimerInfo@@UBE_NABV0@@Z		; CvTurnTimerInfo::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8CvTurnTimerInfo@@UBE_NABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??8CvTurnTimerInfo@@UBE_NABV0@@Z PROC			; CvTurnTimerInfo::operator==, COMDAT
; _this$ = ecx

; 3615 : {

	push	esi
	push	edi

; 3616 : 	if(this == &rhs) return true;

	mov	edi, DWORD PTR _rhs$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	jne	SHORT $LN6@operator@2
	pop	edi
	mov	al, 1
	pop	esi

; 3622 : 	return true;
; 3623 : }

	ret	4
$LN6@operator@2:

; 3617 : 	if(!CvBaseInfo::operator==(rhs)) return false;

	push	edi
	call	??8CvBaseInfo@@UBE_NABV0@@Z		; CvBaseInfo::operator==
	test	al, al
	jne	SHORT $LN5@operator@2
$LN9@operator@2:
	pop	edi
	xor	al, al
	pop	esi

; 3622 : 	return true;
; 3623 : }

	ret	4
$LN5@operator@2:

; 3618 : 	if(m_iBaseTime != rhs.m_iBaseTime) return false;

	mov	eax, DWORD PTR [esi+260]
	cmp	eax, DWORD PTR [edi+260]
	jne	SHORT $LN9@operator@2

; 3619 : 	if(m_iCityResource != rhs.m_iCityResource) return false;

	mov	ecx, DWORD PTR [esi+264]
	cmp	ecx, DWORD PTR [edi+264]
	jne	SHORT $LN9@operator@2

; 3620 : 	if(m_iUnitResource != rhs.m_iUnitResource) return false;

	mov	edx, DWORD PTR [esi+268]
	cmp	edx, DWORD PTR [edi+268]
	jne	SHORT $LN9@operator@2

; 3621 : 	if(m_iFirstTurnMultiplier != rhs.m_iFirstTurnMultiplier) return false;

	mov	eax, DWORD PTR [esi+272]
	cmp	eax, DWORD PTR [edi+272]
	pop	edi
	sete	al
	pop	esi

; 3622 : 	return true;
; 3623 : }

	ret	4
??8CvTurnTimerInfo@@UBE_NABV0@@Z ENDP			; CvTurnTimerInfo::operator==
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvTurnTimerInfo@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvTurnTimerInfo@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvTurnTimerInfo@@@Z PROC	; operator<<, COMDAT

; 3645 : 	readFrom.writeTo(saveTo);

	mov	ecx, DWORD PTR _readFrom$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	push	esi
	call	edx

; 3646 : 	return saveTo;

	mov	eax, esi
	pop	esi

; 3647 : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvTurnTimerInfo@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvTurnTimerInfo@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvTurnTimerInfo@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvTurnTimerInfo@@@Z PROC	; operator>>, COMDAT

; 3651 : 	writeTo.readFrom(loadFrom);

	mov	ecx, DWORD PTR _writeTo$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	esi
	call	edx

; 3652 : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 3653 : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvTurnTimerInfo@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	?getTime@CvBuildInfo@@QBEHXZ			; CvBuildInfo::getTime
; Function compile flags: /Ogtpy
;	COMDAT ?getTime@CvBuildInfo@@QBEHXZ
_TEXT	SEGMENT
?getTime@CvBuildInfo@@QBEHXZ PROC			; CvBuildInfo::getTime, COMDAT
; _this$ = ecx

; 3703 : 	return m_iTime;

	mov	eax, DWORD PTR [ecx+460]

; 3704 : }

	ret	0
?getTime@CvBuildInfo@@QBEHXZ ENDP			; CvBuildInfo::getTime
_TEXT	ENDS
PUBLIC	?getCost@CvBuildInfo@@QBEHXZ			; CvBuildInfo::getCost
; Function compile flags: /Ogtpy
;	COMDAT ?getCost@CvBuildInfo@@QBEHXZ
_TEXT	SEGMENT
?getCost@CvBuildInfo@@QBEHXZ PROC			; CvBuildInfo::getCost, COMDAT
; _this$ = ecx

; 3708 : 	return m_iCost;

	mov	eax, DWORD PTR [ecx+464]

; 3709 : }

	ret	0
?getCost@CvBuildInfo@@QBEHXZ ENDP			; CvBuildInfo::getCost
_TEXT	ENDS
PUBLIC	?getCostIncreasePerImprovement@CvBuildInfo@@QBEHXZ ; CvBuildInfo::getCostIncreasePerImprovement
; Function compile flags: /Ogtpy
;	COMDAT ?getCostIncreasePerImprovement@CvBuildInfo@@QBEHXZ
_TEXT	SEGMENT
?getCostIncreasePerImprovement@CvBuildInfo@@QBEHXZ PROC	; CvBuildInfo::getCostIncreasePerImprovement, COMDAT
; _this$ = ecx

; 3713 : 	return m_iCostIncreasePerImprovement;

	mov	eax, DWORD PTR [ecx+468]

; 3714 : }

	ret	0
?getCostIncreasePerImprovement@CvBuildInfo@@QBEHXZ ENDP	; CvBuildInfo::getCostIncreasePerImprovement
_TEXT	ENDS
PUBLIC	?getTechPrereq@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getTechPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?getTechPrereq@CvBuildInfo@@QBEHXZ
_TEXT	SEGMENT
?getTechPrereq@CvBuildInfo@@QBEHXZ PROC			; CvBuildInfo::getTechPrereq, COMDAT
; _this$ = ecx

; 3718 : 	return m_iTechPrereq;

	mov	eax, DWORD PTR [ecx+472]

; 3719 : }

	ret	0
?getTechPrereq@CvBuildInfo@@QBEHXZ ENDP			; CvBuildInfo::getTechPrereq
_TEXT	ENDS
PUBLIC	?getImprovement@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getImprovement
; Function compile flags: /Ogtpy
;	COMDAT ?getImprovement@CvBuildInfo@@QBEHXZ
_TEXT	SEGMENT
?getImprovement@CvBuildInfo@@QBEHXZ PROC		; CvBuildInfo::getImprovement, COMDAT
; _this$ = ecx

; 3723 : 	return m_iImprovement;

	mov	eax, DWORD PTR [ecx+476]

; 3724 : }

	ret	0
?getImprovement@CvBuildInfo@@QBEHXZ ENDP		; CvBuildInfo::getImprovement
_TEXT	ENDS
PUBLIC	?getRoute@CvBuildInfo@@QBEHXZ			; CvBuildInfo::getRoute
; Function compile flags: /Ogtpy
;	COMDAT ?getRoute@CvBuildInfo@@QBEHXZ
_TEXT	SEGMENT
?getRoute@CvBuildInfo@@QBEHXZ PROC			; CvBuildInfo::getRoute, COMDAT
; _this$ = ecx

; 3728 : 	return m_iRoute;

	mov	eax, DWORD PTR [ecx+480]

; 3729 : }

	ret	0
?getRoute@CvBuildInfo@@QBEHXZ ENDP			; CvBuildInfo::getRoute
_TEXT	ENDS
PUBLIC	?getEntityEvent@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getEntityEvent
; Function compile flags: /Ogtpy
;	COMDAT ?getEntityEvent@CvBuildInfo@@QBEHXZ
_TEXT	SEGMENT
?getEntityEvent@CvBuildInfo@@QBEHXZ PROC		; CvBuildInfo::getEntityEvent, COMDAT
; _this$ = ecx

; 3733 : 	return m_iEntityEvent;

	mov	eax, DWORD PTR [ecx+484]

; 3734 : }

	ret	0
?getEntityEvent@CvBuildInfo@@QBEHXZ ENDP		; CvBuildInfo::getEntityEvent
_TEXT	ENDS
PUBLIC	?getMissionType@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getMissionType
; Function compile flags: /Ogtpy
;	COMDAT ?getMissionType@CvBuildInfo@@QBEHXZ
_TEXT	SEGMENT
?getMissionType@CvBuildInfo@@QBEHXZ PROC		; CvBuildInfo::getMissionType, COMDAT
; _this$ = ecx

; 3738 : 	return m_iMissionType;

	mov	eax, DWORD PTR [ecx+488]

; 3739 : }

	ret	0
?getMissionType@CvBuildInfo@@QBEHXZ ENDP		; CvBuildInfo::getMissionType
_TEXT	ENDS
PUBLIC	?setMissionType@CvBuildInfo@@QAEXH@Z		; CvBuildInfo::setMissionType
; Function compile flags: /Ogtpy
;	COMDAT ?setMissionType@CvBuildInfo@@QAEXH@Z
_TEXT	SEGMENT
_iNewType$ = 8						; size = 4
?setMissionType@CvBuildInfo@@QAEXH@Z PROC		; CvBuildInfo::setMissionType, COMDAT
; _this$ = ecx

; 3743 : 	m_iMissionType = iNewType;

	mov	eax, DWORD PTR _iNewType$[esp-4]
	mov	DWORD PTR [ecx+488], eax

; 3744 : }

	ret	4
?setMissionType@CvBuildInfo@@QAEXH@Z ENDP		; CvBuildInfo::setMissionType
_TEXT	ENDS
PUBLIC	?isKill@CvBuildInfo@@QBE_NXZ			; CvBuildInfo::isKill
; Function compile flags: /Ogtpy
;	COMDAT ?isKill@CvBuildInfo@@QBE_NXZ
_TEXT	SEGMENT
?isKill@CvBuildInfo@@QBE_NXZ PROC			; CvBuildInfo::isKill, COMDAT
; _this$ = ecx

; 3748 : 	return m_bKill;

	mov	al, BYTE PTR [ecx+492]

; 3749 : }

	ret	0
?isKill@CvBuildInfo@@QBE_NXZ ENDP			; CvBuildInfo::isKill
_TEXT	ENDS
PUBLIC	?isRepair@CvBuildInfo@@QBE_NXZ			; CvBuildInfo::isRepair
; Function compile flags: /Ogtpy
;	COMDAT ?isRepair@CvBuildInfo@@QBE_NXZ
_TEXT	SEGMENT
?isRepair@CvBuildInfo@@QBE_NXZ PROC			; CvBuildInfo::isRepair, COMDAT
; _this$ = ecx

; 3753 : 	return m_bRepair;

	mov	al, BYTE PTR [ecx+493]

; 3754 : }

	ret	0
?isRepair@CvBuildInfo@@QBE_NXZ ENDP			; CvBuildInfo::isRepair
_TEXT	ENDS
PUBLIC	?IsRemoveRoute@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::IsRemoveRoute
; Function compile flags: /Ogtpy
;	COMDAT ?IsRemoveRoute@CvBuildInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsRemoveRoute@CvBuildInfo@@QBE_NXZ PROC		; CvBuildInfo::IsRemoveRoute, COMDAT
; _this$ = ecx

; 3758 : 	return m_bRemoveRoute;

	mov	al, BYTE PTR [ecx+494]

; 3759 : }

	ret	0
?IsRemoveRoute@CvBuildInfo@@QBE_NXZ ENDP		; CvBuildInfo::IsRemoveRoute
_TEXT	ENDS
PUBLIC	?IsSpecificCivRequired@CvBuildInfo@@QBE_NXZ	; CvBuildInfo::IsSpecificCivRequired
; Function compile flags: /Ogtpy
;	COMDAT ?IsSpecificCivRequired@CvBuildInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsSpecificCivRequired@CvBuildInfo@@QBE_NXZ PROC	; CvBuildInfo::IsSpecificCivRequired, COMDAT
; _this$ = ecx

; 3765 : 	return m_bSpecificCivRequired;

	mov	al, BYTE PTR [ecx+495]

; 3766 : }

	ret	0
?IsSpecificCivRequired@CvBuildInfo@@QBE_NXZ ENDP	; CvBuildInfo::IsSpecificCivRequired
_TEXT	ENDS
PUBLIC	?GetRequiredCivilization@CvBuildInfo@@QBE?AW4CivilizationTypes@@XZ ; CvBuildInfo::GetRequiredCivilization
; Function compile flags: /Ogtpy
;	COMDAT ?GetRequiredCivilization@CvBuildInfo@@QBE?AW4CivilizationTypes@@XZ
_TEXT	SEGMENT
?GetRequiredCivilization@CvBuildInfo@@QBE?AW4CivilizationTypes@@XZ PROC ; CvBuildInfo::GetRequiredCivilization, COMDAT
; _this$ = ecx

; 3770 : 	return m_eRequiredCivilization;

	mov	eax, DWORD PTR [ecx+496]

; 3771 : }

	ret	0
?GetRequiredCivilization@CvBuildInfo@@QBE?AW4CivilizationTypes@@XZ ENDP ; CvBuildInfo::GetRequiredCivilization
_TEXT	ENDS
PUBLIC	?IsWater@CvBuildInfo@@QBE_NXZ			; CvBuildInfo::IsWater
; Function compile flags: /Ogtpy
;	COMDAT ?IsWater@CvBuildInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsWater@CvBuildInfo@@QBE_NXZ PROC			; CvBuildInfo::IsWater, COMDAT
; _this$ = ecx

; 3776 : 	return m_bWater;

	mov	al, BYTE PTR [ecx+500]

; 3777 : }

	ret	0
?IsWater@CvBuildInfo@@QBE_NXZ ENDP			; CvBuildInfo::IsWater
_TEXT	ENDS
PUBLIC	?IsCanBeEmbarked@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::IsCanBeEmbarked
; Function compile flags: /Ogtpy
;	COMDAT ?IsCanBeEmbarked@CvBuildInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsCanBeEmbarked@CvBuildInfo@@QBE_NXZ PROC		; CvBuildInfo::IsCanBeEmbarked, COMDAT
; _this$ = ecx

; 3781 : 	return m_bCanBeEmbarked;

	mov	al, BYTE PTR [ecx+501]

; 3782 : }

	ret	0
?IsCanBeEmbarked@CvBuildInfo@@QBE_NXZ ENDP		; CvBuildInfo::IsCanBeEmbarked
_TEXT	ENDS
PUBLIC	?getFeatureTech@CvBuildInfo@@QBEHH@Z		; CvBuildInfo::getFeatureTech
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureTech@CvBuildInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getFeatureTech@CvBuildInfo@@QBEHH@Z PROC		; CvBuildInfo::getFeatureTech, COMDAT
; _this$ = ecx

; 3787 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 3788 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3789 : 	return m_paiFeatureTech ? m_paiFeatureTech[i] : -1;

	mov	eax, DWORD PTR [ecx+504]
	test	eax, eax
	je	SHORT $LN3@getFeature
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3790 : }

	ret	4
$LN3@getFeature:

; 3787 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 3788 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3789 : 	return m_paiFeatureTech ? m_paiFeatureTech[i] : -1;

	or	eax, -1

; 3790 : }

	ret	4
?getFeatureTech@CvBuildInfo@@QBEHH@Z ENDP		; CvBuildInfo::getFeatureTech
_TEXT	ENDS
PUBLIC	?getFeatureTime@CvBuildInfo@@QBEHH@Z		; CvBuildInfo::getFeatureTime
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureTime@CvBuildInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getFeatureTime@CvBuildInfo@@QBEHH@Z PROC		; CvBuildInfo::getFeatureTime, COMDAT
; _this$ = ecx

; 3794 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 3795 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3796 : 	return m_paiFeatureTime ? m_paiFeatureTime[i] : -1;

	mov	eax, DWORD PTR [ecx+508]
	test	eax, eax
	je	SHORT $LN3@getFeature@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3797 : }

	ret	4
$LN3@getFeature@2:

; 3794 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 3795 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3796 : 	return m_paiFeatureTime ? m_paiFeatureTime[i] : -1;

	or	eax, -1

; 3797 : }

	ret	4
?getFeatureTime@CvBuildInfo@@QBEHH@Z ENDP		; CvBuildInfo::getFeatureTime
_TEXT	ENDS
PUBLIC	?getFeatureProduction@CvBuildInfo@@QBEHH@Z	; CvBuildInfo::getFeatureProduction
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureProduction@CvBuildInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getFeatureProduction@CvBuildInfo@@QBEHH@Z PROC		; CvBuildInfo::getFeatureProduction, COMDAT
; _this$ = ecx

; 3801 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 3802 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3803 : 	return m_paiFeatureProduction ? m_paiFeatureProduction[i] : -1;

	mov	eax, DWORD PTR [ecx+512]
	test	eax, eax
	je	SHORT $LN3@getFeature@3
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3804 : }

	ret	4
$LN3@getFeature@3:

; 3801 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 3802 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3803 : 	return m_paiFeatureProduction ? m_paiFeatureProduction[i] : -1;

	or	eax, -1

; 3804 : }

	ret	4
?getFeatureProduction@CvBuildInfo@@QBEHH@Z ENDP		; CvBuildInfo::getFeatureProduction
_TEXT	ENDS
PUBLIC	?getFeatureFood@CvBuildInfo@@QBEHH@Z		; CvBuildInfo::getFeatureFood
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureFood@CvBuildInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getFeatureFood@CvBuildInfo@@QBEHH@Z PROC		; CvBuildInfo::getFeatureFood, COMDAT
; _this$ = ecx

; 3809 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 3810 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3811 : 	return m_paiFeatureFood ? m_paiFeatureFood[i] : -1;

	mov	eax, DWORD PTR [ecx+516]
	test	eax, eax
	je	SHORT $LN3@getFeature@4
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3812 : }

	ret	4
$LN3@getFeature@4:

; 3809 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 3810 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3811 : 	return m_paiFeatureFood ? m_paiFeatureFood[i] : -1;

	or	eax, -1

; 3812 : }

	ret	4
?getFeatureFood@CvBuildInfo@@QBEHH@Z ENDP		; CvBuildInfo::getFeatureFood
_TEXT	ENDS
PUBLIC	?getFeatureCost@CvBuildInfo@@QBEHH@Z		; CvBuildInfo::getFeatureCost
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureCost@CvBuildInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getFeatureCost@CvBuildInfo@@QBEHH@Z PROC		; CvBuildInfo::getFeatureCost, COMDAT
; _this$ = ecx

; 3817 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 3818 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3819 : 	return m_paiFeatureCost ? m_paiFeatureCost[i] : -1;

	mov	eax, DWORD PTR [ecx+520]
	test	eax, eax
	je	SHORT $LN3@getFeature@5
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3820 : }

	ret	4
$LN3@getFeature@5:

; 3817 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 3818 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3819 : 	return m_paiFeatureCost ? m_paiFeatureCost[i] : -1;

	or	eax, -1

; 3820 : }

	ret	4
?getFeatureCost@CvBuildInfo@@QBEHH@Z ENDP		; CvBuildInfo::getFeatureCost
_TEXT	ENDS
PUBLIC	?getTechTimeChange@CvBuildInfo@@QBEHH@Z		; CvBuildInfo::getTechTimeChange
; Function compile flags: /Ogtpy
;	COMDAT ?getTechTimeChange@CvBuildInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getTechTimeChange@CvBuildInfo@@QBEHH@Z PROC		; CvBuildInfo::getTechTimeChange, COMDAT
; _this$ = ecx

; 3824 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 3825 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3826 : 	return m_paiTechTimeChange ? m_paiTechTimeChange[i] : -1;

	mov	eax, DWORD PTR [ecx+524]
	test	eax, eax
	je	SHORT $LN3@getTechTim
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3827 : }

	ret	4
$LN3@getTechTim:

; 3824 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 3825 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3826 : 	return m_paiTechTimeChange ? m_paiTechTimeChange[i] : -1;

	or	eax, -1

; 3827 : }

	ret	4
?getTechTimeChange@CvBuildInfo@@QBEHH@Z ENDP		; CvBuildInfo::getTechTimeChange
_TEXT	ENDS
PUBLIC	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z		; CvBuildInfo::isFeatureRemove
; Function compile flags: /Ogtpy
;	COMDAT ?isFeatureRemove@CvBuildInfo@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?isFeatureRemove@CvBuildInfo@@QBE_NH@Z PROC		; CvBuildInfo::isFeatureRemove, COMDAT
; _this$ = ecx

; 3831 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 3832 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3833 : 	return m_pabFeatureRemove ? m_pabFeatureRemove[i] : false;

	mov	eax, DWORD PTR [ecx+528]
	test	eax, eax
	je	SHORT $LN3@isFeatureR
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 3834 : }

	ret	4
$LN3@isFeatureR:

; 3831 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 3832 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 3833 : 	return m_pabFeatureRemove ? m_pabFeatureRemove[i] : false;

	xor	al, al

; 3834 : }

	ret	4
?isFeatureRemove@CvBuildInfo@@QBE_NH@Z ENDP		; CvBuildInfo::isFeatureRemove
_TEXT	ENDS
PUBLIC	?SafeStrlen@FStringA@@SAHPBD@Z			; FStringA::SafeStrlen
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ?SafeStrlen@FStringA@@SAHPBD@Z
_TEXT	SEGMENT
_lpsz$ = 8						; size = 4
?SafeStrlen@FStringA@@SAHPBD@Z PROC			; FStringA::SafeStrlen, COMDAT

; 1030 : 	return ( lpsz ? ( int )strlen( lpsz ) : 0 );

	mov	eax, DWORD PTR _lpsz$[esp-4]
	test	eax, eax
	je	SHORT $LN3@SafeStrlen
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL5@SafeStrlen:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL5@SafeStrlen
	sub	eax, edx

; 1031 : }

	ret	0
$LN3@SafeStrlen:

; 1030 : 	return ( lpsz ? ( int )strlen( lpsz ) : 0 );

	xor	eax, eax

; 1031 : }

	ret	0
?SafeStrlen@FStringA@@SAHPBD@Z ENDP			; FStringA::SafeStrlen
_TEXT	ENDS
PUBLIC	?getGold@CvGoodyInfo@@QBEHXZ			; CvGoodyInfo::getGold
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
;	COMDAT ?getGold@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getGold@CvGoodyInfo@@QBEHXZ PROC			; CvGoodyInfo::getGold, COMDAT
; _this$ = ecx

; 4018 : 	return m_iGold;

	mov	eax, DWORD PTR [ecx+260]

; 4019 : }

	ret	0
?getGold@CvGoodyInfo@@QBEHXZ ENDP			; CvGoodyInfo::getGold
_TEXT	ENDS
PUBLIC	?getNumGoldRandRolls@CvGoodyInfo@@QBEHXZ	; CvGoodyInfo::getNumGoldRandRolls
; Function compile flags: /Ogtpy
;	COMDAT ?getNumGoldRandRolls@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getNumGoldRandRolls@CvGoodyInfo@@QBEHXZ PROC		; CvGoodyInfo::getNumGoldRandRolls, COMDAT
; _this$ = ecx

; 4023 : 	return m_iNumGoldRandRolls;

	mov	eax, DWORD PTR [ecx+264]

; 4024 : }

	ret	0
?getNumGoldRandRolls@CvGoodyInfo@@QBEHXZ ENDP		; CvGoodyInfo::getNumGoldRandRolls
_TEXT	ENDS
PUBLIC	?getGoldRandAmount@CvGoodyInfo@@QBEHXZ		; CvGoodyInfo::getGoldRandAmount
; Function compile flags: /Ogtpy
;	COMDAT ?getGoldRandAmount@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getGoldRandAmount@CvGoodyInfo@@QBEHXZ PROC		; CvGoodyInfo::getGoldRandAmount, COMDAT
; _this$ = ecx

; 4028 : 	return m_iGoldRandAmount;

	mov	eax, DWORD PTR [ecx+268]

; 4029 : }

	ret	0
?getGoldRandAmount@CvGoodyInfo@@QBEHXZ ENDP		; CvGoodyInfo::getGoldRandAmount
_TEXT	ENDS
PUBLIC	?getMapOffset@CvGoodyInfo@@QBEHXZ		; CvGoodyInfo::getMapOffset
; Function compile flags: /Ogtpy
;	COMDAT ?getMapOffset@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getMapOffset@CvGoodyInfo@@QBEHXZ PROC			; CvGoodyInfo::getMapOffset, COMDAT
; _this$ = ecx

; 4033 : 	return m_iMapOffset;

	mov	eax, DWORD PTR [ecx+272]

; 4034 : }

	ret	0
?getMapOffset@CvGoodyInfo@@QBEHXZ ENDP			; CvGoodyInfo::getMapOffset
_TEXT	ENDS
PUBLIC	?getMapRange@CvGoodyInfo@@QBEHXZ		; CvGoodyInfo::getMapRange
; Function compile flags: /Ogtpy
;	COMDAT ?getMapRange@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getMapRange@CvGoodyInfo@@QBEHXZ PROC			; CvGoodyInfo::getMapRange, COMDAT
; _this$ = ecx

; 4038 : 	return m_iMapRange;

	mov	eax, DWORD PTR [ecx+276]

; 4039 : }

	ret	0
?getMapRange@CvGoodyInfo@@QBEHXZ ENDP			; CvGoodyInfo::getMapRange
_TEXT	ENDS
PUBLIC	?getMapProb@CvGoodyInfo@@QBEHXZ			; CvGoodyInfo::getMapProb
; Function compile flags: /Ogtpy
;	COMDAT ?getMapProb@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getMapProb@CvGoodyInfo@@QBEHXZ PROC			; CvGoodyInfo::getMapProb, COMDAT
; _this$ = ecx

; 4043 : 	return m_iMapProb;

	mov	eax, DWORD PTR [ecx+280]

; 4044 : }

	ret	0
?getMapProb@CvGoodyInfo@@QBEHXZ ENDP			; CvGoodyInfo::getMapProb
_TEXT	ENDS
PUBLIC	?getExperience@CvGoodyInfo@@QBEHXZ		; CvGoodyInfo::getExperience
; Function compile flags: /Ogtpy
;	COMDAT ?getExperience@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getExperience@CvGoodyInfo@@QBEHXZ PROC			; CvGoodyInfo::getExperience, COMDAT
; _this$ = ecx

; 4048 : 	return m_iExperience;

	mov	eax, DWORD PTR [ecx+284]

; 4049 : }

	ret	0
?getExperience@CvGoodyInfo@@QBEHXZ ENDP			; CvGoodyInfo::getExperience
_TEXT	ENDS
PUBLIC	?getHealing@CvGoodyInfo@@QBEHXZ			; CvGoodyInfo::getHealing
; Function compile flags: /Ogtpy
;	COMDAT ?getHealing@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getHealing@CvGoodyInfo@@QBEHXZ PROC			; CvGoodyInfo::getHealing, COMDAT
; _this$ = ecx

; 4053 : 	return m_iHealing;

	mov	eax, DWORD PTR [ecx+288]

; 4054 : }

	ret	0
?getHealing@CvGoodyInfo@@QBEHXZ ENDP			; CvGoodyInfo::getHealing
_TEXT	ENDS
PUBLIC	?getDamagePrereq@CvGoodyInfo@@QBEHXZ		; CvGoodyInfo::getDamagePrereq
; Function compile flags: /Ogtpy
;	COMDAT ?getDamagePrereq@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getDamagePrereq@CvGoodyInfo@@QBEHXZ PROC		; CvGoodyInfo::getDamagePrereq, COMDAT
; _this$ = ecx

; 4058 : 	return m_iDamagePrereq;

	mov	eax, DWORD PTR [ecx+292]

; 4059 : }

	ret	0
?getDamagePrereq@CvGoodyInfo@@QBEHXZ ENDP		; CvGoodyInfo::getDamagePrereq
_TEXT	ENDS
PUBLIC	?getCulture@CvGoodyInfo@@QBEHXZ			; CvGoodyInfo::getCulture
; Function compile flags: /Ogtpy
;	COMDAT ?getCulture@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getCulture@CvGoodyInfo@@QBEHXZ PROC			; CvGoodyInfo::getCulture, COMDAT
; _this$ = ecx

; 4063 : 	return m_iCulture;

	mov	eax, DWORD PTR [ecx+300]

; 4064 : }

	ret	0
?getCulture@CvGoodyInfo@@QBEHXZ ENDP			; CvGoodyInfo::getCulture
_TEXT	ENDS
PUBLIC	?getFaith@CvGoodyInfo@@QBEHXZ			; CvGoodyInfo::getFaith
; Function compile flags: /Ogtpy
;	COMDAT ?getFaith@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getFaith@CvGoodyInfo@@QBEHXZ PROC			; CvGoodyInfo::getFaith, COMDAT
; _this$ = ecx

; 4068 : 	return m_iFaith;

	mov	eax, DWORD PTR [ecx+304]

; 4069 : }

	ret	0
?getFaith@CvGoodyInfo@@QBEHXZ ENDP			; CvGoodyInfo::getFaith
_TEXT	ENDS
PUBLIC	?getProphetPercent@CvGoodyInfo@@QBEHXZ		; CvGoodyInfo::getProphetPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getProphetPercent@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getProphetPercent@CvGoodyInfo@@QBEHXZ PROC		; CvGoodyInfo::getProphetPercent, COMDAT
; _this$ = ecx

; 4073 : 	return m_iProphetPercent;

	mov	eax, DWORD PTR [ecx+308]

; 4074 : }

	ret	0
?getProphetPercent@CvGoodyInfo@@QBEHXZ ENDP		; CvGoodyInfo::getProphetPercent
_TEXT	ENDS
PUBLIC	?getRevealNearbyBarbariansRange@CvGoodyInfo@@QBEHXZ ; CvGoodyInfo::getRevealNearbyBarbariansRange
; Function compile flags: /Ogtpy
;	COMDAT ?getRevealNearbyBarbariansRange@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getRevealNearbyBarbariansRange@CvGoodyInfo@@QBEHXZ PROC ; CvGoodyInfo::getRevealNearbyBarbariansRange, COMDAT
; _this$ = ecx

; 4078 : 	return m_iRevealNearbyBarbariansRange;

	mov	eax, DWORD PTR [ecx+312]

; 4079 : }

	ret	0
?getRevealNearbyBarbariansRange@CvGoodyInfo@@QBEHXZ ENDP ; CvGoodyInfo::getRevealNearbyBarbariansRange
_TEXT	ENDS
PUBLIC	?getPopulation@CvGoodyInfo@@QBEHXZ		; CvGoodyInfo::getPopulation
; Function compile flags: /Ogtpy
;	COMDAT ?getPopulation@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getPopulation@CvGoodyInfo@@QBEHXZ PROC			; CvGoodyInfo::getPopulation, COMDAT
; _this$ = ecx

; 4083 : 	return m_iPopulation;

	mov	eax, DWORD PTR [ecx+296]

; 4084 : }

	ret	0
?getPopulation@CvGoodyInfo@@QBEHXZ ENDP			; CvGoodyInfo::getPopulation
_TEXT	ENDS
PUBLIC	?getBarbarianUnitProb@CvGoodyInfo@@QBEHXZ	; CvGoodyInfo::getBarbarianUnitProb
; Function compile flags: /Ogtpy
;	COMDAT ?getBarbarianUnitProb@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getBarbarianUnitProb@CvGoodyInfo@@QBEHXZ PROC		; CvGoodyInfo::getBarbarianUnitProb, COMDAT
; _this$ = ecx

; 4088 : 	return m_iBarbarianUnitProb;

	mov	eax, DWORD PTR [ecx+316]

; 4089 : }

	ret	0
?getBarbarianUnitProb@CvGoodyInfo@@QBEHXZ ENDP		; CvGoodyInfo::getBarbarianUnitProb
_TEXT	ENDS
PUBLIC	?getMinBarbarians@CvGoodyInfo@@QBEHXZ		; CvGoodyInfo::getMinBarbarians
; Function compile flags: /Ogtpy
;	COMDAT ?getMinBarbarians@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getMinBarbarians@CvGoodyInfo@@QBEHXZ PROC		; CvGoodyInfo::getMinBarbarians, COMDAT
; _this$ = ecx

; 4093 : 	return m_iMinBarbarians;

	mov	eax, DWORD PTR [ecx+320]

; 4094 : }

	ret	0
?getMinBarbarians@CvGoodyInfo@@QBEHXZ ENDP		; CvGoodyInfo::getMinBarbarians
_TEXT	ENDS
PUBLIC	?getUnitClassType@CvGoodyInfo@@QBEHXZ		; CvGoodyInfo::getUnitClassType
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitClassType@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getUnitClassType@CvGoodyInfo@@QBEHXZ PROC		; CvGoodyInfo::getUnitClassType, COMDAT
; _this$ = ecx

; 4098 : 	return m_iUnitClassType;

	mov	eax, DWORD PTR [ecx+324]

; 4099 : }

	ret	0
?getUnitClassType@CvGoodyInfo@@QBEHXZ ENDP		; CvGoodyInfo::getUnitClassType
_TEXT	ENDS
PUBLIC	?getBarbarianUnitClass@CvGoodyInfo@@QBEHXZ	; CvGoodyInfo::getBarbarianUnitClass
; Function compile flags: /Ogtpy
;	COMDAT ?getBarbarianUnitClass@CvGoodyInfo@@QBEHXZ
_TEXT	SEGMENT
?getBarbarianUnitClass@CvGoodyInfo@@QBEHXZ PROC		; CvGoodyInfo::getBarbarianUnitClass, COMDAT
; _this$ = ecx

; 4103 : 	return m_iBarbarianUnitClass;

	mov	eax, DWORD PTR [ecx+328]

; 4104 : }

	ret	0
?getBarbarianUnitClass@CvGoodyInfo@@QBEHXZ ENDP		; CvGoodyInfo::getBarbarianUnitClass
_TEXT	ENDS
PUBLIC	?isTech@CvGoodyInfo@@QBE_NXZ			; CvGoodyInfo::isTech
; Function compile flags: /Ogtpy
;	COMDAT ?isTech@CvGoodyInfo@@QBE_NXZ
_TEXT	SEGMENT
?isTech@CvGoodyInfo@@QBE_NXZ PROC			; CvGoodyInfo::isTech, COMDAT
; _this$ = ecx

; 4108 : 	return m_bTech;

	mov	al, BYTE PTR [ecx+332]

; 4109 : }

	ret	0
?isTech@CvGoodyInfo@@QBE_NXZ ENDP			; CvGoodyInfo::isTech
_TEXT	ENDS
PUBLIC	?isRevealUnknownResource@CvGoodyInfo@@QBE_NXZ	; CvGoodyInfo::isRevealUnknownResource
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealUnknownResource@CvGoodyInfo@@QBE_NXZ
_TEXT	SEGMENT
?isRevealUnknownResource@CvGoodyInfo@@QBE_NXZ PROC	; CvGoodyInfo::isRevealUnknownResource, COMDAT
; _this$ = ecx

; 4113 : 	return m_bRevealUnknownResource;

	mov	al, BYTE PTR [ecx+333]

; 4114 : }

	ret	0
?isRevealUnknownResource@CvGoodyInfo@@QBE_NXZ ENDP	; CvGoodyInfo::isRevealUnknownResource
_TEXT	ENDS
PUBLIC	?isUpgradeUnit@CvGoodyInfo@@QBE_NXZ		; CvGoodyInfo::isUpgradeUnit
; Function compile flags: /Ogtpy
;	COMDAT ?isUpgradeUnit@CvGoodyInfo@@QBE_NXZ
_TEXT	SEGMENT
?isUpgradeUnit@CvGoodyInfo@@QBE_NXZ PROC		; CvGoodyInfo::isUpgradeUnit, COMDAT
; _this$ = ecx

; 4118 : 	return m_bUpgradeUnit;

	mov	al, BYTE PTR [ecx+334]

; 4119 : }

	ret	0
?isUpgradeUnit@CvGoodyInfo@@QBE_NXZ ENDP		; CvGoodyInfo::isUpgradeUnit
_TEXT	ENDS
PUBLIC	?isPantheonFaith@CvGoodyInfo@@QBE_NXZ		; CvGoodyInfo::isPantheonFaith
; Function compile flags: /Ogtpy
;	COMDAT ?isPantheonFaith@CvGoodyInfo@@QBE_NXZ
_TEXT	SEGMENT
?isPantheonFaith@CvGoodyInfo@@QBE_NXZ PROC		; CvGoodyInfo::isPantheonFaith, COMDAT
; _this$ = ecx

; 4123 : 	return m_bPantheonFaith;

	mov	al, BYTE PTR [ecx+335]

; 4124 : }

	ret	0
?isPantheonFaith@CvGoodyInfo@@QBE_NXZ ENDP		; CvGoodyInfo::isPantheonFaith
_TEXT	ENDS
PUBLIC	?isBad@CvGoodyInfo@@QBE_NXZ			; CvGoodyInfo::isBad
; Function compile flags: /Ogtpy
;	COMDAT ?isBad@CvGoodyInfo@@QBE_NXZ
_TEXT	SEGMENT
?isBad@CvGoodyInfo@@QBE_NXZ PROC			; CvGoodyInfo::isBad, COMDAT
; _this$ = ecx

; 4128 : 	return m_bBad;

	mov	al, BYTE PTR [ecx+336]

; 4129 : }

	ret	0
?isBad@CvGoodyInfo@@QBE_NXZ ENDP			; CvGoodyInfo::isBad
_TEXT	ENDS
PUBLIC	?getSound@CvGoodyInfo@@QBEPBDXZ			; CvGoodyInfo::getSound
; Function compile flags: /Ogtpy
;	COMDAT ?getSound@CvGoodyInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getSound@CvGoodyInfo@@QBEPBDXZ PROC			; CvGoodyInfo::getSound, COMDAT
; _this$ = ecx

; 4133 : 	return m_strSound.c_str();

	add	ecx, 340				; 00000154H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getSound@CvGoodyInfo@@QBEPBDXZ ENDP			; CvGoodyInfo::getSound
_TEXT	ENDS
PUBLIC	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ		; CvRouteInfo::GetGoldMaintenance
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldMaintenance@CvRouteInfo@@QBEHXZ
_TEXT	SEGMENT
?GetGoldMaintenance@CvRouteInfo@@QBEHXZ PROC		; CvRouteInfo::GetGoldMaintenance, COMDAT
; _this$ = ecx

; 4221 : 	return m_iGoldMaintenance;

	mov	eax, DWORD PTR [ecx+260]

; 4222 : }

	ret	0
?GetGoldMaintenance@CvRouteInfo@@QBEHXZ ENDP		; CvRouteInfo::GetGoldMaintenance
_TEXT	ENDS
PUBLIC	?getAdvancedStartCost@CvRouteInfo@@QBEHXZ	; CvRouteInfo::getAdvancedStartCost
; Function compile flags: /Ogtpy
;	COMDAT ?getAdvancedStartCost@CvRouteInfo@@QBEHXZ
_TEXT	SEGMENT
?getAdvancedStartCost@CvRouteInfo@@QBEHXZ PROC		; CvRouteInfo::getAdvancedStartCost, COMDAT
; _this$ = ecx

; 4226 : 	return m_iAdvancedStartCost;

	mov	eax, DWORD PTR [ecx+264]

; 4227 : }

	ret	0
?getAdvancedStartCost@CvRouteInfo@@QBEHXZ ENDP		; CvRouteInfo::getAdvancedStartCost
_TEXT	ENDS
PUBLIC	?getValue@CvRouteInfo@@QBEHXZ			; CvRouteInfo::getValue
; Function compile flags: /Ogtpy
;	COMDAT ?getValue@CvRouteInfo@@QBEHXZ
_TEXT	SEGMENT
?getValue@CvRouteInfo@@QBEHXZ PROC			; CvRouteInfo::getValue, COMDAT
; _this$ = ecx

; 4231 : 	return m_iValue;

	mov	eax, DWORD PTR [ecx+268]

; 4232 : }

	ret	0
?getValue@CvRouteInfo@@QBEHXZ ENDP			; CvRouteInfo::getValue
_TEXT	ENDS
PUBLIC	?getMovementCost@CvRouteInfo@@QBEHXZ		; CvRouteInfo::getMovementCost
; Function compile flags: /Ogtpy
;	COMDAT ?getMovementCost@CvRouteInfo@@QBEHXZ
_TEXT	SEGMENT
?getMovementCost@CvRouteInfo@@QBEHXZ PROC		; CvRouteInfo::getMovementCost, COMDAT
; _this$ = ecx

; 4236 : 	return m_iMovementCost;

	mov	eax, DWORD PTR [ecx+272]

; 4237 : }

	ret	0
?getMovementCost@CvRouteInfo@@QBEHXZ ENDP		; CvRouteInfo::getMovementCost
_TEXT	ENDS
PUBLIC	?getFlatMovementCost@CvRouteInfo@@QBEHXZ	; CvRouteInfo::getFlatMovementCost
; Function compile flags: /Ogtpy
;	COMDAT ?getFlatMovementCost@CvRouteInfo@@QBEHXZ
_TEXT	SEGMENT
?getFlatMovementCost@CvRouteInfo@@QBEHXZ PROC		; CvRouteInfo::getFlatMovementCost, COMDAT
; _this$ = ecx

; 4241 : 	return m_iFlatMovementCost;

	mov	eax, DWORD PTR [ecx+276]

; 4242 : }

	ret	0
?getFlatMovementCost@CvRouteInfo@@QBEHXZ ENDP		; CvRouteInfo::getFlatMovementCost
_TEXT	ENDS
PUBLIC	?IsIndustrial@CvRouteInfo@@QBE_NXZ		; CvRouteInfo::IsIndustrial
; Function compile flags: /Ogtpy
;	COMDAT ?IsIndustrial@CvRouteInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsIndustrial@CvRouteInfo@@QBE_NXZ PROC			; CvRouteInfo::IsIndustrial, COMDAT
; _this$ = ecx

; 4246 : 	return m_bIndustrial;

	cmp	DWORD PTR [ecx+280], 0
	setne	al

; 4247 : }

	ret	0
?IsIndustrial@CvRouteInfo@@QBE_NXZ ENDP			; CvRouteInfo::IsIndustrial
_TEXT	ENDS
PUBLIC	?getYieldChange@CvRouteInfo@@QBEHH@Z		; CvRouteInfo::getYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?getYieldChange@CvRouteInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getYieldChange@CvRouteInfo@@QBEHH@Z PROC		; CvRouteInfo::getYieldChange, COMDAT
; _this$ = ecx

; 4251 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 4252 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4253 : 	return m_piYieldChange ? m_piYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+284]
	test	eax, eax
	je	SHORT $LN3@getYieldCh@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4254 : }

	ret	4
$LN3@getYieldCh@2:

; 4251 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 4252 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4253 : 	return m_piYieldChange ? m_piYieldChange[i] : -1;

	or	eax, -1

; 4254 : }

	ret	4
?getYieldChange@CvRouteInfo@@QBEHH@Z ENDP		; CvRouteInfo::getYieldChange
_TEXT	ENDS
PUBLIC	?getTechMovementChange@CvRouteInfo@@QBEHH@Z	; CvRouteInfo::getTechMovementChange
; Function compile flags: /Ogtpy
;	COMDAT ?getTechMovementChange@CvRouteInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getTechMovementChange@CvRouteInfo@@QBEHH@Z PROC	; CvRouteInfo::getTechMovementChange, COMDAT
; _this$ = ecx

; 4258 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 4259 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4260 : 	return m_piTechMovementChange ? m_piTechMovementChange[i] : -1;

	mov	eax, DWORD PTR [ecx+288]
	test	eax, eax
	je	SHORT $LN3@getTechMov
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4261 : }

	ret	4
$LN3@getTechMov:

; 4258 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 4259 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4260 : 	return m_piTechMovementChange ? m_piTechMovementChange[i] : -1;

	or	eax, -1

; 4261 : }

	ret	4
?getTechMovementChange@CvRouteInfo@@QBEHH@Z ENDP	; CvRouteInfo::getTechMovementChange
_TEXT	ENDS
PUBLIC	?getResourceQuantityRequirement@CvRouteInfo@@QBEHH@Z ; CvRouteInfo::getResourceQuantityRequirement
; Function compile flags: /Ogtpy
;	COMDAT ?getResourceQuantityRequirement@CvRouteInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getResourceQuantityRequirement@CvRouteInfo@@QBEHH@Z PROC ; CvRouteInfo::getResourceQuantityRequirement, COMDAT
; _this$ = ecx

; 4265 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 4266 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4267 : 	return m_piResourceQuantityRequirements ? m_piResourceQuantityRequirements[i] : -1;

	mov	eax, DWORD PTR [ecx+292]
	test	eax, eax
	je	SHORT $LN3@getResourc
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4268 : }

	ret	4
$LN3@getResourc:

; 4265 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 4266 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4267 : 	return m_piResourceQuantityRequirements ? m_piResourceQuantityRequirements[i] : -1;

	or	eax, -1

; 4268 : }

	ret	4
?getResourceQuantityRequirement@CvRouteInfo@@QBEHH@Z ENDP ; CvRouteInfo::getResourceQuantityRequirement
_TEXT	ENDS
PUBLIC	?getUniqueRange@CvResourceClassInfo@@QBEHXZ	; CvResourceClassInfo::getUniqueRange
; Function compile flags: /Ogtpy
;	COMDAT ?getUniqueRange@CvResourceClassInfo@@QBEHXZ
_TEXT	SEGMENT
?getUniqueRange@CvResourceClassInfo@@QBEHXZ PROC	; CvResourceClassInfo::getUniqueRange, COMDAT
; _this$ = ecx

; 4303 : 	return m_iUniqueRange;

	mov	eax, DWORD PTR [ecx+260]

; 4304 : }

	ret	0
?getUniqueRange@CvResourceClassInfo@@QBEHXZ ENDP	; CvResourceClassInfo::getUniqueRange
_TEXT	ENDS
PUBLIC	?getResourceClassType@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getResourceClassType
; Function compile flags: /Ogtpy
;	COMDAT ?getResourceClassType@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getResourceClassType@CvResourceInfo@@QBEHXZ PROC	; CvResourceInfo::getResourceClassType, COMDAT
; _this$ = ecx

; 4388 : 	return m_iResourceClassType;

	mov	eax, DWORD PTR [ecx+260]

; 4389 : }

	ret	0
?getResourceClassType@CvResourceInfo@@QBEHXZ ENDP	; CvResourceInfo::getResourceClassType
_TEXT	ENDS
PUBLIC	?getChar@CvResourceInfo@@QBEHXZ			; CvResourceInfo::getChar
; Function compile flags: /Ogtpy
;	COMDAT ?getChar@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getChar@CvResourceInfo@@QBEHXZ PROC			; CvResourceInfo::getChar, COMDAT
; _this$ = ecx

; 4393 : 	return m_iChar;

	mov	eax, DWORD PTR [ecx+264]

; 4394 : }

	ret	0
?getChar@CvResourceInfo@@QBEHXZ ENDP			; CvResourceInfo::getChar
_TEXT	ENDS
PUBLIC	?setChar@CvResourceInfo@@QAEXH@Z		; CvResourceInfo::setChar
; Function compile flags: /Ogtpy
;	COMDAT ?setChar@CvResourceInfo@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?setChar@CvResourceInfo@@QAEXH@Z PROC			; CvResourceInfo::setChar, COMDAT
; _this$ = ecx

; 4398 : 	m_iChar = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+264], eax

; 4399 : }

	ret	4
?setChar@CvResourceInfo@@QAEXH@Z ENDP			; CvResourceInfo::setChar
_TEXT	ENDS
PUBLIC	?getTechReveal@CvResourceInfo@@QBEHXZ		; CvResourceInfo::getTechReveal
; Function compile flags: /Ogtpy
;	COMDAT ?getTechReveal@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getTechReveal@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getTechReveal, COMDAT
; _this$ = ecx

; 4403 : 	return m_iTechReveal;

	mov	eax, DWORD PTR [ecx+268]

; 4404 : }

	ret	0
?getTechReveal@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getTechReveal
_TEXT	ENDS
PUBLIC	?getPolicyReveal@CvResourceInfo@@QBEHXZ		; CvResourceInfo::getPolicyReveal
; Function compile flags: /Ogtpy
;	COMDAT ?getPolicyReveal@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getPolicyReveal@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getPolicyReveal, COMDAT
; _this$ = ecx

; 4408 : 	return m_iPolicyReveal;

	mov	eax, DWORD PTR [ecx+272]

; 4409 : }

	ret	0
?getPolicyReveal@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getPolicyReveal
_TEXT	ENDS
PUBLIC	?getTechCityTrade@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechCityTrade
; Function compile flags: /Ogtpy
;	COMDAT ?getTechCityTrade@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getTechCityTrade@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getTechCityTrade, COMDAT
; _this$ = ecx

; 4413 : 	return m_iTechCityTrade;

	mov	eax, DWORD PTR [ecx+276]

; 4414 : }

	ret	0
?getTechCityTrade@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getTechCityTrade
_TEXT	ENDS
PUBLIC	?getTechObsolete@CvResourceInfo@@QBEHXZ		; CvResourceInfo::getTechObsolete
; Function compile flags: /Ogtpy
;	COMDAT ?getTechObsolete@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getTechObsolete@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getTechObsolete, COMDAT
; _this$ = ecx

; 4418 : 	return m_iTechObsolete;

	mov	eax, DWORD PTR [ecx+280]

; 4419 : }

	ret	0
?getTechObsolete@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getTechObsolete
_TEXT	ENDS
PUBLIC	?getAIStopTradingEra@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getAIStopTradingEra
; Function compile flags: /Ogtpy
;	COMDAT ?getAIStopTradingEra@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIStopTradingEra@CvResourceInfo@@QBEHXZ PROC	; CvResourceInfo::getAIStopTradingEra, COMDAT
; _this$ = ecx

; 4423 : 	return m_iAIStopTradingEra;

	mov	eax, DWORD PTR [ecx+284]

; 4424 : }

	ret	0
?getAIStopTradingEra@CvResourceInfo@@QBEHXZ ENDP	; CvResourceInfo::getAIStopTradingEra
_TEXT	ENDS
PUBLIC	?getStartingResourceQuantity@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getStartingResourceQuantity
; Function compile flags: /Ogtpy
;	COMDAT ?getStartingResourceQuantity@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartingResourceQuantity@CvResourceInfo@@QBEHXZ PROC ; CvResourceInfo::getStartingResourceQuantity, COMDAT
; _this$ = ecx

; 4428 : 	return m_iStartingResourceQuantity;

	mov	eax, DWORD PTR [ecx+288]

; 4429 : }

	ret	0
?getStartingResourceQuantity@CvResourceInfo@@QBEHXZ ENDP ; CvResourceInfo::getStartingResourceQuantity
_TEXT	ENDS
PUBLIC	?getAITradeModifier@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getAITradeModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getAITradeModifier@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getAITradeModifier@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getAITradeModifier, COMDAT
; _this$ = ecx

; 4433 : 	return m_iAITradeModifier;

	mov	eax, DWORD PTR [ecx+292]

; 4434 : }

	ret	0
?getAITradeModifier@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getAITradeModifier
_TEXT	ENDS
PUBLIC	?getAIObjective@CvResourceInfo@@QBEHXZ		; CvResourceInfo::getAIObjective
; Function compile flags: /Ogtpy
;	COMDAT ?getAIObjective@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIObjective@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getAIObjective, COMDAT
; _this$ = ecx

; 4438 : 	return m_iAIObjective;

	mov	eax, DWORD PTR [ecx+296]

; 4439 : }

	ret	0
?getAIObjective@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getAIObjective
_TEXT	ENDS
PUBLIC	?getHappiness@CvResourceInfo@@QBEHXZ		; CvResourceInfo::getHappiness
; Function compile flags: /Ogtpy
;	COMDAT ?getHappiness@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getHappiness@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getHappiness, COMDAT
; _this$ = ecx

; 4443 : 	return m_iHappiness;

	mov	eax, DWORD PTR [ecx+300]

; 4444 : }

	ret	0
?getHappiness@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getHappiness
_TEXT	ENDS
PUBLIC	?getWonderProductionMod@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getWonderProductionMod
; Function compile flags: /Ogtpy
;	COMDAT ?getWonderProductionMod@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getWonderProductionMod@CvResourceInfo@@QBEHXZ PROC	; CvResourceInfo::getWonderProductionMod, COMDAT
; _this$ = ecx

; 4448 : 	return m_iWonderProductionMod;

	mov	eax, DWORD PTR [ecx+304]

; 4449 : }

	ret	0
?getWonderProductionMod@CvResourceInfo@@QBEHXZ ENDP	; CvResourceInfo::getWonderProductionMod
_TEXT	ENDS
PUBLIC	?getWonderProductionModObsoleteEra@CvResourceInfo@@QBE?AW4EraTypes@@XZ ; CvResourceInfo::getWonderProductionModObsoleteEra
; Function compile flags: /Ogtpy
;	COMDAT ?getWonderProductionModObsoleteEra@CvResourceInfo@@QBE?AW4EraTypes@@XZ
_TEXT	SEGMENT
?getWonderProductionModObsoleteEra@CvResourceInfo@@QBE?AW4EraTypes@@XZ PROC ; CvResourceInfo::getWonderProductionModObsoleteEra, COMDAT
; _this$ = ecx

; 4453 : 	return m_eWonderProductionModObsoleteEra;

	mov	eax, DWORD PTR [ecx+384]

; 4454 : }

	ret	0
?getWonderProductionModObsoleteEra@CvResourceInfo@@QBE?AW4EraTypes@@XZ ENDP ; CvResourceInfo::getWonderProductionModObsoleteEra
_TEXT	ENDS
PUBLIC	?getMinAreaSize@CvResourceInfo@@QBEHXZ		; CvResourceInfo::getMinAreaSize
; Function compile flags: /Ogtpy
;	COMDAT ?getMinAreaSize@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getMinAreaSize@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getMinAreaSize, COMDAT
; _this$ = ecx

; 4458 : 	return m_iMinAreaSize;

	mov	eax, DWORD PTR [ecx+308]

; 4459 : }

	ret	0
?getMinAreaSize@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getMinAreaSize
_TEXT	ENDS
PUBLIC	?getMinLatitude@CvResourceInfo@@QBEHXZ		; CvResourceInfo::getMinLatitude
; Function compile flags: /Ogtpy
;	COMDAT ?getMinLatitude@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getMinLatitude@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getMinLatitude, COMDAT
; _this$ = ecx

; 4463 : 	return m_iMinLatitude;

	mov	eax, DWORD PTR [ecx+312]

; 4464 : }

	ret	0
?getMinLatitude@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getMinLatitude
_TEXT	ENDS
PUBLIC	?getMaxLatitude@CvResourceInfo@@QBEHXZ		; CvResourceInfo::getMaxLatitude
; Function compile flags: /Ogtpy
;	COMDAT ?getMaxLatitude@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getMaxLatitude@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getMaxLatitude, COMDAT
; _this$ = ecx

; 4468 : 	return m_iMaxLatitude;

	mov	eax, DWORD PTR [ecx+316]

; 4469 : }

	ret	0
?getMaxLatitude@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getMaxLatitude
_TEXT	ENDS
PUBLIC	?getPlacementOrder@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPlacementOrder
; Function compile flags: /Ogtpy
;	COMDAT ?getPlacementOrder@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getPlacementOrder@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getPlacementOrder, COMDAT
; _this$ = ecx

; 4473 : 	return m_iPlacementOrder;

	mov	eax, DWORD PTR [ecx+320]

; 4474 : }

	ret	0
?getPlacementOrder@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getPlacementOrder
_TEXT	ENDS
PUBLIC	?getConstAppearance@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getConstAppearance
; Function compile flags: /Ogtpy
;	COMDAT ?getConstAppearance@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getConstAppearance@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getConstAppearance, COMDAT
; _this$ = ecx

; 4478 : 	return m_iConstAppearance;

	mov	eax, DWORD PTR [ecx+324]

; 4479 : }

	ret	0
?getConstAppearance@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getConstAppearance
_TEXT	ENDS
PUBLIC	?getRandAppearance1@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getRandAppearance1
; Function compile flags: /Ogtpy
;	COMDAT ?getRandAppearance1@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getRandAppearance1@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getRandAppearance1, COMDAT
; _this$ = ecx

; 4483 : 	return m_iRandAppearance1;

	mov	eax, DWORD PTR [ecx+328]

; 4484 : }

	ret	0
?getRandAppearance1@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getRandAppearance1
_TEXT	ENDS
PUBLIC	?getRandAppearance2@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getRandAppearance2
; Function compile flags: /Ogtpy
;	COMDAT ?getRandAppearance2@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getRandAppearance2@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getRandAppearance2, COMDAT
; _this$ = ecx

; 4488 : 	return m_iRandAppearance2;

	mov	eax, DWORD PTR [ecx+332]

; 4489 : }

	ret	0
?getRandAppearance2@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getRandAppearance2
_TEXT	ENDS
PUBLIC	?getRandAppearance3@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getRandAppearance3
; Function compile flags: /Ogtpy
;	COMDAT ?getRandAppearance3@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getRandAppearance3@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getRandAppearance3, COMDAT
; _this$ = ecx

; 4493 : 	return m_iRandAppearance3;

	mov	eax, DWORD PTR [ecx+336]

; 4494 : }

	ret	0
?getRandAppearance3@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getRandAppearance3
_TEXT	ENDS
PUBLIC	?getRandAppearance4@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getRandAppearance4
; Function compile flags: /Ogtpy
;	COMDAT ?getRandAppearance4@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getRandAppearance4@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getRandAppearance4, COMDAT
; _this$ = ecx

; 4498 : 	return m_iRandAppearance4;

	mov	eax, DWORD PTR [ecx+340]

; 4499 : }

	ret	0
?getRandAppearance4@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getRandAppearance4
_TEXT	ENDS
PUBLIC	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
; Function compile flags: /Ogtpy
;	COMDAT ?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ
_TEXT	SEGMENT
?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ PROC ; CvResourceInfo::getResourceUsage, COMDAT
; _this$ = ecx

; 4503 : 	return m_eResourceUsage;

	mov	eax, DWORD PTR [ecx+380]

; 4504 : }

	ret	0
?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ENDP ; CvResourceInfo::getResourceUsage
_TEXT	ENDS
PUBLIC	?getPercentPerPlayer@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPercentPerPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?getPercentPerPlayer@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getPercentPerPlayer@CvResourceInfo@@QBEHXZ PROC	; CvResourceInfo::getPercentPerPlayer, COMDAT
; _this$ = ecx

; 4508 : 	return m_iPercentPerPlayer;

	mov	eax, DWORD PTR [ecx+344]

; 4509 : }

	ret	0
?getPercentPerPlayer@CvResourceInfo@@QBEHXZ ENDP	; CvResourceInfo::getPercentPerPlayer
_TEXT	ENDS
PUBLIC	?getTilesPer@CvResourceInfo@@QBEHXZ		; CvResourceInfo::getTilesPer
; Function compile flags: /Ogtpy
;	COMDAT ?getTilesPer@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getTilesPer@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getTilesPer, COMDAT
; _this$ = ecx

; 4513 : 	return m_iTilesPer;

	mov	eax, DWORD PTR [ecx+348]

; 4514 : }

	ret	0
?getTilesPer@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getTilesPer
_TEXT	ENDS
PUBLIC	?getMinLandPercent@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getMinLandPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getMinLandPercent@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getMinLandPercent@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getMinLandPercent, COMDAT
; _this$ = ecx

; 4518 : 	return m_iMinLandPercent;

	mov	eax, DWORD PTR [ecx+352]

; 4519 : }

	ret	0
?getMinLandPercent@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getMinLandPercent
_TEXT	ENDS
PUBLIC	?getUniqueRange@CvResourceInfo@@QBEHXZ		; CvResourceInfo::getUniqueRange
; Function compile flags: /Ogtpy
;	COMDAT ?getUniqueRange@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getUniqueRange@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getUniqueRange, COMDAT
; _this$ = ecx

; 4523 : 	return m_iUniqueRange;

	mov	eax, DWORD PTR [ecx+356]

; 4524 : }

	ret	0
?getUniqueRange@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getUniqueRange
_TEXT	ENDS
PUBLIC	?getGroupRange@CvResourceInfo@@QBEHXZ		; CvResourceInfo::getGroupRange
; Function compile flags: /Ogtpy
;	COMDAT ?getGroupRange@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getGroupRange@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getGroupRange, COMDAT
; _this$ = ecx

; 4528 : 	return m_iGroupRange;

	mov	eax, DWORD PTR [ecx+360]

; 4529 : }

	ret	0
?getGroupRange@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getGroupRange
_TEXT	ENDS
PUBLIC	?getGroupRand@CvResourceInfo@@QBEHXZ		; CvResourceInfo::getGroupRand
; Function compile flags: /Ogtpy
;	COMDAT ?getGroupRand@CvResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getGroupRand@CvResourceInfo@@QBEHXZ PROC		; CvResourceInfo::getGroupRand, COMDAT
; _this$ = ecx

; 4533 : 	return m_iGroupRand;

	mov	eax, DWORD PTR [ecx+364]

; 4534 : }

	ret	0
?getGroupRand@CvResourceInfo@@QBEHXZ ENDP		; CvResourceInfo::getGroupRand
_TEXT	ENDS
PUBLIC	?isPresentOnAllValidPlots@CvResourceInfo@@QBE_NXZ ; CvResourceInfo::isPresentOnAllValidPlots
; Function compile flags: /Ogtpy
;	COMDAT ?isPresentOnAllValidPlots@CvResourceInfo@@QBE_NXZ
_TEXT	SEGMENT
?isPresentOnAllValidPlots@CvResourceInfo@@QBE_NXZ PROC	; CvResourceInfo::isPresentOnAllValidPlots, COMDAT
; _this$ = ecx

; 4538 : 	return m_bPresentOnAllValidPlots;

	mov	al, BYTE PTR [ecx+368]

; 4539 : }

	ret	0
?isPresentOnAllValidPlots@CvResourceInfo@@QBE_NXZ ENDP	; CvResourceInfo::isPresentOnAllValidPlots
_TEXT	ENDS
PUBLIC	?isOneArea@CvResourceInfo@@QBE_NXZ		; CvResourceInfo::isOneArea
; Function compile flags: /Ogtpy
;	COMDAT ?isOneArea@CvResourceInfo@@QBE_NXZ
_TEXT	SEGMENT
?isOneArea@CvResourceInfo@@QBE_NXZ PROC			; CvResourceInfo::isOneArea, COMDAT
; _this$ = ecx

; 4543 : 	return m_bOneArea;

	mov	al, BYTE PTR [ecx+369]

; 4544 : }

	ret	0
?isOneArea@CvResourceInfo@@QBE_NXZ ENDP			; CvResourceInfo::isOneArea
_TEXT	ENDS
PUBLIC	?isHills@CvResourceInfo@@QBE_NXZ		; CvResourceInfo::isHills
; Function compile flags: /Ogtpy
;	COMDAT ?isHills@CvResourceInfo@@QBE_NXZ
_TEXT	SEGMENT
?isHills@CvResourceInfo@@QBE_NXZ PROC			; CvResourceInfo::isHills, COMDAT
; _this$ = ecx

; 4548 : 	return m_bHills;

	mov	al, BYTE PTR [ecx+370]

; 4549 : }

	ret	0
?isHills@CvResourceInfo@@QBE_NXZ ENDP			; CvResourceInfo::isHills
_TEXT	ENDS
PUBLIC	?isFlatlands@CvResourceInfo@@QBE_NXZ		; CvResourceInfo::isFlatlands
; Function compile flags: /Ogtpy
;	COMDAT ?isFlatlands@CvResourceInfo@@QBE_NXZ
_TEXT	SEGMENT
?isFlatlands@CvResourceInfo@@QBE_NXZ PROC		; CvResourceInfo::isFlatlands, COMDAT
; _this$ = ecx

; 4553 : 	return m_bFlatlands;

	mov	al, BYTE PTR [ecx+371]

; 4554 : }

	ret	0
?isFlatlands@CvResourceInfo@@QBE_NXZ ENDP		; CvResourceInfo::isFlatlands
_TEXT	ENDS
PUBLIC	?isNoRiverSide@CvResourceInfo@@QBE_NXZ		; CvResourceInfo::isNoRiverSide
; Function compile flags: /Ogtpy
;	COMDAT ?isNoRiverSide@CvResourceInfo@@QBE_NXZ
_TEXT	SEGMENT
?isNoRiverSide@CvResourceInfo@@QBE_NXZ PROC		; CvResourceInfo::isNoRiverSide, COMDAT
; _this$ = ecx

; 4558 : 	return m_bNoRiverSide;

	mov	al, BYTE PTR [ecx+372]

; 4559 : }

	ret	0
?isNoRiverSide@CvResourceInfo@@QBE_NXZ ENDP		; CvResourceInfo::isNoRiverSide
_TEXT	ENDS
PUBLIC	?isNormalize@CvResourceInfo@@QBE_NXZ		; CvResourceInfo::isNormalize
; Function compile flags: /Ogtpy
;	COMDAT ?isNormalize@CvResourceInfo@@QBE_NXZ
_TEXT	SEGMENT
?isNormalize@CvResourceInfo@@QBE_NXZ PROC		; CvResourceInfo::isNormalize, COMDAT
; _this$ = ecx

; 4563 : 	return m_bNormalize;

	mov	al, BYTE PTR [ecx+373]

; 4564 : }

	ret	0
?isNormalize@CvResourceInfo@@QBE_NXZ ENDP		; CvResourceInfo::isNormalize
_TEXT	ENDS
PUBLIC	?isOnlyMinorCivs@CvResourceInfo@@QBE_NXZ	; CvResourceInfo::isOnlyMinorCivs
; Function compile flags: /Ogtpy
;	COMDAT ?isOnlyMinorCivs@CvResourceInfo@@QBE_NXZ
_TEXT	SEGMENT
?isOnlyMinorCivs@CvResourceInfo@@QBE_NXZ PROC		; CvResourceInfo::isOnlyMinorCivs, COMDAT
; _this$ = ecx

; 4568 : 	return m_bOnlyMinorCivs;

	mov	al, BYTE PTR [ecx+374]

; 4569 : }

	ret	0
?isOnlyMinorCivs@CvResourceInfo@@QBE_NXZ ENDP		; CvResourceInfo::isOnlyMinorCivs
_TEXT	ENDS
PUBLIC	?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ ; CvResourceInfo::GetRequiredCivilization
; Function compile flags: /Ogtpy
;	COMDAT ?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ
_TEXT	SEGMENT
?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ PROC ; CvResourceInfo::GetRequiredCivilization, COMDAT
; _this$ = ecx

; 4573 : 	return m_eRequiredCivilization;

	mov	eax, DWORD PTR [ecx+376]

; 4574 : }

	ret	0
?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ ENDP ; CvResourceInfo::GetRequiredCivilization
_TEXT	ENDS
PUBLIC	?getYieldChange@CvResourceInfo@@QBEHH@Z		; CvResourceInfo::getYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?getYieldChange@CvResourceInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getYieldChange@CvResourceInfo@@QBEHH@Z PROC		; CvResourceInfo::getYieldChange, COMDAT
; _this$ = ecx

; 4628 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 4629 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4630 : 	return m_piYieldChange ? m_piYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+528]
	test	eax, eax
	je	SHORT $LN3@getYieldCh@3
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4631 : }

	ret	4
$LN3@getYieldCh@3:

; 4628 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 4629 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4630 : 	return m_piYieldChange ? m_piYieldChange[i] : -1;

	or	eax, -1

; 4631 : }

	ret	4
?getYieldChange@CvResourceInfo@@QBEHH@Z ENDP		; CvResourceInfo::getYieldChange
_TEXT	ENDS
PUBLIC	?getYieldChangeArray@CvResourceInfo@@QAEPAHXZ	; CvResourceInfo::getYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?getYieldChangeArray@CvResourceInfo@@QAEPAHXZ
_TEXT	SEGMENT
?getYieldChangeArray@CvResourceInfo@@QAEPAHXZ PROC	; CvResourceInfo::getYieldChangeArray, COMDAT
; _this$ = ecx

; 4635 : 	return m_piYieldChange;

	mov	eax, DWORD PTR [ecx+528]

; 4636 : }

	ret	0
?getYieldChangeArray@CvResourceInfo@@QAEPAHXZ ENDP	; CvResourceInfo::getYieldChangeArray
_TEXT	ENDS
PUBLIC	?getResourceQuantityType@CvResourceInfo@@QBEHH@Z ; CvResourceInfo::getResourceQuantityType
; Function compile flags: /Ogtpy
;	COMDAT ?getResourceQuantityType@CvResourceInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getResourceQuantityType@CvResourceInfo@@QBEHH@Z PROC	; CvResourceInfo::getResourceQuantityType, COMDAT
; _this$ = ecx

; 4751 : 	CvAssertMsg(i < GC.getNUM_RESOURCE_QUANTITY_TYPES(), "Index out of bounds");
; 4752 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4753 : 	return m_piResourceQuantityTypes ? m_piResourceQuantityTypes[i] : -1;

	mov	eax, DWORD PTR [ecx+560]
	test	eax, eax
	je	SHORT $LN3@getResourc@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4754 : }

	ret	4
$LN3@getResourc@2:

; 4751 : 	CvAssertMsg(i < GC.getNUM_RESOURCE_QUANTITY_TYPES(), "Index out of bounds");
; 4752 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4753 : 	return m_piResourceQuantityTypes ? m_piResourceQuantityTypes[i] : -1;

	or	eax, -1

; 4754 : }

	ret	4
?getResourceQuantityType@CvResourceInfo@@QBEHH@Z ENDP	; CvResourceInfo::getResourceQuantityType
_TEXT	ENDS
PUBLIC	?getImprovementChange@CvResourceInfo@@QBEHH@Z	; CvResourceInfo::getImprovementChange
; Function compile flags: /Ogtpy
;	COMDAT ?getImprovementChange@CvResourceInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getImprovementChange@CvResourceInfo@@QBEHH@Z PROC	; CvResourceInfo::getImprovementChange, COMDAT
; _this$ = ecx

; 4758 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 4759 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4760 : 	return m_piImprovementChange ? m_piImprovementChange[i] : -1;

	mov	eax, DWORD PTR [ecx+564]
	test	eax, eax
	je	SHORT $LN3@getImprove
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4761 : }

	ret	4
$LN3@getImprove:

; 4758 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 4759 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4760 : 	return m_piImprovementChange ? m_piImprovementChange[i] : -1;

	or	eax, -1

; 4761 : }

	ret	4
?getImprovementChange@CvResourceInfo@@QBEHH@Z ENDP	; CvResourceInfo::getImprovementChange
_TEXT	ENDS
PUBLIC	?isTerrain@CvResourceInfo@@QBE_NH@Z		; CvResourceInfo::isTerrain
; Function compile flags: /Ogtpy
;	COMDAT ?isTerrain@CvResourceInfo@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?isTerrain@CvResourceInfo@@QBE_NH@Z PROC		; CvResourceInfo::isTerrain, COMDAT
; _this$ = ecx

; 4765 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 4766 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4767 : 	return m_pbTerrain ?	m_pbTerrain[i] : false;

	mov	eax, DWORD PTR [ecx+572]
	test	eax, eax
	je	SHORT $LN3@isTerrain
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 4768 : }

	ret	4
$LN3@isTerrain:

; 4765 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 4766 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4767 : 	return m_pbTerrain ?	m_pbTerrain[i] : false;

	xor	al, al

; 4768 : }

	ret	4
?isTerrain@CvResourceInfo@@QBE_NH@Z ENDP		; CvResourceInfo::isTerrain
_TEXT	ENDS
PUBLIC	?isFeature@CvResourceInfo@@QBE_NH@Z		; CvResourceInfo::isFeature
; Function compile flags: /Ogtpy
;	COMDAT ?isFeature@CvResourceInfo@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?isFeature@CvResourceInfo@@QBE_NH@Z PROC		; CvResourceInfo::isFeature, COMDAT
; _this$ = ecx

; 4772 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 4773 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4774 : 	return m_pbFeature ? m_pbFeature[i] : false;

	mov	eax, DWORD PTR [ecx+576]
	test	eax, eax
	je	SHORT $LN3@isFeature
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 4775 : }

	ret	4
$LN3@isFeature:

; 4772 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 4773 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4774 : 	return m_pbFeature ? m_pbFeature[i] : false;

	xor	al, al

; 4775 : }

	ret	4
?isFeature@CvResourceInfo@@QBE_NH@Z ENDP		; CvResourceInfo::isFeature
_TEXT	ENDS
PUBLIC	?isFeatureTerrain@CvResourceInfo@@QBE_NH@Z	; CvResourceInfo::isFeatureTerrain
; Function compile flags: /Ogtpy
;	COMDAT ?isFeatureTerrain@CvResourceInfo@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?isFeatureTerrain@CvResourceInfo@@QBE_NH@Z PROC		; CvResourceInfo::isFeatureTerrain, COMDAT
; _this$ = ecx

; 4779 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 4780 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4781 : 	return m_pbFeatureTerrain ?	m_pbFeatureTerrain[i] : false;

	mov	eax, DWORD PTR [ecx+580]
	test	eax, eax
	je	SHORT $LN3@isFeatureT
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 4782 : }

	ret	4
$LN3@isFeatureT:

; 4779 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 4780 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 4781 : 	return m_pbFeatureTerrain ?	m_pbFeatureTerrain[i] : false;

	xor	al, al

; 4782 : }

	ret	4
?isFeatureTerrain@CvResourceInfo@@QBE_NH@Z ENDP		; CvResourceInfo::isFeatureTerrain
_TEXT	ENDS
PUBLIC	?getFlavorValue@CvResourceInfo@@QBEHH@Z		; CvResourceInfo::getFlavorValue
; Function compile flags: /Ogtpy
;	COMDAT ?getFlavorValue@CvResourceInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getFlavorValue@CvResourceInfo@@QBEHH@Z PROC		; CvResourceInfo::getFlavorValue, COMDAT
; _this$ = ecx

; 4786 : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "index out of bounds");
; 4787 : 	CvAssertMsg(i > -1, "index out of bounds");
; 4788 : 	return m_piFlavor[i];

	mov	eax, DWORD PTR [ecx+568]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4789 : }

	ret	4
?getFlavorValue@CvResourceInfo@@QBEHH@Z ENDP		; CvResourceInfo::getFlavorValue
_TEXT	ENDS
PUBLIC	?getStartingLocationWeight@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getStartingLocationWeight
; Function compile flags: /Ogtpy
;	COMDAT ?getStartingLocationWeight@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartingLocationWeight@CvFeatureInfo@@QBEHXZ PROC	; CvFeatureInfo::getStartingLocationWeight, COMDAT
; _this$ = ecx

; 5028 : 	return m_iStartingLocationWeight;

	mov	eax, DWORD PTR [ecx+260]

; 5029 : }

	ret	0
?getStartingLocationWeight@CvFeatureInfo@@QBEHXZ ENDP	; CvFeatureInfo::getStartingLocationWeight
_TEXT	ENDS
PUBLIC	?getMovementCost@CvFeatureInfo@@QBEHXZ		; CvFeatureInfo::getMovementCost
; Function compile flags: /Ogtpy
;	COMDAT ?getMovementCost@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getMovementCost@CvFeatureInfo@@QBEHXZ PROC		; CvFeatureInfo::getMovementCost, COMDAT
; _this$ = ecx

; 5033 : 	return m_iMovementCost;

	mov	eax, DWORD PTR [ecx+264]

; 5034 : }

	ret	0
?getMovementCost@CvFeatureInfo@@QBEHXZ ENDP		; CvFeatureInfo::getMovementCost
_TEXT	ENDS
PUBLIC	?getSeeThroughChange@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getSeeThroughChange
; Function compile flags: /Ogtpy
;	COMDAT ?getSeeThroughChange@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getSeeThroughChange@CvFeatureInfo@@QBEHXZ PROC		; CvFeatureInfo::getSeeThroughChange, COMDAT
; _this$ = ecx

; 5038 : 	return m_iSeeThroughChange;

	mov	eax, DWORD PTR [ecx+268]

; 5039 : }

	ret	0
?getSeeThroughChange@CvFeatureInfo@@QBEHXZ ENDP		; CvFeatureInfo::getSeeThroughChange
_TEXT	ENDS
PUBLIC	?getAppearanceProbability@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getAppearanceProbability
; Function compile flags: /Ogtpy
;	COMDAT ?getAppearanceProbability@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getAppearanceProbability@CvFeatureInfo@@QBEHXZ PROC	; CvFeatureInfo::getAppearanceProbability, COMDAT
; _this$ = ecx

; 5043 : 	return m_iAppearanceProbability;

	mov	eax, DWORD PTR [ecx+272]

; 5044 : }

	ret	0
?getAppearanceProbability@CvFeatureInfo@@QBEHXZ ENDP	; CvFeatureInfo::getAppearanceProbability
_TEXT	ENDS
PUBLIC	?getDisappearanceProbability@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getDisappearanceProbability
; Function compile flags: /Ogtpy
;	COMDAT ?getDisappearanceProbability@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getDisappearanceProbability@CvFeatureInfo@@QBEHXZ PROC	; CvFeatureInfo::getDisappearanceProbability, COMDAT
; _this$ = ecx

; 5048 : 	return m_iDisappearanceProbability;

	mov	eax, DWORD PTR [ecx+276]

; 5049 : }

	ret	0
?getDisappearanceProbability@CvFeatureInfo@@QBEHXZ ENDP	; CvFeatureInfo::getDisappearanceProbability
_TEXT	ENDS
PUBLIC	?getGrowthProbability@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getGrowthProbability
; Function compile flags: /Ogtpy
;	COMDAT ?getGrowthProbability@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getGrowthProbability@CvFeatureInfo@@QBEHXZ PROC	; CvFeatureInfo::getGrowthProbability, COMDAT
; _this$ = ecx

; 5053 : 	return m_iGrowthProbability;

	mov	eax, DWORD PTR [ecx+280]

; 5054 : }

	ret	0
?getGrowthProbability@CvFeatureInfo@@QBEHXZ ENDP	; CvFeatureInfo::getGrowthProbability
_TEXT	ENDS
PUBLIC	?getGrowthTerrainType@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getGrowthTerrainType
; Function compile flags: /Ogtpy
;	COMDAT ?getGrowthTerrainType@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getGrowthTerrainType@CvFeatureInfo@@QBEHXZ PROC	; CvFeatureInfo::getGrowthTerrainType, COMDAT
; _this$ = ecx

; 5058 : 	return m_iGrowthTerrainType;

	mov	eax, DWORD PTR [ecx+284]

; 5059 : }

	ret	0
?getGrowthTerrainType@CvFeatureInfo@@QBEHXZ ENDP	; CvFeatureInfo::getGrowthTerrainType
_TEXT	ENDS
PUBLIC	?getDefenseModifier@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getDefenseModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getDefenseModifier@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getDefenseModifier@CvFeatureInfo@@QBEHXZ PROC		; CvFeatureInfo::getDefenseModifier, COMDAT
; _this$ = ecx

; 5063 : 	return m_iDefenseModifier;

	mov	eax, DWORD PTR [ecx+288]

; 5064 : }

	ret	0
?getDefenseModifier@CvFeatureInfo@@QBEHXZ ENDP		; CvFeatureInfo::getDefenseModifier
_TEXT	ENDS
PUBLIC	?getInfluenceCost@CvFeatureInfo@@QBEHXZ		; CvFeatureInfo::getInfluenceCost
; Function compile flags: /Ogtpy
;	COMDAT ?getInfluenceCost@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getInfluenceCost@CvFeatureInfo@@QBEHXZ PROC		; CvFeatureInfo::getInfluenceCost, COMDAT
; _this$ = ecx

; 5068 : 	return m_iInfluenceCost;

	mov	eax, DWORD PTR [ecx+292]

; 5069 : }

	ret	0
?getInfluenceCost@CvFeatureInfo@@QBEHXZ ENDP		; CvFeatureInfo::getInfluenceCost
_TEXT	ENDS
PUBLIC	?getAdvancedStartRemoveCost@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getAdvancedStartRemoveCost
; Function compile flags: /Ogtpy
;	COMDAT ?getAdvancedStartRemoveCost@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getAdvancedStartRemoveCost@CvFeatureInfo@@QBEHXZ PROC	; CvFeatureInfo::getAdvancedStartRemoveCost, COMDAT
; _this$ = ecx

; 5073 : 	return m_iAdvancedStartRemoveCost;

	mov	eax, DWORD PTR [ecx+296]

; 5074 : }

	ret	0
?getAdvancedStartRemoveCost@CvFeatureInfo@@QBEHXZ ENDP	; CvFeatureInfo::getAdvancedStartRemoveCost
_TEXT	ENDS
PUBLIC	?getTurnDamage@CvFeatureInfo@@QBEHXZ		; CvFeatureInfo::getTurnDamage
; Function compile flags: /Ogtpy
;	COMDAT ?getTurnDamage@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getTurnDamage@CvFeatureInfo@@QBEHXZ PROC		; CvFeatureInfo::getTurnDamage, COMDAT
; _this$ = ecx

; 5078 : 	return m_iTurnDamage;

	mov	eax, DWORD PTR [ecx+300]

; 5079 : }

	ret	0
?getTurnDamage@CvFeatureInfo@@QBEHXZ ENDP		; CvFeatureInfo::getTurnDamage
_TEXT	ENDS
PUBLIC	?getFirstFinderGold@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getFirstFinderGold
; Function compile flags: /Ogtpy
;	COMDAT ?getFirstFinderGold@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getFirstFinderGold@CvFeatureInfo@@QBEHXZ PROC		; CvFeatureInfo::getFirstFinderGold, COMDAT
; _this$ = ecx

; 5083 : 	return m_iFirstFinderGold;

	mov	eax, DWORD PTR [ecx+304]

; 5084 : }

	ret	0
?getFirstFinderGold@CvFeatureInfo@@QBEHXZ ENDP		; CvFeatureInfo::getFirstFinderGold
_TEXT	ENDS
PUBLIC	?getInBorderHappiness@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getInBorderHappiness
; Function compile flags: /Ogtpy
;	COMDAT ?getInBorderHappiness@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getInBorderHappiness@CvFeatureInfo@@QBEHXZ PROC	; CvFeatureInfo::getInBorderHappiness, COMDAT
; _this$ = ecx

; 5088 : 	return m_iInBorderHappiness;

	mov	eax, DWORD PTR [ecx+308]

; 5089 : }

	ret	0
?getInBorderHappiness@CvFeatureInfo@@QBEHXZ ENDP	; CvFeatureInfo::getInBorderHappiness
_TEXT	ENDS
PUBLIC	?getOccurrenceFrequency@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getOccurrenceFrequency
; Function compile flags: /Ogtpy
;	COMDAT ?getOccurrenceFrequency@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getOccurrenceFrequency@CvFeatureInfo@@QBEHXZ PROC	; CvFeatureInfo::getOccurrenceFrequency, COMDAT
; _this$ = ecx

; 5093 : 	return m_iOccurrenceFrequency;

	mov	eax, DWORD PTR [ecx+312]

; 5094 : }

	ret	0
?getOccurrenceFrequency@CvFeatureInfo@@QBEHXZ ENDP	; CvFeatureInfo::getOccurrenceFrequency
_TEXT	ENDS
PUBLIC	?getAdjacentUnitFreePromotion@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getAdjacentUnitFreePromotion
; Function compile flags: /Ogtpy
;	COMDAT ?getAdjacentUnitFreePromotion@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getAdjacentUnitFreePromotion@CvFeatureInfo@@QBEHXZ PROC ; CvFeatureInfo::getAdjacentUnitFreePromotion, COMDAT
; _this$ = ecx

; 5098 : 	return m_iAdjacentUnitFreePromotion;

	mov	eax, DWORD PTR [ecx+316]

; 5099 : }

	ret	0
?getAdjacentUnitFreePromotion@CvFeatureInfo@@QBEHXZ ENDP ; CvFeatureInfo::getAdjacentUnitFreePromotion
_TEXT	ENDS
PUBLIC	?isYieldNotAdditive@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isYieldNotAdditive
; Function compile flags: /Ogtpy
;	COMDAT ?isYieldNotAdditive@CvFeatureInfo@@QBE_NXZ
_TEXT	SEGMENT
?isYieldNotAdditive@CvFeatureInfo@@QBE_NXZ PROC		; CvFeatureInfo::isYieldNotAdditive, COMDAT
; _this$ = ecx

; 5103 : 	return m_bYieldNotAdditive;

	mov	al, BYTE PTR [ecx+320]

; 5104 : }

	ret	0
?isYieldNotAdditive@CvFeatureInfo@@QBE_NXZ ENDP		; CvFeatureInfo::isYieldNotAdditive
_TEXT	ENDS
PUBLIC	?isNoCoast@CvFeatureInfo@@QBE_NXZ		; CvFeatureInfo::isNoCoast
; Function compile flags: /Ogtpy
;	COMDAT ?isNoCoast@CvFeatureInfo@@QBE_NXZ
_TEXT	SEGMENT
?isNoCoast@CvFeatureInfo@@QBE_NXZ PROC			; CvFeatureInfo::isNoCoast, COMDAT
; _this$ = ecx

; 5108 : 	return m_bNoCoast;

	mov	al, BYTE PTR [ecx+321]

; 5109 : }

	ret	0
?isNoCoast@CvFeatureInfo@@QBE_NXZ ENDP			; CvFeatureInfo::isNoCoast
_TEXT	ENDS
PUBLIC	?isNoRiver@CvFeatureInfo@@QBE_NXZ		; CvFeatureInfo::isNoRiver
; Function compile flags: /Ogtpy
;	COMDAT ?isNoRiver@CvFeatureInfo@@QBE_NXZ
_TEXT	SEGMENT
?isNoRiver@CvFeatureInfo@@QBE_NXZ PROC			; CvFeatureInfo::isNoRiver, COMDAT
; _this$ = ecx

; 5113 : 	return m_bNoRiver;

	mov	al, BYTE PTR [ecx+322]

; 5114 : }

	ret	0
?isNoRiver@CvFeatureInfo@@QBE_NXZ ENDP			; CvFeatureInfo::isNoRiver
_TEXT	ENDS
PUBLIC	?isNoAdjacent@CvFeatureInfo@@QBE_NXZ		; CvFeatureInfo::isNoAdjacent
; Function compile flags: /Ogtpy
;	COMDAT ?isNoAdjacent@CvFeatureInfo@@QBE_NXZ
_TEXT	SEGMENT
?isNoAdjacent@CvFeatureInfo@@QBE_NXZ PROC		; CvFeatureInfo::isNoAdjacent, COMDAT
; _this$ = ecx

; 5118 : 	return m_bNoAdjacent;

	mov	al, BYTE PTR [ecx+323]

; 5119 : }

	ret	0
?isNoAdjacent@CvFeatureInfo@@QBE_NXZ ENDP		; CvFeatureInfo::isNoAdjacent
_TEXT	ENDS
PUBLIC	?isRequiresFlatlands@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isRequiresFlatlands
; Function compile flags: /Ogtpy
;	COMDAT ?isRequiresFlatlands@CvFeatureInfo@@QBE_NXZ
_TEXT	SEGMENT
?isRequiresFlatlands@CvFeatureInfo@@QBE_NXZ PROC	; CvFeatureInfo::isRequiresFlatlands, COMDAT
; _this$ = ecx

; 5123 : 	return m_bRequiresFlatlands;

	mov	al, BYTE PTR [ecx+324]

; 5124 : }

	ret	0
?isRequiresFlatlands@CvFeatureInfo@@QBE_NXZ ENDP	; CvFeatureInfo::isRequiresFlatlands
_TEXT	ENDS
PUBLIC	?isRequiresRiver@CvFeatureInfo@@QBE_NXZ		; CvFeatureInfo::isRequiresRiver
; Function compile flags: /Ogtpy
;	COMDAT ?isRequiresRiver@CvFeatureInfo@@QBE_NXZ
_TEXT	SEGMENT
?isRequiresRiver@CvFeatureInfo@@QBE_NXZ PROC		; CvFeatureInfo::isRequiresRiver, COMDAT
; _this$ = ecx

; 5128 : 	return m_bRequiresRiver;

	mov	al, BYTE PTR [ecx+325]

; 5129 : }

	ret	0
?isRequiresRiver@CvFeatureInfo@@QBE_NXZ ENDP		; CvFeatureInfo::isRequiresRiver
_TEXT	ENDS
PUBLIC	?isAddsFreshWater@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isAddsFreshWater
; Function compile flags: /Ogtpy
;	COMDAT ?isAddsFreshWater@CvFeatureInfo@@QBE_NXZ
_TEXT	SEGMENT
?isAddsFreshWater@CvFeatureInfo@@QBE_NXZ PROC		; CvFeatureInfo::isAddsFreshWater, COMDAT
; _this$ = ecx

; 5133 : 	return m_bAddsFreshWater;

	mov	al, BYTE PTR [ecx+326]

; 5134 : }

	ret	0
?isAddsFreshWater@CvFeatureInfo@@QBE_NXZ ENDP		; CvFeatureInfo::isAddsFreshWater
_TEXT	ENDS
PUBLIC	?isImpassable@CvFeatureInfo@@QBE_NXZ		; CvFeatureInfo::isImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?isImpassable@CvFeatureInfo@@QBE_NXZ
_TEXT	SEGMENT
?isImpassable@CvFeatureInfo@@QBE_NXZ PROC		; CvFeatureInfo::isImpassable, COMDAT
; _this$ = ecx

; 5138 : 	return m_bImpassable;

	mov	al, BYTE PTR [ecx+327]

; 5139 : }

	ret	0
?isImpassable@CvFeatureInfo@@QBE_NXZ ENDP		; CvFeatureInfo::isImpassable
_TEXT	ENDS
PUBLIC	?isNoCity@CvFeatureInfo@@QBE_NXZ		; CvFeatureInfo::isNoCity
; Function compile flags: /Ogtpy
;	COMDAT ?isNoCity@CvFeatureInfo@@QBE_NXZ
_TEXT	SEGMENT
?isNoCity@CvFeatureInfo@@QBE_NXZ PROC			; CvFeatureInfo::isNoCity, COMDAT
; _this$ = ecx

; 5143 : 	return m_bNoCity;

	mov	al, BYTE PTR [ecx+328]

; 5144 : }

	ret	0
?isNoCity@CvFeatureInfo@@QBE_NXZ ENDP			; CvFeatureInfo::isNoCity
_TEXT	ENDS
PUBLIC	?isNoImprovement@CvFeatureInfo@@QBE_NXZ		; CvFeatureInfo::isNoImprovement
; Function compile flags: /Ogtpy
;	COMDAT ?isNoImprovement@CvFeatureInfo@@QBE_NXZ
_TEXT	SEGMENT
?isNoImprovement@CvFeatureInfo@@QBE_NXZ PROC		; CvFeatureInfo::isNoImprovement, COMDAT
; _this$ = ecx

; 5148 : 	return m_bNoImprovement;

	mov	al, BYTE PTR [ecx+329]

; 5149 : }

	ret	0
?isNoImprovement@CvFeatureInfo@@QBE_NXZ ENDP		; CvFeatureInfo::isNoImprovement
_TEXT	ENDS
PUBLIC	?isVisibleAlways@CvFeatureInfo@@QBE_NXZ		; CvFeatureInfo::isVisibleAlways
; Function compile flags: /Ogtpy
;	COMDAT ?isVisibleAlways@CvFeatureInfo@@QBE_NXZ
_TEXT	SEGMENT
?isVisibleAlways@CvFeatureInfo@@QBE_NXZ PROC		; CvFeatureInfo::isVisibleAlways, COMDAT
; _this$ = ecx

; 5153 : 	return m_bVisibleAlways;

	mov	al, BYTE PTR [ecx+330]

; 5154 : }

	ret	0
?isVisibleAlways@CvFeatureInfo@@QBE_NXZ ENDP		; CvFeatureInfo::isVisibleAlways
_TEXT	ENDS
PUBLIC	?isNukeImmune@CvFeatureInfo@@QBE_NXZ		; CvFeatureInfo::isNukeImmune
; Function compile flags: /Ogtpy
;	COMDAT ?isNukeImmune@CvFeatureInfo@@QBE_NXZ
_TEXT	SEGMENT
?isNukeImmune@CvFeatureInfo@@QBE_NXZ PROC		; CvFeatureInfo::isNukeImmune, COMDAT
; _this$ = ecx

; 5158 : 	return m_bNukeImmune;

	mov	al, BYTE PTR [ecx+331]

; 5159 : }

	ret	0
?isNukeImmune@CvFeatureInfo@@QBE_NXZ ENDP		; CvFeatureInfo::isNukeImmune
_TEXT	ENDS
PUBLIC	?IsRough@CvFeatureInfo@@QBE_NXZ			; CvFeatureInfo::IsRough
; Function compile flags: /Ogtpy
;	COMDAT ?IsRough@CvFeatureInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsRough@CvFeatureInfo@@QBE_NXZ PROC			; CvFeatureInfo::IsRough, COMDAT
; _this$ = ecx

; 5163 : 	return m_bRough;

	mov	al, BYTE PTR [ecx+332]

; 5164 : }

	ret	0
?IsRough@CvFeatureInfo@@QBE_NXZ ENDP			; CvFeatureInfo::IsRough
_TEXT	ENDS
PUBLIC	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ		; CvFeatureInfo::IsNaturalWonder
; Function compile flags: /Ogtpy
;	COMDAT ?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ PROC		; CvFeatureInfo::IsNaturalWonder, COMDAT
; _this$ = ecx

; 5168 : 	return m_bNaturalWonder;

	mov	al, BYTE PTR [ecx+333]

; 5169 : }

	ret	0
?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ ENDP		; CvFeatureInfo::IsNaturalWonder
_TEXT	ENDS
PUBLIC	?getWorldSoundscapeScriptId@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getWorldSoundscapeScriptId
; Function compile flags: /Ogtpy
;	COMDAT ?getWorldSoundscapeScriptId@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getWorldSoundscapeScriptId@CvFeatureInfo@@QBEHXZ PROC	; CvFeatureInfo::getWorldSoundscapeScriptId, COMDAT
; _this$ = ecx

; 5183 : 	return m_iWorldSoundscapeScriptId;

	mov	eax, DWORD PTR [ecx+336]

; 5184 : }

	ret	0
?getWorldSoundscapeScriptId@CvFeatureInfo@@QBEHXZ ENDP	; CvFeatureInfo::getWorldSoundscapeScriptId
_TEXT	ENDS
PUBLIC	?getEffectProbability@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getEffectProbability
; Function compile flags: /Ogtpy
;	COMDAT ?getEffectProbability@CvFeatureInfo@@QBEHXZ
_TEXT	SEGMENT
?getEffectProbability@CvFeatureInfo@@QBEHXZ PROC	; CvFeatureInfo::getEffectProbability, COMDAT
; _this$ = ecx

; 5193 : 	return m_iEffectProbability;

	mov	eax, DWORD PTR [ecx+368]

; 5194 : }

	ret	0
?getEffectProbability@CvFeatureInfo@@QBEHXZ ENDP	; CvFeatureInfo::getEffectProbability
_TEXT	ENDS
PUBLIC	?getYieldChange@CvFeatureInfo@@QBEHH@Z		; CvFeatureInfo::getYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?getYieldChange@CvFeatureInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getYieldChange@CvFeatureInfo@@QBEHH@Z PROC		; CvFeatureInfo::getYieldChange, COMDAT
; _this$ = ecx

; 5198 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 5199 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5200 : 	return m_piYieldChange ? m_piYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+400]
	test	eax, eax
	je	SHORT $LN3@getYieldCh@4
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 5201 : }

	ret	4
$LN3@getYieldCh@4:

; 5198 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 5199 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5200 : 	return m_piYieldChange ? m_piYieldChange[i] : -1;

	or	eax, -1

; 5201 : }

	ret	4
?getYieldChange@CvFeatureInfo@@QBEHH@Z ENDP		; CvFeatureInfo::getYieldChange
_TEXT	ENDS
PUBLIC	?getRiverYieldChange@CvFeatureInfo@@QBEHH@Z	; CvFeatureInfo::getRiverYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?getRiverYieldChange@CvFeatureInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getRiverYieldChange@CvFeatureInfo@@QBEHH@Z PROC	; CvFeatureInfo::getRiverYieldChange, COMDAT
; _this$ = ecx

; 5205 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 5206 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5207 : 	return m_piRiverYieldChange ? m_piRiverYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+404]
	test	eax, eax
	je	SHORT $LN3@getRiverYi
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 5208 : }

	ret	4
$LN3@getRiverYi:

; 5205 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 5206 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5207 : 	return m_piRiverYieldChange ? m_piRiverYieldChange[i] : -1;

	or	eax, -1

; 5208 : }

	ret	4
?getRiverYieldChange@CvFeatureInfo@@QBEHH@Z ENDP	; CvFeatureInfo::getRiverYieldChange
_TEXT	ENDS
PUBLIC	?getHillsYieldChange@CvFeatureInfo@@QBEHH@Z	; CvFeatureInfo::getHillsYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?getHillsYieldChange@CvFeatureInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getHillsYieldChange@CvFeatureInfo@@QBEHH@Z PROC	; CvFeatureInfo::getHillsYieldChange, COMDAT
; _this$ = ecx

; 5212 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 5213 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5214 : 	return m_piHillsYieldChange ? m_piHillsYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+408]
	test	eax, eax
	je	SHORT $LN3@getHillsYi
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 5215 : }

	ret	4
$LN3@getHillsYi:

; 5212 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 5213 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5214 : 	return m_piHillsYieldChange ? m_piHillsYieldChange[i] : -1;

	or	eax, -1

; 5215 : }

	ret	4
?getHillsYieldChange@CvFeatureInfo@@QBEHH@Z ENDP	; CvFeatureInfo::getHillsYieldChange
_TEXT	ENDS
PUBLIC	?get3DAudioScriptFootstepIndex@CvFeatureInfo@@QBEHH@Z ; CvFeatureInfo::get3DAudioScriptFootstepIndex
; Function compile flags: /Ogtpy
;	COMDAT ?get3DAudioScriptFootstepIndex@CvFeatureInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?get3DAudioScriptFootstepIndex@CvFeatureInfo@@QBEHH@Z PROC ; CvFeatureInfo::get3DAudioScriptFootstepIndex, COMDAT
; _this$ = ecx

; 5219 : 	//	CvAssertMsg(i < ?, "Index out of bounds");
; 5220 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5221 : 	return m_pi3DAudioScriptFootstepIndex ? m_pi3DAudioScriptFootstepIndex[i] : -1;

	mov	eax, DWORD PTR [ecx+412]
	test	eax, eax
	je	SHORT $LN3@get3DAudio
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 5222 : }

	ret	4
$LN3@get3DAudio:

; 5219 : 	//	CvAssertMsg(i < ?, "Index out of bounds");
; 5220 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5221 : 	return m_pi3DAudioScriptFootstepIndex ? m_pi3DAudioScriptFootstepIndex[i] : -1;

	or	eax, -1

; 5222 : }

	ret	4
?get3DAudioScriptFootstepIndex@CvFeatureInfo@@QBEHH@Z ENDP ; CvFeatureInfo::get3DAudioScriptFootstepIndex
_TEXT	ENDS
PUBLIC	?isTerrain@CvFeatureInfo@@QBE_NH@Z		; CvFeatureInfo::isTerrain
; Function compile flags: /Ogtpy
;	COMDAT ?isTerrain@CvFeatureInfo@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?isTerrain@CvFeatureInfo@@QBE_NH@Z PROC			; CvFeatureInfo::isTerrain, COMDAT
; _this$ = ecx

; 5226 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 5227 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5228 : 	return m_pbTerrain ? m_pbTerrain[i] : false;

	mov	eax, DWORD PTR [ecx+416]
	test	eax, eax
	je	SHORT $LN3@isTerrain@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 5229 : }

	ret	4
$LN3@isTerrain@2:

; 5226 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 5227 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5228 : 	return m_pbTerrain ? m_pbTerrain[i] : false;

	xor	al, al

; 5229 : }

	ret	4
?isTerrain@CvFeatureInfo@@QBE_NH@Z ENDP			; CvFeatureInfo::isTerrain
_TEXT	ENDS
PUBLIC	?IsClearable@CvFeatureInfo@@QBE_NXZ		; CvFeatureInfo::IsClearable
; Function compile flags: /Ogtpy
;	COMDAT ?IsClearable@CvFeatureInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsClearable@CvFeatureInfo@@QBE_NXZ PROC		; CvFeatureInfo::IsClearable, COMDAT
; _this$ = ecx

; 5234 : 	return m_bClearable;

	mov	al, BYTE PTR [ecx+334]

; 5235 : }

	ret	0
?IsClearable@CvFeatureInfo@@QBE_NXZ ENDP		; CvFeatureInfo::IsClearable
_TEXT	ENDS
PUBLIC	?SetClearable@CvFeatureInfo@@QAEX_N@Z		; CvFeatureInfo::SetClearable
; Function compile flags: /Ogtpy
;	COMDAT ?SetClearable@CvFeatureInfo@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetClearable@CvFeatureInfo@@QAEX_N@Z PROC		; CvFeatureInfo::SetClearable, COMDAT
; _this$ = ecx

; 5239 : 	m_bClearable = bValue;

	mov	al, BYTE PTR _bValue$[esp-4]
	mov	BYTE PTR [ecx+334], al

; 5240 : }

	ret	4
?SetClearable@CvFeatureInfo@@QAEX_N@Z ENDP		; CvFeatureInfo::SetClearable
_TEXT	ENDS
PUBLIC	?getHillsChange@CvYieldInfo@@QBEHXZ		; CvYieldInfo::getHillsChange
; Function compile flags: /Ogtpy
;	COMDAT ?getHillsChange@CvYieldInfo@@QBEHXZ
_TEXT	SEGMENT
?getHillsChange@CvYieldInfo@@QBEHXZ PROC		; CvYieldInfo::getHillsChange, COMDAT
; _this$ = ecx

; 5349 : 	return m_iHillsChange;

	mov	eax, DWORD PTR [ecx+260]

; 5350 : }

	ret	0
?getHillsChange@CvYieldInfo@@QBEHXZ ENDP		; CvYieldInfo::getHillsChange
_TEXT	ENDS
PUBLIC	?getMountainChange@CvYieldInfo@@QBEHXZ		; CvYieldInfo::getMountainChange
; Function compile flags: /Ogtpy
;	COMDAT ?getMountainChange@CvYieldInfo@@QBEHXZ
_TEXT	SEGMENT
?getMountainChange@CvYieldInfo@@QBEHXZ PROC		; CvYieldInfo::getMountainChange, COMDAT
; _this$ = ecx

; 5354 : 	return m_iMountainChange;

	mov	eax, DWORD PTR [ecx+264]

; 5355 : }

	ret	0
?getMountainChange@CvYieldInfo@@QBEHXZ ENDP		; CvYieldInfo::getMountainChange
_TEXT	ENDS
PUBLIC	?getLakeChange@CvYieldInfo@@QBEHXZ		; CvYieldInfo::getLakeChange
; Function compile flags: /Ogtpy
;	COMDAT ?getLakeChange@CvYieldInfo@@QBEHXZ
_TEXT	SEGMENT
?getLakeChange@CvYieldInfo@@QBEHXZ PROC			; CvYieldInfo::getLakeChange, COMDAT
; _this$ = ecx

; 5359 : 	return m_iLakeChange;

	mov	eax, DWORD PTR [ecx+268]

; 5360 : }

	ret	0
?getLakeChange@CvYieldInfo@@QBEHXZ ENDP			; CvYieldInfo::getLakeChange
_TEXT	ENDS
PUBLIC	?getCityChange@CvYieldInfo@@QBEHXZ		; CvYieldInfo::getCityChange
; Function compile flags: /Ogtpy
;	COMDAT ?getCityChange@CvYieldInfo@@QBEHXZ
_TEXT	SEGMENT
?getCityChange@CvYieldInfo@@QBEHXZ PROC			; CvYieldInfo::getCityChange, COMDAT
; _this$ = ecx

; 5364 : 	return m_iCityChange;

	mov	eax, DWORD PTR [ecx+272]

; 5365 : }

	ret	0
?getCityChange@CvYieldInfo@@QBEHXZ ENDP			; CvYieldInfo::getCityChange
_TEXT	ENDS
PUBLIC	?getPopulationChangeOffset@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getPopulationChangeOffset
; Function compile flags: /Ogtpy
;	COMDAT ?getPopulationChangeOffset@CvYieldInfo@@QBEHXZ
_TEXT	SEGMENT
?getPopulationChangeOffset@CvYieldInfo@@QBEHXZ PROC	; CvYieldInfo::getPopulationChangeOffset, COMDAT
; _this$ = ecx

; 5369 : 	return m_iPopulationChangeOffset;

	mov	eax, DWORD PTR [ecx+276]

; 5370 : }

	ret	0
?getPopulationChangeOffset@CvYieldInfo@@QBEHXZ ENDP	; CvYieldInfo::getPopulationChangeOffset
_TEXT	ENDS
PUBLIC	?getPopulationChangeDivisor@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getPopulationChangeDivisor
; Function compile flags: /Ogtpy
;	COMDAT ?getPopulationChangeDivisor@CvYieldInfo@@QBEHXZ
_TEXT	SEGMENT
?getPopulationChangeDivisor@CvYieldInfo@@QBEHXZ PROC	; CvYieldInfo::getPopulationChangeDivisor, COMDAT
; _this$ = ecx

; 5374 : 	return m_iPopulationChangeDivisor;

	mov	eax, DWORD PTR [ecx+280]

; 5375 : }

	ret	0
?getPopulationChangeDivisor@CvYieldInfo@@QBEHXZ ENDP	; CvYieldInfo::getPopulationChangeDivisor
_TEXT	ENDS
PUBLIC	?getMinCity@CvYieldInfo@@QBEHXZ			; CvYieldInfo::getMinCity
; Function compile flags: /Ogtpy
;	COMDAT ?getMinCity@CvYieldInfo@@QBEHXZ
_TEXT	SEGMENT
?getMinCity@CvYieldInfo@@QBEHXZ PROC			; CvYieldInfo::getMinCity, COMDAT
; _this$ = ecx

; 5379 : 	return m_iMinCity;

	mov	eax, DWORD PTR [ecx+284]

; 5380 : }

	ret	0
?getMinCity@CvYieldInfo@@QBEHXZ ENDP			; CvYieldInfo::getMinCity
_TEXT	ENDS
PUBLIC	?getMinCityOnHillsAdjust@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getMinCityOnHillsAdjust
; Function compile flags: /Ogtpy
;	COMDAT ?getMinCityOnHillsAdjust@CvYieldInfo@@QBEHXZ
_TEXT	SEGMENT
?getMinCityOnHillsAdjust@CvYieldInfo@@QBEHXZ PROC	; CvYieldInfo::getMinCityOnHillsAdjust, COMDAT
; _this$ = ecx

; 5384 : 	return m_iMinCityOnHillsAdjust;

	mov	eax, DWORD PTR [ecx+288]

; 5385 : }

	ret	0
?getMinCityOnHillsAdjust@CvYieldInfo@@QBEHXZ ENDP	; CvYieldInfo::getMinCityOnHillsAdjust
_TEXT	ENDS
PUBLIC	?getGoldenAgeYield@CvYieldInfo@@QBEHXZ		; CvYieldInfo::getGoldenAgeYield
; Function compile flags: /Ogtpy
;	COMDAT ?getGoldenAgeYield@CvYieldInfo@@QBEHXZ
_TEXT	SEGMENT
?getGoldenAgeYield@CvYieldInfo@@QBEHXZ PROC		; CvYieldInfo::getGoldenAgeYield, COMDAT
; _this$ = ecx

; 5390 : 	return m_iGoldenAgeYield;

	mov	eax, DWORD PTR [ecx+292]

; 5391 : }

	ret	0
?getGoldenAgeYield@CvYieldInfo@@QBEHXZ ENDP		; CvYieldInfo::getGoldenAgeYield
_TEXT	ENDS
PUBLIC	?getGoldenAgeYieldThreshold@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getGoldenAgeYieldThreshold
; Function compile flags: /Ogtpy
;	COMDAT ?getGoldenAgeYieldThreshold@CvYieldInfo@@QBEHXZ
_TEXT	SEGMENT
?getGoldenAgeYieldThreshold@CvYieldInfo@@QBEHXZ PROC	; CvYieldInfo::getGoldenAgeYieldThreshold, COMDAT
; _this$ = ecx

; 5395 : 	return m_iGoldenAgeYieldThreshold;

	mov	eax, DWORD PTR [ecx+296]

; 5396 : }

	ret	0
?getGoldenAgeYieldThreshold@CvYieldInfo@@QBEHXZ ENDP	; CvYieldInfo::getGoldenAgeYieldThreshold
_TEXT	ENDS
PUBLIC	?getGoldenAgeYieldMod@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getGoldenAgeYieldMod
; Function compile flags: /Ogtpy
;	COMDAT ?getGoldenAgeYieldMod@CvYieldInfo@@QBEHXZ
_TEXT	SEGMENT
?getGoldenAgeYieldMod@CvYieldInfo@@QBEHXZ PROC		; CvYieldInfo::getGoldenAgeYieldMod, COMDAT
; _this$ = ecx

; 5400 : 	return m_iGoldenAgeYieldMod;

	mov	eax, DWORD PTR [ecx+300]

; 5401 : }

	ret	0
?getGoldenAgeYieldMod@CvYieldInfo@@QBEHXZ ENDP		; CvYieldInfo::getGoldenAgeYieldMod
_TEXT	ENDS
PUBLIC	?getAIWeightPercent@CvYieldInfo@@QBEHXZ		; CvYieldInfo::getAIWeightPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getAIWeightPercent@CvYieldInfo@@QBEHXZ
_TEXT	SEGMENT
?getAIWeightPercent@CvYieldInfo@@QBEHXZ PROC		; CvYieldInfo::getAIWeightPercent, COMDAT
; _this$ = ecx

; 5405 : 	return m_iAIWeightPercent;

	mov	eax, DWORD PTR [ecx+304]

; 5406 : }

	ret	0
?getAIWeightPercent@CvYieldInfo@@QBEHXZ ENDP		; CvYieldInfo::getAIWeightPercent
_TEXT	ENDS
PUBLIC	?getMovementCost@CvTerrainInfo@@QBEHXZ		; CvTerrainInfo::getMovementCost
; Function compile flags: /Ogtpy
;	COMDAT ?getMovementCost@CvTerrainInfo@@QBEHXZ
_TEXT	SEGMENT
?getMovementCost@CvTerrainInfo@@QBEHXZ PROC		; CvTerrainInfo::getMovementCost, COMDAT
; _this$ = ecx

; 5465 : 	return m_iMovementCost;

	mov	eax, DWORD PTR [ecx+260]

; 5466 : }

	ret	0
?getMovementCost@CvTerrainInfo@@QBEHXZ ENDP		; CvTerrainInfo::getMovementCost
_TEXT	ENDS
PUBLIC	?getSeeFromLevel@CvTerrainInfo@@QBEHXZ		; CvTerrainInfo::getSeeFromLevel
; Function compile flags: /Ogtpy
;	COMDAT ?getSeeFromLevel@CvTerrainInfo@@QBEHXZ
_TEXT	SEGMENT
?getSeeFromLevel@CvTerrainInfo@@QBEHXZ PROC		; CvTerrainInfo::getSeeFromLevel, COMDAT
; _this$ = ecx

; 5470 : 	return m_iSeeFromLevel;

	mov	eax, DWORD PTR [ecx+264]

; 5471 : }

	ret	0
?getSeeFromLevel@CvTerrainInfo@@QBEHXZ ENDP		; CvTerrainInfo::getSeeFromLevel
_TEXT	ENDS
PUBLIC	?getSeeThroughLevel@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getSeeThroughLevel
; Function compile flags: /Ogtpy
;	COMDAT ?getSeeThroughLevel@CvTerrainInfo@@QBEHXZ
_TEXT	SEGMENT
?getSeeThroughLevel@CvTerrainInfo@@QBEHXZ PROC		; CvTerrainInfo::getSeeThroughLevel, COMDAT
; _this$ = ecx

; 5475 : 	return m_iSeeThroughLevel;

	mov	eax, DWORD PTR [ecx+268]

; 5476 : }

	ret	0
?getSeeThroughLevel@CvTerrainInfo@@QBEHXZ ENDP		; CvTerrainInfo::getSeeThroughLevel
_TEXT	ENDS
PUBLIC	?getBuildModifier@CvTerrainInfo@@QBEHXZ		; CvTerrainInfo::getBuildModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildModifier@CvTerrainInfo@@QBEHXZ
_TEXT	SEGMENT
?getBuildModifier@CvTerrainInfo@@QBEHXZ PROC		; CvTerrainInfo::getBuildModifier, COMDAT
; _this$ = ecx

; 5480 : 	return m_iBuildModifier;

	mov	eax, DWORD PTR [ecx+272]

; 5481 : }

	ret	0
?getBuildModifier@CvTerrainInfo@@QBEHXZ ENDP		; CvTerrainInfo::getBuildModifier
_TEXT	ENDS
PUBLIC	?getDefenseModifier@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getDefenseModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getDefenseModifier@CvTerrainInfo@@QBEHXZ
_TEXT	SEGMENT
?getDefenseModifier@CvTerrainInfo@@QBEHXZ PROC		; CvTerrainInfo::getDefenseModifier, COMDAT
; _this$ = ecx

; 5485 : 	return m_iDefenseModifier;

	mov	eax, DWORD PTR [ecx+276]

; 5486 : }

	ret	0
?getDefenseModifier@CvTerrainInfo@@QBEHXZ ENDP		; CvTerrainInfo::getDefenseModifier
_TEXT	ENDS
PUBLIC	?getInfluenceCost@CvTerrainInfo@@QBEHXZ		; CvTerrainInfo::getInfluenceCost
; Function compile flags: /Ogtpy
;	COMDAT ?getInfluenceCost@CvTerrainInfo@@QBEHXZ
_TEXT	SEGMENT
?getInfluenceCost@CvTerrainInfo@@QBEHXZ PROC		; CvTerrainInfo::getInfluenceCost, COMDAT
; _this$ = ecx

; 5490 : 	return m_iInfluenceCost;

	mov	eax, DWORD PTR [ecx+280]

; 5491 : }

	ret	0
?getInfluenceCost@CvTerrainInfo@@QBEHXZ ENDP		; CvTerrainInfo::getInfluenceCost
_TEXT	ENDS
PUBLIC	?isWater@CvTerrainInfo@@QBE_NXZ			; CvTerrainInfo::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvTerrainInfo@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvTerrainInfo@@QBE_NXZ PROC			; CvTerrainInfo::isWater, COMDAT
; _this$ = ecx

; 5495 : 	return m_bWater;

	mov	al, BYTE PTR [ecx+284]

; 5496 : }

	ret	0
?isWater@CvTerrainInfo@@QBE_NXZ ENDP			; CvTerrainInfo::isWater
_TEXT	ENDS
PUBLIC	?isImpassable@CvTerrainInfo@@QBE_NXZ		; CvTerrainInfo::isImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?isImpassable@CvTerrainInfo@@QBE_NXZ
_TEXT	SEGMENT
?isImpassable@CvTerrainInfo@@QBE_NXZ PROC		; CvTerrainInfo::isImpassable, COMDAT
; _this$ = ecx

; 5500 : 	return m_bImpassable;

	mov	al, BYTE PTR [ecx+285]

; 5501 : }

	ret	0
?isImpassable@CvTerrainInfo@@QBE_NXZ ENDP		; CvTerrainInfo::isImpassable
_TEXT	ENDS
PUBLIC	?isFound@CvTerrainInfo@@QBE_NXZ			; CvTerrainInfo::isFound
; Function compile flags: /Ogtpy
;	COMDAT ?isFound@CvTerrainInfo@@QBE_NXZ
_TEXT	SEGMENT
?isFound@CvTerrainInfo@@QBE_NXZ PROC			; CvTerrainInfo::isFound, COMDAT
; _this$ = ecx

; 5505 : 	return m_bFound;

	mov	al, BYTE PTR [ecx+286]

; 5506 : }

	ret	0
?isFound@CvTerrainInfo@@QBE_NXZ ENDP			; CvTerrainInfo::isFound
_TEXT	ENDS
PUBLIC	?isFoundCoast@CvTerrainInfo@@QBE_NXZ		; CvTerrainInfo::isFoundCoast
; Function compile flags: /Ogtpy
;	COMDAT ?isFoundCoast@CvTerrainInfo@@QBE_NXZ
_TEXT	SEGMENT
?isFoundCoast@CvTerrainInfo@@QBE_NXZ PROC		; CvTerrainInfo::isFoundCoast, COMDAT
; _this$ = ecx

; 5510 : 	return m_bFoundCoast;

	mov	al, BYTE PTR [ecx+287]

; 5511 : }

	ret	0
?isFoundCoast@CvTerrainInfo@@QBE_NXZ ENDP		; CvTerrainInfo::isFoundCoast
_TEXT	ENDS
PUBLIC	?isFoundFreshWater@CvTerrainInfo@@QBE_NXZ	; CvTerrainInfo::isFoundFreshWater
; Function compile flags: /Ogtpy
;	COMDAT ?isFoundFreshWater@CvTerrainInfo@@QBE_NXZ
_TEXT	SEGMENT
?isFoundFreshWater@CvTerrainInfo@@QBE_NXZ PROC		; CvTerrainInfo::isFoundFreshWater, COMDAT
; _this$ = ecx

; 5515 : 	return m_bFoundFreshWater;

	mov	al, BYTE PTR [ecx+288]

; 5516 : }

	ret	0
?isFoundFreshWater@CvTerrainInfo@@QBE_NXZ ENDP		; CvTerrainInfo::isFoundFreshWater
_TEXT	ENDS
PUBLIC	?getWorldSoundscapeScriptId@CvTerrainInfo@@QBEHXZ ; CvTerrainInfo::getWorldSoundscapeScriptId
; Function compile flags: /Ogtpy
;	COMDAT ?getWorldSoundscapeScriptId@CvTerrainInfo@@QBEHXZ
_TEXT	SEGMENT
?getWorldSoundscapeScriptId@CvTerrainInfo@@QBEHXZ PROC	; CvTerrainInfo::getWorldSoundscapeScriptId, COMDAT
; _this$ = ecx

; 5530 : 	return m_iWorldSoundscapeScriptId;

	mov	eax, DWORD PTR [ecx+292]

; 5531 : }

	ret	0
?getWorldSoundscapeScriptId@CvTerrainInfo@@QBEHXZ ENDP	; CvTerrainInfo::getWorldSoundscapeScriptId
_TEXT	ENDS
PUBLIC	?getYield@CvTerrainInfo@@QBEHH@Z		; CvTerrainInfo::getYield
; Function compile flags: /Ogtpy
;	COMDAT ?getYield@CvTerrainInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getYield@CvTerrainInfo@@QBEHH@Z PROC			; CvTerrainInfo::getYield, COMDAT
; _this$ = ecx

; 5540 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 5541 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5542 : 	return m_piYields ? m_piYields[i] : -1;

	mov	eax, DWORD PTR [ecx+296]
	test	eax, eax
	je	SHORT $LN3@getYield
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 5543 : }

	ret	4
$LN3@getYield:

; 5540 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 5541 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5542 : 	return m_piYields ? m_piYields[i] : -1;

	or	eax, -1

; 5543 : }

	ret	4
?getYield@CvTerrainInfo@@QBEHH@Z ENDP			; CvTerrainInfo::getYield
_TEXT	ENDS
PUBLIC	?getRiverYieldChange@CvTerrainInfo@@QBEHH@Z	; CvTerrainInfo::getRiverYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?getRiverYieldChange@CvTerrainInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getRiverYieldChange@CvTerrainInfo@@QBEHH@Z PROC	; CvTerrainInfo::getRiverYieldChange, COMDAT
; _this$ = ecx

; 5547 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 5548 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5549 : 	return m_piRiverYieldChange ? m_piRiverYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+300]
	test	eax, eax
	je	SHORT $LN3@getRiverYi@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 5550 : }

	ret	4
$LN3@getRiverYi@2:

; 5547 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 5548 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5549 : 	return m_piRiverYieldChange ? m_piRiverYieldChange[i] : -1;

	or	eax, -1

; 5550 : }

	ret	4
?getRiverYieldChange@CvTerrainInfo@@QBEHH@Z ENDP	; CvTerrainInfo::getRiverYieldChange
_TEXT	ENDS
PUBLIC	?getHillsYieldChange@CvTerrainInfo@@QBEHH@Z	; CvTerrainInfo::getHillsYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?getHillsYieldChange@CvTerrainInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getHillsYieldChange@CvTerrainInfo@@QBEHH@Z PROC	; CvTerrainInfo::getHillsYieldChange, COMDAT
; _this$ = ecx

; 5554 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 5555 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5556 : 	return m_piHillsYieldChange ? m_piHillsYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+304]
	test	eax, eax
	je	SHORT $LN3@getHillsYi@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 5557 : }

	ret	4
$LN3@getHillsYi@2:

; 5554 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 5555 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5556 : 	return m_piHillsYieldChange ? m_piHillsYieldChange[i] : -1;

	or	eax, -1

; 5557 : }

	ret	4
?getHillsYieldChange@CvTerrainInfo@@QBEHH@Z ENDP	; CvTerrainInfo::getHillsYieldChange
_TEXT	ENDS
PUBLIC	?get3DAudioScriptFootstepIndex@CvTerrainInfo@@QBEHH@Z ; CvTerrainInfo::get3DAudioScriptFootstepIndex
; Function compile flags: /Ogtpy
;	COMDAT ?get3DAudioScriptFootstepIndex@CvTerrainInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?get3DAudioScriptFootstepIndex@CvTerrainInfo@@QBEHH@Z PROC ; CvTerrainInfo::get3DAudioScriptFootstepIndex, COMDAT
; _this$ = ecx

; 5561 : //	CvAssertMsg(i < ?, "Index out of bounds");
; 5562 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5563 : 	return m_pi3DAudioScriptFootstepIndex ? m_pi3DAudioScriptFootstepIndex[i] : -1;

	mov	eax, DWORD PTR [ecx+308]
	test	eax, eax
	je	SHORT $LN3@get3DAudio@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 5564 : }

	ret	4
$LN3@get3DAudio@2:

; 5561 : //	CvAssertMsg(i < ?, "Index out of bounds");
; 5562 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5563 : 	return m_pi3DAudioScriptFootstepIndex ? m_pi3DAudioScriptFootstepIndex[i] : -1;

	or	eax, -1

; 5564 : }

	ret	4
?get3DAudioScriptFootstepIndex@CvTerrainInfo@@QBEHH@Z ENDP ; CvTerrainInfo::get3DAudioScriptFootstepIndex
_TEXT	ENDS
PUBLIC	?getCursorIndex@CvInterfaceModeInfo@@QBEHXZ	; CvInterfaceModeInfo::getCursorIndex
; Function compile flags: /Ogtpy
;	COMDAT ?getCursorIndex@CvInterfaceModeInfo@@QBEHXZ
_TEXT	SEGMENT
?getCursorIndex@CvInterfaceModeInfo@@QBEHXZ PROC	; CvInterfaceModeInfo::getCursorIndex, COMDAT
; _this$ = ecx

; 5623 : 	return m_iCursorIndex;

	mov	eax, DWORD PTR [ecx+460]

; 5624 : }

	ret	0
?getCursorIndex@CvInterfaceModeInfo@@QBEHXZ ENDP	; CvInterfaceModeInfo::getCursorIndex
_TEXT	ENDS
PUBLIC	?getMissionType@CvInterfaceModeInfo@@QBEHXZ	; CvInterfaceModeInfo::getMissionType
; Function compile flags: /Ogtpy
;	COMDAT ?getMissionType@CvInterfaceModeInfo@@QBEHXZ
_TEXT	SEGMENT
?getMissionType@CvInterfaceModeInfo@@QBEHXZ PROC	; CvInterfaceModeInfo::getMissionType, COMDAT
; _this$ = ecx

; 5628 : 	return m_iMissionType;

	mov	eax, DWORD PTR [ecx+464]

; 5629 : }

	ret	0
?getMissionType@CvInterfaceModeInfo@@QBEHXZ ENDP	; CvInterfaceModeInfo::getMissionType
_TEXT	ENDS
PUBLIC	?getVisible@CvInterfaceModeInfo@@QBE_NXZ	; CvInterfaceModeInfo::getVisible
; Function compile flags: /Ogtpy
;	COMDAT ?getVisible@CvInterfaceModeInfo@@QBE_NXZ
_TEXT	SEGMENT
?getVisible@CvInterfaceModeInfo@@QBE_NXZ PROC		; CvInterfaceModeInfo::getVisible, COMDAT
; _this$ = ecx

; 5633 : 	return m_bVisible;

	mov	al, BYTE PTR [ecx+468]

; 5634 : }

	ret	0
?getVisible@CvInterfaceModeInfo@@QBE_NXZ ENDP		; CvInterfaceModeInfo::getVisible
_TEXT	ENDS
PUBLIC	?getHighlightPlot@CvInterfaceModeInfo@@QBE_NXZ	; CvInterfaceModeInfo::getHighlightPlot
; Function compile flags: /Ogtpy
;	COMDAT ?getHighlightPlot@CvInterfaceModeInfo@@QBE_NXZ
_TEXT	SEGMENT
?getHighlightPlot@CvInterfaceModeInfo@@QBE_NXZ PROC	; CvInterfaceModeInfo::getHighlightPlot, COMDAT
; _this$ = ecx

; 5638 : 	return m_bHighlightPlot;

	mov	al, BYTE PTR [ecx+469]

; 5639 : }

	ret	0
?getHighlightPlot@CvInterfaceModeInfo@@QBE_NXZ ENDP	; CvInterfaceModeInfo::getHighlightPlot
_TEXT	ENDS
PUBLIC	?getSelectType@CvInterfaceModeInfo@@QBE_NXZ	; CvInterfaceModeInfo::getSelectType
; Function compile flags: /Ogtpy
;	COMDAT ?getSelectType@CvInterfaceModeInfo@@QBE_NXZ
_TEXT	SEGMENT
?getSelectType@CvInterfaceModeInfo@@QBE_NXZ PROC	; CvInterfaceModeInfo::getSelectType, COMDAT
; _this$ = ecx

; 5643 : 	return m_bSelectType;

	mov	al, BYTE PTR [ecx+470]

; 5644 : }

	ret	0
?getSelectType@CvInterfaceModeInfo@@QBE_NXZ ENDP	; CvInterfaceModeInfo::getSelectType
_TEXT	ENDS
PUBLIC	?getSelectAll@CvInterfaceModeInfo@@QBE_NXZ	; CvInterfaceModeInfo::getSelectAll
; Function compile flags: /Ogtpy
;	COMDAT ?getSelectAll@CvInterfaceModeInfo@@QBE_NXZ
_TEXT	SEGMENT
?getSelectAll@CvInterfaceModeInfo@@QBE_NXZ PROC		; CvInterfaceModeInfo::getSelectAll, COMDAT
; _this$ = ecx

; 5648 : 	return m_bSelectAll;

	mov	al, BYTE PTR [ecx+471]

; 5649 : }

	ret	0
?getSelectAll@CvInterfaceModeInfo@@QBE_NXZ ENDP		; CvInterfaceModeInfo::getSelectAll
_TEXT	ENDS
PUBLIC	?GetVictoryCompetitiveness@CvLeaderHeadInfo@@QBEHXZ ; CvLeaderHeadInfo::GetVictoryCompetitiveness
; Function compile flags: /Ogtpy
;	COMDAT ?GetVictoryCompetitiveness@CvLeaderHeadInfo@@QBEHXZ
_TEXT	SEGMENT
?GetVictoryCompetitiveness@CvLeaderHeadInfo@@QBEHXZ PROC ; CvLeaderHeadInfo::GetVictoryCompetitiveness, COMDAT
; _this$ = ecx

; 5704 : 	return m_iVictoryCompetitiveness;

	mov	eax, DWORD PTR [ecx+260]

; 5705 : }

	ret	0
?GetVictoryCompetitiveness@CvLeaderHeadInfo@@QBEHXZ ENDP ; CvLeaderHeadInfo::GetVictoryCompetitiveness
_TEXT	ENDS
PUBLIC	?GetWonderCompetitiveness@CvLeaderHeadInfo@@QBEHXZ ; CvLeaderHeadInfo::GetWonderCompetitiveness
; Function compile flags: /Ogtpy
;	COMDAT ?GetWonderCompetitiveness@CvLeaderHeadInfo@@QBEHXZ
_TEXT	SEGMENT
?GetWonderCompetitiveness@CvLeaderHeadInfo@@QBEHXZ PROC	; CvLeaderHeadInfo::GetWonderCompetitiveness, COMDAT
; _this$ = ecx

; 5709 : 	return m_iWonderCompetitiveness;

	mov	eax, DWORD PTR [ecx+264]

; 5710 : }

	ret	0
?GetWonderCompetitiveness@CvLeaderHeadInfo@@QBEHXZ ENDP	; CvLeaderHeadInfo::GetWonderCompetitiveness
_TEXT	ENDS
PUBLIC	?GetMinorCivCompetitiveness@CvLeaderHeadInfo@@QBEHXZ ; CvLeaderHeadInfo::GetMinorCivCompetitiveness
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinorCivCompetitiveness@CvLeaderHeadInfo@@QBEHXZ
_TEXT	SEGMENT
?GetMinorCivCompetitiveness@CvLeaderHeadInfo@@QBEHXZ PROC ; CvLeaderHeadInfo::GetMinorCivCompetitiveness, COMDAT
; _this$ = ecx

; 5714 : 	return m_iMinorCivCompetitiveness;

	mov	eax, DWORD PTR [ecx+268]

; 5715 : }

	ret	0
?GetMinorCivCompetitiveness@CvLeaderHeadInfo@@QBEHXZ ENDP ; CvLeaderHeadInfo::GetMinorCivCompetitiveness
_TEXT	ENDS
PUBLIC	?GetBoldness@CvLeaderHeadInfo@@QBEHXZ		; CvLeaderHeadInfo::GetBoldness
; Function compile flags: /Ogtpy
;	COMDAT ?GetBoldness@CvLeaderHeadInfo@@QBEHXZ
_TEXT	SEGMENT
?GetBoldness@CvLeaderHeadInfo@@QBEHXZ PROC		; CvLeaderHeadInfo::GetBoldness, COMDAT
; _this$ = ecx

; 5719 : 	return m_iBoldness;

	mov	eax, DWORD PTR [ecx+272]

; 5720 : }

	ret	0
?GetBoldness@CvLeaderHeadInfo@@QBEHXZ ENDP		; CvLeaderHeadInfo::GetBoldness
_TEXT	ENDS
PUBLIC	?GetDiploBalance@CvLeaderHeadInfo@@QBEHXZ	; CvLeaderHeadInfo::GetDiploBalance
; Function compile flags: /Ogtpy
;	COMDAT ?GetDiploBalance@CvLeaderHeadInfo@@QBEHXZ
_TEXT	SEGMENT
?GetDiploBalance@CvLeaderHeadInfo@@QBEHXZ PROC		; CvLeaderHeadInfo::GetDiploBalance, COMDAT
; _this$ = ecx

; 5724 : 	return m_iDiploBalance;

	mov	eax, DWORD PTR [ecx+276]

; 5725 : }

	ret	0
?GetDiploBalance@CvLeaderHeadInfo@@QBEHXZ ENDP		; CvLeaderHeadInfo::GetDiploBalance
_TEXT	ENDS
PUBLIC	?GetWarmongerHate@CvLeaderHeadInfo@@QBEHXZ	; CvLeaderHeadInfo::GetWarmongerHate
; Function compile flags: /Ogtpy
;	COMDAT ?GetWarmongerHate@CvLeaderHeadInfo@@QBEHXZ
_TEXT	SEGMENT
?GetWarmongerHate@CvLeaderHeadInfo@@QBEHXZ PROC		; CvLeaderHeadInfo::GetWarmongerHate, COMDAT
; _this$ = ecx

; 5729 : 	return m_iWarmongerHate;

	mov	eax, DWORD PTR [ecx+280]

; 5730 : }

	ret	0
?GetWarmongerHate@CvLeaderHeadInfo@@QBEHXZ ENDP		; CvLeaderHeadInfo::GetWarmongerHate
_TEXT	ENDS
PUBLIC	?GetDenounceWillingness@CvLeaderHeadInfo@@QBEHXZ ; CvLeaderHeadInfo::GetDenounceWillingness
; Function compile flags: /Ogtpy
;	COMDAT ?GetDenounceWillingness@CvLeaderHeadInfo@@QBEHXZ
_TEXT	SEGMENT
?GetDenounceWillingness@CvLeaderHeadInfo@@QBEHXZ PROC	; CvLeaderHeadInfo::GetDenounceWillingness, COMDAT
; _this$ = ecx

; 5734 : 	return m_iDenounceWillingness;

	mov	eax, DWORD PTR [ecx+284]

; 5735 : }

	ret	0
?GetDenounceWillingness@CvLeaderHeadInfo@@QBEHXZ ENDP	; CvLeaderHeadInfo::GetDenounceWillingness
_TEXT	ENDS
PUBLIC	?GetDoFWillingness@CvLeaderHeadInfo@@QBEHXZ	; CvLeaderHeadInfo::GetDoFWillingness
; Function compile flags: /Ogtpy
;	COMDAT ?GetDoFWillingness@CvLeaderHeadInfo@@QBEHXZ
_TEXT	SEGMENT
?GetDoFWillingness@CvLeaderHeadInfo@@QBEHXZ PROC	; CvLeaderHeadInfo::GetDoFWillingness, COMDAT
; _this$ = ecx

; 5739 : 	return m_iDoFWillingness;

	mov	eax, DWORD PTR [ecx+288]

; 5740 : }

	ret	0
?GetDoFWillingness@CvLeaderHeadInfo@@QBEHXZ ENDP	; CvLeaderHeadInfo::GetDoFWillingness
_TEXT	ENDS
PUBLIC	?GetLoyalty@CvLeaderHeadInfo@@QBEHXZ		; CvLeaderHeadInfo::GetLoyalty
; Function compile flags: /Ogtpy
;	COMDAT ?GetLoyalty@CvLeaderHeadInfo@@QBEHXZ
_TEXT	SEGMENT
?GetLoyalty@CvLeaderHeadInfo@@QBEHXZ PROC		; CvLeaderHeadInfo::GetLoyalty, COMDAT
; _this$ = ecx

; 5744 : 	return m_iLoyalty;

	mov	eax, DWORD PTR [ecx+292]

; 5745 : }

	ret	0
?GetLoyalty@CvLeaderHeadInfo@@QBEHXZ ENDP		; CvLeaderHeadInfo::GetLoyalty
_TEXT	ENDS
PUBLIC	?GetNeediness@CvLeaderHeadInfo@@QBEHXZ		; CvLeaderHeadInfo::GetNeediness
; Function compile flags: /Ogtpy
;	COMDAT ?GetNeediness@CvLeaderHeadInfo@@QBEHXZ
_TEXT	SEGMENT
?GetNeediness@CvLeaderHeadInfo@@QBEHXZ PROC		; CvLeaderHeadInfo::GetNeediness, COMDAT
; _this$ = ecx

; 5749 : 	return m_iNeediness;

	mov	eax, DWORD PTR [ecx+296]

; 5750 : }

	ret	0
?GetNeediness@CvLeaderHeadInfo@@QBEHXZ ENDP		; CvLeaderHeadInfo::GetNeediness
_TEXT	ENDS
PUBLIC	?GetForgiveness@CvLeaderHeadInfo@@QBEHXZ	; CvLeaderHeadInfo::GetForgiveness
; Function compile flags: /Ogtpy
;	COMDAT ?GetForgiveness@CvLeaderHeadInfo@@QBEHXZ
_TEXT	SEGMENT
?GetForgiveness@CvLeaderHeadInfo@@QBEHXZ PROC		; CvLeaderHeadInfo::GetForgiveness, COMDAT
; _this$ = ecx

; 5754 : 	return m_iForgiveness;

	mov	eax, DWORD PTR [ecx+300]

; 5755 : }

	ret	0
?GetForgiveness@CvLeaderHeadInfo@@QBEHXZ ENDP		; CvLeaderHeadInfo::GetForgiveness
_TEXT	ENDS
PUBLIC	?GetChattiness@CvLeaderHeadInfo@@QBEHXZ		; CvLeaderHeadInfo::GetChattiness
; Function compile flags: /Ogtpy
;	COMDAT ?GetChattiness@CvLeaderHeadInfo@@QBEHXZ
_TEXT	SEGMENT
?GetChattiness@CvLeaderHeadInfo@@QBEHXZ PROC		; CvLeaderHeadInfo::GetChattiness, COMDAT
; _this$ = ecx

; 5759 : 	return m_iChattiness;

	mov	eax, DWORD PTR [ecx+304]

; 5760 : }

	ret	0
?GetChattiness@CvLeaderHeadInfo@@QBEHXZ ENDP		; CvLeaderHeadInfo::GetChattiness
_TEXT	ENDS
PUBLIC	?GetMeanness@CvLeaderHeadInfo@@QBEHXZ		; CvLeaderHeadInfo::GetMeanness
; Function compile flags: /Ogtpy
;	COMDAT ?GetMeanness@CvLeaderHeadInfo@@QBEHXZ
_TEXT	SEGMENT
?GetMeanness@CvLeaderHeadInfo@@QBEHXZ PROC		; CvLeaderHeadInfo::GetMeanness, COMDAT
; _this$ = ecx

; 5764 : 	return m_iMeanness;

	mov	eax, DWORD PTR [ecx+308]

; 5765 : }

	ret	0
?GetMeanness@CvLeaderHeadInfo@@QBEHXZ ENDP		; CvLeaderHeadInfo::GetMeanness
_TEXT	ENDS
PUBLIC	?GetMajorCivApproachBias@CvLeaderHeadInfo@@QBEHH@Z ; CvLeaderHeadInfo::GetMajorCivApproachBias
; Function compile flags: /Ogtpy
;	COMDAT ?GetMajorCivApproachBias@CvLeaderHeadInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetMajorCivApproachBias@CvLeaderHeadInfo@@QBEHH@Z PROC	; CvLeaderHeadInfo::GetMajorCivApproachBias, COMDAT
; _this$ = ecx

; 5769 : 	CvAssertMsg(i < NUM_MAJOR_CIV_APPROACHES, "Index out of bounds");
; 5770 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5771 : 	return m_piMajorCivApproachBiases? m_piMajorCivApproachBiases[i] : -1;

	mov	eax, DWORD PTR [ecx+312]
	test	eax, eax
	je	SHORT $LN3@GetMajorCi
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 5772 : }

	ret	4
$LN3@GetMajorCi:

; 5769 : 	CvAssertMsg(i < NUM_MAJOR_CIV_APPROACHES, "Index out of bounds");
; 5770 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5771 : 	return m_piMajorCivApproachBiases? m_piMajorCivApproachBiases[i] : -1;

	or	eax, -1

; 5772 : }

	ret	4
?GetMajorCivApproachBias@CvLeaderHeadInfo@@QBEHH@Z ENDP	; CvLeaderHeadInfo::GetMajorCivApproachBias
_TEXT	ENDS
PUBLIC	?GetMinorCivApproachBias@CvLeaderHeadInfo@@QBEHH@Z ; CvLeaderHeadInfo::GetMinorCivApproachBias
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinorCivApproachBias@CvLeaderHeadInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetMinorCivApproachBias@CvLeaderHeadInfo@@QBEHH@Z PROC	; CvLeaderHeadInfo::GetMinorCivApproachBias, COMDAT
; _this$ = ecx

; 5776 : 	CvAssertMsg(i < NUM_MINOR_CIV_APPROACHES, "Index out of bounds");
; 5777 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5778 : 	return m_piMinorCivApproachBiases? m_piMinorCivApproachBiases[i] : -1;

	mov	eax, DWORD PTR [ecx+316]
	test	eax, eax
	je	SHORT $LN3@GetMinorCi
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 5779 : }

	ret	4
$LN3@GetMinorCi:

; 5776 : 	CvAssertMsg(i < NUM_MINOR_CIV_APPROACHES, "Index out of bounds");
; 5777 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5778 : 	return m_piMinorCivApproachBiases? m_piMinorCivApproachBiases[i] : -1;

	or	eax, -1

; 5779 : }

	ret	4
?GetMinorCivApproachBias@CvLeaderHeadInfo@@QBEHH@Z ENDP	; CvLeaderHeadInfo::GetMinorCivApproachBias
_TEXT	ENDS
PUBLIC	?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z		; CvLeaderHeadInfo::hasTrait
; Function compile flags: /Ogtpy
;	COMDAT ?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z PROC		; CvLeaderHeadInfo::hasTrait, COMDAT
; _this$ = ecx

; 5793 : 	CvAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
; 5794 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5795 : 	return m_pbTraits ? m_pbTraits[i] : false;

	mov	eax, DWORD PTR [ecx+348]
	test	eax, eax
	je	SHORT $LN3@hasTrait
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 5796 : }

	ret	4
$LN3@hasTrait:

; 5793 : 	CvAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
; 5794 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5795 : 	return m_pbTraits ? m_pbTraits[i] : false;

	xor	al, al

; 5796 : }

	ret	4
?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z ENDP		; CvLeaderHeadInfo::hasTrait
_TEXT	ENDS
PUBLIC	?getFlavorValue@CvLeaderHeadInfo@@QBEHH@Z	; CvLeaderHeadInfo::getFlavorValue
; Function compile flags: /Ogtpy
;	COMDAT ?getFlavorValue@CvLeaderHeadInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getFlavorValue@CvLeaderHeadInfo@@QBEHH@Z PROC		; CvLeaderHeadInfo::getFlavorValue, COMDAT
; _this$ = ecx

; 5800 : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 5801 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5802 : 	return m_piFlavorValue ? m_piFlavorValue[i] : 0;

	mov	eax, DWORD PTR [ecx+352]
	test	eax, eax
	je	SHORT $LN3@getFlavorV@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 5803 : }

	ret	4
$LN3@getFlavorV@2:

; 5800 : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 5801 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 5802 : 	return m_piFlavorValue ? m_piFlavorValue[i] : 0;

	xor	eax, eax

; 5803 : }

	ret	4
?getFlavorValue@CvLeaderHeadInfo@@QBEHH@Z ENDP		; CvLeaderHeadInfo::getFlavorValue
_TEXT	ENDS
PUBLIC	?getLeaderHead@CvLeaderHeadInfo@@QBEPBDXZ	; CvLeaderHeadInfo::getLeaderHead
; Function compile flags: /Ogtpy
;	COMDAT ?getLeaderHead@CvLeaderHeadInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getLeaderHead@CvLeaderHeadInfo@@QBEPBDXZ PROC		; CvLeaderHeadInfo::getLeaderHead, COMDAT
; _this$ = ecx

; 5807 : 	return NULL;

	xor	eax, eax

; 5808 : }

	ret	0
?getLeaderHead@CvLeaderHeadInfo@@QBEPBDXZ ENDP		; CvLeaderHeadInfo::getLeaderHead
_TEXT	ENDS
PUBLIC	?getDefaultPlayers@CvWorldInfo@@QBEHXZ		; CvWorldInfo::getDefaultPlayers
; Function compile flags: /Ogtpy
;	COMDAT ?getDefaultPlayers@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getDefaultPlayers@CvWorldInfo@@QBEHXZ PROC		; CvWorldInfo::getDefaultPlayers, COMDAT
; _this$ = ecx

; 5878 : 	return m_iDefaultPlayers;

	mov	eax, DWORD PTR [ecx+260]

; 5879 : }

	ret	0
?getDefaultPlayers@CvWorldInfo@@QBEHXZ ENDP		; CvWorldInfo::getDefaultPlayers
_TEXT	ENDS
PUBLIC	?getDefaultMinorCivs@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getDefaultMinorCivs
; Function compile flags: /Ogtpy
;	COMDAT ?getDefaultMinorCivs@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getDefaultMinorCivs@CvWorldInfo@@QBEHXZ PROC		; CvWorldInfo::getDefaultMinorCivs, COMDAT
; _this$ = ecx

; 5883 : 	return m_iDefaultMinorCivs;

	mov	eax, DWORD PTR [ecx+264]

; 5884 : }

	ret	0
?getDefaultMinorCivs@CvWorldInfo@@QBEHXZ ENDP		; CvWorldInfo::getDefaultMinorCivs
_TEXT	ENDS
PUBLIC	?getFogTilesPerBarbarianCamp@CvWorldInfo@@QBEHXZ ; CvWorldInfo::getFogTilesPerBarbarianCamp
; Function compile flags: /Ogtpy
;	COMDAT ?getFogTilesPerBarbarianCamp@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getFogTilesPerBarbarianCamp@CvWorldInfo@@QBEHXZ PROC	; CvWorldInfo::getFogTilesPerBarbarianCamp, COMDAT
; _this$ = ecx

; 5888 : 	return m_iFogTilesPerBarbarianCamp;

	mov	eax, DWORD PTR [ecx+268]

; 5889 : }

	ret	0
?getFogTilesPerBarbarianCamp@CvWorldInfo@@QBEHXZ ENDP	; CvWorldInfo::getFogTilesPerBarbarianCamp
_TEXT	ENDS
PUBLIC	?getNumNaturalWonders@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getNumNaturalWonders
; Function compile flags: /Ogtpy
;	COMDAT ?getNumNaturalWonders@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getNumNaturalWonders@CvWorldInfo@@QBEHXZ PROC		; CvWorldInfo::getNumNaturalWonders, COMDAT
; _this$ = ecx

; 5893 : 	return m_iNumNaturalWonders;

	mov	eax, DWORD PTR [ecx+272]

; 5894 : }

	ret	0
?getNumNaturalWonders@CvWorldInfo@@QBEHXZ ENDP		; CvWorldInfo::getNumNaturalWonders
_TEXT	ENDS
PUBLIC	?getUnitNameModifier@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getUnitNameModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitNameModifier@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getUnitNameModifier@CvWorldInfo@@QBEHXZ PROC		; CvWorldInfo::getUnitNameModifier, COMDAT
; _this$ = ecx

; 5898 : 	return m_iUnitNameModifier;

	mov	eax, DWORD PTR [ecx+276]

; 5899 : }

	ret	0
?getUnitNameModifier@CvWorldInfo@@QBEHXZ ENDP		; CvWorldInfo::getUnitNameModifier
_TEXT	ENDS
PUBLIC	?getTargetNumCities@CvWorldInfo@@QBEHXZ		; CvWorldInfo::getTargetNumCities
; Function compile flags: /Ogtpy
;	COMDAT ?getTargetNumCities@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getTargetNumCities@CvWorldInfo@@QBEHXZ PROC		; CvWorldInfo::getTargetNumCities, COMDAT
; _this$ = ecx

; 5903 : 	return m_iTargetNumCities;

	mov	eax, DWORD PTR [ecx+280]

; 5904 : }

	ret	0
?getTargetNumCities@CvWorldInfo@@QBEHXZ ENDP		; CvWorldInfo::getTargetNumCities
_TEXT	ENDS
PUBLIC	?getNumFreeBuildingResources@CvWorldInfo@@QBEHXZ ; CvWorldInfo::getNumFreeBuildingResources
; Function compile flags: /Ogtpy
;	COMDAT ?getNumFreeBuildingResources@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getNumFreeBuildingResources@CvWorldInfo@@QBEHXZ PROC	; CvWorldInfo::getNumFreeBuildingResources, COMDAT
; _this$ = ecx

; 5908 : 	return m_iNumFreeBuildingResources;

	mov	eax, DWORD PTR [ecx+284]

; 5909 : }

	ret	0
?getNumFreeBuildingResources@CvWorldInfo@@QBEHXZ ENDP	; CvWorldInfo::getNumFreeBuildingResources
_TEXT	ENDS
PUBLIC	?getBuildingClassPrereqModifier@CvWorldInfo@@QBEHXZ ; CvWorldInfo::getBuildingClassPrereqModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildingClassPrereqModifier@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getBuildingClassPrereqModifier@CvWorldInfo@@QBEHXZ PROC ; CvWorldInfo::getBuildingClassPrereqModifier, COMDAT
; _this$ = ecx

; 5913 : 	return m_iBuildingClassPrereqModifier;

	mov	eax, DWORD PTR [ecx+288]

; 5914 : }

	ret	0
?getBuildingClassPrereqModifier@CvWorldInfo@@QBEHXZ ENDP ; CvWorldInfo::getBuildingClassPrereqModifier
_TEXT	ENDS
PUBLIC	?getMaxConscriptModifier@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getMaxConscriptModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getMaxConscriptModifier@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getMaxConscriptModifier@CvWorldInfo@@QBEHXZ PROC	; CvWorldInfo::getMaxConscriptModifier, COMDAT
; _this$ = ecx

; 5918 : 	return m_iMaxConscriptModifier;

	mov	eax, DWORD PTR [ecx+292]

; 5919 : }

	ret	0
?getMaxConscriptModifier@CvWorldInfo@@QBEHXZ ENDP	; CvWorldInfo::getMaxConscriptModifier
_TEXT	ENDS
PUBLIC	?getGridWidth@CvWorldInfo@@QBEHXZ		; CvWorldInfo::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvWorldInfo@@QBEHXZ PROC			; CvWorldInfo::getGridWidth, COMDAT
; _this$ = ecx

; 5923 : 	return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+296]

; 5924 : }

	ret	0
?getGridWidth@CvWorldInfo@@QBEHXZ ENDP			; CvWorldInfo::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvWorldInfo@@QBEHXZ		; CvWorldInfo::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvWorldInfo@@QBEHXZ PROC			; CvWorldInfo::getGridHeight, COMDAT
; _this$ = ecx

; 5928 : 	return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+300]

; 5929 : }

	ret	0
?getGridHeight@CvWorldInfo@@QBEHXZ ENDP			; CvWorldInfo::getGridHeight
_TEXT	ENDS
PUBLIC	?getTerrainGrainChange@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getTerrainGrainChange
; Function compile flags: /Ogtpy
;	COMDAT ?getTerrainGrainChange@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getTerrainGrainChange@CvWorldInfo@@QBEHXZ PROC		; CvWorldInfo::getTerrainGrainChange, COMDAT
; _this$ = ecx

; 5945 : 	return m_iTerrainGrainChange;

	mov	eax, DWORD PTR [ecx+308]

; 5946 : }

	ret	0
?getTerrainGrainChange@CvWorldInfo@@QBEHXZ ENDP		; CvWorldInfo::getTerrainGrainChange
_TEXT	ENDS
PUBLIC	?getFeatureGrainChange@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getFeatureGrainChange
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureGrainChange@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getFeatureGrainChange@CvWorldInfo@@QBEHXZ PROC		; CvWorldInfo::getFeatureGrainChange, COMDAT
; _this$ = ecx

; 5950 : 	return m_iFeatureGrainChange;

	mov	eax, DWORD PTR [ecx+312]

; 5951 : }

	ret	0
?getFeatureGrainChange@CvWorldInfo@@QBEHXZ ENDP		; CvWorldInfo::getFeatureGrainChange
_TEXT	ENDS
PUBLIC	?getResearchPercent@CvWorldInfo@@QBEHXZ		; CvWorldInfo::getResearchPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getResearchPercent@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getResearchPercent@CvWorldInfo@@QBEHXZ PROC		; CvWorldInfo::getResearchPercent, COMDAT
; _this$ = ecx

; 5955 : 	return m_iResearchPercent;

	mov	eax, DWORD PTR [ecx+316]

; 5956 : }

	ret	0
?getResearchPercent@CvWorldInfo@@QBEHXZ ENDP		; CvWorldInfo::getResearchPercent
_TEXT	ENDS
PUBLIC	?getAdvancedStartPointsMod@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getAdvancedStartPointsMod
; Function compile flags: /Ogtpy
;	COMDAT ?getAdvancedStartPointsMod@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getAdvancedStartPointsMod@CvWorldInfo@@QBEHXZ PROC	; CvWorldInfo::getAdvancedStartPointsMod, COMDAT
; _this$ = ecx

; 5960 : 	return m_iAdvancedStartPointsMod;

	mov	eax, DWORD PTR [ecx+320]

; 5961 : }

	ret	0
?getAdvancedStartPointsMod@CvWorldInfo@@QBEHXZ ENDP	; CvWorldInfo::getAdvancedStartPointsMod
_TEXT	ENDS
PUBLIC	?getNumCitiesUnhappinessPercent@CvWorldInfo@@QBEHXZ ; CvWorldInfo::getNumCitiesUnhappinessPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getNumCitiesUnhappinessPercent@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getNumCitiesUnhappinessPercent@CvWorldInfo@@QBEHXZ PROC ; CvWorldInfo::getNumCitiesUnhappinessPercent, COMDAT
; _this$ = ecx

; 5965 : 	return m_iNumCitiesUnhappinessPercent;

	mov	eax, DWORD PTR [ecx+324]

; 5966 : }

	ret	0
?getNumCitiesUnhappinessPercent@CvWorldInfo@@QBEHXZ ENDP ; CvWorldInfo::getNumCitiesUnhappinessPercent
_TEXT	ENDS
PUBLIC	?GetNumCitiesPolicyCostMod@CvWorldInfo@@QBEHXZ	; CvWorldInfo::GetNumCitiesPolicyCostMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCitiesPolicyCostMod@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?GetNumCitiesPolicyCostMod@CvWorldInfo@@QBEHXZ PROC	; CvWorldInfo::GetNumCitiesPolicyCostMod, COMDAT
; _this$ = ecx

; 5970 : 	return m_iNumCitiesPolicyCostMod;

	mov	eax, DWORD PTR [ecx+328]

; 5971 : }

	ret	0
?GetNumCitiesPolicyCostMod@CvWorldInfo@@QBEHXZ ENDP	; CvWorldInfo::GetNumCitiesPolicyCostMod
_TEXT	ENDS
PUBLIC	?GetNumCitiesTechCostMod@CvWorldInfo@@QBEHXZ	; CvWorldInfo::GetNumCitiesTechCostMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumCitiesTechCostMod@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?GetNumCitiesTechCostMod@CvWorldInfo@@QBEHXZ PROC	; CvWorldInfo::GetNumCitiesTechCostMod, COMDAT
; _this$ = ecx

; 5975 : 	return m_iNumCitiesTechCostMod;

	mov	eax, DWORD PTR [ecx+332]

; 5976 : }

	ret	0
?GetNumCitiesTechCostMod@CvWorldInfo@@QBEHXZ ENDP	; CvWorldInfo::GetNumCitiesTechCostMod
_TEXT	ENDS
PUBLIC	?GetEstimatedNumCities@CvWorldInfo@@QBEHXZ	; CvWorldInfo::GetEstimatedNumCities
; Function compile flags: /Ogtpy
;	COMDAT ?GetEstimatedNumCities@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?GetEstimatedNumCities@CvWorldInfo@@QBEHXZ PROC		; CvWorldInfo::GetEstimatedNumCities, COMDAT
; _this$ = ecx

; 5980 : 	return m_iEstimatedNumCities;

	mov	eax, DWORD PTR [ecx+336]

; 5981 : }

	ret	0
?GetEstimatedNumCities@CvWorldInfo@@QBEHXZ ENDP		; CvWorldInfo::GetEstimatedNumCities
_TEXT	ENDS
PUBLIC	??8CvWorldInfo@@UBE_NABV0@@Z			; CvWorldInfo::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8CvWorldInfo@@UBE_NABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??8CvWorldInfo@@UBE_NABV0@@Z PROC			; CvWorldInfo::operator==, COMDAT
; _this$ = ecx

; 6033 : {

	push	esi
	push	edi

; 6034 : 	if(this == &rhs) return true;

	mov	edi, DWORD PTR _rhs$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	jne	SHORT $LN21@operator@3
	pop	edi
	mov	al, 1
	pop	esi

; 6055 : 	return true;
; 6056 : }

	ret	4
$LN21@operator@3:

; 6035 : 	if(!CvBaseInfo::operator==(rhs)) return false;

	push	edi
	call	??8CvBaseInfo@@UBE_NABV0@@Z		; CvBaseInfo::operator==
	test	al, al
	jne	SHORT $LN20@operator@3
$LN24@operator@3:
	pop	edi
	xor	al, al
	pop	esi

; 6055 : 	return true;
; 6056 : }

	ret	4
$LN20@operator@3:

; 6036 : 	if(m_iDefaultPlayers != rhs.m_iDefaultPlayers) return false;

	mov	eax, DWORD PTR [esi+260]
	cmp	eax, DWORD PTR [edi+260]
	jne	SHORT $LN24@operator@3

; 6037 : 	if(m_iDefaultMinorCivs != rhs.m_iDefaultMinorCivs) return false;

	mov	ecx, DWORD PTR [esi+264]
	cmp	ecx, DWORD PTR [edi+264]
	jne	SHORT $LN24@operator@3

; 6038 : 	if(m_iFogTilesPerBarbarianCamp != rhs.m_iFogTilesPerBarbarianCamp) return false;

	mov	edx, DWORD PTR [esi+268]
	cmp	edx, DWORD PTR [edi+268]
	jne	SHORT $LN24@operator@3

; 6039 : 	if(m_iNumNaturalWonders != rhs.m_iNumNaturalWonders) return false;

	mov	eax, DWORD PTR [esi+272]
	cmp	eax, DWORD PTR [edi+272]
	jne	SHORT $LN24@operator@3

; 6040 : 	if(m_iUnitNameModifier != rhs.m_iUnitNameModifier) return false;

	mov	ecx, DWORD PTR [esi+276]
	cmp	ecx, DWORD PTR [edi+276]
	jne	SHORT $LN24@operator@3

; 6041 : 	if(m_iTargetNumCities != rhs.m_iTargetNumCities) return false;

	mov	edx, DWORD PTR [esi+280]
	cmp	edx, DWORD PTR [edi+280]
	jne	SHORT $LN24@operator@3

; 6042 : 	if(m_iNumFreeBuildingResources != rhs.m_iNumFreeBuildingResources) return false;

	mov	eax, DWORD PTR [esi+284]
	cmp	eax, DWORD PTR [edi+284]
	jne	SHORT $LN24@operator@3

; 6043 : 	if(m_iBuildingClassPrereqModifier != rhs.m_iBuildingClassPrereqModifier) return false;

	mov	ecx, DWORD PTR [esi+288]
	cmp	ecx, DWORD PTR [edi+288]
	jne	SHORT $LN24@operator@3

; 6044 : 	if(m_iMaxConscriptModifier != rhs.m_iMaxConscriptModifier) return false;

	mov	edx, DWORD PTR [esi+292]
	cmp	edx, DWORD PTR [edi+292]
	jne	$LN24@operator@3

; 6045 : 	if(m_iGridWidth != rhs.m_iGridWidth) return false;

	mov	eax, DWORD PTR [esi+296]
	cmp	eax, DWORD PTR [edi+296]
	jne	$LN24@operator@3

; 6046 : 	if(m_iGridHeight != rhs.m_iGridHeight) return false;

	mov	ecx, DWORD PTR [esi+300]
	cmp	ecx, DWORD PTR [edi+300]
	jne	$LN24@operator@3

; 6047 : 	if(m_iMaxActiveReligions != rhs.m_iMaxActiveReligions) return false;

	mov	edx, DWORD PTR [esi+304]
	cmp	edx, DWORD PTR [edi+304]
	jne	$LN24@operator@3

; 6048 : 	if(m_iTerrainGrainChange != rhs.m_iTerrainGrainChange) return false;

	mov	eax, DWORD PTR [esi+308]
	cmp	eax, DWORD PTR [edi+308]
	jne	$LN24@operator@3

; 6049 : 	if(m_iFeatureGrainChange != rhs.m_iFeatureGrainChange) return false;

	mov	ecx, DWORD PTR [esi+312]
	cmp	ecx, DWORD PTR [edi+312]
	jne	$LN24@operator@3

; 6050 : 	if(m_iResearchPercent != rhs.m_iResearchPercent) return false;

	mov	edx, DWORD PTR [esi+316]
	cmp	edx, DWORD PTR [edi+316]
	jne	$LN24@operator@3

; 6051 : 	if(m_iAdvancedStartPointsMod != rhs.m_iAdvancedStartPointsMod) return false;

	mov	eax, DWORD PTR [esi+320]
	cmp	eax, DWORD PTR [edi+320]
	jne	$LN24@operator@3

; 6052 : 	if(m_iNumCitiesUnhappinessPercent != rhs.m_iNumCitiesUnhappinessPercent) return false;

	mov	ecx, DWORD PTR [esi+324]
	cmp	ecx, DWORD PTR [edi+324]
	jne	$LN24@operator@3

; 6053 : 	if(m_iNumCitiesPolicyCostMod != rhs.m_iNumCitiesPolicyCostMod) return false;

	mov	edx, DWORD PTR [esi+328]
	cmp	edx, DWORD PTR [edi+328]
	jne	$LN24@operator@3

; 6054 : 	if(m_iNumCitiesTechCostMod != rhs.m_iNumCitiesTechCostMod) return false;

	mov	eax, DWORD PTR [esi+332]
	cmp	eax, DWORD PTR [edi+332]
	pop	edi
	sete	al
	pop	esi

; 6055 : 	return true;
; 6056 : }

	ret	4
??8CvWorldInfo@@UBE_NABV0@@Z ENDP			; CvWorldInfo::operator==
_TEXT	ENDS
PUBLIC	??9CvWorldInfo@@QBE_NABV0@@Z			; CvWorldInfo::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9CvWorldInfo@@QBE_NABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??9CvWorldInfo@@QBE_NABV0@@Z PROC			; CvWorldInfo::operator!=, COMDAT
; _this$ = ecx

; 6060 : 	return !(*this == rhs);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _rhs$[esp-4]
	mov	eax, DWORD PTR [eax+16]
	push	edx
	call	eax
	xor	ecx, ecx
	test	al, al
	sete	cl
	mov	al, cl

; 6061 : }

	ret	4
??9CvWorldInfo@@QBE_NABV0@@Z ENDP			; CvWorldInfo::operator!=
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvWorldInfo@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvWorldInfo@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvWorldInfo@@@Z PROC	; operator<<, COMDAT

; 6152 : 	readFrom.writeTo(saveTo);

	mov	ecx, DWORD PTR _readFrom$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	push	esi
	call	edx

; 6153 : 	return saveTo;

	mov	eax, esi
	pop	esi

; 6154 : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvWorldInfo@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvWorldInfo@@@Z	; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvWorldInfo@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvWorldInfo@@@Z PROC	; operator>>, COMDAT

; 6158 : 	writeTo.readFrom(loadFrom);

	mov	ecx, DWORD PTR _writeTo$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	esi
	call	edx

; 6159 : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 6160 : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvWorldInfo@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvClimateInfo@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvClimateInfo@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvClimateInfo@@@Z PROC	; operator<<, COMDAT

; 6237 : 	readFrom.writeTo(saveTo);

	mov	ecx, DWORD PTR _readFrom$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	push	esi
	call	edx

; 6238 : 	return saveTo;

	mov	eax, esi
	pop	esi

; 6239 : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvClimateInfo@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvClimateInfo@@@Z	; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvClimateInfo@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvClimateInfo@@@Z PROC	; operator>>, COMDAT

; 6243 : 	writeTo.readFrom(loadFrom);

	mov	ecx, DWORD PTR _writeTo$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	esi
	call	edx

; 6244 : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 6245 : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvClimateInfo@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvSeaLevelInfo@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvSeaLevelInfo@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvSeaLevelInfo@@@Z PROC	; operator<<, COMDAT

; 6278 : 	readFrom.writeTo(saveTo);

	mov	ecx, DWORD PTR _readFrom$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	push	esi
	call	edx

; 6279 : 	return saveTo;

	mov	eax, esi
	pop	esi

; 6280 : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvSeaLevelInfo@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvSeaLevelInfo@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvSeaLevelInfo@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvSeaLevelInfo@@@Z PROC	; operator>>, COMDAT

; 6284 : 	writeTo.readFrom(loadFrom);

	mov	ecx, DWORD PTR _writeTo$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	esi
	call	edx

; 6285 : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 6286 : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvSeaLevelInfo@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	?getTechPrereq@CvProcessInfo@@QBEHXZ		; CvProcessInfo::getTechPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?getTechPrereq@CvProcessInfo@@QBEHXZ
_TEXT	SEGMENT
?getTechPrereq@CvProcessInfo@@QBEHXZ PROC		; CvProcessInfo::getTechPrereq, COMDAT
; _this$ = ecx

; 6306 : 	return m_iTechPrereq;

	mov	eax, DWORD PTR [ecx+260]

; 6307 : }

	ret	0
?getTechPrereq@CvProcessInfo@@QBEHXZ ENDP		; CvProcessInfo::getTechPrereq
_TEXT	ENDS
PUBLIC	?getProductionToYieldModifier@CvProcessInfo@@QBEHH@Z ; CvProcessInfo::getProductionToYieldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getProductionToYieldModifier@CvProcessInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getProductionToYieldModifier@CvProcessInfo@@QBEHH@Z PROC ; CvProcessInfo::getProductionToYieldModifier, COMDAT
; _this$ = ecx

; 6312 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 6313 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 6314 : 	return m_paiProductionToYieldModifier ? m_paiProductionToYieldModifier[i] : -1;

	mov	eax, DWORD PTR [ecx+264]
	test	eax, eax
	je	SHORT $LN3@getProduct@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 6315 : }

	ret	4
$LN3@getProduct@2:

; 6312 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 6313 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 6314 : 	return m_paiProductionToYieldModifier ? m_paiProductionToYieldModifier[i] : -1;

	or	eax, -1

; 6315 : }

	ret	4
?getProductionToYieldModifier@CvProcessInfo@@QBEHH@Z ENDP ; CvProcessInfo::getProductionToYieldModifier
_TEXT	ENDS
PUBLIC	?GetFlavorValue@CvProcessInfo@@QBEHH@Z		; CvProcessInfo::GetFlavorValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlavorValue@CvProcessInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFlavorValue@CvProcessInfo@@QBEHH@Z PROC		; CvProcessInfo::GetFlavorValue, COMDAT
; _this$ = ecx

; 6320 : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 6321 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 6322 : 	return m_paiFlavorValue ? m_paiFlavorValue[i] : -1;

	mov	eax, DWORD PTR [ecx+268]
	test	eax, eax
	je	SHORT $LN3@GetFlavorV
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 6323 : }

	ret	4
$LN3@GetFlavorV:

; 6320 : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 6321 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 6322 : 	return m_paiFlavorValue ? m_paiFlavorValue[i] : -1;

	or	eax, -1

; 6323 : }

	ret	4
?GetFlavorValue@CvProcessInfo@@QBEHH@Z ENDP		; CvProcessInfo::GetFlavorValue
_TEXT	ENDS
PUBLIC	?getPopulationThreshold@CvVoteInfo@@QBEHXZ	; CvVoteInfo::getPopulationThreshold
; Function compile flags: /Ogtpy
;	COMDAT ?getPopulationThreshold@CvVoteInfo@@QBEHXZ
_TEXT	SEGMENT
?getPopulationThreshold@CvVoteInfo@@QBEHXZ PROC		; CvVoteInfo::getPopulationThreshold, COMDAT
; _this$ = ecx

; 6372 : 	return m_iPopulationThreshold;

	mov	eax, DWORD PTR [ecx+260]

; 6373 : }

	ret	0
?getPopulationThreshold@CvVoteInfo@@QBEHXZ ENDP		; CvVoteInfo::getPopulationThreshold
_TEXT	ENDS
PUBLIC	?getMinVoters@CvVoteInfo@@QBEHXZ		; CvVoteInfo::getMinVoters
; Function compile flags: /Ogtpy
;	COMDAT ?getMinVoters@CvVoteInfo@@QBEHXZ
_TEXT	SEGMENT
?getMinVoters@CvVoteInfo@@QBEHXZ PROC			; CvVoteInfo::getMinVoters, COMDAT
; _this$ = ecx

; 6377 : 	return m_iMinVoters;

	mov	eax, DWORD PTR [ecx+264]

; 6378 : }

	ret	0
?getMinVoters@CvVoteInfo@@QBEHXZ ENDP			; CvVoteInfo::getMinVoters
_TEXT	ENDS
PUBLIC	?isSecretaryGeneral@CvVoteInfo@@QBE_NXZ		; CvVoteInfo::isSecretaryGeneral
; Function compile flags: /Ogtpy
;	COMDAT ?isSecretaryGeneral@CvVoteInfo@@QBE_NXZ
_TEXT	SEGMENT
?isSecretaryGeneral@CvVoteInfo@@QBE_NXZ PROC		; CvVoteInfo::isSecretaryGeneral, COMDAT
; _this$ = ecx

; 6382 : 	return m_bSecretaryGeneral;

	mov	al, BYTE PTR [ecx+268]

; 6383 : }

	ret	0
?isSecretaryGeneral@CvVoteInfo@@QBE_NXZ ENDP		; CvVoteInfo::isSecretaryGeneral
_TEXT	ENDS
PUBLIC	?isVictory@CvVoteInfo@@QBE_NXZ			; CvVoteInfo::isVictory
; Function compile flags: /Ogtpy
;	COMDAT ?isVictory@CvVoteInfo@@QBE_NXZ
_TEXT	SEGMENT
?isVictory@CvVoteInfo@@QBE_NXZ PROC			; CvVoteInfo::isVictory, COMDAT
; _this$ = ecx

; 6387 : 	return m_bVictory;

	mov	al, BYTE PTR [ecx+269]

; 6388 : }

	ret	0
?isVictory@CvVoteInfo@@QBE_NXZ ENDP			; CvVoteInfo::isVictory
_TEXT	ENDS
PUBLIC	?isNoNukes@CvVoteInfo@@QBE_NXZ			; CvVoteInfo::isNoNukes
; Function compile flags: /Ogtpy
;	COMDAT ?isNoNukes@CvVoteInfo@@QBE_NXZ
_TEXT	SEGMENT
?isNoNukes@CvVoteInfo@@QBE_NXZ PROC			; CvVoteInfo::isNoNukes, COMDAT
; _this$ = ecx

; 6392 : 	return m_bNoNukes;

	mov	al, BYTE PTR [ecx+270]

; 6393 : }

	ret	0
?isNoNukes@CvVoteInfo@@QBE_NXZ ENDP			; CvVoteInfo::isNoNukes
_TEXT	ENDS
PUBLIC	?isCityVoting@CvVoteInfo@@QBE_NXZ		; CvVoteInfo::isCityVoting
; Function compile flags: /Ogtpy
;	COMDAT ?isCityVoting@CvVoteInfo@@QBE_NXZ
_TEXT	SEGMENT
?isCityVoting@CvVoteInfo@@QBE_NXZ PROC			; CvVoteInfo::isCityVoting, COMDAT
; _this$ = ecx

; 6397 : 	return m_bCityVoting;

	mov	al, BYTE PTR [ecx+271]

; 6398 : }

	ret	0
?isCityVoting@CvVoteInfo@@QBE_NXZ ENDP			; CvVoteInfo::isCityVoting
_TEXT	ENDS
PUBLIC	?isCivVoting@CvVoteInfo@@QBE_NXZ		; CvVoteInfo::isCivVoting
; Function compile flags: /Ogtpy
;	COMDAT ?isCivVoting@CvVoteInfo@@QBE_NXZ
_TEXT	SEGMENT
?isCivVoting@CvVoteInfo@@QBE_NXZ PROC			; CvVoteInfo::isCivVoting, COMDAT
; _this$ = ecx

; 6402 : 	return m_bCivVoting;

	mov	al, BYTE PTR [ecx+272]

; 6403 : }

	ret	0
?isCivVoting@CvVoteInfo@@QBE_NXZ ENDP			; CvVoteInfo::isCivVoting
_TEXT	ENDS
PUBLIC	?isDefensivePact@CvVoteInfo@@QBE_NXZ		; CvVoteInfo::isDefensivePact
; Function compile flags: /Ogtpy
;	COMDAT ?isDefensivePact@CvVoteInfo@@QBE_NXZ
_TEXT	SEGMENT
?isDefensivePact@CvVoteInfo@@QBE_NXZ PROC		; CvVoteInfo::isDefensivePact, COMDAT
; _this$ = ecx

; 6407 : 	return m_bDefensivePact;

	mov	al, BYTE PTR [ecx+273]

; 6408 : }

	ret	0
?isDefensivePact@CvVoteInfo@@QBE_NXZ ENDP		; CvVoteInfo::isDefensivePact
_TEXT	ENDS
PUBLIC	?isOpenBorders@CvVoteInfo@@QBE_NXZ		; CvVoteInfo::isOpenBorders
; Function compile flags: /Ogtpy
;	COMDAT ?isOpenBorders@CvVoteInfo@@QBE_NXZ
_TEXT	SEGMENT
?isOpenBorders@CvVoteInfo@@QBE_NXZ PROC			; CvVoteInfo::isOpenBorders, COMDAT
; _this$ = ecx

; 6412 : 	return m_bOpenBorders;

	mov	al, BYTE PTR [ecx+274]

; 6413 : }

	ret	0
?isOpenBorders@CvVoteInfo@@QBE_NXZ ENDP			; CvVoteInfo::isOpenBorders
_TEXT	ENDS
PUBLIC	?isForcePeace@CvVoteInfo@@QBE_NXZ		; CvVoteInfo::isForcePeace
; Function compile flags: /Ogtpy
;	COMDAT ?isForcePeace@CvVoteInfo@@QBE_NXZ
_TEXT	SEGMENT
?isForcePeace@CvVoteInfo@@QBE_NXZ PROC			; CvVoteInfo::isForcePeace, COMDAT
; _this$ = ecx

; 6417 : 	return m_bForcePeace;

	mov	al, BYTE PTR [ecx+275]

; 6418 : }

	ret	0
?isForcePeace@CvVoteInfo@@QBE_NXZ ENDP			; CvVoteInfo::isForcePeace
_TEXT	ENDS
PUBLIC	?isForceNoTrade@CvVoteInfo@@QBE_NXZ		; CvVoteInfo::isForceNoTrade
; Function compile flags: /Ogtpy
;	COMDAT ?isForceNoTrade@CvVoteInfo@@QBE_NXZ
_TEXT	SEGMENT
?isForceNoTrade@CvVoteInfo@@QBE_NXZ PROC		; CvVoteInfo::isForceNoTrade, COMDAT
; _this$ = ecx

; 6422 : 	return m_bForceNoTrade;

	mov	al, BYTE PTR [ecx+276]

; 6423 : }

	ret	0
?isForceNoTrade@CvVoteInfo@@QBE_NXZ ENDP		; CvVoteInfo::isForceNoTrade
_TEXT	ENDS
PUBLIC	?isForceWar@CvVoteInfo@@QBE_NXZ			; CvVoteInfo::isForceWar
; Function compile flags: /Ogtpy
;	COMDAT ?isForceWar@CvVoteInfo@@QBE_NXZ
_TEXT	SEGMENT
?isForceWar@CvVoteInfo@@QBE_NXZ PROC			; CvVoteInfo::isForceWar, COMDAT
; _this$ = ecx

; 6427 : 	return m_bForceWar;

	mov	al, BYTE PTR [ecx+277]

; 6428 : }

	ret	0
?isForceWar@CvVoteInfo@@QBE_NXZ ENDP			; CvVoteInfo::isForceWar
_TEXT	ENDS
PUBLIC	?isAssignCity@CvVoteInfo@@QBE_NXZ		; CvVoteInfo::isAssignCity
; Function compile flags: /Ogtpy
;	COMDAT ?isAssignCity@CvVoteInfo@@QBE_NXZ
_TEXT	SEGMENT
?isAssignCity@CvVoteInfo@@QBE_NXZ PROC			; CvVoteInfo::isAssignCity, COMDAT
; _this$ = ecx

; 6432 : 	return m_bAssignCity;

	mov	al, BYTE PTR [ecx+278]

; 6433 : }

	ret	0
?isAssignCity@CvVoteInfo@@QBE_NXZ ENDP			; CvVoteInfo::isAssignCity
_TEXT	ENDS
PUBLIC	?isVoteSourceType@CvVoteInfo@@QBE_NH@Z		; CvVoteInfo::isVoteSourceType
; Function compile flags: /Ogtpy
;	COMDAT ?isVoteSourceType@CvVoteInfo@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?isVoteSourceType@CvVoteInfo@@QBE_NH@Z PROC		; CvVoteInfo::isVoteSourceType, COMDAT
; _this$ = ecx

; 6437 : 	CvAssertMsg(i < GC.getNumVoteSourceInfos(), "Index out of bounds");
; 6438 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 6439 : 	return m_abVoteSourceTypes ? m_abVoteSourceTypes[i] : false;

	mov	eax, DWORD PTR [ecx+280]
	test	eax, eax
	je	SHORT $LN3@isVoteSour
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 6440 : }

	ret	4
$LN3@isVoteSour:

; 6437 : 	CvAssertMsg(i < GC.getNumVoteSourceInfos(), "Index out of bounds");
; 6438 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 6439 : 	return m_abVoteSourceTypes ? m_abVoteSourceTypes[i] : false;

	xor	al, al

; 6440 : }

	ret	4
?isVoteSourceType@CvVoteInfo@@QBE_NH@Z ENDP		; CvVoteInfo::isVoteSourceType
_TEXT	ENDS
PUBLIC	?getUpdateFormation@CvEntityEventInfo@@QBE_NXZ	; CvEntityEventInfo::getUpdateFormation
; Function compile flags: /Ogtpy
;	COMDAT ?getUpdateFormation@CvEntityEventInfo@@QBE_NXZ
_TEXT	SEGMENT
?getUpdateFormation@CvEntityEventInfo@@QBE_NXZ PROC	; CvEntityEventInfo::getUpdateFormation, COMDAT
; _this$ = ecx

; 6520 : 	return m_bUpdateFormation;

	mov	al, BYTE PTR [ecx+276]

; 6521 : }

	ret	0
?getUpdateFormation@CvEntityEventInfo@@QBE_NXZ ENDP	; CvEntityEventInfo::getUpdateFormation
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	?getStartingUnitMultiplier@CvEraInfo@@QBEHXZ	; CvEraInfo::getStartingUnitMultiplier
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
;	COMDAT ?getStartingUnitMultiplier@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartingUnitMultiplier@CvEraInfo@@QBEHXZ PROC	; CvEraInfo::getStartingUnitMultiplier, COMDAT
; _this$ = ecx

; 6571 : 	return m_iStartingUnitMultiplier;

	mov	eax, DWORD PTR [ecx+260]

; 6572 : }

	ret	0
?getStartingUnitMultiplier@CvEraInfo@@QBEHXZ ENDP	; CvEraInfo::getStartingUnitMultiplier
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator@4
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator@4:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	?getStartingDefenseUnits@CvEraInfo@@QBEHXZ	; CvEraInfo::getStartingDefenseUnits
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
;	COMDAT ?getStartingDefenseUnits@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartingDefenseUnits@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getStartingDefenseUnits, COMDAT
; _this$ = ecx

; 6576 : 	return m_iStartingDefenseUnits;

	mov	eax, DWORD PTR [ecx+264]

; 6577 : }

	ret	0
?getStartingDefenseUnits@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getStartingDefenseUnits
_TEXT	ENDS
PUBLIC	?getStartingWorkerUnits@CvEraInfo@@QBEHXZ	; CvEraInfo::getStartingWorkerUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getStartingWorkerUnits@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartingWorkerUnits@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getStartingWorkerUnits, COMDAT
; _this$ = ecx

; 6581 : 	return m_iStartingWorkerUnits;

	mov	eax, DWORD PTR [ecx+268]

; 6582 : }

	ret	0
?getStartingWorkerUnits@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getStartingWorkerUnits
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?getStartingExploreUnits@CvEraInfo@@QBEHXZ	; CvEraInfo::getStartingExploreUnits
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
;	COMDAT ?getStartingExploreUnits@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartingExploreUnits@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getStartingExploreUnits, COMDAT
; _this$ = ecx

; 6586 : 	return m_iStartingExploreUnits;

	mov	eax, DWORD PTR [ecx+272]

; 6587 : }

	ret	0
?getStartingExploreUnits@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getStartingExploreUnits
_TEXT	ENDS
PUBLIC	?getResearchAgreementCost@CvEraInfo@@QBEHXZ	; CvEraInfo::getResearchAgreementCost
; Function compile flags: /Ogtpy
;	COMDAT ?getResearchAgreementCost@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getResearchAgreementCost@CvEraInfo@@QBEHXZ PROC	; CvEraInfo::getResearchAgreementCost, COMDAT
; _this$ = ecx

; 6591 : 	return m_iResearchAgreementCost;

	mov	eax, DWORD PTR [ecx+276]

; 6592 : }

	ret	0
?getResearchAgreementCost@CvEraInfo@@QBEHXZ ENDP	; CvEraInfo::getResearchAgreementCost
_TEXT	ENDS
PUBLIC	?GetCString@CvString@@QBEPBDXZ			; CvString::GetCString
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ?GetCString@CvString@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@CvString@@QBEPBDXZ PROC			; CvString::GetCString, COMDAT
; _this$ = ecx

; 42   : 	const char* GetCString() const 	{ return c_str(); }

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCString@CvString@@QBEPBDXZ ENDP			; CvString::GetCString
_TEXT	ENDS
PUBLIC	?getEmbarkedUnitDefense@CvEraInfo@@QBEHXZ	; CvEraInfo::getEmbarkedUnitDefense
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
;	COMDAT ?getEmbarkedUnitDefense@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getEmbarkedUnitDefense@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getEmbarkedUnitDefense, COMDAT
; _this$ = ecx

; 6596 : 	return m_iEmbarkedUnitDefense;

	mov	eax, DWORD PTR [ecx+280]

; 6597 : }

	ret	0
?getEmbarkedUnitDefense@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getEmbarkedUnitDefense
_TEXT	ENDS
PUBLIC	?getStartingGold@CvEraInfo@@QBEHXZ		; CvEraInfo::getStartingGold
; Function compile flags: /Ogtpy
;	COMDAT ?getStartingGold@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartingGold@CvEraInfo@@QBEHXZ PROC			; CvEraInfo::getStartingGold, COMDAT
; _this$ = ecx

; 6601 : 	return m_iStartingGold;

	mov	eax, DWORD PTR [ecx+284]

; 6602 : }

	ret	0
?getStartingGold@CvEraInfo@@QBEHXZ ENDP			; CvEraInfo::getStartingGold
_TEXT	ENDS
PUBLIC	?getStartingCulture@CvEraInfo@@QBEHXZ		; CvEraInfo::getStartingCulture
; Function compile flags: /Ogtpy
;	COMDAT ?getStartingCulture@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartingCulture@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getStartingCulture, COMDAT
; _this$ = ecx

; 6606 : 	return m_iStartingCulture;

	mov	eax, DWORD PTR [ecx+288]

; 6607 : }

	ret	0
?getStartingCulture@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getStartingCulture
_TEXT	ENDS
PUBLIC	?getFreePopulation@CvEraInfo@@QBEHXZ		; CvEraInfo::getFreePopulation
; Function compile flags: /Ogtpy
;	COMDAT ?getFreePopulation@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getFreePopulation@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getFreePopulation, COMDAT
; _this$ = ecx

; 6611 : 	return m_iFreePopulation;

	mov	eax, DWORD PTR [ecx+292]

; 6612 : }

	ret	0
?getFreePopulation@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getFreePopulation
_TEXT	ENDS
PUBLIC	?getLaterEraBuildingConstructMod@CvEraInfo@@QBEHXZ ; CvEraInfo::getLaterEraBuildingConstructMod
; Function compile flags: /Ogtpy
;	COMDAT ?getLaterEraBuildingConstructMod@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getLaterEraBuildingConstructMod@CvEraInfo@@QBEHXZ PROC	; CvEraInfo::getLaterEraBuildingConstructMod, COMDAT
; _this$ = ecx

; 6616 : 	return m_iLaterEraBuildingConstructMod;

	mov	eax, DWORD PTR [ecx+296]

; 6617 : }

	ret	0
?getLaterEraBuildingConstructMod@CvEraInfo@@QBEHXZ ENDP	; CvEraInfo::getLaterEraBuildingConstructMod
_TEXT	ENDS
PUBLIC	?getStartPercent@CvEraInfo@@QBEHXZ		; CvEraInfo::getStartPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getStartPercent@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getStartPercent@CvEraInfo@@QBEHXZ PROC			; CvEraInfo::getStartPercent, COMDAT
; _this$ = ecx

; 6621 : 	return m_iStartPercent;

	mov	eax, DWORD PTR [ecx+300]

; 6622 : }

	ret	0
?getStartPercent@CvEraInfo@@QBEHXZ ENDP			; CvEraInfo::getStartPercent
_TEXT	ENDS
PUBLIC	?getBuildingMaintenancePercent@CvEraInfo@@QBEHXZ ; CvEraInfo::getBuildingMaintenancePercent
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildingMaintenancePercent@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getBuildingMaintenancePercent@CvEraInfo@@QBEHXZ PROC	; CvEraInfo::getBuildingMaintenancePercent, COMDAT
; _this$ = ecx

; 6626 : 	return m_iBuildingMaintenancePercent;

	mov	eax, DWORD PTR [ecx+304]

; 6627 : }

	ret	0
?getBuildingMaintenancePercent@CvEraInfo@@QBEHXZ ENDP	; CvEraInfo::getBuildingMaintenancePercent
_TEXT	ENDS
PUBLIC	?getGrowthPercent@CvEraInfo@@QBEHXZ		; CvEraInfo::getGrowthPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getGrowthPercent@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getGrowthPercent@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getGrowthPercent, COMDAT
; _this$ = ecx

; 6631 : 	return m_iGrowthPercent;

	mov	eax, DWORD PTR [ecx+308]

; 6632 : }

	ret	0
?getGrowthPercent@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getGrowthPercent
_TEXT	ENDS
PUBLIC	?getTrainPercent@CvEraInfo@@QBEHXZ		; CvEraInfo::getTrainPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getTrainPercent@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getTrainPercent@CvEraInfo@@QBEHXZ PROC			; CvEraInfo::getTrainPercent, COMDAT
; _this$ = ecx

; 6636 : 	return m_iTrainPercent;

	mov	eax, DWORD PTR [ecx+312]

; 6637 : }

	ret	0
?getTrainPercent@CvEraInfo@@QBEHXZ ENDP			; CvEraInfo::getTrainPercent
_TEXT	ENDS
PUBLIC	?getConstructPercent@CvEraInfo@@QBEHXZ		; CvEraInfo::getConstructPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getConstructPercent@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getConstructPercent@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getConstructPercent, COMDAT
; _this$ = ecx

; 6641 : 	return m_iConstructPercent;

	mov	eax, DWORD PTR [ecx+316]

; 6642 : }

	ret	0
?getConstructPercent@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getConstructPercent
_TEXT	ENDS
PUBLIC	?getCreatePercent@CvEraInfo@@QBEHXZ		; CvEraInfo::getCreatePercent
; Function compile flags: /Ogtpy
;	COMDAT ?getCreatePercent@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getCreatePercent@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getCreatePercent, COMDAT
; _this$ = ecx

; 6646 : 	return m_iCreatePercent;

	mov	eax, DWORD PTR [ecx+320]

; 6647 : }

	ret	0
?getCreatePercent@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getCreatePercent
_TEXT	ENDS
PUBLIC	?getResearchPercent@CvEraInfo@@QBEHXZ		; CvEraInfo::getResearchPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getResearchPercent@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getResearchPercent@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getResearchPercent, COMDAT
; _this$ = ecx

; 6651 : 	return m_iResearchPercent;

	mov	eax, DWORD PTR [ecx+324]

; 6652 : }

	ret	0
?getResearchPercent@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getResearchPercent
_TEXT	ENDS
PUBLIC	?getBuildPercent@CvEraInfo@@QBEHXZ		; CvEraInfo::getBuildPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildPercent@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getBuildPercent@CvEraInfo@@QBEHXZ PROC			; CvEraInfo::getBuildPercent, COMDAT
; _this$ = ecx

; 6656 : 	return m_iBuildPercent;

	mov	eax, DWORD PTR [ecx+328]

; 6657 : }

	ret	0
?getBuildPercent@CvEraInfo@@QBEHXZ ENDP			; CvEraInfo::getBuildPercent
_TEXT	ENDS
PUBLIC	?getImprovementPercent@CvEraInfo@@QBEHXZ	; CvEraInfo::getImprovementPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getImprovementPercent@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getImprovementPercent@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getImprovementPercent, COMDAT
; _this$ = ecx

; 6661 : 	return m_iImprovementPercent;

	mov	eax, DWORD PTR [ecx+332]

; 6662 : }

	ret	0
?getImprovementPercent@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getImprovementPercent
_TEXT	ENDS
PUBLIC	?getGreatPeoplePercent@CvEraInfo@@QBEHXZ	; CvEraInfo::getGreatPeoplePercent
; Function compile flags: /Ogtpy
;	COMDAT ?getGreatPeoplePercent@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getGreatPeoplePercent@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getGreatPeoplePercent, COMDAT
; _this$ = ecx

; 6666 : 	return m_iGreatPeoplePercent;

	mov	eax, DWORD PTR [ecx+336]

; 6667 : }

	ret	0
?getGreatPeoplePercent@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getGreatPeoplePercent
_TEXT	ENDS
PUBLIC	?getEventChancePerTurn@CvEraInfo@@QBEHXZ	; CvEraInfo::getEventChancePerTurn
; Function compile flags: /Ogtpy
;	COMDAT ?getEventChancePerTurn@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getEventChancePerTurn@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getEventChancePerTurn, COMDAT
; _this$ = ecx

; 6671 : 	return m_iEventChancePerTurn;

	mov	eax, DWORD PTR [ecx+340]

; 6672 : }

	ret	0
?getEventChancePerTurn@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getEventChancePerTurn
_TEXT	ENDS
PUBLIC	?getSpiesGrantedForPlayer@CvEraInfo@@QBEHXZ	; CvEraInfo::getSpiesGrantedForPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?getSpiesGrantedForPlayer@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getSpiesGrantedForPlayer@CvEraInfo@@QBEHXZ PROC	; CvEraInfo::getSpiesGrantedForPlayer, COMDAT
; _this$ = ecx

; 6677 : 	return m_iSpiesGrantedForPlayer;

	mov	eax, DWORD PTR [ecx+344]

; 6678 : }

	ret	0
?getSpiesGrantedForPlayer@CvEraInfo@@QBEHXZ ENDP	; CvEraInfo::getSpiesGrantedForPlayer
_TEXT	ENDS
PUBLIC	?getSpiesGrantedForEveryone@CvEraInfo@@QBEHXZ	; CvEraInfo::getSpiesGrantedForEveryone
; Function compile flags: /Ogtpy
;	COMDAT ?getSpiesGrantedForEveryone@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getSpiesGrantedForEveryone@CvEraInfo@@QBEHXZ PROC	; CvEraInfo::getSpiesGrantedForEveryone, COMDAT
; _this$ = ecx

; 6683 : 	return m_iSpiesGrantedForEveryone;

	mov	eax, DWORD PTR [ecx+348]

; 6684 : }

	ret	0
?getSpiesGrantedForEveryone@CvEraInfo@@QBEHXZ ENDP	; CvEraInfo::getSpiesGrantedForEveryone
_TEXT	ENDS
PUBLIC	?getFaithCostMultiplier@CvEraInfo@@QBEHXZ	; CvEraInfo::getFaithCostMultiplier
; Function compile flags: /Ogtpy
;	COMDAT ?getFaithCostMultiplier@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getFaithCostMultiplier@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getFaithCostMultiplier, COMDAT
; _this$ = ecx

; 6689 : 	return m_iFaithCostMultiplier;

	mov	eax, DWORD PTR [ecx+352]

; 6690 : }

	ret	0
?getFaithCostMultiplier@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getFaithCostMultiplier
_TEXT	ENDS
PUBLIC	?getDiploEmphasisReligion@CvEraInfo@@QBEHXZ	; CvEraInfo::getDiploEmphasisReligion
; Function compile flags: /Ogtpy
;	COMDAT ?getDiploEmphasisReligion@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getDiploEmphasisReligion@CvEraInfo@@QBEHXZ PROC	; CvEraInfo::getDiploEmphasisReligion, COMDAT
; _this$ = ecx

; 6695 : 	return m_iDiploEmphasisReligion;

	mov	eax, DWORD PTR [ecx+356]

; 6696 : }

	ret	0
?getDiploEmphasisReligion@CvEraInfo@@QBEHXZ ENDP	; CvEraInfo::getDiploEmphasisReligion
_TEXT	ENDS
PUBLIC	?getDiplpEmphasisLatePolicies@CvEraInfo@@QBEHXZ	; CvEraInfo::getDiplpEmphasisLatePolicies
; Function compile flags: /Ogtpy
;	COMDAT ?getDiplpEmphasisLatePolicies@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getDiplpEmphasisLatePolicies@CvEraInfo@@QBEHXZ PROC	; CvEraInfo::getDiplpEmphasisLatePolicies, COMDAT
; _this$ = ecx

; 6701 : 	return m_iDiplpEmphasisLatePolicies;

	mov	eax, DWORD PTR [ecx+360]

; 6702 : }

	ret	0
?getDiplpEmphasisLatePolicies@CvEraInfo@@QBEHXZ ENDP	; CvEraInfo::getDiplpEmphasisLatePolicies
_TEXT	ENDS
PUBLIC	?getTradeRouteFoodBonusTimes100@CvEraInfo@@QBEHXZ ; CvEraInfo::getTradeRouteFoodBonusTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?getTradeRouteFoodBonusTimes100@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getTradeRouteFoodBonusTimes100@CvEraInfo@@QBEHXZ PROC	; CvEraInfo::getTradeRouteFoodBonusTimes100, COMDAT
; _this$ = ecx

; 6707 : 	return m_iTradeRouteFoodBonusTimes100;

	mov	eax, DWORD PTR [ecx+364]

; 6708 : }

	ret	0
?getTradeRouteFoodBonusTimes100@CvEraInfo@@QBEHXZ ENDP	; CvEraInfo::getTradeRouteFoodBonusTimes100
_TEXT	ENDS
PUBLIC	?getTradeRouteProductionBonusTimes100@CvEraInfo@@QBEHXZ ; CvEraInfo::getTradeRouteProductionBonusTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?getTradeRouteProductionBonusTimes100@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getTradeRouteProductionBonusTimes100@CvEraInfo@@QBEHXZ PROC ; CvEraInfo::getTradeRouteProductionBonusTimes100, COMDAT
; _this$ = ecx

; 6713 : 	return m_iTradeRouteProductionBonusTimes100;

	mov	eax, DWORD PTR [ecx+368]

; 6714 : }

	ret	0
?getTradeRouteProductionBonusTimes100@CvEraInfo@@QBEHXZ ENDP ; CvEraInfo::getTradeRouteProductionBonusTimes100
_TEXT	ENDS
PUBLIC	?getLeaguePercent@CvEraInfo@@QBEHXZ		; CvEraInfo::getLeaguePercent
; Function compile flags: /Ogtpy
;	COMDAT ?getLeaguePercent@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getLeaguePercent@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getLeaguePercent, COMDAT
; _this$ = ecx

; 6719 : 	return m_iLeaguePercent;

	mov	eax, DWORD PTR [ecx+372]

; 6720 : }

	ret	0
?getLeaguePercent@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getLeaguePercent
_TEXT	ENDS
PUBLIC	?getWarmongerPercent@CvEraInfo@@QBEHXZ		; CvEraInfo::getWarmongerPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getWarmongerPercent@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?getWarmongerPercent@CvEraInfo@@QBEHXZ PROC		; CvEraInfo::getWarmongerPercent, COMDAT
; _this$ = ecx

; 6725 : 	return m_iWarmongerPercent;

	mov	eax, DWORD PTR [ecx+376]

; 6726 : }

	ret	0
?getWarmongerPercent@CvEraInfo@@QBEHXZ ENDP		; CvEraInfo::getWarmongerPercent
_TEXT	ENDS
PUBLIC	?getArtPrefix@CvEraInfo@@QBEPBDXZ		; CvEraInfo::getArtPrefix
; Function compile flags: /Ogtpy
;	COMDAT ?getArtPrefix@CvEraInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getArtPrefix@CvEraInfo@@QBEPBDXZ PROC			; CvEraInfo::getArtPrefix, COMDAT
; _this$ = ecx

; 6731 : 	return m_strArtPrefix.c_str();

	add	ecx, 464				; 000001d0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getArtPrefix@CvEraInfo@@QBEPBDXZ ENDP			; CvEraInfo::getArtPrefix
_TEXT	ENDS
PUBLIC	?GetCityBombardEffectTag@CvEraInfo@@QBEPBDXZ	; CvEraInfo::GetCityBombardEffectTag
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityBombardEffectTag@CvEraInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetCityBombardEffectTag@CvEraInfo@@QBEPBDXZ PROC	; CvEraInfo::GetCityBombardEffectTag, COMDAT
; _this$ = ecx

; 6736 : 	return m_strCityBombardEffectTag;

	add	ecx, 380				; 0000017cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCityBombardEffectTag@CvEraInfo@@QBEPBDXZ ENDP	; CvEraInfo::GetCityBombardEffectTag
_TEXT	ENDS
PUBLIC	?GetCityBombardEffectTagHash@CvEraInfo@@QBEIXZ	; CvEraInfo::GetCityBombardEffectTagHash
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityBombardEffectTagHash@CvEraInfo@@QBEIXZ
_TEXT	SEGMENT
?GetCityBombardEffectTagHash@CvEraInfo@@QBEIXZ PROC	; CvEraInfo::GetCityBombardEffectTagHash, COMDAT
; _this$ = ecx

; 6741 : 	return m_uiCityBombardEffectTagHash;

	mov	eax, DWORD PTR [ecx+548]

; 6742 : }

	ret	0
?GetCityBombardEffectTagHash@CvEraInfo@@QBEIXZ ENDP	; CvEraInfo::GetCityBombardEffectTagHash
_TEXT	ENDS
PUBLIC	?getAudioUnitVictoryScript@CvEraInfo@@QBEPBDXZ	; CvEraInfo::getAudioUnitVictoryScript
; Function compile flags: /Ogtpy
;	COMDAT ?getAudioUnitVictoryScript@CvEraInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getAudioUnitVictoryScript@CvEraInfo@@QBEPBDXZ PROC	; CvEraInfo::getAudioUnitVictoryScript, COMDAT
; _this$ = ecx

; 6746 : 	return m_strAudioUnitVictoryScript;

	add	ecx, 408				; 00000198H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getAudioUnitVictoryScript@CvEraInfo@@QBEPBDXZ ENDP	; CvEraInfo::getAudioUnitVictoryScript
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?getAudioUnitDefeatScript@CvEraInfo@@QBEPBDXZ	; CvEraInfo::getAudioUnitDefeatScript
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
;	COMDAT ?getAudioUnitDefeatScript@CvEraInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getAudioUnitDefeatScript@CvEraInfo@@QBEPBDXZ PROC	; CvEraInfo::getAudioUnitDefeatScript, COMDAT
; _this$ = ecx

; 6751 : 	return m_strAudioUnitDefeatScript;

	add	ecx, 436				; 000001b4H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getAudioUnitDefeatScript@CvEraInfo@@QBEPBDXZ ENDP	; CvEraInfo::getAudioUnitDefeatScript
_TEXT	ENDS
PUBLIC	?isNoGoodies@CvEraInfo@@QBE_NXZ			; CvEraInfo::isNoGoodies
; Function compile flags: /Ogtpy
;	COMDAT ?isNoGoodies@CvEraInfo@@QBE_NXZ
_TEXT	SEGMENT
?isNoGoodies@CvEraInfo@@QBE_NXZ PROC			; CvEraInfo::isNoGoodies, COMDAT
; _this$ = ecx

; 6756 : 	return m_bNoGoodies;

	mov	al, BYTE PTR [ecx+552]

; 6757 : }

	ret	0
?isNoGoodies@CvEraInfo@@QBE_NXZ ENDP			; CvEraInfo::isNoGoodies
_TEXT	ENDS
PUBLIC	?isNoBarbUnits@CvEraInfo@@QBE_NXZ		; CvEraInfo::isNoBarbUnits
; Function compile flags: /Ogtpy
;	COMDAT ?isNoBarbUnits@CvEraInfo@@QBE_NXZ
_TEXT	SEGMENT
?isNoBarbUnits@CvEraInfo@@QBE_NXZ PROC			; CvEraInfo::isNoBarbUnits, COMDAT
; _this$ = ecx

; 6761 : 	return m_bNoBarbUnits;

	mov	al, BYTE PTR [ecx+553]

; 6762 : }//------------------------------------------------------------------------------

	ret	0
?isNoBarbUnits@CvEraInfo@@QBE_NXZ ENDP			; CvEraInfo::isNoBarbUnits
_TEXT	ENDS
PUBLIC	?isNoReligion@CvEraInfo@@QBE_NXZ		; CvEraInfo::isNoReligion
; Function compile flags: /Ogtpy
;	COMDAT ?isNoReligion@CvEraInfo@@QBE_NXZ
_TEXT	SEGMENT
?isNoReligion@CvEraInfo@@QBE_NXZ PROC			; CvEraInfo::isNoReligion, COMDAT
; _this$ = ecx

; 6765 : 	return m_bNoReligion;

	mov	al, BYTE PTR [ecx+554]

; 6766 : }

	ret	0
?isNoReligion@CvEraInfo@@QBE_NXZ ENDP			; CvEraInfo::isNoReligion
_TEXT	ENDS
PUBLIC	?getShortDesc@CvEraInfo@@QBEPBDXZ		; CvEraInfo::getShortDesc
; Function compile flags: /Ogtpy
;	COMDAT ?getShortDesc@CvEraInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getShortDesc@CvEraInfo@@QBEPBDXZ PROC			; CvEraInfo::getShortDesc, COMDAT
; _this$ = ecx

; 6781 : 	return m_strShortDesc.c_str();

	add	ecx, 492				; 000001ecH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getShortDesc@CvEraInfo@@QBEPBDXZ ENDP			; CvEraInfo::getShortDesc
_TEXT	ENDS
PUBLIC	?getAbbreviation@CvEraInfo@@QBEPBDXZ		; CvEraInfo::getAbbreviation
; Function compile flags: /Ogtpy
;	COMDAT ?getAbbreviation@CvEraInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getAbbreviation@CvEraInfo@@QBEPBDXZ PROC		; CvEraInfo::getAbbreviation, COMDAT
; _this$ = ecx

; 6787 : 	return m_strAbbreviation.c_str();

	add	ecx, 520				; 00000208H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getAbbreviation@CvEraInfo@@QBEPBDXZ ENDP		; CvEraInfo::getAbbreviation
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??0CvColorA@@QAE@MMMM@Z				; CvColorA::CvColorA
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
;	COMDAT ??0CvColorA@@QAE@MMMM@Z
_TEXT	SEGMENT
_fr$ = 8						; size = 4
_fg$ = 12						; size = 4
_fb$ = 16						; size = 4
_fa$ = 20						; size = 4
??0CvColorA@@QAE@MMMM@Z PROC				; CvColorA::CvColorA, COMDAT
; _this$ = ecx

; 5    : 	CvColorA(float fr, float fg, float fb, float fa) : r(fr), g(fg), b(fb), a(fa) {}

	mov	edx, DWORD PTR _fg$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _fr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _fb$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _fa$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	ret	16					; 00000010H
??0CvColorA@@QAE@MMMM@Z ENDP				; CvColorA::CvColorA
_TEXT	ENDS
PUBLIC	?GetColor@CvColorInfo@@QBEABUCvColorA@@XZ	; CvColorInfo::GetColor
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
;	COMDAT ?GetColor@CvColorInfo@@QBEABUCvColorA@@XZ
_TEXT	SEGMENT
?GetColor@CvColorInfo@@QBEABUCvColorA@@XZ PROC		; CvColorInfo::GetColor, COMDAT
; _this$ = ecx

; 6871 : 	return m_Color;

	lea	eax, DWORD PTR [ecx+260]

; 6872 : }

	ret	0
?GetColor@CvColorInfo@@QBEABUCvColorA@@XZ ENDP		; CvColorInfo::GetColor
_TEXT	ENDS
PUBLIC	?GetColorTypePrimary@CvPlayerColorInfo@@QBEHXZ	; CvPlayerColorInfo::GetColorTypePrimary
; Function compile flags: /Ogtpy
;	COMDAT ?GetColorTypePrimary@CvPlayerColorInfo@@QBEHXZ
_TEXT	SEGMENT
?GetColorTypePrimary@CvPlayerColorInfo@@QBEHXZ PROC	; CvPlayerColorInfo::GetColorTypePrimary, COMDAT
; _this$ = ecx

; 6897 : 	return m_iColorTypePrimary;

	mov	eax, DWORD PTR [ecx+260]

; 6898 : }

	ret	0
?GetColorTypePrimary@CvPlayerColorInfo@@QBEHXZ ENDP	; CvPlayerColorInfo::GetColorTypePrimary
_TEXT	ENDS
PUBLIC	?GetColorTypeSecondary@CvPlayerColorInfo@@QBEHXZ ; CvPlayerColorInfo::GetColorTypeSecondary
; Function compile flags: /Ogtpy
;	COMDAT ?GetColorTypeSecondary@CvPlayerColorInfo@@QBEHXZ
_TEXT	SEGMENT
?GetColorTypeSecondary@CvPlayerColorInfo@@QBEHXZ PROC	; CvPlayerColorInfo::GetColorTypeSecondary, COMDAT
; _this$ = ecx

; 6902 : 	return m_iColorTypeSecondary;

	mov	eax, DWORD PTR [ecx+264]

; 6903 : }

	ret	0
?GetColorTypeSecondary@CvPlayerColorInfo@@QBEHXZ ENDP	; CvPlayerColorInfo::GetColorTypeSecondary
_TEXT	ENDS
PUBLIC	?GetColorTypeText@CvPlayerColorInfo@@QBEHXZ	; CvPlayerColorInfo::GetColorTypeText
; Function compile flags: /Ogtpy
;	COMDAT ?GetColorTypeText@CvPlayerColorInfo@@QBEHXZ
_TEXT	SEGMENT
?GetColorTypeText@CvPlayerColorInfo@@QBEHXZ PROC	; CvPlayerColorInfo::GetColorTypeText, COMDAT
; _this$ = ecx

; 6907 : 	return m_iColorTypeText;

	mov	eax, DWORD PTR [ecx+268]

; 6908 : }

	ret	0
?GetColorTypeText@CvPlayerColorInfo@@QBEHXZ ENDP	; CvPlayerColorInfo::GetColorTypeText
_TEXT	ENDS
PUBLIC	?getDefault@CvGameOptionInfo@@QBE_NXZ		; CvGameOptionInfo::getDefault
; Function compile flags: /Ogtpy
;	COMDAT ?getDefault@CvGameOptionInfo@@QBE_NXZ
_TEXT	SEGMENT
?getDefault@CvGameOptionInfo@@QBE_NXZ PROC		; CvGameOptionInfo::getDefault, COMDAT
; _this$ = ecx

; 6953 : 	return m_bDefault;

	mov	al, BYTE PTR [ecx+260]

; 6954 : }

	ret	0
?getDefault@CvGameOptionInfo@@QBE_NXZ ENDP		; CvGameOptionInfo::getDefault
_TEXT	ENDS
PUBLIC	?getVisible@CvGameOptionInfo@@QBE_NXZ		; CvGameOptionInfo::getVisible
; Function compile flags: /Ogtpy
;	COMDAT ?getVisible@CvGameOptionInfo@@QBE_NXZ
_TEXT	SEGMENT
?getVisible@CvGameOptionInfo@@QBE_NXZ PROC		; CvGameOptionInfo::getVisible, COMDAT
; _this$ = ecx

; 6958 : 	return m_bVisible;

	mov	al, BYTE PTR [ecx+261]

; 6959 : }

	ret	0
?getVisible@CvGameOptionInfo@@QBE_NXZ ENDP		; CvGameOptionInfo::getVisible
_TEXT	ENDS
PUBLIC	?getDefault@CvMPOptionInfo@@QBE_NXZ		; CvMPOptionInfo::getDefault
; Function compile flags: /Ogtpy
;	COMDAT ?getDefault@CvMPOptionInfo@@QBE_NXZ
_TEXT	SEGMENT
?getDefault@CvMPOptionInfo@@QBE_NXZ PROC		; CvMPOptionInfo::getDefault, COMDAT
; _this$ = ecx

; 6983 : 	return m_bDefault;

	mov	al, BYTE PTR [ecx+260]

; 6984 : }

	ret	0
?getDefault@CvMPOptionInfo@@QBE_NXZ ENDP		; CvMPOptionInfo::getDefault
_TEXT	ENDS
PUBLIC	?getDefault@CvPlayerOptionInfo@@QBE_NXZ		; CvPlayerOptionInfo::getDefault
; Function compile flags: /Ogtpy
;	COMDAT ?getDefault@CvPlayerOptionInfo@@QBE_NXZ
_TEXT	SEGMENT
?getDefault@CvPlayerOptionInfo@@QBE_NXZ PROC		; CvPlayerOptionInfo::getDefault, COMDAT
; _this$ = ecx

; 7007 : 	return m_bDefault;

	mov	al, BYTE PTR [ecx+260]

; 7008 : }

	ret	0
?getDefault@CvPlayerOptionInfo@@QBE_NXZ ENDP		; CvPlayerOptionInfo::getDefault
_TEXT	ENDS
PUBLIC	?getVoteInterval@CvVoteSourceInfo@@QBEHXZ	; CvVoteSourceInfo::getVoteInterval
; Function compile flags: /Ogtpy
;	COMDAT ?getVoteInterval@CvVoteSourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getVoteInterval@CvVoteSourceInfo@@QBEHXZ PROC		; CvVoteSourceInfo::getVoteInterval, COMDAT
; _this$ = ecx

; 7036 : 	return m_iVoteInterval;

	mov	eax, DWORD PTR [ecx+260]

; 7037 : }

	ret	0
?getVoteInterval@CvVoteSourceInfo@@QBEHXZ ENDP		; CvVoteSourceInfo::getVoteInterval
_TEXT	ENDS
PUBLIC	?getFreeSpecialist@CvVoteSourceInfo@@QBEHXZ	; CvVoteSourceInfo::getFreeSpecialist
; Function compile flags: /Ogtpy
;	COMDAT ?getFreeSpecialist@CvVoteSourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getFreeSpecialist@CvVoteSourceInfo@@QBEHXZ PROC	; CvVoteSourceInfo::getFreeSpecialist, COMDAT
; _this$ = ecx

; 7041 : 	return m_iFreeSpecialist;

	mov	eax, DWORD PTR [ecx+264]

; 7042 : }

	ret	0
?getFreeSpecialist@CvVoteSourceInfo@@QBEHXZ ENDP	; CvVoteSourceInfo::getFreeSpecialist
_TEXT	ENDS
PUBLIC	?getPolicy@CvVoteSourceInfo@@QBEHXZ		; CvVoteSourceInfo::getPolicy
; Function compile flags: /Ogtpy
;	COMDAT ?getPolicy@CvVoteSourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getPolicy@CvVoteSourceInfo@@QBEHXZ PROC		; CvVoteSourceInfo::getPolicy, COMDAT
; _this$ = ecx

; 7046 : 	return m_iPolicy;

	mov	eax, DWORD PTR [ecx+268]

; 7047 : }

	ret	0
?getPolicy@CvVoteSourceInfo@@QBEHXZ ENDP		; CvVoteSourceInfo::getPolicy
_TEXT	ENDS
PUBLIC	?getPopupText@CvVoteSourceInfo@@QBEABVCvString@@XZ ; CvVoteSourceInfo::getPopupText
; Function compile flags: /Ogtpy
;	COMDAT ?getPopupText@CvVoteSourceInfo@@QBEABVCvString@@XZ
_TEXT	SEGMENT
?getPopupText@CvVoteSourceInfo@@QBEABVCvString@@XZ PROC	; CvVoteSourceInfo::getPopupText, COMDAT
; _this$ = ecx

; 7051 : 	return m_strPopupText;

	lea	eax, DWORD PTR [ecx+272]

; 7052 : }

	ret	0
?getPopupText@CvVoteSourceInfo@@QBEABVCvString@@XZ ENDP	; CvVoteSourceInfo::getPopupText
_TEXT	ENDS
PUBLIC	?getSecretaryGeneralText@CvVoteSourceInfo@@QBEABVCvString@@XZ ; CvVoteSourceInfo::getSecretaryGeneralText
; Function compile flags: /Ogtpy
;	COMDAT ?getSecretaryGeneralText@CvVoteSourceInfo@@QBEABVCvString@@XZ
_TEXT	SEGMENT
?getSecretaryGeneralText@CvVoteSourceInfo@@QBEABVCvString@@XZ PROC ; CvVoteSourceInfo::getSecretaryGeneralText, COMDAT
; _this$ = ecx

; 7056 : 	return m_strSecretaryGeneralText;

	lea	eax, DWORD PTR [ecx+300]

; 7057 : }

	ret	0
?getSecretaryGeneralText@CvVoteSourceInfo@@QBEABVCvString@@XZ ENDP ; CvVoteSourceInfo::getSecretaryGeneralText
_TEXT	ENDS
PUBLIC	?size@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEIXZ ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 4

; 727  : 		}

	ret	0
?size@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEABVCvFormationSlotEntry@@I@Z ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEABVCvFormationSlotEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEABVCvFormationSlotEntry@@I@Z PROC ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx+4]

; 771  : 		}

	ret	4
??A?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEABVCvFormationSlotEntry@@I@Z ENDP ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ; std::vector<CvString,std::allocator<CvString> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ PROC ; std::vector<CvString,std::allocator<CvString> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	esi

; 726  : 		return (_Mylast - _Myfirst);

	mov	esi, DWORD PTR [ecx+8]
	sub	esi, DWORD PTR [ecx+4]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	add	edx, esi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 727  : 		}

	ret	0
?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@I@Z ; std::vector<CvString,std::allocator<CvString> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@I@Z PROC ; std::vector<CvString,std::allocator<CvString> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+edx*4]

; 771  : 		}

	ret	4
??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@I@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAVCvString@@I@Z ; std::vector<CvString,std::allocator<CvString> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAVCvString@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAVCvString@@I@Z PROC ; std::vector<CvString,std::allocator<CvString> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+edx*4]

; 786  : 		}

	ret	4
??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAVCvString@@I@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::size, COMDAT
; _this$ = ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+8]

; 602  : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEIXZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEIXZ PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEIXZ ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEIXZ ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEABW4AnimationPathTypes@@I@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEABW4AnimationPathTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEABW4AnimationPathTypes@@I@Z PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEABW4AnimationPathTypes@@I@Z ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 12			; 0000000cH

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator++
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEIXZ ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::capacity
; Function compile flags: /Ogtpy
;	COMDAT ?capacity@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 4

; 636  : 		}

	ret	0
?capacity@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::capacity
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ; std::vector<CvString,std::allocator<CvString> >::capacity
; Function compile flags: /Ogtpy
;	COMDAT ?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ PROC ; std::vector<CvString,std::allocator<CvString> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity@2

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::~_Container_base_aux_alloc_empty<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::~_Container_base_aux_alloc_empty<std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::~_Container_base_aux_alloc_empty<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvString@@@std@@QAE@XZ		; std::allocator<CvString>::allocator<CvString>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvString@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VCvString@@@std@@QAE@XZ PROC		; std::allocator<CvString>::allocator<CvString>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VCvString@@@std@@QAE@XZ ENDP		; std::allocator<CvString>::allocator<CvString>
_TEXT	ENDS
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::key_comp
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::key_comp, COMDAT
; _this$ = ecx

; 621  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 622  : 		}

	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::key_comp
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >
_TEXT	ENDS
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setl	al

; 144  : 		}

	ret	8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEIXZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEIXZ PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity@3

; 636  : 		}

	ret	0
$LN3@capacity@3:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEIXZ ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<ProductionCostModifiers> >::~_Container_base_aux_alloc_empty<std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<ProductionCostModifiers> >::~_Container_base_aux_alloc_empty<std::allocator<ProductionCostModifiers> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<ProductionCostModifiers> >::~_Container_base_aux_alloc_empty<std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UProductionCostModifiers@@@std@@QAE@XZ ; std::allocator<ProductionCostModifiers>::allocator<ProductionCostModifiers>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UProductionCostModifiers@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UProductionCostModifiers@@@std@@QAE@XZ PROC ; std::allocator<ProductionCostModifiers>::allocator<ProductionCostModifiers>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@UProductionCostModifiers@@@std@@QAE@XZ ENDP ; std::allocator<ProductionCostModifiers>::allocator<ProductionCostModifiers>
_TEXT	ENDS
PUBLIC	??0?$allocator@UProductionCostModifiers@@@std@@QAE@ABV01@@Z ; std::allocator<ProductionCostModifiers>::allocator<ProductionCostModifiers>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$allocator@UProductionCostModifiers@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UProductionCostModifiers@@@std@@QAE@ABV01@@Z PROC ; std::allocator<ProductionCostModifiers>::allocator<ProductionCostModifiers>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@UProductionCostModifiers@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<ProductionCostModifiers>::allocator<ProductionCostModifiers>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEIXZ ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@4
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@4:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >::~_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4AnimationPathTypes@@@std@@QAE@XZ ; std::allocator<enum AnimationPathTypes>::allocator<enum AnimationPathTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4AnimationPathTypes@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@W4AnimationPathTypes@@@std@@QAE@XZ PROC	; std::allocator<enum AnimationPathTypes>::allocator<enum AnimationPathTypes>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@W4AnimationPathTypes@@@std@@QAE@XZ ENDP	; std::allocator<enum AnimationPathTypes>::allocator<enum AnimationPathTypes>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@PAUProductionCostModifiers@@@Z ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@PAUProductionCostModifiers@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@PAUProductionCostModifiers@@@Z PROC ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@PAUProductionCostModifiers@@@Z ENDP ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEABUProductionCostModifiers@@XZ ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEABUProductionCostModifiers@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEABUProductionCostModifiers@@XZ PROC ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEABUProductionCostModifiers@@XZ ENDP ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator*
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator==
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231008 = -80						; size = 28
$T231007 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ PROC ; std::vector<CvString,std::allocator<CvString> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231008[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231007[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231008[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231007[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231007[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231007[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231007[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231008[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231007[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::_Container_base_aux_alloc_empty<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::_Container_base_aux_alloc_empty<std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::_Container_base_aux_alloc_empty<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z	; std::allocator<CvString>::allocator<CvString>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvString>::allocator<CvString>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvString>::allocator<CvString>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z ; std::allocator<CvString>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z PROC ; std::allocator<CvString>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z ENDP ; std::allocator<CvString>::deallocate
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Isnil
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 33					; 00000021H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	??0ProductionCostModifiers@@QAE@XZ		; ProductionCostModifiers::ProductionCostModifiers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ??0ProductionCostModifiers@@QAE@XZ
_TEXT	SEGMENT
??0ProductionCostModifiers@@QAE@XZ PROC			; ProductionCostModifiers::ProductionCostModifiers, COMDAT
; _this$ = ecx

; 34   : 	{};

	mov	eax, ecx
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1
	mov	DWORD PTR [eax+8], 0
	ret	0
??0ProductionCostModifiers@@QAE@XZ ENDP			; ProductionCostModifiers::ProductionCostModifiers
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Left
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Left
_TEXT	ENDS
PUBLIC	?GetID@CvBaseInfo@@QBEHXZ			; CvBaseInfo::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetID@CvBaseInfo@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvBaseInfo@@QBEHXZ PROC				; CvBaseInfo::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvBaseInfo@@QBEHXZ ENDP				; CvBaseInfo::GetID
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Parent
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?GetCivilopedia@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetCivilopedia
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetCivilopedia@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetCivilopedia@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetCivilopedia, COMDAT
; _this$ = ecx

; 59   : 		return m_strCivilopedia.c_str();

	add	ecx, 8
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCivilopedia@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetCivilopedia
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Right
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAAU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?GetDescription@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetDescription
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetDescription@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescription@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetDescription, COMDAT
; _this$ = ecx

; 64   : 		return m_strDescription.c_str();

	add	ecx, 36					; 00000024H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDescription@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetDescription
_TEXT	ENDS
PUBLIC	?GetStrategy@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetStrategy
; Function compile flags: /Ogtpy
;	COMDAT ?GetStrategy@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetStrategy@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetStrategy, COMDAT
; _this$ = ecx

; 84   : 		return m_strStrategy.c_str();

	add	ecx, 148				; 00000094H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetStrategy@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetStrategy
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	??0CvFormationSlotEntry@@QAE@XZ			; CvFormationSlotEntry::CvFormationSlotEntry
; Function compile flags: /Ogtpy
;	COMDAT ??0CvFormationSlotEntry@@QAE@XZ
_TEXT	SEGMENT
??0CvFormationSlotEntry@@QAE@XZ PROC			; CvFormationSlotEntry::CvFormationSlotEntry, COMDAT
; _this$ = ecx

; 420  : 	{

	mov	eax, ecx
	or	ecx, -1
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	BYTE PTR [eax+12], 0

; 421  : 	}

	ret	0
??0CvFormationSlotEntry@@QAE@XZ ENDP			; CvFormationSlotEntry::CvFormationSlotEntry
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Max
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN1@Max
	npad	3
$LL2@Max:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LL2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Min
; Function compile flags: /Ogtpy
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Min, COMDAT

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN1@Min
	npad	4
$LL2@Min:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LL2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Min
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ; std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z PROC ; std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0>::_Kfn, COMDAT

; 65   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[esp-4]

; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ENDP ; std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231136 = -80						; size = 28
$T231135 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231136[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231135[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231136[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231135[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231135[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231135[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231135[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231136[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231135[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE@V?$allocator@UProductionCostModifiers@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<ProductionCostModifiers> >::_Container_base_aux_alloc_empty<std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE@V?$allocator@UProductionCostModifiers@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE@V?$allocator@UProductionCostModifiers@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<ProductionCostModifiers> >::_Container_base_aux_alloc_empty<std::allocator<ProductionCostModifiers> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE@V?$allocator@UProductionCostModifiers@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<ProductionCostModifiers> >::_Container_base_aux_alloc_empty<std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UProductionCostModifiers@@@std@@QAEXPAUProductionCostModifiers@@I@Z ; std::allocator<ProductionCostModifiers>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@UProductionCostModifiers@@@std@@QAEXPAUProductionCostModifiers@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UProductionCostModifiers@@@std@@QAEXPAUProductionCostModifiers@@I@Z PROC ; std::allocator<ProductionCostModifiers>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@UProductionCostModifiers@@@std@@QAEXPAUProductionCostModifiers@@I@Z ENDP ; std::allocator<ProductionCostModifiers>::deallocate
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231167 = -80						; size = 28
$T231166 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231167[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231166[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231167[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231166[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231166[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231166[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231166[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@3:
$LN12@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231167[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231166[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@V?$allocator@W4AnimationPathTypes@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@V?$allocator@W4AnimationPathTypes@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@V?$allocator@W4AnimationPathTypes@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@V?$allocator@W4AnimationPathTypes@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >::_Container_base_aux_alloc_empty<std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	??0?$allocator@W4AnimationPathTypes@@@std@@QAE@ABV01@@Z ; std::allocator<enum AnimationPathTypes>::allocator<enum AnimationPathTypes>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4AnimationPathTypes@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@W4AnimationPathTypes@@@std@@QAE@ABV01@@Z PROC ; std::allocator<enum AnimationPathTypes>::allocator<enum AnimationPathTypes>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@W4AnimationPathTypes@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<enum AnimationPathTypes>::allocator<enum AnimationPathTypes>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@I@Z ; std::allocator<enum AnimationPathTypes>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@I@Z PROC ; std::allocator<enum AnimationPathTypes>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@I@Z ENDP ; std::allocator<enum AnimationPathTypes>::deallocate
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 217  : 			{	// construct with null node pointer

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 218  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 4

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::operator-
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator-
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@PAUProductionCostModifiers@@@Z ; std::_Vector_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Vector_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@PAUProductionCostModifiers@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@PAUProductionCostModifiers@@@Z PROC ; std::_Vector_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Vector_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@PAUProductionCostModifiers@@@Z ENDP ; std::_Vector_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Vector_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::operator-
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@KAXXZ ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231228 = -80						; size = 28
$T231227 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231228[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231227[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231228[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231227[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231227[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231227[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231227[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@4:
$LN12@Xlen@4:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231228[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231227[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Xlen
PUBLIC	?deallocate@?$allocator@VCvFormationSlotEntry@@@std@@QAEXPAVCvFormationSlotEntry@@I@Z ; std::allocator<CvFormationSlotEntry>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@VCvFormationSlotEntry@@@std@@QAEXPAVCvFormationSlotEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCvFormationSlotEntry@@@std@@QAEXPAVCvFormationSlotEntry@@I@Z PROC ; std::allocator<CvFormationSlotEntry>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VCvFormationSlotEntry@@@std@@QAEXPAVCvFormationSlotEntry@@I@Z ENDP ; std::allocator<CvFormationSlotEntry>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCvString@@@std@@QBEIXZ	; std::allocator<CvString>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@VCvString@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCvString@@@std@@QBEIXZ PROC	; std::allocator<CvString>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 153391689				; 09249249H

; 167  : 		}

	ret	0
?max_size@?$allocator@VCvString@@@std@@QBEIXZ ENDP	; std::allocator<CvString>::max_size
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 32					; 00000020H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 577  : 		}

	ret	8
?_Make_iter@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UProductionCostModifiers@@@std@@QBEIXZ ; std::allocator<ProductionCostModifiers>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@UProductionCostModifiers@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UProductionCostModifiers@@@std@@QBEIXZ PROC ; std::allocator<ProductionCostModifiers>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 357913941				; 15555555H

; 167  : 		}

	ret	0
?max_size@?$allocator@UProductionCostModifiers@@@std@@QBEIXZ ENDP ; std::allocator<ProductionCostModifiers>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@W4AnimationPathTypes@@@std@@QBEIXZ ; std::allocator<enum AnimationPathTypes>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@W4AnimationPathTypes@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@W4AnimationPathTypes@@@std@@QBEIXZ PROC ; std::allocator<enum AnimationPathTypes>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@W4AnimationPathTypes@@@std@@QBEIXZ ENDP ; std::allocator<enum AnimationPathTypes>::max_size
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+33], 0
	jne	SHORT $LN43@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN24@Dec
	npad	1
$LL25@Dec:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL25@Dec
$LN24@Dec:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN3@Dec
$LL4@Dec:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+33], 0
	jne	SHORT $LN1@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN3@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+33], 0
	jne	SHORT $LN34@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN17@Inc
	npad	7
$LL18@Inc:
	mov	edx, eax
	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL18@Inc
$LN17@Inc:
	mov	DWORD PTR [ecx], edx

; 405  : 				}
; 406  : 			}

	ret	0
$LN34@Inc:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN1@Inc
$LL2@Inc:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [ecx], eax
$LN3@Inc:

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE@PAVCvFormationSlotEntry@@@Z ; std::_Vector_const_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Vector_const_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE@PAVCvFormationSlotEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE@PAVCvFormationSlotEntry@@@Z PROC ; std::_Vector_const_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Vector_const_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE@PAVCvFormationSlotEntry@@@Z ENDP ; std::_Vector_const_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Vector_const_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::_Vector_const_iterator<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::_Vector_const_iterator<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::_Vector_const_iterator<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@PAW4AnimationPathTypes@@@Z ; std::_Vector_const_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Vector_const_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@PAW4AnimationPathTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@PAW4AnimationPathTypes@@@Z PROC ; std::_Vector_const_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Vector_const_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@PAW4AnimationPathTypes@@@Z ENDP ; std::_Vector_const_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Vector_const_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::iterator,bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCvFormationSlotEntry@@@std@@QBEIXZ ; std::allocator<CvFormationSlotEntry>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@VCvFormationSlotEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCvFormationSlotEntry@@@std@@QBEIXZ PROC ; std::allocator<CvFormationSlotEntry>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 268435455				; 0fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@VCvFormationSlotEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvFormationSlotEntry>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 214748364				; 0cccccccH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >::max_size
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	shl	ecx, 4
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >
_TEXT	ENDS
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _s$[esp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, esi
	pop	esi

; 493  : }

	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z		; SAFE_DELETE_ARRAY<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z PROC		; SAFE_DELETE_ARRAY<bool>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z ENDP		; SAFE_DELETE_ARRAY<bool>
_TEXT	ENDS
PUBLIC	??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ		; sprintf_s<512>
EXTRN	__imp__vsprintf_s:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdio.h
;	COMDAT ??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ PROC		; sprintf_s<512>, COMDAT

; 322  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

	mov	ecx, DWORD PTR __Format$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	lea	eax, DWORD PTR __Format$[esp]
	push	eax
	push	ecx
	push	512					; 00000200H
	push	edx
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	ret	0
??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ ENDP		; sprintf_s<512>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@UGameTurnInfo@@@@YAXAAPAUGameTurnInfo@@@Z ; SAFE_DELETE_ARRAY<GameTurnInfo>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@UGameTurnInfo@@@@YAXAAPAUGameTurnInfo@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@UGameTurnInfo@@@@YAXAAPAUGameTurnInfo@@@Z PROC ; SAFE_DELETE_ARRAY<GameTurnInfo>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@UGameTurnInfo@@@@YAXAAPAUGameTurnInfo@@@Z ENDP ; SAFE_DELETE_ARRAY<GameTurnInfo>
_TEXT	ENDS
PUBLIC	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ		; sprintf_s<256>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdio.h
;	COMDAT ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ PROC		; sprintf_s<256>, COMDAT

; 322  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

	mov	ecx, DWORD PTR __Format$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	lea	eax, DWORD PTR __Format$[esp]
	push	eax
	push	ecx
	push	256					; 00000100H
	push	edx
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	ret	0
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ENDP		; sprintf_s<256>
_TEXT	ENDS
PUBLIC	??$?5F@FDataStream@@QAEAAV0@AAF@Z		; FDataStream::operator>><short>
EXTRN	?Read@FDataStream@@IAEXAAF@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5F@FDataStream@@QAEAAV0@AAF@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5F@FDataStream@@QAEAAV0@AAF@Z PROC			; FDataStream::operator>><short>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5F@FDataStream@@QAEAAV0@AAF@Z ENDP			; FDataStream::operator>><short>
_TEXT	ENDS
PUBLIC	??$?6F@FDataStream@@QAEAAV0@ABF@Z		; FDataStream::operator<<<short>
EXTRN	?Write@FDataStream@@IAEXABF@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6F@FDataStream@@QAEAAV0@ABF@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6F@FDataStream@@QAEAAV0@ABF@Z PROC			; FDataStream::operator<<<short>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6F@FDataStream@@QAEAAV0@ABF@Z ENDP			; FDataStream::operator<<<short>
_TEXT	ENDS
PUBLIC	??$?5M@FDataStream@@QAEAAV0@AAM@Z		; FDataStream::operator>><float>
EXTRN	?Read@FDataStream@@IAEXAAM@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5M@FDataStream@@QAEAAV0@AAM@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5M@FDataStream@@QAEAAV0@AAM@Z PROC			; FDataStream::operator>><float>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAM@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5M@FDataStream@@QAEAAV0@AAM@Z ENDP			; FDataStream::operator>><float>
_TEXT	ENDS
PUBLIC	??$?6M@FDataStream@@QAEAAV0@ABM@Z		; FDataStream::operator<<<float>
EXTRN	?Write@FDataStream@@IAEXABM@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6M@FDataStream@@QAEAAV0@ABM@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6M@FDataStream@@QAEAAV0@ABM@Z PROC			; FDataStream::operator<<<float>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABM@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6M@FDataStream@@QAEAAV0@ABM@Z ENDP			; FDataStream::operator<<<float>
_TEXT	ENDS
PUBLIC	??$?8U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@0@0@Z ; std::operator==<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >,std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$?8U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@0@0@Z PROC ; std::operator==<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >,std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >, COMDAT

; 175  : 	return (true);

	mov	al, 1

; 176  : 	}

	ret	0
??$?8U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@U01@@std@@YA_NABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@0@0@Z ENDP ; std::operator==<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >,std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >
_TEXT	ENDS
PUBLIC	??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@0@Z ; std::swap<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@0@Z PROC ; std::swap<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@0@Z ENDP ; std::swap<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$swap@I@std@@YAXAAI0@Z			; std::swap<unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$swap@I@std@@YAXAAI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@I@std@@YAXAAI0@Z PROC				; std::swap<unsigned int>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@2:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@I@std@@YAXAAI0@Z ENDP				; std::swap<unsigned int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z
_TEXT	SEGMENT
$T231477 = -12						; size = 12
$T231481 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z PROC ; std::_Allocate<CvString>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 28					; 0000001cH
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231481[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T231477[esp+16]
	mov	DWORD PTR $T231481[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231477[esp+16]
	push	ecx
	mov	DWORD PTR $T231477[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ENDP ; std::_Allocate<CvString>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *><std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *><std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *><std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Allocate@UProductionCostModifiers@@@std@@YAPAUProductionCostModifiers@@IPAU1@@Z ; std::_Allocate<ProductionCostModifiers>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@UProductionCostModifiers@@@std@@YAPAUProductionCostModifiers@@IPAU1@@Z
_TEXT	SEGMENT
$T231493 = -12						; size = 12
$T231497 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UProductionCostModifiers@@@std@@YAPAUProductionCostModifiers@@IPAU1@@Z PROC ; std::_Allocate<ProductionCostModifiers>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231497[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T231493[esp+16]
	mov	DWORD PTR $T231497[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231493[esp+16]
	push	ecx
	mov	DWORD PTR $T231493[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@UProductionCostModifiers@@@std@@YAPAUProductionCostModifiers@@IPAU1@@Z ENDP ; std::_Allocate<ProductionCostModifiers>
_TEXT	ENDS
PUBLIC	??$_Allocate@W4AnimationPathTypes@@@std@@YAPAW4AnimationPathTypes@@IPAW41@@Z ; std::_Allocate<enum AnimationPathTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@W4AnimationPathTypes@@@std@@YAPAW4AnimationPathTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T231503 = -12						; size = 12
$T231507 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4AnimationPathTypes@@@std@@YAPAW4AnimationPathTypes@@IPAW41@@Z PROC ; std::_Allocate<enum AnimationPathTypes>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231507[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T231503[esp+16]
	mov	DWORD PTR $T231507[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231503[esp+16]
	push	ecx
	mov	DWORD PTR $T231503[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@W4AnimationPathTypes@@@std@@YAPAW4AnimationPathTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum AnimationPathTypes>
_TEXT	ENDS
PUBLIC	??$_Allocate@VCvFormationSlotEntry@@@std@@YAPAVCvFormationSlotEntry@@IPAV1@@Z ; std::_Allocate<CvFormationSlotEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@VCvFormationSlotEntry@@@std@@YAPAVCvFormationSlotEntry@@IPAV1@@Z
_TEXT	SEGMENT
$T231513 = -12						; size = 12
$T231517 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvFormationSlotEntry@@@std@@YAPAVCvFormationSlotEntry@@IPAV1@@Z PROC ; std::_Allocate<CvFormationSlotEntry>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231517[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T231513[esp+16]
	mov	DWORD PTR $T231517[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231513[esp+16]
	push	ecx
	mov	DWORD PTR $T231513[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@4:
$LN8@Allocate@4:
	int	3
??$_Allocate@VCvFormationSlotEntry@@@std@@YAPAVCvFormationSlotEntry@@IPAV1@@Z ENDP ; std::_Allocate<CvFormationSlotEntry>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node><std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node><std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node><std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T231526 = -12						; size = 12
$T231530 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*8]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 36					; 00000024H
	jae	SHORT $LN1@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231530[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T231526[esp+16]
	mov	DWORD PTR $T231530[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231526[esp+16]
	push	ecx
	mov	DWORD PTR $T231526[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@5:
$LN8@Allocate@5:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ; std::swap<std::less<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z PROC	; std::swap<std::less<int> >, COMDAT

; 18   : 	if (&_Left != &_Right)
; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;
; 21   : 
; 22   : 		_Left = _Right;
; 23   : 		_Right = _Tmp;
; 24   : 		}
; 25   : 	}

	ret	0
??$swap@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ENDP	; std::swap<std::less<int> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvFormationSlotEntry@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvFormationSlotEntry@@0@Z ; std::_Ptr_cat<CvFormationSlotEntry *,CvFormationSlotEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVCvFormationSlotEntry@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvFormationSlotEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvFormationSlotEntry@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvFormationSlotEntry@@0@Z PROC ; std::_Ptr_cat<CvFormationSlotEntry *,CvFormationSlotEntry *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvFormationSlotEntry@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvFormationSlotEntry@@0@Z ENDP ; std::_Ptr_cat<CvFormationSlotEntry *,CvFormationSlotEntry *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z ; std::_Iter_random<CvString *,CvString *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z PROC ; std::_Iter_random<CvString *,CvString *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z ENDP ; std::_Iter_random<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z ; std::_Ptr_cat<CvString *,CvString *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z PROC ; std::_Ptr_cat<CvString *,CvString *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z ENDP ; std::_Ptr_cat<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUProductionCostModifiers@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUProductionCostModifiers@@0@Z ; std::_Iter_random<ProductionCostModifiers *,ProductionCostModifiers *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUProductionCostModifiers@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUProductionCostModifiers@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUProductionCostModifiers@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUProductionCostModifiers@@0@Z PROC ; std::_Iter_random<ProductionCostModifiers *,ProductionCostModifiers *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUProductionCostModifiers@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUProductionCostModifiers@@0@Z ENDP ; std::_Iter_random<ProductionCostModifiers *,ProductionCostModifiers *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUProductionCostModifiers@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUProductionCostModifiers@@0@Z ; std::_Ptr_cat<ProductionCostModifiers *,ProductionCostModifiers *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUProductionCostModifiers@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUProductionCostModifiers@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUProductionCostModifiers@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUProductionCostModifiers@@0@Z PROC ; std::_Ptr_cat<ProductionCostModifiers *,ProductionCostModifiers *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUProductionCostModifiers@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUProductionCostModifiers@@0@Z ENDP ; std::_Ptr_cat<ProductionCostModifiers *,ProductionCostModifiers *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUProductionCostModifiers@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<ProductionCostModifiers *,ProductionCostModifiers *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAUProductionCostModifiers@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUProductionCostModifiers@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<ProductionCostModifiers *,ProductionCostModifiers *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt
	push	esi
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt
	pop	esi
$LN1@Copy_opt:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAUProductionCostModifiers@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<ProductionCostModifiers *,ProductionCostModifiers *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAW4AnimationPathTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4AnimationPathTypes@@0@Z ; std::_Ptr_cat<enum AnimationPathTypes *,enum AnimationPathTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAW4AnimationPathTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4AnimationPathTypes@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAW4AnimationPathTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4AnimationPathTypes@@0@Z PROC ; std::_Ptr_cat<enum AnimationPathTypes *,enum AnimationPathTypes *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAW4AnimationPathTypes@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4AnimationPathTypes@@0@Z ENDP ; std::_Ptr_cat<enum AnimationPathTypes *,enum AnimationPathTypes *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVCvFormationSlotEntry@@V1@@std@@YAXPAVCvFormationSlotEntry@@0ABV1@@Z ; std::_Fill<CvFormationSlotEntry *,CvFormationSlotEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAVCvFormationSlotEntry@@V1@@std@@YAXPAVCvFormationSlotEntry@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVCvFormationSlotEntry@@V1@@std@@YAXPAVCvFormationSlotEntry@@0ABV1@@Z PROC ; std::_Fill<CvFormationSlotEntry *,CvFormationSlotEntry>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	add	eax, 16					; 00000010H
	cmp	eax, edx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAVCvFormationSlotEntry@@V1@@std@@YAXPAVCvFormationSlotEntry@@0ABV1@@Z ENDP ; std::_Fill<CvFormationSlotEntry *,CvFormationSlotEntry>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvFormationSlotEntry@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvFormationSlotEntry@@0@Z ; std::_Iter_random<CvFormationSlotEntry *,CvFormationSlotEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvFormationSlotEntry@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvFormationSlotEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvFormationSlotEntry@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvFormationSlotEntry@@0@Z PROC ; std::_Iter_random<CvFormationSlotEntry *,CvFormationSlotEntry *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvFormationSlotEntry@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvFormationSlotEntry@@0@Z ENDP ; std::_Iter_random<CvFormationSlotEntry *,CvFormationSlotEntry *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAVCvFormationSlotEntry@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvFormationSlotEntry@@@Z ; std::_Move_cat<CvFormationSlotEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAVCvFormationSlotEntry@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvFormationSlotEntry@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVCvFormationSlotEntry@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvFormationSlotEntry@@@Z PROC ; std::_Move_cat<CvFormationSlotEntry *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAVCvFormationSlotEntry@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvFormationSlotEntry@@@Z ENDP ; std::_Move_cat<CvFormationSlotEntry *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z ; std::_Move_cat<CvString *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z PROC ; std::_Move_cat<CvString *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z ENDP ; std::_Move_cat<CvString *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUProductionCostModifiers@@U1@@std@@YAXPAUProductionCostModifiers@@0ABU1@@Z ; std::_Fill<ProductionCostModifiers *,ProductionCostModifiers>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAUProductionCostModifiers@@U1@@std@@YAXPAUProductionCostModifiers@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUProductionCostModifiers@@U1@@std@@YAXPAUProductionCostModifiers@@0ABU1@@Z PROC ; std::_Fill<ProductionCostModifiers *,ProductionCostModifiers>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL3@Fill@2
	pop	esi
$LN1@Fill@2:

; 3160 : 	}

	ret	0
??$_Fill@PAUProductionCostModifiers@@U1@@std@@YAXPAUProductionCostModifiers@@0ABU1@@Z ENDP ; std::_Fill<ProductionCostModifiers *,ProductionCostModifiers>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAUProductionCostModifiers@@@std@@YA?AU_Undefined_move_tag@0@ABQAUProductionCostModifiers@@@Z ; std::_Move_cat<ProductionCostModifiers *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAUProductionCostModifiers@@@std@@YA?AU_Undefined_move_tag@0@ABQAUProductionCostModifiers@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUProductionCostModifiers@@@std@@YA?AU_Undefined_move_tag@0@ABQAUProductionCostModifiers@@@Z PROC ; std::_Move_cat<ProductionCostModifiers *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAUProductionCostModifiers@@@std@@YA?AU_Undefined_move_tag@0@ABQAUProductionCostModifiers@@@Z ENDP ; std::_Move_cat<ProductionCostModifiers *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAW4AnimationPathTypes@@W41@@std@@YAXPAW4AnimationPathTypes@@0ABW41@@Z ; std::_Fill<enum AnimationPathTypes *,enum AnimationPathTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAW4AnimationPathTypes@@W41@@std@@YAXPAW4AnimationPathTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAW4AnimationPathTypes@@W41@@std@@YAXPAW4AnimationPathTypes@@0ABW41@@Z PROC ; std::_Fill<enum AnimationPathTypes *,enum AnimationPathTypes>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@3:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@3
	pop	esi
$LN1@Fill@3:

; 3160 : 	}

	ret	0
??$_Fill@PAW4AnimationPathTypes@@W41@@std@@YAXPAW4AnimationPathTypes@@0ABW41@@Z ENDP ; std::_Fill<enum AnimationPathTypes *,enum AnimationPathTypes>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAW4AnimationPathTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4AnimationPathTypes@@0@Z ; std::_Iter_random<enum AnimationPathTypes *,enum AnimationPathTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAW4AnimationPathTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4AnimationPathTypes@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAW4AnimationPathTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4AnimationPathTypes@@0@Z PROC ; std::_Iter_random<enum AnimationPathTypes *,enum AnimationPathTypes *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAW4AnimationPathTypes@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4AnimationPathTypes@@0@Z ENDP ; std::_Iter_random<enum AnimationPathTypes *,enum AnimationPathTypes *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAW4AnimationPathTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4AnimationPathTypes@@@Z ; std::_Move_cat<enum AnimationPathTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAW4AnimationPathTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4AnimationPathTypes@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAW4AnimationPathTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4AnimationPathTypes@@@Z PROC ; std::_Move_cat<enum AnimationPathTypes *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAW4AnimationPathTypes@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4AnimationPathTypes@@@Z ENDP ; std::_Move_cat<enum AnimationPathTypes *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@PAUProductionCostModifiers@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@0@AAPAUProductionCostModifiers@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,ProductionCostModifiers *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@PAUProductionCostModifiers@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@0@AAPAUProductionCostModifiers@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@PAUProductionCostModifiers@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@0@AAPAUProductionCostModifiers@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,ProductionCostModifiers *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@PAUProductionCostModifiers@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@0@AAPAUProductionCostModifiers@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,ProductionCostModifiers *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvFormationSlotEntry@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvFormationSlotEntry@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvFormationSlotEntry *,CvFormationSlotEntry *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvFormationSlotEntry@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvFormationSlotEntry@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvFormationSlotEntry@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvFormationSlotEntry@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvFormationSlotEntry *,CvFormationSlotEntry *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvFormationSlotEntry@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvFormationSlotEntry@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvFormationSlotEntry *,CvFormationSlotEntry *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUProductionCostModifiers@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<ProductionCostModifiers *,ProductionCostModifiers *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUProductionCostModifiers@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUProductionCostModifiers@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<ProductionCostModifiers *,ProductionCostModifiers *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@2
	push	esi
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@2
	pop	esi
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUProductionCostModifiers@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<ProductionCostModifiers *,ProductionCostModifiers *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAW4AnimationPathTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4AnimationPathTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum AnimationPathTypes *,enum AnimationPathTypes *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAW4AnimationPathTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4AnimationPathTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAW4AnimationPathTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4AnimationPathTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<enum AnimationPathTypes *,enum AnimationPathTypes *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@3
	push	esi
$LL2@Copy_backw@3:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@3
	pop	esi
$LN1@Copy_backw@3:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAW4AnimationPathTypes@@PAW41@Urandom_access_iterator_tag@std@@@std@@YAPAW4AnimationPathTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<enum AnimationPathTypes *,enum AnimationPathTypes *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvFormationSlotEntry@@V1@@std@@YAXPAVCvFormationSlotEntry@@ABV1@@Z ; std::_Construct<CvFormationSlotEntry,CvFormationSlotEntry>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@VCvFormationSlotEntry@@V1@@std@@YAXPAVCvFormationSlotEntry@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvFormationSlotEntry@@V1@@std@@YAXPAVCvFormationSlotEntry@@ABV1@@Z PROC ; std::_Construct<CvFormationSlotEntry,CvFormationSlotEntry>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@VCvFormationSlotEntry@@V1@@std@@YAXPAVCvFormationSlotEntry@@ABV1@@Z ENDP ; std::_Construct<CvFormationSlotEntry,CvFormationSlotEntry>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvFormationSlotEntry@@@std@@YAXPAVCvFormationSlotEntry@@@Z ; std::_Destroy<CvFormationSlotEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvFormationSlotEntry@@@std@@YAXPAVCvFormationSlotEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvFormationSlotEntry@@@std@@YAXPAVCvFormationSlotEntry@@@Z PROC ; std::_Destroy<CvFormationSlotEntry>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvFormationSlotEntry@@@std@@YAXPAVCvFormationSlotEntry@@@Z ENDP ; std::_Destroy<CvFormationSlotEntry>
_TEXT	ENDS
PUBLIC	??$_Construct@UProductionCostModifiers@@U1@@std@@YAXPAUProductionCostModifiers@@ABU1@@Z ; std::_Construct<ProductionCostModifiers,ProductionCostModifiers>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@UProductionCostModifiers@@U1@@std@@YAXPAUProductionCostModifiers@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UProductionCostModifiers@@U1@@std@@YAXPAUProductionCostModifiers@@ABU1@@Z PROC ; std::_Construct<ProductionCostModifiers,ProductionCostModifiers>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN3@Construct@3:

; 53   : 	}

	ret	0
??$_Construct@UProductionCostModifiers@@U1@@std@@YAXPAUProductionCostModifiers@@ABU1@@Z ENDP ; std::_Construct<ProductionCostModifiers,ProductionCostModifiers>
_TEXT	ENDS
PUBLIC	??$_Destroy@UProductionCostModifiers@@@std@@YAXPAUProductionCostModifiers@@@Z ; std::_Destroy<ProductionCostModifiers>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@UProductionCostModifiers@@@std@@YAXPAUProductionCostModifiers@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UProductionCostModifiers@@@std@@YAXPAUProductionCostModifiers@@@Z PROC ; std::_Destroy<ProductionCostModifiers>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@UProductionCostModifiers@@@std@@YAXPAUProductionCostModifiers@@@Z ENDP ; std::_Destroy<ProductionCostModifiers>
_TEXT	ENDS
PUBLIC	??$_Construct@W4AnimationPathTypes@@W41@@std@@YAXPAW4AnimationPathTypes@@ABW41@@Z ; std::_Construct<enum AnimationPathTypes,enum AnimationPathTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@W4AnimationPathTypes@@W41@@std@@YAXPAW4AnimationPathTypes@@ABW41@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@W4AnimationPathTypes@@W41@@std@@YAXPAW4AnimationPathTypes@@ABW41@@Z PROC ; std::_Construct<enum AnimationPathTypes,enum AnimationPathTypes>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@4
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@4:

; 53   : 	}

	ret	0
??$_Construct@W4AnimationPathTypes@@W41@@std@@YAXPAW4AnimationPathTypes@@ABW41@@Z ENDP ; std::_Construct<enum AnimationPathTypes,enum AnimationPathTypes>
_TEXT	ENDS
PUBLIC	??$_Destroy@W4AnimationPathTypes@@@std@@YAXPAW4AnimationPathTypes@@@Z ; std::_Destroy<enum AnimationPathTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@W4AnimationPathTypes@@@std@@YAXPAW4AnimationPathTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@W4AnimationPathTypes@@@std@@YAXPAW4AnimationPathTypes@@@Z PROC ; std::_Destroy<enum AnimationPathTypes>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@W4AnimationPathTypes@@@std@@YAXPAW4AnimationPathTypes@@@Z ENDP ; std::_Destroy<enum AnimationPathTypes>
_TEXT	ENDS
PUBLIC	??_GCvString@@QAEPAXI@Z				; CvString::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvString@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvString@@QAEPAXI@Z PROC				; CvString::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvString@@QAEPAXI@Z ENDP				; CvString::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAI@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@IV?$allocator@I@std@@@0@AAPAI@Z ; std::_Ptr_cat<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAI@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@IV?$allocator@I@std@@@0@AAPAI@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAI@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@IV?$allocator@I@std@@@0@AAPAI@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAI@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@IV?$allocator@I@std@@@0@AAPAI@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEABIXZ ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEABIXZ PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEABIXZ ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator++
_TEXT	ENDS
PUBLIC	??$_Construct@II@std@@YAXPAIABI@Z		; std::_Construct<unsigned int,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@II@std@@YAXPAIABI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@II@std@@YAXPAIABI@Z PROC			; std::_Construct<unsigned int,unsigned int>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@5
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@5:

; 53   : 	}

	ret	0
??$_Construct@II@std@@YAXPAIABI@Z ENDP			; std::_Construct<unsigned int,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Destroy@I@std@@YAXPAI@Z			; std::_Destroy<unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@I@std@@YAXPAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@I@std@@YAXPAI@Z PROC			; std::_Destroy<unsigned int>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@I@std@@YAXPAI@Z ENDP			; std::_Destroy<unsigned int>
_TEXT	ENDS
PUBLIC	?getNUM_VICTORY_POINT_AWARDS@CvGlobals@@QAEHXZ	; CvGlobals::getNUM_VICTORY_POINT_AWARDS
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getNUM_VICTORY_POINT_AWARDS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUM_VICTORY_POINT_AWARDS@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNUM_VICTORY_POINT_AWARDS, COMDAT
; _this$ = ecx

; 5340 : 		return m_iNUM_VICTORY_POINT_AWARDS;

	mov	eax, DWORD PTR [ecx+6264]

; 5341 : 	}

	ret	0
?getNUM_VICTORY_POINT_AWARDS@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNUM_VICTORY_POINT_AWARDS
_TEXT	ENDS
PUBLIC	?getNUM_RESOURCE_QUANTITY_TYPES@CvGlobals@@QAEHXZ ; CvGlobals::getNUM_RESOURCE_QUANTITY_TYPES
; Function compile flags: /Ogtpy
;	COMDAT ?getNUM_RESOURCE_QUANTITY_TYPES@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUM_RESOURCE_QUANTITY_TYPES@CvGlobals@@QAEHXZ PROC	; CvGlobals::getNUM_RESOURCE_QUANTITY_TYPES, COMDAT
; _this$ = ecx

; 6092 : 		return m_iNUM_RESOURCE_QUANTITY_TYPES;

	mov	eax, DWORD PTR [ecx+7016]

; 6093 : 	}

	ret	0
?getNUM_RESOURCE_QUANTITY_TYPES@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getNUM_RESOURCE_QUANTITY_TYPES
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7738 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8596]

; 7739 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ ; CvGlobals::GetGameDatabase
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ
_TEXT	SEGMENT
?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ PROC ; CvGlobals::GetGameDatabase, COMDAT
; _this$ = ecx

; 9792 : 	return m_pGameDatabase;

	mov	eax, DWORD PTR [ecx+912]

; 9793 : }

	ret	0
?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ ENDP ; CvGlobals::GetGameDatabase
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z
_TEXT	SEGMENT
_pArray$ = 8						; size = 4
_count$ = 12						; size = 4
_iDefault$ = 16						; size = 4
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z PROC	; CvDatabaseUtility::InitializeArray, COMDAT
; _this$ = ecx

; 120  : {

	push	esi

; 121  : 	CvAssertMsg(count > 0, "Initializing array to 0 or less items.");
; 122  : #ifdef AUI_WARNING_FIXES
; 123  : 	delete[] pArray;
; 124  : #endif
; 125  : 	pArray = FNEW(int[count], c_eCiv5GameplayDLL, 0);

	mov	esi, DWORD PTR _count$[esp]
	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 126  : 	if(iDefault == 0)

	mov	edx, DWORD PTR _iDefault$[esp+4]
	mov	ecx, DWORD PTR _pArray$[esp+4]
	add	esp, 4
	mov	DWORD PTR [ecx], eax
	test	edx, edx
	jne	SHORT $LN5@Initialize

; 127  : 	{
; 128  : 		ZeroMemory(pArray, sizeof(int) * count);

	lea	ecx, DWORD PTR [esi*4]
	push	ecx
	push	edx
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
$LN5@Initialize:

; 129  : 	}
; 130  : 	else
; 131  : 	{
; 132  : 		for(size_t i = 0; i < count; ++i)

	xor	eax, eax
	test	esi, esi
	jbe	SHORT $LN1@Initialize
	push	edi
	npad	5
$LL3@Initialize:

; 133  : 			pArray[i] = iDefault;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edi+eax*4], edx
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL3@Initialize
	pop	edi
$LN1@Initialize:
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ENDP	; CvDatabaseUtility::InitializeArray
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z ; CvDatabaseUtility::InitializeArray
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z
_TEXT	SEGMENT
_pArray$ = 8						; size = 4
_count$ = 12						; size = 4
tv143 = 16						; size = 4
_bDefault$ = 16						; size = 1
?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z PROC ; CvDatabaseUtility::InitializeArray, COMDAT
; _this$ = ecx

; 138  : {

	push	esi

; 139  : 	CvAssertMsg(count > 0, "Initializing array to 0 or less items.");
; 140  : #ifdef AUI_WARNING_FIXES
; 141  : 	delete[] pArray;
; 142  : #endif
; 143  : 	pArray = FNEW(bool[count], c_eCiv5GameplayDLL, 0);

	mov	esi, DWORD PTR _count$[esp]
	push	edi
	push	esi
	call	??_U@YAPAXI@Z				; operator new[]

; 144  : #ifdef AUI_WARNING_FIXES
; 145  : 	if (bDefault == false)
; 146  : #else
; 147  : 	if(bDefault == 0.0f)

	mov	dl, BYTE PTR _bDefault$[esp+8]
	mov	ecx, DWORD PTR _pArray$[esp+8]
	mov	edi, eax
	movzx	eax, dl
	mov	DWORD PTR tv143[esp+8], eax
	add	esp, 4
	mov	DWORD PTR [ecx], edi
	fild	DWORD PTR tv143[esp+4]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@Initialize@2

; 148  : #endif
; 149  : 	{
; 150  : 		ZeroMemory(pArray, sizeof(bool) * count);

	push	esi
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 156  : 	}
; 157  : }

	ret	12					; 0000000cH
$LN5@Initialize@2:

; 151  : 	}
; 152  : 	else
; 153  : 	{
; 154  : 		for(size_t i = 0; i < count; ++i)

	xor	eax, eax
	test	esi, esi
	jbe	SHORT $LN1@Initialize@2
$LL3@Initialize@2:

; 155  : 			pArray[i] = bDefault;

	mov	edi, DWORD PTR [ecx]
	mov	BYTE PTR [eax+edi], dl
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL3@Initialize@2
$LN1@Initialize@2:
	pop	edi
	pop	esi

; 156  : 	}
; 157  : }

	ret	12					; 0000000cH
?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z ENDP ; CvDatabaseUtility::InitializeArray
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@3

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	dl, BYTE PTR [eax]
	push	ebx

; 21   : 
; 22   : 		_Left = _Right;

	mov	bl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], bl

; 23   : 		_Right = _Tmp;

	mov	BYTE PTR [ecx], dl
	pop	ebx
$LN1@swap@3:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::_Container_base_aux_alloc_empty<std::allocator<bool> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::_Container_base_aux_alloc_empty<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@V?$allocator@_N@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::_Container_base_aux_alloc_empty<std::allocator<bool> >
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
_TEXT	ENDS
PUBLIC	??0?$allocator@_N@std@@QAE@XZ			; std::allocator<bool>::allocator<bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@_N@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_N@std@@QAE@XZ PROC			; std::allocator<bool>::allocator<bool>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@_N@std@@QAE@XZ ENDP			; std::allocator<bool>::allocator<bool>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::~_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::~_Container_base_aux_alloc_empty<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::~_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@I@std@@QAE@XZ			; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@I@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@I@std@@QAE@XZ PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@I@std@@QAE@XZ ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
_TEXT	ENDS
PUBLIC	?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z ; std::vector<bool,std::allocator<bool> >::_Nw
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z PROC	; std::vector<bool,std::allocator<bool> >::_Nw, COMDAT

; 2331 : 		return ((_Count + _VBITS - 1) / _VBITS);

	mov	eax, DWORD PTR __Count$[esp-4]
	add	eax, 31					; 0000001fH
	shr	eax, 5

; 2332 : 		}

	ret	0
?_Nw@?$vector@_NV?$allocator@_N@std@@@std@@KAII@Z ENDP	; std::vector<bool,std::allocator<bool> >::_Nw
_TEXT	ENDS
PUBLIC	??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
;	COMDAT ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ DB 'vector<bool> to'
	DB	'o long', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$2
__ehfuncinfo$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T231761 = -80						; size = 28
$T231760 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ PROC ; std::vector<bool,std::allocator<bool> >::_Xlen, COMDAT
; _this$ = ecx

; 2374 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 2375 : 		_THROW(length_error, "vector<bool> too long");

	push	OFFSET ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231761[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231760[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231761[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231760[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231760[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231760[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231760[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@5:
$LN12@Xlen@5:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$0:
	lea	ecx, DWORD PTR $T231761[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$2:
	lea	ecx, DWORD PTR $T231760[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::_Xlen
PUBLIC	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231792 = -80						; size = 28
$T231791 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231792[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231791[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231792[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231791[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231791[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231791[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231791[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@6:
$LN12@Xlen@6:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231792[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231791[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >::_Container_base_aux_alloc_empty<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@I@std@@QAE@ABV01@@Z		; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@I@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@I@std@@QAE@ABV01@@Z PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@I@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@I@std@@QAEXPAII@Z	; std::allocator<unsigned int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@I@std@@QAEXPAII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@I@std@@QAEXPAII@Z PROC		; std::allocator<unsigned int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@I@std@@QAEXPAII@Z ENDP		; std::allocator<unsigned int>::deallocate
_TEXT	ENDS
PUBLIC	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=, COMDAT
; _this$ = ecx

; 1602 : 		{	// increment by integer

	mov	eax, ecx

; 1603 : 		if (_Off == 0)

	mov	ecx, DWORD PTR __Off$[esp-4]
	test	ecx, ecx

; 1604 : 			return (*this); // early out

	je	SHORT $LN6@operator@5
	push	esi

; 1605 : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1606 : 		if (_Off < 0)
; 1607 : 			{
; 1608 : 			_SCL_SECURE_VALIDATE_RANGE(this->_My_actual_offset() >= ((size_type)-_Off));
; 1609 : 			}
; 1610 : 		else
; 1611 : 			{
; 1612 : 			_SCL_SECURE_VALIDATE_RANGE((this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1613 : 			}
; 1614 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	jge	SHORT $LN2@operator@5
	mov	edx, DWORD PTR [eax+4]
	mov	esi, ecx
	neg	esi
	cmp	edx, esi
	jae	SHORT $LN2@operator@5

; 1615 : 			{	/* add negative increment */
; 1616 : 			this->_Myoff += _Off;

	add	ecx, edx

; 1617 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	or	edx, -1
	sub	edx, ecx
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	mov	esi, -4					; fffffffcH
	sub	esi, edx
	add	DWORD PTR [eax], esi

; 1624 : 			this->_Myoff %= _VBITS;

	and	ecx, 31					; 0000001fH
	mov	DWORD PTR [eax+4], ecx
	pop	esi

; 1625 : 			}
; 1626 : 		return (*this);
; 1627 : 		}

	ret	4
$LN2@operator@5:

; 1618 : 			this->_Myoff %= _VBITS;
; 1619 : 			}
; 1620 : 		else
; 1621 : 			{	/* add non-negative increment */
; 1622 : 			this->_Myoff += _Off;

	mov	edx, DWORD PTR [eax+4]
	add	ecx, edx

; 1623 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	edx, ecx
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 1624 : 			this->_Myoff %= _VBITS;

	and	ecx, 31					; 0000001fH
	mov	DWORD PTR [eax+4], ecx
	pop	esi
$LN6@operator@5:

; 1625 : 			}
; 1626 : 		return (*this);
; 1627 : 		}

	ret	4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
_TEXT	ENDS
PUBLIC	??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-, COMDAT
; _this$ = ecx

; 1649 : 
; 1650 :  #if _HAS_ITERATOR_DEBUGGING
; 1651 : 		_Compat(_Right);
; 1652 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1653 : 
; 1654 : 		return (_VBITS * (this->_Myptr - _Right._Myptr)
; 1655 : 			+ (difference_type)this->_Myoff
; 1656 : 			- (difference_type)_Right._Myoff);

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx]
	sar	eax, 2
	shl	eax, 5
	sub	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR [ecx+4]

; 1657 : 		}

	ret	4
??G?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@I@std@@QBEIXZ		; std::allocator<unsigned int>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@I@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@I@std@@QBEIXZ PROC		; std::allocator<unsigned int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@I@std@@QBEIXZ ENDP		; std::allocator<unsigned int>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z ; std::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z PROC ; std::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1403 : 		{	// construct with offset and pointer

	mov	edx, DWORD PTR __Off$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1404 : 		}

	ret	8
??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z ENDP ; std::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator==
_TEXT	ENDS
PUBLIC	??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z ; FDataStream::operator>><CvString>
EXTRN	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z PROC ; FDataStream::operator>><CvString>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z ENDP ; FDataStream::operator>><CvString>
_TEXT	ENDS
PUBLIC	??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z ; FDataStream::operator<<<CvString>
EXTRN	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z PROC ; FDataStream::operator<<<CvString>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z ENDP ; FDataStream::operator<<<CvString>
_TEXT	ENDS
PUBLIC	??$_Allocate@I@std@@YAPAIIPAI@Z			; std::_Allocate<unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@I@std@@YAPAIIPAI@Z
_TEXT	SEGMENT
$T231855 = -12						; size = 12
$T231859 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@I@std@@YAPAIIPAI@Z PROC			; std::_Allocate<unsigned int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231859[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T231855[esp+16]
	mov	DWORD PTR $T231859[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231855[esp+16]
	push	ecx
	mov	DWORD PTR $T231855[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@6:
$LN8@Allocate@6:
	int	3
??$_Allocate@I@std@@YAPAIIPAI@Z ENDP			; std::_Allocate<unsigned int>
_TEXT	ENDS
PUBLIC	?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC	; std::vector<bool,std::allocator<bool> >::size, COMDAT
; _this$ = ecx

; 2048 : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx]

; 2049 : 		}

	ret	0
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP	; std::vector<bool,std::allocator<bool> >::size
_TEXT	ENDS
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
_TEXT	ENDS
PUBLIC	??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator==, COMDAT
; _this$ = ecx

; 1666 : 
; 1667 :  #if _HAS_ITERATOR_DEBUGGING
; 1668 : 		_Compat(_Right);
; 1669 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1670 : 
; 1671 : 		return (this->_Myptr == _Right._Myptr
; 1672 : 			&& this->_Myoff == _Right._Myoff);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@operator@6
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator@6
	mov	eax, 1

; 1673 : 		}

	ret	4
$LN3@operator@6:

; 1666 : 
; 1667 :  #if _HAS_ITERATOR_DEBUGGING
; 1668 : 		_Compat(_Right);
; 1669 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1670 : 
; 1671 : 		return (this->_Myptr == _Right._Myptr
; 1672 : 			&& this->_Myoff == _Right._Myoff);

	xor	eax, eax

; 1673 : 		}

	ret	4
??8?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator==
_TEXT	ENDS
PUBLIC	?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Inc, COMDAT
; _this$ = ecx

; 1734 : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1735 : 		_SCL_SECURE_VALIDATE_RANGE((this->_My_actual_offset() + 1) <= ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1736 : 		if (this->_Myoff < _VBITS - 1)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 31					; 0000001fH
	jae	SHORT $LN2@Inc@2

; 1737 : 			++this->_Myoff;

	inc	eax
	mov	DWORD PTR [ecx+4], eax

; 1740 : 		}

	ret	0
$LN2@Inc@2:

; 1738 : 		else
; 1739 : 			this->_Myoff = 0, ++this->_Myptr;

	add	DWORD PTR [ecx], 4
	mov	DWORD PTR [ecx+4], 0

; 1740 : 		}

	ret	0
?_Inc@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Inc
_TEXT	ENDS
PUBLIC	??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1465 : 		{	// construct with base

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1466 : 		}

	ret	4
??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Getptr
; Function compile flags: /Ogtpy
;	COMDAT ?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ
_TEXT	SEGMENT
?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Getptr, COMDAT
; _this$ = ecx

; 1500 : 
; 1501 :  #if _HAS_ITERATOR_DEBUGGING
; 1502 : 		if (this->_Mycont == 0 || this->_Myptr == 0)
; 1503 : 			{
; 1504 : 			_DEBUG_ERROR("vector<bool> iterator not dereferencable");
; 1505 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1506 : 			}
; 1507 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1508 :  		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1509 : 		_SCL_SECURE_VALIDATE_RANGE(this->_My_actual_offset() < ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1510 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1511 : 
; 1512 : 		return (this->_Myptr);

	mov	eax, DWORD PTR [ecx]

; 1513 : 		}

	ret	0
?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Getptr
_TEXT	ENDS
PUBLIC	?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Mask
; Function compile flags: /Ogtpy
;	COMDAT ?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ
_TEXT	SEGMENT
?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Mask, COMDAT
; _this$ = ecx

; 1518 : 		return ((_Vbase)(1 << this->_Myoff));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, 1
	shl	eax, cl

; 1519 : 		}

	ret	0
?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Mask
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ; std::_Iter_random<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z ; std::_Iter_random<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z PROC ; std::_Iter_random<unsigned int *,unsigned int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z ENDP ; std::_Iter_random<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ; std::_Ptr_cat<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z PROC ; std::_Ptr_cat<unsigned int *,unsigned int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ENDP ; std::_Ptr_cat<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@2

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@2:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*, COMDAT
; _this$ = ecx

; 1791 : 		return (_Reft(*this));

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 1792 : 		}

	ret	4
??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
_TEXT	ENDS
PUBLIC	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 1
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=, COMDAT
; _this$ = ecx

; 1475 : 		{	// assign _Val to bit

	mov	eax, ecx

; 1476 : 		if (_Val)
; 1477 : 			*_Getptr() |= _Mask();

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, 1
	shl	esi, cl
	cmp	BYTE PTR __Val$[esp], 0
	je	SHORT $LN2@operator@7
	or	DWORD PTR [edx], esi
	pop	esi

; 1480 : 		return (*this);
; 1481 : 		}

	ret	4
$LN2@operator@7:

; 1478 : 		else
; 1479 : 			*_Getptr() &= ~_Mask();

	not	esi
	and	DWORD PTR [edx], esi
	pop	esi

; 1480 : 		return (*this);
; 1481 : 		}

	ret	4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
_TEXT	ENDS
PUBLIC	?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
; Function compile flags: /Ogtpy
;	COMDAT ?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@5
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@5:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
_TEXT	ENDS
PUBLIC	??$_Fill@PAII@std@@YAXPAI0ABI@Z			; std::_Fill<unsigned int *,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAII@std@@YAXPAI0ABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAII@std@@YAXPAI0ABI@Z PROC			; std::_Fill<unsigned int *,unsigned int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@4:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@4
	pop	esi
$LN1@Fill@4:

; 3160 : 	}

	ret	0
??$_Fill@PAII@std@@YAXPAI0ABI@Z ENDP			; std::_Fill<unsigned int *,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ; std::_Move_cat<unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z PROC ; std::_Move_cat<unsigned int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ENDP ; std::_Move_cat<unsigned int *>
_TEXT	ENDS
PUBLIC	?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Dec
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Dec, COMDAT
; _this$ = ecx

; 1719 : 		if (this->_Myoff != 0)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN2@Dec@2

; 1720 : 			{
; 1721 : 			--this->_Myoff;

	dec	eax
	mov	DWORD PTR [ecx+4], eax

; 1729 : 			}
; 1730 : 		}

	ret	0
$LN2@Dec@2:

; 1722 : 			}
; 1723 : 		else
; 1724 : 			{
; 1725 : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1726 : 			_SCL_SECURE_VALIDATE_RANGE(this->_Myptr > this->_My_cont_begin());
; 1727 : 			--this->_Myptr;

	add	DWORD PTR [ecx], -4			; fffffffcH

; 1728 : 			this->_Myoff = _VBITS - 1;

	mov	DWORD PTR [ecx+4], 31			; 0000001fH

; 1729 : 			}
; 1730 : 		}

	ret	0
?_Dec@?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IAEXXZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Dec
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@4

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@4:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ; std::_Iter_cat<unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z PROC ; std::_Iter_cat<unsigned int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ENDP ; std::_Iter_cat<unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
_TEXT	ENDS
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T231980 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 514  : {

	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T231980[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 516  : 
; 517  : 	size_t bytes = 0;
; 518  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR __$EHRec$[esp+128], 1
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 519  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 520  : 	str.assign(szComposedString, bytes);
; 521  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T231980[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 522  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	mov	eax, DWORD PTR $T231980[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz
	and	DWORD PTR $T231980[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
PUBLIC	??_7CvBaseInfo@@6B@				; CvBaseInfo::`vftable'
PUBLIC	??0CvBaseInfo@@QAE@XZ				; CvBaseInfo::CvBaseInfo
PUBLIC	??_R4CvBaseInfo@@6B@				; CvBaseInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
PUBLIC	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z	; CvBaseInfo::readFrom
PUBLIC	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z	; CvBaseInfo::writeTo
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvBaseInfo@@8
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvBaseInfo@@6B@
rdata$r	SEGMENT
??_R4CvBaseInfo@@6B@ DD 00H				; CvBaseInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvBaseInfo@@@8
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvBaseInfo@@6B@
CONST	SEGMENT
??_7CvBaseInfo@@6B@ DD FLAT:??_R4CvBaseInfo@@6B@	; CvBaseInfo::`vftable'
	DD	FLAT:?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??0CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::CvBaseInfo, COMDAT
; _this$ = ecx

; 39   : {}

	push	-1
	push	__ehhandler$??0CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvBaseInfo@@6B@
	mov	DWORD PTR [esi+4], -1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+232]
	mov	BYTE PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::CvBaseInfo
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
__ehfuncinfo$?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
$T232058 = -68						; size = 28
$T232059 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
___formal$ = 12						; size = 4
?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvBaseInfo::CacheResults, COMDAT
; _this$ = ecx

; 48   : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 49   : 	m_iID				= kResults.GetInt("ID");

	mov	edi, DWORD PTR _kResults$[esp+80]
	mov	esi, ecx
	push	OFFSET $SG218616
	mov	ecx, edi
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z

; 50   : 	m_strType			= kResults.GetText("Type");

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG218617
	mov	ecx, edi
	mov	DWORD PTR [esi+4], eax
	call	ebx
	lea	ecx, DWORD PTR [esi+176]
	test	eax, eax
	je	SHORT $LN9@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN8@CacheResul
$LN9@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN8@CacheResul:

; 51   : 	m_strTextKey		= kResults.GetText("Text");

	push	OFFSET $SG218618
	mov	ecx, edi
	call	ebx
	lea	ebp, DWORD PTR [esi+204]
	mov	ecx, ebp
	test	eax, eax
	je	SHORT $LN13@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN12@CacheResul
$LN13@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN12@CacheResul:

; 52   : 	m_strCivilopedia	= kResults.GetText("Civilopedia");

	push	OFFSET $SG218619
	mov	ecx, edi
	call	ebx
	lea	ecx, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN17@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN16@CacheResul
$LN17@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN16@CacheResul:

; 53   : 	m_strStrategy		= kResults.GetText("Strategy");

	push	OFFSET $SG218620
	mov	ecx, edi
	call	ebx
	lea	ecx, DWORD PTR [esi+148]
	test	eax, eax
	je	SHORT $LN21@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN20@CacheResul
$LN21@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN20@CacheResul:

; 54   : 	m_strHelp			= kResults.GetText("Help");

	push	OFFSET $SG218621
	mov	ecx, edi
	call	ebx
	lea	ecx, DWORD PTR [esi+92]
	test	eax, eax
	je	SHORT $LN25@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN24@CacheResul
$LN25@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN24@CacheResul:

; 55   : 	m_strDisabledHelp	= kResults.GetText("DisabledHelp");

	push	OFFSET $SG218622
	mov	ecx, edi
	call	ebx
	lea	ecx, DWORD PTR [esi+120]
	test	eax, eax
	je	SHORT $LN29@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN28@CacheResul
$LN29@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN28@CacheResul:

; 56   : 
; 57   : 	if(!m_strTextKey.empty())

	mov	ecx, ebp
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	test	al, al
	jne	SHORT $LN3@CacheResul

; 58   : 		m_strText = GetLocalizedText(m_strTextKey);

	mov	ecx, ebp
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T232058[esp+88]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	lea	ecx, DWORD PTR [esi+232]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T232058[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@CacheResul:

; 59   : 
; 60   : 
; 61   : 	const char* szDescription = kResults.GetText("Description");

	push	OFFSET $SG218626
	mov	ecx, edi
	call	ebx
	mov	edi, eax

; 62   : 	if(szDescription)

	test	edi, edi
	je	SHORT $LN55@CacheResul

; 63   : 	{
; 64   : 		m_strDescriptionKey = szDescription;

	lea	ecx, DWORD PTR [esi+64]
	push	edi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 65   : 		m_strDescription = GetLocalizedText(szDescription);

	lea	ecx, DWORD PTR $T232059[esp+84]
	push	edi
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	lea	ebx, DWORD PTR [esi+36]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+96], 1
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T232059[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 66   : 
; 67   : 		//CvInfoBase did this, gotta support it for now...
; 68   : 		if(m_strTextKey.empty())

	mov	ecx, ebp
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN55@CacheResul

; 69   : 		{
; 70   : 			m_strTextKey = szDescription;

	push	edi
	mov	ecx, ebp
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 71   : 			m_strText = m_strDescription;

	push	ebx
	lea	ecx, DWORD PTR [esi+232]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN55@CacheResul:

; 72   : 		}
; 73   : 	}
; 74   : 
; 75   : 	return true;
; 76   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR $T232058[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR $T232059[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvBaseInfo::CacheResults
; Function compile flags: /Ogtpy
;	COMDAT ?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z PROC	; CvBaseInfo::readFrom, COMDAT
; _this$ = ecx

; 104  : {

	push	esi
	mov	esi, ecx
	push	edi

; 105  : 	loadFrom >> m_iID;

	mov	edi, DWORD PTR _loadFrom$[esp+4]
	lea	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 106  : 	loadFrom >> m_strCivilopedia;

	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 107  : 	loadFrom >> m_strDescription;

	lea	edx, DWORD PTR [esi+36]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 108  : 	loadFrom >> m_strHelp;

	lea	eax, DWORD PTR [esi+92]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 109  : 	loadFrom >> m_strDisabledHelp;

	lea	ecx, DWORD PTR [esi+120]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 110  : 	loadFrom >> m_strStrategy;

	lea	edx, DWORD PTR [esi+148]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 111  : 	loadFrom >> m_strType;

	lea	eax, DWORD PTR [esi+176]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 112  : 	loadFrom >> m_strTextKey;

	lea	ecx, DWORD PTR [esi+204]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 113  : 	loadFrom >> m_strText;

	add	esi, 232				; 000000e8H
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read
	pop	edi
	pop	esi

; 114  : }

	ret	4
?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z ENDP	; CvBaseInfo::readFrom
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z PROC	; CvBaseInfo::writeTo, COMDAT
; _this$ = ecx

; 117  : {

	push	esi
	mov	esi, ecx
	push	edi

; 118  : 	saveTo << m_iID;

	mov	edi, DWORD PTR _saveTo$[esp+4]
	lea	eax, DWORD PTR [esi+4]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 119  : 	saveTo << m_strCivilopedia;

	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 120  : 	saveTo << m_strDescription;

	lea	edx, DWORD PTR [esi+36]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 121  : 	saveTo << m_strHelp;

	lea	eax, DWORD PTR [esi+92]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 122  : 	saveTo << m_strDisabledHelp;

	lea	ecx, DWORD PTR [esi+120]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 123  : 	saveTo << m_strStrategy;

	lea	edx, DWORD PTR [esi+148]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 124  : 	saveTo << m_strType;

	lea	eax, DWORD PTR [esi+176]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 125  : 	saveTo << m_strTextKey;

	lea	ecx, DWORD PTR [esi+204]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 126  : 	saveTo << m_strText;

	add	esi, 232				; 000000e8H
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write
	pop	edi
	pop	esi

; 127  : }

	ret	4
?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z ENDP	; CvBaseInfo::writeTo
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	?CreateKeyStringFromKBCode@CvHotKeyInfo@@SA?AVCvString@@PBD@Z ; CvHotKeyInfo::CreateKeyStringFromKBCode
; Function compile flags: /Ogtpy
;	COMDAT ?CreateKeyStringFromKBCode@CvHotKeyInfo@@SA?AVCvString@@PBD@Z
_TEXT	SEGMENT
_asCvKeyBoardMapping$ = -1312				; size = 1308
$T232277 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pszHotKey$ = 12					; size = 4
?CreateKeyStringFromKBCode@CvHotKeyInfo@@SA?AVCvString@@PBD@Z PROC ; CvHotKeyInfo::CreateKeyStringFromKBCode, COMDAT

; 349  : {

	sub	esp, 1312				; 00000520H

; 350  : 	struct CvKeyBoardMapping
; 351  : 	{
; 352  : 		const char* szDefineString;
; 353  : 		const char* szKeyString;
; 354  : 		bool bIsLocalizedText;
; 355  : 	};
; 356  : 
; 357  : 	// TODO - this should be a stl map instead of looping strcmp
; 358  : 	const CvKeyBoardMapping asCvKeyBoardMapping[] =
; 359  : 	{
; 360  : 		{"KB_ESCAPE", "TXT_KEY_KEYBOARD_ESCAPE", true},
; 361  : 		{"KB_0","0", false},
; 362  : 		{"KB_1","1", false},
; 363  : 		{"KB_2","2", false},
; 364  : 		{"KB_3","3", false},
; 365  : 		{"KB_4","4", false},
; 366  : 		{"KB_5","5", false},
; 367  : 		{"KB_6","6", false},
; 368  : 		{"KB_7","7", false},
; 369  : 		{"KB_8","8", false},
; 370  : 		{"KB_9","9", false},
; 371  : 		{"KB_MINUS","-", false},	    // - on main keyboard
; 372  : 		{"KB_A","A", false},
; 373  : 		{"KB_B","B", false},
; 374  : 		{"KB_C","C", false},
; 375  : 		{"KB_D","D", false},
; 376  : 		{"KB_E","E", false},
; 377  : 		{"KB_F","F", false},
; 378  : 		{"KB_G","G", false},
; 379  : 		{"KB_H","H", false},
; 380  : 		{"KB_I","I", false},
; 381  : 		{"KB_J","J", false},
; 382  : 		{"KB_K","K", false},
; 383  : 		{"KB_L","L", false},
; 384  : 		{"KB_M","M", false},
; 385  : 		{"KB_N","N", false},
; 386  : 		{"KB_O","O", false},
; 387  : 		{"KB_P","P", false},
; 388  : 		{"KB_Q","Q", false},
; 389  : 		{"KB_R","R", false},
; 390  : 		{"KB_S","S", false},
; 391  : 		{"KB_T","T", false},
; 392  : 		{"KB_U","U", false},
; 393  : 		{"KB_V","V", false},
; 394  : 		{"KB_W","W", false},
; 395  : 		{"KB_X","X", false},
; 396  : 		{"KB_Y","Y", false},
; 397  : 		{"KB_Z","Z", false},
; 398  : 		{"KB_EQUALS","=", false},
; 399  : 		{"KB_BACKSPACE", "TXT_KEY_KEYBOARD_BACKSPACE", true},
; 400  : 		{"KB_TAB","TAB", false},
; 401  : 		{"KB_LBRACKET","[", false},
; 402  : 		{"KB_RBRACKET","]", false},
; 403  : 		{"KB_RETURN", "TXT_KEY_KEYBOARD_ENTER", true},		// Enter on main keyboard
; 404  : 		{"KB_LCONTROL", "TXT_KEY_KEYBOARD_LEFT_CONTROL_KEY", true},
; 405  : 		{"KB_SEMICOLON",";", false},
; 406  : 		{"KB_APOSTROPHE","'", false},
; 407  : 		{"KB_GRAVE","`", false},		// accent grave
; 408  : 		{"KB_LSHIFT", "TXT_KEY_KEYBOARD_LEFT_SHIFT_KEY", true},
; 409  : 		{"KB_BACKSLASH","\\"},
; 410  : 		{"KB_COMMA",",", false},
; 411  : 		{"KB_PERIOD",".", false},
; 412  : 		{"KB_SLASH","/", false},
; 413  : 		{"KB_RSHIFT", "TXT_KEY_KEYBOARD_RIGHT_SHIFT_KEY", true},
; 414  : 		{"KB_NUMPADSTAR", "TXT_KEY_KEYBOARD_NUM_PAD_STAR", true},
; 415  : 		{"KB_LALT", "TXT_KEY_KEYBOARD_LEFT_ALT_KEY", true},
; 416  : 		{"KB_SPACE", "TXT_KEY_KEYBOARD_SPACE_KEY", true},
; 417  : 		{"KB_CAPSLOCK", "TXT_KEY_KEYBOARD_CAPS_LOCK", true},
; 418  : 		{"KB_F1","F1", false},
; 419  : 		{"KB_F2","F2", false},
; 420  : 		{"KB_F3","F3", false},
; 421  : 		{"KB_F4","F4", false},
; 422  : 		{"KB_F5","F5", false},
; 423  : 		{"KB_F6","F6", false},
; 424  : 		{"KB_F7","F7", false},
; 425  : 		{"KB_F8","F8", false},
; 426  : 		{"KB_F9","F9", false},
; 427  : 		{"KB_F10","F10", false},
; 428  : 		{"KB_NUMLOCK", "TXT_KEY_KEYBOARD_NUM_LOCK", true},
; 429  : 		{"KB_SCROLL", "TXT_KEY_KEYBOARD_SCROLL_KEY", true},
; 430  : 		{"KB_NUMPAD7", "TXT_KEY_KEYBOARD_NUMPAD_NUMBER7", true},
; 431  : 		{"KB_NUMPAD8", "TXT_KEY_KEYBOARD_NUMPAD_NUMBER8", true},
; 432  : 		{"KB_NUMPAD9", "TXT_KEY_KEYBOARD_NUMPAD_NUMBER9", true},
; 433  : 		{"KB_NUMPADMINUS", "TXT_KEY_KEYBOARD_NUMPAD_MINUS", true},
; 434  : 		{"KB_NUMPAD4", "TXT_KEY_KEYBOARD_NUMPAD_NUMBER4", true},
; 435  : 		{"KB_NUMPAD5", "TXT_KEY_KEYBOARD_NUMPAD_NUMBER5", true},
; 436  : 		{"KB_NUMPAD6", "TXT_KEY_KEYBOARD_NUMPAD_NUMBER6", true},
; 437  : 		{"KB_NUMPADPLUS", "TXT_KEY_KEYBOARD_NUMPAD_PLUS", true},
; 438  : 		{"KB_NUMPAD1", "TXT_KEY_KEYBOARD_NUMPAD_NUMBER1", true},
; 439  : 		{"KB_NUMPAD2", "TXT_KEY_KEYBOARD_NUMPAD_NUMBER2", true},
; 440  : 		{"KB_NUMPAD3", "TXT_KEY_KEYBOARD_NUMPAD_NUMBER3", true},
; 441  : 		{"KB_NUMPAD0", "TXT_KEY_KEYBOARD_NUMPAD_NUMBER0", true},
; 442  : 		{"KB_NUMPADPERIOD", "TXT_KEY_KEYBOARD_NUMPAD_PERIOD", true},
; 443  : 		{"KB_F11","F11", false},
; 444  : 		{"KB_F12","F12", false},
; 445  : 		{"KB_NUMPADEQUALS", "TXT_KEY_KEYBOARD_NUMPAD_EQUALS", true},
; 446  : 		{"KB_AT","@", false},
; 447  : 		{"KB_UNDERLINE","_", false},
; 448  : 		{"KB_COLON",":", false},
; 449  : 		{"KB_NUMPADENTER", "TXT_KEY_KEYBOARD_NUMPAD_ENTER_KEY", true},
; 450  : 		{"KB_RCONTROL", "TXT_KEY_KEYBOARD_RIGHT_CONTROL_KEY", true},
; 451  : 		{"KB_VOLUMEDOWN", "TXT_KEY_KEYBOARD_VOLUME_DOWN", true},
; 452  : 		{"KB_VOLUMEUP", "TXT_KEY_KEYBOARD_VOLUME_UP", true},
; 453  : 		{"KB_NUMPADCOMMA", "TXT_KEY_KEYBOARD_NUMPAD_COMMA", true},
; 454  : 		{"KB_NUMPADSLASH", "TXT_KEY_KEYBOARD_NUMPAD_SLASH", true},
; 455  : 		{"KB_SYSRQ", "TXT_KEY_KEYBOARD_SYSRQ", true},
; 456  : 		{"KB_RALT", "TXT_KEY_KEYBOARD_RIGHT_ALT_KEY", true},
; 457  : 		{"KB_PAUSE", "TXT_KEY_KEYBOARD_PAUSE_KEY", true},
; 458  : 		{"KB_HOME", "TXT_KEY_KEYBOARD_HOME_KEY", true},
; 459  : 		{"KB_UP", "TXT_KEY_KEYBOARD_UP_ARROW", true},
; 460  : 		{"KB_PGUP", "TXT_KEY_KEYBOARD_PAGE_UP", true},
; 461  : 		{"KB_LEFT", "TXT_KEY_KEYBOARD_LEFT_ARROW", true},
; 462  : 		{"KB_RIGHT", "TXT_KEY_KEYBOARD_RIGHT_ARROW", true},
; 463  : 		{"KB_END", "TXT_KEY_KEYBOARD_END_KEY", true},
; 464  : 		{"KB_DOWN", "TXT_KEY_KEYBOARD_DOWN_ARROW", true},
; 465  : 		{"KB_PGDN", "TXT_KEY_KEYBOARD_PAGE_DOWN", true},
; 466  : 		{"KB_INSERT", "TXT_KEY_KEYBOARD_INSERT_KEY", true},
; 467  : 		{"KB_DELETE", "TXT_KEY_KEYBOARD_DELETE_KEY", true},
; 468  : 		{NULL, NULL, false},
; 469  : 	};
; 470  : 
; 471  : 	size_t i = 0;
; 472  : 	while(asCvKeyBoardMapping[i].szDefineString != NULL)

	xor	eax, eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, OFFSET $SG218835
	mov	ecx, 1
	mov	DWORD PTR $T232277[esp+1328], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1328], edi
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1332], OFFSET $SG218836
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1336], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1340], OFFSET $SG218837
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1344], OFFSET $SG218838
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1348], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1352], OFFSET $SG218839
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1356], OFFSET $SG218840
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1360], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1364], OFFSET $SG218841
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1368], OFFSET $SG218842
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1372], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1376], OFFSET $SG218843
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1380], OFFSET $SG218844
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1384], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1388], OFFSET $SG218845
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1392], OFFSET $SG218846
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1396], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1400], OFFSET $SG218847
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1404], OFFSET $SG218848
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1408], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1412], OFFSET $SG218849
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1416], OFFSET $SG218850
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1420], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1424], OFFSET $SG218851
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1428], OFFSET $SG218852
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1432], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1436], OFFSET $SG218853
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1440], OFFSET $SG218854
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1444], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1448], OFFSET $SG218855
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1452], OFFSET $SG218856
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1456], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1460], OFFSET $SG218857
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1464], OFFSET $SG218858
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1468], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1472], OFFSET $SG218859
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1476], OFFSET $SG218860
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1480], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1484], OFFSET $SG218861
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1488], OFFSET $SG218862
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1492], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1496], OFFSET $SG218863
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1500], OFFSET $SG218864
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1504], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1508], OFFSET $SG218865
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1512], OFFSET $SG218866
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1516], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1520], OFFSET $SG218867
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1524], OFFSET $SG218868
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1528], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1532], OFFSET $SG218869
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1536], OFFSET $SG218870
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1540], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1544], OFFSET $SG218871
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1548], OFFSET $SG218872
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1552], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1556], OFFSET $SG218873
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1560], OFFSET $SG218874
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1564], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1568], OFFSET $SG218875
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1572], OFFSET $SG218876
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1576], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1580], OFFSET $SG218877
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1584], OFFSET $SG218878
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1588], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1592], OFFSET $SG218879
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1596], OFFSET $SG218880
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1600], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1604], OFFSET $SG218881
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1608], OFFSET $SG218882
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1612], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1616], OFFSET $SG218883
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1620], OFFSET $SG218884
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1624], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1628], OFFSET $SG218885
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1632], OFFSET $SG218886
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1636], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1640], OFFSET $SG218887
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1644], OFFSET $SG218888
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1648], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1652], OFFSET $SG218889
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1656], OFFSET $SG218890
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1660], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1664], OFFSET $SG218891
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1668], OFFSET $SG218892
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1672], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1676], OFFSET $SG218893
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1680], OFFSET $SG218894
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1684], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1688], OFFSET $SG218895
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1692], OFFSET $SG218896
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1696], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1700], OFFSET $SG218897
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1704], OFFSET $SG218898
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1708], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1712], OFFSET $SG218899
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1716], OFFSET $SG218900
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1720], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1724], OFFSET $SG218901
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1728], OFFSET $SG218902
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1732], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1736], OFFSET $SG218903
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1740], OFFSET $SG218904
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1744], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1748], OFFSET $SG218905
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1752], OFFSET $SG218906
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1756], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1760], OFFSET $SG218907
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1764], OFFSET $SG218908
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1768], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1772], OFFSET $SG218909
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1776], OFFSET $SG218910
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1780], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1784], OFFSET $SG218911
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1788], OFFSET $SG218912
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1792], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1796], OFFSET $SG218913
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1800], OFFSET $SG218914
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1804], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1808], OFFSET $SG218915
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1812], OFFSET $SG218916
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1816], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1820], OFFSET $SG218917
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1824], OFFSET $SG218918
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1828], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1832], OFFSET $SG218919
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1836], OFFSET $SG218920
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1840], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1844], OFFSET $SG218921
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1848], OFFSET $SG218922
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1852], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1856], OFFSET $SG218923
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1860], OFFSET $SG218924
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1864], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1868], OFFSET $SG218925
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1872], OFFSET $SG218926
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1876], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1880], OFFSET $SG218927
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1884], OFFSET $SG218928
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1888], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1892], OFFSET $SG218929
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1896], OFFSET $SG218930
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1900], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1904], OFFSET $SG218931
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1908], OFFSET $SG218932
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1912], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1916], OFFSET $SG218933
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1920], OFFSET $SG218934
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1924], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1928], OFFSET $SG218935
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1932], OFFSET $SG218936
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1936], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1940], OFFSET $SG218937
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1944], OFFSET $SG218938
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1948], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1952], OFFSET $SG218939
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1956], OFFSET $SG218940
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1960], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1964], OFFSET $SG218941
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1968], OFFSET $SG218942
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1972], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1976], OFFSET $SG218943
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1980], OFFSET $SG218944
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1984], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1988], OFFSET $SG218945
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+1992], OFFSET $SG218946
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+1996], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2000], OFFSET $SG218947
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2004], OFFSET $SG218948
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2008], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2012], OFFSET $SG218949
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2016], OFFSET $SG218950
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2020], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2024], OFFSET $SG218951
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2028], OFFSET $SG218952
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2032], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2036], OFFSET $SG218953
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2040], OFFSET $SG218954
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2044], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2048], OFFSET $SG218955
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2052], OFFSET $SG218956
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2056], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2060], OFFSET $SG218957
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2064], OFFSET $SG218958
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2068], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2072], OFFSET $SG218959
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2076], OFFSET $SG218960
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2080], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2084], OFFSET $SG218961
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2088], OFFSET $SG218962
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2092], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2096], OFFSET $SG218963
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2100], OFFSET $SG218964
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2104], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2108], OFFSET $SG218965
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2112], OFFSET $SG218966
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2116], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2120], OFFSET $SG218967
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2124], OFFSET $SG218968
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2128], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2132], OFFSET $SG218969
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2136], OFFSET $SG218970
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2140], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2144], OFFSET $SG218971
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2148], OFFSET $SG218972
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2152], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2156], OFFSET $SG218973
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2160], OFFSET $SG218974
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2164], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2168], OFFSET $SG218975
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2172], OFFSET $SG218976
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2176], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2180], OFFSET $SG218977
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2184], OFFSET $SG218978
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2188], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2192], OFFSET $SG218979
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2196], OFFSET $SG218980
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2200], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2204], OFFSET $SG218981
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2208], OFFSET $SG218982
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2212], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2216], OFFSET $SG218983
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2220], OFFSET $SG218984
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2224], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2228], OFFSET $SG218985
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2232], OFFSET $SG218986
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2236], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2240], OFFSET $SG218987
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2244], OFFSET $SG218988
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2248], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2252], OFFSET $SG218989
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2256], OFFSET $SG218990
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2260], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2264], OFFSET $SG218991
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2268], OFFSET $SG218992
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2272], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2276], OFFSET $SG218993
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2280], OFFSET $SG218994
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2284], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2288], OFFSET $SG218995
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2292], OFFSET $SG218996
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2296], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2300], OFFSET $SG218997
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2304], OFFSET $SG218998
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2308], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2312], OFFSET $SG218999
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2316], OFFSET $SG219000
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2320], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2324], OFFSET $SG219001
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2328], OFFSET $SG219002
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2332], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2336], OFFSET $SG219003
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2340], OFFSET $SG219004
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2344], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2348], OFFSET $SG219005
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2352], OFFSET $SG219006
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2356], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2360], OFFSET $SG219007
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2364], OFFSET $SG219008
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2368], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2372], OFFSET $SG219009
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2376], OFFSET $SG219010
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2380], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2384], OFFSET $SG219011
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2388], OFFSET $SG219012
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2392], al
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2396], OFFSET $SG219013
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2400], OFFSET $SG219014
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2404], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2408], OFFSET $SG219015
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2412], OFFSET $SG219016
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2416], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2420], OFFSET $SG219017
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2424], OFFSET $SG219018
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2428], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2432], OFFSET $SG219019
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2436], OFFSET $SG219020
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2440], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2444], OFFSET $SG219021
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2448], OFFSET $SG219022
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2452], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2456], OFFSET $SG219023
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2460], OFFSET $SG219024
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2464], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2468], OFFSET $SG219025
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2472], OFFSET $SG219026
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2476], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2480], OFFSET $SG219027
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2484], OFFSET $SG219028
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2488], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2492], OFFSET $SG219029
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2496], OFFSET $SG219030
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2500], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2504], OFFSET $SG219031
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2508], OFFSET $SG219032
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2512], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2516], OFFSET $SG219033
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2520], OFFSET $SG219034
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2524], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2528], OFFSET $SG219035
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2532], OFFSET $SG219036
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2536], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2540], OFFSET $SG219037
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2544], OFFSET $SG219038
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2548], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2552], OFFSET $SG219039
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2556], OFFSET $SG219040
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2560], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2564], OFFSET $SG219041
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2568], OFFSET $SG219042
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2572], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2576], OFFSET $SG219043
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2580], OFFSET $SG219044
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2584], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2588], OFFSET $SG219045
	xor	ebx, ebx
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2592], OFFSET $SG219046
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2596], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2600], OFFSET $SG219047
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2604], OFFSET $SG219048
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2608], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2612], OFFSET $SG219049
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2616], OFFSET $SG219050
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2620], cl
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2624], eax
	mov	DWORD PTR _asCvKeyBoardMapping$[esp+2628], eax
	mov	BYTE PTR _asCvKeyBoardMapping$[esp+2632], al
	cmp	edi, eax
	je	SHORT $LN4@CreateKeyS
	mov	ebp, DWORD PTR _pszHotKey$[esp+1324]
$LL5@CreateKeyS:

; 473  : 	{
; 474  : 		if(strcmp(pszHotKey, asCvKeyBoardMapping[i].szDefineString) == 0)

	mov	esi, ebp
$LL23@CreateKeyS:
	mov	dl, BYTE PTR [esi]
	cmp	dl, BYTE PTR [edi]
	jne	SHORT $LN24@CreateKeyS
	cmp	dl, al
	je	SHORT $LN25@CreateKeyS
	mov	dl, BYTE PTR [esi+1]
	cmp	dl, BYTE PTR [edi+1]
	jne	SHORT $LN24@CreateKeyS
	add	esi, 2
	add	edi, 2
	cmp	dl, al
	jne	SHORT $LL23@CreateKeyS
$LN25@CreateKeyS:
	xor	edx, edx
	jmp	SHORT $LN26@CreateKeyS
$LN24@CreateKeyS:
	sbb	edx, edx
	sbb	edx, -1
$LN26@CreateKeyS:
	cmp	edx, eax
	je	SHORT $LN21@CreateKeyS

; 483  : 			}
; 484  : 		}
; 485  : 		i++;

	add	ebx, ecx
	lea	edx, DWORD PTR [ebx+ebx*2]
	mov	edi, DWORD PTR _asCvKeyBoardMapping$[esp+edx*4+1328]
	cmp	edi, eax
	jne	SHORT $LL5@CreateKeyS
$LN4@CreateKeyS:

; 486  : 	}
; 487  : 
; 488  : 	return "";

	push	OFFSET $SG219059
$LN28@CreateKeyS:
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+1328]
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 489  : }

	add	esp, 1312				; 00000520H
	ret	0
$LN21@CreateKeyS:

; 475  : 		{
; 476  : 			if(asCvKeyBoardMapping[i].bIsLocalizedText)

	lea	ecx, DWORD PTR [ebx+ebx*2]
	add	ecx, ecx
	add	ecx, ecx
	cmp	BYTE PTR _asCvKeyBoardMapping$[esp+ecx+1336], al
	je	SHORT $LN2@CreateKeyS

; 477  : 			{
; 478  : 				return GetLocalizedText(asCvKeyBoardMapping[i].szKeyString);

	mov	eax, DWORD PTR _asCvKeyBoardMapping$[esp+ecx+1332]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+1324]
	push	eax
	push	esi
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	pop	edi

; 486  : 	}
; 487  : 
; 488  : 	return "";

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 489  : }

	add	esp, 1312				; 00000520H
	ret	0
$LN2@CreateKeyS:

; 479  : 			}
; 480  : 			else
; 481  : 			{
; 482  : 				return asCvKeyBoardMapping[i].szKeyString;

	mov	ecx, DWORD PTR _asCvKeyBoardMapping$[esp+ecx+1332]
	cmp	ecx, eax
	jne	SHORT $LN13@CreateKeyS
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN13@CreateKeyS:
	push	ecx
	jmp	SHORT $LN28@CreateKeyS
?CreateKeyStringFromKBCode@CvHotKeyInfo@@SA?AVCvString@@PBD@Z ENDP ; CvHotKeyInfo::CreateKeyStringFromKBCode
_TEXT	ENDS
PUBLIC	?getHotKey@CvHotKeyInfo@@QBEPBDXZ		; CvHotKeyInfo::getHotKey
; Function compile flags: /Ogtpy
;	COMDAT ?getHotKey@CvHotKeyInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getHotKey@CvHotKeyInfo@@QBEPBDXZ PROC			; CvHotKeyInfo::getHotKey, COMDAT
; _this$ = ecx

; 652  : 	return m_strHotKey;

	add	ecx, 292				; 00000124H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getHotKey@CvHotKeyInfo@@QBEPBDXZ ENDP			; CvHotKeyInfo::getHotKey
_TEXT	ENDS
PUBLIC	?setHotKey@CvHotKeyInfo@@QAEXPBD@Z		; CvHotKeyInfo::setHotKey
; Function compile flags: /Ogtpy
;	COMDAT ?setHotKey@CvHotKeyInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setHotKey@CvHotKeyInfo@@QAEXPBD@Z PROC			; CvHotKeyInfo::setHotKey, COMDAT
; _this$ = ecx

; 657  : 	m_strHotKey = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 292				; 00000124H
	test	eax, eax
	je	SHORT $LN4@setHotKey
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setHotKey:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 658  : }

	ret	4
?setHotKey@CvHotKeyInfo@@QAEXPBD@Z ENDP			; CvHotKeyInfo::setHotKey
_TEXT	ENDS
PUBLIC	?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CvHotKeyInfo::getHotKeyDescription
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
EXTRN	__imp_??4String@Localization@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??4String@Localization@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??0String@Localization@@QAE@XZ:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvlocalization\include\cvlocalization.h
xdata$x	SEGMENT
__unwindtable$?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$2
__ehfuncinfo$?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T232329 = -176						; size = 4
_strTempText$ = -172					; size = 80
$T232326 = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; CvHotKeyInfo::getHotKeyDescription, COMDAT
; _this$ = ecx

; 671  : {

	push	-1
	push	__ehhandler$?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 164				; 000000a4H
	push	ebp
	push	esi
	xor	eax, eax
	mov	esi, ecx
	push	edi

; 672  : 	Localization::String strTempText;

	lea	ecx, DWORD PTR _strTempText$[esp+188]
	mov	DWORD PTR __$EHRec$[esp+196], eax
	mov	DWORD PTR $T232329[esp+188], eax
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ

; 673  : 	std::string strHotKeyDescription;

	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+184]
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+196], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 690  : 	}
; 691  : 
; 692  : 	return strHotKeyDescription;

	lea	edi, DWORD PTR [esi+348]
	mov	ecx, edi
	mov	DWORD PTR $T232329[esp+188], 1
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	test	al, al
	jne	SHORT $LN3@getHotKeyD
	push	OFFSET $SG219191
	lea	ecx, DWORD PTR _strTempText$[esp+192]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@PBD@Z
	mov	ecx, edi
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edi, DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z
	push	eax
	lea	ecx, DWORD PTR _strTempText$[esp+192]
	call	edi
	lea	ecx, DWORD PTR [esi+320]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTempText$[esp+192]
	call	edi
	jmp	SHORT $LN2@getHotKeyD
$LN3@getHotKeyD:

; 674  : 	if(!m_strHotKeyAltDescriptionKey.empty())
; 675  : 	{
; 676  : 		strTempText = "{1: textkey} ({2: textkey})";
; 677  : 		strTempText << m_strHotKeyAltDescriptionKey.c_str();
; 678  : 		strTempText << m_strHotKeyDescriptionKey.c_str();
; 679  : 	}
; 680  : 	else
; 681  : 	{
; 682  : 		strTempText = Localization::Lookup(m_strHotKeyDescriptionKey.c_str());

	lea	ecx, DWORD PTR [esi+320]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T232326[esp+192]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strTempText$[esp+192]
	mov	BYTE PTR __$EHRec$[esp+200], 2
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T232326[esp+188]
	mov	BYTE PTR __$EHRec$[esp+196], 1
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN2@getHotKeyD:

; 683  : 	}
; 684  : 
; 685  : 	strHotKeyDescription = strTempText.toUTF8();

	lea	ecx, DWORD PTR _strTempText$[esp+188]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	mov	ecx, ebp
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 686  : 
; 687  : 	if(!m_strHotKeyString.empty())

	add	esi, 376				; 00000178H
	mov	ecx, esi
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	test	al, al
	jne	SHORT $LN1@getHotKeyD

; 688  : 	{
; 689  : 		strHotKeyDescription += m_strHotKeyString;

	push	esi
	mov	ecx, ebp
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN1@getHotKeyD:

; 690  : 	}
; 691  : 
; 692  : 	return strHotKeyDescription;

	lea	ecx, DWORD PTR _strTempText$[esp+188]
	mov	BYTE PTR __$EHRec$[esp+196], 0
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 693  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+188]
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 176				; 000000b0H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0:
	lea	ecx, DWORD PTR _strTempText$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1:
	mov	eax, DWORD PTR $T232329[ebp]
	and	eax, 1
	je	$LN8@getHotKeyD
	and	DWORD PTR $T232329[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN8@getHotKeyD:
	ret	0
__unwindfunclet$?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$2:
	lea	ecx, DWORD PTR $T232326[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; CvHotKeyInfo::getHotKeyDescription
PUBLIC	?setHotKeyDescription@CvHotKeyInfo@@QAEXPBD00@Z	; CvHotKeyInfo::setHotKeyDescription
; Function compile flags: /Ogtpy
;	COMDAT ?setHotKeyDescription@CvHotKeyInfo@@QAEXPBD00@Z
_TEXT	SEGMENT
_szHotKeyDescKey$ = 8					; size = 4
_szHotKeyAltDescKey$ = 12				; size = 4
_szHotKeyString$ = 16					; size = 4
?setHotKeyDescription@CvHotKeyInfo@@QAEXPBD00@Z PROC	; CvHotKeyInfo::setHotKeyDescription, COMDAT
; _this$ = ecx

; 703  : 	m_strHotKeyDescriptionKey = szHotKeyDescKey;

	mov	eax, DWORD PTR _szHotKeyDescKey$[esp-4]
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+320]
	test	eax, eax
	je	SHORT $LN4@setHotKeyD
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN3@setHotKeyD
$LN4@setHotKeyD:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN3@setHotKeyD:

; 704  : 	m_strHotKeyAltDescriptionKey = szHotKeyAltDescKey;

	mov	eax, DWORD PTR _szHotKeyAltDescKey$[esp]
	lea	ecx, DWORD PTR [esi+348]
	test	eax, eax
	je	SHORT $LN8@setHotKeyD
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN7@setHotKeyD
$LN8@setHotKeyD:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN7@setHotKeyD:

; 705  : 	m_strHotKeyString = szHotKeyString;

	mov	eax, DWORD PTR _szHotKeyString$[esp]
	lea	ecx, DWORD PTR [esi+376]
	pop	esi
	test	eax, eax
	je	SHORT $LN12@setHotKeyD
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 706  : }

	ret	12					; 0000000cH

; 705  : 	m_strHotKeyString = szHotKeyString;

$LN12@setHotKeyD:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 706  : }

	ret	12					; 0000000cH
?setHotKeyDescription@CvHotKeyInfo@@QAEXPBD00@Z ENDP	; CvHotKeyInfo::setHotKeyDescription
_TEXT	ENDS
PUBLIC	??1CvHotKeyInfo@@QAE@XZ				; CvHotKeyInfo::~CvHotKeyInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvHotKeyInfo@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??1CvHotKeyInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvHotKeyInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$5
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvHotKeyInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvHotKeyInfo@@QAE@XZ PROC				; CvHotKeyInfo::~CvHotKeyInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvHotKeyInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+432]
	mov	DWORD PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+404]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+376]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+348]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+320]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+292]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 320				; 00000140H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 348				; 0000015cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 376				; 00000178H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvHotKeyInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvHotKeyInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvHotKeyInfo@@QAE@XZ ENDP				; CvHotKeyInfo::~CvHotKeyInfo
PUBLIC	??_7CvSpecialistInfo@@6B@			; CvSpecialistInfo::`vftable'
PUBLIC	??1CvSpecialistInfo@@UAE@XZ			; CvSpecialistInfo::~CvSpecialistInfo
PUBLIC	??_R4CvSpecialistInfo@@6B@			; CvSpecialistInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvSpecialistInfo@@@8			; CvSpecialistInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvSpecialistInfo@@8			; CvSpecialistInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvSpecialistInfo@@8			; CvSpecialistInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvSpecialistInfo@@8		; CvSpecialistInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvHotKeyInfo@@8			; CvHotKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvHotKeyInfo@@@8			; CvHotKeyInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvHotKeyInfo@@8				; CvHotKeyInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvHotKeyInfo@@8				; CvHotKeyInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvSpecialistInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvSpecialistInfo::CacheResults
EXTRN	??_ECvSpecialistInfo@@UAEPAXI@Z:PROC		; CvSpecialistInfo::`vector deleting destructor'
;	COMDAT ??_R2CvHotKeyInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R2CvHotKeyInfo@@8 DD FLAT:??_R1A@?0A@EA@CvHotKeyInfo@@8 ; CvHotKeyInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvHotKeyInfo@@8
rdata$r	SEGMENT
??_R3CvHotKeyInfo@@8 DD 00H				; CvHotKeyInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvHotKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvHotKeyInfo@@@8
_DATA	SEGMENT
??_R0?AVCvHotKeyInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvHotKeyInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvHotKeyInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvHotKeyInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvHotKeyInfo@@8 DD FLAT:??_R0?AVCvHotKeyInfo@@@8 ; CvHotKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvHotKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvSpecialistInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvSpecialistInfo@@8 DD FLAT:??_R0?AVCvSpecialistInfo@@@8 ; CvSpecialistInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvSpecialistInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvSpecialistInfo@@8
rdata$r	SEGMENT
??_R2CvSpecialistInfo@@8 DD FLAT:??_R1A@?0A@EA@CvSpecialistInfo@@8 ; CvSpecialistInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvHotKeyInfo@@8
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvSpecialistInfo@@8
rdata$r	SEGMENT
??_R3CvSpecialistInfo@@8 DD 00H				; CvSpecialistInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvSpecialistInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvSpecialistInfo@@@8
_DATA	SEGMENT
??_R0?AVCvSpecialistInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvSpecialistInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvSpecialistInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvSpecialistInfo@@6B@
rdata$r	SEGMENT
??_R4CvSpecialistInfo@@6B@ DD 00H			; CvSpecialistInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvSpecialistInfo@@@8
	DD	FLAT:??_R3CvSpecialistInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvSpecialistInfo@@6B@
CONST	SEGMENT
??_7CvSpecialistInfo@@6B@ DD FLAT:??_R4CvSpecialistInfo@@6B@ ; CvSpecialistInfo::`vftable'
	DD	FLAT:?CacheResults@CvSpecialistInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvSpecialistInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvSpecialistInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvSpecialistInfo@@UAE@XZ$0
__ehfuncinfo$??1CvSpecialistInfo@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvSpecialistInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??1CvSpecialistInfo@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvSpecialistInfo@@UAE@XZ PROC			; CvSpecialistInfo::~CvSpecialistInfo, COMDAT
; _this$ = ecx

; 725  : {

	push	-1
	push	__ehhandler$??1CvSpecialistInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvSpecialistInfo@@6B@

; 726  : 	SAFE_DELETE_ARRAY(m_piYieldChange);

	mov	eax, DWORD PTR [esi+516]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+516], 0

; 727  : 	SAFE_DELETE_ARRAY(m_piFlavorValue);

	mov	eax, DWORD PTR [esi+520]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 8

; 728  : }

	lea	ecx, DWORD PTR [esi+488]
	mov	DWORD PTR [esi+520], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CvHotKeyInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvSpecialistInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvHotKeyInfo@@QAE@XZ
__ehhandler$??1CvSpecialistInfo@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvSpecialistInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvSpecialistInfo@@UAE@XZ ENDP			; CvSpecialistInfo::~CvSpecialistInfo
PUBLIC	?getTexture@CvSpecialistInfo@@QBEPBDXZ		; CvSpecialistInfo::getTexture
; Function compile flags: /Ogtpy
;	COMDAT ?getTexture@CvSpecialistInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getTexture@CvSpecialistInfo@@QBEPBDXZ PROC		; CvSpecialistInfo::getTexture, COMDAT
; _this$ = ecx

; 791  : 	return m_strTexture;

	add	ecx, 488				; 000001e8H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getTexture@CvSpecialistInfo@@QBEPBDXZ ENDP		; CvSpecialistInfo::getTexture
_TEXT	ENDS
PUBLIC	?setTexture@CvSpecialistInfo@@QAEXPBD@Z		; CvSpecialistInfo::setTexture
; Function compile flags: /Ogtpy
;	COMDAT ?setTexture@CvSpecialistInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setTexture@CvSpecialistInfo@@QAEXPBD@Z PROC		; CvSpecialistInfo::setTexture, COMDAT
; _this$ = ecx

; 796  : 	m_strTexture = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 488				; 000001e8H
	test	eax, eax
	je	SHORT $LN4@setTexture
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setTexture:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 797  : }

	ret	4
?setTexture@CvSpecialistInfo@@QAEXPBD@Z ENDP		; CvSpecialistInfo::setTexture
_TEXT	ENDS
PUBLIC	?getWaypoint@CvMissionInfo@@QBEPBDXZ		; CvMissionInfo::getWaypoint
; Function compile flags: /Ogtpy
;	COMDAT ?getWaypoint@CvMissionInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getWaypoint@CvMissionInfo@@QBEPBDXZ PROC		; CvMissionInfo::getWaypoint, COMDAT
; _this$ = ecx

; 863  : 	return m_strWaypoint;

	add	ecx, 472				; 000001d8H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getWaypoint@CvMissionInfo@@QBEPBDXZ ENDP		; CvMissionInfo::getWaypoint
_TEXT	ENDS
PUBLIC	?getMissionType@CvActionInfo@@QBEHXZ		; CvActionInfo::getMissionType
; Function compile flags: /Ogtpy
;	COMDAT ?getMissionType@CvActionInfo@@QBEHXZ
_TEXT	SEGMENT
?getMissionType@CvActionInfo@@QBEHXZ PROC		; CvActionInfo::getMissionType, COMDAT
; _this$ = ecx

; 1087 : 	if(ACTIONSUBTYPE_BUILD == m_eSubType)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 2
	jne	SHORT $LN7@getMission@2

; 1088 : 	{
; 1089 : 		CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes)m_iOriginalIndex);

	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 1090 : 		if(pkBuildInfo)

	test	eax, eax
	je	SHORT $LN1@getMission@2

; 1091 : 			return pkBuildInfo->getMissionType();

	mov	eax, DWORD PTR [eax+488]

; 1105 : }

	ret	0
$LN7@getMission@2:

; 1092 : 	}
; 1093 : 	else if(ACTIONSUBTYPE_SPECIALIST == m_eSubType)

	cmp	eax, 4
	jne	SHORT $LN4@getMission@2

; 1094 : 	{
; 1095 : 		CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo((SpecialistTypes)m_iOriginalIndex);

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getSpecialistInfo@CvGlobals@@QAEPAVCvSpecialistInfo@@W4SpecialistTypes@@@Z ; CvGlobals::getSpecialistInfo

; 1096 : 		if(pkSpecialistInfo)

	test	eax, eax
	je	SHORT $LN1@getMission@2

; 1097 : 			return pkSpecialistInfo->getMissionType();

	mov	eax, DWORD PTR [eax+476]

; 1105 : }

	ret	0
$LN4@getMission@2:

; 1098 : 	}
; 1099 : 	else if(ACTIONSUBTYPE_MISSION == m_eSubType)

	cmp	eax, 7
	jne	SHORT $LN1@getMission@2

; 1100 : 	{
; 1101 : 		return m_iOriginalIndex;

	mov	eax, DWORD PTR [ecx]

; 1105 : }

	ret	0
$LN1@getMission@2:

; 1102 : 	}
; 1103 : 
; 1104 : 	return NO_MISSION;

	or	eax, -1

; 1105 : }

	ret	0
?getMissionType@CvActionInfo@@QBEHXZ ENDP		; CvActionInfo::getMissionType
_TEXT	ENDS
PUBLIC	?isVisible@CvActionInfo@@QBE_NXZ		; CvActionInfo::isVisible
; Function compile flags: /Ogtpy
;	COMDAT ?isVisible@CvActionInfo@@QBE_NXZ
_TEXT	SEGMENT
?isVisible@CvActionInfo@@QBE_NXZ PROC			; CvActionInfo::isVisible, COMDAT
; _this$ = ecx

; 1176 : 	if(ACTIONSUBTYPE_CONTROL == m_eSubType)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 5
	jne	SHORT $LN13@isVisible

; 1177 : 	{
; 1178 : 		return false;

	xor	al, al

; 1214 : }

	ret	0
$LN13@isVisible:

; 1179 : 	}
; 1180 : 	else if(ACTIONSUBTYPE_COMMAND == m_eSubType)

	cmp	eax, 1
	jne	SHORT $LN11@isVisible

; 1181 : 	{
; 1182 : 		CvCommandInfo* pkCommandInfo = GC.getCommandInfo((CommandTypes)m_iOriginalIndex);

	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCommandInfo@CvGlobals@@QAEPAVCvCommandInfo@@W4CommandTypes@@@Z ; CvGlobals::getCommandInfo

; 1183 : 		if(pkCommandInfo)

	test	eax, eax
	je	SHORT $LN1@isVisible

; 1184 : 		{
; 1185 : 			return pkCommandInfo->getVisible();

	mov	al, BYTE PTR [eax+465]

; 1214 : }

	ret	0
$LN11@isVisible:

; 1186 : 		}
; 1187 : 	}
; 1188 : 	else if(ACTIONSUBTYPE_AUTOMATE == m_eSubType)

	cmp	eax, 6
	jne	SHORT $LN8@isVisible

; 1189 : 	{
; 1190 : 		CvAutomateInfo* pkAutomateInfo = GC.getAutomateInfo((AutomateTypes)m_iOriginalIndex);

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAutomateInfo@CvGlobals@@QAEPAVCvAutomateInfo@@H@Z ; CvGlobals::getAutomateInfo

; 1191 : 		if(pkAutomateInfo)

	test	eax, eax
	je	SHORT $LN1@isVisible

; 1192 : 		{
; 1193 : 			return pkAutomateInfo->getVisible();

	mov	al, BYTE PTR [eax+469]

; 1214 : }

	ret	0
$LN8@isVisible:

; 1194 : 		}
; 1195 : 	}
; 1196 : 	else if(ACTIONSUBTYPE_MISSION == m_eSubType)

	cmp	eax, 7
	jne	SHORT $LN5@isVisible

; 1197 : 	{
; 1198 : 		CvMissionInfo* pkMissionInfo = GC.getMissionInfo((MissionTypes)m_iOriginalIndex);

	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMissionInfo@CvGlobals@@QAEPAVCvMissionInfo@@W4MissionTypes@@@Z ; CvGlobals::getMissionInfo

; 1199 : 		if(pkMissionInfo)

	test	eax, eax
	je	SHORT $LN1@isVisible

; 1200 : 		{
; 1201 : 			return pkMissionInfo->getVisible();

	mov	al, BYTE PTR [eax+467]

; 1214 : }

	ret	0
$LN5@isVisible:

; 1202 : 		}
; 1203 : 	}
; 1204 : 	else if(ACTIONSUBTYPE_INTERFACEMODE== m_eSubType)

	test	eax, eax
	jne	SHORT $LN1@isVisible

; 1205 : 	{
; 1206 : 		CvInterfaceModeInfo* pkInterfaceModeInfo = GC.getInterfaceModeInfo((InterfaceModeTypes)m_iOriginalIndex);

	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInterfaceModeInfo@CvGlobals@@QAEPAVCvInterfaceModeInfo@@W4InterfaceModeTypes@@@Z ; CvGlobals::getInterfaceModeInfo

; 1207 : 		if(pkInterfaceModeInfo)

	test	eax, eax
	je	SHORT $LN1@isVisible

; 1208 : 		{
; 1209 : 			return pkInterfaceModeInfo->getVisible();

	mov	al, BYTE PTR [eax+468]

; 1214 : }

	ret	0
$LN1@isVisible:

; 1210 : 		}
; 1211 : 	}
; 1212 : 
; 1213 : 	return true;

	mov	al, 1

; 1214 : }

	ret	0
?isVisible@CvActionInfo@@QBE_NXZ ENDP			; CvActionInfo::isVisible
_TEXT	ENDS
PUBLIC	?GetType@CvActionInfo@@QBEPBDXZ			; CvActionInfo::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CvActionInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvActionInfo@@QBEPBDXZ PROC			; CvActionInfo::GetType, COMDAT
; _this$ = ecx

; 1309 : {

	push	esi
	mov	esi, ecx

; 1310 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@GetType

; 1311 : 	{
; 1312 : 		return getHotkeyInfo()->GetType();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	lea	ecx, DWORD PTR [eax+176]
	pop	esi
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LN1@GetType:

; 1313 : 	}
; 1314 : 
; 1315 : 	return NULL;

	xor	eax, eax
	pop	esi

; 1316 : }

	ret	0
?GetType@CvActionInfo@@QBEPBDXZ ENDP			; CvActionInfo::GetType
_TEXT	ENDS
PUBLIC	?GetDescription@CvActionInfo@@QBEPBDXZ		; CvActionInfo::GetDescription
; Function compile flags: /Ogtpy
;	COMDAT ?GetDescription@CvActionInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescription@CvActionInfo@@QBEPBDXZ PROC		; CvActionInfo::GetDescription, COMDAT
; _this$ = ecx

; 1319 : {

	push	esi
	mov	esi, ecx

; 1320 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@GetDescrip

; 1321 : 	{
; 1322 : 		return getHotkeyInfo()->GetDescription();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	lea	ecx, DWORD PTR [eax+36]
	pop	esi
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LN1@GetDescrip:

; 1323 : 	}
; 1324 : 
; 1325 : 	return "";

	mov	eax, OFFSET $SG219555
	pop	esi

; 1326 : }

	ret	0
?GetDescription@CvActionInfo@@QBEPBDXZ ENDP		; CvActionInfo::GetDescription
_TEXT	ENDS
PUBLIC	?GetCivilopedia@CvActionInfo@@QBEPBDXZ		; CvActionInfo::GetCivilopedia
; Function compile flags: /Ogtpy
;	COMDAT ?GetCivilopedia@CvActionInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetCivilopedia@CvActionInfo@@QBEPBDXZ PROC		; CvActionInfo::GetCivilopedia, COMDAT
; _this$ = ecx

; 1329 : {

	push	esi
	mov	esi, ecx

; 1330 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@GetCivilop

; 1331 : 	{
; 1332 : 		return getHotkeyInfo()->GetCivilopedia();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	lea	ecx, DWORD PTR [eax+8]
	pop	esi
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LN1@GetCivilop:

; 1333 : 	}
; 1334 : 
; 1335 : 	return "";

	mov	eax, OFFSET $SG219560
	pop	esi

; 1336 : }

	ret	0
?GetCivilopedia@CvActionInfo@@QBEPBDXZ ENDP		; CvActionInfo::GetCivilopedia
_TEXT	ENDS
PUBLIC	?GetStrategy@CvActionInfo@@QBEPBDXZ		; CvActionInfo::GetStrategy
; Function compile flags: /Ogtpy
;	COMDAT ?GetStrategy@CvActionInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetStrategy@CvActionInfo@@QBEPBDXZ PROC		; CvActionInfo::GetStrategy, COMDAT
; _this$ = ecx

; 1359 : {

	push	esi
	mov	esi, ecx

; 1360 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@GetStrateg

; 1361 : 	{
; 1362 : 		return getHotkeyInfo()->GetStrategy();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	lea	ecx, DWORD PTR [eax+148]
	pop	esi
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LN1@GetStrateg:

; 1363 : 	}
; 1364 : 
; 1365 : 	return "";

	mov	eax, OFFSET $SG219575
	pop	esi

; 1366 : }

	ret	0
?GetStrategy@CvActionInfo@@QBEPBDXZ ENDP		; CvActionInfo::GetStrategy
_TEXT	ENDS
PUBLIC	?getHotKey@CvActionInfo@@QBEPBDXZ		; CvActionInfo::getHotKey
; Function compile flags: /Ogtpy
;	COMDAT ?getHotKey@CvActionInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getHotKey@CvActionInfo@@QBEPBDXZ PROC			; CvActionInfo::getHotKey, COMDAT
; _this$ = ecx

; 1499 : {

	push	esi
	mov	esi, ecx

; 1500 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	test	eax, eax
	je	SHORT $LN1@getHotKey

; 1501 : 	{
; 1502 : 		return getHotkeyInfo()->getHotKey();

	mov	ecx, esi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	lea	ecx, DWORD PTR [eax+292]
	pop	esi
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LN1@getHotKey:

; 1503 : 	}
; 1504 : 
; 1505 : 	return NULL;

	xor	eax, eax
	pop	esi

; 1506 : }

	ret	0
?getHotKey@CvActionInfo@@QBEPBDXZ ENDP			; CvActionInfo::getHotKey
_TEXT	ENDS
PUBLIC	?getHotKeyDescription@CvActionInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CvActionInfo::getHotKeyDescription
; Function compile flags: /Ogtpy
;	COMDAT ?getHotKeyDescription@CvActionInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T232541 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getHotKeyDescription@CvActionInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; CvActionInfo::getHotKeyDescription, COMDAT
; _this$ = ecx

; 1509 : {

	push	ecx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR $T232541[esp+12], 0

; 1510 : 	if(getHotkeyInfo())

	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo

; 1511 : 	{
; 1512 : 		return getHotkeyInfo()->getHotKeyDescription();

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	test	eax, eax
	je	SHORT $LN1@getHotKeyD@2
	push	esi
	mov	ecx, edi
	call	?getHotkeyInfo@CvActionInfo@@ABEPAVCvHotKeyInfo@@XZ ; CvActionInfo::getHotkeyInfo
	mov	ecx, eax
	call	?getHotKeyDescription@CvHotKeyInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CvHotKeyInfo::getHotKeyDescription
	pop	edi

; 1513 : 	}
; 1514 : 
; 1515 : 	return "";

	mov	eax, esi
	pop	esi

; 1516 : }

	pop	ecx
	ret	4
$LN1@getHotKeyD@2:

; 1513 : 	}
; 1514 : 
; 1515 : 	return "";

	push	OFFSET $SG219638
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	pop	edi
	mov	eax, esi
	pop	esi

; 1516 : }

	pop	ecx
	ret	4
?getHotKeyDescription@CvActionInfo@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; CvActionInfo::getHotKeyDescription
_TEXT	ENDS
PUBLIC	?getFormationName@CvMultiUnitFormationInfo@@QBEPBDXZ ; CvMultiUnitFormationInfo::getFormationName
; Function compile flags: /Ogtpy
;	COMDAT ?getFormationName@CvMultiUnitFormationInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getFormationName@CvMultiUnitFormationInfo@@QBEPBDXZ PROC ; CvMultiUnitFormationInfo::getFormationName, COMDAT
; _this$ = ecx

; 1533 : 	return m_strFormationName;

	add	ecx, 260				; 00000104H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getFormationName@CvMultiUnitFormationInfo@@QBEPBDXZ ENDP ; CvMultiUnitFormationInfo::getFormationName
_TEXT	ENDS
PUBLIC	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
; Function compile flags: /Ogtpy
;	COMDAT ?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ
_TEXT	SEGMENT
?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ PROC ; CvMultiUnitFormationInfo::getNumFormationSlotEntries, COMDAT
; _this$ = ecx

; 1538 : 	return m_vctSlotEntries.size();

	mov	eax, DWORD PTR [ecx+296]
	sub	eax, DWORD PTR [ecx+292]
	sar	eax, 4

; 1539 : }

	ret	0
?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ ENDP ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
_TEXT	ENDS
PUBLIC	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry
; Function compile flags: /Ogtpy
;	COMDAT ?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z PROC ; CvMultiUnitFormationInfo::getFormationSlotEntry, COMDAT
; _this$ = ecx

; 1548 : 	return m_vctSlotEntries[index];

	mov	eax, DWORD PTR _index$[esp-4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx+292]

; 1549 : }

	ret	4
?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ENDP ; CvMultiUnitFormationInfo::getFormationSlotEntry
_TEXT	ENDS
PUBLIC	??_7CvSpecialUnitInfo@@6B@			; CvSpecialUnitInfo::`vftable'
PUBLIC	??0CvSpecialUnitInfo@@QAE@XZ			; CvSpecialUnitInfo::CvSpecialUnitInfo
PUBLIC	??_R4CvSpecialUnitInfo@@6B@			; CvSpecialUnitInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvSpecialUnitInfo@@@8			; CvSpecialUnitInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvSpecialUnitInfo@@8			; CvSpecialUnitInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvSpecialUnitInfo@@8			; CvSpecialUnitInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvSpecialUnitInfo@@8		; CvSpecialUnitInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvSpecialUnitInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvSpecialUnitInfo::CacheResults
EXTRN	??_ECvSpecialUnitInfo@@UAEPAXI@Z:PROC		; CvSpecialUnitInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvSpecialUnitInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvSpecialUnitInfo@@8 DD FLAT:??_R0?AVCvSpecialUnitInfo@@@8 ; CvSpecialUnitInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvSpecialUnitInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvSpecialUnitInfo@@8
rdata$r	SEGMENT
??_R2CvSpecialUnitInfo@@8 DD FLAT:??_R1A@?0A@EA@CvSpecialUnitInfo@@8 ; CvSpecialUnitInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvSpecialUnitInfo@@8
rdata$r	SEGMENT
??_R3CvSpecialUnitInfo@@8 DD 00H			; CvSpecialUnitInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvSpecialUnitInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvSpecialUnitInfo@@@8
_DATA	SEGMENT
??_R0?AVCvSpecialUnitInfo@@@8 DD FLAT:??_7type_info@@6B@ ; CvSpecialUnitInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvSpecialUnitInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvSpecialUnitInfo@@6B@
rdata$r	SEGMENT
??_R4CvSpecialUnitInfo@@6B@ DD 00H			; CvSpecialUnitInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvSpecialUnitInfo@@@8
	DD	FLAT:??_R3CvSpecialUnitInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvSpecialUnitInfo@@6B@
CONST	SEGMENT
??_7CvSpecialUnitInfo@@6B@ DD FLAT:??_R4CvSpecialUnitInfo@@6B@ ; CvSpecialUnitInfo::`vftable'
	DD	FLAT:?CacheResults@CvSpecialUnitInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvSpecialUnitInfo@@UAEPAXI@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvSpecialUnitInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvSpecialUnitInfo@@QAE@XZ PROC			; CvSpecialUnitInfo::CvSpecialUnitInfo, COMDAT
; _this$ = ecx

; 1604 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	mov	BYTE PTR [esi+260], al
	mov	BYTE PTR [esi+261], al
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvSpecialUnitInfo@@6B@

; 1605 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvSpecialUnitInfo@@QAE@XZ ENDP			; CvSpecialUnitInfo::CvSpecialUnitInfo
_TEXT	ENDS
PUBLIC	??1CvSpecialUnitInfo@@UAE@XZ			; CvSpecialUnitInfo::~CvSpecialUnitInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvSpecialUnitInfo@@UAE@XZ
_TEXT	SEGMENT
??1CvSpecialUnitInfo@@UAE@XZ PROC			; CvSpecialUnitInfo::~CvSpecialUnitInfo, COMDAT
; _this$ = ecx

; 1608 : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvSpecialUnitInfo@@6B@

; 1609 : 	SAFE_DELETE_ARRAY(m_pbCarrierUnitAITypes);

	mov	eax, DWORD PTR [esi+264]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+264], 0

; 1610 : 	SAFE_DELETE_ARRAY(m_piProductionTraits);

	mov	ecx, DWORD PTR [esi+268]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 8
	mov	DWORD PTR [esi+268], 0

; 1611 : }

	mov	ecx, esi
	pop	esi
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvSpecialUnitInfo@@UAE@XZ ENDP			; CvSpecialUnitInfo::~CvSpecialUnitInfo
_TEXT	ENDS
EXTRN	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z:PROC ; CvDatabaseUtility::PopulateArrayByValue
EXTRN	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z:PROC ; CvDatabaseUtility::PopulateArrayByExistence
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvSpecialUnitInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvSpecialUnitInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvSpecialUnitInfo::CacheResults, COMDAT
; _this$ = ecx

; 1638 : {

	push	ebx

; 1639 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	ebx, DWORD PTR _kUtility$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+8]
	push	ebx
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@2
	pop	edi
	pop	esi
	pop	ebx

; 1650 : }

	ret	8
$LN1@CacheResul@2:
	push	ebp

; 1640 : 		return false;
; 1641 : 
; 1642 : 	m_bValid = kResults.GetBool("Valid");

	mov	ebp, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG219717
	mov	ecx, edi
	call	ebp

; 1643 : 	m_bCityLoad = kResults.GetBool("CityLoad");

	push	OFFSET $SG219718
	mov	ecx, edi
	mov	BYTE PTR [esi+260], al
	call	ebp

; 1644 : 
; 1645 : 	const char* szSpecialUnitType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR [esi+261], al
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edi, eax

; 1646 : 	kUtility.PopulateArrayByExistence(m_pbCarrierUnitAITypes, "UnitAIInfos", "SpecialUnit_CarrierUnitAI", "UnitAIType", "SpecialUnitType", szSpecialUnitType);

	push	edi
	push	OFFSET $SG219720
	push	OFFSET $SG219721
	push	OFFSET $SG219722
	push	OFFSET $SG219723
	lea	eax, DWORD PTR [esi+264]
	push	eax
	mov	ecx, ebx
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 1647 : 	kUtility.PopulateArrayByValue(m_piProductionTraits, "Traits", "SpecialUnit_ProductionTraits", "TraitType", "SpecialUnitType", szSpecialUnitType, "Trait");

	push	0
	push	0
	push	OFFSET $SG219724
	push	edi
	push	OFFSET $SG219725
	push	OFFSET $SG219726
	push	OFFSET $SG219727
	push	OFFSET $SG219728
	add	esi, 268				; 0000010cH
	push	esi
	mov	ecx, ebx
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue
	pop	ebp
	pop	edi
	pop	esi

; 1648 : 
; 1649 : 	return true;

	mov	al, 1
	pop	ebx

; 1650 : }

	ret	8
?CacheResults@CvSpecialUnitInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvSpecialUnitInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvUnitClassInfo@@6B@			; CvUnitClassInfo::`vftable'
PUBLIC	??0CvUnitClassInfo@@QAE@XZ			; CvUnitClassInfo::CvUnitClassInfo
PUBLIC	??_R4CvUnitClassInfo@@6B@			; CvUnitClassInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvUnitClassInfo@@@8			; CvUnitClassInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvUnitClassInfo@@8				; CvUnitClassInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvUnitClassInfo@@8				; CvUnitClassInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvUnitClassInfo@@8		; CvUnitClassInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvUnitClassInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvUnitClassInfo::CacheResults
;	COMDAT ??_R1A@?0A@EA@CvUnitClassInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvUnitClassInfo@@8 DD FLAT:??_R0?AVCvUnitClassInfo@@@8 ; CvUnitClassInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvUnitClassInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvUnitClassInfo@@8
rdata$r	SEGMENT
??_R2CvUnitClassInfo@@8 DD FLAT:??_R1A@?0A@EA@CvUnitClassInfo@@8 ; CvUnitClassInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvUnitClassInfo@@8
rdata$r	SEGMENT
??_R3CvUnitClassInfo@@8 DD 00H				; CvUnitClassInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvUnitClassInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvUnitClassInfo@@@8
_DATA	SEGMENT
??_R0?AVCvUnitClassInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvUnitClassInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvUnitClassInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvUnitClassInfo@@6B@
rdata$r	SEGMENT
??_R4CvUnitClassInfo@@6B@ DD 00H			; CvUnitClassInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvUnitClassInfo@@@8
	DD	FLAT:??_R3CvUnitClassInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvUnitClassInfo@@6B@
CONST	SEGMENT
??_7CvUnitClassInfo@@6B@ DD FLAT:??_R4CvUnitClassInfo@@6B@ ; CvUnitClassInfo::`vftable'
	DD	FLAT:?CacheResults@CvUnitClassInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvUnitClassInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvUnitClassInfo@@QAE@XZ PROC				; CvUnitClassInfo::CvUnitClassInfo, COMDAT
; _this$ = ecx

; 1661 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi+272], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvUnitClassInfo@@6B@
	mov	DWORD PTR [esi+276], -1

; 1662 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvUnitClassInfo@@QAE@XZ ENDP				; CvUnitClassInfo::CvUnitClassInfo
_TEXT	ENDS
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvUnitClassInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvUnitClassInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvUnitClassInfo::CacheResults, COMDAT
; _this$ = ecx

; 1696 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@3
	pop	edi
	pop	esi

; 1707 : }

	ret	8
$LN1@CacheResul@3:
	push	ebx

; 1697 : 		return false;
; 1698 : 
; 1699 : 	m_iMaxGlobalInstances = kResults.GetInt("MaxGlobalInstances");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG219757
	mov	ecx, edi
	call	ebx

; 1700 : 	m_iMaxTeamInstances = kResults.GetInt("MaxTeamInstances");

	push	OFFSET $SG219758
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 1701 : 	m_iMaxPlayerInstances = kResults.GetInt("MaxPlayerInstances");

	push	OFFSET $SG219759
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 1702 : 	m_iInstanceCostModifier = kResults.GetInt("InstanceCostModifier");

	push	OFFSET $SG219760
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 1703 : 
; 1704 : 	m_iDefaultUnitIndex = GC.getInfoTypeForString(kResults.GetText("DefaultUnit"), true);

	push	1
	push	OFFSET $SG219761
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	pop	ebx
	mov	DWORD PTR [esi+276], eax
	pop	edi

; 1705 : 
; 1706 : 	return true;

	mov	al, 1
	pop	esi

; 1707 : }

	ret	8
?CacheResults@CvUnitClassInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvUnitClassInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvBuildingClassInfo@@6B@			; CvBuildingClassInfo::`vftable'
PUBLIC	??0CvBuildingClassInfo@@QAE@XZ			; CvBuildingClassInfo::CvBuildingClassInfo
PUBLIC	??_R4CvBuildingClassInfo@@6B@			; CvBuildingClassInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvBuildingClassInfo@@@8			; CvBuildingClassInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBuildingClassInfo@@8			; CvBuildingClassInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBuildingClassInfo@@8			; CvBuildingClassInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvBuildingClassInfo@@8		; CvBuildingClassInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvBuildingClassInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBuildingClassInfo::CacheResults
EXTRN	??_ECvBuildingClassInfo@@UAEPAXI@Z:PROC		; CvBuildingClassInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvBuildingClassInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBuildingClassInfo@@8 DD FLAT:??_R0?AVCvBuildingClassInfo@@@8 ; CvBuildingClassInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBuildingClassInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvBuildingClassInfo@@8
rdata$r	SEGMENT
??_R2CvBuildingClassInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBuildingClassInfo@@8 ; CvBuildingClassInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvBuildingClassInfo@@8
rdata$r	SEGMENT
??_R3CvBuildingClassInfo@@8 DD 00H			; CvBuildingClassInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvBuildingClassInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBuildingClassInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBuildingClassInfo@@@8 DD FLAT:??_7type_info@@6B@ ; CvBuildingClassInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBuildingClassInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvBuildingClassInfo@@6B@
rdata$r	SEGMENT
??_R4CvBuildingClassInfo@@6B@ DD 00H			; CvBuildingClassInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvBuildingClassInfo@@@8
	DD	FLAT:??_R3CvBuildingClassInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvBuildingClassInfo@@6B@
CONST	SEGMENT
??_7CvBuildingClassInfo@@6B@ DD FLAT:??_R4CvBuildingClassInfo@@6B@ ; CvBuildingClassInfo::`vftable'
	DD	FLAT:?CacheResults@CvBuildingClassInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvBuildingClassInfo@@UAEPAXI@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvBuildingClassInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvBuildingClassInfo@@QAE@XZ PROC			; CvBuildingClassInfo::CvBuildingClassInfo, COMDAT
; _this$ = ecx

; 1721 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi+272], eax
	mov	BYTE PTR [esi+280], al
	mov	BYTE PTR [esi+281], al
	mov	DWORD PTR [esi+284], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvBuildingClassInfo@@6B@
	mov	DWORD PTR [esi+276], -1

; 1722 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvBuildingClassInfo@@QAE@XZ ENDP			; CvBuildingClassInfo::CvBuildingClassInfo
_TEXT	ENDS
PUBLIC	??1CvBuildingClassInfo@@UAE@XZ			; CvBuildingClassInfo::~CvBuildingClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvBuildingClassInfo@@UAE@XZ
_TEXT	SEGMENT
??1CvBuildingClassInfo@@UAE@XZ PROC			; CvBuildingClassInfo::~CvBuildingClassInfo, COMDAT
; _this$ = ecx

; 1725 : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvBuildingClassInfo@@6B@

; 1726 : 	SAFE_DELETE_ARRAY(m_piVictoryThreshold);

	mov	eax, DWORD PTR [esi+284]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+284], 0

; 1727 : }

	mov	ecx, esi
	pop	esi
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvBuildingClassInfo@@UAE@XZ ENDP			; CvBuildingClassInfo::~CvBuildingClassInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvBuildingClassInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvBuildingClassInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvBuildingClassInfo::CacheResults, COMDAT
; _this$ = ecx

; 1777 : {

	push	ebp

; 1778 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	ebp, DWORD PTR _kUtility$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+8]
	push	ebp
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@4
	pop	edi
	pop	esi
	pop	ebp

; 1798 : }

	ret	8
$LN1@CacheResul@4:
	push	ebx

; 1779 : 		return false;
; 1780 : 
; 1781 : 	//Basic Properties
; 1782 : 	m_iMaxGlobalInstances = kResults.GetInt("MaxGlobalInstances");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG219807
	mov	ecx, edi
	call	ebx

; 1783 : 	m_iMaxTeamInstances = kResults.GetInt("MaxTeamInstances");

	push	OFFSET $SG219808
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 1784 : 	m_iMaxPlayerInstances = kResults.GetInt("MaxPlayerInstances");

	push	OFFSET $SG219809
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 1785 : 	m_iExtraPlayerInstances = kResults.GetInt("ExtraPlayerInstances");

	push	OFFSET $SG219810
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 1786 : 
; 1787 : 	m_bNoLimit = kResults.GetBool("NoLimit");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG219811
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebx

; 1788 : 	m_bMonument = kResults.GetBool("Monument");

	push	OFFSET $SG219812
	mov	ecx, edi
	mov	BYTE PTR [esi+280], al
	call	ebx

; 1789 : 
; 1790 : 	//References
; 1791 : 	const char* szDefaultBuilding = kResults.GetText("DefaultBuilding");

	push	OFFSET $SG219814
	mov	ecx, edi
	mov	BYTE PTR [esi+281], al
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 1792 : 	m_iDefaultBuildingIndex = GC.getInfoTypeForString(szDefaultBuilding, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1793 : 
; 1794 : 	//Arrays
; 1795 : 	kUtility.PopulateArrayByValue(m_piVictoryThreshold, "Victories", "BuildingClass_VictoryThresholds", "VictoryType", "BuildingClassType", GetType(), "Threshold");

	push	0
	push	0
	push	OFFSET $SG219815
	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+276], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG219816
	push	OFFSET $SG219817
	push	OFFSET $SG219818
	push	OFFSET $SG219819
	add	esi, 284				; 0000011cH
	push	esi
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue
	pop	ebx
	pop	edi
	pop	esi

; 1796 : 
; 1797 : 	return true;

	mov	al, 1
	pop	ebp

; 1798 : }

	ret	8
?CacheResults@CvBuildingClassInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvBuildingClassInfo::CacheResults
_TEXT	ENDS
PUBLIC	?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingClassArrayHelpers::Read
EXTRN	?LogMessage@CvGlobals@@QAEXPBD@Z:PROC		; CvGlobals::LogMessage
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z$0
__ehfuncinfo$?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z
_TEXT	SEGMENT
_bValid$219830 = -49					; size = 1
_iNumEntries$ = -48					; size = 4
_iDummy$219837 = -44					; size = 4
_szError$219835 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
_paiArray$ = 12						; size = 4
?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z PROC ; BuildingClassArrayHelpers::Read, COMDAT

; 1802 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebp
	push	esi

; 1803 : 	int iNumEntries;
; 1804 : 	int iType;
; 1805 : 
; 1806 : 	kStream >> iNumEntries;

	mov	esi, DWORD PTR _kStream$[esp+56]
	lea	eax, DWORD PTR _iNumEntries$[esp+60]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1807 : 
; 1808 : 	for(int iI = 0; iI < iNumEntries; iI++)

	xor	ebp, ebp
	cmp	DWORD PTR _iNumEntries$[esp+60], ebp
	jle	SHORT $LN5@Read
$LL7@Read:

; 1809 : 	{
; 1810 : 		bool bValid = true;
; 1811 : 		iType = CvInfosSerializationHelper::ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$219830[esp+60]
	push	ecx
	push	esi
	mov	BYTE PTR _bValid$219830[esp+68], 1
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8

; 1812 : 		if(iType != -1 || !bValid)

	cmp	eax, -1
	jne	SHORT $LN27@Read
	cmp	BYTE PTR _bValid$219830[esp+60], 0
	jne	SHORT $LN6@Read

; 1819 : 			{
; 1820 : 				CvString szError;

	lea	ecx, DWORD PTR _szError$219835[esp+60]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1821 : 				szError.Format("LOAD ERROR: Building Class Type not found");

	lea	ecx, DWORD PTR _szError$219835[esp+60]
	push	OFFSET $SG219836
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+76], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 1822 : 				GC.LogMessage(szError.GetCString());

	lea	ecx, DWORD PTR _szError$219835[esp+60]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage

; 1823 : 				CvAssertMsg(false, szError);
; 1824 : 				int iDummy;
; 1825 : 				kStream >> iDummy;	// Skip it.

	lea	edx, DWORD PTR _iDummy$219837[esp+60]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1826 : 			}

	lea	ecx, DWORD PTR _szError$219835[esp+60]
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@Read:
	inc	ebp
	cmp	ebp, DWORD PTR _iNumEntries$[esp+60]
	jl	SHORT $LL7@Read
$LN5@Read:

; 1827 : 		}
; 1828 : 	}
; 1829 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	0
$LN27@Read:

; 1813 : 		{
; 1814 : 			if(iType != -1)
; 1815 : 			{
; 1816 : 				kStream >> paiArray[iType];

	mov	edx, DWORD PTR _paiArray$[esp+56]
	lea	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1817 : 			}
; 1818 : 			else

	jmp	SHORT $LN6@Read
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z$0:
	lea	ecx, DWORD PTR _szError$219835[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z:
	mov	eax, OFFSET __ehfuncinfo$?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Read@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z ENDP ; BuildingClassArrayHelpers::Read
PUBLIC	?Write@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingClassArrayHelpers::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z:PROC ; CvGlobals::getBuildingClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?Write@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
$T232657 = -4						; size = 4
_kStream$ = 8						; size = 4
_paiArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
?Write@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z PROC ; BuildingClassArrayHelpers::Write, COMDAT

; 1833 : {

	push	ecx
	push	esi
	push	edi

; 1834 : 	kStream << iArraySize;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	eax, DWORD PTR _iArraySize$[esp+8]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1835 : 
; 1836 : 	for(int iI = 0; iI < iArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _iArraySize$[esp+8], esi
	jle	SHORT $LN3@Write
	push	ebx
	mov	ebx, DWORD PTR _paiArray$[esp+12]
$LL5@Write:

; 1837 : 	{
; 1838 : 		const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
; 1839 : 		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 1840 : 		if(pkBuildingClassInfo)

	test	eax, eax
	je	SHORT $LN2@Write

; 1841 : 		{
; 1842 : 			CvInfosSerializationHelper::WriteHashed(kStream, pkBuildingClassInfo);

	push	eax
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 1843 : 			kStream << paiArray[iI];

	push	ebx

; 1844 : 		}
; 1845 : 		else

	jmp	SHORT $LN16@Write
$LN2@Write:

; 1846 : 		{
; 1847 : 			kStream << (int)0;

	lea	ecx, DWORD PTR $T232657[esp+16]
	mov	DWORD PTR $T232657[esp+16], 0
	push	ecx
$LN16@Write:
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	esi
	add	ebx, 4
	cmp	esi, DWORD PTR _iArraySize$[esp+12]
	jl	SHORT $LL5@Write
	pop	ebx
$LN3@Write:
	pop	edi
	pop	esi

; 1848 : 		}
; 1849 : 	}
; 1850 : }

	pop	ecx
	ret	0
?Write@BuildingClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ENDP ; BuildingClassArrayHelpers::Write
_TEXT	ENDS
PUBLIC	?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; UnitClassArrayHelpers::Read
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z$0
__ehfuncinfo$?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z
_TEXT	SEGMENT
_bValid$219864 = -49					; size = 1
_iNumEntries$ = -48					; size = 4
_iDummy$219871 = -44					; size = 4
_szError$219869 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
_paiArray$ = 12						; size = 4
?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z PROC ; UnitClassArrayHelpers::Read, COMDAT

; 1854 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebp
	push	esi

; 1855 : 	int iNumEntries;
; 1856 : 	int iType;
; 1857 : 
; 1858 : 	kStream >> iNumEntries;

	mov	esi, DWORD PTR _kStream$[esp+56]
	lea	eax, DWORD PTR _iNumEntries$[esp+60]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1859 : 
; 1860 : 	for(int iI = 0; iI < iNumEntries; iI++)

	xor	ebp, ebp
	cmp	DWORD PTR _iNumEntries$[esp+60], ebp
	jle	SHORT $LN5@Read@2
$LL7@Read@2:

; 1861 : 	{
; 1862 : 		bool bValid = true;
; 1863 : 		iType = CvInfosSerializationHelper::ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$219864[esp+60]
	push	ecx
	push	esi
	mov	BYTE PTR _bValid$219864[esp+68], 1
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8

; 1864 : 		if(iType != -1 || !bValid)

	cmp	eax, -1
	jne	SHORT $LN27@Read@2
	cmp	BYTE PTR _bValid$219864[esp+60], 0
	jne	SHORT $LN6@Read@2

; 1871 : 			{
; 1872 : 				CvString szError;

	lea	ecx, DWORD PTR _szError$219869[esp+60]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1873 : 				szError.Format("LOAD ERROR: Unit Class Type not found");

	lea	ecx, DWORD PTR _szError$219869[esp+60]
	push	OFFSET $SG219870
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+76], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 1874 : 				GC.LogMessage(szError.GetCString());

	lea	ecx, DWORD PTR _szError$219869[esp+60]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage

; 1875 : 				CvAssertMsg(false, szError);
; 1876 : 
; 1877 : 				int iDummy;
; 1878 : 				kStream >> iDummy;

	lea	edx, DWORD PTR _iDummy$219871[esp+60]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1879 : 			}

	lea	ecx, DWORD PTR _szError$219869[esp+60]
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@Read@2:
	inc	ebp
	cmp	ebp, DWORD PTR _iNumEntries$[esp+60]
	jl	SHORT $LL7@Read@2
$LN5@Read@2:

; 1880 : 		}
; 1881 : 	}
; 1882 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	0
$LN27@Read@2:

; 1865 : 		{
; 1866 : 			if(iType != -1)
; 1867 : 			{
; 1868 : 				kStream >> paiArray[iType];

	mov	edx, DWORD PTR _paiArray$[esp+56]
	lea	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1869 : 			}
; 1870 : 			else

	jmp	SHORT $LN6@Read@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z$0:
	lea	ecx, DWORD PTR _szError$219869[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z:
	mov	eax, OFFSET __ehfuncinfo$?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Read@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAH@Z ENDP ; UnitClassArrayHelpers::Read
PUBLIC	?Write@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; UnitClassArrayHelpers::Write
EXTRN	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z:PROC ; CvGlobals::getUnitClassInfo
; Function compile flags: /Ogtpy
;	COMDAT ?Write@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
$T232706 = -4						; size = 4
_kStream$ = 8						; size = 4
_paiArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
?Write@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z PROC ; UnitClassArrayHelpers::Write, COMDAT

; 1886 : {

	push	ecx
	push	esi
	push	edi

; 1887 : 	kStream << iArraySize;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	eax, DWORD PTR _iArraySize$[esp+8]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1888 : 
; 1889 : 	for(int iI = 0; iI < iArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _iArraySize$[esp+8], esi
	jle	SHORT $LN3@Write@2
	push	ebx
	mov	ebx, DWORD PTR _paiArray$[esp+12]
$LL5@Write@2:

; 1890 : 	{
; 1891 : 		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
; 1892 : 		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo

; 1893 : 		if(pkUnitClassInfo)

	test	eax, eax
	je	SHORT $LN2@Write@2

; 1894 : 		{
; 1895 : 			CvInfosSerializationHelper::WriteHashed(kStream, pkUnitClassInfo);

	push	eax
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 1896 : 			kStream << paiArray[iI];

	push	ebx

; 1897 : 		}
; 1898 : 		else

	jmp	SHORT $LN16@Write@2
$LN2@Write@2:

; 1899 : 		{			
; 1900 : 			kStream << (int)0;

	lea	ecx, DWORD PTR $T232706[esp+16]
	mov	DWORD PTR $T232706[esp+16], 0
	push	ecx
$LN16@Write@2:
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	esi
	add	ebx, 4
	cmp	esi, DWORD PTR _iArraySize$[esp+12]
	jl	SHORT $LL5@Write@2
	pop	ebx
$LN3@Write@2:
	pop	edi
	pop	esi

; 1901 : 		}
; 1902 : 	}
; 1903 : }

	pop	ecx
	ret	0
?Write@UnitClassArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ENDP ; UnitClassArrayHelpers::Write
_TEXT	ENDS
PUBLIC	??_7CvCivilizationBaseInfo@@6B@			; CvCivilizationBaseInfo::`vftable'
PUBLIC	??0CvCivilizationBaseInfo@@QAE@XZ		; CvCivilizationBaseInfo::CvCivilizationBaseInfo
PUBLIC	??_R4CvCivilizationBaseInfo@@6B@		; CvCivilizationBaseInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvCivilizationBaseInfo@@@8		; CvCivilizationBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvCivilizationBaseInfo@@8			; CvCivilizationBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvCivilizationBaseInfo@@8			; CvCivilizationBaseInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvCivilizationBaseInfo@@8		; CvCivilizationBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvCivilizationBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvCivilizationBaseInfo::CacheResults
EXTRN	??_ECvCivilizationBaseInfo@@UAEPAXI@Z:PROC	; CvCivilizationBaseInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvCivilizationBaseInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvCivilizationBaseInfo@@8 DD FLAT:??_R0?AVCvCivilizationBaseInfo@@@8 ; CvCivilizationBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvCivilizationBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvCivilizationBaseInfo@@8
rdata$r	SEGMENT
??_R2CvCivilizationBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvCivilizationBaseInfo@@8 ; CvCivilizationBaseInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvCivilizationBaseInfo@@8
rdata$r	SEGMENT
??_R3CvCivilizationBaseInfo@@8 DD 00H			; CvCivilizationBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvCivilizationBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvCivilizationBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvCivilizationBaseInfo@@@8 DD FLAT:??_7type_info@@6B@ ; CvCivilizationBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvCivilizationBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvCivilizationBaseInfo@@6B@
rdata$r	SEGMENT
??_R4CvCivilizationBaseInfo@@6B@ DD 00H			; CvCivilizationBaseInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvCivilizationBaseInfo@@@8
	DD	FLAT:??_R3CvCivilizationBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvCivilizationBaseInfo@@6B@
CONST	SEGMENT
??_7CvCivilizationBaseInfo@@6B@ DD FLAT:??_R4CvCivilizationBaseInfo@@6B@ ; CvCivilizationBaseInfo::`vftable'
	DD	FLAT:?CacheResults@CvCivilizationBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvCivilizationBaseInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvCivilizationBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvCivilizationBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvCivilizationBaseInfo@@QAE@XZ$1
__ehfuncinfo$??0CvCivilizationBaseInfo@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvCivilizationBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvCivilizationBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvCivilizationBaseInfo@@QAE@XZ PROC			; CvCivilizationBaseInfo::CvCivilizationBaseInfo, COMDAT
; _this$ = ecx

; 1911 : {

	push	-1
	push	__ehhandler$??0CvCivilizationBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	lea	ecx, DWORD PTR [esi+264]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	mov	DWORD PTR [esi], OFFSET ??_7CvCivilizationBaseInfo@@6B@
	mov	BYTE PTR [esi+260], 0
	mov	BYTE PTR [esi+261], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+292]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1912 : 	memset((void*)&m_kPackageID, 0, sizeof(m_kPackageID));
; 1913 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	xor	eax, eax
	mov	DWORD PTR [esi+320], eax
	mov	DWORD PTR [esi+324], eax
	mov	DWORD PTR [esi+328], eax
	mov	DWORD PTR [esi+332], eax
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvCivilizationBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvCivilizationBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 264				; 00000108H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvCivilizationBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvCivilizationBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvCivilizationBaseInfo@@QAE@XZ ENDP			; CvCivilizationBaseInfo::CvCivilizationBaseInfo
PUBLIC	??1CvCivilizationBaseInfo@@UAE@XZ		; CvCivilizationBaseInfo::~CvCivilizationBaseInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvCivilizationBaseInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvCivilizationBaseInfo@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvCivilizationBaseInfo@@UAE@XZ$1
__ehfuncinfo$??1CvCivilizationBaseInfo@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvCivilizationBaseInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??1CvCivilizationBaseInfo@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvCivilizationBaseInfo@@UAE@XZ PROC			; CvCivilizationBaseInfo::~CvCivilizationBaseInfo, COMDAT
; _this$ = ecx

; 1917 : {

	push	-1
	push	__ehhandler$??1CvCivilizationBaseInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvCivilizationBaseInfo@@6B@

; 1918 : }

	lea	ecx, DWORD PTR [esi+292]
	mov	DWORD PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+264]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvCivilizationBaseInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvCivilizationBaseInfo@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 264				; 00000108H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvCivilizationBaseInfo@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvCivilizationBaseInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvCivilizationBaseInfo@@UAE@XZ ENDP			; CvCivilizationBaseInfo::~CvCivilizationBaseInfo
PUBLIC	?setShortDescriptionKey@CvCivilizationBaseInfo@@QAEXPBD@Z ; CvCivilizationBaseInfo::setShortDescriptionKey
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?setShortDescriptionKey@CvCivilizationBaseInfo@@QAEXPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setShortDescriptionKey@CvCivilizationBaseInfo@@QAEXPBD@Z$0
__ehfuncinfo$?setShortDescriptionKey@CvCivilizationBaseInfo@@QAEXPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?setShortDescriptionKey@CvCivilizationBaseInfo@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?setShortDescriptionKey@CvCivilizationBaseInfo@@QAEXPBD@Z
_TEXT	SEGMENT
$T232766 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_szVal$ = 8						; size = 4
?setShortDescriptionKey@CvCivilizationBaseInfo@@QAEXPBD@Z PROC ; CvCivilizationBaseInfo::setShortDescriptionKey, COMDAT
; _this$ = ecx

; 1937 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?setShortDescriptionKey@CvCivilizationBaseInfo@@QAEXPBD@Z
	push	eax

; 1938 : 	m_strShortDescriptionKey = szVal;

	mov	eax, DWORD PTR _szVal$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi
	push	edi
	mov	edi, ecx
	lea	esi, DWORD PTR [edi+292]
	mov	ecx, esi
	test	eax, eax
	je	SHORT $LN5@setShortDe
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN4@setShortDe
$LN5@setShortDe:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN4@setShortDe:

; 1939 : 	m_strShortDescription = GetLocalizedText(m_strShortDescriptionKey.c_str());

	mov	ecx, esi
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T232766[esp+52]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	lea	ecx, DWORD PTR [edi+264]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T232766[esp+48]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1940 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setShortDescriptionKey@CvCivilizationBaseInfo@@QAEXPBD@Z$0:
	lea	ecx, DWORD PTR $T232766[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?setShortDescriptionKey@CvCivilizationBaseInfo@@QAEXPBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?setShortDescriptionKey@CvCivilizationBaseInfo@@QAEXPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setShortDescriptionKey@CvCivilizationBaseInfo@@QAEXPBD@Z ENDP ; CvCivilizationBaseInfo::setShortDescriptionKey
EXTRN	?ExtractGUID@@YA_NPBDAAU_GUID@@PAI@Z:PROC	; ExtractGUID
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvCivilizationBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvCivilizationBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvCivilizationBaseInfo::CacheResults, COMDAT
; _this$ = ecx

; 1955 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	mov	esi, DWORD PTR _kResults$[esp]
	push	edi
	push	eax
	push	esi
	mov	edi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN2@CacheResul@5
	pop	edi
	pop	esi

; 1973 : }

	ret	8
$LN2@CacheResul@5:
	push	ebx

; 1956 : 		return false;
; 1957 : 
; 1958 : 	const char* szTextVal = NULL;	//! temporary val
; 1959 : 
; 1960 : 	//Basic Properties
; 1961 : 	m_bPlayable = kResults.GetBool("Playable");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG219926
	mov	ecx, esi
	call	ebx

; 1962 : 	m_bAIPlayable = kResults.GetBool("AIPlayable");

	push	OFFSET $SG219927
	mov	ecx, esi
	mov	BYTE PTR [edi+261], al
	call	ebx

; 1963 : 
; 1964 : 	szTextVal = kResults.GetText("ShortDescription");

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG219928
	mov	ecx, esi
	mov	BYTE PTR [edi+260], al
	call	ebx

; 1965 : 	setShortDescriptionKey(szTextVal);

	push	eax
	mov	ecx, edi
	call	?setShortDescriptionKey@CvCivilizationBaseInfo@@QAEXPBD@Z ; CvCivilizationBaseInfo::setShortDescriptionKey

; 1966 : 
; 1967 : 	szTextVal = kResults.GetText("PackageID");

	push	OFFSET $SG219929
	mov	ecx, esi
	call	ebx
	pop	ebx

; 1968 : 	if(szTextVal)

	test	eax, eax
	je	SHORT $LN1@CacheResul@5

; 1969 : 	{
; 1970 : 		ExtractGUID(szTextVal, m_kPackageID);

	push	0
	add	edi, 320				; 00000140H
	push	edi
	push	eax
	call	?ExtractGUID@@YA_NPBDAAU_GUID@@PAI@Z	; ExtractGUID
	add	esp, 12					; 0000000cH
$LN1@CacheResul@5:
	pop	edi

; 1971 : 	}
; 1972 : 	return true;

	mov	al, 1
	pop	esi

; 1973 : }

	ret	8
?CacheResults@CvCivilizationBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvCivilizationBaseInfo::CacheResults
_TEXT	ENDS
PUBLIC	?getNumCityNames@CvCivilizationInfo@@QBEHXZ	; CvCivilizationInfo::getNumCityNames
; Function compile flags: /Ogtpy
;	COMDAT ?getNumCityNames@CvCivilizationInfo@@QBEHXZ
_TEXT	SEGMENT
?getNumCityNames@CvCivilizationInfo@@QBEHXZ PROC	; CvCivilizationInfo::getNumCityNames, COMDAT
; _this$ = ecx

; 2085 : {

	push	esi

; 2086 : 	return m_vCityNames.size();

	mov	esi, DWORD PTR [ecx+592]
	sub	esi, DWORD PTR [ecx+588]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	add	edx, esi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 2087 : }

	ret	0
?getNumCityNames@CvCivilizationInfo@@QBEHXZ ENDP	; CvCivilizationInfo::getNumCityNames
_TEXT	ENDS
PUBLIC	?getNumSpyNames@CvCivilizationInfo@@QBEHXZ	; CvCivilizationInfo::getNumSpyNames
; Function compile flags: /Ogtpy
;	COMDAT ?getNumSpyNames@CvCivilizationInfo@@QBEHXZ
_TEXT	SEGMENT
?getNumSpyNames@CvCivilizationInfo@@QBEHXZ PROC		; CvCivilizationInfo::getNumSpyNames, COMDAT
; _this$ = ecx

; 2090 : {

	push	esi

; 2091 : 	return m_vSpyNames.size();

	mov	esi, DWORD PTR [ecx+608]
	sub	esi, DWORD PTR [ecx+604]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	add	edx, esi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 2092 : }

	ret	0
?getNumSpyNames@CvCivilizationInfo@@QBEHXZ ENDP		; CvCivilizationInfo::getNumSpyNames
_TEXT	ENDS
PUBLIC	?setAdjectiveKey@CvCivilizationInfo@@QAEXPBD@Z	; CvCivilizationInfo::setAdjectiveKey
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?setAdjectiveKey@CvCivilizationInfo@@QAEXPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setAdjectiveKey@CvCivilizationInfo@@QAEXPBD@Z$0
__ehfuncinfo$?setAdjectiveKey@CvCivilizationInfo@@QAEXPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?setAdjectiveKey@CvCivilizationInfo@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?setAdjectiveKey@CvCivilizationInfo@@QAEXPBD@Z
_TEXT	SEGMENT
$T232809 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_szVal$ = 8						; size = 4
?setAdjectiveKey@CvCivilizationInfo@@QAEXPBD@Z PROC	; CvCivilizationInfo::setAdjectiveKey, COMDAT
; _this$ = ecx

; 2118 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?setAdjectiveKey@CvCivilizationInfo@@QAEXPBD@Z
	push	eax

; 2119 : 	m_strAdjectiveKey = szVal;

	mov	eax, DWORD PTR _szVal$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi
	push	edi
	mov	edi, ecx
	lea	esi, DWORD PTR [edi+460]
	mov	ecx, esi
	test	eax, eax
	je	SHORT $LN5@setAdjecti
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN4@setAdjecti
$LN5@setAdjecti:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN4@setAdjecti:

; 2120 : 	m_strAdjective = GetLocalizedText(m_strAdjectiveKey.c_str());

	mov	ecx, esi
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T232809[esp+52]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	lea	ecx, DWORD PTR [edi+432]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T232809[esp+48]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2121 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setAdjectiveKey@CvCivilizationInfo@@QAEXPBD@Z$0:
	lea	ecx, DWORD PTR $T232809[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?setAdjectiveKey@CvCivilizationInfo@@QAEXPBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?setAdjectiveKey@CvCivilizationInfo@@QAEXPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setAdjectiveKey@CvCivilizationInfo@@QAEXPBD@Z ENDP	; CvCivilizationInfo::setAdjectiveKey
PUBLIC	?setArtDefineTag@CvCivilizationInfo@@QAEXPBD@Z	; CvCivilizationInfo::setArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?setArtDefineTag@CvCivilizationInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setArtDefineTag@CvCivilizationInfo@@QAEXPBD@Z PROC	; CvCivilizationInfo::setArtDefineTag, COMDAT
; _this$ = ecx

; 2140 : 	m_strArtDefineTag = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 348				; 0000015cH
	test	eax, eax
	je	SHORT $LN4@setArtDefi
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setArtDefi:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 2141 : }

	ret	4
?setArtDefineTag@CvCivilizationInfo@@QAEXPBD@Z ENDP	; CvCivilizationInfo::setArtDefineTag
_TEXT	ENDS
PUBLIC	?setArtStyleSuffix@CvCivilizationInfo@@QAEXPBD@Z ; CvCivilizationInfo::setArtStyleSuffix
; Function compile flags: /Ogtpy
;	COMDAT ?setArtStyleSuffix@CvCivilizationInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setArtStyleSuffix@CvCivilizationInfo@@QAEXPBD@Z PROC	; CvCivilizationInfo::setArtStyleSuffix, COMDAT
; _this$ = ecx

; 2145 : 	m_strArtStyleSuffix = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 404				; 00000194H
	test	eax, eax
	je	SHORT $LN4@setArtStyl
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setArtStyl:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 2146 : }

	ret	4
?setArtStyleSuffix@CvCivilizationInfo@@QAEXPBD@Z ENDP	; CvCivilizationInfo::setArtStyleSuffix
_TEXT	ENDS
PUBLIC	?setArtStylePrefix@CvCivilizationInfo@@QAEXPBD@Z ; CvCivilizationInfo::setArtStylePrefix
; Function compile flags: /Ogtpy
;	COMDAT ?setArtStylePrefix@CvCivilizationInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setArtStylePrefix@CvCivilizationInfo@@QAEXPBD@Z PROC	; CvCivilizationInfo::setArtStylePrefix, COMDAT
; _this$ = ecx

; 2150 : 	m_strArtStylePrefix = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 376				; 00000178H
	test	eax, eax
	je	SHORT $LN4@setArtStyl@2
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setArtStyl@2:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 2151 : }

	ret	4
?setArtStylePrefix@CvCivilizationInfo@@QAEXPBD@Z ENDP	; CvCivilizationInfo::setArtStylePrefix
_TEXT	ENDS
PUBLIC	?getCityNames@CvCivilizationInfo@@QBEPBDH@Z	; CvCivilizationInfo::getCityNames
; Function compile flags: /Ogtpy
;	COMDAT ?getCityNames@CvCivilizationInfo@@QBEPBDH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getCityNames@CvCivilizationInfo@@QBEPBDH@Z PROC	; CvCivilizationInfo::getCityNames, COMDAT
; _this$ = ecx

; 2242 : 	return m_vCityNames[i].c_str();

	mov	eax, DWORD PTR _i$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+588]
	lea	ecx, DWORD PTR [eax+edx*4]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 2243 : }

	ret	4
?getCityNames@CvCivilizationInfo@@QBEPBDH@Z ENDP	; CvCivilizationInfo::getCityNames
_TEXT	ENDS
PUBLIC	?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z	; CvCivilizationInfo::getSpyNames
; Function compile flags: /Ogtpy
;	COMDAT ?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z PROC		; CvCivilizationInfo::getSpyNames, COMDAT
; _this$ = ecx

; 2247 : 	return m_vSpyNames[i].c_str();

	mov	eax, DWORD PTR _i$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+604]
	lea	ecx, DWORD PTR [eax+edx*4]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 2248 : }

	ret	4
?getSpyNames@CvCivilizationInfo@@QBEPBDH@Z ENDP		; CvCivilizationInfo::getSpyNames
_TEXT	ENDS
PUBLIC	??_7CvVictoryInfo@@6B@				; CvVictoryInfo::`vftable'
PUBLIC	??0CvVictoryInfo@@QAE@XZ			; CvVictoryInfo::CvVictoryInfo
PUBLIC	??_R4CvVictoryInfo@@6B@				; CvVictoryInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvVictoryInfo@@@8			; CvVictoryInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvVictoryInfo@@8				; CvVictoryInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvVictoryInfo@@8				; CvVictoryInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvVictoryInfo@@8			; CvVictoryInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvVictoryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvVictoryInfo::CacheResults
EXTRN	??_ECvVictoryInfo@@UAEPAXI@Z:PROC		; CvVictoryInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvVictoryInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvVictoryInfo@@8 DD FLAT:??_R0?AVCvVictoryInfo@@@8 ; CvVictoryInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvVictoryInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvVictoryInfo@@8
rdata$r	SEGMENT
??_R2CvVictoryInfo@@8 DD FLAT:??_R1A@?0A@EA@CvVictoryInfo@@8 ; CvVictoryInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvVictoryInfo@@8
rdata$r	SEGMENT
??_R3CvVictoryInfo@@8 DD 00H				; CvVictoryInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvVictoryInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvVictoryInfo@@@8
_DATA	SEGMENT
??_R0?AVCvVictoryInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvVictoryInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvVictoryInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvVictoryInfo@@6B@
rdata$r	SEGMENT
??_R4CvVictoryInfo@@6B@ DD 00H				; CvVictoryInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvVictoryInfo@@@8
	DD	FLAT:??_R3CvVictoryInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvVictoryInfo@@6B@
CONST	SEGMENT
??_7CvVictoryInfo@@6B@ DD FLAT:??_R4CvVictoryInfo@@6B@	; CvVictoryInfo::`vftable'
	DD	FLAT:?CacheResults@CvVictoryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvVictoryInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvVictoryInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvVictoryInfo@@QAE@XZ$0
__ehfuncinfo$??0CvVictoryInfo@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvVictoryInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvVictoryInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvVictoryInfo@@QAE@XZ PROC				; CvVictoryInfo::CvVictoryInfo, COMDAT
; _this$ = ecx

; 2520 : {

	push	-1
	push	__ehhandler$??0CvVictoryInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	ebx, ebx
	lea	ecx, DWORD PTR [esi+300]
	mov	DWORD PTR __$EHRec$[esp+32], ebx
	mov	DWORD PTR [esi], OFFSET ??_7CvVictoryInfo@@6B@
	mov	DWORD PTR [esi+260], ebx
	mov	DWORD PTR [esi+264], ebx
	mov	DWORD PTR [esi+268], ebx
	mov	DWORD PTR [esi+272], ebx
	mov	DWORD PTR [esi+276], ebx
	mov	DWORD PTR [esi+280], ebx
	mov	DWORD PTR [esi+284], ebx
	mov	BYTE PTR [esi+288], bl
	mov	BYTE PTR [esi+289], bl
	mov	BYTE PTR [esi+290], bl
	mov	BYTE PTR [esi+291], bl
	mov	BYTE PTR [esi+292], bl
	mov	BYTE PTR [esi+293], bl
	mov	BYTE PTR [esi+294], bl
	mov	BYTE PTR [esi+295], bl
	mov	BYTE PTR [esi+296], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2521 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+328], ebx
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvVictoryInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??0CvVictoryInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvVictoryInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvVictoryInfo@@QAE@XZ ENDP				; CvVictoryInfo::CvVictoryInfo
PUBLIC	??1CvVictoryInfo@@UAE@XZ			; CvVictoryInfo::~CvVictoryInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvVictoryInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvVictoryInfo@@UAE@XZ$0
__ehfuncinfo$??1CvVictoryInfo@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvVictoryInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??1CvVictoryInfo@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvVictoryInfo@@UAE@XZ PROC				; CvVictoryInfo::~CvVictoryInfo, COMDAT
; _this$ = ecx

; 2524 : {

	push	-1
	push	__ehhandler$??1CvVictoryInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvVictoryInfo@@6B@

; 2525 : 	SAFE_DELETE_ARRAY(m_piVictoryPointAwards);

	mov	eax, DWORD PTR [esi+328]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 2526 : }

	lea	ecx, DWORD PTR [esi+300]
	mov	DWORD PTR [esi+328], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvVictoryInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??1CvVictoryInfo@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvVictoryInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvVictoryInfo@@UAE@XZ ENDP				; CvVictoryInfo::~CvVictoryInfo
EXTRN	__imp_?Reset@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBD_N@Z:PROC
EXTRN	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; CvDatabaseUtility::PrepareResults
EXTRN	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CvDatabaseUtility::GetResults
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvVictoryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvVictoryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
__ehfuncinfo$?CacheResults@CvVictoryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CacheResults@CvVictoryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvVictoryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_strKey$220295 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvVictoryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvVictoryInfo::CacheResults, COMDAT
; _this$ = ecx

; 2619 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvVictoryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax

; 2620 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+44]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN4@CacheResul@6
	pop	edi
	pop	esi

; 2670 : 
; 2671 : 	return true;
; 2672 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
$LN4@CacheResul@6:
	push	ebx

; 2621 : 		return false;
; 2622 : 
; 2623 : 	m_bWinsGame = kResults.GetBool("WinsGame");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	ebp
	push	OFFSET $SG220275
	mov	ecx, edi
	call	ebx

; 2624 : 	m_bTargetScore = kResults.GetBool("TargetScore");

	push	OFFSET $SG220276
	mov	ecx, edi
	mov	BYTE PTR [esi+288], al
	call	ebx

; 2625 : 	m_bEndScore = kResults.GetBool("EndScore");

	push	OFFSET $SG220277
	mov	ecx, edi
	mov	BYTE PTR [esi+289], al
	call	ebx

; 2626 : 	m_bConquest = kResults.GetBool("Conquest");

	push	OFFSET $SG220278
	mov	ecx, edi
	mov	BYTE PTR [esi+290], al
	call	ebx

; 2627 : 	m_bInfluential = kResults.GetBool("Influential");

	push	OFFSET $SG220279
	mov	ecx, edi
	mov	BYTE PTR [esi+291], al
	call	ebx

; 2628 : 	m_bDiploVote = kResults.GetBool("DiploVote");

	push	OFFSET $SG220280
	mov	ecx, edi
	mov	BYTE PTR [esi+292], al
	call	ebx

; 2629 : 	m_bPermanent = kResults.GetBool("Permanent");

	push	OFFSET $SG220281
	mov	ecx, edi
	mov	BYTE PTR [esi+293], al
	call	ebx

; 2630 : 	m_bReligionInAllCities = kResults.GetBool("ReligionInAllCities");

	push	OFFSET $SG220282
	mov	ecx, edi
	mov	BYTE PTR [esi+294], al
	call	ebx

; 2631 : 	m_bFindAllNaturalWonders = kResults.GetBool("FindAllNaturalWonders");

	push	OFFSET $SG220283
	mov	ecx, edi
	mov	BYTE PTR [esi+295], al
	call	ebx

; 2632 : 	m_iPopulationPercentLead = kResults.GetInt("PopulationPercentLead");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG220284
	mov	ecx, edi
	mov	BYTE PTR [esi+296], al
	call	ebx

; 2633 : 	m_iLandPercent = kResults.GetInt("LandPercent");

	push	OFFSET $SG220285
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 2634 : 	m_iMinLandPercent = kResults.GetInt("MinLandPercent");

	push	OFFSET $SG220286
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 2635 : 
; 2636 : 	m_iNumCultureCities = kResults.GetInt("NumCultureCities");

	push	OFFSET $SG220287
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 2637 : 	m_iTotalCultureRatio = kResults.GetInt("TotalCultureRatio");

	push	OFFSET $SG220288
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebx

; 2638 : 	m_iVictoryDelayTurns = kResults.GetInt("VictoryDelayTurns");

	push	OFFSET $SG220289
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebx

; 2639 : 
; 2640 : 	m_strMovie = kResults.GetText("VictoryMovie");

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG220290
	mov	ecx, edi
	mov	DWORD PTR [esi+284], eax
	call	ebx
	lea	ecx, DWORD PTR [esi+300]
	test	eax, eax
	je	SHORT $LN9@CacheResul@6
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN8@CacheResul@6
$LN9@CacheResul@6:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN8@CacheResul@6:

; 2641 : 
; 2642 : 	const char* szCityCulture = kResults.GetText("CityCulture");

	push	OFFSET $SG220292
	mov	ecx, edi
	call	ebx

; 2643 : 	m_iCityCulture = GC.getInfoTypeForString(szCityCulture, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2644 : 
; 2645 : 	//VictoryPointAwards
; 2646 : 	{
; 2647 : 		const char* szVictoryType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+272], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 2648 : 
; 2649 : 		const int iNumVictoryPoints = GC.getNUM_VICTORY_POINT_AWARDS();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6264
	mov	ebp, eax

; 2650 : 		kUtility.InitializeArray(m_piVictoryPointAwards, iNumVictoryPoints);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+328], eax
	call	_memset
	add	esp, 16					; 00000010H

; 2651 : 
; 2652 : 		std::string strKey = "CvVictoryInfo_VictoryPointAwards";

	push	OFFSET $SG220296
	lea	ecx, DWORD PTR _strKey$220295[esp+60]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2653 : 		Database::Results* pVictoryPointResults = kUtility.GetResults(strKey);

	mov	ebx, DWORD PTR _kUtility$[esp+52]
	lea	edx, DWORD PTR _strKey$220295[esp+56]
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+68], 0
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 2654 : 		if(pVictoryPointResults == NULL)

	test	edi, edi
	jne	SHORT $LN3@CacheResul@6

; 2655 : 		{
; 2656 : 			pVictoryPointResults = kUtility.PrepareResults(strKey, "select VictoryPoints from VictoryPointAwards where VictoryType == ? order by VictoryPoints desc;");

	push	OFFSET $SG220299
	lea	eax, DWORD PTR _strKey$220295[esp+60]
	push	eax
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax
$LN3@CacheResul@6:

; 2657 : 		}
; 2658 : 
; 2659 : 		pVictoryPointResults->Bind(1, szVictoryType);

	push	1
	push	ebp
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 2660 : 
; 2661 : 		int i = 0;
; 2662 : 		while(pVictoryPointResults->Step())

	mov	ebp, DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	mov	ecx, edi
	call	ebp
	test	al, al
	je	SHORT $LN1@CacheResul@6

; 2657 : 		}
; 2658 : 
; 2659 : 		pVictoryPointResults->Bind(1, szVictoryType);

	xor	ebx, ebx
	npad	9
$LL2@CacheResul@6:

; 2663 : 		{
; 2664 : 			CvAssert(i < iNumVictoryPoints);
; 2665 : 			m_piVictoryPointAwards[i++] = pVictoryPointResults->GetInt(0);

	push	0
	mov	ecx, edi
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	ecx, DWORD PTR [esi+328]
	mov	DWORD PTR [ebx+ecx], eax
	mov	ecx, edi
	add	ebx, 4
	call	ebp
	test	al, al
	jne	SHORT $LL2@CacheResul@6
$LN1@CacheResul@6:

; 2666 : 		}
; 2667 : 
; 2668 : 		pVictoryPointResults->Reset();

	mov	ecx, edi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 2669 : 	}

	lea	ecx, DWORD PTR _strKey$220295[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2670 : 
; 2671 : 	return true;
; 2672 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	ebp
	pop	ebx
	pop	edi
	mov	al, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvVictoryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _strKey$220295[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvVictoryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvVictoryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvVictoryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvVictoryInfo::CacheResults
PUBLIC	??_7CvSmallAwardInfo@@6B@			; CvSmallAwardInfo::`vftable'
PUBLIC	??0CvSmallAwardInfo@@QAE@XZ			; CvSmallAwardInfo::CvSmallAwardInfo
PUBLIC	??_R4CvSmallAwardInfo@@6B@			; CvSmallAwardInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvSmallAwardInfo@@@8			; CvSmallAwardInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvSmallAwardInfo@@8			; CvSmallAwardInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvSmallAwardInfo@@8			; CvSmallAwardInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvSmallAwardInfo@@8		; CvSmallAwardInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvSmallAwardInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvSmallAwardInfo::CacheResults
EXTRN	??_ECvSmallAwardInfo@@UAEPAXI@Z:PROC		; CvSmallAwardInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvSmallAwardInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvSmallAwardInfo@@8 DD FLAT:??_R0?AVCvSmallAwardInfo@@@8 ; CvSmallAwardInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvSmallAwardInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvSmallAwardInfo@@8
rdata$r	SEGMENT
??_R2CvSmallAwardInfo@@8 DD FLAT:??_R1A@?0A@EA@CvSmallAwardInfo@@8 ; CvSmallAwardInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvSmallAwardInfo@@8
rdata$r	SEGMENT
??_R3CvSmallAwardInfo@@8 DD 00H				; CvSmallAwardInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvSmallAwardInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvSmallAwardInfo@@@8
_DATA	SEGMENT
??_R0?AVCvSmallAwardInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvSmallAwardInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvSmallAwardInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvSmallAwardInfo@@6B@
rdata$r	SEGMENT
??_R4CvSmallAwardInfo@@6B@ DD 00H			; CvSmallAwardInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvSmallAwardInfo@@@8
	DD	FLAT:??_R3CvSmallAwardInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvSmallAwardInfo@@6B@
CONST	SEGMENT
??_7CvSmallAwardInfo@@6B@ DD FLAT:??_R4CvSmallAwardInfo@@6B@ ; CvSmallAwardInfo::`vftable'
	DD	FLAT:?CacheResults@CvSmallAwardInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvSmallAwardInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvSmallAwardInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvSmallAwardInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvSmallAwardInfo@@QAE@XZ$1
__ehfuncinfo$??0CvSmallAwardInfo@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvSmallAwardInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvSmallAwardInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvSmallAwardInfo@@QAE@XZ PROC			; CvSmallAwardInfo::CvSmallAwardInfo, COMDAT
; _this$ = ecx

; 2685 : {

	push	-1
	push	__ehhandler$??0CvSmallAwardInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	edi, edi
	lea	ecx, DWORD PTR [esi+260]
	push	OFFSET $SG220307
	mov	DWORD PTR __$EHRec$[esp+36], edi
	mov	DWORD PTR [esi], OFFSET ??_7CvSmallAwardInfo@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	push	OFFSET $SG220308
	lea	ecx, DWORD PTR [esi+288]
	mov	BYTE PTR __$EHRec$[esp+36], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2686 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+316], edi
	mov	DWORD PTR [esi+320], edi
	mov	DWORD PTR [esi+324], edi
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvSmallAwardInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvSmallAwardInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260				; 00000104H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvSmallAwardInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvSmallAwardInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvSmallAwardInfo@@QAE@XZ ENDP			; CvSmallAwardInfo::CvSmallAwardInfo
PUBLIC	??1CvSmallAwardInfo@@UAE@XZ			; CvSmallAwardInfo::~CvSmallAwardInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvSmallAwardInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvSmallAwardInfo@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvSmallAwardInfo@@UAE@XZ$1
__ehfuncinfo$??1CvSmallAwardInfo@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvSmallAwardInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??1CvSmallAwardInfo@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvSmallAwardInfo@@UAE@XZ PROC			; CvSmallAwardInfo::~CvSmallAwardInfo, COMDAT
; _this$ = ecx

; 2689 : {

	push	-1
	push	__ehhandler$??1CvSmallAwardInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvSmallAwardInfo@@6B@

; 2690 : }

	lea	ecx, DWORD PTR [esi+288]
	mov	DWORD PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+260]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvSmallAwardInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvSmallAwardInfo@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260				; 00000104H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvSmallAwardInfo@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvSmallAwardInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvSmallAwardInfo@@UAE@XZ ENDP			; CvSmallAwardInfo::~CvSmallAwardInfo
PUBLIC	?GetNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ ; CvSmallAwardInfo::GetNotificationString
; Function compile flags: /Ogtpy
;	COMDAT ?GetNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ
_TEXT	SEGMENT
$T233005 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ PROC ; CvSmallAwardInfo::GetNotificationString, COMDAT
; _this$ = ecx

; 2698 : {

	push	ecx
	push	esi

; 2699 : 	return m_szNotification;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	add	ecx, 260				; 00000104H
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T233005[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi

; 2700 : }

	pop	ecx
	ret	4
?GetNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ ENDP ; CvSmallAwardInfo::GetNotificationString
_TEXT	ENDS
PUBLIC	?GetTeamNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ ; CvSmallAwardInfo::GetTeamNotificationString
; Function compile flags: /Ogtpy
;	COMDAT ?GetTeamNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ
_TEXT	SEGMENT
$T233015 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetTeamNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ PROC ; CvSmallAwardInfo::GetTeamNotificationString, COMDAT
; _this$ = ecx

; 2703 : {

	push	ecx
	push	esi

; 2704 : 	return m_szTeamNotification;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	add	ecx, 288				; 00000120H
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T233015[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi

; 2705 : }

	pop	ecx
	ret	4
?GetTeamNotificationString@CvSmallAwardInfo@@QBE?AVCvString@@XZ ENDP ; CvSmallAwardInfo::GetTeamNotificationString
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvSmallAwardInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvSmallAwardInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvSmallAwardInfo::CacheResults, COMDAT
; _this$ = ecx

; 2719 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@7
	pop	edi
	pop	esi

; 2731 : }

	ret	8
$LN1@CacheResul@7:
	push	ebx

; 2720 : 		return false;
; 2721 : 
; 2722 : 	m_szNotification = kResults.GetText("Notification");

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG220339
	mov	ecx, edi
	call	ebx
	lea	ecx, DWORD PTR [esi+260]
	test	eax, eax
	je	SHORT $LN5@CacheResul@7
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN4@CacheResul@7
$LN5@CacheResul@7:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN4@CacheResul@7:

; 2723 : 	m_szTeamNotification = kResults.GetText("TeamNotification");

	push	OFFSET $SG220340
	mov	ecx, edi
	call	ebx
	lea	ecx, DWORD PTR [esi+288]
	test	eax, eax
	je	SHORT $LN9@CacheResul@7
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN8@CacheResul@7
$LN9@CacheResul@7:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN8@CacheResul@7:

; 2724 : 
; 2725 : 	m_iNumVictoryPoints = kResults.GetInt("NumVictoryPoints");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG220341
	mov	ecx, edi
	call	ebx

; 2726 : 
; 2727 : 	m_iNumCities = kResults.GetInt("NumCities");

	push	OFFSET $SG220342
	mov	ecx, edi
	mov	DWORD PTR [esi+316], eax
	call	ebx

; 2728 : 	m_iCityPopulation = kResults.GetInt("CityPopulation");

	push	OFFSET $SG220343
	mov	ecx, edi
	mov	DWORD PTR [esi+320], eax
	call	ebx
	pop	ebx
	mov	DWORD PTR [esi+324], eax
	pop	edi

; 2729 : 
; 2730 : 	return true;

	mov	al, 1
	pop	esi

; 2731 : }

	ret	8
?CacheResults@CvSmallAwardInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvSmallAwardInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvHurryInfo@@6B@				; CvHurryInfo::`vftable'
PUBLIC	??0CvHurryInfo@@QAE@XZ				; CvHurryInfo::CvHurryInfo
PUBLIC	??_R4CvHurryInfo@@6B@				; CvHurryInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvHurryInfo@@@8				; CvHurryInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvHurryInfo@@8				; CvHurryInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvHurryInfo@@8				; CvHurryInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvHurryInfo@@8			; CvHurryInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvHurryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvHurryInfo::CacheResults
;	COMDAT ??_R1A@?0A@EA@CvHurryInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvHurryInfo@@8 DD FLAT:??_R0?AVCvHurryInfo@@@8 ; CvHurryInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvHurryInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvHurryInfo@@8
rdata$r	SEGMENT
??_R2CvHurryInfo@@8 DD FLAT:??_R1A@?0A@EA@CvHurryInfo@@8 ; CvHurryInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvHurryInfo@@8
rdata$r	SEGMENT
??_R3CvHurryInfo@@8 DD 00H				; CvHurryInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvHurryInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvHurryInfo@@@8
_DATA	SEGMENT
??_R0?AVCvHurryInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvHurryInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvHurryInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvHurryInfo@@6B@
rdata$r	SEGMENT
??_R4CvHurryInfo@@6B@ DD 00H				; CvHurryInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvHurryInfo@@@8
	DD	FLAT:??_R3CvHurryInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvHurryInfo@@6B@
CONST	SEGMENT
??_7CvHurryInfo@@6B@ DD FLAT:??_R4CvHurryInfo@@6B@	; CvHurryInfo::`vftable'
	DD	FLAT:?CacheResults@CvHurryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvHurryInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvHurryInfo@@QAE@XZ PROC				; CvHurryInfo::CvHurryInfo, COMDAT
; _this$ = ecx

; 2742 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi+272], eax
	mov	DWORD PTR [esi+276], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvHurryInfo@@6B@
	mov	DWORD PTR [esi+260], -1

; 2743 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvHurryInfo@@QAE@XZ ENDP				; CvHurryInfo::CvHurryInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvHurryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvHurryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvHurryInfo::CacheResults, COMDAT
; _this$ = ecx

; 2772 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@8
	pop	edi
	pop	esi

; 2784 : }

	ret	8
$LN1@CacheResul@8:
	push	ebx

; 2773 : 		return false;
; 2774 : 
; 2775 : 	m_iGoldPerProduction = kResults.GetInt("GoldPerProduction");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG220368
	mov	ecx, edi
	call	ebx

; 2776 : 	m_iProductionPerPopulation = kResults.GetInt("ProductionPerPopulation");

	push	OFFSET $SG220369
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 2777 : 	m_iGoldPerBeaker = kResults.GetInt("GoldPerBeaker");

	push	OFFSET $SG220370
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 2778 : 	m_iGoldPerCulture = kResults.GetInt("GoldPerCulture");

	push	OFFSET $SG220371
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebx

; 2779 : 
; 2780 : 	const char* szPolicyPrereq = kResults.GetText("PolicyPrereq");

	push	OFFSET $SG220373
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 2781 : 	m_iPolicyPrereq = GC.getInfoTypeForString(szPolicyPrereq, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	pop	ebx
	mov	DWORD PTR [esi+260], eax
	pop	edi

; 2782 : 
; 2783 : 	return true;

	mov	al, 1
	pop	esi

; 2784 : }

	ret	8
?CacheResults@CvHurryInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvHurryInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvHandicapInfo@@6B@				; CvHandicapInfo::`vftable'
PUBLIC	??0CvHandicapInfo@@QAE@XZ			; CvHandicapInfo::CvHandicapInfo
PUBLIC	??_R4CvHandicapInfo@@6B@			; CvHandicapInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvHandicapInfo@@@8			; CvHandicapInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvHandicapInfo@@8				; CvHandicapInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvHandicapInfo@@8				; CvHandicapInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvHandicapInfo@@8			; CvHandicapInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvHandicapInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvHandicapInfo::CacheResults
EXTRN	??_ECvHandicapInfo@@UAEPAXI@Z:PROC		; CvHandicapInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvHandicapInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvHandicapInfo@@8 DD FLAT:??_R0?AVCvHandicapInfo@@@8 ; CvHandicapInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvHandicapInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvHandicapInfo@@8
rdata$r	SEGMENT
??_R2CvHandicapInfo@@8 DD FLAT:??_R1A@?0A@EA@CvHandicapInfo@@8 ; CvHandicapInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvHandicapInfo@@8
rdata$r	SEGMENT
??_R3CvHandicapInfo@@8 DD 00H				; CvHandicapInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvHandicapInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvHandicapInfo@@@8
_DATA	SEGMENT
??_R0?AVCvHandicapInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvHandicapInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvHandicapInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvHandicapInfo@@6B@
rdata$r	SEGMENT
??_R4CvHandicapInfo@@6B@ DD 00H				; CvHandicapInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvHandicapInfo@@@8
	DD	FLAT:??_R3CvHandicapInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvHandicapInfo@@6B@
CONST	SEGMENT
??_7CvHandicapInfo@@6B@ DD FLAT:??_R4CvHandicapInfo@@6B@ ; CvHandicapInfo::`vftable'
	DD	FLAT:?CacheResults@CvHandicapInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvHandicapInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvHandicapInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvHandicapInfo@@QAE@XZ$0
__ehfuncinfo$??0CvHandicapInfo@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvHandicapInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvHandicapInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvHandicapInfo@@QAE@XZ PROC				; CvHandicapInfo::CvHandicapInfo, COMDAT
; _this$ = ecx

; 2854 : {

	push	-1
	push	__ehhandler$??0CvHandicapInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	edi, edi
	lea	ecx, DWORD PTR [esi+500]
	mov	DWORD PTR __$EHRec$[esp+32], edi
	mov	DWORD PTR [esi], OFFSET ??_7CvHandicapInfo@@6B@
	mov	DWORD PTR [esi+260], edi
	mov	DWORD PTR [esi+264], edi
	mov	DWORD PTR [esi+268], edi
	mov	DWORD PTR [esi+272], edi
	mov	DWORD PTR [esi+276], edi
	mov	DWORD PTR [esi+280], edi
	mov	DWORD PTR [esi+284], edi
	mov	DWORD PTR [esi+288], edi
	mov	DWORD PTR [esi+292], edi
	mov	DWORD PTR [esi+296], edi
	mov	DWORD PTR [esi+300], edi
	mov	DWORD PTR [esi+304], edi
	mov	DWORD PTR [esi+308], edi
	mov	DWORD PTR [esi+312], edi
	mov	DWORD PTR [esi+316], edi
	mov	DWORD PTR [esi+320], edi
	mov	DWORD PTR [esi+324], edi
	mov	DWORD PTR [esi+328], edi
	mov	DWORD PTR [esi+332], edi
	mov	DWORD PTR [esi+336], edi
	mov	DWORD PTR [esi+340], edi
	mov	DWORD PTR [esi+344], edi
	mov	DWORD PTR [esi+348], edi
	mov	DWORD PTR [esi+352], edi
	mov	DWORD PTR [esi+356], edi
	mov	DWORD PTR [esi+360], edi
	mov	DWORD PTR [esi+364], edi
	mov	DWORD PTR [esi+368], edi
	mov	DWORD PTR [esi+372], edi
	mov	DWORD PTR [esi+376], edi
	mov	DWORD PTR [esi+380], edi
	mov	DWORD PTR [esi+384], edi
	mov	DWORD PTR [esi+388], edi
	mov	DWORD PTR [esi+392], edi
	mov	DWORD PTR [esi+396], edi
	mov	DWORD PTR [esi+400], edi
	mov	DWORD PTR [esi+404], edi
	mov	DWORD PTR [esi+408], edi
	mov	DWORD PTR [esi+412], edi
	mov	DWORD PTR [esi+416], edi
	mov	DWORD PTR [esi+420], edi
	mov	DWORD PTR [esi+424], edi
	mov	DWORD PTR [esi+428], edi
	mov	DWORD PTR [esi+432], edi
	mov	DWORD PTR [esi+436], edi
	mov	DWORD PTR [esi+440], edi
	mov	DWORD PTR [esi+444], edi
	mov	DWORD PTR [esi+448], edi
	mov	DWORD PTR [esi+452], edi
	mov	DWORD PTR [esi+456], edi
	mov	DWORD PTR [esi+460], edi
	mov	DWORD PTR [esi+464], edi
	mov	DWORD PTR [esi+468], edi
	mov	DWORD PTR [esi+472], edi
	mov	DWORD PTR [esi+476], edi
	mov	DWORD PTR [esi+480], edi
	mov	DWORD PTR [esi+484], edi
	mov	DWORD PTR [esi+488], edi
	mov	DWORD PTR [esi+492], edi
	mov	DWORD PTR [esi+496], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2855 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+528], edi
	mov	DWORD PTR [esi+532], edi
	mov	DWORD PTR [esi+536], edi
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvHandicapInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??0CvHandicapInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvHandicapInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvHandicapInfo@@QAE@XZ ENDP				; CvHandicapInfo::CvHandicapInfo
PUBLIC	??1CvHandicapInfo@@UAE@XZ			; CvHandicapInfo::~CvHandicapInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvHandicapInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvHandicapInfo@@UAE@XZ$0
__ehfuncinfo$??1CvHandicapInfo@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvHandicapInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??1CvHandicapInfo@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvHandicapInfo@@UAE@XZ PROC				; CvHandicapInfo::~CvHandicapInfo, COMDAT
; _this$ = ecx

; 2858 : {

	push	-1
	push	__ehhandler$??1CvHandicapInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvHandicapInfo@@6B@

; 2859 : 	SAFE_DELETE_ARRAY(m_piGoodies);

	mov	eax, DWORD PTR [esi+528]
	xor	edi, edi
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], edi
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+528], edi

; 2860 : 	SAFE_DELETE_ARRAY(m_pbFreeTechs);

	mov	eax, DWORD PTR [esi+532]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+532], edi

; 2861 : 	SAFE_DELETE_ARRAY(m_pbAIFreeTechs);

	mov	eax, DWORD PTR [esi+536]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH

; 2862 : }

	lea	ecx, DWORD PTR [esi+500]
	mov	DWORD PTR [esi+536], edi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvHandicapInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??1CvHandicapInfo@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvHandicapInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvHandicapInfo@@UAE@XZ ENDP				; CvHandicapInfo::~CvHandicapInfo
EXTRN	__imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z:PROC
EXTRN	__imp_??0Results@Database@@QAE@PBD@Z:PROC
EXTRN	__imp_?SelectAt@Connection@Database@@QAE_NAAVResults@2@PBD11@Z:PROC
EXTRN	__imp_??0SingleResult@Database@@QAE@PBD@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvHandicapInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvHandicapInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CacheResults@CvHandicapInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
__ehfuncinfo$?CacheResults@CvHandicapInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CacheResults@CvHandicapInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?CacheResults@CvHandicapInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kArrayResults$220649 = -652				; size = 64
_kCount$220642 = -588					; size = 64
_szSQL$220650 = -524					; size = 512
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvHandicapInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvHandicapInfo::CacheResults, COMDAT
; _this$ = ecx

; 3186 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvHandicapInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax

; 3187 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 640				; 00000280H
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+656]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	je	$LN6@CacheResul@9
$LN5@CacheResul@9:
	push	ebx

; 3188 : 		return false;
; 3189 : 
; 3190 : 	m_iStartingLocationPercent = kResults.GetInt("StartingLocPercent");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	ebp
	push	OFFSET $SG220582
	mov	ecx, edi
	call	ebx

; 3191 : 	m_iAdvancedStartPointsMod = kResults.GetInt("AdvancedStartPointsMod");

	push	OFFSET $SG220583
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 3192 : 	m_iStartingPolicyPoints = kResults.GetInt("StartingPolicyPoints");

	push	OFFSET $SG220584
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 3193 : 	m_iHappinessDefault = kResults.GetInt("HappinessDefault");

	push	OFFSET $SG220585
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 3194 : 	m_iExtraHappinessPerLuxury = kResults.GetInt("ExtraHappinessPerLuxury");

	push	OFFSET $SG220586
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebx

; 3195 : 	m_iNumCitiesUnhappinessMod = kResults.GetInt("NumCitiesUnhappinessMod");

	push	OFFSET $SG220587
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebx

; 3196 : 	m_iPopulationUnhappinessMod = kResults.GetInt("PopulationUnhappinessMod");

	push	OFFSET $SG220588
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebx

; 3197 : 	m_iStartingGold = kResults.GetInt("Gold");

	push	OFFSET $SG220589
	mov	ecx, edi
	mov	DWORD PTR [esi+284], eax
	call	ebx

; 3198 : 	m_iGoldFreeUnits = kResults.GetInt("GoldFreeUnits");

	push	OFFSET $SG220590
	mov	ecx, edi
	mov	DWORD PTR [esi+288], eax
	call	ebx

; 3199 : 	m_iProductionFreeUnits = kResults.GetInt("ProductionFreeUnits");

	push	OFFSET $SG220591
	mov	ecx, edi
	mov	DWORD PTR [esi+292], eax
	call	ebx

; 3200 : 	m_iProductionFreeUnitsPerCity = kResults.GetInt("ProductionFreeUnitsPerCity");

	push	OFFSET $SG220592
	mov	ecx, edi
	mov	DWORD PTR [esi+296], eax
	call	ebx

; 3201 : 	m_iProductionFreeUnitsPopulationPercent = kResults.GetInt("ProductionFreeUnitsPopulationPercent");

	push	OFFSET $SG220593
	mov	ecx, edi
	mov	DWORD PTR [esi+300], eax
	call	ebx

; 3202 : 	m_iRouteCostPercent = kResults.GetInt("RouteCostPercent");

	push	OFFSET $SG220594
	mov	ecx, edi
	mov	DWORD PTR [esi+304], eax
	call	ebx

; 3203 : 	m_iUnitCostPercent = kResults.GetInt("UnitCostPercent");

	push	OFFSET $SG220595
	mov	ecx, edi
	mov	DWORD PTR [esi+308], eax
	call	ebx

; 3204 : 	m_iBuildingCostPercent = kResults.GetInt("BuildingCostPercent");

	push	OFFSET $SG220596
	mov	ecx, edi
	mov	DWORD PTR [esi+312], eax
	call	ebx

; 3205 : 	m_iResearchPercent = kResults.GetInt("ResearchPercent");

	push	OFFSET $SG220597
	mov	ecx, edi
	mov	DWORD PTR [esi+316], eax
	call	ebx

; 3206 : 	m_iPolicyPercent = kResults.GetInt("PolicyPercent");

	push	OFFSET $SG220598
	mov	ecx, edi
	mov	DWORD PTR [esi+320], eax
	call	ebx

; 3207 : 	m_iImprovementCostPercent = kResults.GetInt("ImprovementCostPercent");

	push	OFFSET $SG220599
	mov	ecx, edi
	mov	DWORD PTR [esi+324], eax
	call	ebx

; 3208 : 	m_iCityProductionNumOptions = kResults.GetInt("CityProductionNumOptionsConsidered");

	push	OFFSET $SG220600
	mov	ecx, edi
	mov	DWORD PTR [esi+328], eax
	call	ebx
	mov	DWORD PTR [esi+332], eax

; 3209 : 	m_iTechNumOptions = kResults.GetInt("TechNumOptionsConsidered");

	push	OFFSET $SG220601
	mov	ecx, edi
	call	ebx

; 3210 : 	m_iPolicyNumOptions = kResults.GetInt("PolicyNumOptionsConsidered");

	push	OFFSET $SG220602
	mov	ecx, edi
	mov	DWORD PTR [esi+336], eax
	call	ebx

; 3211 : 	m_iInflationPercent = kResults.GetInt("InflationPercent");

	push	OFFSET $SG220603
	mov	ecx, edi
	mov	DWORD PTR [esi+340], eax
	call	ebx

; 3212 : 	m_iFreeCulturePerTurn = kResults.GetInt("FreeCulturePerTurn");

	push	OFFSET $SG220604
	mov	ecx, edi
	mov	DWORD PTR [esi+344], eax
	call	ebx

; 3213 : 	m_iAttitudeChange = kResults.GetInt("AttitudeChange");

	push	OFFSET $SG220605
	mov	ecx, edi
	mov	DWORD PTR [esi+348], eax
	call	ebx

; 3214 : 	m_iNoTechTradeModifier = kResults.GetInt("NoTechTradeModifier");

	push	OFFSET $SG220606
	mov	ecx, edi
	mov	DWORD PTR [esi+352], eax
	call	ebx

; 3215 : 	m_iTechTradeKnownModifier = kResults.GetInt("TechTradeKnownModifier");

	push	OFFSET $SG220607
	mov	ecx, edi
	mov	DWORD PTR [esi+356], eax
	call	ebx

; 3216 : 	m_iBarbCampGold = kResults.GetInt("BarbCampGold");

	push	OFFSET $SG220608
	mov	ecx, edi
	mov	DWORD PTR [esi+360], eax
	call	ebx

; 3217 : 	m_iBarbSpawnMod = kResults.GetInt("BarbSpawnMod");

	push	OFFSET $SG220609
	mov	ecx, edi
	mov	DWORD PTR [esi+364], eax
	call	ebx

; 3218 : 	m_iBarbarianCombatModifier = kResults.GetInt("BarbarianBonus");

	push	OFFSET $SG220610
	mov	ecx, edi
	mov	DWORD PTR [esi+368], eax
	call	ebx

; 3219 : 	m_iAIBarbarianCombatModifier = kResults.GetInt("AIBarbarianBonus");

	push	OFFSET $SG220611
	mov	ecx, edi
	mov	DWORD PTR [esi+372], eax
	call	ebx

; 3220 : 	m_iEarliestBarbarianReleaseTurn = kResults.GetInt("EarliestBarbarianReleaseTurn");

	push	OFFSET $SG220612
	mov	ecx, edi
	mov	DWORD PTR [esi+376], eax
	call	ebx

; 3221 : 	m_iBarbarianLandTargetRange = kResults.GetInt("BarbarianLandTargetRange");

	push	OFFSET $SG220613
	mov	ecx, edi
	mov	DWORD PTR [esi+380], eax
	call	ebx

; 3222 : 	m_iBarbarianSeaTargetRange = kResults.GetInt("BarbarianSeaTargetRange");

	push	OFFSET $SG220614
	mov	ecx, edi
	mov	DWORD PTR [esi+384], eax
	call	ebx

; 3223 : 	m_iStartingDefenseUnits = kResults.GetInt("StartingDefenseUnits");

	push	OFFSET $SG220615
	mov	ecx, edi
	mov	DWORD PTR [esi+388], eax
	call	ebx

; 3224 : 	m_iStartingWorkerUnits = kResults.GetInt("StartingWorkerUnits");

	push	OFFSET $SG220616
	mov	ecx, edi
	mov	DWORD PTR [esi+392], eax
	call	ebx

; 3225 : 	m_iStartingExploreUnits = kResults.GetInt("StartingExploreUnits");

	push	OFFSET $SG220617
	mov	ecx, edi
	mov	DWORD PTR [esi+396], eax
	call	ebx

; 3226 : 	m_iAIStartingUnitMultiplier = kResults.GetInt("AIStartingUnitMultiplier");

	push	OFFSET $SG220618
	mov	ecx, edi
	mov	DWORD PTR [esi+400], eax
	call	ebx

; 3227 : 	m_iAIStartingDefenseUnits = kResults.GetInt("AIStartingDefenseUnits");

	push	OFFSET $SG220619
	mov	ecx, edi
	mov	DWORD PTR [esi+404], eax
	call	ebx

; 3228 : 	m_iAIStartingWorkerUnits = kResults.GetInt("AIStartingWorkerUnits");

	push	OFFSET $SG220620
	mov	ecx, edi
	mov	DWORD PTR [esi+408], eax
	call	ebx

; 3229 : 	m_iAIStartingExploreUnits = kResults.GetInt("AIStartingExploreUnits");

	push	OFFSET $SG220621
	mov	ecx, edi
	mov	DWORD PTR [esi+412], eax
	call	ebx

; 3230 : 	m_iAIDeclareWarProb = kResults.GetInt("AIDeclareWarProb");

	push	OFFSET $SG220622
	mov	ecx, edi
	mov	DWORD PTR [esi+416], eax
	call	ebx

; 3231 : 	m_iAIWorkRateModifier = kResults.GetInt("AIWorkRateModifier");

	push	OFFSET $SG220623
	mov	ecx, edi
	mov	DWORD PTR [esi+420], eax
	call	ebx

; 3232 : 	m_iAIUnhappinessPercent = kResults.GetInt("AIUnhappinessPercent");

	push	OFFSET $SG220624
	mov	ecx, edi
	mov	DWORD PTR [esi+424], eax
	call	ebx

; 3233 : 	m_iAIGrowthPercent = kResults.GetInt("AIGrowthPercent");

	push	OFFSET $SG220625
	mov	ecx, edi
	mov	DWORD PTR [esi+428], eax
	call	ebx

; 3234 : 	m_iAITrainPercent = kResults.GetInt("AITrainPercent");

	push	OFFSET $SG220626
	mov	ecx, edi
	mov	DWORD PTR [esi+432], eax
	call	ebx

; 3235 : 	m_iAIWorldTrainPercent = kResults.GetInt("AIWorldTrainPercent");

	push	OFFSET $SG220627
	mov	ecx, edi
	mov	DWORD PTR [esi+436], eax
	call	ebx

; 3236 : 	m_iAIConstructPercent = kResults.GetInt("AIConstructPercent");

	push	OFFSET $SG220628
	mov	ecx, edi
	mov	DWORD PTR [esi+440], eax
	call	ebx

; 3237 : 	m_iAIWorldConstructPercent = kResults.GetInt("AIWorldConstructPercent");

	push	OFFSET $SG220629
	mov	ecx, edi
	mov	DWORD PTR [esi+444], eax
	call	ebx

; 3238 : 	m_iAICreatePercent = kResults.GetInt("AICreatePercent");

	push	OFFSET $SG220630
	mov	ecx, edi
	mov	DWORD PTR [esi+448], eax
	call	ebx

; 3239 : 	m_iAIWorldCreatePercent = kResults.GetInt("AIWorldCreatePercent");

	push	OFFSET $SG220631
	mov	ecx, edi
	mov	DWORD PTR [esi+452], eax
	call	ebx

; 3240 : 	m_iAIBuildingCostPercent = kResults.GetInt("AIBuildingCostPercent");

	push	OFFSET $SG220632
	mov	ecx, edi
	mov	DWORD PTR [esi+456], eax
	call	ebx

; 3241 : 	m_iAIUnitCostPercent = kResults.GetInt("AIUnitCostPercent");

	push	OFFSET $SG220633
	mov	ecx, edi
	mov	DWORD PTR [esi+460], eax
	call	ebx

; 3242 : 	m_iAIUnitSupplyPercent = kResults.GetInt("AIUnitSupplyPercent");

	push	OFFSET $SG220634
	mov	ecx, edi
	mov	DWORD PTR [esi+464], eax
	call	ebx

; 3243 : 	m_iAIUnitUpgradePercent = kResults.GetInt("AIUnitUpgradePercent");

	push	OFFSET $SG220635
	mov	ecx, edi
	mov	DWORD PTR [esi+468], eax
	call	ebx

; 3244 : 	m_iAIInflationPercent = kResults.GetInt("AIInflationPercent");

	push	OFFSET $SG220636
	mov	ecx, edi
	mov	DWORD PTR [esi+472], eax
	call	ebx

; 3245 : 	m_iAIPerEraModifier = kResults.GetInt("AIPerEraModifier");

	push	OFFSET $SG220637
	mov	ecx, edi
	mov	DWORD PTR [esi+476], eax
	call	ebx

; 3246 : 	m_iAIAdvancedStartPercent = kResults.GetInt("AIAdvancedStartPercent");

	push	OFFSET $SG220638
	mov	ecx, edi
	mov	DWORD PTR [esi+480], eax
	call	ebx

; 3247 : 	m_iAIFreeXP = kResults.GetInt("AIFreeXP");

	push	OFFSET $SG220639
	mov	ecx, edi
	mov	DWORD PTR [esi+484], eax
	call	ebx

; 3248 : 	m_iAIFreeXPPercent = kResults.GetInt("AIFreeXPPercent");

	push	OFFSET $SG220640
	mov	ecx, edi
	mov	DWORD PTR [esi+488], eax
	call	ebx

; 3249 : 
; 3250 : 	//Arrays
; 3251 : 	const char* szHandicapType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+492], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ebp, eax

; 3252 : 
; 3253 : 	//Goodies
; 3254 : 	{
; 3255 : 		//First find out how many goodies there are.
; 3256 : 		Database::SingleResult kCount("count(*)");

	push	OFFSET $SG220643
	lea	ecx, DWORD PTR _kCount$220642[esp+672]
	call	DWORD PTR __imp_??0SingleResult@Database@@QAE@PBD@Z

; 3257 : 		if(DB.SelectAt(kCount, "HandicapInfo_Goodies", "HandicapType", szHandicapType))

	push	ebp
	push	OFFSET $SG220645
	push	OFFSET $SG220646
	lea	ecx, DWORD PTR _kCount$220642[esp+680]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+692], edi
	call	DWORD PTR __imp_?SelectAt@Connection@Database@@QAE_NAAVResults@2@PBD11@Z
	test	al, al
	je	SHORT $LN4@CacheResul@9

; 3258 : 		{
; 3259 : 			m_iNumGoodies = kCount.GetInt(0);

	push	edi
	lea	ecx, DWORD PTR _kCount$220642[esp+672]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR [esi+496], eax
$LN4@CacheResul@9:

; 3260 : 
; 3261 : 		}
; 3262 : 
; 3263 : #ifdef AUI_WARNING_FIXES
; 3264 : 		SAFE_DELETE_ARRAY(m_piGoodies);
; 3265 : #endif
; 3266 : 		m_piGoodies = FNEW(int[m_iNumGoodies], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR [esi+496]
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 3267 : 		Database::Results kArrayResults;

	push	edi
	lea	ecx, DWORD PTR _kArrayResults$220649[esp+672]
	mov	DWORD PTR [esi+528], eax
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z

; 3268 : 		char szSQL[512];
; 3269 : 		sprintf_s(szSQL, "select GoodyHuts.ID from HandicapInfo_Goodies inner join GoodyHuts on GoodyType = GoodyHuts.Type where HandicapType = '%s';", szHandicapType);

	push	ebp
	lea	eax, DWORD PTR _szSQL$220650[esp+672]
	push	OFFSET $SG220656
	push	eax
	mov	BYTE PTR __$EHRec$[esp+688], 1
	call	??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ	; sprintf_s<512>
	add	esp, 12					; 0000000cH

; 3270 : 
; 3271 : 		if(DB.Execute(kArrayResults, szSQL))

	push	-1
	lea	ecx, DWORD PTR _szSQL$220650[esp+672]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	lea	edx, DWORD PTR _kArrayResults$220649[esp+676]
	push	edx
	call	DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z
	test	al, al
	je	SHORT $LN1@CacheResul@9

; 3272 : 		{
; 3273 : 			int i = 0;
; 3274 : 			while(kArrayResults.Step())

	mov	ebx, DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	lea	ecx, DWORD PTR _kArrayResults$220649[esp+668]
	call	ebx
	test	al, al
	je	SHORT $LN1@CacheResul@9
	npad	6
$LL2@CacheResul@9:

; 3275 : 			{
; 3276 : 				m_piGoodies[i++] = kArrayResults.GetInt(0);

	push	0
	lea	ecx, DWORD PTR _kArrayResults$220649[esp+672]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	ecx, DWORD PTR [esi+528]
	mov	DWORD PTR [edi+ecx], eax
	lea	ecx, DWORD PTR _kArrayResults$220649[esp+668]
	add	edi, 4
	call	ebx
	test	al, al
	jne	SHORT $LL2@CacheResul@9
$LN1@CacheResul@9:

; 3277 : 			}
; 3278 : 		}
; 3279 : 
; 3280 : 	}

	mov	edi, DWORD PTR __imp_??1Results@Database@@UAE@XZ
	lea	ecx, DWORD PTR _kArrayResults$220649[esp+668]
	mov	BYTE PTR __$EHRec$[esp+676], 0
	call	edi
	lea	ecx, DWORD PTR _kCount$220642[esp+668]
	mov	DWORD PTR __$EHRec$[esp+676], -1
	call	edi

; 3281 : 
; 3282 : 	kUtility.PopulateArrayByExistence(m_pbFreeTechs, "Technologies", "HandicapInfo_FreeTechs", "TechType", "HandicapType", szHandicapType);

	mov	edi, DWORD PTR _kUtility$[esp+664]
	push	ebp
	push	OFFSET $SG220662
	push	OFFSET $SG220663
	push	OFFSET $SG220664
	push	OFFSET $SG220665
	lea	edx, DWORD PTR [esi+532]
	push	edx
	mov	ecx, edi
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 3283 : 	kUtility.PopulateArrayByExistence(m_pbAIFreeTechs, "Technologies", "HandicapInfo_AIFreeTechs", "TechType", "HandicapType", szHandicapType);

	push	ebp
	push	OFFSET $SG220666
	push	OFFSET $SG220667
	push	OFFSET $SG220668
	push	OFFSET $SG220669
	add	esi, 536				; 00000218H
	push	esi
	mov	ecx, edi
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence
	pop	ebp

; 3284 : 
; 3285 : 	return true;

	mov	al, 1
	pop	ebx
$LN6@CacheResul@9:

; 3286 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+660]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 652				; 0000028cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvHandicapInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _kCount$220642[ebp]
	jmp	??1SingleResult@Database@@UAE@XZ
__unwindfunclet$?CacheResults@CvHandicapInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _kArrayResults$220649[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__ehhandler$?CacheResults@CvHandicapInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvHandicapInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvHandicapInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvHandicapInfo::CacheResults
PUBLIC	??_7CvGameSpeedInfo@@6B@			; CvGameSpeedInfo::`vftable'
PUBLIC	??0CvGameSpeedInfo@@QAE@XZ			; CvGameSpeedInfo::CvGameSpeedInfo
PUBLIC	??_R4CvGameSpeedInfo@@6B@			; CvGameSpeedInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvGameSpeedInfo@@@8			; CvGameSpeedInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvGameSpeedInfo@@8				; CvGameSpeedInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvGameSpeedInfo@@8				; CvGameSpeedInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvGameSpeedInfo@@8		; CvGameSpeedInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvGameSpeedInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvGameSpeedInfo::CacheResults
EXTRN	??_ECvGameSpeedInfo@@UAEPAXI@Z:PROC		; CvGameSpeedInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvGameSpeedInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvGameSpeedInfo@@8 DD FLAT:??_R0?AVCvGameSpeedInfo@@@8 ; CvGameSpeedInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvGameSpeedInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvGameSpeedInfo@@8
rdata$r	SEGMENT
??_R2CvGameSpeedInfo@@8 DD FLAT:??_R1A@?0A@EA@CvGameSpeedInfo@@8 ; CvGameSpeedInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvGameSpeedInfo@@8
rdata$r	SEGMENT
??_R3CvGameSpeedInfo@@8 DD 00H				; CvGameSpeedInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvGameSpeedInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvGameSpeedInfo@@@8
_DATA	SEGMENT
??_R0?AVCvGameSpeedInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvGameSpeedInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvGameSpeedInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvGameSpeedInfo@@6B@
rdata$r	SEGMENT
??_R4CvGameSpeedInfo@@6B@ DD 00H			; CvGameSpeedInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvGameSpeedInfo@@@8
	DD	FLAT:??_R3CvGameSpeedInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvGameSpeedInfo@@6B@
CONST	SEGMENT
??_7CvGameSpeedInfo@@6B@ DD FLAT:??_R4CvGameSpeedInfo@@6B@ ; CvGameSpeedInfo::`vftable'
	DD	FLAT:?CacheResults@CvGameSpeedInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvGameSpeedInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvGameSpeedInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvGameSpeedInfo@@QAE@XZ$0
__ehfuncinfo$??0CvGameSpeedInfo@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvGameSpeedInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvGameSpeedInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvGameSpeedInfo@@QAE@XZ PROC				; CvGameSpeedInfo::CvGameSpeedInfo, COMDAT
; _this$ = ecx

; 3326 : {

	push	-1
	push	__ehhandler$??0CvGameSpeedInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	edi, edi
	lea	ecx, DWORD PTR [esi+384]
	mov	DWORD PTR __$EHRec$[esp+32], edi
	mov	DWORD PTR [esi], OFFSET ??_7CvGameSpeedInfo@@6B@
	mov	DWORD PTR [esi+260], edi
	mov	DWORD PTR [esi+264], edi
	mov	DWORD PTR [esi+268], edi
	mov	DWORD PTR [esi+272], edi
	mov	DWORD PTR [esi+276], edi
	mov	DWORD PTR [esi+280], edi
	mov	DWORD PTR [esi+284], 100		; 00000064H
	mov	DWORD PTR [esi+288], edi
	mov	DWORD PTR [esi+292], edi
	mov	DWORD PTR [esi+296], edi
	mov	DWORD PTR [esi+300], edi
	mov	DWORD PTR [esi+304], edi
	mov	DWORD PTR [esi+308], edi
	mov	DWORD PTR [esi+312], edi
	mov	DWORD PTR [esi+316], edi
	mov	DWORD PTR [esi+320], edi
	mov	DWORD PTR [esi+324], edi
	mov	DWORD PTR [esi+328], edi
	mov	DWORD PTR [esi+332], edi
	mov	DWORD PTR [esi+336], edi
	mov	DWORD PTR [esi+340], edi
	mov	DWORD PTR [esi+344], edi
	mov	DWORD PTR [esi+348], edi
	mov	DWORD PTR [esi+352], edi
	mov	DWORD PTR [esi+356], edi
	mov	DWORD PTR [esi+376], edi
	mov	DWORD PTR [esi+380], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3327 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+412], edi
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvGameSpeedInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??0CvGameSpeedInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvGameSpeedInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvGameSpeedInfo@@QAE@XZ ENDP				; CvGameSpeedInfo::CvGameSpeedInfo
PUBLIC	??1CvGameSpeedInfo@@UAE@XZ			; CvGameSpeedInfo::~CvGameSpeedInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvGameSpeedInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvGameSpeedInfo@@UAE@XZ$0
__ehfuncinfo$??1CvGameSpeedInfo@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvGameSpeedInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??1CvGameSpeedInfo@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvGameSpeedInfo@@UAE@XZ PROC				; CvGameSpeedInfo::~CvGameSpeedInfo, COMDAT
; _this$ = ecx

; 3330 : {

	push	-1
	push	__ehhandler$??1CvGameSpeedInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvGameSpeedInfo@@6B@

; 3331 : 	SAFE_DELETE_ARRAY(m_pGameTurnInfo);

	mov	eax, DWORD PTR [esi+412]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 3332 : }

	lea	ecx, DWORD PTR [esi+384]
	mov	DWORD PTR [esi+412], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvGameSpeedInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??1CvGameSpeedInfo@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvGameSpeedInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvGameSpeedInfo@@UAE@XZ ENDP				; CvGameSpeedInfo::~CvGameSpeedInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvGameSpeedInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvGameSpeedInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CacheResults@CvGameSpeedInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
__ehfuncinfo$?CacheResults@CvGameSpeedInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CacheResults@CvGameSpeedInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?CacheResults@CvGameSpeedInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kArrayResults$220837 = -652				; size = 64
_kCount$220833 = -588					; size = 64
_szCountSQL$220826 = -524				; size = 256
_szSQL$220835 = -268					; size = 256
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvGameSpeedInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvGameSpeedInfo::CacheResults, COMDAT
; _this$ = ecx

; 3500 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvGameSpeedInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax

; 3501 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 640				; 00000280H
	push	ebx
	mov	ebx, DWORD PTR _kResults$[esp+652]
	push	esi
	push	eax
	push	ebx
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	je	$LN6@CacheResul@10
$LN5@CacheResul@10:
	push	ebp
	push	edi

; 3502 : 		return false;
; 3503 : 
; 3504 : 	m_iDealDuration					= kResults.GetInt("DealDuration");

	mov	edi, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG220795
	mov	ecx, ebx
	call	edi

; 3505 : 	m_iGrowthPercent				= kResults.GetInt("GrowthPercent");

	push	OFFSET $SG220796
	mov	ecx, ebx
	mov	DWORD PTR [esi+260], eax
	call	edi

; 3506 : 	m_iTrainPercent					= kResults.GetInt("TrainPercent");

	push	OFFSET $SG220797
	mov	ecx, ebx
	mov	DWORD PTR [esi+264], eax
	call	edi

; 3507 : 	m_iConstructPercent				= kResults.GetInt("ConstructPercent");

	push	OFFSET $SG220798
	mov	ecx, ebx
	mov	DWORD PTR [esi+268], eax
	call	edi

; 3508 : 	m_iCreatePercent				= kResults.GetInt("CreatePercent");

	push	OFFSET $SG220799
	mov	ecx, ebx
	mov	DWORD PTR [esi+272], eax
	call	edi

; 3509 : 	m_iResearchPercent				= kResults.GetInt("ResearchPercent");

	push	OFFSET $SG220800
	mov	ecx, ebx
	mov	DWORD PTR [esi+276], eax
	call	edi

; 3510 : 	m_iGoldPercent					= kResults.GetInt("GoldPercent");

	push	OFFSET $SG220801
	mov	ecx, ebx
	mov	DWORD PTR [esi+280], eax
	call	edi

; 3511 : 	m_iGoldGiftMod					= kResults.GetInt("GoldGiftMod");

	push	OFFSET $SG220802
	mov	ecx, ebx
	mov	DWORD PTR [esi+284], eax
	call	edi

; 3512 : 	m_iBuildPercent					= kResults.GetInt("BuildPercent");

	push	OFFSET $SG220803
	mov	ecx, ebx
	mov	DWORD PTR [esi+288], eax
	call	edi

; 3513 : 	m_iImprovementPercent			= kResults.GetInt("ImprovementPercent");

	push	OFFSET $SG220804
	mov	ecx, ebx
	mov	DWORD PTR [esi+292], eax
	call	edi

; 3514 : 	m_iGreatPeoplePercent			= kResults.GetInt("GreatPeoplePercent");

	push	OFFSET $SG220805
	mov	ecx, ebx
	mov	DWORD PTR [esi+296], eax
	call	edi

; 3515 : 	m_iCulturePercent				= kResults.GetInt("CulturePercent");

	push	OFFSET $SG220806
	mov	ecx, ebx
	mov	DWORD PTR [esi+300], eax
	call	edi

; 3516 : 	m_iFaithPercent					= kResults.GetInt("FaithPercent");

	push	OFFSET $SG220807
	mov	ecx, ebx
	mov	DWORD PTR [esi+304], eax
	call	edi

; 3517 : 	m_iBarbPercent					= kResults.GetInt("BarbPercent");

	push	OFFSET $SG220808
	mov	ecx, ebx
	mov	DWORD PTR [esi+308], eax
	call	edi

; 3518 : 	m_iFeatureProductionPercent		= kResults.GetInt("FeatureProductionPercent");

	push	OFFSET $SG220809
	mov	ecx, ebx
	mov	DWORD PTR [esi+312], eax
	call	edi

; 3519 : 	m_iUnitDiscoverPercent			= kResults.GetInt("UnitDiscoverPercent");

	push	OFFSET $SG220810
	mov	ecx, ebx
	mov	DWORD PTR [esi+316], eax
	call	edi

; 3520 : 	m_iUnitHurryPercent				= kResults.GetInt("UnitHurryPercent");

	push	OFFSET $SG220811
	mov	ecx, ebx
	mov	DWORD PTR [esi+320], eax
	call	edi

; 3521 : 	m_iUnitTradePercent				= kResults.GetInt("UnitTradePercent");

	push	OFFSET $SG220812
	mov	ecx, ebx
	mov	DWORD PTR [esi+324], eax
	call	edi

; 3522 : 	m_iGoldenAgePercent				= kResults.GetInt("GoldenAgePercent");

	push	OFFSET $SG220813
	mov	ecx, ebx
	mov	DWORD PTR [esi+328], eax
	call	edi
	mov	DWORD PTR [esi+332], eax

; 3523 : 	m_iHurryPercent					= kResults.GetInt("HurryPercent");

	push	OFFSET $SG220814
	mov	ecx, ebx
	call	edi

; 3524 : 	m_iInflationOffset				= kResults.GetInt("InflationOffset");

	push	OFFSET $SG220815
	mov	ecx, ebx
	mov	DWORD PTR [esi+336], eax
	call	edi

; 3525 : 	m_iInflationPercent				= kResults.GetInt("InflationPercent");

	push	OFFSET $SG220816
	mov	ecx, ebx
	mov	DWORD PTR [esi+340], eax
	call	edi

; 3526 : 	m_iReligiousPressureAdjacentCity= kResults.GetInt("ReligiousPressureAdjacentCity");

	push	OFFSET $SG220817
	mov	ecx, ebx
	mov	DWORD PTR [esi+348], eax
	call	edi

; 3527 : 	m_iVictoryDelayPercent			= kResults.GetInt("VictoryDelayPercent");

	push	OFFSET $SG220818
	mov	ecx, ebx
	mov	DWORD PTR [esi+344], eax
	call	edi

; 3528 : 	m_iMinorCivElectionFreqMod		= kResults.GetInt("MinorCivElectionFreqMod");

	push	OFFSET $SG220819
	mov	ecx, ebx
	mov	DWORD PTR [esi+352], eax
	call	edi

; 3529 : 	m_iOpinionDurationPercent		= kResults.GetInt("OpinionDurationPercent");

	push	OFFSET $SG220820
	mov	ecx, ebx
	mov	DWORD PTR [esi+356], eax
	call	edi

; 3530 : 	m_iSpyRatePercent				= kResults.GetInt("SpyRatePercent");

	push	OFFSET $SG220821
	mov	ecx, ebx
	mov	DWORD PTR [esi+360], eax
	call	edi

; 3531 : 	m_iPeaceDealDuration			= kResults.GetInt("PeaceDealDuration");

	push	OFFSET $SG220822
	mov	ecx, ebx
	mov	DWORD PTR [esi+364], eax
	call	edi

; 3532 : 	m_iRelationshipDuration			= kResults.GetInt("RelationshipDuration");

	push	OFFSET $SG220823
	mov	ecx, ebx
	mov	DWORD PTR [esi+368], eax
	call	edi

; 3533 : 	m_iLeaguePercent				= kResults.GetInt("LeaguePercent");

	push	OFFSET $SG220824
	mov	ecx, ebx
	mov	DWORD PTR [esi+372], eax
	call	edi

; 3534 : 
; 3535 : 	//GameTurnInfos
; 3536 : 	{
; 3537 : 		const char* szGameSpeedInfoType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+376], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ebp, eax

; 3538 : 
; 3539 : 		//Calculate number of turn increments
; 3540 : 		char szCountSQL[256];
; 3541 : 		sprintf_s(szCountSQL, "select count(*) from GameSpeed_Turns where GameSpeedType = '%s'", szGameSpeedInfoType);

	push	ebp
	lea	ecx, DWORD PTR _szCountSQL$220826[esp+672]
	push	OFFSET $SG220832
	push	ecx
	call	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ	; sprintf_s<256>
	add	esp, 12					; 0000000cH

; 3542 : 		Database::SingleResult kCount;

	push	0
	lea	ecx, DWORD PTR _kCount$220833[esp+672]
	call	DWORD PTR __imp_??0SingleResult@Database@@QAE@PBD@Z

; 3543 : 		if(DB.Execute(kCount, szCountSQL))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	mov	ebx, DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z
	push	-1
	lea	edx, DWORD PTR _szCountSQL$220826[esp+672]
	push	edx
	lea	eax, DWORD PTR _kCount$220833[esp+676]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+688], 0
	call	ebx
	test	al, al
	je	SHORT $LN4@CacheResul@10

; 3544 : 		{
; 3545 : 			m_iNumTurnIncrements = kCount.GetInt(0);

	push	0
	lea	ecx, DWORD PTR _kCount$220833[esp+672]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR [esi+380], eax
$LN4@CacheResul@10:

; 3546 : 		}
; 3547 : 
; 3548 : 		//Update turn increments
; 3549 : 		allocateGameTurnInfos(getNumTurnIncrements());

	mov	eax, DWORD PTR [esi+380]
	xor	ecx, ecx
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 3550 : 		char szSQL[256];
; 3551 : 		sprintf_s(szSQL, "select * from GameSpeed_Turns where GameSpeedType = '%s'", szGameSpeedInfoType);

	push	ebp
	mov	DWORD PTR [esi+412], eax
	lea	eax, DWORD PTR _szSQL$220835[esp+676]
	push	OFFSET $SG220836
	push	eax
	call	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ	; sprintf_s<256>
	add	esp, 16					; 00000010H

; 3552 : 		Database::Results kArrayResults;

	push	0
	lea	ecx, DWORD PTR _kArrayResults$220837[esp+672]
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z

; 3553 : 		if(DB.Execute(kArrayResults, szSQL))

	push	-1
	lea	ecx, DWORD PTR _szSQL$220835[esp+672]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	lea	edx, DWORD PTR _kArrayResults$220837[esp+676]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+688], 1
	call	ebx
	test	al, al
	je	SHORT $LN1@CacheResul@10

; 3556 : 			while(kArrayResults.Step())

	lea	ecx, DWORD PTR _kArrayResults$220837[esp+668]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN1@CacheResul@10

; 3554 : 		{
; 3555 : 			int i = 0;

	xor	ebx, ebx
	npad	8
$LL2@CacheResul@10:

; 3557 : 			{
; 3558 : 				GameTurnInfo& kInfo = getGameTurnInfo(i++);

	mov	ebp, DWORD PTR [esi+412]
	add	ebp, ebx

; 3559 : 				kInfo.iMonthIncrement = kArrayResults.GetInt("MonthIncrement");

	push	OFFSET $SG220844
	lea	ecx, DWORD PTR _kArrayResults$220837[esp+672]
	add	ebx, 8
	call	edi

; 3560 : 				kInfo.iNumGameTurnsPerIncrement = kArrayResults.GetInt("TurnsPerIncrement");

	push	OFFSET $SG220845
	lea	ecx, DWORD PTR _kArrayResults$220837[esp+672]
	mov	DWORD PTR [ebp], eax
	call	edi
	lea	ecx, DWORD PTR _kArrayResults$220837[esp+668]
	mov	DWORD PTR [ebp+4], eax
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL2@CacheResul@10
$LN1@CacheResul@10:

; 3561 : 			}
; 3562 : 		}
; 3563 : 	}

	mov	esi, DWORD PTR __imp_??1Results@Database@@UAE@XZ
	lea	ecx, DWORD PTR _kArrayResults$220837[esp+668]
	mov	BYTE PTR __$EHRec$[esp+676], 0
	call	esi
	lea	ecx, DWORD PTR _kCount$220833[esp+668]
	mov	DWORD PTR __$EHRec$[esp+676], -1
	call	esi
	pop	edi

; 3564 : 
; 3565 : 	return true;

	mov	al, 1
	pop	ebp
$LN6@CacheResul@10:

; 3566 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+660]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 652				; 0000028cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvGameSpeedInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _kCount$220833[ebp]
	jmp	??1SingleResult@Database@@UAE@XZ
__unwindfunclet$?CacheResults@CvGameSpeedInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _kArrayResults$220837[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__ehhandler$?CacheResults@CvGameSpeedInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvGameSpeedInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvGameSpeedInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvGameSpeedInfo::CacheResults
PUBLIC	??_7CvTurnTimerInfo@@6B@			; CvTurnTimerInfo::`vftable'
PUBLIC	??0CvTurnTimerInfo@@QAE@XZ			; CvTurnTimerInfo::CvTurnTimerInfo
PUBLIC	??_R4CvTurnTimerInfo@@6B@			; CvTurnTimerInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvTurnTimerInfo@@@8			; CvTurnTimerInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvTurnTimerInfo@@8				; CvTurnTimerInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvTurnTimerInfo@@8				; CvTurnTimerInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvTurnTimerInfo@@8		; CvTurnTimerInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvTurnTimerInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvTurnTimerInfo::CacheResults
PUBLIC	?readFrom@CvTurnTimerInfo@@UAEXAAVFDataStream@@@Z ; CvTurnTimerInfo::readFrom
PUBLIC	?writeTo@CvTurnTimerInfo@@UBEXAAVFDataStream@@@Z ; CvTurnTimerInfo::writeTo
;	COMDAT ??_R1A@?0A@EA@CvTurnTimerInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvTurnTimerInfo@@8 DD FLAT:??_R0?AVCvTurnTimerInfo@@@8 ; CvTurnTimerInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvTurnTimerInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvTurnTimerInfo@@8
rdata$r	SEGMENT
??_R2CvTurnTimerInfo@@8 DD FLAT:??_R1A@?0A@EA@CvTurnTimerInfo@@8 ; CvTurnTimerInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvTurnTimerInfo@@8
rdata$r	SEGMENT
??_R3CvTurnTimerInfo@@8 DD 00H				; CvTurnTimerInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvTurnTimerInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvTurnTimerInfo@@@8
_DATA	SEGMENT
??_R0?AVCvTurnTimerInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvTurnTimerInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvTurnTimerInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvTurnTimerInfo@@6B@
rdata$r	SEGMENT
??_R4CvTurnTimerInfo@@6B@ DD 00H			; CvTurnTimerInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvTurnTimerInfo@@@8
	DD	FLAT:??_R3CvTurnTimerInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvTurnTimerInfo@@6B@
CONST	SEGMENT
??_7CvTurnTimerInfo@@6B@ DD FLAT:??_R4CvTurnTimerInfo@@6B@ ; CvTurnTimerInfo::`vftable'
	DD	FLAT:?CacheResults@CvTurnTimerInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvTurnTimerInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvTurnTimerInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??8CvTurnTimerInfo@@UBE_NABV0@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvTurnTimerInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvTurnTimerInfo@@QAE@XZ PROC				; CvTurnTimerInfo::CvTurnTimerInfo, COMDAT
; _this$ = ecx

; 3577 : {}

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi+272], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvTurnTimerInfo@@6B@
	mov	eax, esi
	pop	esi
	ret	0
??0CvTurnTimerInfo@@QAE@XZ ENDP				; CvTurnTimerInfo::CvTurnTimerInfo
_TEXT	ENDS
EXTRN	__imp_?GetValue@Results@Database@@QAEXPBDAAH@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvTurnTimerInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_results$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvTurnTimerInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvTurnTimerInfo::CacheResults, COMDAT
; _this$ = ecx

; 3601 : 	if(CvBaseInfo::CacheResults(results, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _results$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	je	SHORT $LN1@CacheResul@11
	push	ebx

; 3602 : 	{
; 3603 : 		results.GetValue("BaseTime", m_iBaseTime);

	mov	ebx, DWORD PTR __imp_?GetValue@Results@Database@@QAEXPBDAAH@Z
	lea	ecx, DWORD PTR [esi+260]
	push	ecx
	push	OFFSET $SG220867
	mov	ecx, edi
	call	ebx

; 3604 : 		results.GetValue("CityResource", m_iCityResource);

	lea	edx, DWORD PTR [esi+264]
	push	edx
	push	OFFSET $SG220868
	mov	ecx, edi
	call	ebx

; 3605 : 		results.GetValue("UnitResource", m_iUnitResource);

	lea	eax, DWORD PTR [esi+268]
	push	eax
	push	OFFSET $SG220869
	mov	ecx, edi
	call	ebx

; 3606 : 		results.GetValue("FirstTurnMultiplier", m_iFirstTurnMultiplier);

	add	esi, 272				; 00000110H
	push	esi
	push	OFFSET $SG220870
	mov	ecx, edi
	call	ebx
	pop	ebx
	pop	edi

; 3607 : 
; 3608 : 		return true;

	mov	al, 1
	pop	esi

; 3612 : }

	ret	8
$LN1@CacheResul@11:
	pop	edi

; 3609 : 	}
; 3610 : 
; 3611 : 	return false;

	xor	al, al
	pop	esi

; 3612 : }

	ret	8
?CacheResults@CvTurnTimerInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvTurnTimerInfo::CacheResults
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?writeTo@CvTurnTimerInfo@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
?writeTo@CvTurnTimerInfo@@UBEXAAVFDataStream@@@Z PROC	; CvTurnTimerInfo::writeTo, COMDAT
; _this$ = ecx

; 3626 : {

	push	esi
	push	edi

; 3627 : 	CvBaseInfo::writeTo(saveTo);

	mov	edi, DWORD PTR _saveTo$[esp+4]
	push	edi
	mov	esi, ecx
	call	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z ; CvBaseInfo::writeTo

; 3628 : 	saveTo << m_iBaseTime;

	lea	eax, DWORD PTR [esi+260]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3629 : 	saveTo << m_iCityResource;

	lea	ecx, DWORD PTR [esi+264]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3630 : 	saveTo << m_iUnitResource;

	lea	edx, DWORD PTR [esi+268]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3631 : 	saveTo << m_iFirstTurnMultiplier;

	add	esi, 272				; 00000110H
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi
	pop	esi

; 3632 : }

	ret	4
?writeTo@CvTurnTimerInfo@@UBEXAAVFDataStream@@@Z ENDP	; CvTurnTimerInfo::writeTo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?readFrom@CvTurnTimerInfo@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
?readFrom@CvTurnTimerInfo@@UAEXAAVFDataStream@@@Z PROC	; CvTurnTimerInfo::readFrom, COMDAT
; _this$ = ecx

; 3635 : {

	push	esi
	push	edi

; 3636 : 	CvBaseInfo::readFrom(loadFrom);

	mov	edi, DWORD PTR _loadFrom$[esp+4]
	push	edi
	mov	esi, ecx
	call	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z ; CvBaseInfo::readFrom

; 3637 : 	loadFrom >> m_iBaseTime;

	lea	eax, DWORD PTR [esi+260]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3638 : 	loadFrom >> m_iCityResource;

	lea	ecx, DWORD PTR [esi+264]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3639 : 	loadFrom >> m_iUnitResource;

	lea	edx, DWORD PTR [esi+268]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3640 : 	loadFrom >> m_iFirstTurnMultiplier;

	add	esi, 272				; 00000110H
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi
	pop	esi

; 3641 : }

	ret	4
?readFrom@CvTurnTimerInfo@@UAEXAAVFDataStream@@@Z ENDP	; CvTurnTimerInfo::readFrom
_TEXT	ENDS
PUBLIC	??_7CvBuildInfo@@6B@				; CvBuildInfo::`vftable'
PUBLIC	??1CvBuildInfo@@UAE@XZ				; CvBuildInfo::~CvBuildInfo
PUBLIC	??_R4CvBuildInfo@@6B@				; CvBuildInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvBuildInfo@@@8				; CvBuildInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBuildInfo@@8				; CvBuildInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBuildInfo@@8				; CvBuildInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvBuildInfo@@8			; CvBuildInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvBuildInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBuildInfo::CacheResults
EXTRN	??_ECvBuildInfo@@UAEPAXI@Z:PROC			; CvBuildInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvBuildInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBuildInfo@@8 DD FLAT:??_R0?AVCvBuildInfo@@@8 ; CvBuildInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBuildInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvBuildInfo@@8
rdata$r	SEGMENT
??_R2CvBuildInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBuildInfo@@8 ; CvBuildInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvHotKeyInfo@@8
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvBuildInfo@@8
rdata$r	SEGMENT
??_R3CvBuildInfo@@8 DD 00H				; CvBuildInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvBuildInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBuildInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBuildInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBuildInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBuildInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvBuildInfo@@6B@
rdata$r	SEGMENT
??_R4CvBuildInfo@@6B@ DD 00H				; CvBuildInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvBuildInfo@@@8
	DD	FLAT:??_R3CvBuildInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvBuildInfo@@6B@
CONST	SEGMENT
??_7CvBuildInfo@@6B@ DD FLAT:??_R4CvBuildInfo@@6B@	; CvBuildInfo::`vftable'
	DD	FLAT:?CacheResults@CvBuildInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvBuildInfo@@UAEPAXI@Z
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
CONST	ENDS
;	COMDAT ??1CvBuildInfo@@UAE@XZ
_TEXT	SEGMENT
??1CvBuildInfo@@UAE@XZ PROC				; CvBuildInfo::~CvBuildInfo, COMDAT
; _this$ = ecx

; 3689 : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvBuildInfo@@6B@

; 3690 : 	SAFE_DELETE_ARRAY(m_paiFeatureTech);

	mov	eax, DWORD PTR [esi+504]
	push	edi
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	edi, edi
	mov	DWORD PTR [esi+504], edi

; 3691 : 	SAFE_DELETE_ARRAY(m_paiFeatureTime);

	mov	ecx, DWORD PTR [esi+508]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+508], edi

; 3692 : 	SAFE_DELETE_ARRAY(m_paiFeatureProduction);

	mov	edx, DWORD PTR [esi+512]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+512], edi

; 3693 : #ifdef NQ_FOOD_FROM_CHOPS
; 3694 : 	SAFE_DELETE_ARRAY(m_paiFeatureFood);

	mov	eax, DWORD PTR [esi+516]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+516], edi

; 3695 : #endif
; 3696 : 	SAFE_DELETE_ARRAY(m_paiFeatureCost);

	mov	ecx, DWORD PTR [esi+520]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+520], edi

; 3697 : 	SAFE_DELETE_ARRAY(m_paiTechTimeChange);

	mov	edx, DWORD PTR [esi+524]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+524], edi

; 3698 : 	SAFE_DELETE_ARRAY(m_pabFeatureRemove);

	mov	eax, DWORD PTR [esi+528]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR [esi+528], edi
	pop	edi

; 3699 : }

	mov	ecx, esi
	pop	esi
	jmp	??1CvHotKeyInfo@@QAE@XZ
??1CvBuildInfo@@UAE@XZ ENDP				; CvBuildInfo::~CvBuildInfo
_TEXT	ENDS
PUBLIC	?Hash@FStringA@@SAIPBD@Z			; FStringA::Hash
EXTRN	?Calc@FCRC@@QBEKPBXHK@Z:PROC			; FCRC::Calc
EXTRN	?g_CRC32@@3VFCRC@@A:BYTE			; g_CRC32
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ?Hash@FStringA@@SAIPBD@Z
_TEXT	SEGMENT
_pszStr$ = 8						; size = 4
?Hash@FStringA@@SAIPBD@Z PROC				; FStringA::Hash, COMDAT

; 998  : {

	push	esi

; 999  : 	FAssert(pszStr != NULL);
; 1000 : 	return ( g_CRC32.Calc( ( void* )pszStr, SafeStrlen(pszStr) * sizeof ( char ) ) );

	mov	esi, DWORD PTR _pszStr$[esp]
	test	esi, esi
	je	SHORT $LN5@Hash
	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL7@Hash:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL7@Hash
	push	-1
	sub	eax, edx
	push	eax
	push	esi
	mov	ecx, OFFSET ?g_CRC32@@3VFCRC@@A		; g_CRC32
	call	?Calc@FCRC@@QBEKPBXHK@Z			; FCRC::Calc
	pop	esi

; 1001 : }

	ret	0

; 999  : 	FAssert(pszStr != NULL);
; 1000 : 	return ( g_CRC32.Calc( ( void* )pszStr, SafeStrlen(pszStr) * sizeof ( char ) ) );

$LN5@Hash:
	push	-1
	xor	eax, eax
	push	eax
	push	esi
	mov	ecx, OFFSET ?g_CRC32@@3VFCRC@@A		; g_CRC32
	call	?Calc@FCRC@@QBEKPBXHK@Z			; FCRC::Calc
	pop	esi

; 1001 : }

	ret	0
?Hash@FStringA@@SAIPBD@Z ENDP				; FStringA::Hash
_TEXT	ENDS
PUBLIC	?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z ; BuildArrayHelpers::Read
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z$0
__ehfuncinfo$?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z
_TEXT	SEGMENT
_bValid$221056 = -49					; size = 1
_iNumEntries$ = -48					; size = 4
_iDummy$221066 = -44					; size = 4
_szError$221064 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
_paiBuildArray$ = 12					; size = 4
?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z PROC	; BuildArrayHelpers::Read, COMDAT

; 3923 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebp
	push	esi

; 3924 : 	int iNumEntries;
; 3925 : 	int iType;
; 3926 : 
; 3927 : 	kStream >> iNumEntries;

	mov	esi, DWORD PTR _kStream$[esp+56]
	lea	eax, DWORD PTR _iNumEntries$[esp+60]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3928 : 
; 3929 : 	for(int iI = 0; iI < iNumEntries; iI++)

	xor	ebp, ebp
	cmp	DWORD PTR _iNumEntries$[esp+60], ebp
	jle	SHORT $LN5@Read@3
$LL7@Read@3:

; 3930 : 	{
; 3931 : 		bool bValid = true;
; 3932 : 		iType = CvInfosSerializationHelper::ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$221056[esp+60]
	push	ecx
	push	esi
	mov	BYTE PTR _bValid$221056[esp+68], 1
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8

; 3933 : 		if(iType != -1 || !bValid)

	cmp	eax, -1
	jne	SHORT $LN27@Read@3
	cmp	BYTE PTR _bValid$221056[esp+60], 0
	jne	SHORT $LN6@Read@3

; 3940 : 			{
; 3941 : 				CvString szError;

	lea	ecx, DWORD PTR _szError$221064[esp+60]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3942 : 				szError.Format("LOAD ERROR: Build Type not found");

	lea	ecx, DWORD PTR _szError$221064[esp+60]
	push	OFFSET $SG221065
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+76], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3943 : 				GC.LogMessage(szError.GetCString());

	lea	ecx, DWORD PTR _szError$221064[esp+60]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage

; 3944 : 				CvAssertMsg(false, szError);
; 3945 : 
; 3946 : 				int iDummy;
; 3947 : 				kStream >> iDummy;

	lea	edx, DWORD PTR _iDummy$221066[esp+60]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3948 : 			}

	lea	ecx, DWORD PTR _szError$221064[esp+60]
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@Read@3:
	inc	ebp
	cmp	ebp, DWORD PTR _iNumEntries$[esp+60]
	jl	SHORT $LL7@Read@3
$LN5@Read@3:

; 3949 : 		}
; 3950 : 	}
; 3951 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	0
$LN27@Read@3:

; 3934 : 		{
; 3935 : 			if(iType != -1)
; 3936 : 			{
; 3937 : 				kStream >> paiBuildArray[iType];

	mov	edx, DWORD PTR _paiBuildArray$[esp+56]
	lea	eax, DWORD PTR [edx+eax*2]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 3938 : 			}
; 3939 : 			else

	jmp	SHORT $LN6@Read@3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z$0:
	lea	ecx, DWORD PTR _szError$221064[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z:
	mov	eax, OFFSET __ehfuncinfo$?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z ENDP	; BuildArrayHelpers::Read
PUBLIC	?Write@BuildArrayHelpers@@YAXAAVFDataStream@@PAFH@Z ; BuildArrayHelpers::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@BuildArrayHelpers@@YAXAAVFDataStream@@PAFH@Z
_TEXT	SEGMENT
$T233335 = -4						; size = 4
_kStream$ = 8						; size = 4
_paiBuildArray$ = 12					; size = 4
_iArraySize$ = 16					; size = 4
?Write@BuildArrayHelpers@@YAXAAVFDataStream@@PAFH@Z PROC ; BuildArrayHelpers::Write, COMDAT

; 3959 : {

	push	ecx
	push	esi
	push	edi

; 3960 : 	kStream << iArraySize;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	eax, DWORD PTR _iArraySize$[esp+8]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3961 : 
; 3962 : 	for(int iI = 0; iI < iArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _iArraySize$[esp+8], esi
	jle	SHORT $LN3@Write@3
	push	ebx
	mov	ebx, DWORD PTR _paiBuildArray$[esp+12]
$LL5@Write@3:

; 3963 : 	{
; 3964 : 		const BuildTypes eBuild = static_cast<BuildTypes>(iI);
; 3965 : 		CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 3966 : 		if(pkBuildInfo)

	test	eax, eax
	je	SHORT $LN2@Write@3

; 3967 : 		{
; 3968 : 			CvInfosSerializationHelper::WriteHashed(kStream, pkBuildInfo);

	push	eax
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 3969 : 			kStream << paiBuildArray[iI];

	push	ebx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 3970 : 		}
; 3971 : 		else

	jmp	SHORT $LN4@Write@3
$LN2@Write@3:

; 3972 : 		{
; 3973 : 			kStream << (int)0;

	lea	ecx, DWORD PTR $T233335[esp+16]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T233335[esp+20], 0
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN4@Write@3:
	inc	esi
	add	ebx, 2
	cmp	esi, DWORD PTR _iArraySize$[esp+12]
	jl	SHORT $LL5@Write@3
	pop	ebx
$LN3@Write@3:
	pop	edi
	pop	esi

; 3974 : 		}
; 3975 : 	}
; 3976 : }

	pop	ecx
	ret	0
?Write@BuildArrayHelpers@@YAXAAVFDataStream@@PAFH@Z ENDP ; BuildArrayHelpers::Write
_TEXT	ENDS
PUBLIC	??_7CvGoodyInfo@@6B@				; CvGoodyInfo::`vftable'
PUBLIC	??0CvGoodyInfo@@QAE@XZ				; CvGoodyInfo::CvGoodyInfo
PUBLIC	??_R4CvGoodyInfo@@6B@				; CvGoodyInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvGoodyInfo@@@8				; CvGoodyInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvGoodyInfo@@8				; CvGoodyInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvGoodyInfo@@8				; CvGoodyInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvGoodyInfo@@8			; CvGoodyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvGoodyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvGoodyInfo::CacheResults
;	COMDAT ??_R1A@?0A@EA@CvGoodyInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvGoodyInfo@@8 DD FLAT:??_R0?AVCvGoodyInfo@@@8 ; CvGoodyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvGoodyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvGoodyInfo@@8
rdata$r	SEGMENT
??_R2CvGoodyInfo@@8 DD FLAT:??_R1A@?0A@EA@CvGoodyInfo@@8 ; CvGoodyInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvGoodyInfo@@8
rdata$r	SEGMENT
??_R3CvGoodyInfo@@8 DD 00H				; CvGoodyInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvGoodyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvGoodyInfo@@@8
_DATA	SEGMENT
??_R0?AVCvGoodyInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvGoodyInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvGoodyInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvGoodyInfo@@6B@
rdata$r	SEGMENT
??_R4CvGoodyInfo@@6B@ DD 00H				; CvGoodyInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvGoodyInfo@@@8
	DD	FLAT:??_R3CvGoodyInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvGoodyInfo@@6B@
CONST	SEGMENT
??_7CvGoodyInfo@@6B@ DD FLAT:??_R4CvGoodyInfo@@6B@	; CvGoodyInfo::`vftable'
	DD	FLAT:?CacheResults@CvGoodyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvGoodyInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvGoodyInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvGoodyInfo@@QAE@XZ$1
__ehfuncinfo$??0CvGoodyInfo@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvGoodyInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvGoodyInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvGoodyInfo@@QAE@XZ PROC				; CvGoodyInfo::CvGoodyInfo, COMDAT
; _this$ = ecx

; 4013 : {

	push	-1
	push	__ehhandler$??0CvGoodyInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	or	ecx, -1
	mov	DWORD PTR [esi+324], ecx
	mov	DWORD PTR [esi+328], ecx
	lea	ecx, DWORD PTR [esi+340]
	mov	DWORD PTR __$EHRec$[esp+28], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvGoodyInfo@@6B@
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi+272], eax
	mov	DWORD PTR [esi+276], eax
	mov	DWORD PTR [esi+280], eax
	mov	DWORD PTR [esi+284], eax
	mov	DWORD PTR [esi+288], eax
	mov	DWORD PTR [esi+292], eax
	mov	DWORD PTR [esi+296], eax
	mov	DWORD PTR [esi+300], eax
	mov	DWORD PTR [esi+304], eax
	mov	DWORD PTR [esi+308], eax
	mov	DWORD PTR [esi+312], eax
	mov	DWORD PTR [esi+316], eax
	mov	DWORD PTR [esi+320], eax
	mov	BYTE PTR [esi+332], al
	mov	BYTE PTR [esi+333], al
	mov	BYTE PTR [esi+334], al
	mov	BYTE PTR [esi+335], al
	mov	BYTE PTR [esi+336], al
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+368]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4014 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvGoodyInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvGoodyInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvGoodyInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvGoodyInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvGoodyInfo@@QAE@XZ ENDP				; CvGoodyInfo::CvGoodyInfo
PUBLIC	?setSound@CvGoodyInfo@@QAEXPBD@Z		; CvGoodyInfo::setSound
; Function compile flags: /Ogtpy
;	COMDAT ?setSound@CvGoodyInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setSound@CvGoodyInfo@@QAEXPBD@Z PROC			; CvGoodyInfo::setSound, COMDAT
; _this$ = ecx

; 4138 : 	m_strSound = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 340				; 00000154H
	test	eax, eax
	je	SHORT $LN4@setSound
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setSound:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 4139 : }

	ret	4
?setSound@CvGoodyInfo@@QAEXPBD@Z ENDP			; CvGoodyInfo::setSound
_TEXT	ENDS
PUBLIC	?GetChooseDesc@CvGoodyInfo@@QBEPBDXZ		; CvGoodyInfo::GetChooseDesc
; Function compile flags: /Ogtpy
;	COMDAT ?GetChooseDesc@CvGoodyInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetChooseDesc@CvGoodyInfo@@QBEPBDXZ PROC		; CvGoodyInfo::GetChooseDesc, COMDAT
; _this$ = ecx

; 4143 : 	return m_strChooseDesc;

	add	ecx, 368				; 00000170H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetChooseDesc@CvGoodyInfo@@QBEPBDXZ ENDP		; CvGoodyInfo::GetChooseDesc
_TEXT	ENDS
PUBLIC	?SetChooseDesc@CvGoodyInfo@@QAEXPBD@Z		; CvGoodyInfo::SetChooseDesc
; Function compile flags: /Ogtpy
;	COMDAT ?SetChooseDesc@CvGoodyInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?SetChooseDesc@CvGoodyInfo@@QAEXPBD@Z PROC		; CvGoodyInfo::SetChooseDesc, COMDAT
; _this$ = ecx

; 4148 : 	m_strChooseDesc = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 368				; 00000170H
	test	eax, eax
	je	SHORT $LN4@SetChooseD
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@SetChooseD:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 4149 : }

	ret	4
?SetChooseDesc@CvGoodyInfo@@QAEXPBD@Z ENDP		; CvGoodyInfo::SetChooseDesc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvGoodyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_results$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvGoodyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvGoodyInfo::CacheResults, COMDAT
; _this$ = ecx

; 4153 : 	if(!CvBaseInfo::CacheResults(results, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	mov	esi, DWORD PTR _results$[esp]
	push	edi
	push	eax
	push	esi
	mov	edi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN3@CacheResul@12
	pop	edi
	pop	esi

; 4194 : }

	ret	8
$LN3@CacheResul@12:
	push	ebx
	push	ebp

; 4154 : 	{
; 4155 : 		return false;
; 4156 : 	}
; 4157 : 
; 4158 : 	const char* szChooseDesc = results.GetText("ChooseDescription");

	mov	ebp, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG221184
	mov	ecx, esi
	call	ebp

; 4159 : 	if (szChooseDesc)

	test	eax, eax
	je	SHORT $LN6@CacheResul@12

; 4160 : 		m_strChooseDesc = szChooseDesc;

	lea	ecx, DWORD PTR [edi+368]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN6@CacheResul@12:

; 4161 : 
; 4162 : 	const char* szSound = results.GetText("Sound");

	push	OFFSET $SG221187
	mov	ecx, esi
	call	ebp

; 4163 : 	if(szSound)

	test	eax, eax
	je	SHORT $LN10@CacheResul@12

; 4164 : 		m_strSound = szSound;

	lea	ecx, DWORD PTR [edi+340]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN10@CacheResul@12:

; 4165 : 
; 4166 : 	m_iGold = results.GetInt("Gold");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG221189
	mov	ecx, esi
	call	ebx

; 4167 : 	m_iNumGoldRandRolls = results.GetInt("NumGoldRandRolls");

	push	OFFSET $SG221190
	mov	ecx, esi
	mov	DWORD PTR [edi+260], eax
	call	ebx

; 4168 : 	m_iGoldRandAmount = results.GetInt("GoldRandAmount");

	push	OFFSET $SG221191
	mov	ecx, esi
	mov	DWORD PTR [edi+264], eax
	call	ebx

; 4169 : 	m_iMapOffset = results.GetInt("MapOffset");

	push	OFFSET $SG221192
	mov	ecx, esi
	mov	DWORD PTR [edi+268], eax
	call	ebx

; 4170 : 	m_iMapRange = results.GetInt("MapRange");

	push	OFFSET $SG221193
	mov	ecx, esi
	mov	DWORD PTR [edi+272], eax
	call	ebx

; 4171 : 	m_iMapProb = results.GetInt("MapProb");

	push	OFFSET $SG221194
	mov	ecx, esi
	mov	DWORD PTR [edi+276], eax
	call	ebx

; 4172 : 	m_iExperience = results.GetInt("Experience");

	push	OFFSET $SG221195
	mov	ecx, esi
	mov	DWORD PTR [edi+280], eax
	call	ebx

; 4173 : 	m_iHealing = results.GetInt("Healing");

	push	OFFSET $SG221196
	mov	ecx, esi
	mov	DWORD PTR [edi+284], eax
	call	ebx

; 4174 : 	m_iDamagePrereq = results.GetInt("DamagePrereq");

	push	OFFSET $SG221197
	mov	ecx, esi
	mov	DWORD PTR [edi+288], eax
	call	ebx

; 4175 : 	m_iPopulation = results.GetInt("Population");

	push	OFFSET $SG221198
	mov	ecx, esi
	mov	DWORD PTR [edi+292], eax
	call	ebx

; 4176 : 	m_iCulture = results.GetInt("Culture");

	push	OFFSET $SG221199
	mov	ecx, esi
	mov	DWORD PTR [edi+296], eax
	call	ebx

; 4177 : 	m_iFaith = results.GetInt("Faith");

	push	OFFSET $SG221200
	mov	ecx, esi
	mov	DWORD PTR [edi+300], eax
	call	ebx

; 4178 : 	m_iProphetPercent = results.GetInt("ProphetPercent");

	push	OFFSET $SG221201
	mov	ecx, esi
	mov	DWORD PTR [edi+304], eax
	call	ebx

; 4179 : 	m_iRevealNearbyBarbariansRange = results.GetInt("RevealNearbyBarbariansRange");

	push	OFFSET $SG221202
	mov	ecx, esi
	mov	DWORD PTR [edi+308], eax
	call	ebx

; 4180 : 	m_iBarbarianUnitProb = results.GetInt("BarbarianUnitProb");

	push	OFFSET $SG221203
	mov	ecx, esi
	mov	DWORD PTR [edi+312], eax
	call	ebx

; 4181 : 	m_iMinBarbarians = results.GetInt("MinBarbarians");

	push	OFFSET $SG221204
	mov	ecx, esi
	mov	DWORD PTR [edi+316], eax
	call	ebx

; 4182 : 	m_bTech = results.GetBool("Tech");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG221205
	mov	ecx, esi
	mov	DWORD PTR [edi+320], eax
	call	ebx

; 4183 : 	m_bBad = results.GetBool("Bad");

	push	OFFSET $SG221206
	mov	ecx, esi
	mov	BYTE PTR [edi+332], al
	call	ebx

; 4184 : 	m_bRevealUnknownResource = results.GetBool("RevealUnknownResource");

	push	OFFSET $SG221207
	mov	ecx, esi
	mov	BYTE PTR [edi+336], al
	call	ebx

; 4185 : 	m_bUpgradeUnit = results.GetBool("UpgradeUnit");

	push	OFFSET $SG221208
	mov	ecx, esi
	mov	BYTE PTR [edi+333], al
	call	ebx

; 4186 : 	m_bPantheonFaith = results.GetBool("PantheonFaith");

	push	OFFSET $SG221209
	mov	ecx, esi
	mov	BYTE PTR [edi+334], al
	call	ebx

; 4187 : 
; 4188 : 	//TEMP TEMP TEMP TEMP
; 4189 : 	m_iUnitClassType = GC.getInfoTypeForString(results.GetText("UnitClass"), true);

	push	1
	push	OFFSET $SG221210
	mov	ecx, esi
	mov	BYTE PTR [edi+335], al
	call	ebp
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4190 : 	m_iBarbarianUnitClass = GC.getInfoTypeForString(results.GetText("BarbarianUnitClass"), true);

	push	1
	push	OFFSET $SG221211
	mov	ecx, esi
	mov	DWORD PTR [edi+324], eax
	call	ebp
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	pop	ebp
	pop	ebx
	mov	DWORD PTR [edi+328], eax
	pop	edi

; 4191 : 
; 4192 : 
; 4193 : 	return true;

	mov	al, 1
	pop	esi

; 4194 : }

	ret	8
?CacheResults@CvGoodyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvGoodyInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvRouteInfo@@6B@				; CvRouteInfo::`vftable'
PUBLIC	??0CvRouteInfo@@QAE@XZ				; CvRouteInfo::CvRouteInfo
PUBLIC	??_R4CvRouteInfo@@6B@				; CvRouteInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvRouteInfo@@@8				; CvRouteInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvRouteInfo@@8				; CvRouteInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvRouteInfo@@8				; CvRouteInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvRouteInfo@@8			; CvRouteInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvRouteInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvRouteInfo::CacheResults
EXTRN	??_ECvRouteInfo@@UAEPAXI@Z:PROC			; CvRouteInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvRouteInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvRouteInfo@@8 DD FLAT:??_R0?AVCvRouteInfo@@@8 ; CvRouteInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvRouteInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvRouteInfo@@8
rdata$r	SEGMENT
??_R2CvRouteInfo@@8 DD FLAT:??_R1A@?0A@EA@CvRouteInfo@@8 ; CvRouteInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvRouteInfo@@8
rdata$r	SEGMENT
??_R3CvRouteInfo@@8 DD 00H				; CvRouteInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvRouteInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvRouteInfo@@@8
_DATA	SEGMENT
??_R0?AVCvRouteInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvRouteInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvRouteInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvRouteInfo@@6B@
rdata$r	SEGMENT
??_R4CvRouteInfo@@6B@ DD 00H				; CvRouteInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvRouteInfo@@@8
	DD	FLAT:??_R3CvRouteInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvRouteInfo@@6B@
CONST	SEGMENT
??_7CvRouteInfo@@6B@ DD FLAT:??_R4CvRouteInfo@@6B@	; CvRouteInfo::`vftable'
	DD	FLAT:?CacheResults@CvRouteInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvRouteInfo@@UAEPAXI@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvRouteInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvRouteInfo@@QAE@XZ PROC				; CvRouteInfo::CvRouteInfo, COMDAT
; _this$ = ecx

; 4209 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi+272], eax
	mov	DWORD PTR [esi+276], eax
	mov	DWORD PTR [esi+280], eax
	mov	DWORD PTR [esi+284], eax
	mov	DWORD PTR [esi+288], eax
	mov	DWORD PTR [esi+292], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvRouteInfo@@6B@

; 4210 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvRouteInfo@@QAE@XZ ENDP				; CvRouteInfo::CvRouteInfo
_TEXT	ENDS
PUBLIC	??1CvRouteInfo@@UAE@XZ				; CvRouteInfo::~CvRouteInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvRouteInfo@@UAE@XZ
_TEXT	SEGMENT
??1CvRouteInfo@@UAE@XZ PROC				; CvRouteInfo::~CvRouteInfo, COMDAT
; _this$ = ecx

; 4213 : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvRouteInfo@@6B@

; 4214 : 	SAFE_DELETE_ARRAY(m_piYieldChange);

	mov	eax, DWORD PTR [esi+284]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+284], 0

; 4215 : 	SAFE_DELETE_ARRAY(m_piTechMovementChange);

	mov	ecx, DWORD PTR [esi+288]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+288], 0

; 4216 : 	SAFE_DELETE_ARRAY(m_piResourceQuantityRequirements);

	mov	edx, DWORD PTR [esi+292]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+292], 0

; 4217 : }

	mov	ecx, esi
	pop	esi
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvRouteInfo@@UAE@XZ ENDP				; CvRouteInfo::~CvRouteInfo
_TEXT	ENDS
EXTRN	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z:PROC ; CvDatabaseUtility::SetYields
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvRouteInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvRouteInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvRouteInfo::CacheResults, COMDAT
; _this$ = ecx

; 4271 : {

	push	ebp

; 4272 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	ebp, DWORD PTR _kUtility$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+8]
	push	ebp
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@13
	pop	edi
	pop	esi
	pop	ebp

; 4291 : }

	ret	8
$LN1@CacheResul@13:
	push	ebx

; 4273 : 		return false;
; 4274 : 
; 4275 : 	m_iGoldMaintenance = kResults.GetInt("GoldMaintenance");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG221258
	mov	ecx, edi
	call	ebx

; 4276 : 	m_iAdvancedStartCost = kResults.GetInt("AdvancedStartCost");

	push	OFFSET $SG221259
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 4277 : 	m_iValue = kResults.GetInt("Value");

	push	OFFSET $SG221260
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 4278 : 	m_iMovementCost = kResults.GetInt("Movement");

	push	OFFSET $SG221261
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 4279 : 	m_iFlatMovementCost = kResults.GetInt("FlatMovement");

	push	OFFSET $SG221262
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebx

; 4280 : 
; 4281 : 	m_bIndustrial = kResults.GetBool("Industrial");

	push	OFFSET $SG221263
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	movzx	eax, al

; 4282 : 
; 4283 : 	//Arrays
; 4284 : 	const char* szRouteType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+280], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edi, eax

; 4285 : 	kUtility.SetYields(m_piYieldChange, "Route_Yields", "RouteType", szRouteType);

	push	edi
	push	OFFSET $SG221265
	push	OFFSET $SG221266
	lea	ecx, DWORD PTR [esi+284]
	push	ecx
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 4286 : 
; 4287 : 	kUtility.PopulateArrayByValue(m_piTechMovementChange, "Technologies", "Route_TechMovementChanges", "TechType", "RouteType", szRouteType, "MovementChange");

	push	0
	push	0
	push	OFFSET $SG221267
	push	edi
	push	OFFSET $SG221268
	push	OFFSET $SG221269
	push	OFFSET $SG221270
	push	OFFSET $SG221271
	lea	edx, DWORD PTR [esi+288]
	push	edx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 4288 : 	kUtility.PopulateArrayByValue(m_piResourceQuantityRequirements, "Resources", "Route_ResourceQuantityRequirements", "ResourceType", "RouteType", szRouteType, "Cost");

	push	0
	push	0
	push	OFFSET $SG221272
	push	edi
	push	OFFSET $SG221273
	push	OFFSET $SG221274
	push	OFFSET $SG221275
	push	OFFSET $SG221276
	add	esi, 292				; 00000124H
	push	esi
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue
	pop	ebx
	pop	edi
	pop	esi

; 4289 : 
; 4290 : 	return true;

	mov	al, 1
	pop	ebp

; 4291 : }

	ret	8
?CacheResults@CvRouteInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvRouteInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvResourceClassInfo@@6B@			; CvResourceClassInfo::`vftable'
PUBLIC	??0CvResourceClassInfo@@QAE@XZ			; CvResourceClassInfo::CvResourceClassInfo
PUBLIC	??_R4CvResourceClassInfo@@6B@			; CvResourceClassInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvResourceClassInfo@@@8			; CvResourceClassInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvResourceClassInfo@@8			; CvResourceClassInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvResourceClassInfo@@8			; CvResourceClassInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvResourceClassInfo@@8		; CvResourceClassInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvResourceClassInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvResourceClassInfo::CacheResults
;	COMDAT ??_R1A@?0A@EA@CvResourceClassInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvResourceClassInfo@@8 DD FLAT:??_R0?AVCvResourceClassInfo@@@8 ; CvResourceClassInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvResourceClassInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvResourceClassInfo@@8
rdata$r	SEGMENT
??_R2CvResourceClassInfo@@8 DD FLAT:??_R1A@?0A@EA@CvResourceClassInfo@@8 ; CvResourceClassInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvResourceClassInfo@@8
rdata$r	SEGMENT
??_R3CvResourceClassInfo@@8 DD 00H			; CvResourceClassInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvResourceClassInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvResourceClassInfo@@@8
_DATA	SEGMENT
??_R0?AVCvResourceClassInfo@@@8 DD FLAT:??_7type_info@@6B@ ; CvResourceClassInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvResourceClassInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvResourceClassInfo@@6B@
rdata$r	SEGMENT
??_R4CvResourceClassInfo@@6B@ DD 00H			; CvResourceClassInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvResourceClassInfo@@@8
	DD	FLAT:??_R3CvResourceClassInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvResourceClassInfo@@6B@
CONST	SEGMENT
??_7CvResourceClassInfo@@6B@ DD FLAT:??_R4CvResourceClassInfo@@6B@ ; CvResourceClassInfo::`vftable'
	DD	FLAT:?CacheResults@CvResourceClassInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvResourceClassInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvResourceClassInfo@@QAE@XZ PROC			; CvResourceClassInfo::CvResourceClassInfo, COMDAT
; _this$ = ecx

; 4298 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	mov	DWORD PTR [esi], OFFSET ??_7CvResourceClassInfo@@6B@
	mov	DWORD PTR [esi+260], 0

; 4299 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvResourceClassInfo@@QAE@XZ ENDP			; CvResourceClassInfo::CvResourceClassInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvResourceClassInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvResourceClassInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvResourceClassInfo::CacheResults, COMDAT
; _this$ = ecx

; 4308 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@14
	pop	edi
	pop	esi

; 4314 : }

	ret	8
$LN1@CacheResul@14:

; 4309 : 		return false;
; 4310 : 
; 4311 : 	m_iUniqueRange = kResults.GetInt("UniqueRange");

	push	OFFSET $SG221289
	mov	ecx, edi
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	DWORD PTR [esi+260], eax
	pop	edi

; 4312 : 
; 4313 : 	return true;

	mov	al, 1
	pop	esi

; 4314 : }

	ret	8
?CacheResults@CvResourceClassInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvResourceClassInfo::CacheResults
_TEXT	ENDS
PUBLIC	?GetIconString@CvResourceInfo@@QBEPBDXZ		; CvResourceInfo::GetIconString
; Function compile flags: /Ogtpy
;	COMDAT ?GetIconString@CvResourceInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetIconString@CvResourceInfo@@QBEPBDXZ PROC		; CvResourceInfo::GetIconString, COMDAT
; _this$ = ecx

; 4578 : 	return m_strIconString;

	add	ecx, 388				; 00000184H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetIconString@CvResourceInfo@@QBEPBDXZ ENDP		; CvResourceInfo::GetIconString
_TEXT	ENDS
PUBLIC	?SetIconString@CvResourceInfo@@QAEXPBD@Z	; CvResourceInfo::SetIconString
; Function compile flags: /Ogtpy
;	COMDAT ?SetIconString@CvResourceInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?SetIconString@CvResourceInfo@@QAEXPBD@Z PROC		; CvResourceInfo::SetIconString, COMDAT
; _this$ = ecx

; 4583 : 	m_strIconString = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 388				; 00000184H
	test	eax, eax
	je	SHORT $LN4@SetIconStr
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@SetIconStr:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 4584 : }

	ret	4
?SetIconString@CvResourceInfo@@QAEXPBD@Z ENDP		; CvResourceInfo::SetIconString
_TEXT	ENDS
PUBLIC	?getArtDefineTag@CvResourceInfo@@QBEPBDXZ	; CvResourceInfo::getArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?getArtDefineTag@CvResourceInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getArtDefineTag@CvResourceInfo@@QBEPBDXZ PROC		; CvResourceInfo::getArtDefineTag, COMDAT
; _this$ = ecx

; 4588 : 	return m_strArtDefineTag;

	add	ecx, 416				; 000001a0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getArtDefineTag@CvResourceInfo@@QBEPBDXZ ENDP		; CvResourceInfo::getArtDefineTag
_TEXT	ENDS
PUBLIC	?setArtDefineTag@CvResourceInfo@@QAEXPBD@Z	; CvResourceInfo::setArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?setArtDefineTag@CvResourceInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setArtDefineTag@CvResourceInfo@@QAEXPBD@Z PROC		; CvResourceInfo::setArtDefineTag, COMDAT
; _this$ = ecx

; 4593 : 	m_strArtDefineTag = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 416				; 000001a0H
	test	eax, eax
	je	SHORT $LN4@setArtDefi@2
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setArtDefi@2:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 4594 : }

	ret	4
?setArtDefineTag@CvResourceInfo@@QAEXPBD@Z ENDP		; CvResourceInfo::setArtDefineTag
_TEXT	ENDS
PUBLIC	?getArtDefineTagHeavy@CvResourceInfo@@QBEPBDXZ	; CvResourceInfo::getArtDefineTagHeavy
; Function compile flags: /Ogtpy
;	COMDAT ?getArtDefineTagHeavy@CvResourceInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getArtDefineTagHeavy@CvResourceInfo@@QBEPBDXZ PROC	; CvResourceInfo::getArtDefineTagHeavy, COMDAT
; _this$ = ecx

; 4598 : 	return m_strArtDefineTagHeavy;

	add	ecx, 444				; 000001bcH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getArtDefineTagHeavy@CvResourceInfo@@QBEPBDXZ ENDP	; CvResourceInfo::getArtDefineTagHeavy
_TEXT	ENDS
PUBLIC	?setArtDefineTagHeavy@CvResourceInfo@@QAEXPBD@Z	; CvResourceInfo::setArtDefineTagHeavy
; Function compile flags: /Ogtpy
;	COMDAT ?setArtDefineTagHeavy@CvResourceInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setArtDefineTagHeavy@CvResourceInfo@@QAEXPBD@Z PROC	; CvResourceInfo::setArtDefineTagHeavy, COMDAT
; _this$ = ecx

; 4603 : 	m_strArtDefineTagHeavy = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 444				; 000001bcH
	test	eax, eax
	je	SHORT $LN4@setArtDefi@3
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setArtDefi@3:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 4604 : }

	ret	4
?setArtDefineTagHeavy@CvResourceInfo@@QAEXPBD@Z ENDP	; CvResourceInfo::setArtDefineTagHeavy
_TEXT	ENDS
PUBLIC	?getAltArtDefineTag@CvResourceInfo@@QBEPBDXZ	; CvResourceInfo::getAltArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?getAltArtDefineTag@CvResourceInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getAltArtDefineTag@CvResourceInfo@@QBEPBDXZ PROC	; CvResourceInfo::getAltArtDefineTag, COMDAT
; _this$ = ecx

; 4608 : 	return m_strAltArtDefineTag;

	add	ecx, 472				; 000001d8H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getAltArtDefineTag@CvResourceInfo@@QBEPBDXZ ENDP	; CvResourceInfo::getAltArtDefineTag
_TEXT	ENDS
PUBLIC	?setAltArtDefineTag@CvResourceInfo@@QAEXPBD@Z	; CvResourceInfo::setAltArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?setAltArtDefineTag@CvResourceInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setAltArtDefineTag@CvResourceInfo@@QAEXPBD@Z PROC	; CvResourceInfo::setAltArtDefineTag, COMDAT
; _this$ = ecx

; 4613 : 	m_strAltArtDefineTag = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 472				; 000001d8H
	test	eax, eax
	je	SHORT $LN4@setAltArtD
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setAltArtD:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 4614 : }

	ret	4
?setAltArtDefineTag@CvResourceInfo@@QAEXPBD@Z ENDP	; CvResourceInfo::setAltArtDefineTag
_TEXT	ENDS
PUBLIC	?getAltArtDefineTagHeavy@CvResourceInfo@@QBEPBDXZ ; CvResourceInfo::getAltArtDefineTagHeavy
; Function compile flags: /Ogtpy
;	COMDAT ?getAltArtDefineTagHeavy@CvResourceInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getAltArtDefineTagHeavy@CvResourceInfo@@QBEPBDXZ PROC	; CvResourceInfo::getAltArtDefineTagHeavy, COMDAT
; _this$ = ecx

; 4618 : 	return m_strAltArtDefineTagHeavy;

	add	ecx, 500				; 000001f4H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getAltArtDefineTagHeavy@CvResourceInfo@@QBEPBDXZ ENDP	; CvResourceInfo::getAltArtDefineTagHeavy
_TEXT	ENDS
PUBLIC	?setAltArtDefineTagHeavy@CvResourceInfo@@QAEXPBD@Z ; CvResourceInfo::setAltArtDefineTagHeavy
; Function compile flags: /Ogtpy
;	COMDAT ?setAltArtDefineTagHeavy@CvResourceInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setAltArtDefineTagHeavy@CvResourceInfo@@QAEXPBD@Z PROC	; CvResourceInfo::setAltArtDefineTagHeavy, COMDAT
; _this$ = ecx

; 4623 : 	m_strAltArtDefineTagHeavy = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 500				; 000001f4H
	test	eax, eax
	je	SHORT $LN4@setAltArtD@2
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setAltArtD@2:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 4624 : }

	ret	4
?setAltArtDefineTagHeavy@CvResourceInfo@@QAEXPBD@Z ENDP	; CvResourceInfo::setAltArtDefineTagHeavy
_TEXT	ENDS
PUBLIC	?isHasUnitCombatProductionCostModifiersLocal@CvResourceInfo@@QBE_NXZ ; CvResourceInfo::isHasUnitCombatProductionCostModifiersLocal
; Function compile flags: /Ogtpy
;	COMDAT ?isHasUnitCombatProductionCostModifiersLocal@CvResourceInfo@@QBE_NXZ
_TEXT	SEGMENT
?isHasUnitCombatProductionCostModifiersLocal@CvResourceInfo@@QBE_NXZ PROC ; CvResourceInfo::isHasUnitCombatProductionCostModifiersLocal, COMDAT
; _this$ = ecx

; 4642 : 	return m_piiiUnitCombatProductionCostModifiersLocal.size() > 0;

	xor	eax, eax
	cmp	eax, DWORD PTR [ecx+540]
	sbb	eax, eax
	neg	eax

; 4643 : }

	ret	0
?isHasUnitCombatProductionCostModifiersLocal@CvResourceInfo@@QBE_NXZ ENDP ; CvResourceInfo::isHasUnitCombatProductionCostModifiersLocal
_TEXT	ENDS
PUBLIC	?isHasBuildingProductionCostModifiersLocal@CvResourceInfo@@QBE_NXZ ; CvResourceInfo::isHasBuildingProductionCostModifiersLocal
; Function compile flags: /Ogtpy
;	COMDAT ?isHasBuildingProductionCostModifiersLocal@CvResourceInfo@@QBE_NXZ
_TEXT	SEGMENT
?isHasBuildingProductionCostModifiersLocal@CvResourceInfo@@QBE_NXZ PROC ; CvResourceInfo::isHasBuildingProductionCostModifiersLocal, COMDAT
; _this$ = ecx

; 4705 : 	return m_aiiiBuildingProductionCostModifiersLocal.size() > 0;

	mov	edx, DWORD PTR [ecx+552]
	sub	edx, DWORD PTR [ecx+548]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	cmp	ecx, eax
	sbb	eax, eax
	neg	eax

; 4706 : }

	ret	0
?isHasBuildingProductionCostModifiersLocal@CvResourceInfo@@QBE_NXZ ENDP ; CvResourceInfo::isHasBuildingProductionCostModifiersLocal
_TEXT	ENDS
PUBLIC	??_7CvFeatureInfo@@6B@				; CvFeatureInfo::`vftable'
PUBLIC	??0CvFeatureInfo@@QAE@XZ			; CvFeatureInfo::CvFeatureInfo
PUBLIC	??_R4CvFeatureInfo@@6B@				; CvFeatureInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvFeatureInfo@@@8			; CvFeatureInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvFeatureInfo@@8				; CvFeatureInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvFeatureInfo@@8				; CvFeatureInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvFeatureInfo@@8			; CvFeatureInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvFeatureInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvFeatureInfo::CacheResults
EXTRN	??_ECvFeatureInfo@@UAEPAXI@Z:PROC		; CvFeatureInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvFeatureInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvFeatureInfo@@8 DD FLAT:??_R0?AVCvFeatureInfo@@@8 ; CvFeatureInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvFeatureInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvFeatureInfo@@8
rdata$r	SEGMENT
??_R2CvFeatureInfo@@8 DD FLAT:??_R1A@?0A@EA@CvFeatureInfo@@8 ; CvFeatureInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvFeatureInfo@@8
rdata$r	SEGMENT
??_R3CvFeatureInfo@@8 DD 00H				; CvFeatureInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvFeatureInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvFeatureInfo@@@8
_DATA	SEGMENT
??_R0?AVCvFeatureInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvFeatureInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvFeatureInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvFeatureInfo@@6B@
rdata$r	SEGMENT
??_R4CvFeatureInfo@@6B@ DD 00H				; CvFeatureInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvFeatureInfo@@@8
	DD	FLAT:??_R3CvFeatureInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvFeatureInfo@@6B@
CONST	SEGMENT
??_7CvFeatureInfo@@6B@ DD FLAT:??_R4CvFeatureInfo@@6B@	; CvFeatureInfo::`vftable'
	DD	FLAT:?CacheResults@CvFeatureInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvFeatureInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvFeatureInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvFeatureInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvFeatureInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvFeatureInfo@@QAE@XZ$2
__ehfuncinfo$??0CvFeatureInfo@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CvFeatureInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvFeatureInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvFeatureInfo@@QAE@XZ PROC				; CvFeatureInfo::CvFeatureInfo, COMDAT
; _this$ = ecx

; 5014 : {

	push	-1
	push	__ehhandler$??0CvFeatureInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	ebx, ebx
	or	eax, -1
	lea	ecx, DWORD PTR [esi+340]
	mov	DWORD PTR __$EHRec$[esp+32], ebx
	mov	DWORD PTR [esi], OFFSET ??_7CvFeatureInfo@@6B@
	mov	DWORD PTR [esi+260], ebx
	mov	DWORD PTR [esi+264], ebx
	mov	DWORD PTR [esi+268], ebx
	mov	DWORD PTR [esi+272], ebx
	mov	DWORD PTR [esi+276], ebx
	mov	DWORD PTR [esi+280], ebx
	mov	DWORD PTR [esi+284], eax
	mov	DWORD PTR [esi+288], ebx
	mov	DWORD PTR [esi+292], ebx
	mov	DWORD PTR [esi+296], ebx
	mov	DWORD PTR [esi+300], ebx
	mov	DWORD PTR [esi+304], ebx
	mov	DWORD PTR [esi+308], ebx
	mov	DWORD PTR [esi+312], ebx
	mov	DWORD PTR [esi+316], eax
	mov	BYTE PTR [esi+320], bl
	mov	BYTE PTR [esi+321], bl
	mov	BYTE PTR [esi+322], bl
	mov	BYTE PTR [esi+323], bl
	mov	BYTE PTR [esi+324], bl
	mov	BYTE PTR [esi+325], bl
	mov	BYTE PTR [esi+326], bl
	mov	BYTE PTR [esi+327], bl
	mov	BYTE PTR [esi+328], bl
	mov	BYTE PTR [esi+329], bl
	mov	BYTE PTR [esi+330], bl
	mov	BYTE PTR [esi+331], bl
	mov	BYTE PTR [esi+332], bl
	mov	BYTE PTR [esi+333], bl
	mov	BYTE PTR [esi+334], bl
	mov	DWORD PTR [esi+336], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+372]
	mov	BYTE PTR __$EHRec$[esp+32], 1
	mov	DWORD PTR [esi+368], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+420]
	mov	BYTE PTR __$EHRec$[esp+32], 2
	mov	DWORD PTR [esi+400], ebx
	mov	DWORD PTR [esi+404], ebx
	mov	DWORD PTR [esi+408], ebx
	mov	DWORD PTR [esi+412], ebx
	mov	DWORD PTR [esi+416], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5015 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvFeatureInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvFeatureInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvFeatureInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvFeatureInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvFeatureInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvFeatureInfo@@QAE@XZ ENDP				; CvFeatureInfo::CvFeatureInfo
PUBLIC	??1CvFeatureInfo@@UAE@XZ			; CvFeatureInfo::~CvFeatureInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvFeatureInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvFeatureInfo@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvFeatureInfo@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvFeatureInfo@@UAE@XZ$2
__ehfuncinfo$??1CvFeatureInfo@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1CvFeatureInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??1CvFeatureInfo@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvFeatureInfo@@UAE@XZ PROC				; CvFeatureInfo::~CvFeatureInfo, COMDAT
; _this$ = ecx

; 5018 : {

	push	-1
	push	__ehhandler$??1CvFeatureInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvFeatureInfo@@6B@

; 5019 : 	SAFE_DELETE_ARRAY(m_piYieldChange);

	mov	eax, DWORD PTR [esi+400]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], 2
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+400], ebx

; 5020 : 	SAFE_DELETE_ARRAY(m_piRiverYieldChange);

	mov	eax, DWORD PTR [esi+404]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+404], ebx

; 5021 : 	SAFE_DELETE_ARRAY(m_piHillsYieldChange);

	mov	eax, DWORD PTR [esi+408]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+408], ebx

; 5022 : 	SAFE_DELETE_ARRAY(m_pi3DAudioScriptFootstepIndex);

	mov	eax, DWORD PTR [esi+412]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+412], ebx

; 5023 : 	SAFE_DELETE_ARRAY(m_pbTerrain);

	mov	eax, DWORD PTR [esi+416]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 20					; 00000014H

; 5024 : }

	lea	ecx, DWORD PTR [esi+420]
	mov	DWORD PTR [esi+416], ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+372]
	mov	BYTE PTR __$EHRec$[esp+32], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+340]
	mov	BYTE PTR __$EHRec$[esp+32], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvFeatureInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvFeatureInfo@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvFeatureInfo@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvFeatureInfo@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvFeatureInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvFeatureInfo@@UAE@XZ ENDP				; CvFeatureInfo::~CvFeatureInfo
PUBLIC	?getArtDefineTag@CvFeatureInfo@@QBEPBDXZ	; CvFeatureInfo::getArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?getArtDefineTag@CvFeatureInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getArtDefineTag@CvFeatureInfo@@QBEPBDXZ PROC		; CvFeatureInfo::getArtDefineTag, COMDAT
; _this$ = ecx

; 5173 : 	return m_strArtDefineTag;

	add	ecx, 420				; 000001a4H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getArtDefineTag@CvFeatureInfo@@QBEPBDXZ ENDP		; CvFeatureInfo::getArtDefineTag
_TEXT	ENDS
PUBLIC	?setArtDefineTag@CvFeatureInfo@@QAEXPBD@Z	; CvFeatureInfo::setArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?setArtDefineTag@CvFeatureInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szTag$ = 8						; size = 4
?setArtDefineTag@CvFeatureInfo@@QAEXPBD@Z PROC		; CvFeatureInfo::setArtDefineTag, COMDAT
; _this$ = ecx

; 5178 : 	m_strArtDefineTag = szTag;

	mov	eax, DWORD PTR _szTag$[esp-4]
	add	ecx, 420				; 000001a4H
	test	eax, eax
	je	SHORT $LN4@setArtDefi@4
	mov	DWORD PTR _szTag$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setArtDefi@4:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 5179 : }

	ret	4
?setArtDefineTag@CvFeatureInfo@@QAEXPBD@Z ENDP		; CvFeatureInfo::setArtDefineTag
_TEXT	ENDS
PUBLIC	?getEffectType@CvFeatureInfo@@QBEPBDXZ		; CvFeatureInfo::getEffectType
; Function compile flags: /Ogtpy
;	COMDAT ?getEffectType@CvFeatureInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getEffectType@CvFeatureInfo@@QBEPBDXZ PROC		; CvFeatureInfo::getEffectType, COMDAT
; _this$ = ecx

; 5188 : 	return m_strEffectType;

	add	ecx, 340				; 00000154H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getEffectType@CvFeatureInfo@@QBEPBDXZ ENDP		; CvFeatureInfo::getEffectType
_TEXT	ENDS
PUBLIC	?getEffectTypeTag@CvFeatureInfo@@QBEPBDXZ	; CvFeatureInfo::getEffectTypeTag
; Function compile flags: /Ogtpy
;	COMDAT ?getEffectTypeTag@CvFeatureInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getEffectTypeTag@CvFeatureInfo@@QBEPBDXZ PROC		; CvFeatureInfo::getEffectTypeTag, COMDAT
; _this$ = ecx

; 5245 : 	return m_strEffectTypeTag;

	add	ecx, 372				; 00000174H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getEffectTypeTag@CvFeatureInfo@@QBEPBDXZ ENDP		; CvFeatureInfo::getEffectTypeTag
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvFeatureInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvFeatureInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvFeatureInfo::CacheResults, COMDAT
; _this$ = ecx

; 5251 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN4@CacheResul@15
	pop	edi
	pop	esi

; 5324 : }

	ret	8
$LN4@CacheResul@15:
	push	ebx
	push	ebp

; 5252 : 		return false;
; 5253 : 
; 5254 : 	const char* szArtDefineTag = kResults.GetText("ArtDefineTag");

	mov	ebp, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG222100
	mov	ecx, edi
	call	ebp

; 5255 : 	setArtDefineTag(szArtDefineTag);

	lea	ecx, DWORD PTR [esi+420]
	test	eax, eax
	je	SHORT $LN10@CacheResul@15
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN9@CacheResul@15
$LN10@CacheResul@15:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN9@CacheResul@15:

; 5256 : 
; 5257 : 	// Basic properties
; 5258 : 	m_iStartingLocationWeight = kResults.GetInt("StartingLocationWeight");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG222101
	mov	ecx, edi
	call	ebx

; 5259 : 	m_iMovementCost = kResults.GetInt("Movement");

	push	OFFSET $SG222102
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 5260 : 	m_iSeeThroughChange = kResults.GetInt("SeeThrough");

	push	OFFSET $SG222103
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 5261 : 	m_iDefenseModifier = kResults.GetInt("Defense");

	push	OFFSET $SG222104
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 5262 : 	m_iInfluenceCost = kResults.GetInt("InfluenceCost");

	push	OFFSET $SG222105
	mov	ecx, edi
	mov	DWORD PTR [esi+288], eax
	call	ebx

; 5263 : 	m_iAdvancedStartRemoveCost = kResults.GetInt("AdvancedStartRemoveCost");

	push	OFFSET $SG222106
	mov	ecx, edi
	mov	DWORD PTR [esi+292], eax
	call	ebx

; 5264 : 	m_iTurnDamage = kResults.GetInt("TurnDamage");

	push	OFFSET $SG222107
	mov	ecx, edi
	mov	DWORD PTR [esi+296], eax
	call	ebx

; 5265 : 	m_iAppearanceProbability = kResults.GetInt("AppearanceProbability");

	push	OFFSET $SG222108
	mov	ecx, edi
	mov	DWORD PTR [esi+300], eax
	call	ebx

; 5266 : 	m_iDisappearanceProbability = kResults.GetInt("DisappearanceProbability");

	push	OFFSET $SG222109
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebx

; 5267 : 	m_iGrowthProbability = kResults.GetInt("Growth");

	push	OFFSET $SG222110
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebx

; 5268 : 	m_iFirstFinderGold = kResults.GetInt("FirstFinderGold");

	push	OFFSET $SG222111
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebx

; 5269 : 	m_iInBorderHappiness = kResults.GetInt("InBorderHappiness");

	push	OFFSET $SG222112
	mov	ecx, edi
	mov	DWORD PTR [esi+304], eax
	call	ebx

; 5270 : 	m_iOccurrenceFrequency = kResults.GetInt("OccurrenceFrequency");

	push	OFFSET $SG222113
	mov	ecx, edi
	mov	DWORD PTR [esi+308], eax
	call	ebx

; 5271 : 
; 5272 : 	const char* szTextVal;
; 5273 : 	szTextVal = kResults.GetText("AdjacentUnitFreePromotion");

	push	OFFSET $SG222115
	mov	ecx, edi
	mov	DWORD PTR [esi+312], eax
	call	ebp

; 5274 : 	m_iAdjacentUnitFreePromotion = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 5275 : 
; 5276 : 	const char* szTerrainType = kResults.GetText("GrowthTerrainType");

	push	OFFSET $SG222117
	mov	ecx, edi
	mov	DWORD PTR [esi+316], eax
	call	ebp

; 5277 : 	if(szTerrainType != NULL)

	test	eax, eax
	je	SHORT $LN3@CacheResul@15

; 5278 : 	{
; 5279 : 		m_iGrowthTerrainType = GC.getInfoTypeForString(szTerrainType, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+284], eax
$LN3@CacheResul@15:

; 5280 : 	}
; 5281 : 
; 5282 : 	m_iEffectProbability = kResults.GetInt("EffectProbability");

	push	OFFSET $SG222119
	mov	ecx, edi
	call	ebx

; 5283 : 	m_bYieldNotAdditive = kResults.GetBool("YieldNotAdditive");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG222120
	mov	ecx, edi
	mov	DWORD PTR [esi+368], eax
	call	ebx

; 5284 : 	m_bNoCoast = kResults.GetBool("NoCoast");

	push	OFFSET $SG222121
	mov	ecx, edi
	mov	BYTE PTR [esi+320], al
	call	ebx

; 5285 : 	m_bNoRiver = kResults.GetBool("NoRiver");

	push	OFFSET $SG222122
	mov	ecx, edi
	mov	BYTE PTR [esi+321], al
	call	ebx

; 5286 : 	m_bNoAdjacent = kResults.GetBool("NoAdjacent");

	push	OFFSET $SG222123
	mov	ecx, edi
	mov	BYTE PTR [esi+322], al
	call	ebx

; 5287 : 	m_bRequiresFlatlands = kResults.GetBool("RequiresFlatlands");

	push	OFFSET $SG222124
	mov	ecx, edi
	mov	BYTE PTR [esi+323], al
	call	ebx

; 5288 : 	m_bRequiresRiver = kResults.GetBool("RequiresRiver");

	push	OFFSET $SG222125
	mov	ecx, edi
	mov	BYTE PTR [esi+324], al
	call	ebx

; 5289 : 	m_bAddsFreshWater = kResults.GetBool("AddsFreshWater");

	push	OFFSET $SG222126
	mov	ecx, edi
	mov	BYTE PTR [esi+325], al
	call	ebx

; 5290 : 	m_bImpassable = kResults.GetBool("Impassable");

	push	OFFSET $SG222127
	mov	ecx, edi
	mov	BYTE PTR [esi+326], al
	call	ebx

; 5291 : 	m_bNoCity = kResults.GetBool("NoCity");

	push	OFFSET $SG222128
	mov	ecx, edi
	mov	BYTE PTR [esi+327], al
	call	ebx

; 5292 : 	m_bNoImprovement = kResults.GetBool("NoImprovement");

	push	OFFSET $SG222129
	mov	ecx, edi
	mov	BYTE PTR [esi+328], al
	call	ebx

; 5293 : 	m_bVisibleAlways = kResults.GetBool("VisibleAlways");

	push	OFFSET $SG222130
	mov	ecx, edi
	mov	BYTE PTR [esi+329], al
	call	ebx

; 5294 : 	m_bNukeImmune = kResults.GetBool("NukeImmune");

	push	OFFSET $SG222131
	mov	ecx, edi
	mov	BYTE PTR [esi+330], al
	call	ebx

; 5295 : 	m_bRough = kResults.GetBool("Rough");

	push	OFFSET $SG222132
	mov	ecx, edi
	mov	BYTE PTR [esi+331], al
	call	ebx

; 5296 : 	m_bNaturalWonder = kResults.GetBool("NaturalWonder");

	push	OFFSET $SG222133
	mov	ecx, edi
	mov	BYTE PTR [esi+332], al
	call	ebx

; 5297 : 
; 5298 : 	m_strEffectType = kResults.GetText("EffectType");

	push	OFFSET $SG222134
	mov	ecx, edi
	mov	BYTE PTR [esi+333], al
	call	ebp
	lea	ecx, DWORD PTR [esi+340]
	test	eax, eax
	je	SHORT $LN14@CacheResul@15
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN13@CacheResul@15
$LN14@CacheResul@15:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN13@CacheResul@15:

; 5299 : 	m_strEffectTypeTag = kResults.GetText("EffectTypeTag");

	push	OFFSET $SG222135
	mov	ecx, edi
	call	ebp
	lea	ecx, DWORD PTR [esi+372]
	test	eax, eax
	je	SHORT $LN18@CacheResul@15
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN17@CacheResul@15
$LN18@CacheResul@15:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN17@CacheResul@15:

; 5300 : 
; 5301 : 	const char* szWorldsoundscapeAudioScript = kResults.GetText("WorldSoundscapeAudioScript");

	push	OFFSET $SG222137
	mov	ecx, edi
	call	ebp

; 5302 : 	if(szWorldsoundscapeAudioScript != NULL)

	test	eax, eax
	je	SHORT $LN2@CacheResul@15

; 5303 : 	{
; 5304 : 		m_iWorldSoundscapeScriptId = gDLL->GetAudioTagIndex(szWorldsoundscapeAudioScript, AUDIOTAG_SOUNDSCAPE);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	push	5
	push	eax
	mov	eax, DWORD PTR [edx+508]
	call	eax
	mov	DWORD PTR [esi+336], eax

; 5305 : 	}
; 5306 : 	else

	jmp	SHORT $LN1@CacheResul@15
$LN2@CacheResul@15:

; 5307 : 	{
; 5308 : 		m_iWorldSoundscapeScriptId = -1;
; 5309 : 		Remark(1, "Warning: Missing soundscape definition in XML for feature: '%s'", GetType());

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+336], -1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG222140
	push	1
	call	?Remark@@YA_NHPBDZZ			; Remark
	add	esp, 12					; 0000000cH
$LN1@CacheResul@15:

; 5310 : 	}
; 5311 : 
; 5312 : 	// Array properties
; 5313 : 	const char* szFeatureType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 5314 : 	kUtility.SetYields(m_piYieldChange, "Feature_YieldChanges", "FeatureType", szFeatureType);

	mov	ebx, DWORD PTR _kUtility$[esp+12]
	mov	edi, eax
	push	edi
	push	OFFSET $SG222142
	push	OFFSET $SG222143
	lea	ecx, DWORD PTR [esi+400]
	push	ecx
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 5315 : 	kUtility.SetYields(m_piRiverYieldChange, "Feature_RiverYieldChanges", "FeatureType", szFeatureType);

	push	edi
	push	OFFSET $SG222144
	push	OFFSET $SG222145
	lea	edx, DWORD PTR [esi+404]
	push	edx
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 5316 : 	kUtility.SetYields(m_piHillsYieldChange, "Feature_HillsYieldChanges", "FeatureType", szFeatureType);

	push	edi
	push	OFFSET $SG222146
	push	OFFSET $SG222147
	lea	eax, DWORD PTR [esi+408]
	push	eax
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 5317 : 
; 5318 : 	kUtility.PopulateArrayByExistence(m_pbTerrain, "Terrains", "Feature_TerrainBooleans", "TerrainType", "FeatureType", szFeatureType);

	push	edi
	push	OFFSET $SG222148
	push	OFFSET $SG222149
	push	OFFSET $SG222150
	push	OFFSET $SG222151
	lea	ecx, DWORD PTR [esi+416]
	push	ecx
	mov	ecx, ebx
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence
	pop	ebp
	pop	ebx
	pop	edi

; 5319 : 
; 5320 : 	// Determine of this feature is clearable - set each time the game is started
; 5321 : 	m_bClearable = false;

	mov	BYTE PTR [esi+334], 0

; 5322 : 
; 5323 : 	return true;

	mov	al, 1
	pop	esi

; 5324 : }

	ret	8
?CacheResults@CvFeatureInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvFeatureInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvYieldInfo@@6B@				; CvYieldInfo::`vftable'
PUBLIC	??0CvYieldInfo@@QAE@XZ				; CvYieldInfo::CvYieldInfo
PUBLIC	??_R4CvYieldInfo@@6B@				; CvYieldInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvYieldInfo@@@8				; CvYieldInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvYieldInfo@@8				; CvYieldInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvYieldInfo@@8				; CvYieldInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvYieldInfo@@8			; CvYieldInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvYieldInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvYieldInfo::CacheResults
;	COMDAT ??_R1A@?0A@EA@CvYieldInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvYieldInfo@@8 DD FLAT:??_R0?AVCvYieldInfo@@@8 ; CvYieldInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvYieldInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvYieldInfo@@8
rdata$r	SEGMENT
??_R2CvYieldInfo@@8 DD FLAT:??_R1A@?0A@EA@CvYieldInfo@@8 ; CvYieldInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvYieldInfo@@8
rdata$r	SEGMENT
??_R3CvYieldInfo@@8 DD 00H				; CvYieldInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvYieldInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvYieldInfo@@@8
_DATA	SEGMENT
??_R0?AVCvYieldInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvYieldInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvYieldInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvYieldInfo@@6B@
rdata$r	SEGMENT
??_R4CvYieldInfo@@6B@ DD 00H				; CvYieldInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvYieldInfo@@@8
	DD	FLAT:??_R3CvYieldInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvYieldInfo@@6B@
CONST	SEGMENT
??_7CvYieldInfo@@6B@ DD FLAT:??_R4CvYieldInfo@@6B@	; CvYieldInfo::`vftable'
	DD	FLAT:?CacheResults@CvYieldInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvYieldInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvYieldInfo@@QAE@XZ PROC				; CvYieldInfo::CvYieldInfo, COMDAT
; _this$ = ecx

; 5344 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi+272], eax
	mov	DWORD PTR [esi+276], eax
	mov	DWORD PTR [esi+280], eax
	mov	DWORD PTR [esi+284], eax
	mov	DWORD PTR [esi+288], eax
	mov	DWORD PTR [esi+292], eax
	mov	DWORD PTR [esi+296], eax
	mov	DWORD PTR [esi+300], eax
	mov	DWORD PTR [esi+304], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvYieldInfo@@6B@

; 5345 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvYieldInfo@@QAE@XZ ENDP				; CvYieldInfo::CvYieldInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvYieldInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvYieldInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvYieldInfo::CacheResults, COMDAT
; _this$ = ecx

; 5410 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@16
	pop	edi
	pop	esi

; 5429 : 
; 5430 : }

	ret	8
$LN1@CacheResul@16:
	push	ebx

; 5411 : 		return false;
; 5412 : 
; 5413 : 	kResults.GetValue("HillsChange", m_iHillsChange);

	mov	ebx, DWORD PTR __imp_?GetValue@Results@Database@@QAEXPBDAAH@Z
	lea	ecx, DWORD PTR [esi+260]
	push	ecx
	push	OFFSET $SG222197
	mov	ecx, edi
	call	ebx

; 5414 : 	kResults.GetValue("MountainChange", m_iMountainChange);

	lea	edx, DWORD PTR [esi+264]
	push	edx
	push	OFFSET $SG222198
	mov	ecx, edi
	call	ebx

; 5415 : 	kResults.GetValue("LakeChange", m_iLakeChange);

	lea	eax, DWORD PTR [esi+268]
	push	eax
	push	OFFSET $SG222199
	mov	ecx, edi
	call	ebx

; 5416 : 	kResults.GetValue("CityChange", m_iCityChange);

	lea	ecx, DWORD PTR [esi+272]
	push	ecx
	push	OFFSET $SG222200
	mov	ecx, edi
	call	ebx

; 5417 : 	kResults.GetValue("PopulationChangeOffset", m_iPopulationChangeOffset);

	lea	edx, DWORD PTR [esi+276]
	push	edx
	push	OFFSET $SG222201
	mov	ecx, edi
	call	ebx

; 5418 : 	kResults.GetValue("PopulationChangeDivisor", m_iPopulationChangeDivisor);

	lea	eax, DWORD PTR [esi+280]
	push	eax
	push	OFFSET $SG222202
	mov	ecx, edi
	call	ebx

; 5419 : 	kResults.GetValue("MinCity", m_iMinCity);

	lea	ecx, DWORD PTR [esi+284]
	push	ecx
	push	OFFSET $SG222203
	mov	ecx, edi
	call	ebx

; 5420 : #ifdef NQM_YIELD_MIN_CITY_ON_HILLS_ADJUST
; 5421 : 	kResults.GetValue("MinCityOnHillsAdjust", m_iMinCityOnHillsAdjust);

	lea	edx, DWORD PTR [esi+288]
	push	edx
	push	OFFSET $SG222204
	mov	ecx, edi
	call	ebx

; 5422 : #endif
; 5423 : 	kResults.GetValue("GoldenAgeYield", m_iGoldenAgeYield);

	lea	eax, DWORD PTR [esi+292]
	push	eax
	push	OFFSET $SG222205
	mov	ecx, edi
	call	ebx

; 5424 : 	kResults.GetValue("GoldenAgeYieldThreshold", m_iGoldenAgeYieldThreshold);

	lea	ecx, DWORD PTR [esi+296]
	push	ecx
	push	OFFSET $SG222206
	mov	ecx, edi
	call	ebx

; 5425 : 	kResults.GetValue("GoldenAgeYieldMod", m_iGoldenAgeYieldMod);

	lea	edx, DWORD PTR [esi+300]
	push	edx
	push	OFFSET $SG222207
	mov	ecx, edi
	call	ebx

; 5426 : 	kResults.GetValue("AIWeightPercent", m_iAIWeightPercent);

	add	esi, 304				; 00000130H
	push	esi
	push	OFFSET $SG222208
	mov	ecx, edi
	call	ebx
	pop	ebx
	pop	edi

; 5427 : 
; 5428 : 	return true;

	mov	al, 1
	pop	esi

; 5429 : 
; 5430 : }

	ret	8
?CacheResults@CvYieldInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvYieldInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvTerrainInfo@@6B@				; CvTerrainInfo::`vftable'
PUBLIC	??0CvTerrainInfo@@QAE@XZ			; CvTerrainInfo::CvTerrainInfo
PUBLIC	??_R4CvTerrainInfo@@6B@				; CvTerrainInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvTerrainInfo@@@8			; CvTerrainInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvTerrainInfo@@8				; CvTerrainInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvTerrainInfo@@8				; CvTerrainInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvTerrainInfo@@8			; CvTerrainInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvTerrainInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvTerrainInfo::CacheResults
EXTRN	??_ECvTerrainInfo@@UAEPAXI@Z:PROC		; CvTerrainInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvTerrainInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvTerrainInfo@@8 DD FLAT:??_R0?AVCvTerrainInfo@@@8 ; CvTerrainInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvTerrainInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvTerrainInfo@@8
rdata$r	SEGMENT
??_R2CvTerrainInfo@@8 DD FLAT:??_R1A@?0A@EA@CvTerrainInfo@@8 ; CvTerrainInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvTerrainInfo@@8
rdata$r	SEGMENT
??_R3CvTerrainInfo@@8 DD 00H				; CvTerrainInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvTerrainInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvTerrainInfo@@@8
_DATA	SEGMENT
??_R0?AVCvTerrainInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvTerrainInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvTerrainInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvTerrainInfo@@6B@
rdata$r	SEGMENT
??_R4CvTerrainInfo@@6B@ DD 00H				; CvTerrainInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvTerrainInfo@@@8
	DD	FLAT:??_R3CvTerrainInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvTerrainInfo@@6B@
CONST	SEGMENT
??_7CvTerrainInfo@@6B@ DD FLAT:??_R4CvTerrainInfo@@6B@	; CvTerrainInfo::`vftable'
	DD	FLAT:?CacheResults@CvTerrainInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvTerrainInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvTerrainInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTerrainInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvTerrainInfo@@QAE@XZ$1
__ehfuncinfo$??0CvTerrainInfo@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvTerrainInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvTerrainInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvTerrainInfo@@QAE@XZ PROC				; CvTerrainInfo::CvTerrainInfo, COMDAT
; _this$ = ecx

; 5452 : {

	push	-1
	push	__ehhandler$??0CvTerrainInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	lea	ecx, DWORD PTR [esi+312]
	mov	DWORD PTR __$EHRec$[esp+28], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvTerrainInfo@@6B@
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi+272], eax
	mov	DWORD PTR [esi+276], eax
	mov	DWORD PTR [esi+280], eax
	mov	BYTE PTR [esi+284], al
	mov	BYTE PTR [esi+285], al
	mov	BYTE PTR [esi+286], al
	mov	BYTE PTR [esi+287], al
	mov	BYTE PTR [esi+288], al
	mov	DWORD PTR [esi+292], eax
	mov	DWORD PTR [esi+296], eax
	mov	DWORD PTR [esi+300], eax
	mov	DWORD PTR [esi+304], eax
	mov	DWORD PTR [esi+308], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+340]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5453 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTerrainInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvTerrainInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 312				; 00000138H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvTerrainInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvTerrainInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTerrainInfo@@QAE@XZ ENDP				; CvTerrainInfo::CvTerrainInfo
PUBLIC	??1CvTerrainInfo@@UAE@XZ			; CvTerrainInfo::~CvTerrainInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvTerrainInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTerrainInfo@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvTerrainInfo@@UAE@XZ$1
__ehfuncinfo$??1CvTerrainInfo@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvTerrainInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??1CvTerrainInfo@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTerrainInfo@@UAE@XZ PROC				; CvTerrainInfo::~CvTerrainInfo, COMDAT
; _this$ = ecx

; 5456 : {

	push	-1
	push	__ehhandler$??1CvTerrainInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvTerrainInfo@@6B@

; 5457 : 	SAFE_DELETE_ARRAY(m_piYields);

	mov	eax, DWORD PTR [esi+296]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], 1
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+296], ebx

; 5458 : 	SAFE_DELETE_ARRAY(m_piRiverYieldChange);

	mov	eax, DWORD PTR [esi+300]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+300], ebx

; 5459 : 	SAFE_DELETE_ARRAY(m_piHillsYieldChange);

	mov	eax, DWORD PTR [esi+304]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+304], ebx

; 5460 : 	SAFE_DELETE_ARRAY(m_pi3DAudioScriptFootstepIndex);

	mov	eax, DWORD PTR [esi+308]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 5461 : }

	lea	ecx, DWORD PTR [esi+340]
	mov	DWORD PTR [esi+308], ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+312]
	mov	BYTE PTR __$EHRec$[esp+32], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTerrainInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvTerrainInfo@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 312				; 00000138H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvTerrainInfo@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvTerrainInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTerrainInfo@@UAE@XZ ENDP				; CvTerrainInfo::~CvTerrainInfo
PUBLIC	?getArtDefineTag@CvTerrainInfo@@QBEPBDXZ	; CvTerrainInfo::getArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?getArtDefineTag@CvTerrainInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getArtDefineTag@CvTerrainInfo@@QBEPBDXZ PROC		; CvTerrainInfo::getArtDefineTag, COMDAT
; _this$ = ecx

; 5520 : 	return m_strArtDefineTag;

	add	ecx, 340				; 00000154H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getArtDefineTag@CvTerrainInfo@@QBEPBDXZ ENDP		; CvTerrainInfo::getArtDefineTag
_TEXT	ENDS
PUBLIC	?setArtDefineTag@CvTerrainInfo@@QAEXPBD@Z	; CvTerrainInfo::setArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?setArtDefineTag@CvTerrainInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szTag$ = 8						; size = 4
?setArtDefineTag@CvTerrainInfo@@QAEXPBD@Z PROC		; CvTerrainInfo::setArtDefineTag, COMDAT
; _this$ = ecx

; 5525 : 	m_strArtDefineTag = szTag;

	mov	eax, DWORD PTR _szTag$[esp-4]
	add	ecx, 340				; 00000154H
	test	eax, eax
	je	SHORT $LN4@setArtDefi@5
	mov	DWORD PTR _szTag$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setArtDefi@5:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 5526 : }

	ret	4
?setArtDefineTag@CvTerrainInfo@@QAEXPBD@Z ENDP		; CvTerrainInfo::setArtDefineTag
_TEXT	ENDS
PUBLIC	?getEffectTypeTag@CvTerrainInfo@@QBEPBDXZ	; CvTerrainInfo::getEffectTypeTag
; Function compile flags: /Ogtpy
;	COMDAT ?getEffectTypeTag@CvTerrainInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getEffectTypeTag@CvTerrainInfo@@QBEPBDXZ PROC		; CvTerrainInfo::getEffectTypeTag, COMDAT
; _this$ = ecx

; 5535 : 	return m_strEffectTypeTag;

	add	ecx, 312				; 00000138H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getEffectTypeTag@CvTerrainInfo@@QBEPBDXZ ENDP		; CvTerrainInfo::getEffectTypeTag
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvTerrainInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvTerrainInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvTerrainInfo::CacheResults, COMDAT
; _this$ = ecx

; 5568 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN3@CacheResul@17
	pop	edi
	pop	esi

; 5606 : }

	ret	8
$LN3@CacheResul@17:
	push	ebx
	push	ebp

; 5569 : 		return false;
; 5570 : 
; 5571 : 	setArtDefineTag(kResults.GetText("ArtDefineTag"));

	mov	ebp, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG222287
	mov	ecx, edi
	call	ebp
	lea	ecx, DWORD PTR [esi+340]
	test	eax, eax
	je	SHORT $LN9@CacheResul@17
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN8@CacheResul@17
$LN9@CacheResul@17:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN8@CacheResul@17:

; 5572 : 
; 5573 : 	m_bWater = kResults.GetBool("Water");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG222288
	mov	ecx, edi
	call	ebx

; 5574 : 	m_bImpassable = kResults.GetBool("Impassable");

	push	OFFSET $SG222289
	mov	ecx, edi
	mov	BYTE PTR [esi+284], al
	call	ebx

; 5575 : 	m_bFound = kResults.GetBool("Found");

	push	OFFSET $SG222290
	mov	ecx, edi
	mov	BYTE PTR [esi+285], al
	call	ebx

; 5576 : 	m_bFoundCoast = kResults.GetBool("FoundCoast");

	push	OFFSET $SG222291
	mov	ecx, edi
	mov	BYTE PTR [esi+286], al
	call	ebx

; 5577 : 	m_bFoundFreshWater = kResults.GetBool("FoundFreshWater");

	push	OFFSET $SG222292
	mov	ecx, edi
	mov	BYTE PTR [esi+287], al
	call	ebx

; 5578 : 
; 5579 : 	m_iMovementCost = kResults.GetInt("Movement");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG222293
	mov	ecx, edi
	mov	BYTE PTR [esi+288], al
	call	ebx

; 5580 : 	m_iSeeFromLevel = kResults.GetInt("SeeFrom");

	push	OFFSET $SG222294
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 5581 : 	m_iSeeThroughLevel = kResults.GetInt("SeeThrough");

	push	OFFSET $SG222295
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 5582 : 	m_iBuildModifier = kResults.GetInt("BuildModifier");

	push	OFFSET $SG222296
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 5583 : 	m_iDefenseModifier = kResults.GetInt("Defense");

	push	OFFSET $SG222297
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebx

; 5584 : 	m_iInfluenceCost = kResults.GetInt("InfluenceCost");

	push	OFFSET $SG222298
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebx

; 5585 : 
; 5586 : 	const char* szTextVal = kResults.GetText("WorldSoundscapeAudioScript");

	push	OFFSET $SG222300
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebp

; 5587 : 	if(szTextVal != NULL)

	test	eax, eax
	je	SHORT $LN2@CacheResul@17

; 5588 : 	{
; 5589 : 		m_iWorldSoundscapeScriptId = gDLL->GetAudioTagIndex(szTextVal, AUDIOTAG_SOUNDSCAPE);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	push	5
	push	eax
	mov	eax, DWORD PTR [edx+508]
	call	eax
	mov	DWORD PTR [esi+292], eax

; 5590 : 	}
; 5591 : 	else

	jmp	SHORT $LN1@CacheResul@17
$LN2@CacheResul@17:

; 5592 : 	{
; 5593 : 		m_iWorldSoundscapeScriptId = -1;
; 5594 : 		Remark(1, "Warning: Missing soundscape definition in XML for feature: '%s'", GetType());

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+292], -1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG222303
	push	1
	call	?Remark@@YA_NHPBDZZ			; Remark
	add	esp, 12					; 0000000cH
$LN1@CacheResul@17:

; 5595 : 	}
; 5596 : 
; 5597 : 	//Arrays
; 5598 : 	const char* szTerrainType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ebx, eax

; 5599 : 	kUtility.SetYields(m_piYields, "Terrain_Yields", "TerrainType", szTerrainType);

	push	ebx
	push	OFFSET $SG222305
	push	OFFSET $SG222306
	lea	ecx, DWORD PTR [esi+296]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[esp+28]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 5600 : 	kUtility.SetYields(m_piRiverYieldChange, "Terrain_RiverYieldChanges", "TerrainType", szTerrainType);

	mov	ecx, DWORD PTR _kUtility$[esp+12]
	push	ebx
	push	OFFSET $SG222307
	push	OFFSET $SG222308
	lea	edx, DWORD PTR [esi+300]
	push	edx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 5601 : 	kUtility.SetYields(m_piHillsYieldChange, "Terrain_HillsYieldChanges", "TerrainType", szTerrainType);

	mov	ecx, DWORD PTR _kUtility$[esp+12]
	push	ebx
	push	OFFSET $SG222309
	push	OFFSET $SG222310
	lea	eax, DWORD PTR [esi+304]
	push	eax
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 5602 : 
; 5603 : 	m_strEffectTypeTag = kResults.GetText("EffectTypeTag");

	push	OFFSET $SG222311
	mov	ecx, edi
	call	ebp
	pop	ebp
	lea	ecx, DWORD PTR [esi+312]
	pop	ebx
	test	eax, eax
	je	SHORT $LN19@CacheResul@17
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	pop	edi

; 5604 : 
; 5605 : 	return true;

	mov	al, 1
	pop	esi

; 5606 : }

	ret	8

; 5602 : 
; 5603 : 	m_strEffectTypeTag = kResults.GetText("EffectTypeTag");

$LN19@CacheResul@17:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	pop	edi

; 5604 : 
; 5605 : 	return true;

	mov	al, 1
	pop	esi

; 5606 : }

	ret	8
?CacheResults@CvTerrainInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvTerrainInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvLeaderHeadInfo@@6B@			; CvLeaderHeadInfo::`vftable'
PUBLIC	??0CvLeaderHeadInfo@@QAE@XZ			; CvLeaderHeadInfo::CvLeaderHeadInfo
PUBLIC	??_R4CvLeaderHeadInfo@@6B@			; CvLeaderHeadInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvLeaderHeadInfo@@@8			; CvLeaderHeadInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvLeaderHeadInfo@@8			; CvLeaderHeadInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvLeaderHeadInfo@@8			; CvLeaderHeadInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvLeaderHeadInfo@@8		; CvLeaderHeadInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvLeaderHeadInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvLeaderHeadInfo::CacheResults
EXTRN	??_ECvLeaderHeadInfo@@UAEPAXI@Z:PROC		; CvLeaderHeadInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvLeaderHeadInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvLeaderHeadInfo@@8 DD FLAT:??_R0?AVCvLeaderHeadInfo@@@8 ; CvLeaderHeadInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvLeaderHeadInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvLeaderHeadInfo@@8
rdata$r	SEGMENT
??_R2CvLeaderHeadInfo@@8 DD FLAT:??_R1A@?0A@EA@CvLeaderHeadInfo@@8 ; CvLeaderHeadInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvLeaderHeadInfo@@8
rdata$r	SEGMENT
??_R3CvLeaderHeadInfo@@8 DD 00H				; CvLeaderHeadInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvLeaderHeadInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvLeaderHeadInfo@@@8
_DATA	SEGMENT
??_R0?AVCvLeaderHeadInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvLeaderHeadInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvLeaderHeadInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvLeaderHeadInfo@@6B@
rdata$r	SEGMENT
??_R4CvLeaderHeadInfo@@6B@ DD 00H			; CvLeaderHeadInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvLeaderHeadInfo@@@8
	DD	FLAT:??_R3CvLeaderHeadInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvLeaderHeadInfo@@6B@
CONST	SEGMENT
??_7CvLeaderHeadInfo@@6B@ DD FLAT:??_R4CvLeaderHeadInfo@@6B@ ; CvLeaderHeadInfo::`vftable'
	DD	FLAT:?CacheResults@CvLeaderHeadInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvLeaderHeadInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvLeaderHeadInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvLeaderHeadInfo@@QAE@XZ$0
__ehfuncinfo$??0CvLeaderHeadInfo@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvLeaderHeadInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvLeaderHeadInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvLeaderHeadInfo@@QAE@XZ PROC			; CvLeaderHeadInfo::CvLeaderHeadInfo, COMDAT
; _this$ = ecx

; 5691 : {

	push	-1
	push	__ehhandler$??0CvLeaderHeadInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	edi, edi
	lea	ecx, DWORD PTR [esi+320]
	mov	DWORD PTR __$EHRec$[esp+32], edi
	mov	DWORD PTR [esi], OFFSET ??_7CvLeaderHeadInfo@@6B@
	mov	DWORD PTR [esi+260], edi
	mov	DWORD PTR [esi+264], edi
	mov	DWORD PTR [esi+268], edi
	mov	DWORD PTR [esi+272], edi
	mov	DWORD PTR [esi+276], edi
	mov	DWORD PTR [esi+280], edi
	mov	DWORD PTR [esi+284], edi
	mov	DWORD PTR [esi+288], edi
	mov	DWORD PTR [esi+292], edi
	mov	DWORD PTR [esi+296], edi
	mov	DWORD PTR [esi+300], edi
	mov	DWORD PTR [esi+304], edi
	mov	DWORD PTR [esi+308], edi
	mov	DWORD PTR [esi+312], edi
	mov	DWORD PTR [esi+316], edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5692 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+348], edi
	mov	DWORD PTR [esi+352], edi
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvLeaderHeadInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??0CvLeaderHeadInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvLeaderHeadInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvLeaderHeadInfo@@QAE@XZ ENDP			; CvLeaderHeadInfo::CvLeaderHeadInfo
PUBLIC	??1CvLeaderHeadInfo@@UAE@XZ			; CvLeaderHeadInfo::~CvLeaderHeadInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvLeaderHeadInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvLeaderHeadInfo@@UAE@XZ$0
__ehfuncinfo$??1CvLeaderHeadInfo@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvLeaderHeadInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??1CvLeaderHeadInfo@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvLeaderHeadInfo@@UAE@XZ PROC			; CvLeaderHeadInfo::~CvLeaderHeadInfo, COMDAT
; _this$ = ecx

; 5695 : {

	push	-1
	push	__ehhandler$??1CvLeaderHeadInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvLeaderHeadInfo@@6B@

; 5696 : 	SAFE_DELETE_ARRAY(m_piMajorCivApproachBiases);

	mov	eax, DWORD PTR [esi+312]
	xor	edi, edi
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], edi
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+312], edi

; 5697 : 	SAFE_DELETE_ARRAY(m_piMinorCivApproachBiases);

	mov	eax, DWORD PTR [esi+316]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+316], edi

; 5698 : 	SAFE_DELETE_ARRAY(m_pbTraits);

	mov	eax, DWORD PTR [esi+348]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+348], edi

; 5699 : 	SAFE_DELETE_ARRAY(m_piFlavorValue);

	mov	eax, DWORD PTR [esi+352]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 5700 : }

	lea	ecx, DWORD PTR [esi+320]
	mov	DWORD PTR [esi+352], edi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvLeaderHeadInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??1CvLeaderHeadInfo@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvLeaderHeadInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvLeaderHeadInfo@@UAE@XZ ENDP			; CvLeaderHeadInfo::~CvLeaderHeadInfo
PUBLIC	?getArtDefineTag@CvLeaderHeadInfo@@QBEPBDXZ	; CvLeaderHeadInfo::getArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?getArtDefineTag@CvLeaderHeadInfo@@QBEPBDXZ
_TEXT	SEGMENT
?getArtDefineTag@CvLeaderHeadInfo@@QBEPBDXZ PROC	; CvLeaderHeadInfo::getArtDefineTag, COMDAT
; _this$ = ecx

; 5783 : 	return m_strArtDefineTag;

	add	ecx, 320				; 00000140H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?getArtDefineTag@CvLeaderHeadInfo@@QBEPBDXZ ENDP	; CvLeaderHeadInfo::getArtDefineTag
_TEXT	ENDS
PUBLIC	?setArtDefineTag@CvLeaderHeadInfo@@QAEXPBD@Z	; CvLeaderHeadInfo::setArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?setArtDefineTag@CvLeaderHeadInfo@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?setArtDefineTag@CvLeaderHeadInfo@@QAEXPBD@Z PROC	; CvLeaderHeadInfo::setArtDefineTag, COMDAT
; _this$ = ecx

; 5788 : 	m_strArtDefineTag = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 320				; 00000140H
	test	eax, eax
	je	SHORT $LN4@setArtDefi@6
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@setArtDefi@6:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 5789 : }

	ret	4
?setArtDefineTag@CvLeaderHeadInfo@@QAEXPBD@Z ENDP	; CvLeaderHeadInfo::setArtDefineTag
_TEXT	ENDS
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvLeaderHeadInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvLeaderHeadInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvLeaderHeadInfo::CacheResults, COMDAT
; _this$ = ecx

; 5811 : {

	push	ebp

; 5812 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	ebp, DWORD PTR _kUtility$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+8]
	push	ebp
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@18
	pop	edi
	pop	esi
	pop	ebp

; 5847 : }

	ret	8
$LN1@CacheResul@18:

; 5813 : 		return false;
; 5814 : 
; 5815 : 	//Basic Properties
; 5816 : 
; 5817 : 	const char* szTextVal = NULL;	//Temp storage
; 5818 : 	szTextVal = kResults.GetText("ArtDefineTag");

	push	OFFSET $SG222429
	mov	ecx, edi
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 5819 : 	setArtDefineTag(szTextVal);

	lea	ecx, DWORD PTR [esi+320]
	test	eax, eax
	je	SHORT $LN7@CacheResul@18
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN6@CacheResul@18
$LN7@CacheResul@18:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN6@CacheResul@18:
	push	ebx

; 5820 : 
; 5821 : 	m_iVictoryCompetitiveness					= kResults.GetInt("VictoryCompetitiveness");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG222430
	mov	ecx, edi
	call	ebx

; 5822 : 	m_iWonderCompetitiveness					= kResults.GetInt("WonderCompetitiveness");

	push	OFFSET $SG222431
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 5823 : 	m_iMinorCivCompetitiveness					= kResults.GetInt("MinorCivCompetitiveness");

	push	OFFSET $SG222432
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 5824 : 	m_iBoldness									= kResults.GetInt("Boldness");

	push	OFFSET $SG222433
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 5825 : 	m_iDiploBalance									= kResults.GetInt("DiploBalance");

	push	OFFSET $SG222434
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebx

; 5826 : 	m_iWarmongerHate									= kResults.GetInt("WarmongerHate");

	push	OFFSET $SG222435
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebx

; 5827 : 	m_iDenounceWillingness									= kResults.GetInt("DenounceWillingness");

	push	OFFSET $SG222436
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebx

; 5828 : 	m_iDoFWillingness									= kResults.GetInt("DoFWillingness");

	push	OFFSET $SG222437
	mov	ecx, edi
	mov	DWORD PTR [esi+284], eax
	call	ebx

; 5829 : 	m_iLoyalty									= kResults.GetInt("Loyalty");

	push	OFFSET $SG222438
	mov	ecx, edi
	mov	DWORD PTR [esi+288], eax
	call	ebx

; 5830 : 	m_iNeediness									= kResults.GetInt("Neediness");

	push	OFFSET $SG222439
	mov	ecx, edi
	mov	DWORD PTR [esi+292], eax
	call	ebx

; 5831 : 	m_iForgiveness									= kResults.GetInt("Forgiveness");

	push	OFFSET $SG222440
	mov	ecx, edi
	mov	DWORD PTR [esi+296], eax
	call	ebx

; 5832 : 	m_iChattiness									= kResults.GetInt("Chattiness");

	push	OFFSET $SG222441
	mov	ecx, edi
	mov	DWORD PTR [esi+300], eax
	call	ebx

; 5833 : 	m_iMeanness									= kResults.GetInt("Meanness");

	push	OFFSET $SG222442
	mov	ecx, edi
	mov	DWORD PTR [esi+304], eax
	call	ebx

; 5834 : 
; 5835 : 	//Arrays
; 5836 : 	const char* szType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+308], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 5837 : 
; 5838 : 	kUtility.SetFlavors(m_piFlavorValue, "Leader_Flavors", "LeaderType", szType);

	push	0
	mov	edi, eax
	push	edi
	push	OFFSET $SG222444
	push	OFFSET $SG222445
	lea	eax, DWORD PTR [esi+352]
	push	eax
	mov	ecx, ebp
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 5839 : 
; 5840 : 	kUtility.PopulateArrayByValue(m_piMajorCivApproachBiases, "MajorCivApproachTypes", "Leader_MajorCivApproachBiases", "MajorCivApproachType", "LeaderType", szType, "Bias");

	push	0
	push	0
	push	OFFSET $SG222446
	push	edi
	push	OFFSET $SG222447
	push	OFFSET $SG222448
	push	OFFSET $SG222449
	push	OFFSET $SG222450
	lea	ecx, DWORD PTR [esi+312]
	push	ecx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 5841 : 
; 5842 : 	kUtility.PopulateArrayByValue(m_piMinorCivApproachBiases, "MinorCivApproachTypes", "Leader_MinorCivApproachBiases", "MinorCivApproachType", "LeaderType", szType, "Bias");

	push	0
	push	0
	push	OFFSET $SG222451
	push	edi
	push	OFFSET $SG222452
	push	OFFSET $SG222453
	push	OFFSET $SG222454
	push	OFFSET $SG222455
	lea	edx, DWORD PTR [esi+316]
	push	edx
	mov	ecx, ebp
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 5843 : 
; 5844 : 	kUtility.PopulateArrayByExistence(m_pbTraits, "Traits", "Leader_Traits", "TraitType", "LeaderType", szType);

	push	edi
	push	OFFSET $SG222456
	push	OFFSET $SG222457
	push	OFFSET $SG222458
	push	OFFSET $SG222459
	add	esi, 348				; 0000015cH
	push	esi
	mov	ecx, ebp
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence
	pop	ebx
	pop	edi
	pop	esi

; 5845 : 
; 5846 : 	return true;

	mov	al, 1
	pop	ebp

; 5847 : }

	ret	8
?CacheResults@CvLeaderHeadInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvLeaderHeadInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvWorldInfo@@6B@				; CvWorldInfo::`vftable'
PUBLIC	??0CvWorldInfo@@QAE@XZ				; CvWorldInfo::CvWorldInfo
PUBLIC	??_R4CvWorldInfo@@6B@				; CvWorldInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvWorldInfo@@@8				; CvWorldInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvWorldInfo@@8				; CvWorldInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvWorldInfo@@8				; CvWorldInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvWorldInfo@@8			; CvWorldInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvWorldInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvWorldInfo::CacheResults
PUBLIC	?readFrom@CvWorldInfo@@UAEXAAVFDataStream@@@Z	; CvWorldInfo::readFrom
PUBLIC	?writeTo@CvWorldInfo@@UBEXAAVFDataStream@@@Z	; CvWorldInfo::writeTo
;	COMDAT ??_R1A@?0A@EA@CvWorldInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvWorldInfo@@8 DD FLAT:??_R0?AVCvWorldInfo@@@8 ; CvWorldInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvWorldInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvWorldInfo@@8
rdata$r	SEGMENT
??_R2CvWorldInfo@@8 DD FLAT:??_R1A@?0A@EA@CvWorldInfo@@8 ; CvWorldInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvWorldInfo@@8
rdata$r	SEGMENT
??_R3CvWorldInfo@@8 DD 00H				; CvWorldInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvWorldInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvWorldInfo@@@8
_DATA	SEGMENT
??_R0?AVCvWorldInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvWorldInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvWorldInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvWorldInfo@@6B@
rdata$r	SEGMENT
??_R4CvWorldInfo@@6B@ DD 00H				; CvWorldInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvWorldInfo@@@8
	DD	FLAT:??_R3CvWorldInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvWorldInfo@@6B@
CONST	SEGMENT
??_7CvWorldInfo@@6B@ DD FLAT:??_R4CvWorldInfo@@6B@	; CvWorldInfo::`vftable'
	DD	FLAT:?CacheResults@CvWorldInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvWorldInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvWorldInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??8CvWorldInfo@@UBE_NABV0@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvWorldInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvWorldInfo@@QAE@XZ PROC				; CvWorldInfo::CvWorldInfo, COMDAT
; _this$ = ecx

; 5873 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi+272], eax
	mov	DWORD PTR [esi+276], eax
	mov	DWORD PTR [esi+280], eax
	mov	DWORD PTR [esi+284], eax
	mov	DWORD PTR [esi+288], eax
	mov	DWORD PTR [esi+292], eax
	mov	DWORD PTR [esi+296], eax
	mov	DWORD PTR [esi+300], eax
	mov	DWORD PTR [esi+304], eax
	mov	DWORD PTR [esi+308], eax
	mov	DWORD PTR [esi+312], eax
	mov	DWORD PTR [esi+316], eax
	mov	DWORD PTR [esi+320], eax
	mov	DWORD PTR [esi+336], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvWorldInfo@@6B@
	mov	DWORD PTR [esi+324], 100		; 00000064H
	mov	DWORD PTR [esi+328], 10			; 0000000aH
	mov	DWORD PTR [esi+332], 5

; 5874 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvWorldInfo@@QAE@XZ ENDP				; CvWorldInfo::CvWorldInfo
_TEXT	ENDS
PUBLIC	?getMaxActiveReligions@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getMaxActiveReligions
EXTRN	?countMajorCivsEverAlive@CvGame@@QBEHXZ:PROC	; CvGame::countMajorCivsEverAlive
EXTRN	?isOption@CvGame@@QBE_NPBD@Z:PROC		; CvGame::isOption
; Function compile flags: /Ogtpy
;	COMDAT ?getMaxActiveReligions@CvWorldInfo@@QBEHXZ
_TEXT	SEGMENT
?getMaxActiveReligions@CvWorldInfo@@QBEHXZ PROC		; CvWorldInfo::getMaxActiveReligions, COMDAT
; _this$ = ecx

; 5932 : {

	push	esi
	mov	esi, ecx

; 5933 : #ifdef NQ_ALLOW_EXTRA_RELIGIONS
; 5934 : 	if (GC.getGame().isOption("GAMEOPTION_ALLOW_EXTRA_RELIGIONS"))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG222500
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	je	SHORT $LN1@getMaxActi

; 5935 : 	{
; 5936 : 		return GC.getGame().countMajorCivsEverAlive();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	pop	esi
	jmp	?countMajorCivsEverAlive@CvGame@@QBEHXZ	; CvGame::countMajorCivsEverAlive
$LN1@getMaxActi:

; 5937 : 	}
; 5938 : #endif
; 5939 : 
; 5940 : 	return m_iMaxActiveReligions;

	mov	eax, DWORD PTR [esi+304]
	pop	esi

; 5941 : }

	ret	0
?getMaxActiveReligions@CvWorldInfo@@QBEHXZ ENDP		; CvWorldInfo::getMaxActiveReligions
_TEXT	ENDS
PUBLIC	??1CvWorldInfo@@QAE@XZ				; CvWorldInfo::~CvWorldInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvWorldInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvWorldInfo@@QAE@XZ PROC				; CvWorldInfo::~CvWorldInfo, COMDAT
; _this$ = ecx
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvWorldInfo@@QAE@XZ ENDP				; CvWorldInfo::~CvWorldInfo
_TEXT	ENDS
PUBLIC	??0CvBaseInfo@@QAE@ABV0@@Z			; CvBaseInfo::CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CvBaseInfo@@QAE@ABV0@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??0CvBaseInfo@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvBaseInfo@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0CvBaseInfo@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0CvBaseInfo@@QAE@ABV0@@Z PROC				; CvBaseInfo::CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0CvBaseInfo@@QAE@ABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	DWORD PTR [esi], OFFSET ??_7CvBaseInfo@@6B@
	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [esi+8]
	push	edx
	mov	DWORD PTR _this$[esp+28], esi
	mov	DWORD PTR [esi+4], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	eax, DWORD PTR [edi+36]
	lea	ecx, DWORD PTR [esi+36]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	edx, DWORD PTR [edi+64]
	lea	ecx, DWORD PTR [esi+64]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+36], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	eax, DWORD PTR [edi+92]
	lea	ecx, DWORD PTR [esi+92]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+36], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	edx, DWORD PTR [edi+120]
	lea	ecx, DWORD PTR [esi+120]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+36], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	eax, DWORD PTR [edi+148]
	lea	ecx, DWORD PTR [esi+148]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+36], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	edx, DWORD PTR [edi+176]
	lea	ecx, DWORD PTR [esi+176]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+36], 5
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	eax, DWORD PTR [edi+204]
	lea	ecx, DWORD PTR [esi+204]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+36], 6
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	add	edi, 232				; 000000e8H
	push	edi
	lea	ecx, DWORD PTR [esi+232]
	mov	BYTE PTR __$EHRec$[esp+36], 7
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBaseInfo@@QAE@ABV0@@Z$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvBaseInfo@@QAE@ABV0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0CvBaseInfo@@QAE@ABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvBaseInfo@@QAE@ABV0@@Z ENDP				; CvBaseInfo::CvBaseInfo
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvWorldInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvWorldInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvWorldInfo::CacheResults, COMDAT
; _this$ = ecx

; 6005 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@19
	pop	edi
	pop	esi

; 6030 : }

	ret	8
$LN1@CacheResul@19:
	push	ebx

; 6006 : 		return false;
; 6007 : 
; 6008 : 	m_iDefaultPlayers				= kResults.GetInt("DefaultPlayers");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG222555
	mov	ecx, edi
	call	ebx

; 6009 : 	m_iDefaultMinorCivs				= kResults.GetInt("DefaultMinorCivs");

	push	OFFSET $SG222556
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 6010 : 	m_iFogTilesPerBarbarianCamp		= kResults.GetInt("FogTilesPerBarbarianCamp");

	push	OFFSET $SG222557
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 6011 : 	m_iNumNaturalWonders			= kResults.GetInt("NumNaturalWonders");

	push	OFFSET $SG222558
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 6012 : 	m_iUnitNameModifier				= kResults.GetInt("UnitNameModifier");

	push	OFFSET $SG222559
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebx

; 6013 : 	m_iTargetNumCities				= kResults.GetInt("TargetNumCities");

	push	OFFSET $SG222560
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebx

; 6014 : 	m_iNumFreeBuildingResources		= kResults.GetInt("NumFreeBuildingResources");

	push	OFFSET $SG222561
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebx

; 6015 : 	m_iBuildingClassPrereqModifier	= kResults.GetInt("BuildingClassPrereqModifier");

	push	OFFSET $SG222562
	mov	ecx, edi
	mov	DWORD PTR [esi+284], eax
	call	ebx

; 6016 : 	m_iMaxConscriptModifier			= kResults.GetInt("MaxConscriptModifier");

	push	OFFSET $SG222563
	mov	ecx, edi
	mov	DWORD PTR [esi+288], eax
	call	ebx

; 6017 : 	m_iGridWidth					= kResults.GetInt("GridWidth");

	push	OFFSET $SG222564
	mov	ecx, edi
	mov	DWORD PTR [esi+292], eax
	call	ebx

; 6018 : 	m_iGridHeight					= kResults.GetInt("GridHeight");

	push	OFFSET $SG222565
	mov	ecx, edi
	mov	DWORD PTR [esi+296], eax
	call	ebx

; 6019 : 	m_iMaxActiveReligions			= kResults.GetInt("MaxActiveReligions");

	push	OFFSET $SG222566
	mov	ecx, edi
	mov	DWORD PTR [esi+300], eax
	call	ebx

; 6020 : 	m_iTerrainGrainChange			= kResults.GetInt("TerrainGrainChange");

	push	OFFSET $SG222567
	mov	ecx, edi
	mov	DWORD PTR [esi+304], eax
	call	ebx

; 6021 : 	m_iFeatureGrainChange			= kResults.GetInt("FeatureGrainChange");

	push	OFFSET $SG222568
	mov	ecx, edi
	mov	DWORD PTR [esi+308], eax
	call	ebx

; 6022 : 	m_iResearchPercent				= kResults.GetInt("ResearchPercent");

	push	OFFSET $SG222569
	mov	ecx, edi
	mov	DWORD PTR [esi+312], eax
	call	ebx

; 6023 : 	m_iAdvancedStartPointsMod		= kResults.GetInt("AdvancedStartPointsMod");

	push	OFFSET $SG222570
	mov	ecx, edi
	mov	DWORD PTR [esi+316], eax
	call	ebx

; 6024 : 	m_iNumCitiesUnhappinessPercent	= kResults.GetInt("NumCitiesUnhappinessPercent");

	push	OFFSET $SG222571
	mov	ecx, edi
	mov	DWORD PTR [esi+320], eax
	call	ebx

; 6025 : 	m_iNumCitiesPolicyCostMod		= kResults.GetInt("NumCitiesPolicyCostMod");

	push	OFFSET $SG222572
	mov	ecx, edi
	mov	DWORD PTR [esi+324], eax
	call	ebx

; 6026 : 	m_iNumCitiesTechCostMod			= kResults.GetInt("NumCitiesTechCostMod");

	push	OFFSET $SG222573
	mov	ecx, edi
	mov	DWORD PTR [esi+328], eax
	call	ebx

; 6027 : 	m_iEstimatedNumCities			= kResults.GetInt("EstimatedNumCities");

	push	OFFSET $SG222574
	mov	ecx, edi
	mov	DWORD PTR [esi+332], eax
	call	ebx
	pop	ebx
	mov	DWORD PTR [esi+336], eax
	pop	edi

; 6028 : 
; 6029 : 	return true;

	mov	al, 1
	pop	esi

; 6030 : }

	ret	8
?CacheResults@CvWorldInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvWorldInfo::CacheResults
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?readFrom@CvWorldInfo@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_iVersion$ = 8						; size = 4
_loadFrom$ = 8						; size = 4
?readFrom@CvWorldInfo@@UAEXAAVFDataStream@@@Z PROC	; CvWorldInfo::readFrom, COMDAT
; _this$ = ecx

; 6064 : {

	push	esi
	push	edi

; 6065 : 	int iVersion;
; 6066 : 	loadFrom >> iVersion;				// Make sure to update versioning if the members change!

	mov	edi, DWORD PTR _loadFrom$[esp+4]
	lea	eax, DWORD PTR _iVersion$[esp+4]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6067 : 
; 6068 : 	CvBaseInfo::readFrom(loadFrom);

	push	edi
	mov	ecx, esi
	call	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z ; CvBaseInfo::readFrom

; 6069 : 
; 6070 : 	loadFrom >> m_iDefaultPlayers;

	lea	ecx, DWORD PTR [esi+260]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6071 : 	loadFrom >> m_iDefaultMinorCivs;

	lea	edx, DWORD PTR [esi+264]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6072 : 	loadFrom >> m_iFogTilesPerBarbarianCamp;

	lea	eax, DWORD PTR [esi+268]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6073 : 	loadFrom >> m_iNumNaturalWonders;

	lea	ecx, DWORD PTR [esi+272]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6074 : 	loadFrom >> m_iUnitNameModifier;

	lea	edx, DWORD PTR [esi+276]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6075 : 	loadFrom >> m_iTargetNumCities;

	lea	eax, DWORD PTR [esi+280]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6076 : 	loadFrom >> m_iNumFreeBuildingResources;

	lea	ecx, DWORD PTR [esi+284]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6077 : 	loadFrom >> m_iBuildingClassPrereqModifier;

	lea	edx, DWORD PTR [esi+288]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6078 : 	loadFrom >> m_iMaxConscriptModifier;

	lea	eax, DWORD PTR [esi+292]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6079 : 	loadFrom >> m_iGridWidth;

	lea	ecx, DWORD PTR [esi+296]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6080 : 	loadFrom >> m_iGridHeight;

	lea	edx, DWORD PTR [esi+300]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6081 : 	loadFrom >> m_iMaxActiveReligions;

	lea	eax, DWORD PTR [esi+304]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6082 : 	loadFrom >> m_iTerrainGrainChange;

	lea	ecx, DWORD PTR [esi+308]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6083 : 	loadFrom >> m_iFeatureGrainChange;

	lea	edx, DWORD PTR [esi+312]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6084 : 	loadFrom >> m_iResearchPercent;

	lea	eax, DWORD PTR [esi+316]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6085 : 	loadFrom >> m_iAdvancedStartPointsMod;

	lea	ecx, DWORD PTR [esi+320]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6086 : 	loadFrom >> m_iNumCitiesUnhappinessPercent;

	lea	edx, DWORD PTR [esi+324]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6087 : 	loadFrom >> m_iNumCitiesPolicyCostMod;

	lea	eax, DWORD PTR [esi+328]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6088 : 
; 6089 : 	if (iVersion >= 2)

	cmp	DWORD PTR _iVersion$[esp+4], 2
	jl	SHORT $LN2@readFrom

; 6090 : 	{
; 6091 : 		loadFrom >> m_iNumCitiesTechCostMod;

	add	esi, 332				; 0000014cH
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi
	pop	esi

; 6096 : 	}
; 6097 : }

	ret	4
$LN2@readFrom:
	pop	edi

; 6092 : 	}
; 6093 : 	else
; 6094 : 	{
; 6095 : 		m_iNumCitiesTechCostMod = 0;

	mov	DWORD PTR [esi+332], 0
	pop	esi

; 6096 : 	}
; 6097 : }

	ret	4
?readFrom@CvWorldInfo@@UAEXAAVFDataStream@@@Z ENDP	; CvWorldInfo::readFrom
_TEXT	ENDS
PUBLIC	?readFromVersion0@CvWorldInfo@@QAEXAAVFDataStream@@@Z ; CvWorldInfo::readFromVersion0
; Function compile flags: /Ogtpy
;	COMDAT ?readFromVersion0@CvWorldInfo@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
?readFromVersion0@CvWorldInfo@@QAEXAAVFDataStream@@@Z PROC ; CvWorldInfo::readFromVersion0, COMDAT
; _this$ = ecx

; 6101 : {

	push	esi
	push	edi

; 6102 : 	CvBaseInfo::readFrom(loadFrom);

	mov	edi, DWORD PTR _loadFrom$[esp+4]
	push	edi
	mov	esi, ecx
	call	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z ; CvBaseInfo::readFrom

; 6103 : 	loadFrom >> m_iDefaultPlayers;

	lea	eax, DWORD PTR [esi+260]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6104 : 	loadFrom >> m_iDefaultMinorCivs;

	lea	ecx, DWORD PTR [esi+264]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6105 : 	loadFrom >> m_iFogTilesPerBarbarianCamp;

	lea	edx, DWORD PTR [esi+268]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6106 : 	loadFrom >> m_iNumNaturalWonders;

	lea	eax, DWORD PTR [esi+272]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6107 : 	loadFrom >> m_iUnitNameModifier;

	lea	ecx, DWORD PTR [esi+276]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6108 : 	loadFrom >> m_iTargetNumCities;

	lea	edx, DWORD PTR [esi+280]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6109 : 	loadFrom >> m_iNumFreeBuildingResources;

	lea	eax, DWORD PTR [esi+284]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6110 : 	loadFrom >> m_iBuildingClassPrereqModifier;

	lea	ecx, DWORD PTR [esi+288]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6111 : 	loadFrom >> m_iMaxConscriptModifier;

	lea	edx, DWORD PTR [esi+292]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6112 : 	loadFrom >> m_iGridWidth;

	lea	eax, DWORD PTR [esi+296]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6113 : 	loadFrom >> m_iGridHeight;

	lea	ecx, DWORD PTR [esi+300]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6114 : 	loadFrom >> m_iTerrainGrainChange;

	lea	edx, DWORD PTR [esi+308]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6115 : 	loadFrom >> m_iFeatureGrainChange;

	lea	eax, DWORD PTR [esi+312]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6116 : 	loadFrom >> m_iResearchPercent;

	lea	ecx, DWORD PTR [esi+316]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6117 : 	loadFrom >> m_iAdvancedStartPointsMod;

	lea	edx, DWORD PTR [esi+320]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6118 : 	loadFrom >> m_iNumCitiesUnhappinessPercent;

	lea	eax, DWORD PTR [esi+324]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6119 : 	loadFrom >> m_iNumCitiesPolicyCostMod;

	add	esi, 328				; 00000148H
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi
	pop	esi

; 6120 : }

	ret	4
?readFromVersion0@CvWorldInfo@@QAEXAAVFDataStream@@@Z ENDP ; CvWorldInfo::readFromVersion0
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?writeTo@CvWorldInfo@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_iVersion$ = -4						; size = 4
_saveTo$ = 8						; size = 4
?writeTo@CvWorldInfo@@UBEXAAVFDataStream@@@Z PROC	; CvWorldInfo::writeTo, COMDAT
; _this$ = ecx

; 6123 : {

	push	ecx
	push	esi
	push	edi

; 6124 : 	int iVersion = 2;		// Make sure to update the versioning if the members change!
; 6125 : 	saveTo << iVersion;

	mov	edi, DWORD PTR _saveTo$[esp+8]
	lea	eax, DWORD PTR _iVersion$[esp+12]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _iVersion$[esp+16], 2
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6126 : 
; 6127 : 	CvBaseInfo::writeTo(saveTo);

	push	edi
	mov	ecx, esi
	call	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z ; CvBaseInfo::writeTo

; 6128 : 
; 6129 : 	saveTo << m_iDefaultPlayers;

	lea	ecx, DWORD PTR [esi+260]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6130 : 	saveTo << m_iDefaultMinorCivs;

	lea	edx, DWORD PTR [esi+264]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6131 : 	saveTo << m_iFogTilesPerBarbarianCamp;

	lea	eax, DWORD PTR [esi+268]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6132 : 	saveTo << m_iNumNaturalWonders;

	lea	ecx, DWORD PTR [esi+272]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6133 : 	saveTo << m_iUnitNameModifier;

	lea	edx, DWORD PTR [esi+276]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6134 : 	saveTo << m_iTargetNumCities;

	lea	eax, DWORD PTR [esi+280]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6135 : 	saveTo << m_iNumFreeBuildingResources;

	lea	ecx, DWORD PTR [esi+284]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6136 : 	saveTo << m_iBuildingClassPrereqModifier;

	lea	edx, DWORD PTR [esi+288]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6137 : 	saveTo << m_iMaxConscriptModifier;

	lea	eax, DWORD PTR [esi+292]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6138 : 	saveTo << m_iGridWidth;

	lea	ecx, DWORD PTR [esi+296]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6139 : 	saveTo << m_iGridHeight;

	lea	edx, DWORD PTR [esi+300]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6140 : 	saveTo << m_iMaxActiveReligions;

	lea	eax, DWORD PTR [esi+304]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6141 : 	saveTo << m_iTerrainGrainChange;

	lea	ecx, DWORD PTR [esi+308]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6142 : 	saveTo << m_iFeatureGrainChange;

	lea	edx, DWORD PTR [esi+312]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6143 : 	saveTo << m_iResearchPercent;

	lea	eax, DWORD PTR [esi+316]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6144 : 	saveTo << m_iAdvancedStartPointsMod;

	lea	ecx, DWORD PTR [esi+320]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6145 : 	saveTo << m_iNumCitiesUnhappinessPercent;

	lea	edx, DWORD PTR [esi+324]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6146 : 	saveTo << m_iNumCitiesPolicyCostMod;

	lea	eax, DWORD PTR [esi+328]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6147 : 	saveTo << m_iNumCitiesTechCostMod;

	add	esi, 332				; 0000014cH
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi
	pop	esi

; 6148 : }

	pop	ecx
	ret	4
?writeTo@CvWorldInfo@@UBEXAAVFDataStream@@@Z ENDP	; CvWorldInfo::writeTo
_TEXT	ENDS
PUBLIC	??_7CvClimateInfo@@6B@				; CvClimateInfo::`vftable'
PUBLIC	??0CvClimateInfo@@QAE@XZ			; CvClimateInfo::CvClimateInfo
PUBLIC	??_R4CvClimateInfo@@6B@				; CvClimateInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvClimateInfo@@@8			; CvClimateInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvClimateInfo@@8				; CvClimateInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvClimateInfo@@8				; CvClimateInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvClimateInfo@@8			; CvClimateInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvClimateInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvClimateInfo::CacheResults
PUBLIC	?readFrom@CvClimateInfo@@UAEXAAVFDataStream@@@Z	; CvClimateInfo::readFrom
PUBLIC	?writeTo@CvClimateInfo@@UBEXAAVFDataStream@@@Z	; CvClimateInfo::writeTo
;	COMDAT ??_R1A@?0A@EA@CvClimateInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvClimateInfo@@8 DD FLAT:??_R0?AVCvClimateInfo@@@8 ; CvClimateInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvClimateInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvClimateInfo@@8
rdata$r	SEGMENT
??_R2CvClimateInfo@@8 DD FLAT:??_R1A@?0A@EA@CvClimateInfo@@8 ; CvClimateInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvClimateInfo@@8
rdata$r	SEGMENT
??_R3CvClimateInfo@@8 DD 00H				; CvClimateInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvClimateInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvClimateInfo@@@8
_DATA	SEGMENT
??_R0?AVCvClimateInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvClimateInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvClimateInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvClimateInfo@@6B@
rdata$r	SEGMENT
??_R4CvClimateInfo@@6B@ DD 00H				; CvClimateInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvClimateInfo@@@8
	DD	FLAT:??_R3CvClimateInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvClimateInfo@@6B@
CONST	SEGMENT
??_7CvClimateInfo@@6B@ DD FLAT:??_R4CvClimateInfo@@6B@	; CvClimateInfo::`vftable'
	DD	FLAT:?CacheResults@CvClimateInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvClimateInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvClimateInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvClimateInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvClimateInfo@@QAE@XZ PROC				; CvClimateInfo::CvClimateInfo, COMDAT
; _this$ = ecx

; 6177 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi+272], eax
	mov	DWORD PTR [esi+276], eax
	mov	DWORD PTR [esi+280], eax
	mov	DWORD PTR [esi+284], eax
	mov	DWORD PTR [esi+288], eax
	mov	DWORD PTR [esi+292], eax
	mov	DWORD PTR [esi+296], eax
	mov	DWORD PTR [esi+300], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvClimateInfo@@6B@

; 6178 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvClimateInfo@@QAE@XZ ENDP				; CvClimateInfo::CvClimateInfo
_TEXT	ENDS
EXTRN	__imp_?GetFloat@Results@Database@@QAEMPBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvClimateInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvClimateInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvClimateInfo::CacheResults, COMDAT
; _this$ = ecx

; 6182 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@20
	pop	edi
	pop	esi

; 6199 : }

	ret	8
$LN1@CacheResul@20:
	push	ebx

; 6183 : 		return false;
; 6184 : 
; 6185 : 	m_iDesertPercentChange			= kResults.GetInt("DesertPercentChange");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG222637
	mov	ecx, edi
	call	ebx

; 6186 : 	m_iJungleLatitude				= kResults.GetInt("JungleLatitude");

	push	OFFSET $SG222638
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 6187 : 	m_iHillRange					= kResults.GetInt("HillRange");

	push	OFFSET $SG222639
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 6188 : 	m_iMountainPercent					= kResults.GetInt("MountainPercent");

	push	OFFSET $SG222640
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 6189 : 
; 6190 : 	m_fSnowLatitudeChange			= kResults.GetFloat("SnowLatitudeChange");

	push	OFFSET $SG222641
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR [esi+276]

; 6191 : 	m_fTundraLatitudeChange			= kResults.GetFloat("TundraLatitudeChange");

	push	OFFSET $SG222642
	mov	ecx, edi
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR [esi+280]

; 6192 : 	m_fGrassLatitudeChange			= kResults.GetFloat("GrassLatitudeChange");

	push	OFFSET $SG222643
	mov	ecx, edi
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR [esi+284]

; 6193 : 	m_fDesertBottomLatitudeChange	= kResults.GetFloat("DesertBottomLatitudeChange");

	push	OFFSET $SG222644
	mov	ecx, edi
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR [esi+288]

; 6194 : 	m_fDesertTopLatitudeChange		= kResults.GetFloat("DesertTopLatitudeChange");

	push	OFFSET $SG222645
	mov	ecx, edi
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR [esi+292]

; 6195 : 	m_fIceLatitude					= kResults.GetFloat("IceLatitude");

	push	OFFSET $SG222646
	mov	ecx, edi
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR [esi+296]

; 6196 : 	m_fRandIceLatitude				= kResults.GetFloat("RandIceLatitude");

	push	OFFSET $SG222647
	mov	ecx, edi
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR [esi+300]
	pop	ebx
	pop	edi

; 6197 : 
; 6198 : 	return true;

	mov	al, 1
	pop	esi

; 6199 : }

	ret	8
?CacheResults@CvClimateInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvClimateInfo::CacheResults
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?readFrom@CvClimateInfo@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
?readFrom@CvClimateInfo@@UAEXAAVFDataStream@@@Z PROC	; CvClimateInfo::readFrom, COMDAT
; _this$ = ecx

; 6202 : {

	push	esi
	push	edi

; 6203 : 	CvBaseInfo::readFrom(loadFrom);

	mov	edi, DWORD PTR _loadFrom$[esp+4]
	push	edi
	mov	esi, ecx
	call	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z ; CvBaseInfo::readFrom

; 6204 : 
; 6205 : 	loadFrom >> m_iDesertPercentChange;

	lea	eax, DWORD PTR [esi+260]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6206 : 	loadFrom >> m_iJungleLatitude;

	lea	ecx, DWORD PTR [esi+264]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6207 : 	loadFrom >> m_iHillRange;

	lea	edx, DWORD PTR [esi+268]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6208 : 	loadFrom >> m_iMountainPercent;

	lea	eax, DWORD PTR [esi+272]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 6209 : 	loadFrom >> m_fSnowLatitudeChange;

	lea	ecx, DWORD PTR [esi+276]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAM@Z		; FDataStream::Read

; 6210 : 	loadFrom >> m_fTundraLatitudeChange;

	lea	edx, DWORD PTR [esi+280]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAM@Z		; FDataStream::Read

; 6211 : 	loadFrom >> m_fGrassLatitudeChange;

	lea	eax, DWORD PTR [esi+284]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAM@Z		; FDataStream::Read

; 6212 : 	loadFrom >> m_fDesertBottomLatitudeChange;

	lea	ecx, DWORD PTR [esi+288]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAM@Z		; FDataStream::Read

; 6213 : 	loadFrom >> m_fDesertTopLatitudeChange;

	lea	edx, DWORD PTR [esi+292]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAM@Z		; FDataStream::Read

; 6214 : 	loadFrom >> m_fIceLatitude;

	lea	eax, DWORD PTR [esi+296]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAM@Z		; FDataStream::Read

; 6215 : 	loadFrom >> m_fRandIceLatitude;

	add	esi, 300				; 0000012cH
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAM@Z		; FDataStream::Read
	pop	edi
	pop	esi

; 6216 : }

	ret	4
?readFrom@CvClimateInfo@@UAEXAAVFDataStream@@@Z ENDP	; CvClimateInfo::readFrom
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?writeTo@CvClimateInfo@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
?writeTo@CvClimateInfo@@UBEXAAVFDataStream@@@Z PROC	; CvClimateInfo::writeTo, COMDAT
; _this$ = ecx

; 6219 : {

	push	esi
	push	edi

; 6220 : 	CvBaseInfo::writeTo(saveTo);

	mov	edi, DWORD PTR _saveTo$[esp+4]
	push	edi
	mov	esi, ecx
	call	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z ; CvBaseInfo::writeTo

; 6221 : 
; 6222 : 	saveTo << m_iDesertPercentChange;

	lea	eax, DWORD PTR [esi+260]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6223 : 	saveTo << m_iJungleLatitude;

	lea	ecx, DWORD PTR [esi+264]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6224 : 	saveTo << m_iHillRange;

	lea	edx, DWORD PTR [esi+268]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6225 : 	saveTo << m_iMountainPercent;

	lea	eax, DWORD PTR [esi+272]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 6226 : 	saveTo << m_fSnowLatitudeChange;

	lea	ecx, DWORD PTR [esi+276]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABM@Z		; FDataStream::Write

; 6227 : 	saveTo << m_fTundraLatitudeChange;

	lea	edx, DWORD PTR [esi+280]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABM@Z		; FDataStream::Write

; 6228 : 	saveTo << m_fGrassLatitudeChange;

	lea	eax, DWORD PTR [esi+284]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABM@Z		; FDataStream::Write

; 6229 : 	saveTo << m_fDesertBottomLatitudeChange;

	lea	ecx, DWORD PTR [esi+288]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABM@Z		; FDataStream::Write

; 6230 : 	saveTo << m_fDesertTopLatitudeChange;

	lea	edx, DWORD PTR [esi+292]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABM@Z		; FDataStream::Write

; 6231 : 	saveTo << m_fIceLatitude;

	lea	eax, DWORD PTR [esi+296]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABM@Z		; FDataStream::Write

; 6232 : 	saveTo << m_fRandIceLatitude;

	add	esi, 300				; 0000012cH
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABM@Z		; FDataStream::Write
	pop	edi
	pop	esi

; 6233 : }

	ret	4
?writeTo@CvClimateInfo@@UBEXAAVFDataStream@@@Z ENDP	; CvClimateInfo::writeTo
_TEXT	ENDS
PUBLIC	??_7CvSeaLevelInfo@@6B@				; CvSeaLevelInfo::`vftable'
PUBLIC	??0CvSeaLevelInfo@@QAE@XZ			; CvSeaLevelInfo::CvSeaLevelInfo
PUBLIC	??_R4CvSeaLevelInfo@@6B@			; CvSeaLevelInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvSeaLevelInfo@@@8			; CvSeaLevelInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvSeaLevelInfo@@8				; CvSeaLevelInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvSeaLevelInfo@@8				; CvSeaLevelInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvSeaLevelInfo@@8			; CvSeaLevelInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvSeaLevelInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvSeaLevelInfo::CacheResults
PUBLIC	?readFrom@CvSeaLevelInfo@@UAEXAAVFDataStream@@@Z ; CvSeaLevelInfo::readFrom
PUBLIC	?writeTo@CvSeaLevelInfo@@UBEXAAVFDataStream@@@Z	; CvSeaLevelInfo::writeTo
;	COMDAT ??_R1A@?0A@EA@CvSeaLevelInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvSeaLevelInfo@@8 DD FLAT:??_R0?AVCvSeaLevelInfo@@@8 ; CvSeaLevelInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvSeaLevelInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvSeaLevelInfo@@8
rdata$r	SEGMENT
??_R2CvSeaLevelInfo@@8 DD FLAT:??_R1A@?0A@EA@CvSeaLevelInfo@@8 ; CvSeaLevelInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvSeaLevelInfo@@8
rdata$r	SEGMENT
??_R3CvSeaLevelInfo@@8 DD 00H				; CvSeaLevelInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvSeaLevelInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvSeaLevelInfo@@@8
_DATA	SEGMENT
??_R0?AVCvSeaLevelInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvSeaLevelInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvSeaLevelInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvSeaLevelInfo@@6B@
rdata$r	SEGMENT
??_R4CvSeaLevelInfo@@6B@ DD 00H				; CvSeaLevelInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvSeaLevelInfo@@@8
	DD	FLAT:??_R3CvSeaLevelInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvSeaLevelInfo@@6B@
CONST	SEGMENT
??_7CvSeaLevelInfo@@6B@ DD FLAT:??_R4CvSeaLevelInfo@@6B@ ; CvSeaLevelInfo::`vftable'
	DD	FLAT:?CacheResults@CvSeaLevelInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvSeaLevelInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvSeaLevelInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvSeaLevelInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvSeaLevelInfo@@QAE@XZ PROC				; CvSeaLevelInfo::CvSeaLevelInfo, COMDAT
; _this$ = ecx

; 6252 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	mov	DWORD PTR [esi], OFFSET ??_7CvSeaLevelInfo@@6B@
	mov	DWORD PTR [esi+260], 0

; 6253 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvSeaLevelInfo@@QAE@XZ ENDP				; CvSeaLevelInfo::CvSeaLevelInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvSeaLevelInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvSeaLevelInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvSeaLevelInfo::CacheResults, COMDAT
; _this$ = ecx

; 6257 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@21
	pop	edi
	pop	esi

; 6262 : }

	ret	8
$LN1@CacheResul@21:

; 6258 : 		return false;
; 6259 : 
; 6260 : 	m_iSeaLevelChange = kResults.GetInt("SeaLevelChange");

	push	OFFSET $SG222684
	mov	ecx, edi
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	DWORD PTR [esi+260], eax
	pop	edi

; 6261 : 	return true;

	mov	al, 1
	pop	esi

; 6262 : }

	ret	8
?CacheResults@CvSeaLevelInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvSeaLevelInfo::CacheResults
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?readFrom@CvSeaLevelInfo@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
?readFrom@CvSeaLevelInfo@@UAEXAAVFDataStream@@@Z PROC	; CvSeaLevelInfo::readFrom, COMDAT
; _this$ = ecx

; 6265 : {

	push	esi
	push	edi

; 6266 : 	CvBaseInfo::readFrom(loadFrom);

	mov	edi, DWORD PTR _loadFrom$[esp+4]
	push	edi
	mov	esi, ecx
	call	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z ; CvBaseInfo::readFrom

; 6267 : 	loadFrom >> m_iSeaLevelChange;

	add	esi, 260				; 00000104H
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi
	pop	esi

; 6268 : }

	ret	4
?readFrom@CvSeaLevelInfo@@UAEXAAVFDataStream@@@Z ENDP	; CvSeaLevelInfo::readFrom
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?writeTo@CvSeaLevelInfo@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
?writeTo@CvSeaLevelInfo@@UBEXAAVFDataStream@@@Z PROC	; CvSeaLevelInfo::writeTo, COMDAT
; _this$ = ecx

; 6271 : {

	push	esi
	push	edi

; 6272 : 	CvBaseInfo::writeTo(saveTo);

	mov	edi, DWORD PTR _saveTo$[esp+4]
	push	edi
	mov	esi, ecx
	call	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z ; CvBaseInfo::writeTo

; 6273 : 	saveTo << m_iSeaLevelChange;

	add	esi, 260				; 00000104H
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi
	pop	esi

; 6274 : }

	ret	4
?writeTo@CvSeaLevelInfo@@UBEXAAVFDataStream@@@Z ENDP	; CvSeaLevelInfo::writeTo
_TEXT	ENDS
PUBLIC	??_7CvProcessInfo@@6B@				; CvProcessInfo::`vftable'
PUBLIC	??0CvProcessInfo@@QAE@XZ			; CvProcessInfo::CvProcessInfo
PUBLIC	??_R4CvProcessInfo@@6B@				; CvProcessInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvProcessInfo@@@8			; CvProcessInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvProcessInfo@@8				; CvProcessInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvProcessInfo@@8				; CvProcessInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvProcessInfo@@8			; CvProcessInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvProcessInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvProcessInfo::CacheResults
EXTRN	??_ECvProcessInfo@@UAEPAXI@Z:PROC		; CvProcessInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvProcessInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvProcessInfo@@8 DD FLAT:??_R0?AVCvProcessInfo@@@8 ; CvProcessInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvProcessInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvProcessInfo@@8
rdata$r	SEGMENT
??_R2CvProcessInfo@@8 DD FLAT:??_R1A@?0A@EA@CvProcessInfo@@8 ; CvProcessInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvProcessInfo@@8
rdata$r	SEGMENT
??_R3CvProcessInfo@@8 DD 00H				; CvProcessInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvProcessInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvProcessInfo@@@8
_DATA	SEGMENT
??_R0?AVCvProcessInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvProcessInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvProcessInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvProcessInfo@@6B@
rdata$r	SEGMENT
??_R4CvProcessInfo@@6B@ DD 00H				; CvProcessInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvProcessInfo@@@8
	DD	FLAT:??_R3CvProcessInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvProcessInfo@@6B@
CONST	SEGMENT
??_7CvProcessInfo@@6B@ DD FLAT:??_R4CvProcessInfo@@6B@	; CvProcessInfo::`vftable'
	DD	FLAT:?CacheResults@CvProcessInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvProcessInfo@@UAEPAXI@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvProcessInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvProcessInfo@@QAE@XZ PROC				; CvProcessInfo::CvProcessInfo, COMDAT
; _this$ = ecx

; 6295 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvProcessInfo@@6B@
	mov	DWORD PTR [esi+260], -1

; 6296 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvProcessInfo@@QAE@XZ ENDP				; CvProcessInfo::CvProcessInfo
_TEXT	ENDS
PUBLIC	??1CvProcessInfo@@UAE@XZ			; CvProcessInfo::~CvProcessInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvProcessInfo@@UAE@XZ
_TEXT	SEGMENT
??1CvProcessInfo@@UAE@XZ PROC				; CvProcessInfo::~CvProcessInfo, COMDAT
; _this$ = ecx

; 6299 : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvProcessInfo@@6B@

; 6300 : 	SAFE_DELETE_ARRAY(m_paiProductionToYieldModifier);

	mov	eax, DWORD PTR [esi+264]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+264], 0

; 6301 : 	SAFE_DELETE_ARRAY(m_paiFlavorValue);

	mov	ecx, DWORD PTR [esi+268]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 8
	mov	DWORD PTR [esi+268], 0

; 6302 : }

	mov	ecx, esi
	pop	esi
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvProcessInfo@@UAE@XZ ENDP				; CvProcessInfo::~CvProcessInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvProcessInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvProcessInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvProcessInfo::CacheResults, COMDAT
; _this$ = ecx

; 6328 : {

	push	ebx

; 6329 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	ebx, DWORD PTR _kUtility$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+8]
	push	ebx
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@22
	pop	edi
	pop	esi
	pop	ebx

; 6341 : }

	ret	8
$LN1@CacheResul@22:

; 6330 : 		return false;
; 6331 : 
; 6332 : 	const char* szTechPrereq = kResults.GetText("TechPrereq");

	push	OFFSET $SG222729
	mov	ecx, edi
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 6333 : 	m_iTechPrereq = GC.getInfoTypeForString(szTechPrereq, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 6334 : 
; 6335 : 	const char* szProcessType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+260], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edi, eax

; 6336 : 
; 6337 : 	kUtility.SetYields(m_paiProductionToYieldModifier, "Process_ProductionYields", "ProcessType", szProcessType);

	push	edi
	push	OFFSET $SG222731
	push	OFFSET $SG222732
	lea	eax, DWORD PTR [esi+264]
	push	eax
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 6338 : 	kUtility.SetFlavors(m_paiFlavorValue, "Process_Flavors", "ProcessType", szProcessType);

	push	0
	push	edi
	push	OFFSET $SG222733
	push	OFFSET $SG222734
	add	esi, 268				; 0000010cH
	push	esi
	mov	ecx, ebx
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors
	pop	edi
	pop	esi

; 6339 : 
; 6340 : 	return true;

	mov	al, 1
	pop	ebx

; 6341 : }

	ret	8
?CacheResults@CvProcessInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvProcessInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvVoteInfo@@6B@				; CvVoteInfo::`vftable'
PUBLIC	??0CvVoteInfo@@QAE@XZ				; CvVoteInfo::CvVoteInfo
PUBLIC	??_R4CvVoteInfo@@6B@				; CvVoteInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvVoteInfo@@@8				; CvVoteInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvVoteInfo@@8				; CvVoteInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvVoteInfo@@8				; CvVoteInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvVoteInfo@@8			; CvVoteInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvVoteInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvVoteInfo::CacheResults
EXTRN	??_ECvVoteInfo@@UAEPAXI@Z:PROC			; CvVoteInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvVoteInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvVoteInfo@@8 DD FLAT:??_R0?AVCvVoteInfo@@@8 ; CvVoteInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvVoteInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvVoteInfo@@8
rdata$r	SEGMENT
??_R2CvVoteInfo@@8 DD FLAT:??_R1A@?0A@EA@CvVoteInfo@@8	; CvVoteInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvVoteInfo@@8
rdata$r	SEGMENT
??_R3CvVoteInfo@@8 DD 00H				; CvVoteInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvVoteInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvVoteInfo@@@8
_DATA	SEGMENT
??_R0?AVCvVoteInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvVoteInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvVoteInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvVoteInfo@@6B@
rdata$r	SEGMENT
??_R4CvVoteInfo@@6B@ DD 00H				; CvVoteInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvVoteInfo@@@8
	DD	FLAT:??_R3CvVoteInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvVoteInfo@@6B@
CONST	SEGMENT
??_7CvVoteInfo@@6B@ DD FLAT:??_R4CvVoteInfo@@6B@	; CvVoteInfo::`vftable'
	DD	FLAT:?CacheResults@CvVoteInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvVoteInfo@@UAEPAXI@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvVoteInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvVoteInfo@@QAE@XZ PROC				; CvVoteInfo::CvVoteInfo, COMDAT
; _this$ = ecx

; 6362 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	BYTE PTR [esi+268], al
	mov	BYTE PTR [esi+269], al
	mov	BYTE PTR [esi+270], al
	mov	BYTE PTR [esi+271], al
	mov	BYTE PTR [esi+272], al
	mov	BYTE PTR [esi+273], al
	mov	BYTE PTR [esi+274], al
	mov	BYTE PTR [esi+275], al
	mov	BYTE PTR [esi+276], al
	mov	BYTE PTR [esi+277], al
	mov	BYTE PTR [esi+278], al
	mov	DWORD PTR [esi+280], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvVoteInfo@@6B@

; 6363 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvVoteInfo@@QAE@XZ ENDP				; CvVoteInfo::CvVoteInfo
_TEXT	ENDS
PUBLIC	??1CvVoteInfo@@UAE@XZ				; CvVoteInfo::~CvVoteInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvVoteInfo@@UAE@XZ
_TEXT	SEGMENT
??1CvVoteInfo@@UAE@XZ PROC				; CvVoteInfo::~CvVoteInfo, COMDAT
; _this$ = ecx

; 6366 : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvVoteInfo@@6B@

; 6367 : 	SAFE_DELETE_ARRAY(m_abVoteSourceTypes);

	mov	eax, DWORD PTR [esi+280]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+280], 0

; 6368 : }

	mov	ecx, esi
	pop	esi
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvVoteInfo@@UAE@XZ ENDP				; CvVoteInfo::~CvVoteInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvVoteInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvVoteInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvVoteInfo::CacheResults, COMDAT
; _this$ = ecx

; 6443 : {

	push	ebp

; 6444 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	ebp, DWORD PTR _kUtility$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+8]
	push	ebp
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@23
	pop	edi
	pop	esi
	pop	ebp

; 6466 : }

	ret	8
$LN1@CacheResul@23:
	push	ebx

; 6445 : 		return false;
; 6446 : 
; 6447 : 	m_iPopulationThreshold = kResults.GetInt("PopulationThreshold");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG222794
	mov	ecx, edi
	call	ebx

; 6448 : 	m_iMinVoters = kResults.GetInt("MinVoters");

	push	OFFSET $SG222795
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 6449 : 
; 6450 : 	m_bSecretaryGeneral = kResults.GetBool("SecretaryGeneral");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG222796
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 6451 : 	m_bVictory = kResults.GetBool("Victory");

	push	OFFSET $SG222797
	mov	ecx, edi
	mov	BYTE PTR [esi+268], al
	call	ebx

; 6452 : 	m_bNoNukes = kResults.GetBool("NoNukes");

	push	OFFSET $SG222798
	mov	ecx, edi
	mov	BYTE PTR [esi+269], al
	call	ebx

; 6453 : 	m_bCityVoting = kResults.GetBool("CityVoting");

	push	OFFSET $SG222799
	mov	ecx, edi
	mov	BYTE PTR [esi+270], al
	call	ebx

; 6454 : 	m_bCivVoting = kResults.GetBool("CivVoting");

	push	OFFSET $SG222800
	mov	ecx, edi
	mov	BYTE PTR [esi+271], al
	call	ebx

; 6455 : 	m_bDefensivePact = kResults.GetBool("DefensivePact");

	push	OFFSET $SG222801
	mov	ecx, edi
	mov	BYTE PTR [esi+272], al
	call	ebx

; 6456 : 	m_bOpenBorders = kResults.GetBool("OpenBorders");

	push	OFFSET $SG222802
	mov	ecx, edi
	mov	BYTE PTR [esi+273], al
	call	ebx

; 6457 : 	m_bForcePeace = kResults.GetBool("ForcePeace");

	push	OFFSET $SG222803
	mov	ecx, edi
	mov	BYTE PTR [esi+274], al
	call	ebx

; 6458 : 	m_bForceNoTrade = kResults.GetBool("ForceNoTrade");

	push	OFFSET $SG222804
	mov	ecx, edi
	mov	BYTE PTR [esi+275], al
	call	ebx

; 6459 : 	m_bForceWar = kResults.GetBool("ForceWar");

	push	OFFSET $SG222805
	mov	ecx, edi
	mov	BYTE PTR [esi+276], al
	call	ebx

; 6460 : 	m_bAssignCity = kResults.GetBool("AssignCity");

	push	OFFSET $SG222806
	mov	ecx, edi
	mov	BYTE PTR [esi+277], al
	call	ebx

; 6461 : 
; 6462 : 	const char* szVoteType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR [esi+278], al
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 6463 : 	kUtility.PopulateArrayByExistence(m_abVoteSourceTypes, "VoteSources", "Vote_DiploVotes", "DiploVoteType", "VoteType", szVoteType);

	push	eax
	push	OFFSET $SG222808
	push	OFFSET $SG222809
	push	OFFSET $SG222810
	push	OFFSET $SG222811
	add	esi, 280				; 00000118H
	push	esi
	mov	ecx, ebp
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence
	pop	ebx
	pop	edi
	pop	esi

; 6464 : 
; 6465 : 	return true;

	mov	al, 1
	pop	ebp

; 6466 : }

	ret	8
?CacheResults@CvVoteInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvVoteInfo::CacheResults
_TEXT	ENDS
PUBLIC	?getAnimationPathType@CvEntityEventInfo@@QBE?AW4AnimationPathTypes@@H@Z ; CvEntityEventInfo::getAnimationPathType
; Function compile flags: /Ogtpy
;	COMDAT ?getAnimationPathType@CvEntityEventInfo@@QBE?AW4AnimationPathTypes@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?getAnimationPathType@CvEntityEventInfo@@QBE?AW4AnimationPathTypes@@H@Z PROC ; CvEntityEventInfo::getAnimationPathType, COMDAT
; _this$ = ecx

; 6510 : 	return iIndex >= (int)m_vctAnimationPathType.size() ? ANIMATIONPATH_NONE : m_vctAnimationPathType[iIndex];

	mov	edx, DWORD PTR [ecx+268]
	sub	edx, DWORD PTR [ecx+264]
	mov	eax, DWORD PTR _iIndex$[esp-4]
	sar	edx, 2
	cmp	eax, edx
	jl	SHORT $LN3@getAnimati
	or	eax, -1

; 6511 : }

	ret	4
$LN3@getAnimati:

; 6510 : 	return iIndex >= (int)m_vctAnimationPathType.size() ? ANIMATIONPATH_NONE : m_vctAnimationPathType[iIndex];

	mov	ecx, DWORD PTR [ecx+264]
	mov	eax, DWORD PTR [ecx+eax*4]

; 6511 : }

	ret	4
?getAnimationPathType@CvEntityEventInfo@@QBE?AW4AnimationPathTypes@@H@Z ENDP ; CvEntityEventInfo::getAnimationPathType
_TEXT	ENDS
PUBLIC	?getAnimationPathCount@CvEntityEventInfo@@QBEHXZ ; CvEntityEventInfo::getAnimationPathCount
; Function compile flags: /Ogtpy
;	COMDAT ?getAnimationPathCount@CvEntityEventInfo@@QBEHXZ
_TEXT	SEGMENT
?getAnimationPathCount@CvEntityEventInfo@@QBEHXZ PROC	; CvEntityEventInfo::getAnimationPathCount, COMDAT
; _this$ = ecx

; 6515 : 	return m_vctAnimationPathType.size();

	mov	eax, DWORD PTR [ecx+268]
	sub	eax, DWORD PTR [ecx+264]
	sar	eax, 2

; 6516 : }

	ret	0
?getAnimationPathCount@CvEntityEventInfo@@QBEHXZ ENDP	; CvEntityEventInfo::getAnimationPathCount
_TEXT	ENDS
PUBLIC	?GetNumEraVOs@CvEraInfo@@QBEHXZ			; CvEraInfo::GetNumEraVOs
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumEraVOs@CvEraInfo@@QBEHXZ
_TEXT	SEGMENT
?GetNumEraVOs@CvEraInfo@@QBEHXZ PROC			; CvEraInfo::GetNumEraVOs, COMDAT
; _this$ = ecx

; 6769 : {

	push	esi

; 6770 : 	return m_vEraVOs.size();

	mov	esi, DWORD PTR [ecx+564]
	sub	esi, DWORD PTR [ecx+560]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	add	edx, esi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 6771 : }

	ret	0
?GetNumEraVOs@CvEraInfo@@QBEHXZ ENDP			; CvEraInfo::GetNumEraVOs
_TEXT	ENDS
PUBLIC	?GetEraVO@CvEraInfo@@QAEPBDH@Z			; CvEraInfo::GetEraVO
; Function compile flags: /Ogtpy
;	COMDAT ?GetEraVO@CvEraInfo@@QAEPBDH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetEraVO@CvEraInfo@@QAEPBDH@Z PROC			; CvEraInfo::GetEraVO, COMDAT
; _this$ = ecx

; 6775 : 	return m_vEraVOs[iIndex].c_str();

	mov	eax, DWORD PTR _iIndex$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+560]
	lea	ecx, DWORD PTR [eax+edx*4]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 6776 : }

	ret	4
?GetEraVO@CvEraInfo@@QAEPBDH@Z ENDP			; CvEraInfo::GetEraVO
_TEXT	ENDS
PUBLIC	?CacheResults@CvColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvColorInfo::CacheResults
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
$T234380 = -8						; size = 4
$T234379 = -4						; size = 4
$T234381 = 8						; size = 4
_kResults$ = 8						; size = 4
$T234382 = 12						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvColorInfo::CacheResults, COMDAT
; _this$ = ecx

; 6876 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+12]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@24
	pop	edi
	pop	esi

; 6887 : }

	add	esp, 8
	ret	8
$LN1@CacheResul@24:

; 6877 : 	{
; 6878 : 		return false;
; 6879 : 	}
; 6880 : 
; 6881 : 	m_Color = CvColorA(kResults.GetFloat("Red"),
; 6882 : 	                   kResults.GetFloat("Green"),
; 6883 : 	                   kResults.GetFloat("Blue"),
; 6884 : 	                   kResults.GetFloat("Alpha"));

	push	OFFSET $SG223048
	mov	ecx, edi
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR $T234382[esp+12]
	push	OFFSET $SG223047
	mov	ecx, edi
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR $T234381[esp+12]
	push	OFFSET $SG223046
	mov	ecx, edi
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR $T234380[esp+16]
	push	OFFSET $SG223045
	mov	ecx, edi
	call	DWORD PTR __imp_?GetFloat@Results@Database@@QAEMPBD@Z
	fstp	DWORD PTR $T234379[esp+16]
	mov	eax, DWORD PTR $T234382[esp+12]
	mov	ecx, DWORD PTR $T234381[esp+12]
	mov	edx, DWORD PTR $T234380[esp+16]
	mov	edi, DWORD PTR $T234379[esp+16]
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], ecx
	mov	DWORD PTR [esi+268], edx
	mov	DWORD PTR [esi+272], edi
	pop	edi

; 6885 : 
; 6886 : 	return true;

	mov	al, 1
	pop	esi

; 6887 : }

	add	esp, 8
	ret	8
?CacheResults@CvColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvColorInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvPlayerColorInfo@@6B@			; CvPlayerColorInfo::`vftable'
PUBLIC	??0CvPlayerColorInfo@@QAE@XZ			; CvPlayerColorInfo::CvPlayerColorInfo
PUBLIC	??_R4CvPlayerColorInfo@@6B@			; CvPlayerColorInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvPlayerColorInfo@@@8			; CvPlayerColorInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvPlayerColorInfo@@8			; CvPlayerColorInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvPlayerColorInfo@@8			; CvPlayerColorInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvPlayerColorInfo@@8		; CvPlayerColorInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvPlayerColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvPlayerColorInfo::CacheResults
;	COMDAT ??_R1A@?0A@EA@CvPlayerColorInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvPlayerColorInfo@@8 DD FLAT:??_R0?AVCvPlayerColorInfo@@@8 ; CvPlayerColorInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvPlayerColorInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvPlayerColorInfo@@8
rdata$r	SEGMENT
??_R2CvPlayerColorInfo@@8 DD FLAT:??_R1A@?0A@EA@CvPlayerColorInfo@@8 ; CvPlayerColorInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvPlayerColorInfo@@8
rdata$r	SEGMENT
??_R3CvPlayerColorInfo@@8 DD 00H			; CvPlayerColorInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvPlayerColorInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvPlayerColorInfo@@@8
_DATA	SEGMENT
??_R0?AVCvPlayerColorInfo@@@8 DD FLAT:??_7type_info@@6B@ ; CvPlayerColorInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvPlayerColorInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvPlayerColorInfo@@6B@
rdata$r	SEGMENT
??_R4CvPlayerColorInfo@@6B@ DD 00H			; CvPlayerColorInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvPlayerColorInfo@@@8
	DD	FLAT:??_R3CvPlayerColorInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvPlayerColorInfo@@6B@
CONST	SEGMENT
??_7CvPlayerColorInfo@@6B@ DD FLAT:??_R4CvPlayerColorInfo@@6B@ ; CvPlayerColorInfo::`vftable'
	DD	FLAT:?CacheResults@CvPlayerColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvPlayerColorInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvPlayerColorInfo@@QAE@XZ PROC			; CvPlayerColorInfo::CvPlayerColorInfo, COMDAT
; _this$ = ecx

; 6893 : {}

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	or	eax, -1
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvPlayerColorInfo@@6B@
	mov	eax, esi
	pop	esi
	ret	0
??0CvPlayerColorInfo@@QAE@XZ ENDP			; CvPlayerColorInfo::CvPlayerColorInfo
_TEXT	ENDS
EXTRN	__imp_?Bind@Results@Database@@QAE_NHH@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvPlayerColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPlayerColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
__ehfuncinfo$?CacheResults@CvPlayerColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CacheResults@CvPlayerColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvPlayerColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_strKey$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvPlayerColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvPlayerColorInfo::CacheResults, COMDAT
; _this$ = ecx

; 6911 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvPlayerColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax

; 6912 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kResults$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	mov	ebx, DWORD PTR _kUtility$[esp+40]
	push	edi
	push	ebx
	push	eax
	mov	edi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN4@CacheResul@25
	pop	edi
	pop	ebx

; 6939 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
$LN4@CacheResul@25:
	push	ebp
	push	esi

; 6913 : 		return false;
; 6914 : 
; 6915 : 	//Perform an inner join
; 6916 : 	const char* szSQL =	"select PrimaryColor.ID, SecondaryColor.ID, TextColor.ID FROM PlayerColors INNER JOIN "
; 6917 : 	                    "Colors As PrimaryColor ON PlayerColors.PrimaryColor = PrimaryColor.Type, "
; 6918 : 	                    "Colors AS SecondaryColor ON PlayerColors.SecondaryColor = SecondaryColor.Type, "
; 6919 : 	                    "Colors AS TextColor ON PlayerColors.TextColor = TextColor.Type where PlayerColors.ID = ? LIMIT 1; ";
; 6920 : 
; 6921 : 	std::string strKey("ColorsLookup");

	push	OFFSET $SG223070
	lea	ecx, DWORD PTR _strKey$[esp+60]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 6922 : 	Database::Results* pResults = kUtility.GetResults(strKey);

	lea	ecx, DWORD PTR _strKey$[esp+56]
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+68], 0
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	esi, eax

; 6923 : 	if(pResults == NULL)

	test	esi, esi
	jne	SHORT $LN3@CacheResul@25

; 6924 : 	{
; 6925 : 		pResults = kUtility.PrepareResults(strKey, szSQL);

	push	OFFSET $SG223068
	lea	edx, DWORD PTR _strKey$[esp+60]
	push	edx
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	esi, eax
$LN3@CacheResul@25:

; 6926 : 	}
; 6927 : 
; 6928 : 	pResults->Bind(1, GetID());

	mov	eax, DWORD PTR [edi+4]
	push	eax
	push	1
	mov	ecx, esi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHH@Z

; 6929 : 
; 6930 : 	while(pResults->Step())

	mov	ebp, DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	mov	ecx, esi
	call	ebp
	test	al, al
	je	SHORT $LN1@CacheResul@25
	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
$LL2@CacheResul@25:

; 6931 : 	{
; 6932 : 		m_iColorTypePrimary		= pResults->GetInt(0);

	push	0
	mov	ecx, esi
	call	ebx

; 6933 : 		m_iColorTypeSecondary	= pResults->GetInt(1);

	push	1
	mov	ecx, esi
	mov	DWORD PTR [edi+260], eax
	call	ebx

; 6934 : 		m_iColorTypeText		= pResults->GetInt(2);

	push	2
	mov	ecx, esi
	mov	DWORD PTR [edi+264], eax
	call	ebx
	mov	ecx, esi
	mov	DWORD PTR [edi+268], eax
	call	ebp
	test	al, al
	jne	SHORT $LL2@CacheResul@25
$LN1@CacheResul@25:

; 6935 : 	}
; 6936 : 
; 6937 : 
; 6938 : 	return true;

	lea	ecx, DWORD PTR _strKey$[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6939 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	edi
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvPlayerColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _strKey$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvPlayerColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvPlayerColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvPlayerColorInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvPlayerColorInfo::CacheResults
PUBLIC	??_7CvGameOptionInfo@@6B@			; CvGameOptionInfo::`vftable'
PUBLIC	??0CvGameOptionInfo@@QAE@XZ			; CvGameOptionInfo::CvGameOptionInfo
PUBLIC	??_R4CvGameOptionInfo@@6B@			; CvGameOptionInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvGameOptionInfo@@@8			; CvGameOptionInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvGameOptionInfo@@8			; CvGameOptionInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvGameOptionInfo@@8			; CvGameOptionInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvGameOptionInfo@@8		; CvGameOptionInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvGameOptionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvGameOptionInfo::CacheResults
;	COMDAT ??_R1A@?0A@EA@CvGameOptionInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvGameOptionInfo@@8 DD FLAT:??_R0?AVCvGameOptionInfo@@@8 ; CvGameOptionInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvGameOptionInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvGameOptionInfo@@8
rdata$r	SEGMENT
??_R2CvGameOptionInfo@@8 DD FLAT:??_R1A@?0A@EA@CvGameOptionInfo@@8 ; CvGameOptionInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvGameOptionInfo@@8
rdata$r	SEGMENT
??_R3CvGameOptionInfo@@8 DD 00H				; CvGameOptionInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvGameOptionInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvGameOptionInfo@@@8
_DATA	SEGMENT
??_R0?AVCvGameOptionInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvGameOptionInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvGameOptionInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvGameOptionInfo@@6B@
rdata$r	SEGMENT
??_R4CvGameOptionInfo@@6B@ DD 00H			; CvGameOptionInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvGameOptionInfo@@@8
	DD	FLAT:??_R3CvGameOptionInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvGameOptionInfo@@6B@
CONST	SEGMENT
??_7CvGameOptionInfo@@6B@ DD FLAT:??_R4CvGameOptionInfo@@6B@ ; CvGameOptionInfo::`vftable'
	DD	FLAT:?CacheResults@CvGameOptionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvGameOptionInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvGameOptionInfo@@QAE@XZ PROC			; CvGameOptionInfo::CvGameOptionInfo, COMDAT
; _this$ = ecx

; 6948 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	mov	DWORD PTR [esi], OFFSET ??_7CvGameOptionInfo@@6B@
	mov	BYTE PTR [esi+260], 0
	mov	BYTE PTR [esi+261], 1

; 6949 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvGameOptionInfo@@QAE@XZ ENDP			; CvGameOptionInfo::CvGameOptionInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvGameOptionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvGameOptionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvGameOptionInfo::CacheResults, COMDAT
; _this$ = ecx

; 6963 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@26
	pop	edi
	pop	esi

; 6970 : }

	ret	8
$LN1@CacheResul@26:
	push	ebx

; 6964 : 		return false;
; 6965 : 
; 6966 : 	m_bDefault = kResults.GetBool("Default");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG223092
	mov	ecx, edi
	call	ebx

; 6967 : 	m_bVisible = kResults.GetBool("Visible");

	push	OFFSET $SG223093
	mov	ecx, edi
	mov	BYTE PTR [esi+260], al
	call	ebx
	pop	ebx
	mov	BYTE PTR [esi+261], al
	pop	edi

; 6968 : 
; 6969 : 	return true;

	mov	al, 1
	pop	esi

; 6970 : }

	ret	8
?CacheResults@CvGameOptionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvGameOptionInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvMPOptionInfo@@6B@				; CvMPOptionInfo::`vftable'
PUBLIC	??0CvMPOptionInfo@@QAE@XZ			; CvMPOptionInfo::CvMPOptionInfo
PUBLIC	??_R4CvMPOptionInfo@@6B@			; CvMPOptionInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvMPOptionInfo@@@8			; CvMPOptionInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvMPOptionInfo@@8				; CvMPOptionInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvMPOptionInfo@@8				; CvMPOptionInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvMPOptionInfo@@8			; CvMPOptionInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvMPOptionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvMPOptionInfo::CacheResults
;	COMDAT ??_R1A@?0A@EA@CvMPOptionInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvMPOptionInfo@@8 DD FLAT:??_R0?AVCvMPOptionInfo@@@8 ; CvMPOptionInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvMPOptionInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvMPOptionInfo@@8
rdata$r	SEGMENT
??_R2CvMPOptionInfo@@8 DD FLAT:??_R1A@?0A@EA@CvMPOptionInfo@@8 ; CvMPOptionInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvMPOptionInfo@@8
rdata$r	SEGMENT
??_R3CvMPOptionInfo@@8 DD 00H				; CvMPOptionInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvMPOptionInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvMPOptionInfo@@@8
_DATA	SEGMENT
??_R0?AVCvMPOptionInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvMPOptionInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvMPOptionInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvMPOptionInfo@@6B@
rdata$r	SEGMENT
??_R4CvMPOptionInfo@@6B@ DD 00H				; CvMPOptionInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvMPOptionInfo@@@8
	DD	FLAT:??_R3CvMPOptionInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvMPOptionInfo@@6B@
CONST	SEGMENT
??_7CvMPOptionInfo@@6B@ DD FLAT:??_R4CvMPOptionInfo@@6B@ ; CvMPOptionInfo::`vftable'
	DD	FLAT:?CacheResults@CvMPOptionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvMPOptionInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvMPOptionInfo@@QAE@XZ PROC				; CvMPOptionInfo::CvMPOptionInfo, COMDAT
; _this$ = ecx

; 6978 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	mov	DWORD PTR [esi], OFFSET ??_7CvMPOptionInfo@@6B@
	mov	BYTE PTR [esi+260], 0

; 6979 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvMPOptionInfo@@QAE@XZ ENDP				; CvMPOptionInfo::CvMPOptionInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvMPOptionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvMPOptionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvMPOptionInfo::CacheResults, COMDAT
; _this$ = ecx

; 6988 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@27
	pop	edi
	pop	esi

; 6994 : }

	ret	8
$LN1@CacheResul@27:

; 6989 : 		return false;
; 6990 : 
; 6991 : 	m_bDefault = kResults.GetBool("Default");

	push	OFFSET $SG223106
	mov	ecx, edi
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	BYTE PTR [esi+260], al
	pop	edi

; 6992 : 
; 6993 : 	return true;

	mov	al, 1
	pop	esi

; 6994 : }

	ret	8
?CacheResults@CvMPOptionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvMPOptionInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvPlayerOptionInfo@@6B@			; CvPlayerOptionInfo::`vftable'
PUBLIC	??0CvPlayerOptionInfo@@QAE@XZ			; CvPlayerOptionInfo::CvPlayerOptionInfo
PUBLIC	??_R4CvPlayerOptionInfo@@6B@			; CvPlayerOptionInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvPlayerOptionInfo@@@8			; CvPlayerOptionInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvPlayerOptionInfo@@8			; CvPlayerOptionInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvPlayerOptionInfo@@8			; CvPlayerOptionInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvPlayerOptionInfo@@8		; CvPlayerOptionInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvPlayerOptionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvPlayerOptionInfo::CacheResults
;	COMDAT ??_R1A@?0A@EA@CvPlayerOptionInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvPlayerOptionInfo@@8 DD FLAT:??_R0?AVCvPlayerOptionInfo@@@8 ; CvPlayerOptionInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvPlayerOptionInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvPlayerOptionInfo@@8
rdata$r	SEGMENT
??_R2CvPlayerOptionInfo@@8 DD FLAT:??_R1A@?0A@EA@CvPlayerOptionInfo@@8 ; CvPlayerOptionInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvPlayerOptionInfo@@8
rdata$r	SEGMENT
??_R3CvPlayerOptionInfo@@8 DD 00H			; CvPlayerOptionInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvPlayerOptionInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvPlayerOptionInfo@@@8
_DATA	SEGMENT
??_R0?AVCvPlayerOptionInfo@@@8 DD FLAT:??_7type_info@@6B@ ; CvPlayerOptionInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvPlayerOptionInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvPlayerOptionInfo@@6B@
rdata$r	SEGMENT
??_R4CvPlayerOptionInfo@@6B@ DD 00H			; CvPlayerOptionInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvPlayerOptionInfo@@@8
	DD	FLAT:??_R3CvPlayerOptionInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvPlayerOptionInfo@@6B@
CONST	SEGMENT
??_7CvPlayerOptionInfo@@6B@ DD FLAT:??_R4CvPlayerOptionInfo@@6B@ ; CvPlayerOptionInfo::`vftable'
	DD	FLAT:?CacheResults@CvPlayerOptionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvPlayerOptionInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvPlayerOptionInfo@@QAE@XZ PROC			; CvPlayerOptionInfo::CvPlayerOptionInfo, COMDAT
; _this$ = ecx

; 7002 : {

	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	mov	DWORD PTR [esi], OFFSET ??_7CvPlayerOptionInfo@@6B@
	mov	BYTE PTR [esi+260], 0

; 7003 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvPlayerOptionInfo@@QAE@XZ ENDP			; CvPlayerOptionInfo::CvPlayerOptionInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvPlayerOptionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvPlayerOptionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvPlayerOptionInfo::CacheResults, COMDAT
; _this$ = ecx

; 7012 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@28
	pop	edi
	pop	esi

; 7018 : }

	ret	8
$LN1@CacheResul@28:

; 7013 : 		return false;
; 7014 : 
; 7015 : 	m_bDefault = kResults.GetBool("Default");

	push	OFFSET $SG223119
	mov	ecx, edi
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	BYTE PTR [esi+260], al
	pop	edi

; 7016 : 
; 7017 : 	return true;

	mov	al, 1
	pop	esi

; 7018 : }

	ret	8
?CacheResults@CvPlayerOptionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvPlayerOptionInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvVoteSourceInfo@@6B@			; CvVoteSourceInfo::`vftable'
PUBLIC	??0CvVoteSourceInfo@@QAE@XZ			; CvVoteSourceInfo::CvVoteSourceInfo
PUBLIC	??_R4CvVoteSourceInfo@@6B@			; CvVoteSourceInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvVoteSourceInfo@@@8			; CvVoteSourceInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvVoteSourceInfo@@8			; CvVoteSourceInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvVoteSourceInfo@@8			; CvVoteSourceInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvVoteSourceInfo@@8		; CvVoteSourceInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvVoteSourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvVoteSourceInfo::CacheResults
EXTRN	??_ECvVoteSourceInfo@@UAEPAXI@Z:PROC		; CvVoteSourceInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvVoteSourceInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvVoteSourceInfo@@8 DD FLAT:??_R0?AVCvVoteSourceInfo@@@8 ; CvVoteSourceInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvVoteSourceInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvVoteSourceInfo@@8
rdata$r	SEGMENT
??_R2CvVoteSourceInfo@@8 DD FLAT:??_R1A@?0A@EA@CvVoteSourceInfo@@8 ; CvVoteSourceInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvVoteSourceInfo@@8
rdata$r	SEGMENT
??_R3CvVoteSourceInfo@@8 DD 00H				; CvVoteSourceInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvVoteSourceInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvVoteSourceInfo@@@8
_DATA	SEGMENT
??_R0?AVCvVoteSourceInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvVoteSourceInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvVoteSourceInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvVoteSourceInfo@@6B@
rdata$r	SEGMENT
??_R4CvVoteSourceInfo@@6B@ DD 00H			; CvVoteSourceInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvVoteSourceInfo@@@8
	DD	FLAT:??_R3CvVoteSourceInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvVoteSourceInfo@@6B@
CONST	SEGMENT
??_7CvVoteSourceInfo@@6B@ DD FLAT:??_R4CvVoteSourceInfo@@6B@ ; CvVoteSourceInfo::`vftable'
	DD	FLAT:?CacheResults@CvVoteSourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvVoteSourceInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvVoteSourceInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvVoteSourceInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvVoteSourceInfo@@QAE@XZ$1
__ehfuncinfo$??0CvVoteSourceInfo@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvVoteSourceInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvVoteSourceInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvVoteSourceInfo@@QAE@XZ PROC			; CvVoteSourceInfo::CvVoteSourceInfo, COMDAT
; _this$ = ecx

; 7027 : {

	push	-1
	push	__ehhandler$??0CvVoteSourceInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+28], eax
	mov	DWORD PTR [esi+260], eax
	or	eax, -1
	lea	ecx, DWORD PTR [esi+272]
	mov	DWORD PTR [esi], OFFSET ??_7CvVoteSourceInfo@@6B@
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+300]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7028 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvVoteSourceInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvVoteSourceInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvVoteSourceInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvVoteSourceInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvVoteSourceInfo@@QAE@XZ ENDP			; CvVoteSourceInfo::CvVoteSourceInfo
PUBLIC	??1CvVoteSourceInfo@@UAE@XZ			; CvVoteSourceInfo::~CvVoteSourceInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvVoteSourceInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvVoteSourceInfo@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvVoteSourceInfo@@UAE@XZ$1
__ehfuncinfo$??1CvVoteSourceInfo@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvVoteSourceInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??1CvVoteSourceInfo@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvVoteSourceInfo@@UAE@XZ PROC			; CvVoteSourceInfo::~CvVoteSourceInfo, COMDAT
; _this$ = ecx

; 7031 : {

	push	-1
	push	__ehhandler$??1CvVoteSourceInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvVoteSourceInfo@@6B@

; 7032 : }

	lea	ecx, DWORD PTR [esi+300]
	mov	DWORD PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+272]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvVoteSourceInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvVoteSourceInfo@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvVoteSourceInfo@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvVoteSourceInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvVoteSourceInfo@@UAE@XZ ENDP			; CvVoteSourceInfo::~CvVoteSourceInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvVoteSourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvVoteSourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvVoteSourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
__ehfuncinfo$?CacheResults@CvVoteSourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CacheResults@CvVoteSourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvVoteSourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
$T234472 = -68						; size = 28
$T234473 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvVoteSourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvVoteSourceInfo::CacheResults, COMDAT
; _this$ = ecx

; 7060 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvVoteSourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax

; 7061 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+72]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@29
	pop	edi
	pop	esi

; 7078 : 
; 7079 : 	return true;
; 7080 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	8
$LN1@CacheResul@29:
	push	ebx

; 7062 : 		return false;
; 7063 : 
; 7064 : 	m_iVoteInterval = kResults.GetInt("VoteInterval");

	push	OFFSET $SG223151
	mov	ecx, edi
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z

; 7065 : 
; 7066 : 	const char* szTextVal;
; 7067 : 	szTextVal = kResults.GetText("PopupText");

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG223153
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 7068 : 	m_strPopupText = GetLocalizedText(szTextVal);

	push	eax
	lea	ecx, DWORD PTR $T234472[esp+84]
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	lea	ecx, DWORD PTR [esi+272]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234472[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7069 : 
; 7070 : 	szTextVal = kResults.GetText("SecretaryGeneralText");

	push	OFFSET $SG223155
	mov	ecx, edi
	call	ebx

; 7071 : 	m_strSecretaryGeneralText = GetLocalizedText(szTextVal);

	push	eax
	lea	edx, DWORD PTR $T234473[esp+84]
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	lea	ecx, DWORD PTR [esi+300]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+92], 1
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T234473[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 7072 : 
; 7073 : 	const char* szFreeSpecialist = kResults.GetText("FreeSpecialist");

	push	OFFSET $SG223158
	mov	ecx, edi
	call	ebx

; 7074 : 	m_iFreeSpecialist = GC.getInfoTypeForString(szFreeSpecialist, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7075 : 
; 7076 : 	const char* szPolicy = kResults.GetText("Policy");

	push	OFFSET $SG223160
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 7077 : 	m_iPolicy = GC.getInfoTypeForString(szPolicy, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 7078 : 
; 7079 : 	return true;
; 7080 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	pop	ebx
	mov	DWORD PTR [esi+268], eax
	pop	edi
	mov	al, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvVoteSourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR $T234472[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CacheResults@CvVoteSourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR $T234473[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?CacheResults@CvVoteSourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvVoteSourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvVoteSourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvVoteSourceInfo::CacheResults
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::end
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::end, COMDAT
; _this$ = ecx

; 571  : 		return (_TREE_CONST_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 572  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::end
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??C?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEPBUProductionCostModifiers@@XZ ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator->
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??C?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEPBUProductionCostModifiers@@XZ
_TEXT	SEGMENT
??C?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEPBUProductionCostModifiers@@XZ PROC ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator->, COMDAT
; _this$ = ecx

; 111  : 		return (&**this);

	mov	eax, DWORD PTR [ecx]

; 112  : 		}

	ret	0
??C?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEPBUProductionCostModifiers@@XZ ENDP ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator->
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@XZ ; std::_Vector_val<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::~_Vector_val<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::~_Vector_val<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::~_Vector_val<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::~_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::~_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::~_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	??1?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@QAE@XZ ; std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0>::~_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0>::~_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0>::~_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0>
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ; std::_Vector_val<CvString,std::allocator<CvString> >::_Vector_val<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z PROC ; std::_Vector_val<CvString,std::allocator<CvString> >::_Vector_val<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ENDP ; std::_Vector_val<CvString,std::allocator<CvString> >::_Vector_val<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAABHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Key
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::end, COMDAT
; _this$ = ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::end
_TEXT	ENDS
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::get_allocator
; Function compile flags: /Ogtpy
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::get_allocator, COMDAT
; _this$ = ecx

; 616  : 		return (this->_Alval);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 617  : 		}

	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::get_allocator
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Root
_TEXT	ENDS
PUBLIC	?begin@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@XZ ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::end
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE@V?$allocator@UProductionCostModifiers@@@1@@Z ; std::_Vector_val<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Vector_val<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE@V?$allocator@UProductionCostModifiers@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE@V?$allocator@UProductionCostModifiers@@@1@@Z PROC ; std::_Vector_val<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Vector_val<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE@V?$allocator@UProductionCostModifiers@@@1@@Z ENDP ; std::_Vector_val<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Vector_val<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@V?$allocator@W4AnimationPathTypes@@@1@@Z ; std::_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@V?$allocator@W4AnimationPathTypes@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@V?$allocator@W4AnimationPathTypes@@@1@@Z PROC ; std::_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE@V?$allocator@W4AnimationPathTypes@@@1@@Z ENDP ; std::_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Vector_val<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	??H?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+, COMDAT
; _this$ = ecx

; 1630 : 		{	// return this + integer

	sub	esp, 8

; 1631 : 		_Mytype _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]

; 1632 : 		return (_Tmp += _Off);

	mov	edx, DWORD PTR __Off$[esp+4]
	mov	DWORD PTR __Tmp$[esp+12], ecx
	push	edx
	lea	ecx, DWORD PTR __Tmp$[esp+12]
	mov	DWORD PTR __Tmp$[esp+12], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx], edx
	mov	eax, ecx

; 1633 : 		}

	add	esp, 8
	ret	8
??H?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEAAU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ; std::vector<CvString,std::allocator<CvString> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ PROC ; std::vector<CvString,std::allocator<CvString> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 153391689				; 09249249H

; 732  : 		}

	ret	0
?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z ; std::allocator<CvString>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z PROC ; std::allocator<CvString>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z ENDP ; std::allocator<CvString>::allocate
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::begin
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Lbound
; Function compile flags: /Ogtpy
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN3@Lbound
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL4@Lbound:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	cmp	DWORD PTR [ecx+12], edx
	jge	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LL4@Lbound
$LN3@Lbound:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@@Z PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@@Z ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEIXZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEIXZ PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 357913941				; 15555555H

; 732  : 		}

	ret	0
?max_size@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBEIXZ ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UProductionCostModifiers@@@std@@QAEPAUProductionCostModifiers@@I@Z ; std::allocator<ProductionCostModifiers>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UProductionCostModifiers@@@std@@QAEPAUProductionCostModifiers@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UProductionCostModifiers@@@std@@QAEPAUProductionCostModifiers@@I@Z PROC ; std::allocator<ProductionCostModifiers>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@UProductionCostModifiers@@@std@@YAPAUProductionCostModifiers@@IPAU1@@Z ; std::_Allocate<ProductionCostModifiers>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@UProductionCostModifiers@@@std@@QAEPAUProductionCostModifiers@@I@Z ENDP ; std::allocator<ProductionCostModifiers>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEIXZ ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEIXZ PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@W4AnimationPathTypes@@@std@@QAEPAW4AnimationPathTypes@@I@Z ; std::allocator<enum AnimationPathTypes>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@W4AnimationPathTypes@@@std@@QAEPAW4AnimationPathTypes@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@W4AnimationPathTypes@@@std@@QAEPAW4AnimationPathTypes@@I@Z PROC ; std::allocator<enum AnimationPathTypes>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@W4AnimationPathTypes@@@std@@YAPAW4AnimationPathTypes@@IPAW41@@Z ; std::_Allocate<enum AnimationPathTypes>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@W4AnimationPathTypes@@@std@@QAEPAW4AnimationPathTypes@@I@Z ENDP ; std::allocator<enum AnimationPathTypes>::allocate
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE@PAVCvFormationSlotEntry@@@Z ; std::_Vector_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Vector_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE@PAVCvFormationSlotEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE@PAVCvFormationSlotEntry@@@Z PROC ; std::_Vector_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Vector_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE@PAVCvFormationSlotEntry@@@Z ENDP ; std::_Vector_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Vector_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ; std::_Vector_iterator<CvString,std::allocator<CvString> >::_Vector_iterator<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z PROC ; std::_Vector_iterator<CvString,std::allocator<CvString> >::_Vector_iterator<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ENDP ; std::_Vector_iterator<CvString,std::allocator<CvString> >::_Vector_iterator<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@PAW4AnimationPathTypes@@@Z ; std::_Vector_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Vector_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@PAW4AnimationPathTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@PAW4AnimationPathTypes@@@Z PROC ; std::_Vector_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Vector_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@PAW4AnimationPathTypes@@@Z ENDP ; std::_Vector_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Vector_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEIXZ ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 268435455				; 0fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VCvFormationSlotEntry@@@std@@QAEPAVCvFormationSlotEntry@@I@Z ; std::allocator<CvFormationSlotEntry>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VCvFormationSlotEntry@@@std@@QAEPAVCvFormationSlotEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VCvFormationSlotEntry@@@std@@QAEPAVCvFormationSlotEntry@@I@Z PROC ; std::allocator<CvFormationSlotEntry>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@VCvFormationSlotEntry@@@std@@YAPAVCvFormationSlotEntry@@IPAV1@@Z ; std::_Allocate<CvFormationSlotEntry>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@VCvFormationSlotEntry@@@std@@QAEPAVCvFormationSlotEntry@@I@Z ENDP ; std::allocator<CvFormationSlotEntry>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 214748364				; 0cccccccH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+33], 0
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+33], 0
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, esi
	pop	esi

; 283  : 			}

	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	shl	ecx, 4
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+=
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::iterator::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ; std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0>::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0>::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	mov	eax, ecx

; 40   : 		}

	ret	8
??0?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0>::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0>
_TEXT	ENDS
PUBLIC	??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z ; CvDatabaseUtility::InitializeArray<int>
EXTRN	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z:PROC	; CvDatabaseUtility::MaxRows
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z
_TEXT	SEGMENT
_pArray$ = 8						; size = 4
_szTableName$ = 12					; size = 4
_default$ = 16						; size = 4
??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z PROC ; CvDatabaseUtility::InitializeArray<int>, COMDAT
; _this$ = ecx

; 180  : 	size_t count = MaxRows(szTableName);

	mov	eax, DWORD PTR _szTableName$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 181  : 
; 182  : 	//This is a bit of a hack to support empty tables.
; 183  : 	//For example, the "Automates" table will be empty during a tutorial.
; 184  : 	//We cannot simply NULL out the array because WAY too much code blindly assumes SOMETHING will be there..
; 185  : 	//Instead we allocate room for 1 element and just roll with it.
; 186  : 
; 187  : 	//CvAssertMsg(count > 0, DB.ErrorMessage());
; 188  : 	if(count == 0)

	test	eax, eax
	jne	SHORT $LN1@Initialize@3

; 189  : 		count = 1;

	mov	eax, 1
$LN1@Initialize@3:

; 190  : 
; 191  : 	InitializeArray(pArray, count, default);

	mov	ecx, DWORD PTR _default$[esp]
	mov	edx, DWORD PTR _pArray$[esp]
	push	ecx
	push	eax
	push	edx
	mov	ecx, esi
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
	pop	esi

; 192  : }

	ret	12					; 0000000cH
??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z ENDP ; CvDatabaseUtility::InitializeArray<int>
_TEXT	ENDS
PUBLIC	??$InitializeArray@_N@CvDatabaseUtility@@QAEXAAPA_NPBD_N@Z ; CvDatabaseUtility::InitializeArray<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$InitializeArray@_N@CvDatabaseUtility@@QAEXAAPA_NPBD_N@Z
_TEXT	SEGMENT
_pArray$ = 8						; size = 4
_szTableName$ = 12					; size = 4
_default$ = 16						; size = 1
??$InitializeArray@_N@CvDatabaseUtility@@QAEXAAPA_NPBD_N@Z PROC ; CvDatabaseUtility::InitializeArray<bool>, COMDAT
; _this$ = ecx

; 180  : 	size_t count = MaxRows(szTableName);

	mov	eax, DWORD PTR _szTableName$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 181  : 
; 182  : 	//This is a bit of a hack to support empty tables.
; 183  : 	//For example, the "Automates" table will be empty during a tutorial.
; 184  : 	//We cannot simply NULL out the array because WAY too much code blindly assumes SOMETHING will be there..
; 185  : 	//Instead we allocate room for 1 element and just roll with it.
; 186  : 
; 187  : 	//CvAssertMsg(count > 0, DB.ErrorMessage());
; 188  : 	if(count == 0)

	test	eax, eax
	jne	SHORT $LN1@Initialize@4

; 189  : 		count = 1;

	mov	eax, 1
$LN1@Initialize@4:

; 190  : 
; 191  : 	InitializeArray(pArray, count, default);

	mov	ecx, DWORD PTR _default$[esp]
	mov	edx, DWORD PTR _pArray$[esp]
	push	ecx
	push	eax
	push	edx
	mov	ecx, esi
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z ; CvDatabaseUtility::InitializeArray
	pop	esi

; 192  : }

	ret	12					; 0000000cH
??$InitializeArray@_N@CvDatabaseUtility@@QAEXAAPA_NPBD_N@Z ENDP ; CvDatabaseUtility::InitializeArray<bool>
_TEXT	ENDS
PUBLIC	??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ; std::_Swap_adl<std::less<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z PROC ; std::_Swap_adl<std::less<int> >, COMDAT

; 31   : 	swap(_Left, _Right);
; 32   : 	}

	ret	0
??$_Swap_adl@U?$less@H@std@@@std@@YAXAAU?$less@H@0@0@Z ENDP ; std::_Swap_adl<std::less<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUProductionCostModifiers@@PAU1@@stdext@@YAPAUProductionCostModifiers@@PAU1@00@Z ; stdext::unchecked_copy<ProductionCostModifiers *,ProductionCostModifiers *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUProductionCostModifiers@@PAU1@@stdext@@YAPAUProductionCostModifiers@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUProductionCostModifiers@@PAU1@@stdext@@YAPAUProductionCostModifiers@@PAU1@00@Z PROC ; stdext::unchecked_copy<ProductionCostModifiers *,ProductionCostModifiers *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_
	push	esi
$LL9@unchecked_:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_
	pop	esi
$LN7@unchecked_:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAUProductionCostModifiers@@PAU1@@stdext@@YAPAUProductionCostModifiers@@PAU1@00@Z ENDP ; stdext::unchecked_copy<ProductionCostModifiers *,ProductionCostModifiers *>
_TEXT	ENDS
PUBLIC	??$fill@PAVCvFormationSlotEntry@@V1@@std@@YAXPAVCvFormationSlotEntry@@0ABV1@@Z ; std::fill<CvFormationSlotEntry *,CvFormationSlotEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAVCvFormationSlotEntry@@V1@@std@@YAXPAVCvFormationSlotEntry@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCvFormationSlotEntry@@V1@@std@@YAXPAVCvFormationSlotEntry@@0ABV1@@Z PROC ; std::fill<CvFormationSlotEntry *,CvFormationSlotEntry>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	add	eax, 16					; 00000010H
	cmp	eax, edx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAVCvFormationSlotEntry@@V1@@std@@YAXPAVCvFormationSlotEntry@@0ABV1@@Z ENDP ; std::fill<CvFormationSlotEntry *,CvFormationSlotEntry>
_TEXT	ENDS
PUBLIC	??$fill@PAUProductionCostModifiers@@U1@@std@@YAXPAUProductionCostModifiers@@0ABU1@@Z ; std::fill<ProductionCostModifiers *,ProductionCostModifiers>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAUProductionCostModifiers@@U1@@std@@YAXPAUProductionCostModifiers@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUProductionCostModifiers@@U1@@std@@YAXPAUProductionCostModifiers@@0ABU1@@Z PROC ; std::fill<ProductionCostModifiers *,ProductionCostModifiers>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@2:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL5@fill@2
	pop	esi
$LN3@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAUProductionCostModifiers@@U1@@std@@YAXPAUProductionCostModifiers@@0ABU1@@Z ENDP ; std::fill<ProductionCostModifiers *,ProductionCostModifiers>
_TEXT	ENDS
PUBLIC	??$fill@PAW4AnimationPathTypes@@W41@@std@@YAXPAW4AnimationPathTypes@@0ABW41@@Z ; std::fill<enum AnimationPathTypes *,enum AnimationPathTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAW4AnimationPathTypes@@W41@@std@@YAXPAW4AnimationPathTypes@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAW4AnimationPathTypes@@W41@@std@@YAXPAW4AnimationPathTypes@@0ABW41@@Z PROC ; std::fill<enum AnimationPathTypes *,enum AnimationPathTypes>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@3
	pop	esi
$LN3@fill@3:

; 3188 : 	}

	ret	0
??$fill@PAW4AnimationPathTypes@@W41@@std@@YAXPAW4AnimationPathTypes@@0ABW41@@Z ENDP ; std::fill<enum AnimationPathTypes *,enum AnimationPathTypes>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvString *,CvString *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvString *,CvString *,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN10@Copy_opt@3
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL3@Copy_opt@3:

; 2472 : 		*_Dest = *_First;

	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	add	edi, 28					; 0000001cH
	cmp	esi, ebx
	jne	SHORT $LL3@Copy_opt@3

; 2473 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
$LN10@Copy_opt@3:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvString *,CvString *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVCvFormationSlotEntry@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvFormationSlotEntry@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvFormationSlotEntry *,CvFormationSlotEntry *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAVCvFormationSlotEntry@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvFormationSlotEntry@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVCvFormationSlotEntry@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvFormationSlotEntry@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvFormationSlotEntry *,CvFormationSlotEntry *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAVCvFormationSlotEntry@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvFormationSlotEntry@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvFormationSlotEntry *,CvFormationSlotEntry *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::_Fill<CvString *,CvString>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z PROC ; std::_Fill<CvString *,CvString>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Fill@5
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
$LL3@Fill@5:

; 3159 : 		*_First = _Val;

	push	ebx
	mov	ecx, esi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Fill@5
	pop	ebx
$LN1@Fill@5:
	pop	edi
	pop	esi

; 3160 : 	}

	ret	0
??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ENDP ; std::_Fill<CvString *,CvString>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUProductionCostModifiers@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUProductionCostModifiers@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<ProductionCostModifiers *,ProductionCostModifiers *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAUProductionCostModifiers@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUProductionCostModifiers@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUProductionCostModifiers@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUProductionCostModifiers@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<ProductionCostModifiers *,ProductionCostModifiers *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw@2
	push	esi
$LL6@Move_backw@2:
	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw@2
	pop	esi
$LN5@Move_backw@2:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAUProductionCostModifiers@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUProductionCostModifiers@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<ProductionCostModifiers *,ProductionCostModifiers *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAW4AnimationPathTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4AnimationPathTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<enum AnimationPathTypes *,enum AnimationPathTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAW4AnimationPathTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4AnimationPathTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAW4AnimationPathTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4AnimationPathTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<enum AnimationPathTypes *,enum AnimationPathTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw@3
	push	esi
$LL6@Move_backw@3:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw@3
	pop	esi
$LN5@Move_backw@3:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAW4AnimationPathTypes@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4AnimationPathTypes@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<enum AnimationPathTypes *,enum AnimationPathTypes *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCvFormationSlotEntry@@@std@@QAEXPAVCvFormationSlotEntry@@ABV3@@Z ; std::allocator<CvFormationSlotEntry>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@VCvFormationSlotEntry@@@std@@QAEXPAVCvFormationSlotEntry@@ABV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCvFormationSlotEntry@@@std@@QAEXPAVCvFormationSlotEntry@@ABV3@@Z PROC ; std::allocator<CvFormationSlotEntry>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN5@construct@2:

; 156  : 		}

	ret	8
?construct@?$allocator@VCvFormationSlotEntry@@@std@@QAEXPAVCvFormationSlotEntry@@ABV3@@Z ENDP ; std::allocator<CvFormationSlotEntry>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VCvFormationSlotEntry@@@std@@QAEXPAVCvFormationSlotEntry@@@Z ; std::allocator<CvFormationSlotEntry>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@VCvFormationSlotEntry@@@std@@QAEXPAVCvFormationSlotEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCvFormationSlotEntry@@@std@@QAEXPAVCvFormationSlotEntry@@@Z PROC ; std::allocator<CvFormationSlotEntry>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@VCvFormationSlotEntry@@@std@@QAEXPAVCvFormationSlotEntry@@@Z ENDP ; std::allocator<CvFormationSlotEntry>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UProductionCostModifiers@@@std@@QAEXPAUProductionCostModifiers@@ABU3@@Z ; std::allocator<ProductionCostModifiers>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@UProductionCostModifiers@@@std@@QAEXPAUProductionCostModifiers@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UProductionCostModifiers@@@std@@QAEXPAUProductionCostModifiers@@ABU3@@Z PROC ; std::allocator<ProductionCostModifiers>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN5@construct@3:

; 156  : 		}

	ret	8
?construct@?$allocator@UProductionCostModifiers@@@std@@QAEXPAUProductionCostModifiers@@ABU3@@Z ENDP ; std::allocator<ProductionCostModifiers>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UProductionCostModifiers@@@std@@QAEXPAUProductionCostModifiers@@@Z ; std::allocator<ProductionCostModifiers>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@UProductionCostModifiers@@@std@@QAEXPAUProductionCostModifiers@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UProductionCostModifiers@@@std@@QAEXPAUProductionCostModifiers@@@Z PROC ; std::allocator<ProductionCostModifiers>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@UProductionCostModifiers@@@std@@QAEXPAUProductionCostModifiers@@@Z ENDP ; std::allocator<ProductionCostModifiers>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@ABW43@@Z ; std::allocator<enum AnimationPathTypes>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@ABW43@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@ABW43@@Z PROC ; std::allocator<enum AnimationPathTypes>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@4
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@4:

; 156  : 		}

	ret	8
?construct@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@ABW43@@Z ENDP ; std::allocator<enum AnimationPathTypes>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@@Z ; std::allocator<enum AnimationPathTypes>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@@Z PROC ; std::allocator<enum AnimationPathTypes>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@W4AnimationPathTypes@@@std@@QAEXPAW4AnimationPathTypes@@@Z ENDP ; std::allocator<enum AnimationPathTypes>::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@PAUProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@2@@std@@YAPAUProductionCostModifiers@@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@0@0PAU1@AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@PAUProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@2@@std@@YAPAUProductionCostModifiers@@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@0@0PAU1@AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@PAUProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@2@@std@@YAPAUProductionCostModifiers@@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@0@0PAU1@AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
$LL14@Uninit_cop@2:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@2
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
$LN5@Uninit_cop@2:
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __First$[esp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@PAUProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@2@@std@@YAPAUProductionCostModifiers@@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@0@0PAU1@AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvString *,CvString *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvString *,CvString *,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebx

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	cmp	ebx, esi
	je	SHORT $LN9@Copy_backw@5
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL2@Copy_backw@5:

; 2676 : 		*--_Dest = *--_Last;

	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	cmp	esi, ebx
	jne	SHORT $LL2@Copy_backw@5

; 2677 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
$LN9@Copy_backw@5:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvString *,CvString *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z ; std::_Construct<CvString,CvString>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.h
xdata$x	SEGMENT
__unwindtable$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z$0
__ehfuncinfo$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
_TEXT	SEGMENT
$T235382 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z PROC ; std::_Construct<CvString,CvString>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$[esp+12], ecx

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T235382[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN3@Construct@6
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN3@Construct@6:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T235382[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z ENDP ; std::_Construct<CvString,CvString>
PUBLIC	??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z	; std::_Destroy<CvString>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z PROC	; std::_Destroy<CvString>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z ENDP	; std::_Destroy<CvString>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@3
	push	esi
$LL6@Uninit_cop@3:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@3
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
$LN5@Uninit_cop@3:
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@3
	pop	esi
$LN4@Uninit_cop@3:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@4
	push	esi
$LL6@Uninit_cop@4:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@4
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
$LN5@Uninit_cop@4:
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@4
	pop	esi
$LN4@Uninit_cop@4:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@5
	push	esi
$LL6@Uninit_cop@5:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@5
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@5:
	add	ecx, 4
	add	eax, 4
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@5
	pop	esi
$LN4@Uninit_cop@5:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@I@std@@QAEXPAIABI@Z	; std::allocator<unsigned int>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@I@std@@QAEXPAIABI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@I@std@@QAEXPAIABI@Z PROC		; std::allocator<unsigned int>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@5
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@5:

; 156  : 		}

	ret	8
?construct@?$allocator@I@std@@QAEXPAIABI@Z ENDP		; std::allocator<unsigned int>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@I@std@@QAEXPAI@Z		; std::allocator<unsigned int>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@I@std@@QAEXPAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@I@std@@QAEXPAI@Z PROC		; std::allocator<unsigned int>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@I@std@@QAEXPAI@Z ENDP		; std::allocator<unsigned int>::destroy
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEAAIXZ ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEAAIXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEAAIXZ PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBEAAIXZ ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator++
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=, COMDAT
; _this$ = ecx

; 1822 : 		*(_Mybase *)this += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=

; 1823 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1824 : 		}

	ret	4
??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
_TEXT	ENDS
PUBLIC	??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+, COMDAT
; _this$ = ecx

; 1827 : 		{	// return this + integer

	sub	esp, 8

; 1828 : 		_Mytype _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]

; 1829 : 		return (_Tmp += _Off);

	mov	edx, DWORD PTR __Off$[esp+4]
	mov	DWORD PTR __Tmp$[esp+12], ecx
	push	edx
	lea	ecx, DWORD PTR __Tmp$[esp+12]
	mov	DWORD PTR __Tmp$[esp+12], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Tmp$[esp+8]
	mov	edx, DWORD PTR __Tmp$[esp+12]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1830 : 		}

	add	esp, 8
	ret	8
??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
_TEXT	ENDS
PUBLIC	??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-, COMDAT
; _this$ = ecx

; 1845 : 		return (*(_Mybase *)this - _Right);

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx]
	sar	eax, 2
	shl	eax, 5
	sub	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR [ecx+4]

; 1846 : 		}

	ret	4
??G?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEHABV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator-
_TEXT	ENDS
PUBLIC	?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@I@std@@QAEPAII@Z		; std::allocator<unsigned int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@I@std@@QAEPAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@I@std@@QAEPAII@Z PROC		; std::allocator<unsigned int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@I@std@@QAEPAII@Z ENDP		; std::allocator<unsigned int>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1567 : 		{	// construct with offset and pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1568 : 		}

	ret	4
??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Make_iter
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator!=
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z	; stdext::unchecked_copy<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z PROC	; stdext::unchecked_copy<unsigned int *,unsigned int *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ENDP	; stdext::unchecked_copy<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::begin, COMDAT
; _this$ = ecx

; 1990 : 		return (const_iterator(_VEC_ITER_BASE(_Myvec.begin())));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1991 : 		}

	ret	4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::begin
_TEXT	ENDS
PUBLIC	??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++, COMDAT
; _this$ = ecx

; 1576 : 		{	// preincrement

	mov	eax, ecx

; 1577 : 		_Inc();

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN4@operator@8
	inc	ecx
	mov	DWORD PTR [eax+4], ecx

; 1578 : 		return (*this);
; 1579 : 		}

	ret	0

; 1577 : 		_Inc();

$LN4@operator@8:
	add	DWORD PTR [eax], 4
	mov	DWORD PTR [eax+4], 0

; 1578 : 		return (*this);
; 1579 : 		}

	ret	0
??E?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator!=, COMDAT
; _this$ = ecx

; 1677 : 		return (!(*this == _Right));

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@operator@9
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN5@operator@9
	mov	eax, 1
	xor	edx, edx
	test	al, al
	sete	dl
	mov	al, dl

; 1678 : 		}

	ret	4

; 1677 : 		return (!(*this == _Right));

$LN5@operator@9:
	xor	eax, eax
	xor	edx, edx
	test	al, al
	sete	dl
	mov	al, dl

; 1678 : 		}

	ret	4
??9?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator!=
_TEXT	ENDS
PUBLIC	??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator bool
; Function compile flags: /Ogtpy
;	COMDAT ??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator bool, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if bit is set

	mov	edx, ecx

; 1495 : 		return ((*_Getptr() & _Mask()) != 0);

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR [edx]
	and	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	neg	eax

; 1496 : 		}

	ret	0
??B?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator bool
_TEXT	ENDS
PUBLIC	??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++, COMDAT
; _this$ = ecx

; 1795 : 		{	// preincrement

	mov	eax, ecx

; 1796 : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN6@operator@10
	inc	ecx
	mov	DWORD PTR [eax+4], ecx

; 1797 : 		return (*this);
; 1798 : 		}

	ret	0

; 1796 : 		++*(_Mybase *)this;

$LN6@operator@10:
	add	DWORD PTR [eax], 4
	mov	DWORD PTR [eax+4], 0

; 1797 : 		return (*this);
; 1798 : 		}

	ret	0
??E?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator++
_TEXT	ENDS
PUBLIC	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=, COMDAT
; _this$ = ecx

; 1471 : 		return (*this = bool(_Right));

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR [edx+4]
	push	esi
	mov	esi, 1
	shl	esi, cl
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax]
	test	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	mov	esi, 1
	je	SHORT $LN10@operator@11
	shl	esi, cl
	or	DWORD PTR [edx], esi
	pop	esi

; 1472 : 		}

	ret	4

; 1471 : 		return (*this = bool(_Right));

$LN10@operator@11:
	shl	esi, cl
	not	esi
	and	DWORD PTR [edx], esi
	pop	esi

; 1472 : 		}

	ret	4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
_TEXT	ENDS
PUBLIC	??$fill@PAII@std@@YAXPAI0ABI@Z			; std::fill<unsigned int *,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAII@std@@YAXPAI0ABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAII@std@@YAXPAI0ABI@Z PROC			; std::fill<unsigned int *,unsigned int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@4
	pop	esi
$LN3@fill@4:

; 3188 : 	}

	ret	0
??$fill@PAII@std@@YAXPAI0ABI@Z ENDP			; std::fill<unsigned int *,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z PROC ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
	npad	3

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

$LL10@Fill@6:
	cmp	eax, DWORD PTR __Last$[esp]
	jne	SHORT $LN18@Fill@6
	cmp	ecx, DWORD PTR __Last$[esp+4]
	je	SHORT $LN40@Fill@6
$LN18@Fill@6:

; 3159 : 		*_First = _Val;

	mov	esi, 1
	shl	esi, cl
	cmp	BYTE PTR [edx], 0
	je	SHORT $LN27@Fill@6
	or	DWORD PTR [eax], esi
	jmp	SHORT $LN2@Fill@6
$LN27@Fill@6:
	not	esi
	and	DWORD PTR [eax], esi
$LN2@Fill@6:
	mov	ecx, DWORD PTR __First$[esp+4]
	mov	eax, DWORD PTR __First$[esp]
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN11@Fill@6
	inc	ecx
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LL10@Fill@6

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

$LN11@Fill@6:
	xor	ecx, ecx
	add	eax, 4
	mov	DWORD PTR __First$[esp+4], ecx
	mov	DWORD PTR __First$[esp], eax
	jmp	SHORT $LL10@Fill@6
$LN40@Fill@6:
	pop	esi

; 3160 : 	}

	ret	0
??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ENDP ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@4
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@4:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--, COMDAT
; _this$ = ecx

; 1589 : 		{	// predecrement

	mov	eax, ecx

; 1590 : 		_Dec();

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN4@operator@12
	dec	ecx
	mov	DWORD PTR [eax+4], ecx

; 1591 : 		return (*this);
; 1592 : 		}

	ret	0

; 1590 : 		_Dec();

$LN4@operator@12:
	add	DWORD PTR [eax], -4			; fffffffcH
	mov	DWORD PTR [eax+4], 31			; 0000001fH

; 1591 : 		return (*this);
; 1592 : 		}

	ret	0
??F?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned int *,unsigned int,unsigned int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@2
	pop	esi
$LN3@Fill_n@2:

; 3243 : 	}

	ret	0
??$_Fill_n@PAIIIUrandom_access_iterator_tag@std@@@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned int *,unsigned int,unsigned int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??_7CvHotKeyInfo@@6B@				; CvHotKeyInfo::`vftable'
PUBLIC	??0CvHotKeyInfo@@QAE@XZ				; CvHotKeyInfo::CvHotKeyInfo
PUBLIC	??_R4CvHotKeyInfo@@6B@				; CvHotKeyInfo::`RTTI Complete Object Locator'
PUBLIC	?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvHotKeyInfo::CacheResults
;	COMDAT ??_R4CvHotKeyInfo@@6B@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R4CvHotKeyInfo@@6B@ DD 00H				; CvHotKeyInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvHotKeyInfo@@@8
	DD	FLAT:??_R3CvHotKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvHotKeyInfo@@6B@
CONST	SEGMENT
??_7CvHotKeyInfo@@6B@ DD FLAT:??_R4CvHotKeyInfo@@6B@	; CvHotKeyInfo::`vftable'
	DD	FLAT:?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CvHotKeyInfo@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0CvHotKeyInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvHotKeyInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvHotKeyInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvHotKeyInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvHotKeyInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvHotKeyInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvHotKeyInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvHotKeyInfo@@QAE@XZ$5
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvHotKeyInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvHotKeyInfo@@QAE@XZ PROC				; CvHotKeyInfo::CvHotKeyInfo, COMDAT
; _this$ = ecx

; 157  : {

	push	-1
	push	__ehhandler$??0CvHotKeyInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	or	ecx, -1
	mov	DWORD PTR [esi+260], ecx
	mov	DWORD PTR [esi+264], ecx
	mov	DWORD PTR [esi+268], ecx
	mov	DWORD PTR [esi+272], ecx
	mov	DWORD PTR [esi+276], ecx
	lea	ecx, DWORD PTR [esi+292]
	mov	DWORD PTR __$EHRec$[esp+28], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvHotKeyInfo@@6B@
	mov	DWORD PTR [esi+280], eax
	mov	BYTE PTR [esi+284], al
	mov	BYTE PTR [esi+285], al
	mov	BYTE PTR [esi+286], al
	mov	BYTE PTR [esi+287], al
	mov	BYTE PTR [esi+288], al
	mov	BYTE PTR [esi+289], al
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+320]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+348]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+376]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+404]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+432]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 158  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvHotKeyInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvHotKeyInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvHotKeyInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 320				; 00000140H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvHotKeyInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 348				; 0000015cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvHotKeyInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 376				; 00000178H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvHotKeyInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvHotKeyInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvHotKeyInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvHotKeyInfo@@QAE@XZ ENDP				; CvHotKeyInfo::CvHotKeyInfo
PUBLIC	?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z ; CvHotKeyInfo::CreateHotKeyFromDescription
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z$4
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z
_TEXT	SEGMENT
$T236009 = -44						; size = 4
$T236007 = -40						; size = 28
$T236006 = -40						; size = 28
$T236005 = -40						; size = 28
$T236004 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_pszHotKey$ = 12					; size = 4
_bShift$ = 16						; size = 1
_bAlt$ = 20						; size = 1
_bCtrl$ = 24						; size = 1
?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z PROC ; CvHotKeyInfo::CreateHotKeyFromDescription, COMDAT

; 315  : {

	push	-1
	push	__ehhandler$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T236009[esp+52], ebx

; 316  : 	CvString strHotKey;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+48]
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+64], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 336  : 	}
; 337  : 
; 338  : 	return strHotKey;

	mov	edi, DWORD PTR _pszHotKey$[esp+52]
	mov	DWORD PTR __$EHRec$[esp+64], ebx
	mov	DWORD PTR $T236009[esp+56], 1
	cmp	edi, ebx
	je	$LN33@CreateHotK
	mov	ecx, OFFSET $SG218809
	mov	eax, edi
$LL28@CreateHotK:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN29@CreateHotK

; 317  : 
; 318  : 	if(pszHotKey && strcmp(pszHotKey,"") != 0)

	cmp	dl, bl
	je	SHORT $LN30@CreateHotK
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN29@CreateHotK
	add	eax, 2
	add	ecx, 2
	cmp	dl, bl
	jne	SHORT $LL28@CreateHotK
$LN30@CreateHotK:
	xor	eax, eax
	jmp	SHORT $LN31@CreateHotK
$LN29@CreateHotK:
	sbb	eax, eax
	sbb	eax, -1
$LN31@CreateHotK:
	cmp	eax, ebx
	je	$LN33@CreateHotK

; 319  : 	{
; 320  : 		if(bShift)

	cmp	BYTE PTR _bShift$[esp+52], bl
	je	SHORT $LN3@CreateHotK

; 321  : 		{
; 322  : 			strHotKey += GetLocalizedText("TXT_KEY_SHIFT");

	lea	eax, DWORD PTR $T236004[esp+56]
	push	OFFSET $SG218812
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+68], 1
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236004[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@CreateHotK:

; 323  : 		}
; 324  : 
; 325  : 		if(bAlt)

	cmp	BYTE PTR _bAlt$[esp+52], bl
	je	SHORT $LN2@CreateHotK

; 326  : 		{
; 327  : 			strHotKey += GetLocalizedText("TXT_KEY_ALT");

	lea	ecx, DWORD PTR $T236005[esp+56]
	push	OFFSET $SG218815
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+68], 2
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236005[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@CreateHotK:

; 328  : 		}
; 329  : 
; 330  : 		if(bCtrl)

	cmp	BYTE PTR _bCtrl$[esp+52], bl
	je	SHORT $LN1@CreateHotK

; 331  : 		{
; 332  : 			strHotKey += GetLocalizedText("TXT_KEY_CTRL");

	lea	edx, DWORD PTR $T236006[esp+56]
	push	OFFSET $SG218818
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+68], 3
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236006[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@CreateHotK:

; 333  : 		}
; 334  : 
; 335  : 		strHotKey += CreateKeyStringFromKBCode(pszHotKey);

	lea	eax, DWORD PTR $T236007[esp+56]
	push	edi
	push	eax
	call	?CreateKeyStringFromKBCode@CvHotKeyInfo@@SA?AVCvString@@PBD@Z ; CvHotKeyInfo::CreateKeyStringFromKBCode
	add	esp, 8
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+68], 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T236007[esp+56]
	mov	BYTE PTR __$EHRec$[esp+64], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN33@CreateHotK:

; 339  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z$0:
	mov	eax, DWORD PTR $T236009[ebp]
	and	eax, 1
	je	$LN8@CreateHotK
	and	DWORD PTR $T236009[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN8@CreateHotK:
	ret	0
__unwindfunclet$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z$1:
	lea	ecx, DWORD PTR $T236004[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z$2:
	lea	ecx, DWORD PTR $T236005[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z$3:
	lea	ecx, DWORD PTR $T236006[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z$4:
	lea	ecx, DWORD PTR $T236007[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z:
	mov	eax, OFFSET __ehfuncinfo$?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z ENDP ; CvHotKeyInfo::CreateHotKeyFromDescription
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
__ehfuncinfo$?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
$T236050 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvHotKeyInfo::CacheResults, COMDAT
; _this$ = ecx

; 492  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax

; 493  : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+44]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN3@CacheResul@30
	pop	edi
	pop	esi

; 526  : 
; 527  : 	return true;
; 528  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
$LN3@CacheResul@30:
	push	ebx
	push	ebp

; 494  : 		return false;
; 495  : 
; 496  : 	setHotKey(kResults.GetText("HotKey"));

	mov	ebp, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG219066
	mov	ecx, edi
	call	ebp
	lea	ecx, DWORD PTR [esi+292]
	test	eax, eax
	je	SHORT $LN10@CacheResul@30
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN9@CacheResul@30
$LN10@CacheResul@30:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN9@CacheResul@30:

; 497  : 	const int iHotKeyVal = GetHotKeyInt(kResults.GetText("HotKey"));

	push	OFFSET $SG219068
	mov	ecx, edi
	call	ebp
	push	eax
	mov	ecx, esi
	call	?GetHotKeyInt@CvHotKeyInfo@@IAEHPBD@Z	; CvHotKeyInfo::GetHotKeyInt

; 498  : 	setHotKeyVal(iHotKeyVal);
; 499  : 	setHotKeyPriority(kResults.GetInt("HotKeyPriority"));

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG219069
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 500  : 
; 501  : 	const int iHotKeyValAlt = GetHotKeyInt(kResults.GetText("HotKeyAlt"));

	push	OFFSET $SG219071
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebp
	push	eax
	mov	ecx, esi
	call	?GetHotKeyInt@CvHotKeyInfo@@IAEHPBD@Z	; CvHotKeyInfo::GetHotKeyInt

; 502  : 	setHotKeyValAlt(iHotKeyValAlt);
; 503  : 	setHotKeyPriorityAlt(kResults.GetInt("HotKeyPriorityAlt"));

	push	OFFSET $SG219072
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebx

; 504  : 
; 505  : 	setAltDown(kResults.GetBool("AltDown"));

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG219073
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebx

; 506  : 	setAltDownAlt(kResults.GetBool("AltDownAlt"));

	push	OFFSET $SG219074
	mov	ecx, edi
	mov	BYTE PTR [esi+284], al
	call	ebx

; 507  : 
; 508  : 	setShiftDown(kResults.GetBool("ShiftDown"));

	push	OFFSET $SG219075
	mov	ecx, edi
	mov	BYTE PTR [esi+287], al
	call	ebx

; 509  : 	setShiftDownAlt(kResults.GetBool("ShiftDownAlt"));

	push	OFFSET $SG219076
	mov	ecx, edi
	mov	BYTE PTR [esi+285], al
	call	ebx

; 510  : 
; 511  : 	setCtrlDown(kResults.GetBool("CtrlDown"));

	push	OFFSET $SG219077
	mov	ecx, edi
	mov	BYTE PTR [esi+288], al
	call	ebx

; 512  : 	setCtrlDownAlt(kResults.GetBool("CtrlDownAlt"));

	push	OFFSET $SG219078
	mov	ecx, edi
	mov	BYTE PTR [esi+286], al
	call	ebx

; 513  : 
; 514  : 	setOrderPriority(kResults.GetInt("OrderPriority"));

	push	OFFSET $SG219079
	mov	ecx, edi
	mov	BYTE PTR [esi+289], al
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z

; 515  : 
; 516  : 	const char* szHelp = kResults.GetText("Help");

	push	OFFSET $SG219081
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebp

; 517  : 	if(szHelp)

	test	eax, eax
	je	SHORT $LN35@CacheResul@30

; 518  : 		m_strHelp = szHelp;

	lea	ecx, DWORD PTR [esi+404]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN35@CacheResul@30:

; 519  : 
; 520  : 	const char* szDisabledHelp = kResults.GetText("DisabledHelp");

	push	OFFSET $SG219084
	mov	ecx, edi
	call	ebp

; 521  : 	if(szDisabledHelp)

	test	eax, eax
	je	SHORT $LN39@CacheResul@30

; 522  : 		m_strDisabledHelp = szDisabledHelp;

	lea	ecx, DWORD PTR [esi+432]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN39@CacheResul@30:

; 523  : 
; 524  : 
; 525  : 	setHotKeyDescription(GetTextKey(), NULL, CreateHotKeyFromDescription(getHotKey(), m_bShiftDown, m_bAltDown, m_bCtrlDown));

	lea	ecx, DWORD PTR [esi+292]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	movzx	ecx, BYTE PTR [esi+286]
	movzx	edx, BYTE PTR [esi+284]
	push	ecx
	movzx	ecx, BYTE PTR [esi+285]
	push	edx
	push	ecx
	push	eax
	lea	edx, DWORD PTR $T236050[esp+72]
	push	edx
	call	?CreateHotKeyFromDescription@CvHotKeyInfo@@SA?AVCvString@@PBD_N11@Z ; CvHotKeyInfo::CreateHotKeyFromDescription
	add	esp, 20					; 00000014H
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+64], 0
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	edi, DWORD PTR [esi+204]
	mov	ecx, edi
	mov	ebx, eax
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	test	al, al
	je	SHORT $LN51@CacheResul@30
	xor	eax, eax
	jmp	SHORT $LN52@CacheResul@30
$LN51@CacheResul@30:
	mov	ecx, edi
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LN52@CacheResul@30:
	lea	ecx, DWORD PTR [esi+320]
	test	eax, eax
	je	SHORT $LN56@CacheResul@30
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN55@CacheResul@30
$LN56@CacheResul@30:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN55@CacheResul@30:
	lea	ecx, DWORD PTR [esi+348]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	lea	ecx, DWORD PTR [esi+376]
	test	ebx, ebx
	je	SHORT $LN64@CacheResul@30
	push	ebx
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN63@CacheResul@30
$LN64@CacheResul@30:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN63@CacheResul@30:
	lea	ecx, DWORD PTR $T236050[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 526  : 
; 527  : 	return true;
; 528  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	ebp
	pop	ebx
	pop	edi
	mov	al, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR $T236050[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvHotKeyInfo::CacheResults
PUBLIC	??0CvSpecialistInfo@@QAE@XZ			; CvSpecialistInfo::CvSpecialistInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??0CvSpecialistInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvSpecialistInfo@@QAE@XZ$0
__ehfuncinfo$??0CvSpecialistInfo@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvSpecialistInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvSpecialistInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvSpecialistInfo@@QAE@XZ PROC			; CvSpecialistInfo::CvSpecialistInfo, COMDAT
; _this$ = ecx

; 721  : {

	push	-1
	push	__ehhandler$??0CvSpecialistInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	??0CvHotKeyInfo@@QAE@XZ			; CvHotKeyInfo::CvHotKeyInfo
	xor	ebx, ebx
	or	eax, -1
	lea	ecx, DWORD PTR [esi+488]
	mov	DWORD PTR __$EHRec$[esp+32], ebx
	mov	DWORD PTR [esi], OFFSET ??_7CvSpecialistInfo@@6B@
	mov	DWORD PTR [esi+460], ebx
	mov	DWORD PTR [esi+464], eax
	mov	DWORD PTR [esi+468], ebx
	mov	DWORD PTR [esi+472], ebx
	mov	DWORD PTR [esi+476], eax
	mov	DWORD PTR [esi+480], ebx
	mov	BYTE PTR [esi+484], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 722  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+516], ebx
	mov	DWORD PTR [esi+520], ebx
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvSpecialistInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvHotKeyInfo@@QAE@XZ
__ehhandler$??0CvSpecialistInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvSpecialistInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvSpecialistInfo@@QAE@XZ ENDP			; CvSpecialistInfo::CvSpecialistInfo
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvSpecialistInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvSpecialistInfo@@UAEPAXI@Z PROC			; CvSpecialistInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvSpecialistInfo@@UAE@XZ		; CvSpecialistInfo::~CvSpecialistInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@6:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvSpecialistInfo@@UAEPAXI@Z ENDP			; CvSpecialistInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvSpecialistInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvSpecialistInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvSpecialistInfo::CacheResults, COMDAT
; _this$ = ecx

; 800  : {

	push	ebp

; 801  : 	if(!CvHotKeyInfo::CacheResults(kResults, kUtility))

	mov	ebp, DWORD PTR _kUtility$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+8]
	push	ebp
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvHotKeyInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@31
	pop	edi
	pop	esi
	pop	ebp

; 821  : }

	ret	8
$LN1@CacheResul@31:
	push	ebx

; 802  : 		return false;
; 803  : 
; 804  : 	m_bVisible = kResults.GetBool("Visible");

	push	OFFSET $SG219276
	mov	ecx, edi
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 805  : 	m_iCost = kResults.GetInt("Cost");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG219277
	mov	ecx, edi
	mov	BYTE PTR [esi+484], al
	call	ebx

; 806  : 	m_iExperience = kResults.GetInt("Experience");

	push	OFFSET $SG219278
	mov	ecx, edi
	mov	DWORD PTR [esi+460], eax
	call	ebx

; 807  : 	m_iGreatPeopleRateChange = kResults.GetInt("GreatPeopleRateChange");

	push	OFFSET $SG219279
	mov	ecx, edi
	mov	DWORD PTR [esi+480], eax
	call	ebx

; 808  : 	m_iCulturePerTurn = kResults.GetInt("CulturePerTurn");

	push	OFFSET $SG219280
	mov	ecx, edi
	mov	DWORD PTR [esi+468], eax
	call	ebx

; 809  : 
; 810  : 	setTexture(kResults.GetText("Texture"));

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG219281
	mov	ecx, edi
	mov	DWORD PTR [esi+472], eax
	call	ebx
	lea	ecx, DWORD PTR [esi+488]
	test	eax, eax
	je	SHORT $LN7@CacheResul@31
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN6@CacheResul@31
$LN7@CacheResul@31:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN6@CacheResul@31:

; 811  : 
; 812  : 	const char* szGreatPeople = kResults.GetText("GreatPeopleUnitClass");

	push	OFFSET $SG219283
	mov	ecx, edi
	call	ebx

; 813  : 	m_iGreatPeopleUnitClass = GC.getInfoTypeForString(szGreatPeople, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 814  : 
; 815  : 	//Arrays
; 816  : 	const char* szType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+464], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 817  : 	kUtility.SetFlavors(m_piFlavorValue, "SpecialistFlavors", "SpecialistType", szType);

	push	0
	mov	edi, eax
	push	edi
	push	OFFSET $SG219285
	push	OFFSET $SG219286
	lea	eax, DWORD PTR [esi+520]
	push	eax
	mov	ecx, ebp
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 818  : 	kUtility.SetYields(m_piYieldChange, "SpecialistYields", "SpecialistType", szType);

	push	edi
	push	OFFSET $SG219287
	push	OFFSET $SG219288
	add	esi, 516				; 00000204H
	push	esi
	mov	ecx, ebp
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields
	pop	ebx
	pop	edi
	pop	esi

; 819  : 
; 820  : 	return true;

	mov	al, 1
	pop	ebp

; 821  : }

	ret	8
?CacheResults@CvSpecialistInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvSpecialistInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvMissionInfo@@6B@				; CvMissionInfo::`vftable'
PUBLIC	??0CvMissionInfo@@QAE@XZ			; CvMissionInfo::CvMissionInfo
PUBLIC	??_R4CvMissionInfo@@6B@				; CvMissionInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvMissionInfo@@@8			; CvMissionInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvMissionInfo@@8				; CvMissionInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvMissionInfo@@8				; CvMissionInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvMissionInfo@@8			; CvMissionInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvMissionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvMissionInfo::CacheResults
;	COMDAT ??_R1A@?0A@EA@CvMissionInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvMissionInfo@@8 DD FLAT:??_R0?AVCvMissionInfo@@@8 ; CvMissionInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvMissionInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvMissionInfo@@8
rdata$r	SEGMENT
??_R2CvMissionInfo@@8 DD FLAT:??_R1A@?0A@EA@CvMissionInfo@@8 ; CvMissionInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvHotKeyInfo@@8
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvMissionInfo@@8
rdata$r	SEGMENT
??_R3CvMissionInfo@@8 DD 00H				; CvMissionInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvMissionInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvMissionInfo@@@8
_DATA	SEGMENT
??_R0?AVCvMissionInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvMissionInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvMissionInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvMissionInfo@@6B@
rdata$r	SEGMENT
??_R4CvMissionInfo@@6B@ DD 00H				; CvMissionInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvMissionInfo@@@8
	DD	FLAT:??_R3CvMissionInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvMissionInfo@@6B@
CONST	SEGMENT
??_7CvMissionInfo@@6B@ DD FLAT:??_R4CvMissionInfo@@6B@	; CvMissionInfo::`vftable'
	DD	FLAT:?CacheResults@CvMissionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvMissionInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvMissionInfo@@QAE@XZ$0
__ehfuncinfo$??0CvMissionInfo@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvMissionInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvMissionInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvMissionInfo@@QAE@XZ PROC				; CvMissionInfo::CvMissionInfo, COMDAT
; _this$ = ecx

; 833  : {

	push	-1
	push	__ehhandler$??0CvMissionInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	??0CvHotKeyInfo@@QAE@XZ			; CvHotKeyInfo::CvHotKeyInfo
	xor	eax, eax
	lea	ecx, DWORD PTR [esi+472]
	mov	DWORD PTR __$EHRec$[esp+28], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvMissionInfo@@6B@
	mov	DWORD PTR [esi+460], eax
	mov	BYTE PTR [esi+464], al
	mov	BYTE PTR [esi+465], al
	mov	BYTE PTR [esi+466], al
	mov	BYTE PTR [esi+467], al
	mov	DWORD PTR [esi+468], -1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 834  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvMissionInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvHotKeyInfo@@QAE@XZ
__ehhandler$??0CvMissionInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvMissionInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvMissionInfo@@QAE@XZ ENDP				; CvMissionInfo::CvMissionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvMissionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvMissionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvMissionInfo::CacheResults, COMDAT
; _this$ = ecx

; 873  : 	if(!CvHotKeyInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	mov	esi, DWORD PTR _kResults$[esp]
	push	edi
	push	eax
	push	esi
	mov	edi, ecx
	call	?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvHotKeyInfo::CacheResults
	test	al, al
	jne	SHORT $LN3@CacheResul@32
	pop	edi
	pop	esi

; 894  : }

	ret	8
$LN3@CacheResul@32:
	push	ebx
	push	ebp

; 874  : 		return false;
; 875  : 
; 876  : 	m_strWaypoint	= kResults.GetText("Waypoint");

	mov	ebp, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG219319
	mov	ecx, esi
	call	ebp
	lea	ecx, DWORD PTR [edi+472]
	test	eax, eax
	je	SHORT $LN7@CacheResul@32
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN6@CacheResul@32
$LN7@CacheResul@32:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN6@CacheResul@32:

; 877  : 	m_iTime			= kResults.GetInt("Time");

	push	OFFSET $SG219320
	mov	ecx, esi
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z

; 878  : 	m_bSound		= kResults.GetBool("Sound");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG219321
	mov	ecx, esi
	mov	DWORD PTR [edi+460], eax
	call	ebx

; 879  : 	m_bTarget		= kResults.GetBool("Target");

	push	OFFSET $SG219322
	mov	ecx, esi
	mov	BYTE PTR [edi+464], al
	call	ebx

; 880  : 	m_bBuild		= kResults.GetBool("Build");

	push	OFFSET $SG219323
	mov	ecx, esi
	mov	BYTE PTR [edi+465], al
	call	ebx

; 881  : 	m_bVisible		= kResults.GetBool("Visible");

	push	OFFSET $SG219324
	mov	ecx, esi
	mov	BYTE PTR [edi+466], al
	call	ebx

; 882  : 
; 883  : 	const char* szEntityEventType = kResults.GetText("EntityEventType");

	push	OFFSET $SG219326
	mov	ecx, esi
	mov	BYTE PTR [edi+467], al
	call	ebp
	pop	ebp
	pop	ebx

; 884  : 	if(szEntityEventType)

	test	eax, eax
	je	SHORT $LN2@CacheResul@32

; 885  : 	{
; 886  : 		m_eEntityEvent = (EntityEventTypes)GC.getInfoTypeForString(szEntityEventType, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [edi+468], eax
	pop	edi

; 891  : 	}
; 892  : 
; 893  : 	return true;

	mov	al, 1
	pop	esi

; 894  : }

	ret	8
$LN2@CacheResul@32:

; 887  : 	}
; 888  : 	else
; 889  : 	{
; 890  : 		m_eEntityEvent = ENTITY_EVENT_NONE;

	mov	DWORD PTR [edi+468], -1
	pop	edi

; 891  : 	}
; 892  : 
; 893  : 	return true;

	mov	al, 1
	pop	esi

; 894  : }

	ret	8
?CacheResults@CvMissionInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvMissionInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvCommandInfo@@6B@				; CvCommandInfo::`vftable'
PUBLIC	??0CvCommandInfo@@QAE@XZ			; CvCommandInfo::CvCommandInfo
PUBLIC	??_R4CvCommandInfo@@6B@				; CvCommandInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvCommandInfo@@@8			; CvCommandInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvCommandInfo@@8				; CvCommandInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvCommandInfo@@8				; CvCommandInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvCommandInfo@@8			; CvCommandInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvCommandInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvCommandInfo::CacheResults
;	COMDAT ??_R1A@?0A@EA@CvCommandInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvCommandInfo@@8 DD FLAT:??_R0?AVCvCommandInfo@@@8 ; CvCommandInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvCommandInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvCommandInfo@@8
rdata$r	SEGMENT
??_R2CvCommandInfo@@8 DD FLAT:??_R1A@?0A@EA@CvCommandInfo@@8 ; CvCommandInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvHotKeyInfo@@8
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvCommandInfo@@8
rdata$r	SEGMENT
??_R3CvCommandInfo@@8 DD 00H				; CvCommandInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvCommandInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvCommandInfo@@@8
_DATA	SEGMENT
??_R0?AVCvCommandInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvCommandInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvCommandInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvCommandInfo@@6B@
rdata$r	SEGMENT
??_R4CvCommandInfo@@6B@ DD 00H				; CvCommandInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvCommandInfo@@@8
	DD	FLAT:??_R3CvCommandInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvCommandInfo@@6B@
CONST	SEGMENT
??_7CvCommandInfo@@6B@ DD FLAT:??_R4CvCommandInfo@@6B@	; CvCommandInfo::`vftable'
	DD	FLAT:?CacheResults@CvCommandInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvCommandInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvCommandInfo@@QAE@XZ PROC				; CvCommandInfo::CvCommandInfo, COMDAT
; _this$ = ecx

; 904  : {

	push	esi
	mov	esi, ecx
	call	??0CvHotKeyInfo@@QAE@XZ			; CvHotKeyInfo::CvHotKeyInfo
	xor	al, al
	mov	BYTE PTR [esi+464], al
	mov	BYTE PTR [esi+465], al
	mov	BYTE PTR [esi+466], al
	mov	DWORD PTR [esi], OFFSET ??_7CvCommandInfo@@6B@
	mov	DWORD PTR [esi+460], -1

; 905  : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvCommandInfo@@QAE@XZ ENDP				; CvCommandInfo::CvCommandInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvCommandInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvCommandInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvCommandInfo::CacheResults, COMDAT
; _this$ = ecx

; 934  : 	if(!CvHotKeyInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvHotKeyInfo::CacheResults
	test	al, al
	jne	SHORT $LN2@CacheResul@33
	pop	edi
	pop	esi

; 946  : }

	ret	8
$LN2@CacheResul@33:

; 935  : 		return false;
; 936  : 
; 937  : 	const char* szAutomate = kResults.GetText("Automate");

	push	OFFSET $SG219356
	mov	ecx, edi
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 938  : 	if(szAutomate)

	test	eax, eax
	je	SHORT $LN5@CacheResul@33

; 939  : 		setAutomate(GC.getInfoTypeForString(szAutomate, true));

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+460], eax
$LN5@CacheResul@33:
	push	ebx

; 940  : 
; 941  : 	m_bConfirmCommand = kResults.GetBool("ConfirmCommand");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG219358
	mov	ecx, edi
	call	ebx

; 942  : 	m_bVisible = kResults.GetBool("Visible");

	push	OFFSET $SG219359
	mov	ecx, edi
	mov	BYTE PTR [esi+464], al
	call	ebx

; 943  : 	m_bAll = kResults.GetBool("All");

	push	OFFSET $SG219360
	mov	ecx, edi
	mov	BYTE PTR [esi+465], al
	call	ebx
	pop	ebx
	mov	BYTE PTR [esi+466], al
	pop	edi

; 944  : 
; 945  : 	return true;

	mov	al, 1
	pop	esi

; 946  : }

	ret	8
?CacheResults@CvCommandInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvCommandInfo::CacheResults
_TEXT	ENDS
PUBLIC	??_7CvAutomateInfo@@6B@				; CvAutomateInfo::`vftable'
PUBLIC	??0CvAutomateInfo@@QAE@XZ			; CvAutomateInfo::CvAutomateInfo
PUBLIC	??_R4CvAutomateInfo@@6B@			; CvAutomateInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAutomateInfo@@@8			; CvAutomateInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvAutomateInfo@@8				; CvAutomateInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAutomateInfo@@8				; CvAutomateInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAutomateInfo@@8			; CvAutomateInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvAutomateInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvAutomateInfo::CacheResults
;	COMDAT ??_R1A@?0A@EA@CvAutomateInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAutomateInfo@@8 DD FLAT:??_R0?AVCvAutomateInfo@@@8 ; CvAutomateInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAutomateInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAutomateInfo@@8
rdata$r	SEGMENT
??_R2CvAutomateInfo@@8 DD FLAT:??_R1A@?0A@EA@CvAutomateInfo@@8 ; CvAutomateInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvHotKeyInfo@@8
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAutomateInfo@@8
rdata$r	SEGMENT
??_R3CvAutomateInfo@@8 DD 00H				; CvAutomateInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvAutomateInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAutomateInfo@@@8
_DATA	SEGMENT
??_R0?AVCvAutomateInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvAutomateInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAutomateInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAutomateInfo@@6B@
rdata$r	SEGMENT
??_R4CvAutomateInfo@@6B@ DD 00H				; CvAutomateInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAutomateInfo@@@8
	DD	FLAT:??_R3CvAutomateInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvAutomateInfo@@6B@
CONST	SEGMENT
??_7CvAutomateInfo@@6B@ DD FLAT:??_R4CvAutomateInfo@@6B@ ; CvAutomateInfo::`vftable'
	DD	FLAT:?CacheResults@CvAutomateInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAutomateInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvAutomateInfo@@QAE@XZ PROC				; CvAutomateInfo::CvAutomateInfo, COMDAT
; _this$ = ecx

; 956  : {

	push	esi
	mov	esi, ecx
	call	??0CvHotKeyInfo@@QAE@XZ			; CvHotKeyInfo::CvHotKeyInfo
	or	eax, -1
	mov	DWORD PTR [esi+460], eax
	mov	DWORD PTR [esi+464], eax
	xor	al, al
	mov	BYTE PTR [esi+468], al
	mov	BYTE PTR [esi+469], al
	mov	DWORD PTR [esi], OFFSET ??_7CvAutomateInfo@@6B@

; 957  : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAutomateInfo@@QAE@XZ ENDP				; CvAutomateInfo::CvAutomateInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvAutomateInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvAutomateInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvAutomateInfo::CacheResults, COMDAT
; _this$ = ecx

; 991  : 	if(!CvHotKeyInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvHotKeyInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@34
	pop	edi
	pop	esi

; 1004 : }

	ret	8
$LN1@CacheResul@34:
	push	ebx

; 992  : 		return false;
; 993  : 
; 994  : 	const char* szCommand = kResults.GetText("Command");

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG219391
	mov	ecx, edi
	call	ebx

; 995  : 	setCommand(GC.getInfoTypeForString(szCommand, true));

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 996  : 
; 997  : 	const char* szAutomate = kResults.GetText("Automate");

	push	OFFSET $SG219393
	mov	ecx, edi
	mov	DWORD PTR [esi+460], eax
	call	ebx

; 998  : 	setAutomate(GC.getInfoTypeForString(szAutomate, true));

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 999  : 
; 1000 : 	m_bConfirmCommand = kResults.GetBool("ConfirmCommand");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG219394
	mov	ecx, edi
	mov	DWORD PTR [esi+464], eax
	call	ebx

; 1001 : 	m_bVisible = kResults.GetBool("Visible");

	push	OFFSET $SG219395
	mov	ecx, edi
	mov	BYTE PTR [esi+468], al
	call	ebx
	pop	ebx
	mov	BYTE PTR [esi+469], al
	pop	edi

; 1002 : 
; 1003 : 	return true;

	mov	al, 1
	pop	esi

; 1004 : }

	ret	8
?CacheResults@CvAutomateInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvAutomateInfo::CacheResults
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvSpecialUnitInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvSpecialUnitInfo@@UAEPAXI@Z PROC			; CvSpecialUnitInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvSpecialUnitInfo@@6B@
	mov	eax, DWORD PTR [esi+264]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+264], 0
	mov	ecx, DWORD PTR [esi+268]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 8
	mov	ecx, esi
	mov	DWORD PTR [esi+268], 0
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN11@scalar@7
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@scalar@7:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvSpecialUnitInfo@@UAEPAXI@Z ENDP			; CvSpecialUnitInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvBuildingClassInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvBuildingClassInfo@@UAEPAXI@Z PROC			; CvBuildingClassInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvBuildingClassInfo@@6B@
	mov	eax, DWORD PTR [esi+284]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, esi
	mov	DWORD PTR [esi+284], 0
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN9@scalar@8
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@scalar@8:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvBuildingClassInfo@@UAEPAXI@Z ENDP			; CvBuildingClassInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvCivilizationBaseInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvCivilizationBaseInfo@@UAEPAXI@Z PROC		; CvCivilizationBaseInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvCivilizationBaseInfo@@UAE@XZ	; CvCivilizationBaseInfo::~CvCivilizationBaseInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@9
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@9:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvCivilizationBaseInfo@@UAEPAXI@Z ENDP		; CvCivilizationBaseInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?InitBuildingDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z ; CvCivilizationInfo::InitBuildingDefaults
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
xdata$x	SEGMENT
__unwindtable$?InitBuildingDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitBuildingDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z$0
__ehfuncinfo$?InitBuildingDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?InitBuildingDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?InitBuildingDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_strKey$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_piDefaults$ = 8					; size = 4
_kUtility$ = 12						; size = 4
?InitBuildingDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z PROC ; CvCivilizationInfo::InitBuildingDefaults, COMDAT
; _this$ = ecx

; 2018 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?InitBuildingDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebp
	push	esi
	push	edi

; 2019 : 	kUtility.InitializeArray(piDefaults, "BuildingClasses", -1);

	mov	edi, DWORD PTR _kUtility$[esp+48]
	push	OFFSET $SG219951
	mov	ecx, edi
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN21@InitBuildi
	mov	esi, 1
$LN21@InitBuildi:
	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ebp, DWORD PTR _piDefaults$[esp+52]
	mov	DWORD PTR [ebp], eax
	add	esp, 4
	xor	eax, eax
	test	esi, esi
	jbe	SHORT $LN10@InitBuildi
	npad	2
$LL12@InitBuildi:
	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [ecx+eax*4], -1
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL12@InitBuildi
$LN10@InitBuildi:

; 2020 : 
; 2021 : 	std::string strKey("InitBuildingDefaults");

	push	OFFSET $SG219953
	lea	ecx, DWORD PTR _strKey$[esp+56]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2022 : 	Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$[esp+52]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+64], 0
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	esi, eax

; 2023 : 	if(pResults == NULL)

	test	esi, esi
	jne	SHORT $LN18@InitBuildi

; 2024 : 	{
; 2025 : 		pResults = kUtility.PrepareResults(strKey, "select BuildingClasses.ID, Buildings.ID as BuildingID from BuildingClasses inner join Buildings on Buildings.Type = DefaultBuilding");

	push	OFFSET $SG219956
	lea	eax, DWORD PTR _strKey$[esp+56]
	push	eax
	mov	ecx, edi
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	esi, eax
$LN18@InitBuildi:

; 2026 : 	}
; 2027 : 
; 2028 : 	while(pResults->Step())

	mov	ecx, esi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN1@InitBuildi
	push	ebx
	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	npad	2
$LL2@InitBuildi:

; 2029 : 	{
; 2030 : 		const int idx = pResults->GetInt(0);

	push	0
	mov	ecx, esi
	call	ebx

; 2031 : 		const int buildingID = pResults->GetInt(1);

	push	1
	mov	ecx, esi
	mov	edi, eax
	call	ebx

; 2032 : 
; 2033 : 		piDefaults[idx] = buildingID;

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [ecx+edi*4], eax
	mov	ecx, esi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL2@InitBuildi
	pop	ebx
$LN1@InitBuildi:

; 2034 : 	}
; 2035 : }

	lea	ecx, DWORD PTR _strKey$[esp+52]
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InitBuildingDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _strKey$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?InitBuildingDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?InitBuildingDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?InitBuildingDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z ENDP ; CvCivilizationInfo::InitBuildingDefaults
PUBLIC	?InitUnitDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z ; CvCivilizationInfo::InitUnitDefaults
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
xdata$x	SEGMENT
__unwindtable$?InitUnitDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitUnitDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z$0
__ehfuncinfo$?InitUnitDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?InitUnitDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?InitUnitDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_strKey$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_piDefaults$ = 8					; size = 4
_kUtility$ = 12						; size = 4
?InitUnitDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z PROC ; CvCivilizationInfo::InitUnitDefaults, COMDAT
; _this$ = ecx

; 2045 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?InitUnitDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebp
	push	esi
	push	edi

; 2046 : 	kUtility.InitializeArray(piDefaults, "UnitClasses", -1);

	mov	edi, DWORD PTR _kUtility$[esp+48]
	push	OFFSET $SG219967
	mov	ecx, edi
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN21@InitUnitDe
	mov	esi, 1
$LN21@InitUnitDe:
	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ebp, DWORD PTR _piDefaults$[esp+52]
	mov	DWORD PTR [ebp], eax
	add	esp, 4
	xor	eax, eax
	test	esi, esi
	jbe	SHORT $LN10@InitUnitDe
	npad	2
$LL12@InitUnitDe:
	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [ecx+eax*4], -1
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL12@InitUnitDe
$LN10@InitUnitDe:

; 2047 : 
; 2048 : 	std::string strKey("InitUnitDefaults");

	push	OFFSET $SG219969
	lea	ecx, DWORD PTR _strKey$[esp+56]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2049 : 	Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$[esp+52]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+64], 0
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	esi, eax

; 2050 : 	if(pResults == NULL)

	test	esi, esi
	jne	SHORT $LN18@InitUnitDe

; 2051 : 	{
; 2052 : 		pResults = kUtility.PrepareResults(strKey, "select UnitClasses.ID, Units.ID as UnitID from UnitClasses inner join Units on Units.Type = DefaultUnit");

	push	OFFSET $SG219972
	lea	eax, DWORD PTR _strKey$[esp+56]
	push	eax
	mov	ecx, edi
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	esi, eax
$LN18@InitUnitDe:

; 2053 : 	}
; 2054 : 
; 2055 : 	while(pResults->Step())

	mov	ecx, esi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN1@InitUnitDe
	push	ebx
	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	npad	2
$LL2@InitUnitDe:

; 2056 : 	{
; 2057 : 		const int idx		= pResults->GetInt(0);

	push	0
	mov	ecx, esi
	call	ebx

; 2058 : 		const int unitID	= pResults->GetInt(1);

	push	1
	mov	ecx, esi
	mov	edi, eax
	call	ebx

; 2059 : 
; 2060 : 		piDefaults[idx] = unitID;

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [ecx+edi*4], eax
	mov	ecx, esi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL2@InitUnitDe
	pop	ebx
$LN1@InitUnitDe:

; 2061 : 	}
; 2062 : }

	lea	ecx, DWORD PTR _strKey$[esp+52]
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InitUnitDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _strKey$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?InitUnitDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?InitUnitDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?InitUnitDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z ENDP ; CvCivilizationInfo::InitUnitDefaults
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvVictoryInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvVictoryInfo@@UAEPAXI@Z PROC			; CvVictoryInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvVictoryInfo@@UAE@XZ		; CvVictoryInfo::~CvVictoryInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@10
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@10:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvVictoryInfo@@UAEPAXI@Z ENDP			; CvVictoryInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvSmallAwardInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvSmallAwardInfo@@UAEPAXI@Z PROC			; CvSmallAwardInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvSmallAwardInfo@@UAE@XZ		; CvSmallAwardInfo::~CvSmallAwardInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@11
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@11:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvSmallAwardInfo@@UAEPAXI@Z ENDP			; CvSmallAwardInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvHandicapInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvHandicapInfo@@UAEPAXI@Z PROC			; CvHandicapInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvHandicapInfo@@UAE@XZ		; CvHandicapInfo::~CvHandicapInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@12
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@12:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvHandicapInfo@@UAEPAXI@Z ENDP			; CvHandicapInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvGameSpeedInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvGameSpeedInfo@@UAEPAXI@Z PROC			; CvGameSpeedInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvGameSpeedInfo@@UAE@XZ		; CvGameSpeedInfo::~CvGameSpeedInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@13
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@13:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvGameSpeedInfo@@UAEPAXI@Z ENDP			; CvGameSpeedInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CvBuildInfo@@QAE@XZ				; CvBuildInfo::CvBuildInfo
; Function compile flags: /Ogtpy
;	COMDAT ??0CvBuildInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvBuildInfo@@QAE@XZ PROC				; CvBuildInfo::CvBuildInfo, COMDAT
; _this$ = ecx

; 3685 : {

	push	esi
	mov	esi, ecx
	call	??0CvHotKeyInfo@@QAE@XZ			; CvHotKeyInfo::CvHotKeyInfo
	xor	eax, eax
	or	ecx, -1
	mov	DWORD PTR [esi+460], eax
	mov	DWORD PTR [esi+464], eax
	mov	DWORD PTR [esi+468], eax
	mov	BYTE PTR [esi+492], al
	mov	BYTE PTR [esi+493], al
	mov	BYTE PTR [esi+494], al
	mov	BYTE PTR [esi+495], al
	mov	BYTE PTR [esi+500], al
	mov	BYTE PTR [esi+501], al
	mov	DWORD PTR [esi+504], eax
	mov	DWORD PTR [esi+508], eax
	mov	DWORD PTR [esi+512], eax
	mov	DWORD PTR [esi+516], eax
	mov	DWORD PTR [esi+520], eax
	mov	DWORD PTR [esi+524], eax
	mov	DWORD PTR [esi+528], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvBuildInfo@@6B@
	mov	DWORD PTR [esi+472], ecx
	mov	DWORD PTR [esi+476], ecx
	mov	DWORD PTR [esi+480], ecx
	mov	DWORD PTR [esi+484], ecx
	mov	DWORD PTR [esi+488], ecx
	mov	DWORD PTR [esi+496], ecx

; 3686 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvBuildInfo@@QAE@XZ ENDP				; CvBuildInfo::CvBuildInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvBuildInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvBuildInfo@@UAEPAXI@Z PROC				; CvBuildInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvBuildInfo@@UAE@XZ			; CvBuildInfo::~CvBuildInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@14
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@14:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvBuildInfo@@UAEPAXI@Z ENDP				; CvBuildInfo::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp__sprintf_s:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvBuildInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
__ehfuncinfo$?CacheResults@CvBuildInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CacheResults@CvBuildInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvBuildInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kArrayResults$221025 = -588				; size = 64
_szQuery$221022 = -524					; size = 512
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvBuildInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvBuildInfo::CacheResults, COMDAT
; _this$ = ecx

; 3837 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvBuildInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax

; 3838 : 	if(!CvHotKeyInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 576				; 00000240H
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+592]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvHotKeyInfo::CacheResults
	test	al, al
	je	$LN5@CacheResul@35
$LN4@CacheResul@35:
	push	ebx
	push	ebp

; 3839 : 		return false;
; 3840 : 
; 3841 : 	m_iTime = kResults.GetInt("Time");

	mov	ebp, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG220990
	mov	ecx, edi
	call	ebp

; 3842 : 	m_iCost = kResults.GetInt("Cost");

	push	OFFSET $SG220991
	mov	ecx, edi
	mov	DWORD PTR [esi+460], eax
	call	ebp

; 3843 : 	m_iCostIncreasePerImprovement = kResults.GetInt("CostIncreasePerImprovement");

	push	OFFSET $SG220992
	mov	ecx, edi
	mov	DWORD PTR [esi+464], eax
	call	ebp

; 3844 : 	m_bKill = kResults.GetBool("Kill");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG220993
	mov	ecx, edi
	mov	DWORD PTR [esi+468], eax
	call	ebx

; 3845 : 	m_bRepair = kResults.GetBool("Repair");

	push	OFFSET $SG220994
	mov	ecx, edi
	mov	BYTE PTR [esi+492], al
	call	ebx

; 3846 : 	m_bRemoveRoute = kResults.GetBool("RemoveRoute");

	push	OFFSET $SG220995
	mov	ecx, edi
	mov	BYTE PTR [esi+493], al
	call	ebx

; 3847 : 	m_bWater = kResults.GetBool("Water");

	push	OFFSET $SG220996
	mov	ecx, edi
	mov	BYTE PTR [esi+494], al
	call	ebx

; 3848 : 	m_bCanBeEmbarked = kResults.GetBool("CanBeEmbarked");

	push	OFFSET $SG220997
	mov	ecx, edi
	mov	BYTE PTR [esi+500], al
	call	ebx

; 3849 : 	//EAP: Adding Civ req to builds as well
; 3850 : 	m_bSpecificCivRequired = kResults.GetBool("SpecificCivRequired");

	push	OFFSET $SG220998
	mov	ecx, edi
	mov	BYTE PTR [esi+501], al
	call	ebx

; 3851 : 
; 3852 : 	const char* szCivilizationType = kResults.GetText("CivilizationType");

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG221000
	mov	ecx, edi
	mov	BYTE PTR [esi+495], al
	call	ebx

; 3853 : 	m_eRequiredCivilization = (CivilizationTypes)GC.getInfoTypeForString(szCivilizationType, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 3854 : 
; 3855 : 
; 3856 : 	///
; 3857 : 
; 3858 : 
; 3859 : 	const char* szPrereqTech = kResults.GetText("PrereqTech");

	push	OFFSET $SG221003
	mov	ecx, edi
	mov	DWORD PTR [esi+496], eax
	call	ebx

; 3860 : 	m_iTechPrereq = GC.getInfoTypeForString(szPrereqTech, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 3861 : 
; 3862 : 	const char* szImprovementType = kResults.GetText("ImprovementType");

	push	OFFSET $SG221005
	mov	ecx, edi
	mov	DWORD PTR [esi+472], eax
	call	ebx

; 3863 : 	m_iImprovement = GC.getInfoTypeForString(szImprovementType, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 3864 : 
; 3865 : 	const char* szRouteType = kResults.GetText("RouteType");

	push	OFFSET $SG221007
	mov	ecx, edi
	mov	DWORD PTR [esi+476], eax
	call	ebx

; 3866 : 	m_iRoute = GC.getInfoTypeForString(szRouteType, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 3867 : 
; 3868 : 	const char* szEntityEvent = kResults.GetText("EntityEvent");

	push	OFFSET $SG221009
	mov	ecx, edi
	mov	DWORD PTR [esi+480], eax
	call	ebx

; 3869 : 	m_iEntityEvent = GC.getInfoTypeForString(szEntityEvent, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+484], eax

; 3870 : 
; 3871 : 	//NOTE: Why isn't this really a struct? o_O
; 3872 : 	//HACK: Temporary until the stored proc system is finished
; 3873 : 	//FeatureStructs
; 3874 : 	{
; 3875 : 		kUtility.InitializeArray(m_paiFeatureTech, "Features");

	mov	ecx, DWORD PTR _kUtility$[esp+600]
	push	OFFSET $SG221011
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LN8@CacheResul@35
	mov	edi, 1
$LN8@CacheResul@35:
	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+504], eax
	call	_memset

; 3876 : 		kUtility.InitializeArray(m_paiFeatureTime, "Features");

	mov	ecx, DWORD PTR _kUtility$[esp+616]
	add	esp, 16					; 00000010H
	push	OFFSET $SG221012
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LN18@CacheResul@35
	mov	edi, 1
$LN18@CacheResul@35:
	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+508], eax
	call	_memset

; 3877 : 		kUtility.InitializeArray(m_paiFeatureProduction, "Features");

	mov	ecx, DWORD PTR _kUtility$[esp+616]
	add	esp, 16					; 00000010H
	push	OFFSET $SG221013
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LN28@CacheResul@35
	mov	edi, 1
$LN28@CacheResul@35:
	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+512], eax
	call	_memset

; 3878 : #ifdef NQ_FOOD_FROM_CHOPS
; 3879 : 		kUtility.InitializeArray(m_paiFeatureFood, "Features");

	mov	ecx, DWORD PTR _kUtility$[esp+616]
	add	esp, 16					; 00000010H
	push	OFFSET $SG221014
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LN38@CacheResul@35
	mov	edi, 1
$LN38@CacheResul@35:
	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+516], eax
	call	_memset

; 3880 : #endif
; 3881 : 		kUtility.InitializeArray(m_paiFeatureCost, "Features");

	mov	ecx, DWORD PTR _kUtility$[esp+616]
	add	esp, 16					; 00000010H
	push	OFFSET $SG221015
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LN48@CacheResul@35
	mov	edi, 1
$LN48@CacheResul@35:
	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+520], eax
	call	_memset

; 3882 : 		kUtility.InitializeArray(m_pabFeatureRemove, "Features");

	mov	edi, DWORD PTR _kUtility$[esp+616]
	add	esp, 16					; 00000010H
	push	OFFSET $SG221021
	mov	ecx, edi
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	test	eax, eax
	jne	SHORT $LN69@CacheResul@35
	mov	eax, 1
$LN69@CacheResul@35:
	push	0
	lea	ecx, DWORD PTR [esi+528]
	push	eax
	push	ecx
	mov	ecx, edi
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z ; CvDatabaseUtility::InitializeArray

; 3883 : 
; 3884 : 		char szQuery[512];
; 3885 : 		const char* szFeatureQuery = "select * from BuildFeatures where BuildType = '%s'";
; 3886 : 		sprintf_s(szQuery, 512, szFeatureQuery, GetType());

	lea	ecx, DWORD PTR [esi+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG221024
	lea	edx, DWORD PTR _szQuery$221022[esp+612]
	push	512					; 00000200H
	push	edx
	call	DWORD PTR __imp__sprintf_s
	add	esp, 16					; 00000010H

; 3887 : 
; 3888 : 		Database::Results kArrayResults;

	push	0
	lea	ecx, DWORD PTR _kArrayResults$221025[esp+608]
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z

; 3889 : 		if(DB.Execute(kArrayResults, szQuery))

	push	-1
	lea	eax, DWORD PTR _szQuery$221022[esp+608]
	push	eax
	lea	ecx, DWORD PTR _kArrayResults$221025[esp+612]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	mov	DWORD PTR __$EHRec$[esp+624], 0
	call	DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z
	test	al, al
	je	$LN1@CacheResul@35

; 3890 : 		{
; 3891 : 			while(kArrayResults.Step())

	lea	ecx, DWORD PTR _kArrayResults$221025[esp+604]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	$LN1@CacheResul@35
	npad	4
$LL2@CacheResul@35:

; 3892 : 			{
; 3893 : 				const char* szFeatureType			= kArrayResults.GetText("FeatureType");

	push	OFFSET $SG221031
	lea	ecx, DWORD PTR _kArrayResults$221025[esp+608]
	call	ebx

; 3894 : 				const int iFeatureIdx				= GC.getInfoTypeForString(szFeatureType, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 3895 : 
; 3896 : 				const char* szFeatureTech			= kArrayResults.GetText("PrereqTech");

	push	OFFSET $SG221034
	lea	ecx, DWORD PTR _kArrayResults$221025[esp+608]
	mov	edi, eax
	call	ebx

; 3897 : 
; 3898 : 				CvAssert(iFeatureIdx > -1);
; 3899 : 				m_paiFeatureTech[iFeatureIdx]		= GC.getInfoTypeForString(szFeatureTech, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edx, DWORD PTR [esi+504]

; 3900 : 				m_paiFeatureTime[iFeatureIdx]		= kArrayResults.GetInt("Time");

	push	OFFSET $SG221035
	lea	ecx, DWORD PTR _kArrayResults$221025[esp+608]
	mov	DWORD PTR [edx+edi*4], eax
	call	ebp
	mov	ecx, DWORD PTR [esi+508]
	mov	DWORD PTR [ecx+edi*4], eax

; 3901 : 				m_paiFeatureProduction[iFeatureIdx] = kArrayResults.GetInt("Production");

	push	OFFSET $SG221036
	lea	ecx, DWORD PTR _kArrayResults$221025[esp+608]
	call	ebp
	mov	edx, DWORD PTR [esi+512]

; 3902 : #ifdef NQ_FOOD_FROM_CHOPS
; 3903 : 				m_paiFeatureFood[iFeatureIdx]		= kArrayResults.GetInt("Food");

	push	OFFSET $SG221037
	lea	ecx, DWORD PTR _kArrayResults$221025[esp+608]
	mov	DWORD PTR [edx+edi*4], eax
	call	ebp
	mov	ecx, DWORD PTR [esi+516]
	mov	DWORD PTR [ecx+edi*4], eax

; 3904 : #endif
; 3905 : 				m_paiFeatureCost[iFeatureIdx]		= kArrayResults.GetInt("Cost");

	push	OFFSET $SG221038
	lea	ecx, DWORD PTR _kArrayResults$221025[esp+608]
	call	ebp
	mov	edx, DWORD PTR [esi+520]

; 3906 : 				m_pabFeatureRemove[iFeatureIdx]		= kArrayResults.GetBool("Remove");

	push	OFFSET $SG221039
	lea	ecx, DWORD PTR _kArrayResults$221025[esp+608]
	mov	DWORD PTR [edx+edi*4], eax
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR [esi+528]
	mov	BYTE PTR [edi+ecx], al
	lea	ecx, DWORD PTR _kArrayResults$221025[esp+604]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	$LL2@CacheResul@35

; 3890 : 		{
; 3891 : 			while(kArrayResults.Step())

	mov	edi, DWORD PTR _kUtility$[esp+600]
$LN1@CacheResul@35:

; 3907 : 			}
; 3908 : 		}
; 3909 : 	}

	lea	ecx, DWORD PTR _kArrayResults$221025[esp+604]
	mov	DWORD PTR __$EHRec$[esp+612], -1
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ

; 3910 : 	
; 3911 : 	const char* szBuildType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 3912 : 	kUtility.PopulateArrayByValue(m_paiTechTimeChange, "Technologies", "Build_TechTimeChanges", "TechType", "BuildType", szBuildType, "TimeChange");

	push	0
	push	0
	push	OFFSET $SG221041
	push	eax
	push	OFFSET $SG221042
	push	OFFSET $SG221043
	push	OFFSET $SG221044
	push	OFFSET $SG221045
	add	esi, 524				; 0000020cH
	push	esi
	mov	ecx, edi
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue
	pop	ebp

; 3913 : 
; 3914 : 	return true;

	mov	al, 1
	pop	ebx
$LN5@CacheResul@35:

; 3915 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+596]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 588				; 0000024cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvBuildInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _kArrayResults$221025[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__ehhandler$?CacheResults@CvBuildInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvBuildInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvBuildInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvBuildInfo::CacheResults
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvRouteInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvRouteInfo@@UAEPAXI@Z PROC				; CvRouteInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvRouteInfo@@UAE@XZ			; CvRouteInfo::~CvRouteInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@15
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@15:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvRouteInfo@@UAEPAXI@Z ENDP				; CvRouteInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?getBuildingProductionCostModifiersLocal@CvResourceInfo@@QBEHW4EraTypes@@@Z ; CvResourceInfo::getBuildingProductionCostModifiersLocal
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildingProductionCostModifiersLocal@CvResourceInfo@@QBEHW4EraTypes@@@Z
_TEXT	SEGMENT
_eBuildingEra$ = 8					; size = 4
?getBuildingProductionCostModifiersLocal@CvResourceInfo@@QBEHW4EraTypes@@@Z PROC ; CvResourceInfo::getBuildingProductionCostModifiersLocal, COMDAT
; _this$ = ecx

; 4710 : 	CvAssertMsg(eBuildingEra < GC.getNumEraInfos(), "Index out of bounds");
; 4711 : 	CvAssertMsg(eBuildingEra > -1, "Index out of bounds");
; 4712 : 
; 4713 : 	int iBuildingEra = (int)eBuildingEra;
; 4714 : 	int iMod = 0;
; 4715 : 
; 4716 : 	for (std::vector<ProductionCostModifiers>::const_iterator it = m_aiiiBuildingProductionCostModifiersLocal.begin(); it != m_aiiiBuildingProductionCostModifiersLocal.end(); ++it)

	mov	edx, DWORD PTR [ecx+548]
	push	ebx
	mov	ebx, DWORD PTR [ecx+552]
	xor	eax, eax
	cmp	edx, ebx
	je	SHORT $LN4@getBuildin
	push	esi
	push	edi
	mov	edi, DWORD PTR _eBuildingEra$[esp+8]
	npad	7
$LL13@getBuildin:

; 4717 : 	{
; 4718 : 		EraTypes eRequiredEra = (EraTypes)it->m_iRequiredEra;
; 4719 : 		EraTypes eObsoleteEra = (EraTypes)it->m_iObsoleteEra;

	mov	esi, DWORD PTR [edx+4]

; 4720 : 
; 4721 : 		if (eBuildingEra != NO_ERA)

	cmp	edi, -1
	je	SHORT $LN1@getBuildin
	mov	ecx, DWORD PTR [edx]

; 4722 : 		{
; 4723 : 			// Our building's era needs to be greater than or equal to the required era
; 4724 : 			if (eRequiredEra != NO_ERA && iBuildingEra < it->m_iRequiredEra)

	cmp	ecx, -1
	je	SHORT $LN2@getBuildin
	cmp	edi, ecx
	jl	SHORT $LN5@getBuildin
$LN2@getBuildin:

; 4725 : 			{
; 4726 : 				continue;
; 4727 : 			}
; 4728 : 
; 4729 : 			// Our building's era needs to be less than the obsolete era
; 4730 : 			if (eObsoleteEra != NO_ERA && iBuildingEra >= it->m_iObsoleteEra)

	cmp	esi, -1
	je	SHORT $LN1@getBuildin
	cmp	edi, esi
	jge	SHORT $LN5@getBuildin
$LN1@getBuildin:

; 4731 : 			{
; 4732 : 				continue;
; 4733 : 			}
; 4734 : 		}
; 4735 : 
; 4736 : 		iMod += it->m_iCostModifier;

	add	eax, DWORD PTR [edx+8]
$LN5@getBuildin:

; 4710 : 	CvAssertMsg(eBuildingEra < GC.getNumEraInfos(), "Index out of bounds");
; 4711 : 	CvAssertMsg(eBuildingEra > -1, "Index out of bounds");
; 4712 : 
; 4713 : 	int iBuildingEra = (int)eBuildingEra;
; 4714 : 	int iMod = 0;
; 4715 : 
; 4716 : 	for (std::vector<ProductionCostModifiers>::const_iterator it = m_aiiiBuildingProductionCostModifiersLocal.begin(); it != m_aiiiBuildingProductionCostModifiersLocal.end(); ++it)

	add	edx, 12					; 0000000cH
	cmp	edx, ebx
	jne	SHORT $LL13@getBuildin
	pop	edi
	pop	esi
$LN4@getBuildin:
	pop	ebx

; 4737 : 	}
; 4738 : 
; 4739 : 	return iMod;
; 4740 : }

	ret	4
?getBuildingProductionCostModifiersLocal@CvResourceInfo@@QBEHW4EraTypes@@@Z ENDP ; CvResourceInfo::getBuildingProductionCostModifiersLocal
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvFeatureInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvFeatureInfo@@UAEPAXI@Z PROC			; CvFeatureInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvFeatureInfo@@UAE@XZ		; CvFeatureInfo::~CvFeatureInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@16
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@16:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvFeatureInfo@@UAEPAXI@Z ENDP			; CvFeatureInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvTerrainInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvTerrainInfo@@UAEPAXI@Z PROC			; CvTerrainInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvTerrainInfo@@UAE@XZ		; CvTerrainInfo::~CvTerrainInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@17
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@17:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvTerrainInfo@@UAEPAXI@Z ENDP			; CvTerrainInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7CvInterfaceModeInfo@@6B@			; CvInterfaceModeInfo::`vftable'
PUBLIC	??0CvInterfaceModeInfo@@QAE@XZ			; CvInterfaceModeInfo::CvInterfaceModeInfo
PUBLIC	??_R4CvInterfaceModeInfo@@6B@			; CvInterfaceModeInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvInterfaceModeInfo@@@8			; CvInterfaceModeInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvInterfaceModeInfo@@8			; CvInterfaceModeInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvInterfaceModeInfo@@8			; CvInterfaceModeInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvInterfaceModeInfo@@8		; CvInterfaceModeInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvInterfaceModeInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvInterfaceModeInfo::CacheResults
;	COMDAT ??_R1A@?0A@EA@CvInterfaceModeInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvInterfaceModeInfo@@8 DD FLAT:??_R0?AVCvInterfaceModeInfo@@@8 ; CvInterfaceModeInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvInterfaceModeInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvInterfaceModeInfo@@8
rdata$r	SEGMENT
??_R2CvInterfaceModeInfo@@8 DD FLAT:??_R1A@?0A@EA@CvInterfaceModeInfo@@8 ; CvInterfaceModeInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvHotKeyInfo@@8
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvInterfaceModeInfo@@8
rdata$r	SEGMENT
??_R3CvInterfaceModeInfo@@8 DD 00H			; CvInterfaceModeInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvInterfaceModeInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvInterfaceModeInfo@@@8
_DATA	SEGMENT
??_R0?AVCvInterfaceModeInfo@@@8 DD FLAT:??_7type_info@@6B@ ; CvInterfaceModeInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvInterfaceModeInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvInterfaceModeInfo@@6B@
rdata$r	SEGMENT
??_R4CvInterfaceModeInfo@@6B@ DD 00H			; CvInterfaceModeInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvInterfaceModeInfo@@@8
	DD	FLAT:??_R3CvInterfaceModeInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvInterfaceModeInfo@@6B@
CONST	SEGMENT
??_7CvInterfaceModeInfo@@6B@ DD FLAT:??_R4CvInterfaceModeInfo@@6B@ ; CvInterfaceModeInfo::`vftable'
	DD	FLAT:?CacheResults@CvInterfaceModeInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvInterfaceModeInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvInterfaceModeInfo@@QAE@XZ PROC			; CvInterfaceModeInfo::CvInterfaceModeInfo, COMDAT
; _this$ = ecx

; 5618 : {

	push	esi
	mov	esi, ecx
	call	??0CvHotKeyInfo@@QAE@XZ			; CvHotKeyInfo::CvHotKeyInfo
	or	eax, -1
	mov	DWORD PTR [esi+460], eax
	mov	DWORD PTR [esi+464], eax
	xor	al, al
	mov	BYTE PTR [esi+468], al
	mov	BYTE PTR [esi+469], al
	mov	BYTE PTR [esi+470], al
	mov	BYTE PTR [esi+471], al
	mov	DWORD PTR [esi], OFFSET ??_7CvInterfaceModeInfo@@6B@

; 5619 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvInterfaceModeInfo@@QAE@XZ ENDP			; CvInterfaceModeInfo::CvInterfaceModeInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CacheResults@CvInterfaceModeInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvInterfaceModeInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvInterfaceModeInfo::CacheResults, COMDAT
; _this$ = ecx

; 5653 : 	if(!CvHotKeyInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvHotKeyInfo::CacheResults
	test	al, al
	jne	SHORT $LN1@CacheResul@36
	pop	edi
	pop	esi

; 5668 : }

	ret	8
$LN1@CacheResul@36:
	push	ebx

; 5654 : 		return false;
; 5655 : 
; 5656 : 	const char* szCursorType = kResults.GetText("CursorType");

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG222340
	mov	ecx, edi
	call	ebx

; 5657 : 	m_iCursorIndex = GC.getInfoTypeForString(szCursorType, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 5658 : 
; 5659 : 	const char* szMission = kResults.GetText("Mission");

	push	OFFSET $SG222342
	mov	ecx, edi
	mov	DWORD PTR [esi+460], eax
	call	ebx

; 5660 : 	m_iMissionType = GC.getInfoTypeForString(szMission, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 5661 : 
; 5662 : 	m_bVisible			= kResults.GetBool("Visible");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG222343
	mov	ecx, edi
	mov	DWORD PTR [esi+464], eax
	call	ebx

; 5663 : 	m_bHighlightPlot	= kResults.GetBool("HighlightPlot");

	push	OFFSET $SG222344
	mov	ecx, edi
	mov	BYTE PTR [esi+468], al
	call	ebx

; 5664 : 	m_bSelectType		= kResults.GetBool("SelectType");

	push	OFFSET $SG222345
	mov	ecx, edi
	mov	BYTE PTR [esi+469], al
	call	ebx

; 5665 : 	m_bSelectAll		= kResults.GetBool("SelectAll");

	push	OFFSET $SG222346
	mov	ecx, edi
	mov	BYTE PTR [esi+470], al
	call	ebx
	pop	ebx
	mov	BYTE PTR [esi+471], al
	pop	edi

; 5666 : 
; 5667 : 	return true;

	mov	al, 1
	pop	esi

; 5668 : }

	ret	8
?CacheResults@CvInterfaceModeInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvInterfaceModeInfo::CacheResults
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvLeaderHeadInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvLeaderHeadInfo@@UAEPAXI@Z PROC			; CvLeaderHeadInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvLeaderHeadInfo@@UAE@XZ		; CvLeaderHeadInfo::~CvLeaderHeadInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@18
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@18:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvLeaderHeadInfo@@UAEPAXI@Z ENDP			; CvLeaderHeadInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CvWorldInfo@@QAE@ABV0@@Z			; CvWorldInfo::CvWorldInfo
; Function compile flags: /Ogtpy
;	COMDAT ??0CvWorldInfo@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvWorldInfo@@QAE@ABV0@@Z PROC			; CvWorldInfo::CvWorldInfo, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+4]
	push	edi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@ABV0@@Z
	mov	DWORD PTR [esi], OFFSET ??_7CvWorldInfo@@6B@
	mov	eax, DWORD PTR [edi+260]
	mov	DWORD PTR [esi+260], eax
	mov	ecx, DWORD PTR [edi+264]
	mov	DWORD PTR [esi+264], ecx
	mov	edx, DWORD PTR [edi+268]
	mov	DWORD PTR [esi+268], edx
	mov	eax, DWORD PTR [edi+272]
	mov	DWORD PTR [esi+272], eax
	mov	ecx, DWORD PTR [edi+276]
	mov	DWORD PTR [esi+276], ecx
	mov	edx, DWORD PTR [edi+280]
	mov	DWORD PTR [esi+280], edx
	mov	eax, DWORD PTR [edi+284]
	mov	DWORD PTR [esi+284], eax
	mov	ecx, DWORD PTR [edi+288]
	mov	DWORD PTR [esi+288], ecx
	mov	edx, DWORD PTR [edi+292]
	mov	DWORD PTR [esi+292], edx
	mov	eax, DWORD PTR [edi+296]
	mov	DWORD PTR [esi+296], eax
	mov	ecx, DWORD PTR [edi+300]
	mov	DWORD PTR [esi+300], ecx
	mov	edx, DWORD PTR [edi+304]
	mov	DWORD PTR [esi+304], edx
	mov	eax, DWORD PTR [edi+308]
	mov	DWORD PTR [esi+308], eax
	mov	ecx, DWORD PTR [edi+312]
	mov	DWORD PTR [esi+312], ecx
	mov	edx, DWORD PTR [edi+316]
	mov	DWORD PTR [esi+316], edx
	mov	eax, DWORD PTR [edi+320]
	mov	DWORD PTR [esi+320], eax
	mov	ecx, DWORD PTR [edi+324]
	mov	DWORD PTR [esi+324], ecx
	mov	edx, DWORD PTR [edi+328]
	mov	DWORD PTR [esi+328], edx
	mov	eax, DWORD PTR [edi+332]
	mov	DWORD PTR [esi+332], eax
	mov	ecx, DWORD PTR [edi+336]
	pop	edi
	mov	DWORD PTR [esi+336], ecx
	mov	eax, esi
	pop	esi
	ret	4
??0CvWorldInfo@@QAE@ABV0@@Z ENDP			; CvWorldInfo::CvWorldInfo
_TEXT	ENDS
PUBLIC	?CreateCustomWorldSize@CvWorldInfo@@SA?AV1@ABV1@HHHH@Z ; CvWorldInfo::CreateCustomWorldSize
; Function compile flags: /Ogtpy
;	COMDAT ?CreateCustomWorldSize@CvWorldInfo@@SA?AV1@ABV1@HHHH@Z
_TEXT	SEGMENT
$T236698 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_kTemplate$ = 12					; size = 4
_iWidth$ = 16						; size = 4
_iHeight$ = 20						; size = 4
_iPlayers$ = 24						; size = 4
_iMinorCivs$ = 28					; size = 4
?CreateCustomWorldSize@CvWorldInfo@@SA?AV1@ABV1@HHHH@Z PROC ; CvWorldInfo::CreateCustomWorldSize, COMDAT

; 5993 : {

	push	ecx

; 5994 : 	CvWorldInfo kWorldInfo(kTemplate);

	mov	eax, DWORD PTR _kTemplate$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T236698[esp+12], 0
	call	??0CvWorldInfo@@QAE@ABV0@@Z

; 5995 : 	kWorldInfo.m_iGridWidth = iWidth;

	mov	ecx, DWORD PTR _iWidth$[esp+4]

; 5996 : 	kWorldInfo.m_iGridHeight = iHeight;
; 5997 : 	kWorldInfo.m_iDefaultPlayers = iPlayers;

	mov	eax, DWORD PTR _iPlayers$[esp+4]
	mov	edx, DWORD PTR _iHeight$[esp+4]
	mov	DWORD PTR [esi+296], ecx

; 5998 : 	kWorldInfo.m_iDefaultMinorCivs = iMinorCivs;

	mov	ecx, DWORD PTR _iMinorCivs$[esp+4]
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+300], edx
	mov	DWORD PTR [esi+264], ecx

; 5999 : 
; 6000 : 	return kWorldInfo;

	mov	eax, esi
	pop	esi

; 6001 : }

	pop	ecx
	ret	0
?CreateCustomWorldSize@CvWorldInfo@@SA?AV1@ABV1@HHHH@Z ENDP ; CvWorldInfo::CreateCustomWorldSize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvProcessInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvProcessInfo@@UAEPAXI@Z PROC			; CvProcessInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvProcessInfo@@6B@
	mov	eax, DWORD PTR [esi+264]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+264], 0
	mov	ecx, DWORD PTR [esi+268]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 8
	mov	ecx, esi
	mov	DWORD PTR [esi+268], 0
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN11@scalar@19
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@scalar@19:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvProcessInfo@@UAEPAXI@Z ENDP			; CvProcessInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvVoteInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvVoteInfo@@UAEPAXI@Z PROC				; CvVoteInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvVoteInfo@@6B@
	mov	eax, DWORD PTR [esi+280]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, esi
	mov	DWORD PTR [esi+280], 0
	call	??1CvBaseInfo@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN9@scalar@20
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@scalar@20:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvVoteInfo@@UAEPAXI@Z ENDP				; CvVoteInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvVoteSourceInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvVoteSourceInfo@@UAEPAXI@Z PROC			; CvVoteSourceInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvVoteSourceInfo@@UAE@XZ		; CvVoteSourceInfo::~CvVoteSourceInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@21
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@21:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvVoteSourceInfo@@UAEPAXI@Z ENDP			; CvVoteSourceInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator->
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator->, COMDAT
; _this$ = ecx

; 269  : 			return (&**this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 270  : 			}

	ret	0
??Cconst_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBEPBU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::operator->
_TEXT	ENDS
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::~_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::~_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::~_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@XZ ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::end
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?end@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@XZ PROC ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@XZ ENDP ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ; std::vector<CvString,std::allocator<CvString> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ; std::vector<CvString,std::allocator<CvString> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ; std::vector<CvString,std::allocator<CvString> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 153391689				; 09249249H
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Buy
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::lower_bound
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN32@lower_boun
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun:
	cmp	DWORD PTR [eax+12], edx
	jge	SHORT $LN4@lower_boun
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun
$LN4@lower_boun:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun:
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL6@lower_boun
$LN32@lower_boun:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1005 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1009 : 		return (_TREE_CONST_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN30@lower_boun@2
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun@2:
	cmp	DWORD PTR [eax+12], edx
	jge	SHORT $LN4@lower_boun@2
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun@2
$LN4@lower_boun@2:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun@2:
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL6@lower_boun@2
$LN30@lower_boun@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1010 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE_NI@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE_NI@Z PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@UProductionCostModifiers@@@std@@YAPAUProductionCostModifiers@@IPAU1@@Z ; std::_Allocate<ProductionCostModifiers>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Buy
_TEXT	ENDS
PUBLIC	?end@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@XZ ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@XZ PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@XZ ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@3
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Xlen
$LN16@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@W4AnimationPathTypes@@@std@@YAPAW4AnimationPathTypes@@IPAW41@@Z ; std::_Allocate<enum AnimationPathTypes>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@3:
?_Buy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Buy
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@XZ ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@XZ PROC ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@XZ ENDP ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::begin
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@@Z ; std::vector<CvString,std::allocator<CvString> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Buynode
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode
	mov	DWORD PTR [eax], 0
$LN27@Buynode:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode
	mov	DWORD PTR [ecx], 0
$LN37@Buynode:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode
	mov	DWORD PTR [ecx], 0
$LN47@Buynode:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+32], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+33], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	?begin@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@XZ ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@XZ PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@XZ ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::begin
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	edx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	shl	edx, 4
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::operator+
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	mov	eax, ecx

; 53   : 		}

	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ; stdext::unchecked_copy<CvString *,CvString *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvString *,CvString *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	esi, ebx
	je	SHORT $LN16@unchecked_@4
$LL9@unchecked_@4:
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	add	edi, 28					; 0000001cH
	cmp	esi, ebx
	jne	SHORT $LL9@unchecked_@4
$LN16@unchecked_@4:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvFormationSlotEntry@@PAV1@@stdext@@YAPAVCvFormationSlotEntry@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvFormationSlotEntry *,CvFormationSlotEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAVCvFormationSlotEntry@@PAV1@@stdext@@YAPAVCvFormationSlotEntry@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvFormationSlotEntry@@PAV1@@stdext@@YAPAVCvFormationSlotEntry@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvFormationSlotEntry *,CvFormationSlotEntry *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAVCvFormationSlotEntry@@PAV1@@stdext@@YAPAVCvFormationSlotEntry@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvFormationSlotEntry *,CvFormationSlotEntry *>
_TEXT	ENDS
PUBLIC	??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::fill<CvString *,CvString>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z PROC ; std::fill<CvString *,CvString>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN3@fill@5
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
$LL5@fill@5:
	push	ebx
	mov	ecx, esi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL5@fill@5
	pop	ebx
$LN3@fill@5:
	pop	edi
	pop	esi

; 3188 : 	}

	ret	0
??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ENDP ; std::fill<CvString *,CvString>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUProductionCostModifiers@@PAU1@@stdext@@YAPAUProductionCostModifiers@@PAU1@00@Z ; stdext::_Unchecked_move_backward<ProductionCostModifiers *,ProductionCostModifiers *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAUProductionCostModifiers@@PAU1@@stdext@@YAPAUProductionCostModifiers@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUProductionCostModifiers@@PAU1@@stdext@@YAPAUProductionCostModifiers@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<ProductionCostModifiers *,ProductionCostModifiers *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_@2
	push	esi
$LL12@Unchecked_@2:
	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_@2
	pop	esi
$LN11@Unchecked_@2:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAUProductionCostModifiers@@PAU1@@stdext@@YAPAUProductionCostModifiers@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<ProductionCostModifiers *,ProductionCostModifiers *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAW4AnimationPathTypes@@PAW41@@stdext@@YAPAW4AnimationPathTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum AnimationPathTypes *,enum AnimationPathTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAW4AnimationPathTypes@@PAW41@@stdext@@YAPAW4AnimationPathTypes@@PAW41@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAW4AnimationPathTypes@@PAW41@@stdext@@YAPAW4AnimationPathTypes@@PAW41@00@Z PROC ; stdext::_Unchecked_move_backward<enum AnimationPathTypes *,enum AnimationPathTypes *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_@3
	push	esi
$LL12@Unchecked_@3:
	mov	esi, DWORD PTR [ecx-4]
	sub	ecx, 4
	sub	eax, 4
	mov	DWORD PTR [eax], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_@3
	pop	esi
$LN11@Unchecked_@3:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAW4AnimationPathTypes@@PAW41@@stdext@@YAPAW4AnimationPathTypes@@PAW41@00@Z ENDP ; stdext::_Unchecked_move_backward<enum AnimationPathTypes *,enum AnimationPathTypes *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@PAUProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@2@@stdext@@YAPAUProductionCostModifiers@@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@0PAU1@AAV?$allocator@UProductionCostModifiers@@@3@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@PAUProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@2@@stdext@@YAPAUProductionCostModifiers@@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@0PAU1@AAV?$allocator@UProductionCostModifiers@@@3@@Z
_TEXT	SEGMENT
$T237470 = -4						; size = 1
__Cat$237474 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@PAUProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@2@@stdext@@YAPAUProductionCostModifiers@@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@0PAU1@AAV?$allocator@UProductionCostModifiers@@@3@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T237470[esp+4], 0
	mov	eax, DWORD PTR $T237470[esp+4]
	mov	ecx, DWORD PTR __Cat$237474[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@PAUProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@2@@std@@YAPAUProductionCostModifiers@@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@0@0PAU1@AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@PAUProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@2@@stdext@@YAPAUProductionCostModifiers@@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@0PAU1@AAV?$allocator@UProductionCostModifiers@@@3@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCvFormationSlotEntry@@IV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAXPAVCvFormationSlotEntry@@IABV1@AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvFormationSlotEntry *,unsigned int,CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAVCvFormationSlotEntry@@IV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAXPAVCvFormationSlotEntry@@IABV1@AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvFormationSlotEntry@@IV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAXPAVCvFormationSlotEntry@@IABV1@AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvFormationSlotEntry *,unsigned int,CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], esi
$LN5@Uninit_fil:
	dec	ecx
	add	eax, 16					; 00000010H
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAVCvFormationSlotEntry@@IV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAXPAVCvFormationSlotEntry@@IABV1@AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvFormationSlotEntry *,unsigned int,CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUProductionCostModifiers@@IU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAXPAUProductionCostModifiers@@IABU1@AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<ProductionCostModifiers *,unsigned int,ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAUProductionCostModifiers@@IU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAXPAUProductionCostModifiers@@IABU1@AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUProductionCostModifiers@@IU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAXPAUProductionCostModifiers@@IABU1@AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<ProductionCostModifiers *,unsigned int,ProductionCostModifiers,std::allocator<ProductionCostModifiers> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil@2:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@2
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], esi
$LN5@Uninit_fil@2:
	dec	ecx
	add	eax, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@2
	pop	esi
$LN4@Uninit_fil@2:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAUProductionCostModifiers@@IU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAXPAUProductionCostModifiers@@IABU1@AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<ProductionCostModifiers *,unsigned int,ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAW4AnimationPathTypes@@IW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@IABW41@AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum AnimationPathTypes *,unsigned int,enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAW4AnimationPathTypes@@IW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@IABW41@AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4AnimationPathTypes@@IW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@IABW41@AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum AnimationPathTypes *,unsigned int,enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@3
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil@3:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@3
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_fil@3:
	dec	ecx
	add	eax, 4
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@3
	pop	esi
$LN4@Uninit_fil@3:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAW4AnimationPathTypes@@IW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@IABW41@AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum AnimationPathTypes *,unsigned int,enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvString *,CvString *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvString *,CvString *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	ebx, esi
	je	SHORT $LN13@Move_backw@5
$LL6@Move_backw@5:
	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	cmp	esi, ebx
	jne	SHORT $LL6@Move_backw@5
$LN13@Move_backw@5:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvString *,CvString *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAXPAUProductionCostModifiers@@0AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAXPAUProductionCostModifiers@@0AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAXPAUProductionCostModifiers@@0AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<ProductionCostModifiers> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAXPAUProductionCostModifiers@@0AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<enum AnimationPathTypes> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAXPAVCvFormationSlotEntry@@0AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvFormationSlotEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAXPAVCvFormationSlotEntry@@0AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAXPAVCvFormationSlotEntry@@0AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvFormationSlotEntry> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAXPAVCvFormationSlotEntry@@0AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvFormationSlotEntry> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z ; std::allocator<CvString>::construct
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.h
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z$0
__ehfuncinfo$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
_TEXT	SEGMENT
$T237649 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$237657 = 8					; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z PROC ; std::allocator<CvString>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$237657[esp+12], ecx
	mov	DWORD PTR $T237649[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN5@construct@6
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN5@construct@6:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z$0:
	mov	eax, DWORD PTR __Vptr$237657[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T237649[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z:
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z ENDP ; std::allocator<CvString>::construct
PUBLIC	?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z ; std::allocator<CvString>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z PROC ; std::allocator<CvString>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 161  : 		}

	ret	4
?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z ENDP ; std::allocator<CvString>::destroy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@stdext@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@stdext@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@std@@@Z
_TEXT	SEGMENT
$T237688 = -4						; size = 1
__Cat$237693 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@stdext@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T237688[esp+4], 0
	mov	eax, DWORD PTR $T237688[esp+4]
	mov	ecx, DWORD PTR __Cat$237693[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@stdext@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@stdext@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@std@@@Z ; stdext::unchecked_uninitialized_copy<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@stdext@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@std@@@Z
_TEXT	SEGMENT
$T237697 = -4						; size = 1
__Cat$237702 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@stdext@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T237697[esp+4], 0
	mov	eax, DWORD PTR $T237697[esp+4]
	mov	ecx, DWORD PTR __Cat$237702[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@stdext@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@stdext@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@stdext@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@std@@@Z
_TEXT	SEGMENT
$T237706 = -4						; size = 1
__Cat$237711 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@stdext@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T237706[esp+4], 0
	mov	eax, DWORD PTR $T237706[esp+4]
	mov	ecx, DWORD PTR __Cat$237711[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@stdext@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@std@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@0@0PAIAAV?$allocator@I@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@std@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@0@0PAIAAV?$allocator@I@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@std@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@0@0PAIAAV?$allocator@I@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@6
	push	esi
$LL16@Uninit_cop@6:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@6
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@6:
	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[esp], ecx
	cmp	ecx, edx
	jne	SHORT $LL16@Uninit_cop@6
	pop	esi
$LN4@Uninit_cop@6:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@std@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@0@0PAIAAV?$allocator@I@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T237812 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Vptr$237818 = 8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __First$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_cop@7:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@7

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$237818[ebp], esi
	mov	DWORD PTR $T237812[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@7
	push	edi
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN18@Uninit_cop@7:
	add	esi, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 28					; 0000001cH
	jmp	SHORT $LL6@Uninit_cop@7
__catch$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@7
$LL3@Uninit_cop@7:

; 134  : 		_Al.destroy(_Next);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@7
$LN1@Uninit_cop@7:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN42@Uninit_cop@7:
$LN4@Uninit_cop@7:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@Uninit_cop@7:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$237818[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237812[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@4
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN16@Buy@4:
$LN2@Buy@4:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@4:
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
_TEXT	ENDS
PUBLIC	??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1786 : 		{	// construct with offset and pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1787 : 		}

	ret	4
??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC ; std::vector<bool,std::allocator<bool> >::max_size, COMDAT
; _this$ = ecx

; 2053 : 		const size_type _Maxsize = _Myvec.max_size();
; 2054 : 		return (_Maxsize < (size_type)(-1) / _VBITS
; 2055 : 			? _Maxsize * _VBITS : (size_type)(-1));

	or	eax, -1

; 2056 : 		}

	ret	0
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP ; std::vector<bool,std::allocator<bool> >::max_size
_TEXT	ENDS
PUBLIC	?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::end
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+
_TEXT	ENDS
PUBLIC	??D?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??D?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*, COMDAT
; _this$ = ecx

; 1572 : 		return (_Reft(*this));

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, 1
	shl	eax, cl
	and	eax, DWORD PTR [edx]
	neg	eax
	sbb	eax, eax
	neg	eax

; 1573 : 		}

	ret	0
??D?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First$[esp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Dest$[esp+8]
	npad	2

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

$LL18@Copy_opt@4:
	mov	eax, DWORD PTR __First$[esp+4]
	cmp	eax, DWORD PTR __Last$[esp+4]
	jne	SHORT $LN26@Copy_opt@4
	cmp	ecx, DWORD PTR __Last$[esp+8]
	je	SHORT $LN62@Copy_opt@4
$LN26@Copy_opt@4:

; 2472 : 		*_Dest = *_First;

	mov	ebx, 1
	shl	ebx, cl
	mov	ecx, esi
	test	ebx, DWORD PTR [eax]
	mov	eax, 1
	je	SHORT $LN49@Copy_opt@4
	shl	eax, cl
	or	DWORD PTR [edx], eax
	jmp	SHORT $LN2@Copy_opt@4
$LN49@Copy_opt@4:
	shl	eax, cl
	not	eax
	and	DWORD PTR [edx], eax
$LN2@Copy_opt@4:
	mov	esi, DWORD PTR __Dest$[esp+8]
	mov	edx, DWORD PTR __Dest$[esp+4]
	cmp	esi, 31					; 0000001fH
	jae	SHORT $LN11@Copy_opt@4

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	inc	esi
	jmp	SHORT $LN63@Copy_opt@4
$LN11@Copy_opt@4:
	xor	esi, esi
	add	edx, 4
	mov	DWORD PTR __Dest$[esp+4], edx
$LN63@Copy_opt@4:
	mov	ecx, DWORD PTR __First$[esp+8]
	mov	DWORD PTR __Dest$[esp+8], esi
	cmp	ecx, 31					; 0000001fH
	jae	SHORT $LN19@Copy_opt@4
	inc	ecx
	mov	DWORD PTR __First$[esp+8], ecx
	jmp	SHORT $LL18@Copy_opt@4
$LN19@Copy_opt@4:
	xor	ecx, ecx
	add	DWORD PTR __First$[esp+4], 4
	mov	DWORD PTR __First$[esp+8], ecx
	jmp	SHORT $LL18@Copy_opt@4
$LN62@Copy_opt@4:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax+4], esi
	pop	esi
	mov	DWORD PTR [eax], edx
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z PROC ; std::fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __Last$[esp-4]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+4]
	push	edx
	push	eax
	push	ecx
	call	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
	add	esp, 20					; 00000014H

; 3188 : 	}

	ret	0
??$fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ENDP ; std::fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z PROC ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@4
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@4:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ENDP ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--, COMDAT
; _this$ = ecx

; 1808 : 		{	// predecrement

	mov	eax, ecx

; 1809 : 		--*(_Mybase *)this;

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN6@operator@13
	dec	ecx
	mov	DWORD PTR [eax+4], ecx

; 1810 : 		return (*this);
; 1811 : 		}

	ret	0

; 1809 : 		--*(_Mybase *)this;

$LN6@operator@13:
	add	DWORD PTR [eax], -4			; fffffffcH
	mov	DWORD PTR [eax+4], 31			; 0000001fH

; 1810 : 		return (*this);
; 1811 : 		}

	ret	0
??F?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator--
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z PROC	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@5
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@5:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@5
	pop	esi
$LN7@unchecked_@5:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ENDP	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
_TEXT	ENDS
PUBLIC	?CreateCustomWorldSize@CvWorldInfo@@SA?AV1@ABV1@HH@Z ; CvWorldInfo::CreateCustomWorldSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
;	COMDAT ?CreateCustomWorldSize@CvWorldInfo@@SA?AV1@ABV1@HH@Z
_TEXT	SEGMENT
$T238278 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_kTemplate$ = 12					; size = 4
_iWidth$ = 16						; size = 4
_iHeight$ = 20						; size = 4
?CreateCustomWorldSize@CvWorldInfo@@SA?AV1@ABV1@HH@Z PROC ; CvWorldInfo::CreateCustomWorldSize, COMDAT

; 5984 : {

	push	ecx

; 5985 : 	CvWorldInfo kWorldInfo(kTemplate);

	mov	eax, DWORD PTR _kTemplate$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T238278[esp+12], 0
	call	??0CvWorldInfo@@QAE@ABV0@@Z

; 5986 : 	kWorldInfo.m_iGridWidth = iWidth;

	mov	ecx, DWORD PTR _iWidth$[esp+4]

; 5987 : 	kWorldInfo.m_iGridHeight = iHeight;

	mov	edx, DWORD PTR _iHeight$[esp+4]
	mov	DWORD PTR [esi+296], ecx
	mov	DWORD PTR [esi+300], edx

; 5988 : 
; 5989 : 	return kWorldInfo;

	mov	eax, esi
	pop	esi

; 5990 : }

	pop	ecx
	ret	0
?CreateCustomWorldSize@CvWorldInfo@@SA?AV1@ABV1@HH@Z ENDP ; CvWorldInfo::CreateCustomWorldSize
_TEXT	ENDS
PUBLIC	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??A?$vector@_NV?$allocator@_N@std@@@std@@QBE_NI@Z ; std::vector<bool,std::allocator<bool> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@_NV?$allocator@_N@std@@@std@@QBE_NI@Z
_TEXT	SEGMENT
__Tmp$238420 = -8					; size = 8
__Off$ = 8						; size = 4
??A?$vector@_NV?$allocator@_N@std@@@std@@QBE_NI@Z PROC	; std::vector<bool,std::allocator<bool> >::operator[], COMDAT
; _this$ = ecx

; 2085 : 		{	// subscript nonmutable sequence

	sub	esp, 8

; 2086 : 		return (*(begin() + _Off));

	mov	ecx, DWORD PTR [ecx+8]
	xor	eax, eax
	mov	DWORD PTR __Tmp$238420[esp+12], eax
	mov	eax, DWORD PTR __Off$[esp+4]
	mov	DWORD PTR __Tmp$238420[esp+8], ecx
	push	eax
	lea	ecx, DWORD PTR __Tmp$238420[esp+12]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, 1
	shl	eax, cl
	and	eax, DWORD PTR [edx]
	neg	eax
	sbb	eax, eax
	neg	eax

; 2087 : 		}

	add	esp, 8
	ret	4
??A?$vector@_NV?$allocator@_N@std@@@std@@QBE_NI@Z ENDP	; std::vector<bool,std::allocator<bool> >::operator[]
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::find
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
$T238466 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::find, COMDAT
; _this$ = ecx

; 986  : 		{	// find an element in nonmutable sequence that matches _Keyval

	push	ecx

; 987  : 		const_iterator _Where = lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+33], 0
	push	edi
	mov	edi, DWORD PTR __Keyval$[esp+4]
	jne	SHORT $LN9@find
	push	esi
	mov	esi, DWORD PTR [edi]
$LL10@find:
	cmp	DWORD PTR [eax+12], esi
	jge	SHORT $LN8@find
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@find
$LN8@find:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@find:
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL10@find
	pop	esi
$LN9@find:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Where$[esp+4], edx
	cmp	edx, eax
	je	SHORT $LN3@find
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [edx+12]
	jl	SHORT $LN3@find
	lea	eax, DWORD PTR __Where$[esp+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
$LN3@find:

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	DWORD PTR $T238466[esp+8], eax
	lea	eax, DWORD PTR $T238466[esp+8]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 992  : 		}

	pop	ecx
	ret	8
?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::find
_TEXT	ENDS
PUBLIC	??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@XZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@XZ PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@XZ ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	??0?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::~_Tree_ptr<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::~_Tree_ptr<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_ptr@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::~_Tree_ptr<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Init
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	esi
	mov	esi, ecx

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+33], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0
	pop	esi

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Init
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree_ptr<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree_ptr<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 79   : 		}

	ret	8
??0?$_Tree_ptr@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree_ptr<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
_TEXT	ENDS
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@0PAU2@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Ucopy<std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@0PAU2@@Z
_TEXT	SEGMENT
$T238905 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$238908 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@0PAU2@@Z PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Ucopy<std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$238908[esp]
	mov	BYTE PTR $T238905[esp+4], 0
	mov	eax, DWORD PTR $T238905[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@PAUProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@2@@std@@YAPAUProductionCostModifiers@@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@0@0PAU1@AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@0PAU2@@Z ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Ucopy<std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVCvFormationSlotEntry@@IV1@V?$allocator@VCvFormationSlotEntry@@@std@@@stdext@@YAXPAVCvFormationSlotEntry@@IABV1@AAV?$allocator@VCvFormationSlotEntry@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvFormationSlotEntry *,unsigned int,CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVCvFormationSlotEntry@@IV1@V?$allocator@VCvFormationSlotEntry@@@std@@@stdext@@YAXPAVCvFormationSlotEntry@@IABV1@AAV?$allocator@VCvFormationSlotEntry@@@std@@@Z
_TEXT	SEGMENT
$T238916 = -4						; size = 1
__Cat$238921 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVCvFormationSlotEntry@@IV1@V?$allocator@VCvFormationSlotEntry@@@std@@@stdext@@YAXPAVCvFormationSlotEntry@@IABV1@AAV?$allocator@VCvFormationSlotEntry@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvFormationSlotEntry *,unsigned int,CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T238916[esp+4], 0
	mov	eax, DWORD PTR $T238916[esp+4]
	mov	ecx, DWORD PTR __Cat$238921[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAVCvFormationSlotEntry@@IV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAXPAVCvFormationSlotEntry@@IABV1@AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvFormationSlotEntry *,unsigned int,CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAVCvFormationSlotEntry@@IV1@V?$allocator@VCvFormationSlotEntry@@@std@@@stdext@@YAXPAVCvFormationSlotEntry@@IABV1@AAV?$allocator@VCvFormationSlotEntry@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvFormationSlotEntry *,unsigned int,CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUProductionCostModifiers@@IU1@V?$allocator@UProductionCostModifiers@@@std@@@stdext@@YAXPAUProductionCostModifiers@@IABU1@AAV?$allocator@UProductionCostModifiers@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<ProductionCostModifiers *,unsigned int,ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUProductionCostModifiers@@IU1@V?$allocator@UProductionCostModifiers@@@std@@@stdext@@YAXPAUProductionCostModifiers@@IABU1@AAV?$allocator@UProductionCostModifiers@@@std@@@Z
_TEXT	SEGMENT
$T238925 = -4						; size = 1
__Cat$238930 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUProductionCostModifiers@@IU1@V?$allocator@UProductionCostModifiers@@@std@@@stdext@@YAXPAUProductionCostModifiers@@IABU1@AAV?$allocator@UProductionCostModifiers@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<ProductionCostModifiers *,unsigned int,ProductionCostModifiers,std::allocator<ProductionCostModifiers> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T238925[esp+4], 0
	mov	eax, DWORD PTR $T238925[esp+4]
	mov	ecx, DWORD PTR __Cat$238930[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAUProductionCostModifiers@@IU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAXPAUProductionCostModifiers@@IABU1@AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<ProductionCostModifiers *,unsigned int,ProductionCostModifiers,std::allocator<ProductionCostModifiers> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAUProductionCostModifiers@@IU1@V?$allocator@UProductionCostModifiers@@@std@@@stdext@@YAXPAUProductionCostModifiers@@IABU1@AAV?$allocator@UProductionCostModifiers@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<ProductionCostModifiers *,unsigned int,ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAW4AnimationPathTypes@@IW41@V?$allocator@W4AnimationPathTypes@@@std@@@stdext@@YAXPAW4AnimationPathTypes@@IABW41@AAV?$allocator@W4AnimationPathTypes@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<enum AnimationPathTypes *,unsigned int,enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_fill_n@PAW4AnimationPathTypes@@IW41@V?$allocator@W4AnimationPathTypes@@@std@@@stdext@@YAXPAW4AnimationPathTypes@@IABW41@AAV?$allocator@W4AnimationPathTypes@@@std@@@Z
_TEXT	SEGMENT
$T238934 = -4						; size = 1
__Cat$238939 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAW4AnimationPathTypes@@IW41@V?$allocator@W4AnimationPathTypes@@@std@@@stdext@@YAXPAW4AnimationPathTypes@@IABW41@AAV?$allocator@W4AnimationPathTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<enum AnimationPathTypes *,unsigned int,enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T238934[esp+4], 0
	mov	eax, DWORD PTR $T238934[esp+4]
	mov	ecx, DWORD PTR __Cat$238939[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAW4AnimationPathTypes@@IW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@IABW41@AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum AnimationPathTypes *,unsigned int,enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAW4AnimationPathTypes@@IW41@V?$allocator@W4AnimationPathTypes@@@std@@@stdext@@YAXPAW4AnimationPathTypes@@IABW41@AAV?$allocator@W4AnimationPathTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<enum AnimationPathTypes *,unsigned int,enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvString *,CvString *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvString *,CvString *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	ebx, esi
	je	SHORT $LN19@Unchecked_@5
$LL12@Unchecked_@5:
	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	cmp	esi, ebx
	jne	SHORT $LL12@Unchecked_@5
$LN19@Unchecked_@5:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAXPAUProductionCostModifiers@@0AAV?$allocator@UProductionCostModifiers@@@0@@Z ; std::_Destroy_range<std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAXPAUProductionCostModifiers@@0AAV?$allocator@UProductionCostModifiers@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAXPAUProductionCostModifiers@@0AAV?$allocator@UProductionCostModifiers@@@0@@Z PROC ; std::_Destroy_range<std::allocator<ProductionCostModifiers> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAXPAUProductionCostModifiers@@0AAV?$allocator@UProductionCostModifiers@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@@Z ; std::_Destroy_range<std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum AnimationPathTypes> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@0AAV?$allocator@W4AnimationPathTypes@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAXPAVCvFormationSlotEntry@@0AAV?$allocator@VCvFormationSlotEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvFormationSlotEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAXPAVCvFormationSlotEntry@@0AAV?$allocator@VCvFormationSlotEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAXPAVCvFormationSlotEntry@@0AAV?$allocator@VCvFormationSlotEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvFormationSlotEntry> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAXPAVCvFormationSlotEntry@@0AAV?$allocator@VCvFormationSlotEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvFormationSlotEntry> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T239057 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Vptr$239054 = 12					; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	esi, DWORD PTR __First$[ebp]
	push	edi

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __Count$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_fil@4:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil@4

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$239054[ebp], esi
	mov	DWORD PTR $T239057[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil@4
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN18@Uninit_fil@4:
	dec	edi
	add	esi, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@4
__catch$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@4
$LL3@Uninit_fil@4:

; 407  : 		_Al.destroy(_Next);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@4
$LN1@Uninit_fil@4:

; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN42@Uninit_fil@4:
$LN4@Uninit_fil@4:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@Uninit_fil@4:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$239054[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239057[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
PUBLIC	??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvString> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	esi

; 233  : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra
	npad	2
$LL3@Destroy_ra:

; 234  : 		_Al.destroy(_First);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra
$LN1@Destroy_ra:
	pop	edi
	pop	esi

; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T239150 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$239154 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$239154[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T239150[esp+4], 0
	mov	eax, DWORD PTR $T239150[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@U_Undefined_move_tag@3@@std@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@U_Undefined_move_tag@3@@std@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T239169 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$239173 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@U_Undefined_move_tag@3@@std@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$239173[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T239169[esp+4], 0
	mov	eax, DWORD PTR $T239169[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@U_Undefined_move_tag@3@@std@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T239188 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$239192 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$239192[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T239188[esp+4], 0
	mov	eax, DWORD PTR $T239188[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z
_TEXT	SEGMENT
$T239198 = -4						; size = 1
__Cat$239202 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T239198[esp+4], 0
	mov	eax, DWORD PTR $T239198[esp+4]
	mov	ecx, DWORD PTR __Cat$239202[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@std@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@0@0PAIAAV?$allocator@I@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z
_TEXT	SEGMENT
$T239207 = -4						; size = 1
__Cat$239212 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T239207[esp+4], 0
	mov	eax, DWORD PTR $T239207[esp+4]
	mov	ecx, DWORD PTR __Cat$239212[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::begin, COMDAT
; _this$ = ecx

; 1985 : 		return (iterator(_VEC_ITER_BASE(_Myvec.begin())));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1986 : 		}

	ret	4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::end, COMDAT
; _this$ = ecx

; 1996 : 		iterator _Tmp = begin();

	mov	eax, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], 0

; 1997 : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jbe	SHORT $LN20@end

; 1998 : 			_Tmp += _Mysize;

	push	ecx
	mov	ecx, esi
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN20@end:

; 1999 : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 2000 : 		}

	ret	4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::end
_TEXT	ENDS
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z PROC ; std::vector<bool,std::allocator<bool> >::_Make_iter, COMDAT
; _this$ = ecx

; 2012 : 		iterator _Tmp = begin();

	mov	eax, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], 0

; 2013 : 		if (0 < _Mysize)

	cmp	DWORD PTR [ecx], 0
	jbe	SHORT $LN36@Make_iter

; 2014 : 			_Tmp += _Where - begin();

	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __Where$[esp]
	sub	edx, ecx
	sar	edx, 2
	shl	edx, 5
	add	edx, DWORD PTR __Where$[esp+4]
	mov	ecx, esi
	push	edx
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN36@Make_iter:

; 2015 : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 2016 : 		}

	ret	12					; 0000000cH
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
_TEXT	ENDS
PUBLIC	??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T239612 = -4						; size = 1
__Cat$239617 = 8					; size = 1
$T239614 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z PROC ; std::copy<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 2587 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 2588 : 	return (_Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, 
; 2589 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$239617[esp]
	mov	edx, DWORD PTR $T239614[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T239612[esp+8], 0
	mov	eax, DWORD PTR $T239612[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+28]
	push	edx
	mov	edx, DWORD PTR __First$[esp+28]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
	add	esp, 40					; 00000028H
	mov	eax, esi
	pop	esi

; 2590 : 	}

	pop	ecx
	ret	0
??$copy@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ENDP ; std::copy<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	esi
	push	edi
$LL2@Copy_backw@6:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	esi, DWORD PTR __Last$[esp+4]
	mov	ecx, DWORD PTR __Last$[esp+8]
	cmp	DWORD PTR __First$[esp+4], esi
	jne	SHORT $LN9@Copy_backw@6
	cmp	DWORD PTR __First$[esp+8], ecx
	je	SHORT $LN61@Copy_backw@6
$LN9@Copy_backw@6:

; 2676 : 		*--_Dest = *--_Last;

	test	ecx, ecx
	je	SHORT $LN16@Copy_backw@6
	dec	ecx
	jmp	SHORT $LN62@Copy_backw@6
$LN16@Copy_backw@6:
	sub	esi, 4
	mov	DWORD PTR __Last$[esp+4], esi
	mov	ecx, 31					; 0000001fH
$LN62@Copy_backw@6:
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	eax, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR __Last$[esp+8], ecx
	test	edx, edx
	je	SHORT $LN30@Copy_backw@6
	dec	edx
	jmp	SHORT $LN63@Copy_backw@6
$LN30@Copy_backw@6:
	sub	eax, 4
	mov	DWORD PTR __Dest$[esp+4], eax
	mov	edx, 31					; 0000001fH
$LN63@Copy_backw@6:
	mov	edi, 1
	shl	edi, cl
	mov	DWORD PTR __Dest$[esp+8], edx
	mov	ecx, edx
	test	edi, DWORD PTR [esi]
	mov	esi, 1
	je	SHORT $LN48@Copy_backw@6
	shl	esi, cl
	or	DWORD PTR [eax], esi
	jmp	SHORT $LL2@Copy_backw@6
$LN48@Copy_backw@6:
	shl	esi, cl
	not	esi
	and	DWORD PTR [eax], esi
	jmp	SHORT $LL2@Copy_backw@6
$LN61@Copy_backw@6:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@6
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@6:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@5
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@5:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@5
	pop	esi
$LN9@Uninit_fil@5:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?isCivilizationBuildingOverridden@CvCivilizationInfo@@QBE_NH@Z ; CvCivilizationInfo::isCivilizationBuildingOverridden
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
;	COMDAT ?isCivilizationBuildingOverridden@CvCivilizationInfo@@QBE_NH@Z
_TEXT	SEGMENT
__Tmp$239985 = -8					; size = 8
_i$ = 8							; size = 4
?isCivilizationBuildingOverridden@CvCivilizationInfo@@QBE_NH@Z PROC ; CvCivilizationInfo::isCivilizationBuildingOverridden, COMDAT
; _this$ = ecx

; 2185 : {

	sub	esp, 8

; 2186 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2187 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2188 : 	return m_CivilizationBuildingOverridden[i];

	mov	ecx, DWORD PTR [ecx+624]
	xor	eax, eax
	mov	DWORD PTR __Tmp$239985[esp+12], eax
	mov	eax, DWORD PTR _i$[esp+4]
	mov	DWORD PTR __Tmp$239985[esp+8], ecx
	push	eax
	lea	ecx, DWORD PTR __Tmp$239985[esp+12]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, 1
	shl	eax, cl
	and	eax, DWORD PTR [edx]
	neg	eax
	sbb	eax, eax
	neg	eax

; 2189 : }

	add	esp, 8
	ret	4
?isCivilizationBuildingOverridden@CvCivilizationInfo@@QBE_NH@Z ENDP ; CvCivilizationInfo::isCivilizationBuildingOverridden
_TEXT	ENDS
PUBLIC	?isCivilizationUnitOverridden@CvCivilizationInfo@@QBE_NH@Z ; CvCivilizationInfo::isCivilizationUnitOverridden
; Function compile flags: /Ogtpy
;	COMDAT ?isCivilizationUnitOverridden@CvCivilizationInfo@@QBE_NH@Z
_TEXT	SEGMENT
__Tmp$240095 = -8					; size = 8
_i$ = 8							; size = 4
?isCivilizationUnitOverridden@CvCivilizationInfo@@QBE_NH@Z PROC ; CvCivilizationInfo::isCivilizationUnitOverridden, COMDAT
; _this$ = ecx

; 2192 : {

	sub	esp, 8

; 2193 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 2194 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2195 : 	return m_CivilizationUnitOverridden[i];

	mov	ecx, DWORD PTR [ecx+644]
	xor	eax, eax
	mov	DWORD PTR __Tmp$240095[esp+12], eax
	mov	eax, DWORD PTR _i$[esp+4]
	mov	DWORD PTR __Tmp$240095[esp+8], ecx
	push	eax
	lea	ecx, DWORD PTR __Tmp$240095[esp+12]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, 1
	shl	eax, cl
	and	eax, DWORD PTR [edx]
	neg	eax
	sbb	eax, eax
	neg	eax

; 2196 : }

	add	esp, 8
	ret	4
?isCivilizationUnitOverridden@CvCivilizationInfo@@QBE_NH@Z ENDP ; CvCivilizationInfo::isCivilizationUnitOverridden
_TEXT	ENDS
PUBLIC	?getUnitCombatProductionCostModifiersLocal@CvResourceInfo@@QBEHW4UnitCombatTypes@@W4EraTypes@@@Z ; CvResourceInfo::getUnitCombatProductionCostModifiersLocal
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitCombatProductionCostModifiersLocal@CvResourceInfo@@QBEHW4UnitCombatTypes@@W4EraTypes@@@Z
_TEXT	SEGMENT
_itMap$ = -4						; size = 4
_iUnitCombat$ = 8					; size = 4
_eUnitCombat$ = 8					; size = 4
_eUnitEra$ = 12						; size = 4
?getUnitCombatProductionCostModifiersLocal@CvResourceInfo@@QBEHW4UnitCombatTypes@@W4EraTypes@@@Z PROC ; CvResourceInfo::getUnitCombatProductionCostModifiersLocal, COMDAT
; _this$ = ecx

; 4646 : {

	push	ecx

; 4647 : 	CvAssertMsg(eUnitCombat < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 4648 : 	CvAssertMsg(eUnitCombat > -1, "Index out of bounds");
; 4649 : 
; 4650 : 	CvAssertMsg(eUnitEra < GC.getNumEraInfos(), "Index out of bounds");
; 4651 : 	CvAssertMsg(eUnitEra > -1, "Index out of bounds");
; 4652 : 
; 4653 : 	int iUnitCombat = (int)eUnitCombat;

	mov	eax, DWORD PTR _eUnitCombat$[esp]
	push	ebx
	push	esi
	mov	esi, ecx

; 4654 : 	int iUnitEra = (int)eUnitEra;
; 4655 : 	int iMod = 0;
; 4656 : 
; 4657 : 	std::map<int, std::vector<ProductionCostModifiers>>::const_iterator itMap = m_piiiUnitCombatProductionCostModifiersLocal.find(iUnitCombat);

	lea	ecx, DWORD PTR _iUnitCombat$[esp+8]
	push	ecx
	lea	edx, DWORD PTR _itMap$[esp+16]
	push	edx
	lea	ecx, DWORD PTR [esi+532]
	mov	DWORD PTR _iUnitCombat$[esp+16], eax
	xor	ebx, ebx
	call	?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::find

; 4658 : 	if (itMap != m_piiiUnitCombatProductionCostModifiersLocal.end()) // find returns the iterator to map::end if the key iUnitCombat is not present in the map

	mov	ecx, DWORD PTR _itMap$[esp+12]
	cmp	ecx, DWORD PTR [esi+536]
	je	SHORT $LN67@getUnitCom

; 4659 : 	{
; 4660 : 		for (std::vector<ProductionCostModifiers>::const_iterator itVector = itMap->second.begin(); itVector != itMap->second.end(); ++itVector)

	mov	eax, DWORD PTR [ecx+20]
	push	edi
	mov	edi, DWORD PTR [ecx+24]
	cmp	eax, edi
	je	SHORT $LN66@getUnitCom
	mov	esi, DWORD PTR _eUnitEra$[esp+12]
	npad	1
$LL28@getUnitCom:

; 4661 : 		{
; 4662 : 			EraTypes eRequiredEra = (EraTypes)itVector->m_iRequiredEra;
; 4663 : 			EraTypes eObsoleteEra = (EraTypes)itVector->m_iObsoleteEra;

	mov	edx, DWORD PTR [eax+4]

; 4664 : 
; 4665 : 			if (eUnitEra != NO_ERA)

	cmp	esi, -1
	je	SHORT $LN1@getUnitCom
	mov	ecx, DWORD PTR [eax]

; 4666 : 			{
; 4667 : 				// Our unit's era needs to be greater than or equal to the required era
; 4668 : 				if (eRequiredEra != NO_ERA && iUnitEra < itVector->m_iRequiredEra)

	cmp	ecx, -1
	je	SHORT $LN2@getUnitCom
	cmp	esi, ecx
	jl	SHORT $LN5@getUnitCom
$LN2@getUnitCom:

; 4669 : 				{
; 4670 : 					continue;
; 4671 : 				}
; 4672 : 
; 4673 : 				// Our unit's era needs to be less than the obsolete era
; 4674 : 				if (eObsoleteEra != NO_ERA && iUnitEra >= itVector->m_iObsoleteEra)

	cmp	edx, -1
	je	SHORT $LN1@getUnitCom
	cmp	esi, edx
	jge	SHORT $LN5@getUnitCom
$LN1@getUnitCom:

; 4675 : 				{
; 4676 : 					continue;
; 4677 : 				}
; 4678 : 			}
; 4679 : 
; 4680 : 			iMod += itVector->m_iCostModifier;

	add	ebx, DWORD PTR [eax+8]
$LN5@getUnitCom:

; 4659 : 	{
; 4660 : 		for (std::vector<ProductionCostModifiers>::const_iterator itVector = itMap->second.begin(); itVector != itMap->second.end(); ++itVector)

	add	eax, 12					; 0000000cH
	cmp	eax, edi
	jne	SHORT $LL28@getUnitCom
$LN66@getUnitCom:
	pop	edi
	pop	esi

; 4681 : 		}
; 4682 : 	}
; 4683 : 
; 4684 : 	return iMod;

	mov	eax, ebx
	pop	ebx

; 4685 : }

	pop	ecx
	ret	8
$LN67@getUnitCom:
	pop	esi

; 4681 : 		}
; 4682 : 	}
; 4683 : 
; 4684 : 	return iMod;

	mov	eax, ebx
	pop	ebx

; 4685 : }

	pop	ecx
	ret	8
?getUnitCombatProductionCostModifiersLocal@CvResourceInfo@@QBEHW4UnitCombatTypes@@W4EraTypes@@@Z ENDP ; CvResourceInfo::getUnitCombatProductionCostModifiersLocal
_TEXT	ENDS
PUBLIC	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z
_TEXT	SEGMENT
__Tmp$240297 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z PROC ; std::vector<bool,std::allocator<bool> >::operator[], COMDAT
; _this$ = ecx

; 2090 : 		{	// subscript mutable sequence

	sub	esp, 8

; 2091 : 		return (*(begin() + _Off));

	mov	ecx, DWORD PTR [ecx+8]
	xor	eax, eax
	mov	DWORD PTR __Tmp$240297[esp+12], eax
	mov	eax, DWORD PTR __Off$[esp+4]
	mov	DWORD PTR __Tmp$240297[esp+8], ecx
	push	eax
	lea	ecx, DWORD PTR __Tmp$240297[esp+12]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Tmp$240297[esp+8]
	mov	edx, DWORD PTR __Tmp$240297[esp+12]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 2092 : 		}

	add	esp, 8
	ret	8
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEPAVCvFormationSlotEntry@@PAV3@IABV3@@Z ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEPAVCvFormationSlotEntry@@PAV3@IABV3@@Z
_TEXT	SEGMENT
$T240332 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$240336 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEPAVCvFormationSlotEntry@@PAV3@IABV3@@Z PROC ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$240336[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T240332[esp+12], 0
	mov	eax, DWORD PTR $T240332[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVCvFormationSlotEntry@@IV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAXPAVCvFormationSlotEntry@@IABV1@AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvFormationSlotEntry *,unsigned int,CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >

; 1255 : 		return (_Ptr + _Count);

	mov	eax, esi
	add	esp, 24					; 00000018H
	shl	eax, 4
	add	eax, edi
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEPAVCvFormationSlotEntry@@PAV3@IABV3@@Z ENDP ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree_val<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree_val<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 98   : 		}

	ret	8
??0?$_Tree_val@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree_val<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@PAU3@IABU3@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@PAU3@IABU3@@Z
_TEXT	SEGMENT
$T240435 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$240439 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@PAU3@IABU3@@Z PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$240439[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T240435[esp+12], 0
	mov	eax, DWORD PTR $T240435[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAUProductionCostModifiers@@IU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAXPAUProductionCostModifiers@@IABU1@AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<ProductionCostModifiers *,unsigned int,ProductionCostModifiers,std::allocator<ProductionCostModifiers> >

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi+esi*2]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@PAU3@IABU3@@Z ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEPAW4AnimationPathTypes@@PAW43@IABW43@@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEPAW4AnimationPathTypes@@PAW43@IABW43@@Z
_TEXT	SEGMENT
$T240453 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$240457 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEPAW4AnimationPathTypes@@PAW43@IABW43@@Z PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$240457[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T240453[esp+12], 0
	mov	eax, DWORD PTR $T240453[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAW4AnimationPathTypes@@IW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@IABW41@AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum AnimationPathTypes *,unsigned int,enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEPAW4AnimationPathTypes@@PAW43@IABW43@@Z ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXPAUProductionCostModifiers@@0@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXPAUProductionCostModifiers@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXPAUProductionCostModifiers@@0@Z PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXPAUProductionCostModifiers@@0@Z ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXPAW4AnimationPathTypes@@0@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXPAW4AnimationPathTypes@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXPAW4AnimationPathTypes@@0@Z PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXPAW4AnimationPathTypes@@0@Z ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXPAVCvFormationSlotEntry@@0@Z ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXPAVCvFormationSlotEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXPAVCvFormationSlotEntry@@0@Z PROC ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXPAVCvFormationSlotEntry@@0@Z ENDP ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Destroy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z
_TEXT	SEGMENT
$T240471 = -4						; size = 1
__Cat$240475 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240471[esp+4], 0
	mov	eax, DWORD PTR $T240471[esp+4]
	mov	ecx, DWORD PTR __Cat$240475[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z ; std::_Destroy_range<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvString> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	esi

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN5@Destroy_ra@2
	npad	2
$LL7@Destroy_ra@2:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL7@Destroy_ra@2
$LN5@Destroy_ra@2:
	pop	edi
	pop	esi

; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@stdext@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@stdext@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@std@@@Z
_TEXT	SEGMENT
$T240562 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$240565 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@stdext@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$240565[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240562[esp+4], 0
	mov	eax, DWORD PTR $T240562[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@stdext@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@stdext@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@stdext@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@std@@@Z
_TEXT	SEGMENT
$T240599 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$240602 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@stdext@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$240602[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240599[esp+4], 0
	mov	eax, DWORD PTR $T240599[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@stdext@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@stdext@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@stdext@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@std@@@Z
_TEXT	SEGMENT
$T240636 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$240639 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@stdext@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$240639[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240636[esp+4], 0
	mov	eax, DWORD PTR $T240636[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@stdext@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@U_Undefined_move_tag@2@@std@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@0@0PAIAAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@U_Undefined_move_tag@2@@std@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@0@0PAIAAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T240654 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$240658 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@U_Undefined_move_tag@2@@std@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@0@0PAIAAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$240658[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240654[esp+4], 0
	mov	eax, DWORD PTR $T240654[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@std@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@0@0PAIAAV?$allocator@I@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@U_Undefined_move_tag@2@@std@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@0@0PAIAAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvString *,CvString *,std::allocator<CvString>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T240673 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$240677 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvString *,CvString *,std::allocator<CvString>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$240677[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T240673[esp+4], 0
	mov	eax, DWORD PTR $T240673[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvString *,CvString *,std::allocator<CvString>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
; Function compile flags: /Ogtpy
;	COMDAT ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T240703 = 8						; size = 4
__Size$ = 8						; size = 4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z PROC ; std::vector<bool,std::allocator<bool> >::_Trim, COMDAT
; _this$ = ecx

; 2360 : 		{	// trim base vector to exact length in bits

	push	ebx

; 2361 : 		if (max_size() < _Size)

	mov	ebx, DWORD PTR __Size$[esp]
	push	edi
	mov	edi, ecx
	cmp	ebx, -1
	jbe	SHORT $LN3@Trim

; 2362 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
$LN42@Trim:
$LN3@Trim:

; 2363 : 		size_type _Words = _Nw(_Size);
; 2364 : 
; 2365 : 		if (_Words < _Myvec.size())

	mov	eax, DWORD PTR [edi+12]
	sub	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [edi+4]
	push	esi
	lea	esi, DWORD PTR [ebx+31]
	shr	esi, 5
	sar	eax, 2
	cmp	esi, eax
	jae	SHORT $LN2@Trim

; 2366 : 			_Myvec.erase(_Myvec.begin() + _Words, _Myvec.end());

	mov	eax, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+8]
	push	eax
	lea	edx, DWORD PTR [edx+esi*4]
	push	edx
	lea	eax, DWORD PTR $T240703[esp+16]
	push	eax
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
$LN2@Trim:

; 2367 : 		_Mysize = _Size;

	mov	DWORD PTR [edi], ebx

; 2368 : 		_Size %= _VBITS;

	and	ebx, 31					; 0000001fH

; 2369 : 		if (0 < _Size)

	jbe	SHORT $LN40@Trim

; 2370 : 			_Myvec[_Words - 1] &= (_Vbase)((1 << _Size) - 1);

	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [ecx+esi*4-4]
	mov	edx, 1
	mov	ecx, ebx
	shl	edx, cl
	dec	edx
	and	DWORD PTR [eax], edx
$LN40@Trim:
	pop	esi
	pop	edi
	pop	ebx

; 2371 : 		}

	ret	4
$LN41@Trim:
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Trim
_TEXT	ENDS
PUBLIC	??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T240799 = -4						; size = 1
__Cat$240805 = 8					; size = 1
$T240801 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z PROC ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 2740 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 2741 : 	return _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 2742 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Cat$240805[esp]
	mov	edx, DWORD PTR $T240801[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T240799[esp+8], 0
	mov	eax, DWORD PTR $T240799[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+28]
	push	edx
	mov	edx, DWORD PTR __First$[esp+28]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
	add	esp, 40					; 00000028H
	mov	eax, esi
	pop	esi

; 2743 : 	}

	pop	ecx
	ret	0
??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ENDP ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
_TEXT	ENDS
PUBLIC	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@6
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@6:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@6
	pop	esi
$LN13@unchecked_@6:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ; std::vector<CvString,std::allocator<CvString> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z
_TEXT	SEGMENT
$T240977 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$240981 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$240981[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T240977[esp+12], 0
	mov	eax, DWORD PTR $T240977[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi*8]
	sub	ecx, esi
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	esi
	mov	esi, ecx

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 511  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@0@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@0@Z PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@2
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@2
	push	ebx
	npad	4
$LL28@erase@2:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], ebx
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], ebx
	add	edx, 12					; 0000000cH
	add	esi, 12					; 0000000cH
	cmp	edx, edi
	jne	SHORT $LL28@erase@2
	pop	ebx
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@2:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@0@Z ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXXZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXXZ PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXXZ ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXXZ ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	esi

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN7@Destroy
	npad	2
$LL9@Destroy:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL9@Destroy
$LN7@Destroy:
	pop	edi
	pop	esi

; 1120 : 		}

	ret	8
?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Umove@PAVCvFormationSlotEntry@@@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEPAVCvFormationSlotEntry@@PAV2@00@Z ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Umove<CvFormationSlotEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAVCvFormationSlotEntry@@@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEPAVCvFormationSlotEntry@@PAV2@00@Z
_TEXT	SEGMENT
$T241375 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$241379 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAVCvFormationSlotEntry@@@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEPAVCvFormationSlotEntry@@PAV2@00@Z PROC ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Umove<CvFormationSlotEntry *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$241379[esp]
	mov	BYTE PTR $T241375[esp+4], 0
	mov	eax, DWORD PTR $T241375[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAVCvFormationSlotEntry@@@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEPAVCvFormationSlotEntry@@PAV2@00@Z ENDP ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Umove<CvFormationSlotEntry *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAUProductionCostModifiers@@@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@PAU2@00@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Umove<ProductionCostModifiers *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAUProductionCostModifiers@@@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@PAU2@00@Z
_TEXT	SEGMENT
$T241430 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$241434 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUProductionCostModifiers@@@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@PAU2@00@Z PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Umove<ProductionCostModifiers *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$241434[esp]
	mov	BYTE PTR $T241430[esp+4], 0
	mov	eax, DWORD PTR $T241430[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAUProductionCostModifiers@@@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@PAU2@00@Z ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Umove<ProductionCostModifiers *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAW4AnimationPathTypes@@@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEPAW4AnimationPathTypes@@PAW42@00@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Umove<enum AnimationPathTypes *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAW4AnimationPathTypes@@@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEPAW4AnimationPathTypes@@PAW42@00@Z
_TEXT	SEGMENT
$T241486 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$241490 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAW4AnimationPathTypes@@@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEPAW4AnimationPathTypes@@PAW42@00@Z PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Umove<enum AnimationPathTypes *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$241490[esp]
	mov	BYTE PTR $T241486[esp+4], 0
	mov	eax, DWORD PTR $T241486[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAW4AnimationPathTypes@@@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEPAW4AnimationPathTypes@@PAW42@00@Z ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Umove<enum AnimationPathTypes *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z
_TEXT	SEGMENT
$T241522 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$241525 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$241525[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T241522[esp+4], 0
	mov	eax, DWORD PTR $T241522[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@std@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@0@0PAIAAV?$allocator@I@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@stdext@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@std@@0PAIAAV?$allocator@I@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvString *,CvString *,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z
_TEXT	SEGMENT
$T241559 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$241562 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$241562[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T241559[esp+4], 0
	mov	eax, DWORD PTR $T241559[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvString *,CvString *,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 1903 : 		{	// construct empty vector

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 1904 : 		}

	ret	0
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
_TEXT	ENDS
PUBLIC	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 1957 : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 1958 : 		_Mysize = 0;

	mov	DWORD PTR [esi], 0

; 1959 : 		}

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN9@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@vector@2:
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	pop	esi
	ret	0
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T242191 = -28						; size = 1
__First$ = -24						; size = 8
$T241749 = -16						; size = 8
__Next$ = -8						; size = 8
__Last$ = -8						; size = 8
__Cat$242196 = 8					; size = 1
$T242193 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Tmp$242318 = 12					; size = 8
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z PROC ; std::vector<bool,std::allocator<bool> >::erase, COMDAT
; _this$ = ecx

; 2221 : 		{	// erase [_First, _Last)

	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 2222 : 		iterator _First = _Make_iter(_First_arg);

	mov	ebp, DWORD PTR [edi]
	mov	ebx, DWORD PTR [edi+8]
	xor	esi, esi
	mov	DWORD PTR __First$[esp+44], ebx
	mov	DWORD PTR __First$[esp+48], esi
	cmp	ebp, esi
	jbe	SHORT $LN36@erase@3
	mov	eax, DWORD PTR __First_arg$[esp+40]
	sub	eax, ebx
	sar	eax, 2
	shl	eax, 5
	add	eax, DWORD PTR __First_arg$[esp+44]
	lea	ecx, DWORD PTR __First$[esp+44]
	push	eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN36@erase@3:

; 2223 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	DWORD PTR __Last$[esp+44], ebx
	mov	DWORD PTR __Last$[esp+48], esi
	cmp	ebp, esi
	jbe	SHORT $LN71@erase@3
	mov	ecx, DWORD PTR __Last_arg$[esp+40]
	sub	ecx, ebx
	sar	ecx, 2
	shl	ecx, 5
	add	ecx, DWORD PTR __Last_arg$[esp+44]
	push	ecx
	lea	ecx, DWORD PTR __Last$[esp+48]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN71@erase@3:

; 2224 : 		size_type _Off = _First - begin();

	mov	esi, DWORD PTR __First$[esp+44]
	sub	esi, ebx
	sar	esi, 2
	shl	esi, 5
	add	esi, DWORD PTR __First$[esp+48]

; 2225 : 
; 2226 :  #if _HAS_ITERATOR_DEBUGGING
; 2227 : 		if (_Last < _First || end() < _Last)
; 2228 : 			_DEBUG_ERROR("vector<bool> erase iterator outside range");
; 2229 : 		iterator _Next = std::copy(_Last, end(), _First);
; 2230 : 		size_type _Newsize = _Next - begin();
; 2231 : 		_Orphan_range(_Newsize, _Mysize);
; 2232 : 		_Trim(_Newsize);
; 2233 : 
; 2234 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 2235 : 		iterator _Next = std::copy(_Last, end(), _First);

	mov	DWORD PTR $T241749[esp+44], ebx
	mov	DWORD PTR $T241749[esp+48], 0
	test	ebp, ebp
	jbe	SHORT $LN108@erase@3
	push	ebp
	lea	ecx, DWORD PTR $T241749[esp+48]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN108@erase@3:
	mov	eax, DWORD PTR __Cat$242196[esp+40]
	mov	ecx, DWORD PTR $T242193[esp+40]
	mov	BYTE PTR $T242191[esp+44], 0
	mov	edx, DWORD PTR $T242191[esp+44]
	push	edx
	mov	edx, DWORD PTR __First$[esp+52]
	push	eax
	mov	eax, DWORD PTR __First$[esp+52]
	push	ecx
	mov	ecx, DWORD PTR $T241749[esp+60]
	push	edx
	mov	edx, DWORD PTR $T241749[esp+60]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+68]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+68]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR __Next$[esp+80]
	push	edx
	call	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>

; 2236 : 		_Trim(_Next - begin());

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR __Next$[esp+84]
	sub	ecx, eax
	sar	ecx, 2
	shl	ecx, 5
	add	ecx, DWORD PTR __Next$[esp+88]
	add	esp, 40					; 00000028H
	push	ecx
	mov	ecx, edi
	call	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim

; 2237 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2238 : 
; 2239 : 		return (begin() + _Off);

	mov	edi, DWORD PTR [edi+8]
	xor	eax, eax
	push	esi
	lea	ecx, DWORD PTR __Tmp$242318[esp+44]
	mov	DWORD PTR __Tmp$242318[esp+44], edi
	mov	DWORD PTR __Tmp$242318[esp+48], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+40]
	mov	edx, DWORD PTR __Tmp$242318[esp+40]
	mov	ecx, DWORD PTR __Tmp$242318[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebx

; 2240 : 		}

	add	esp, 28					; 0000001cH
	ret	20					; 00000014H
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ENDP ; std::vector<bool,std::allocator<bool> >::erase
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T242539 = 8						; size = 1
__Cat$242542 = 8					; size = 1
__Right$ = 8						; size = 4
??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx

; 501  : 		if (_Buy(_Right.size()))

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, DWORD PTR [ebx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	push	edi
	sar	edx, 1
	mov	edi, edx
	mov	eax, 0
	shr	edi, 31					; 0000001fH
	add	edi, edx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	je	SHORT $LN7@vector@3
	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN22@vector@3
	call	?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Xlen
$LN54@vector@3:
$LN22@vector@3:
	push	eax
	push	edi
	call	??$_Allocate@UProductionCostModifiers@@@std@@YAPAUProductionCostModifiers@@IPAU1@@Z ; std::_Allocate<ProductionCostModifiers>
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+12], edx

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	BYTE PTR $T242539[ebp], 0
	mov	edx, DWORD PTR $T242539[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$242542[ebp]
	push	edx
	push	esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	ecx, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ebx+4]
	push	eax
	push	ecx
	push	ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@PAUProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@2@@std@@YAPAUProductionCostModifiers@@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@0@0PAU1@AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi+8], eax
$LN7@vector@3:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXXZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN55@vector@3:
$LN53@vector@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
PUBLIC	??1?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@XZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::~vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@XZ PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::~vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@4:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@XZ ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::~vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEXXZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T242580 = -4						; size = 4
?clear@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEXXZ PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T242580[esp+12]
	push	eax
	call	?erase@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@0@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEXXZ ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::~vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::~vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@5:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::~vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
_TEXT	ENDS
PUBLIC	??1?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@QAE@XZ ; std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >::~pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@QAE@XZ PROC ; std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >::~pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN9@pair
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@pair:
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	pop	esi
	ret	0
??1?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@QAE@XZ ENDP ; std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >::~pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >
_TEXT	ENDS
PUBLIC	?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ; std::vector<CvString,std::allocator<CvString> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z PROC ; std::vector<CvString,std::allocator<CvString> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp+4]
	push	edi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edi, DWORD PTR __Last_arg$[esp+8]
	mov	ebp, ecx
	mov	DWORD PTR [eax], esi
	cmp	esi, edi
	je	SHORT $LN1@erase@4
	push	ebx

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ebx, DWORD PTR [ebp+8]
	cmp	edi, ebx
	je	SHORT $LN26@erase@4
	npad	1
$LL28@erase@4:
	push	edi
	mov	ecx, esi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	edi, 28					; 0000001cH
	add	esi, 28					; 0000001cH
	cmp	edi, ebx
	jne	SHORT $LL28@erase@4
$LN26@erase@4:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ebx, DWORD PTR [ebp+8]
	mov	edi, esi
	cmp	esi, ebx
	je	SHORT $LN39@erase@4
	npad	4
$LL41@erase@4:
	mov	ecx, edi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	edi, 28					; 0000001cH
	cmp	edi, ebx
	jne	SHORT $LL41@erase@4
$LN39@erase@4:

; 1049 : 			_Mylast = _Ptr;
; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [ebp+8], esi
	pop	ebx
$LN1@erase@4:
	pop	edi
	pop	esi
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ PROC ; std::vector<CvString,std::allocator<CvString> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebx
	mov	ebx, ecx
	push	esi

; 1124 : 		if (_Myfirst != 0)

	mov	esi, DWORD PTR [ebx+4]
	test	esi, esi
	je	SHORT $LN25@Tidy@4
	push	edi

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [ebx+8]
	cmp	esi, edi
	je	SHORT $LN10@Tidy@4
$LL12@Tidy@4:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL12@Tidy@4
$LN10@Tidy@4:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
$LN25@Tidy@4:
	pop	esi

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
	pop	ebx

; 1135 : 		}

	ret	0
?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@QAE@ABHABV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@@Z ; std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@QAE@ABHABV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@QAE@ABHABV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@@Z PROC ; std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR __Val2$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	push	edx
	lea	ecx, DWORD PTR [esi+4]
	call	??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >

; 51   : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@QAE@ABHABV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@@Z ENDP ; std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z$0
__unwindtable$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z
_TEXT	SEGMENT
__Tmp$224328 = -36					; size = 16
__Tmp$224318 = -36					; size = 16
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$243162 = 8					; size = 1
__Cat$243090 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$224303 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T243158 = 16						; size = 1
$T243085 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z PROC ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 4
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 4
	mov	edx, 268435455				; 0fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@KAXXZ ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Xlen
$LN87@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 268435455				; 0fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@VCvFormationSlotEntry@@@std@@YAPAVCvFormationSlotEntry@@IPAV1@@Z ; std::_Allocate<CvFormationSlotEntry>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	sar	ebx, 4
	push	ecx
	mov	edx, ebx
	shl	edx, 4
	push	edi
	add	edx, eax
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$224303[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEPAVCvFormationSlotEntry@@PAV3@IABV3@@Z ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$243090[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T243085[ebp], 0
	mov	ecx, DWORD PTR $T243085[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$224303[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T243158[ebp], 0
	mov	edx, DWORD PTR $T243158[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$243162[ebp]
	push	edx
	lea	eax, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR __Newvec$224303[ebp]
	shl	eax, 4
	add	eax, ebx
	push	esi
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ecx
	push	eax
	call	??$_Uninit_copy@PAVCvFormationSlotEntry@@PAV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAPAVCvFormationSlotEntry@@PAV1@00AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvFormationSlotEntry *,CvFormationSlotEntry *,std::allocator<CvFormationSlotEntry> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 4
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	shl	eax, 4
	add	eax, ebx

; 1206 : 			_Mylast = _Newvec + _Count;

	shl	edi, 4
	add	edi, ebx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], edi

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebx

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$224303[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n:
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	eax, ebx
	sub	eax, ecx
	sar	eax, 4
	cmp	eax, edi

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	jae	SHORT $LN3@Insert_n
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$224318[ebp], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$224318[ebp+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$224318[ebp+12], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, edi
	shl	eax, 4
	mov	DWORD PTR tv515[ebp], eax
	add	eax, ecx
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$224318[ebp+8], edx
	call	??$_Umove@PAVCvFormationSlotEntry@@@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEPAVCvFormationSlotEntry@@PAV2@00@Z ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Umove<CvFormationSlotEntry *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	edx, eax
	sub	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$224318[ebp]
	push	ecx
	sar	edx, 4
	sub	edi, edx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEPAVCvFormationSlotEntry@@PAV3@IABV3@@Z ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$224318[ebp]
	push	ecx
	sub	esi, eax
	push	esi
	push	edx
	call	??$fill@PAVCvFormationSlotEntry@@V1@@std@@YAXPAVCvFormationSlotEntry@@0ABV1@@Z ; std::fill<CvFormationSlotEntry *,CvFormationSlotEntry>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$224328[ebp], ecx
	mov	ecx, DWORD PTR [eax+8]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	shl	edi, 4
	mov	DWORD PTR __Tmp$224328[ebp+4], edx
	mov	edx, DWORD PTR [eax+12]
	mov	eax, edi
	push	ebx
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	mov	DWORD PTR __Tmp$224328[ebp+8], ecx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __Tmp$224328[ebp+12], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAVCvFormationSlotEntry@@@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEPAVCvFormationSlotEntry@@PAV2@00@Z ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Umove<CvFormationSlotEntry *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAVCvFormationSlotEntry@@PAV1@@stdext@@YAPAVCvFormationSlotEntry@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvFormationSlotEntry *,CvFormationSlotEntry *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$224328[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAVCvFormationSlotEntry@@V1@@std@@YAXPAVCvFormationSlotEntry@@0ABV1@@Z ; std::fill<CvFormationSlotEntry *,CvFormationSlotEntry>
	add	esp, 24					; 00000018H
$LN1@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z ENDP ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Insert_n
PUBLIC	?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z$2
__catchsym$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z$0
__unwindtable$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z
_TEXT	SEGMENT
__Tmp$224633 = -32					; size = 12
__Tmp$224623 = -32					; size = 12
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$243397 = 8					; size = 1
__Cat$243325 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$224608 = 12					; size = 4
__Count$ = 12						; size = 4
tv525 = 16						; size = 4
tv515 = 16						; size = 4
$T243393 = 16						; size = 1
$T243321 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	eax, eax
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@2
$LN29@Insert_n@2:
	mov	edx, DWORD PTR [esi+12]
	sub	edx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, eax
$LN30@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@2

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	edx, ebx
	sub	edx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, 357913941				; 15555555H
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@KAXXZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Xlen
$LN87@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 357913941				; 15555555H
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@UProductionCostModifiers@@@std@@YAPAUProductionCostModifiers@@IPAU1@@Z ; std::_Allocate<ProductionCostModifiers>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[ebp]
	sar	edx, 1
	mov	ebx, edx
	add	esp, 8
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	push	eax
	lea	edx, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	edi
	mov	DWORD PTR __Newvec$224608[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@PAU3@IABU3@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$243325[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T243321[ebp], 0
	mov	ecx, DWORD PTR $T243321[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$224608[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Newvec$224608[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	add	ebx, edi
	lea	ecx, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	BYTE PTR $T243393[ebp], 0
	mov	edx, DWORD PTR $T243393[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$243397[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAUProductionCostModifiers@@PAU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAPAUProductionCostModifiers@@PAU1@00AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<ProductionCostModifiers *,ProductionCostModifiers *,std::allocator<ProductionCostModifiers> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN81@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Newvec$224608[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$224608[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@2:
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	edx, ebx
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	jae	$LN3@Insert_n@2
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$224623[ebp], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$224623[ebp+8], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [edi+edi*2]
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv515[ebp], eax
	add	eax, ecx
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$224623[ebp+4], edx
	call	??$_Umove@PAUProductionCostModifiers@@@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@PAU2@00@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Umove<ProductionCostModifiers *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ebx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR __Tmp$224623[ebp]
	push	ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR __Where$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@PAU3@IABU3@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$224623[ebp]
	push	ecx
	sub	esi, eax
	push	esi
	push	edx
	call	??$fill@PAUProductionCostModifiers@@U1@@std@@YAXPAUProductionCostModifiers@@0ABU1@@Z ; std::fill<ProductionCostModifiers *,ProductionCostModifiers>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [edi+edi*2]
	mov	DWORD PTR __Tmp$224633[ebp+8], eax
	add	edi, edi
	push	ebx
	add	edi, edi
	mov	eax, ebx
	sub	eax, edi
	push	ebx
	mov	DWORD PTR __Tmp$224633[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$224633[ebp+4], edx
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAUProductionCostModifiers@@@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEPAUProductionCostModifiers@@PAU2@00@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Umove<ProductionCostModifiers *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv525[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ebx
	push	ecx
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAUProductionCostModifiers@@PAU1@@stdext@@YAPAUProductionCostModifiers@@PAU1@00@Z ; stdext::_Unchecked_move_backward<ProductionCostModifiers *,ProductionCostModifiers *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$224633[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	edi, eax
	push	edi
	push	eax
	call	??$fill@PAUProductionCostModifiers@@U1@@std@@YAXPAUProductionCostModifiers@@0ABU1@@Z ; std::fill<ProductionCostModifiers *,ProductionCostModifiers>
	add	esp, 24					; 00000018H
$LN1@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Insert_n
PUBLIC	?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z$2
__catchsym$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z
_TEXT	SEGMENT
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$243632 = 8					; size = 1
__Cat$243561 = 8					; size = 1
__Where$ = 8						; size = 4
__Tmp$224706 = 12					; size = 4
__Tmp$224696 = 12					; size = 4
__Newvec$224681 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T243629 = 16						; size = 1
$T243557 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n@3
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@3
$LN29@Insert_n@3:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@3:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@3

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@KAXXZ ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Xlen
$LN87@Insert_n@3:
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@3:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@3:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@W4AnimationPathTypes@@@std@@YAPAW4AnimationPathTypes@@IPAW41@@Z ; std::_Allocate<enum AnimationPathTypes>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	ebx, 2
	push	edi
	lea	edx, DWORD PTR [eax+ebx*4]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$224681[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEPAW4AnimationPathTypes@@PAW43@IABW43@@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$243561[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T243557[ebp], 0
	mov	ecx, DWORD PTR $T243557[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$224681[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T243629[ebp], 0
	mov	edx, DWORD PTR $T243629[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$243632[ebp]
	push	edx
	lea	ecx, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR __Newvec$224681[ebp]
	push	esi
	lea	ecx, DWORD PTR [ebx+ecx*4]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4AnimationPathTypes@@PAW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAPAW4AnimationPathTypes@@PAW41@00AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum AnimationPathTypes *,enum AnimationPathTypes *,std::allocator<enum AnimationPathTypes> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [ebx+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebx

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$224681[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@3:
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, ebx
	sub	ecx, eax
	sar	ecx, 2
	cmp	ecx, edi
	jae	SHORT $LN3@Insert_n@3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$224696[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [edi*4]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAW4AnimationPathTypes@@@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEPAW4AnimationPathTypes@@PAW42@00@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Umove<enum AnimationPathTypes *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$224696[ebp]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEPAW4AnimationPathTypes@@PAW43@IABW43@@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$224696[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAW4AnimationPathTypes@@W41@@std@@YAXPAW4AnimationPathTypes@@0ABW41@@Z ; std::fill<enum AnimationPathTypes *,enum AnimationPathTypes>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@3:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	mov	edi, ebx
	sub	edi, eax
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __Tmp$224706[ebp], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAW4AnimationPathTypes@@@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEPAW4AnimationPathTypes@@PAW42@00@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Umove<enum AnimationPathTypes *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAW4AnimationPathTypes@@PAW41@@stdext@@YAPAW4AnimationPathTypes@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum AnimationPathTypes *,enum AnimationPathTypes *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$224706[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAW4AnimationPathTypes@@W41@@std@@YAXPAW4AnimationPathTypes@@0ABW41@@Z ; std::fill<enum AnimationPathTypes *,enum AnimationPathTypes>
	add	esp, 24					; 00000018H
$LN1@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Insert_n
PUBLIC	??0?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@QAE@ABU01@@Z ; std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@QAE@ABU01@@Z PROC ; std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR [esi], ecx
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
	mov	eax, esi
	pop	esi
	ret	4
??0?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@QAE@ABU01@@Z ENDP ; std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > >
_TEXT	ENDS
PUBLIC	??$_Umove@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_iterator@IV?$allocator@I@std@@@1@0PAI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_iterator@IV?$allocator@I@std@@@1@0PAI@Z
_TEXT	SEGMENT
$T243712 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$243715 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_iterator@IV?$allocator@I@std@@@1@0PAI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$243715[esp]
	mov	BYTE PTR $T243712[esp+4], 0
	mov	eax, DWORD PTR $T243712[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@std@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@0@0PAIAAV?$allocator@I@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@@?$vector@IV?$allocator@I@std@@@std@@IAEPAIV?$_Vector_iterator@IV?$allocator@I@std@@@1@0PAI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> > >
_TEXT	ENDS
PUBLIC	??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z
_TEXT	SEGMENT
$T243764 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$243768 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$243768[esp]
	mov	BYTE PTR $T243764[esp+4], 0
	mov	eax, DWORD PTR $T243764[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>
_TEXT	ENDS
PUBLIC	??1_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node::~_Node
; Function compile flags: /Ogtpy
;	COMDAT ??1_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node::~_Node, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN11@Node
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@Node:
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	pop	esi
	ret	0
??1_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node::~_Node
_TEXT	ENDS
PUBLIC	?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<bool,std::allocator<bool> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T243814 = -8						; size = 8
$T243811 = -8						; size = 8
?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ PROC ; std::vector<bool,std::allocator<bool> >::clear, COMDAT
; _this$ = ecx

; 2243 : 		{	// erase all elements

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 2244 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR [esi+8]
	mov	DWORD PTR $T243811[esp+16], edi
	mov	DWORD PTR $T243811[esp+20], 0
	test	eax, eax
	jbe	SHORT $LN20@clear
	push	eax
	lea	ecx, DWORD PTR $T243811[esp+20]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN20@clear:
	mov	ecx, DWORD PTR $T243811[esp+20]
	mov	edx, DWORD PTR $T243811[esp+16]
	push	ecx
	push	edx
	xor	eax, eax
	push	eax
	push	edi
	lea	eax, DWORD PTR $T243814[esp+32]
	push	eax
	mov	ecx, esi
	call	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
	pop	edi
	pop	esi

; 2245 : 		}

	add	esp, 8
	ret	0
?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::clear
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$215619 = 16					; size = 4
__Tmp$215609 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n@4
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@4
$LN29@Insert_n@4:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@4:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n@4
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@4

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN64@Insert_n@4:
$LN12@Insert_n@4:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n@4

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@4
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n@4
$LN17@Insert_n@4:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n@4:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@4

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n@4:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n@4

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n@4:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n@4:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$215609[esp+16], edx
	jae	SHORT $LN3@Insert_n@4
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215609[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215609[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAII@std@@YAXPAI0ABI@Z		; std::fill<unsigned int *,unsigned int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n@4:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$215619[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAII@std@@YAXPAI0ABI@Z		; std::fill<unsigned int *,unsigned int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n@4:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n@4:
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
_TEXT	ENDS
PUBLIC	?getUnitCombatProductionCostModifiersLocal@CvResourceInfo@@QBE?AV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@W4UnitCombatTypes@@@Z ; CvResourceInfo::getUnitCombatProductionCostModifiersLocal
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
;	COMDAT ?getUnitCombatProductionCostModifiersLocal@CvResourceInfo@@QBE?AV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@W4UnitCombatTypes@@@Z
_TEXT	SEGMENT
$T244030 = -4						; size = 4
_it$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iUnitCombat$ = 12					; size = 4
_eUnitCombat$ = 12					; size = 4
?getUnitCombatProductionCostModifiersLocal@CvResourceInfo@@QBE?AV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@W4UnitCombatTypes@@@Z PROC ; CvResourceInfo::getUnitCombatProductionCostModifiersLocal, COMDAT
; _this$ = ecx

; 4688 : {

	push	ecx
	push	esi
	push	edi
	mov	esi, ecx

; 4689 : 	CvAssertMsg(eUnitCombat < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 4690 : 	CvAssertMsg(eUnitCombat > -1, "Index out of bounds");
; 4691 : 
; 4692 : 	int iUnitCombat = (int)eUnitCombat;
; 4693 : 
; 4694 : 	std::map<int, std::vector<ProductionCostModifiers>>::const_iterator it = m_piiiUnitCombatProductionCostModifiersLocal.find(iUnitCombat);

	lea	ecx, DWORD PTR _iUnitCombat$[esp+8]
	xor	edi, edi
	mov	DWORD PTR $T244030[esp+12], edi
	mov	eax, DWORD PTR _eUnitCombat$[esp+8]
	push	ecx
	lea	edx, DWORD PTR _it$[esp+16]
	push	edx
	lea	ecx, DWORD PTR [esi+532]
	mov	DWORD PTR _iUnitCombat$[esp+16], eax
	call	?find@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::find

; 4695 : 	if (it != m_piiiUnitCombatProductionCostModifiersLocal.end()) // find returns the iterator to map::end if the key iUnitCombat is not present in the map

	mov	eax, DWORD PTR _it$[esp+12]
	cmp	eax, DWORD PTR [esi+536]
	je	SHORT $LN1@getUnitCom@2

; 4696 : 	{
; 4697 : 		return it->second;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, esi
	call	??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
	pop	edi
	mov	eax, esi
	pop	esi

; 4701 : }

	pop	ecx
	ret	8
$LN1@getUnitCom@2:

; 4698 : 	}
; 4699 : 
; 4700 : 	return std::vector<ProductionCostModifiers>();

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	pop	edi
	pop	esi

; 4701 : }

	pop	ecx
	ret	8
?getUnitCombatProductionCostModifiersLocal@CvResourceInfo@@QBE?AV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@W4UnitCombatTypes@@@Z ENDP ; CvResourceInfo::getUnitCombatProductionCostModifiersLocal
_TEXT	ENDS
PUBLIC	?getBuildingProductionCostModifiersLocal@CvResourceInfo@@QBE?AV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@XZ ; CvResourceInfo::getBuildingProductionCostModifiersLocal
; Function compile flags: /Ogtpy
;	COMDAT ?getBuildingProductionCostModifiersLocal@CvResourceInfo@@QBE?AV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@XZ
_TEXT	SEGMENT
$T244207 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getBuildingProductionCostModifiersLocal@CvResourceInfo@@QBE?AV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@XZ PROC ; CvResourceInfo::getBuildingProductionCostModifiersLocal, COMDAT
; _this$ = ecx

; 4744 : {

	push	ecx
	push	esi

; 4745 : 	return m_aiiiBuildingProductionCostModifiersLocal;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	add	ecx, 544				; 00000220H
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T244207[esp+12], 0
	call	??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
	mov	eax, esi
	pop	esi

; 4746 : }

	pop	ecx
	ret	4
?getBuildingProductionCostModifiersLocal@CvResourceInfo@@QBE?AV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@XZ ENDP ; CvResourceInfo::getBuildingProductionCostModifiersLocal
_TEXT	ENDS
PUBLIC	??_7CvEntityEventInfo@@6B@			; CvEntityEventInfo::`vftable'
PUBLIC	??0CvEntityEventInfo@@QAE@XZ			; CvEntityEventInfo::CvEntityEventInfo
PUBLIC	??_R4CvEntityEventInfo@@6B@			; CvEntityEventInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvEntityEventInfo@@@8			; CvEntityEventInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvEntityEventInfo@@8			; CvEntityEventInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvEntityEventInfo@@8			; CvEntityEventInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvEntityEventInfo@@8		; CvEntityEventInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvEntityEventInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvEntityEventInfo::CacheResults
;	COMDAT ??_R1A@?0A@EA@CvEntityEventInfo@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@CvEntityEventInfo@@8 DD FLAT:??_R0?AVCvEntityEventInfo@@@8 ; CvEntityEventInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvEntityEventInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvEntityEventInfo@@8
rdata$r	SEGMENT
??_R2CvEntityEventInfo@@8 DD FLAT:??_R1A@?0A@EA@CvEntityEventInfo@@8 ; CvEntityEventInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvEntityEventInfo@@8
rdata$r	SEGMENT
??_R3CvEntityEventInfo@@8 DD 00H			; CvEntityEventInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvEntityEventInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvEntityEventInfo@@@8
_DATA	SEGMENT
??_R0?AVCvEntityEventInfo@@@8 DD FLAT:??_7type_info@@6B@ ; CvEntityEventInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvEntityEventInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvEntityEventInfo@@6B@
rdata$r	SEGMENT
??_R4CvEntityEventInfo@@6B@ DD 00H			; CvEntityEventInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvEntityEventInfo@@@8
	DD	FLAT:??_R3CvEntityEventInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvEntityEventInfo@@6B@
CONST	SEGMENT
??_7CvEntityEventInfo@@6B@ DD FLAT:??_R4CvEntityEventInfo@@6B@ ; CvEntityEventInfo::`vftable'
	DD	FLAT:?CacheResults@CvEntityEventInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvEntityEventInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvEntityEventInfo@@QAE@XZ$0
__ehfuncinfo$??0CvEntityEventInfo@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvEntityEventInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvEntityEventInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvEntityEventInfo@@QAE@XZ PROC			; CvEntityEventInfo::CvEntityEventInfo, COMDAT
; _this$ = ecx

; 6473 : {

	push	-1
	push	__ehhandler$??0CvEntityEventInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo

; 6474 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR [esi], OFFSET ??_7CvEntityEventInfo@@6B@
	xor	eax, eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi+272], eax
	mov	BYTE PTR [esi+276], 1
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvEntityEventInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??0CvEntityEventInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvEntityEventInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvEntityEventInfo@@QAE@XZ ENDP			; CvEntityEventInfo::CvEntityEventInfo
PUBLIC	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 559  : 		_Tidy();

	jmp	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXXZ ; std::vector<CvString,std::allocator<CvString> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T244370 = -4						; size = 4
?clear@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXXZ PROC ; std::vector<CvString,std::allocator<CvString> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T244370[esp+12]
	push	eax
	call	?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ; std::vector<CvString,std::allocator<CvString> >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::clear
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@V?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@ABVCvFormationSlotEntry@@@Z ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@V?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@ABVCvFormationSlotEntry@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@V?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@ABVCvFormationSlotEntry@@@Z PROC ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -16				; fffffff0H
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 4
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	shl	esi, 4
	add	esi, DWORD PTR [edi+4]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@V?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@ABVCvFormationSlotEntry@@@Z ENDP ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::insert
_TEXT	ENDS
PUBLIC	?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::reserve
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$224000 = -24					; size = 4
$T244597 = -20						; size = 1
__$EHRec$ = -16						; size = 16
__Cat$244600 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH

; 603  : 		if (max_size() < _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	cmp	edx, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@reserve

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
$LN57@reserve:
$LN5@reserve:

; 605  : 		else if (capacity() < _Count)

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LN20@reserve
	xor	eax, eax
	jmp	SHORT $LN21@reserve
$LN20@reserve:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN21@reserve:
	cmp	eax, edx
	jae	SHORT $LN3@reserve

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	push	0
	push	edx
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>

; 608  : 
; 609  : 			_TRY_BEGIN
; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR $T244597[ebp], 0
	mov	edx, DWORD PTR $T244597[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$244600[ebp]
	push	edx
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+8]
	push	esi
	push	ebx
	push	eax
	push	ecx
	mov	DWORD PTR __Ptr$224000[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_iterator@IV?$allocator@I@std@@@std@@PAIV?$allocator@I@2@@std@@YAPAIV?$_Vector_iterator@IV?$allocator@I@std@@@0@0PAIAAV?$allocator@I@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >,unsigned int *,std::allocator<unsigned int> >

; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi+8]
	sub	edi, eax
	add	esp, 32					; 00000020H
	sar	edi, 2

; 617  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN52@reserve

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);
; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN52@reserve:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [ebx+eax*4]

; 628  : 			_Mylast = _Ptr + _Size;

	lea	edx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+8], edx

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+4], ebx
$LN3@reserve:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Ptr$224000[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN58@reserve:
$LN56@reserve:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::reserve
PUBLIC	?insert@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@ABUProductionCostModifiers@@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@ABUProductionCostModifiers@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@ABUProductionCostModifiers@@@Z PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@2
	xor	esi, esi
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@2:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@IAEXV?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@IABUProductionCostModifiers@@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi+esi*2]
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@ABUProductionCostModifiers@@@Z ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@V?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@ABW4AnimationPathTypes@@@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@V?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@ABW4AnimationPathTypes@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@V?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@ABW4AnimationPathTypes@@@Z PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@3
	xor	esi, esi
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@3:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@V?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@ABW4AnimationPathTypes@@@Z ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::insert
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::_Insert_n
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$10
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$11
__unwindtable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
_TEXT	SEGMENT
__Tmp$224385 = -92					; size = 28
__Tmp$224375 = -64					; size = 28
__Whereoff$224361 = -36					; size = 4
_this$ = -32						; size = 4
__Ncopied$224362 = -28					; size = 4
__Newvec$224360 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$244955 = 8					; size = 1
__Cat$244883 = 8					; size = 1
__Where$ = 8						; size = 4
tv525 = 12						; size = 4
__Count$ = 12						; size = 4
$T244951 = 16						; size = 1
$T244879 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	test	eax, eax
	jne	SHORT $LN31@Insert_n@5
	mov	DWORD PTR __Capacity$[ebp], eax
	jmp	SHORT $LN32@Insert_n@5
$LN31@Insert_n@5:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Capacity$[ebp], eax
$LN32@Insert_n@5:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@5

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	ecx, ebx
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, 153391689				; 09249249H
	sub	ecx, eax
	cmp	ecx, edi
	jae	SHORT $LN12@Insert_n@5

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
$LN103@Insert_n@5:
$LN12@Insert_n@5:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	add	eax, edi
	cmp	ecx, eax
	jae	$LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	edx, ecx
	shr	edx, 1
	mov	ebx, 153391689				; 09249249H
	sub	ebx, edx
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@5
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
	add	ecx, edx
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@5:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, eax
	jae	SHORT $LN9@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], eax
	mov	ecx, eax
$LN9@Insert_n@5:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ebx
	add	edx, ebx
	sar	edx, 4
	mov	ebx, edx

; 1175 : 			int _Ncopied = 0;

	xor	eax, eax
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	add	esp, 8
	mov	DWORD PTR __Ncopied$224362[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], eax
	push	edx
	lea	eax, DWORD PTR [ebx*8]
	mov	DWORD PTR __Newvec$224360[ebp], ecx
	sub	eax, ebx
	lea	ecx, DWORD PTR [ecx+eax*4]
	push	edi
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Whereoff$224361[ebp], ebx
	call	?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ; std::vector<CvString,std::allocator<CvString> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Cat$244883[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T244879[ebp], 0
	mov	edx, DWORD PTR $T244879[ebp]
	push	edx
	mov	edx, DWORD PTR __Newvec$224360[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Where$[ebp]
	push	esi
	push	edx
	push	ecx
	push	eax
	mov	DWORD PTR __Ncopied$224362[ebp], 1
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Newvec$224360[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	ebx, edi
	add	esp, 24					; 00000018H
	lea	edx, DWORD PTR [ebx*8]
	sub	edx, ebx
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	BYTE PTR $T244951[ebp], 0
	mov	edx, DWORD PTR $T244951[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$244955[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	DWORD PTR __Ncopied$224362[ebp], 2
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN83@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR [esi+8]
	push	edx
	push	ebx
	mov	ecx, esi
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN83@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR __Newvec$224360[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	mov	DWORD PTR [esi+12], edx
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+8], edx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	mov	ebx, DWORD PTR __Ncopied$224362[ebp]
	cmp	ebx, 1

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	esi, DWORD PTR __Whereoff$224361[ebp]
	mov	edi, DWORD PTR __Newvec$224360[ebp]
	jle	SHORT $LN7@Insert_n@5
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	ecx, DWORD PTR [edi+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	push	edi
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy
$LN7@Insert_n@5:

; 1188 : 			if (0 < _Ncopied)

	test	ebx, ebx
	jle	SHORT $LN6@Insert_n@5

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [esi+edx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edx, DWORD PTR [edi+ecx*4]
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	ecx, DWORD PTR [edi+eax*4]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy
$LN6@Insert_n@5:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN104@Insert_n@5:
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	sub	ebx, DWORD PTR __Where$[ebp]
	mov	eax, -1840700269			; 92492493H
	imul	ebx
	add	edx, ebx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi
	jae	$LN3@Insert_n@5

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$224375[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [esi+8]
	lea	ebx, DWORD PTR [edi*8]
	sub	ebx, edi
	add	ebx, ebx
	add	ebx, ebx
	lea	edx, DWORD PTR [ebx+eax]
	push	edx
	push	ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$224375[ebp]
	push	edx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	mov	eax, DWORD PTR [esi+8]
	push	edi
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ; std::vector<CvString,std::allocator<CvString> >::_Ufill

; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebx
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$224375[ebp]
	push	ecx
	sub	esi, ebx
	push	esi
	push	edx
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::fill<CvString *,CvString>
	add	esp, 12					; 0000000cH

; 1232 : 			}

	lea	ecx, DWORD PTR __Tmp$224375[ebp]

; 1233 : 		else

	jmp	$LN102@Insert_n@5
__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	eax, eax
	add	eax, eax
	add	edx, eax
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	add	eax, edx
	push	eax
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN105@Insert_n@5:
$LN3@Insert_n@5:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$224385[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR [esi+8]

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	ebx, DWORD PTR [edi*8]
	sub	ebx, edi
	add	ebx, ebx
	push	eax
	mov	edi, eax
	add	ebx, ebx
	push	eax
	sub	edi, ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv525[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ecx
	push	edi
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvString *,CvString *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$224385[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	ebx, eax
	push	ebx
	push	eax
	call	??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::fill<CvString *,CvString>
	add	esp, 24					; 00000018H

; 1249 : 			}

	lea	ecx, DWORD PTR __Tmp$224385[ebp]
$LN102@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@Insert_n@5:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN101@Insert_n@5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$224375[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$5:
	lea	ecx, DWORD PTR __Tmp$224385[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Insert_n
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	eax, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Rarg$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR __Parg$[esp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Val$[esp]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], edx
	mov	ecx, DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR [esi+12], ecx
	push	eax
	lea	ecx, DWORD PTR [esi+16]
	call	??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
	mov	dl, BYTE PTR __Carg$[esp]
	mov	BYTE PTR [esi+32], dl
	mov	BYTE PTR [esi+33], 0

; 39   : 			}

	mov	eax, esi
	pop	esi
	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	??_G_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_G_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN13@scalar@22
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@22:
	test	BYTE PTR ___flags$[esp], 1
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	je	SHORT $LN15@scalar@22
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@scalar@22:
	mov	eax, esi
	pop	esi
	ret	4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEPAXI@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z
_TEXT	SEGMENT
$T245069 = 8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::resize, COMDAT
; _this$ = ecx

; 718  : 		if (size() < _Newsize)

	mov	edx, DWORD PTR __Newsize$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	mov	eax, esi
	sub	eax, edi
	sar	eax, 2
	cmp	edx, eax
	jbe	SHORT $LN36@resize

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	edi, DWORD PTR __Val$[esp+4]
	push	edi
	sub	edx, eax
	push	edx
	push	esi
	call	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
	pop	edi
	pop	esi

; 722  : 		}

	ret	8
$LN36@resize:

; 720  : 		else if (_Newsize < size())

	jae	SHORT $LN1@resize

; 721  : 			erase(begin() + _Newsize, end());

	lea	eax, DWORD PTR [edi+edx*4]
	push	esi
	push	eax
	lea	eax, DWORD PTR $T245069[esp+12]
	push	eax
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
$LN1@resize:
	pop	edi
	pop	esi

; 722  : 		}

	ret	8
?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::resize
_TEXT	ENDS
PUBLIC	??_7CvCivilizationInfo@@6B@			; CvCivilizationInfo::`vftable'
PUBLIC	??0CvCivilizationInfo@@QAE@XZ			; CvCivilizationInfo::CvCivilizationInfo
PUBLIC	??_R4CvCivilizationInfo@@6B@			; CvCivilizationInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvCivilizationInfo@@@8			; CvCivilizationInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvCivilizationInfo@@8			; CvCivilizationInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvCivilizationInfo@@8			; CvCivilizationInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvCivilizationInfo@@8		; CvCivilizationInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvCivilizationInfo::CacheResults
EXTRN	??_ECvCivilizationInfo@@UAEPAXI@Z:PROC		; CvCivilizationInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvCivilizationInfo@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@CvCivilizationInfo@@8 DD FLAT:??_R0?AVCvCivilizationInfo@@@8 ; CvCivilizationInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvCivilizationInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvCivilizationInfo@@8
rdata$r	SEGMENT
??_R2CvCivilizationInfo@@8 DD FLAT:??_R1A@?0A@EA@CvCivilizationInfo@@8 ; CvCivilizationInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvCivilizationBaseInfo@@8
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvCivilizationInfo@@8
rdata$r	SEGMENT
??_R3CvCivilizationInfo@@8 DD 00H			; CvCivilizationInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvCivilizationInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvCivilizationInfo@@@8
_DATA	SEGMENT
??_R0?AVCvCivilizationInfo@@@8 DD FLAT:??_7type_info@@6B@ ; CvCivilizationInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvCivilizationInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvCivilizationInfo@@6B@
rdata$r	SEGMENT
??_R4CvCivilizationInfo@@6B@ DD 00H			; CvCivilizationInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvCivilizationInfo@@@8
	DD	FLAT:??_R3CvCivilizationInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvCivilizationInfo@@6B@
CONST	SEGMENT
??_7CvCivilizationInfo@@6B@ DD FLAT:??_R4CvCivilizationInfo@@6B@ ; CvCivilizationInfo::`vftable'
	DD	FLAT:?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvCivilizationInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CvCivilizationInfo@@QAE@XZ DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$??0CvCivilizationInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvCivilizationInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$10
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvCivilizationInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvCivilizationInfo@@QAE@XZ PROC			; CvCivilizationInfo::CvCivilizationInfo, COMDAT
; _this$ = ecx

; 1993 : {

	push	-1
	push	__ehhandler$??0CvCivilizationInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	??0CvCivilizationBaseInfo@@QAE@XZ	; CvCivilizationBaseInfo::CvCivilizationBaseInfo
	or	eax, -1
	xor	ebx, ebx
	lea	ecx, DWORD PTR [esi+348]
	mov	DWORD PTR __$EHRec$[esp+32], ebx
	mov	DWORD PTR [esi], OFFSET ??_7CvCivilizationInfo@@6B@
	mov	DWORD PTR [esi+336], eax
	mov	DWORD PTR [esi+340], eax
	mov	DWORD PTR [esi+344], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+376]
	mov	BYTE PTR __$EHRec$[esp+32], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+404]
	mov	BYTE PTR __$EHRec$[esp+32], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+432]
	mov	BYTE PTR __$EHRec$[esp+32], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+460]
	mov	BYTE PTR __$EHRec$[esp+32], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+488]
	mov	BYTE PTR __$EHRec$[esp+32], 5
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+516]
	mov	BYTE PTR __$EHRec$[esp+32], 6
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR [esi+544], ebx
	mov	DWORD PTR [esi+548], ebx
	mov	DWORD PTR [esi+552], ebx
	mov	DWORD PTR [esi+556], ebx
	mov	DWORD PTR [esi+560], ebx
	mov	DWORD PTR [esi+564], ebx
	mov	DWORD PTR [esi+568], ebx
	mov	DWORD PTR [esi+572], ebx
	mov	DWORD PTR [esi+576], ebx
	mov	BYTE PTR [esi+580], bl
	mov	BYTE PTR [esi+581], bl
	mov	DWORD PTR [esi+588], ebx
	mov	DWORD PTR [esi+592], ebx
	mov	DWORD PTR [esi+596], ebx
	mov	DWORD PTR [esi+604], ebx
	mov	DWORD PTR [esi+608], ebx
	mov	DWORD PTR [esi+612], ebx
	mov	DWORD PTR [esi+616], ebx
	mov	DWORD PTR [esi+624], ebx
	mov	DWORD PTR [esi+628], ebx
	mov	DWORD PTR [esi+632], ebx

; 1994 : 
; 1995 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+636], ebx
	mov	DWORD PTR [esi+644], ebx
	mov	DWORD PTR [esi+648], ebx
	mov	DWORD PTR [esi+652], ebx
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvCivilizationBaseInfo@@UAE@XZ	; CvCivilizationBaseInfo::~CvCivilizationBaseInfo
__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 348				; 0000015cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 376				; 00000178H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 432				; 000001b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 460				; 000001ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 584				; 00000248H
	jmp	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 600				; 00000258H
	jmp	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
__unwindfunclet$??0CvCivilizationInfo@@QAE@XZ$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 616				; 00000268H
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__ehhandler$??0CvCivilizationInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvCivilizationInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvCivilizationInfo@@QAE@XZ ENDP			; CvCivilizationInfo::CvCivilizationInfo
PUBLIC	??1CvCivilizationInfo@@UAE@XZ			; CvCivilizationInfo::~CvCivilizationInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$??1CvCivilizationInfo@@UAE@XZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??1CvCivilizationInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvCivilizationInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$8
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??1CvCivilizationInfo@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvCivilizationInfo@@UAE@XZ PROC			; CvCivilizationInfo::~CvCivilizationInfo, COMDAT
; _this$ = ecx

; 1998 : {

	push	-1
	push	__ehhandler$??1CvCivilizationInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvCivilizationInfo@@6B@

; 1999 : 	SAFE_DELETE_ARRAY(m_piCivilizationBuildings);

	mov	eax, DWORD PTR [esi+544]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], 8
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+544], ebx

; 2000 : 	SAFE_DELETE_ARRAY(m_piCivilizationUnits);

	mov	eax, DWORD PTR [esi+548]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+548], ebx

; 2001 : 	SAFE_DELETE_ARRAY(m_piCivilizationFreeUnitsClass);

	mov	eax, DWORD PTR [esi+552]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+552], ebx

; 2002 : 	SAFE_DELETE_ARRAY(m_piCivilizationFreeUnitsDefaultUnitAI);

	mov	eax, DWORD PTR [esi+556]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+556], ebx

; 2003 : 	SAFE_DELETE_ARRAY(m_pbLeaders);

	mov	eax, DWORD PTR [esi+560]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+560], ebx

; 2004 : 	SAFE_DELETE_ARRAY(m_pbCivilizationFreeBuildingClass);

	mov	eax, DWORD PTR [esi+564]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+564], ebx

; 2005 : 	SAFE_DELETE_ARRAY(m_pbCivilizationFreeTechs);

	mov	eax, DWORD PTR [esi+568]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+568], ebx

; 2006 : 	SAFE_DELETE_ARRAY(m_pbCivilizationDisableTechs);

	mov	eax, DWORD PTR [esi+572]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+572], ebx

; 2007 : 	SAFE_DELETE_ARRAY(m_pbReligions);

	mov	eax, DWORD PTR [esi+576]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+576], ebx

; 2008 : }

	mov	DWORD PTR [esi+636], ebx
	mov	eax, DWORD PTR [esi+644]
	add	esp, 36					; 00000024H
	cmp	eax, ebx
	je	SHORT $LN40@CvCiviliza
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN40@CvCiviliza:
	mov	DWORD PTR [esi+644], ebx
	mov	DWORD PTR [esi+648], ebx
	mov	DWORD PTR [esi+652], ebx
	mov	DWORD PTR [esi+616], ebx
	mov	eax, DWORD PTR [esi+624]
	cmp	eax, ebx
	je	SHORT $LN51@CvCiviliza
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN51@CvCiviliza:
	lea	ecx, DWORD PTR [esi+600]
	mov	DWORD PTR [esi+624], ebx
	mov	DWORD PTR [esi+628], ebx
	mov	DWORD PTR [esi+632], ebx
	call	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
	lea	ecx, DWORD PTR [esi+584]
	mov	BYTE PTR __$EHRec$[esp+32], 7
	call	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
	lea	ecx, DWORD PTR [esi+516]
	mov	BYTE PTR __$EHRec$[esp+32], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+488]
	mov	BYTE PTR __$EHRec$[esp+32], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+460]
	mov	BYTE PTR __$EHRec$[esp+32], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+432]
	mov	BYTE PTR __$EHRec$[esp+32], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+404]
	mov	BYTE PTR __$EHRec$[esp+32], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+376]
	mov	BYTE PTR __$EHRec$[esp+32], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+348]
	mov	BYTE PTR __$EHRec$[esp+32], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1CvCivilizationBaseInfo@@UAE@XZ	; CvCivilizationBaseInfo::~CvCivilizationBaseInfo
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvCivilizationBaseInfo@@UAE@XZ	; CvCivilizationBaseInfo::~CvCivilizationBaseInfo
__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 348				; 0000015cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 376				; 00000178H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 432				; 000001b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 460				; 000001ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvCivilizationInfo@@UAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 584				; 00000248H
	jmp	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
__ehhandler$??1CvCivilizationInfo@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvCivilizationInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvCivilizationInfo@@UAE@XZ ENDP			; CvCivilizationInfo::~CvCivilizationInfo
PUBLIC	??_7CvEraInfo@@6B@				; CvEraInfo::`vftable'
PUBLIC	??0CvEraInfo@@QAE@XZ				; CvEraInfo::CvEraInfo
PUBLIC	??_R4CvEraInfo@@6B@				; CvEraInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvEraInfo@@@8				; CvEraInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvEraInfo@@8				; CvEraInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvEraInfo@@8				; CvEraInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvEraInfo@@8			; CvEraInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvEraInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvEraInfo::CacheResults
EXTRN	??_ECvEraInfo@@UAEPAXI@Z:PROC			; CvEraInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvEraInfo@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@CvEraInfo@@8 DD FLAT:??_R0?AVCvEraInfo@@@8 ; CvEraInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvEraInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvEraInfo@@8
rdata$r	SEGMENT
??_R2CvEraInfo@@8 DD FLAT:??_R1A@?0A@EA@CvEraInfo@@8	; CvEraInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvEraInfo@@8
rdata$r	SEGMENT
??_R3CvEraInfo@@8 DD 00H				; CvEraInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvEraInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvEraInfo@@@8
_DATA	SEGMENT
??_R0?AVCvEraInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvEraInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvEraInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvEraInfo@@6B@
rdata$r	SEGMENT
??_R4CvEraInfo@@6B@ DD 00H				; CvEraInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvEraInfo@@@8
	DD	FLAT:??_R3CvEraInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvEraInfo@@6B@
CONST	SEGMENT
??_7CvEraInfo@@6B@ DD FLAT:??_R4CvEraInfo@@6B@		; CvEraInfo::`vftable'
	DD	FLAT:?CacheResults@CvEraInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvEraInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CvEraInfo@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0CvEraInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvEraInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvEraInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvEraInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvEraInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvEraInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvEraInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvEraInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvEraInfo@@QAE@XZ$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvEraInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvEraInfo@@QAE@XZ PROC				; CvEraInfo::CvEraInfo, COMDAT
; _this$ = ecx

; 6562 : {

	push	-1
	push	__ehhandler$??0CvEraInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	ebx, ebx
	lea	ecx, DWORD PTR [esi+380]
	mov	DWORD PTR __$EHRec$[esp+32], ebx
	mov	DWORD PTR [esi], OFFSET ??_7CvEraInfo@@6B@
	mov	DWORD PTR [esi+260], ebx
	mov	DWORD PTR [esi+264], ebx
	mov	DWORD PTR [esi+268], ebx
	mov	DWORD PTR [esi+272], ebx
	mov	DWORD PTR [esi+276], ebx
	mov	DWORD PTR [esi+280], ebx
	mov	DWORD PTR [esi+284], ebx
	mov	DWORD PTR [esi+288], ebx
	mov	DWORD PTR [esi+292], ebx
	mov	DWORD PTR [esi+296], ebx
	mov	DWORD PTR [esi+300], ebx
	mov	DWORD PTR [esi+304], ebx
	mov	DWORD PTR [esi+308], ebx
	mov	DWORD PTR [esi+312], ebx
	mov	DWORD PTR [esi+316], ebx
	mov	DWORD PTR [esi+320], ebx
	mov	DWORD PTR [esi+324], ebx
	mov	DWORD PTR [esi+328], ebx
	mov	DWORD PTR [esi+332], ebx
	mov	DWORD PTR [esi+336], ebx
	mov	DWORD PTR [esi+340], ebx
	mov	DWORD PTR [esi+344], ebx
	mov	DWORD PTR [esi+348], ebx
	mov	DWORD PTR [esi+352], ebx
	mov	DWORD PTR [esi+356], ebx
	mov	DWORD PTR [esi+360], ebx
	mov	DWORD PTR [esi+364], ebx
	mov	DWORD PTR [esi+368], ebx
	mov	DWORD PTR [esi+372], ebx
	mov	DWORD PTR [esi+376], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+408]
	mov	BYTE PTR __$EHRec$[esp+32], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+436]
	mov	BYTE PTR __$EHRec$[esp+32], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+464]
	mov	BYTE PTR __$EHRec$[esp+32], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+492]
	mov	BYTE PTR __$EHRec$[esp+32], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+520]
	mov	BYTE PTR __$EHRec$[esp+32], 5
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6563 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+548], ebx
	mov	BYTE PTR [esi+552], bl
	mov	BYTE PTR [esi+553], bl
	mov	BYTE PTR [esi+554], bl
	mov	DWORD PTR [esi+560], ebx
	mov	DWORD PTR [esi+564], ebx
	mov	DWORD PTR [esi+568], ebx
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvEraInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvEraInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 380				; 0000017cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvEraInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 408				; 00000198H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvEraInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 436				; 000001b4H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvEraInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvEraInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 492				; 000001ecH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvEraInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 520				; 00000208H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvEraInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvEraInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvEraInfo@@QAE@XZ ENDP				; CvEraInfo::CvEraInfo
PUBLIC	??1CvEraInfo@@UAE@XZ				; CvEraInfo::~CvEraInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$??1CvEraInfo@@UAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??1CvEraInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvEraInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvEraInfo@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvEraInfo@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvEraInfo@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvEraInfo@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvEraInfo@@UAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvEraInfo@@UAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvEraInfo@@UAE@XZ$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??1CvEraInfo@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvEraInfo@@UAE@XZ PROC				; CvEraInfo::~CvEraInfo, COMDAT
; _this$ = ecx

; 6566 : {

	push	-1
	push	__ehhandler$??1CvEraInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvEraInfo@@6B@

; 6567 : }

	lea	ecx, DWORD PTR [esi+556]
	mov	DWORD PTR __$EHRec$[esp+28], 6
	call	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
	lea	ecx, DWORD PTR [esi+520]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+492]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+464]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+436]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+408]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+380]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvEraInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvEraInfo@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 380				; 0000017cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvEraInfo@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 408				; 00000198H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvEraInfo@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 436				; 000001b4H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvEraInfo@@UAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvEraInfo@@UAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 492				; 000001ecH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvEraInfo@@UAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 520				; 00000208H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvEraInfo@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvEraInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvEraInfo@@UAE@XZ ENDP				; CvEraInfo::~CvEraInfo
PUBLIC	?push_back@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAEXABVCvFormationSlotEntry@@@Z ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAEXABVCvFormationSlotEntry@@@Z
_TEXT	SEGMENT
$T246328 = -4						; size = 1
__Cat$246332 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAEXABVCvFormationSlotEntry@@@Z PROC ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back
	xor	eax, eax
	jmp	SHORT $LN10@push_back
$LN9@push_back:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 4
$LN10@push_back:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 4
	cmp	edx, eax
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$246332[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T246328[esp+12], 0
	mov	eax, DWORD PTR $T246328[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAVCvFormationSlotEntry@@IV1@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@YAXPAVCvFormationSlotEntry@@IABV1@AAV?$allocator@VCvFormationSlotEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvFormationSlotEntry *,unsigned int,CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >
	add	esp, 24					; 00000018H
	add	edi, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@2@IABVCvFormationSlotEntry@@@Z ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAEXABVCvFormationSlotEntry@@@Z ENDP ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::push_back
_TEXT	ENDS
PUBLIC	?reserve@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<bool,std::allocator<bool> >::reserve
; Function compile flags: /Ogtpy
;	COMDAT ?reserve@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z PROC ; std::vector<bool,std::allocator<bool> >::reserve, COMDAT
; _this$ = ecx

; 1963 : 		_Myvec.reserve(_Nw(_Count));

	mov	eax, DWORD PTR __Count$[esp-4]
	add	eax, 31					; 0000001fH
	shr	eax, 5
	mov	DWORD PTR __Count$[esp-4], eax
	add	ecx, 4
	jmp	?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::reserve
?reserve@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ENDP ; std::vector<bool,std::allocator<bool> >::reserve
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEXABUProductionCostModifiers@@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEXABUProductionCostModifiers@@@Z
_TEXT	SEGMENT
$T246484 = -4						; size = 1
__Cat$246488 = 8					; size = 1
$T246454 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEXABUProductionCostModifiers@@@Z PROC ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back@2
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back@2
$LN9@push_back@2:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back@2:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$246488[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T246484[esp+16], 0
	mov	ecx, DWORD PTR $T246484[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUProductionCostModifiers@@IU1@V?$allocator@UProductionCostModifiers@@@std@@@std@@YAXPAUProductionCostModifiers@@IABU1@AAV?$allocator@UProductionCostModifiers@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<ProductionCostModifiers *,unsigned int,ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
	add	esp, 24					; 00000018H
	add	edi, 12					; 0000000cH
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@2:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T246454[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@ABUProductionCostModifiers@@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEXABUProductionCostModifiers@@@Z ENDP ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAEXABW4AnimationPathTypes@@@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAEXABW4AnimationPathTypes@@@Z
_TEXT	SEGMENT
$T246542 = -4						; size = 1
__Cat$246546 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAEXABW4AnimationPathTypes@@@Z PROC ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@3
	xor	eax, eax
	jmp	SHORT $LN10@push_back@3
$LN9@push_back@3:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN10@push_back@3:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN2@push_back@3

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$246546[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T246542[esp+12], 0
	mov	eax, DWORD PTR $T246542[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAW4AnimationPathTypes@@IW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@IABW41@AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum AnimationPathTypes *,unsigned int,enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
	add	esp, 24					; 00000018H
	add	edi, 4
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@3:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@QAEXABW4AnimationPathTypes@@@Z ENDP ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::push_back
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@4
	xor	esi, esi
	jmp	SHORT $LN4@insert@4
$LN3@insert@4:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@4:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi*8]
	sub	edx, esi
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::insert
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Buynode
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z$5
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z
_TEXT	SEGMENT
$T246720 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR __Wherenode$[ebp], esi

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	DWORD PTR $T246720[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	test	esi, esi
	je	SHORT $LN4@Buynode@2
	mov	eax, DWORD PTR __Larg$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	edx, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], edx
	mov	ecx, DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR [esi+12], ecx
	push	eax
	lea	ecx, DWORD PTR [esi+16]
	call	??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [esi+32], dl
	mov	BYTE PTR [esi+33], 0
$LN4@Buynode@2:

; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN35@Buynode@2:
$LN34@Buynode@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246720[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Buynode
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	esi

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN15@Destroy@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@Destroy@2:
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	pop	esi

; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>
_TEXT	ENDS
PUBLIC	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z
_TEXT	SEGMENT
$T246848 = -32						; size = 8
__Oldend$215544 = -24					; size = 8
$T246851 = -16						; size = 8
$T246849 = -16						; size = 8
$T246850 = -8						; size = 8
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_x, COMDAT
; _this$ = ecx

; 2296 : 		{	// make room to insert _Count elements at _Where

	sub	esp, 32					; 00000020H
	push	ebx

; 2297 : 		size_type _Off = _Where - begin();
; 2298 : 
; 2299 :  #if _HAS_ITERATOR_DEBUGGING
; 2300 : 		if (end() < _Where)
; 2301 : 			_DEBUG_ERROR("vector<bool> insert iterator outside range");
; 2302 : 		bool _Realloc = capacity() - size() < _Count;
; 2303 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2304 : 
; 2305 : 		if (_Count == 0)

	mov	ebx, DWORD PTR __Count$[esp+32]
	push	ebp
	mov	ebp, DWORD PTR __Where$[esp+36]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	sub	ebp, eax
	sar	ebp, 2
	shl	ebp, 5
	add	ebp, DWORD PTR __Where$[esp+44]
	test	ebx, ebx
	je	$LN1@Insert_x

; 2306 : 			;
; 2307 : 		else if (max_size() - size() < _Count)

	mov	eax, DWORD PTR [esi]
	or	ecx, -1
	sub	ecx, eax
	cmp	ecx, ebx
	jae	SHORT $LN4@Insert_x

; 2308 : 			_Xlen();	// result too long

	mov	ecx, esi
	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
$LN97@Insert_x:
$LN4@Insert_x:
	push	edi

; 2309 : 		else
; 2310 : 			{	// worth doing
; 2311 : 			_Myvec.resize(_Nw(size() + _Count), 0);

	lea	edx, DWORD PTR [eax+ebx+31]
	push	0
	shr	edx, 5
	push	edx
	lea	ecx, DWORD PTR [esi+4]
	call	?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize

; 2312 : 			if (size() == 0)

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	jne	SHORT $LN2@Insert_x
	pop	edi

; 2313 : 				_Mysize += _Count;

	mov	DWORD PTR [esi], ebx
	pop	esi

; 2319 : 				}
; 2320 : 
; 2321 :  #if _HAS_ITERATOR_DEBUGGING
; 2322 : 			_Orphan_range(_Realloc ? 0 : _Off, _Mysize);
; 2323 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2324 : 
; 2325 : 			}
; 2326 : 		return (_Off);

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2327 : 		}

	add	esp, 32					; 00000020H
	ret	12					; 0000000cH
$LN2@Insert_x:

; 2314 : 			else
; 2315 : 				{	// make room and copy down suffix
; 2316 : 				iterator _Oldend = end();

	mov	ebx, DWORD PTR [esi+8]
	mov	DWORD PTR __Oldend$215544[esp+48], ebx
	mov	DWORD PTR __Oldend$215544[esp+52], 0
	test	edi, edi
	jbe	SHORT $LN60@Insert_x
	push	edi
	lea	ecx, DWORD PTR __Oldend$215544[esp+52]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN60@Insert_x:

; 2317 : 				_Mysize += _Count;

	mov	eax, DWORD PTR __Count$[esp+44]
	add	eax, edi
	mov	DWORD PTR [esi], eax

; 2318 : 				std::copy_backward(begin() + _Off, _Oldend, end());

	mov	DWORD PTR $T246848[esp+48], ebx
	mov	DWORD PTR $T246848[esp+52], 0
	je	SHORT $LN79@Insert_x
	push	eax
	lea	ecx, DWORD PTR $T246848[esp+52]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN79@Insert_x:
	push	ebp
	lea	ecx, DWORD PTR $T246850[esp+52]
	push	ecx
	lea	ecx, DWORD PTR $T246849[esp+56]
	mov	DWORD PTR $T246849[esp+56], ebx
	mov	DWORD PTR $T246849[esp+60], 0
	call	??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
	mov	edx, DWORD PTR $T246848[esp+52]
	mov	ecx, DWORD PTR $T246848[esp+48]
	push	edx
	mov	edx, DWORD PTR __Oldend$215544[esp+56]
	push	ecx
	mov	ecx, DWORD PTR __Oldend$215544[esp+56]
	push	edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T246851[esp+72]
	push	ecx
	call	??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
	add	esp, 28					; 0000001cH
	pop	edi
$LN1@Insert_x:
	pop	esi

; 2319 : 				}
; 2320 : 
; 2321 :  #if _HAS_ITERATOR_DEBUGGING
; 2322 : 			_Orphan_range(_Realloc ? 0 : _Off, _Mysize);
; 2323 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2324 : 
; 2325 : 			}
; 2326 : 		return (_Off);

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 2327 : 		}

	add	esp, 32					; 00000020H
	ret	12					; 0000000cH
$LN96@Insert_x:
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_x
_TEXT	ENDS
PUBLIC	?addFormationSlotEntry@CvMultiUnitFormationInfo@@QAEXABVCvFormationSlotEntry@@@Z ; CvMultiUnitFormationInfo::addFormationSlotEntry
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
;	COMDAT ?addFormationSlotEntry@CvMultiUnitFormationInfo@@QAEXABVCvFormationSlotEntry@@@Z
_TEXT	SEGMENT
_slotEntry$ = 8						; size = 4
?addFormationSlotEntry@CvMultiUnitFormationInfo@@QAEXABVCvFormationSlotEntry@@@Z PROC ; CvMultiUnitFormationInfo::addFormationSlotEntry, COMDAT
; _this$ = ecx

; 1554 : 	m_vctSlotEntries.push_back(slotEntry);

	add	ecx, 288				; 00000120H
	jmp	?push_back@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAEXABVCvFormationSlotEntry@@@Z ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::push_back
?addFormationSlotEntry@CvMultiUnitFormationInfo@@QAEXABVCvFormationSlotEntry@@@Z ENDP ; CvMultiUnitFormationInfo::addFormationSlotEntry
_TEXT	ENDS
PUBLIC	?CacheResults@CvMultiUnitFormationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvMultiUnitFormationInfo::CacheResults
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvMultiUnitFormationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvMultiUnitFormationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
__ehfuncinfo$?CacheResults@CvMultiUnitFormationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CacheResults@CvMultiUnitFormationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvMultiUnitFormationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_slotEntry$219676 = -92					; size = 16
_kSlotEntries$219669 = -76				; size = 64
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvMultiUnitFormationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvMultiUnitFormationInfo::CacheResults, COMDAT
; _this$ = ecx

; 1558 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvMultiUnitFormationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax

; 1559 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+96]
	push	eax
	push	edi
	mov	ebx, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN4@CacheResul@37
	pop	edi
	pop	ebx

; 1592 : 
; 1593 : 	return true;
; 1594 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, ecx
	add	esp, 92					; 0000005cH
	ret	8
$LN4@CacheResul@37:
	push	esi

; 1560 : 		return false;
; 1561 : 
; 1562 : 	m_strFormationName = kResults.GetText("Name");

	mov	esi, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG219667
	mov	ecx, edi
	call	esi
	lea	ecx, DWORD PTR [ebx+260]
	test	eax, eax
	je	SHORT $LN9@CacheResul@37
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN8@CacheResul@37
$LN9@CacheResul@37:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN8@CacheResul@37:

; 1563 : 	m_bRequiresNavalUnitConsistency = kResults.GetBool("RequiresNavalUnitConsistency");

	mov	ecx, edi
	mov	edi, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG219668
	call	edi

; 1564 : 
; 1565 : 	//Slot entries
; 1566 : 	{
; 1567 : 		Database::Results kSlotEntries;

	push	0
	lea	ecx, DWORD PTR _kSlotEntries$219669[esp+108]
	mov	BYTE PTR [ebx+304], al
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z

; 1568 : 		if(DB.SelectAt(kSlotEntries, "MultiUnitFormation_SlotEntries", "MultiUnitFormationType", GetType()))

	lea	ecx, DWORD PTR [ebx+176]
	mov	DWORD PTR __$EHRec$[esp+112], 0
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG219671
	push	OFFSET $SG219672
	lea	ecx, DWORD PTR _kSlotEntries$219669[esp+116]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	call	DWORD PTR __imp_?SelectAt@Connection@Database@@QAE_NAAVResults@2@PBD11@Z
	test	al, al
	je	$LN1@CacheResul@37
	push	ebp

; 1569 : 		{
; 1570 : 			while(kSlotEntries.Step())

	mov	ebp, DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	lea	ecx, DWORD PTR _kSlotEntries$219669[esp+108]
	call	ebp
	test	al, al
	je	$LN21@CacheResul@37
	add	ebx, 288				; 00000120H
	npad	1
$LL2@CacheResul@37:

; 1571 : 			{
; 1572 : 				CvFormationSlotEntry slotEntry;
; 1573 : 
; 1574 : 				//Basic Properties
; 1575 : 				slotEntry.m_requiredSlot = kSlotEntries.GetBool("RequiredSlot");

	push	OFFSET $SG219677
	lea	ecx, DWORD PTR _kSlotEntries$219669[esp+112]
	call	edi

; 1576 : 
; 1577 : 				//References
; 1578 : 				const char* szTextVal = NULL;
; 1579 : 				szTextVal = kSlotEntries.GetText("MultiUnitPositionType");

	push	OFFSET $SG219679
	lea	ecx, DWORD PTR _kSlotEntries$219669[esp+112]
	mov	BYTE PTR _slotEntry$219676[esp+124], al
	call	esi

; 1580 : 				slotEntry.m_ePositionType = (MultiunitPositionTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1581 : 
; 1582 : 				szTextVal = kSlotEntries.GetText("PrimaryUnitType");

	push	OFFSET $SG219681
	lea	ecx, DWORD PTR _kSlotEntries$219669[esp+112]
	mov	DWORD PTR _slotEntry$219676[esp+120], eax
	call	esi

; 1583 : 				slotEntry.m_primaryUnitType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1584 : 
; 1585 : 				szTextVal = kSlotEntries.GetText("SecondaryUnitType");

	push	OFFSET $SG219682
	lea	ecx, DWORD PTR _kSlotEntries$219669[esp+112]
	mov	DWORD PTR _slotEntry$219676[esp+112], eax
	call	esi

; 1586 : 				slotEntry.m_secondaryUnitType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1587 : 
; 1588 : 				m_vctSlotEntries.push_back(slotEntry);

	lea	edx, DWORD PTR _slotEntry$219676[esp+108]
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR _slotEntry$219676[esp+116], eax
	call	?push_back@?$vector@VCvFormationSlotEntry@@V?$allocator@VCvFormationSlotEntry@@@std@@@std@@QAEXABVCvFormationSlotEntry@@@Z ; std::vector<CvFormationSlotEntry,std::allocator<CvFormationSlotEntry> >::push_back
	lea	ecx, DWORD PTR _kSlotEntries$219669[esp+108]
	call	ebp
	test	al, al
	jne	SHORT $LL2@CacheResul@37
$LN21@CacheResul@37:
	pop	ebp
$LN1@CacheResul@37:

; 1589 : 			}
; 1590 : 		}
; 1591 : 	}

	lea	ecx, DWORD PTR _kSlotEntries$219669[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ

; 1592 : 
; 1593 : 	return true;
; 1594 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	pop	esi
	pop	edi
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 92					; 0000005cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvMultiUnitFormationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _kSlotEntries$219669[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__ehhandler$?CacheResults@CvMultiUnitFormationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvMultiUnitFormationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvMultiUnitFormationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvMultiUnitFormationInfo::CacheResults
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvCivilizationInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvCivilizationInfo@@UAEPAXI@Z PROC			; CvCivilizationInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvCivilizationInfo@@UAE@XZ		; CvCivilizationInfo::~CvCivilizationInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@23
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@23:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvCivilizationInfo@@UAEPAXI@Z ENDP			; CvCivilizationInfo::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvEntityEventInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvEntityEventInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
__ehfuncinfo$?CacheResults@CvEntityEventInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CacheResults@CvEntityEventInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvEntityEventInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_strKey$222823 = -40					; size = 28
__$EHRec$ = -12						; size = 12
$T247357 = 8						; size = 1
_kResults$ = 8						; size = 4
__Cat$247361 = 12					; size = 1
_eAnimationPath$222831 = 12				; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvEntityEventInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvEntityEventInfo::CacheResults, COMDAT
; _this$ = ecx

; 6477 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvEntityEventInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx

; 6478 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	ebx, DWORD PTR _kUtility$[esp+40]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+48]
	push	ebx
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN4@CacheResul@38
	pop	edi
	pop	esi
	pop	ebx

; 6504 : 
; 6505 : 	return true;
; 6506 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
$LN4@CacheResul@38:
	push	ebp

; 6479 : 		return false;
; 6480 : 
; 6481 : 	m_bUpdateFormation = kResults.GetBool("UpdateFormation");

	push	OFFSET $SG222821
	mov	ecx, edi
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 6482 : 
; 6483 : 	const char* szEntityEventType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR [esi+276], al
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 6484 : 
; 6485 : 	//EntityEvent_AnimationPaths
; 6486 : 	{
; 6487 : 		std::string strKey = "EntityEventInfo - AnimationPaths";

	push	OFFSET $SG222824
	lea	ecx, DWORD PTR _strKey$222823[esp+60]
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 6488 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$222823[esp+56]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+68], 0
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebp, eax

; 6489 : 		if(pResults == NULL)

	test	ebp, ebp
	jne	SHORT $LN3@CacheResul@38

; 6490 : 		{
; 6491 : 			pResults = kUtility.PrepareResults(strKey, "select AnimationPaths.ID from EntityEvent_AnimationPaths inner join AnimationPaths on AnimationPathType = AnimationPaths.Type where EntityEventType = ?");

	push	OFFSET $SG222827
	lea	ecx, DWORD PTR _strKey$222823[esp+60]
	push	ecx
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebp, eax
$LN3@CacheResul@38:

; 6492 : 		}
; 6493 : 
; 6494 : 		pResults->Bind(1, szEntityEventType, -1, false);

	push	0
	push	-1
	push	edi
	push	1
	mov	ecx, ebp
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 6495 : 
; 6496 : 		while(pResults->Step())

	mov	ecx, ebp
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	$LN1@CacheResul@38

; 6497 : 		{
; 6498 : 			const AnimationPathTypes eAnimationPath = (AnimationPathTypes)pResults->GetInt(0);
; 6499 : 			m_vctAnimationPathType.push_back(eAnimationPath);

	mov	ebx, DWORD PTR __Cat$247361[esp+52]
	add	esi, 260				; 00000104H
	npad	5
$LL2@CacheResul@38:
	push	0
	mov	ecx, ebp
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _eAnimationPath$222831[esp+52], eax
	test	ecx, ecx
	jne	SHORT $LN18@CacheResul@38
	xor	eax, eax
	jmp	SHORT $LN19@CacheResul@38
$LN18@CacheResul@38:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN19@CacheResul@38:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN11@CacheResul@38
	mov	BYTE PTR $T247357[esp+52], 0
	mov	eax, DWORD PTR $T247357[esp+52]
	push	eax
	push	ebx
	push	esi
	lea	ecx, DWORD PTR _eAnimationPath$222831[esp+64]
	push	ecx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAW4AnimationPathTypes@@IW41@V?$allocator@W4AnimationPathTypes@@@std@@@std@@YAXPAW4AnimationPathTypes@@IABW41@AAV?$allocator@W4AnimationPathTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum AnimationPathTypes *,unsigned int,enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >
	add	esp, 24					; 00000018H
	add	edi, 4
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN52@CacheResul@38
$LN11@CacheResul@38:
	lea	edx, DWORD PTR _eAnimationPath$222831[esp+52]
	push	edx
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4AnimationPathTypes@@V?$allocator@W4AnimationPathTypes@@@std@@@2@IABW4AnimationPathTypes@@@Z ; std::vector<enum AnimationPathTypes,std::allocator<enum AnimationPathTypes> >::_Insert_n
$LN52@CacheResul@38:
	mov	ecx, ebp
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL2@CacheResul@38
$LN1@CacheResul@38:

; 6500 : 		}
; 6501 : 
; 6502 : 		pResults->Reset();

	mov	ecx, ebp
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 6503 : 	}

	lea	ecx, DWORD PTR _strKey$222823[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6504 : 
; 6505 : 	return true;
; 6506 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	ebp
	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvEntityEventInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _strKey$222823[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvEntityEventInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvEntityEventInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvEntityEventInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvEntityEventInfo::CacheResults
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvEraInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvEraInfo@@UAEPAXI@Z PROC				; CvEraInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvEraInfo@@UAE@XZ			; CvEraInfo::~CvEraInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@24
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@24:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvEraInfo@@UAEPAXI@Z ENDP				; CvEraInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z
_TEXT	SEGMENT
$T247448 = -4						; size = 1
__Cat$247452 = 8					; size = 1
$T247419 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 810  : 		if (size() < capacity())

	mov	ebp, DWORD PTR [edi+4]
	test	ebp, ebp
	jne	SHORT $LN9@push_back@4
	xor	esi, esi
	jmp	SHORT $LN10@push_back@4
$LN9@push_back@4:
	mov	ecx, DWORD PTR [edi+12]
	sub	ecx, ebp
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN10@push_back@4:
	mov	ebx, DWORD PTR [edi+8]
	mov	ecx, ebx
	sub	ecx, ebp
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, esi
	jae	SHORT $LN2@push_back@4

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$247452[esp+16]
	mov	eax, DWORD PTR __Val$[esp+16]
	mov	BYTE PTR $T247448[esp+20], 0
	mov	ecx, DWORD PTR $T247448[esp+20]
	push	ecx
	push	edx
	push	edi
	push	eax
	push	1
	push	ebx
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
	add	esp, 24					; 00000018H
	add	ebx, 28					; 0000001cH
	mov	DWORD PTR [edi+8], ebx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@4:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+16]
	push	ecx
	push	ebx
	lea	edx, DWORD PTR $T247419[esp+24]
	push	edx
	mov	ecx, edi
	call	?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::insert
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::push_back
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T247476 = -80						; size = 28
$T247475 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 214748363		; 0ccccccbH
	jb	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T247476[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T247475[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T247476[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T247475[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T247475[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T247475[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T247475[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert:
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+32], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert
	npad	5
$LL10@Insert:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+32], 0
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+32], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+32], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+32], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Lrotate
$LN5@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+32], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+32], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+32], 0
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+32], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+32], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+32], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+32], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+32], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+33], 0
	jne	SHORT $LN170@Insert
	mov	DWORD PTR [edx+4], eax
$LN170@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert
$LN169@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert
$LN167@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+32], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert
$LN9@Insert:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+32], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR $T247476[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z$2:
	lea	ecx, DWORD PTR $T247475[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Insert
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	esi

; 160  : 		_Destroy(_Ptr);

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN17@destroy
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@destroy:
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	pop	esi

; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::erase
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T247953 = -80						; size = 28
$T247952 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+80]
	cmp	BYTE PTR [eax+33], 0
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$[esp+88], ebx
	je	SHORT $LN40@erase@5

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T247953[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T247952[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T247953[esp+88]
	push	eax
	lea	ecx, DWORD PTR $T247952[esp+104]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	mov	DWORD PTR $T247952[esp+92], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T247952[esp+92]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+104], 0
	mov	DWORD PTR $T247952[esp+96], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN311@erase@5:
$LN40@erase@5:
	push	ebp
	push	esi
	push	edi

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[esp+96]
	mov	ebp, eax
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebp]
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LN39@erase@5

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebp+8]
	jmp	SHORT $LN306@erase@5
$LN39@erase@5:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [ebp+8]
	cmp	BYTE PTR [edx+33], 0
	je	SHORT $LN37@erase@5

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN306@erase@5
$LN37@erase@5:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+96]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebp
	jne	SHORT $LN35@erase@5
$LN306@erase@5:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+33], 0
	mov	esi, DWORD PTR [ebp+4]
	jne	SHORT $LN34@erase@5

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase@5:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebx+4]
	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN33@erase@5

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase@5
$LN33@erase@5:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebp
	jne	SHORT $LN31@erase@5

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase@5
$LN31@erase@5:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase@5:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ebx], ebp
	jne	SHORT $LN29@erase@5

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+33], 0
	je	SHORT $LN43@erase@5
	mov	eax, esi
	jmp	SHORT $LN44@erase@5
$LN43@erase@5:
	push	edi
	call	?_Min@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Min
	add	esp, 4
$LN44@erase@5:
	mov	DWORD PTR [ebx], eax
$LN29@erase@5:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	eax, DWORD PTR _this$[esp+100]
	mov	ebx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ebx+8], ebp
	jne	SHORT $LN173@erase@5

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+33], 0
	je	SHORT $LN45@erase@5
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase@5
$LN45@erase@5:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	push	edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase@5
$LN35@erase@5:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebp+8]
	jne	SHORT $LN26@erase@5

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase@5
$LN26@erase@5:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+33], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase@5

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase@5:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase@5:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx+4], ebp
	jne	SHORT $LN23@erase@5

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase@5
$LN23@erase@5:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx], ebp
	jne	SHORT $LN21@erase@5

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase@5
$LN21@erase@5:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase@5:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebp+32]
	add	eax, 32					; 00000020H
	cmp	eax, ecx
	je	SHORT $LN173@erase@5
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN173@erase@5:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	bl, 1
	cmp	BYTE PTR [ebp+32], bl
	jne	$LN19@erase@5

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	ecx, DWORD PTR _this$[esp+100]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [edx+4]
	je	$LN16@erase@5
	npad	8
$LL18@erase@5:
	cmp	BYTE PTR [edi+32], bl
	jne	$LN16@erase@5

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR [esi]
	cmp	edi, eax
	jne	SHORT $LN15@erase@5

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+32], 0
	jne	SHORT $LN14@erase@5

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+32], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [esi+32], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _this$[esp+100]
$LN14@erase@5:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+33], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN309@erase@5

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+32], bl
	jne	SHORT $LN11@erase@5
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+32], bl
	je	SHORT $LN310@erase@5
$LN11@erase@5:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+32], bl
	jne	SHORT $LN9@erase@5

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]
	mov	BYTE PTR [edx+32], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	eax
	mov	BYTE PTR [eax+32], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _this$[esp+100]
$LN9@erase@5:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+32]
	mov	BYTE PTR [eax+32], dl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+32], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR [eax+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [eax+32], bl
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@5
$LN15@erase@5:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+32], 0
	jne	SHORT $LN7@erase@5

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+32], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [esi+32], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _this$[esp+100]
$LN7@erase@5:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+33], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN309@erase@5

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+32], bl
	jne	SHORT $LN4@erase@5
	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+32], bl
	jne	SHORT $LN4@erase@5
$LN310@erase@5:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [eax+32], 0
$LN309@erase@5:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ecx+4]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [eax+4]
	jne	$LL18@erase@5

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase@5
$LN4@erase@5:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+32], bl
	jne	SHORT $LN2@erase@5

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]
	mov	BYTE PTR [edx+32], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	eax
	mov	BYTE PTR [eax+32], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _this$[esp+100]
$LN2@erase@5:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+32]
	mov	BYTE PTR [eax+32], dl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+32], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR [eax]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [eax+32], bl
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Rrotate
$LN16@erase@5:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+32], bl
$LN19@erase@5:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	mov	eax, DWORD PTR [ebp+20]
	xor	esi, esi
	cmp	eax, esi
	je	SHORT $LN294@erase@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN294@erase@5:

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	ebp
	mov	DWORD PTR [ebp+20], esi
	mov	DWORD PTR [ebp+24], esi
	mov	DWORD PTR [ebp+28], esi
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR _this$[esp+104]
	mov	eax, DWORD PTR [ecx+8]
	add	esp, 4
	pop	edi
	cmp	eax, esi
	pop	esi
	pop	ebp
	jbe	SHORT $LN1@erase@5

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ecx+8], eax
$LN1@erase@5:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[esp+84]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	DWORD PTR [eax], ecx

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	8
$LN308@erase@5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T247953[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2:
	lea	ecx, DWORD PTR $T247952[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z
_TEXT	SEGMENT
__Tmp$248521 = -16					; size = 8
__Tmp$248579 = -8					; size = 8
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 1
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_n, COMDAT
; _this$ = ecx

; 2290 : 		{	// insert _Count * _Val at _Where

	sub	esp, 16					; 00000010H

; 2291 : 		size_type _Off = _Insert_x(_Where, _Count);

	mov	eax, DWORD PTR __Where$[esp+16]
	push	ebx
	mov	ebx, DWORD PTR __Count$[esp+16]
	push	esi
	push	edi
	push	ebx
	mov	esi, ecx
	mov	ecx, DWORD PTR __Where$[esp+28]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x

; 2292 : 		std::fill(begin() + _Off, begin() + (_Off + _Count), _Val);

	mov	esi, DWORD PTR [esi+8]
	mov	edi, eax
	lea	edx, DWORD PTR [edi+ebx]
	xor	eax, eax
	push	edx
	lea	ecx, DWORD PTR __Tmp$248521[esp+32]
	mov	DWORD PTR __Tmp$248521[esp+32], esi
	mov	DWORD PTR __Tmp$248521[esp+36], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	xor	eax, eax
	push	edi
	lea	ecx, DWORD PTR __Tmp$248579[esp+32]
	mov	DWORD PTR __Tmp$248579[esp+32], esi
	mov	DWORD PTR __Tmp$248579[esp+36], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$248521[esp+32]
	mov	edx, DWORD PTR __Tmp$248521[esp+28]
	lea	eax, DWORD PTR __Val$[esp+24]
	push	eax
	mov	eax, DWORD PTR __Tmp$248579[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __Tmp$248579[esp+36]
	push	edx
	push	eax
	push	ecx
	call	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 2293 : 		}

	add	esp, 16					; 00000010H
	ret	16					; 00000010H
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_n
_TEXT	ENDS
EXTRN	__imp_?GetText@Results@Database@@QAEPBDH@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvEraInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvEraInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CacheResults@CvEraInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
__ehfuncinfo$?CacheResults@CvEraInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CacheResults@CvEraInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvEraInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_strKey$223026 = -68					; size = 28
$T248591 = -40						; size = 28
__$EHRec$ = -12						; size = 12
$T248698 = 8						; size = 4
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvEraInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvEraInfo::CacheResults, COMDAT
; _this$ = ecx

; 6792 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvEraInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax

; 6793 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+72]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN4@CacheResul@39
	pop	edi
	pop	esi

; 6861 : 
; 6862 : 	return true;
; 6863 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	8
$LN4@CacheResul@39:
	push	ebx

; 6794 : 		return false;
; 6795 : 
; 6796 : 	m_bNoGoodies				= kResults.GetBool("NoGoodies");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	ebp
	push	OFFSET $SG222987
	mov	ecx, edi
	call	ebx

; 6797 : 	m_bNoBarbUnits				= kResults.GetBool("NoBarbUnits");

	push	OFFSET $SG222988
	mov	ecx, edi
	mov	BYTE PTR [esi+552], al
	call	ebx

; 6798 : 	m_bNoReligion				= kResults.GetBool("NoReligion");

	push	OFFSET $SG222989
	mov	ecx, edi
	mov	BYTE PTR [esi+553], al
	call	ebx

; 6799 : 	m_iStartingUnitMultiplier	= kResults.GetInt("StartingUnitMultiplier");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG222990
	mov	ecx, edi
	mov	BYTE PTR [esi+554], al
	call	ebx

; 6800 : 	m_iStartingDefenseUnits		= kResults.GetInt("StartingDefenseUnits");

	push	OFFSET $SG222991
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 6801 : 	m_iStartingWorkerUnits		= kResults.GetInt("StartingWorkerUnits");

	push	OFFSET $SG222992
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 6802 : 	m_iStartingExploreUnits		= kResults.GetInt("StartingExploreUnits");

	push	OFFSET $SG222993
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 6803 : 	m_iResearchAgreementCost	= kResults.GetInt("ResearchAgreementCost");

	push	OFFSET $SG222994
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebx

; 6804 : 	m_iEmbarkedUnitDefense		= kResults.GetInt("EmbarkedUnitDefense");

	push	OFFSET $SG222995
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebx

; 6805 : 	m_iStartingGold				= kResults.GetInt("StartingGold");

	push	OFFSET $SG222996
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebx

; 6806 : 	m_iStartingCulture			= kResults.GetInt("StartingCulture");

	push	OFFSET $SG222997
	mov	ecx, edi
	mov	DWORD PTR [esi+284], eax
	call	ebx

; 6807 : 	m_iFreePopulation			= kResults.GetInt("FreePopulation");

	push	OFFSET $SG222998
	mov	ecx, edi
	mov	DWORD PTR [esi+288], eax
	call	ebx

; 6808 : 	m_iLaterEraBuildingConstructMod = kResults.GetInt("LaterEraBuildingConstructMod");

	push	OFFSET $SG222999
	mov	ecx, edi
	mov	DWORD PTR [esi+292], eax
	call	ebx

; 6809 : 	m_iStartPercent				= kResults.GetInt("StartPercent");

	push	OFFSET $SG223000
	mov	ecx, edi
	mov	DWORD PTR [esi+296], eax
	call	ebx

; 6810 : 	m_iBuildingMaintenancePercent			= kResults.GetInt("BuildingMaintenancePercent");

	push	OFFSET $SG223001
	mov	ecx, edi
	mov	DWORD PTR [esi+300], eax
	call	ebx

; 6811 : 	m_iGrowthPercent			= kResults.GetInt("GrowthPercent");

	push	OFFSET $SG223002
	mov	ecx, edi
	mov	DWORD PTR [esi+304], eax
	call	ebx

; 6812 : 	m_iTrainPercent				= kResults.GetInt("TrainPercent");

	push	OFFSET $SG223003
	mov	ecx, edi
	mov	DWORD PTR [esi+308], eax
	call	ebx

; 6813 : 	m_iConstructPercent			= kResults.GetInt("ConstructPercent");

	push	OFFSET $SG223004
	mov	ecx, edi
	mov	DWORD PTR [esi+312], eax
	call	ebx

; 6814 : 	m_iCreatePercent			= kResults.GetInt("CreatePercent");

	push	OFFSET $SG223005
	mov	ecx, edi
	mov	DWORD PTR [esi+316], eax
	call	ebx
	mov	DWORD PTR [esi+320], eax

; 6815 : 	m_iResearchPercent			= kResults.GetInt("ResearchPercent");

	push	OFFSET $SG223006
	mov	ecx, edi
	call	ebx

; 6816 : 	m_iBuildPercent				= kResults.GetInt("BuildPercent");

	push	OFFSET $SG223007
	mov	ecx, edi
	mov	DWORD PTR [esi+324], eax
	call	ebx

; 6817 : 	m_iImprovementPercent		= kResults.GetInt("ImprovementPercent");

	push	OFFSET $SG223008
	mov	ecx, edi
	mov	DWORD PTR [esi+328], eax
	call	ebx

; 6818 : 	m_iGreatPeoplePercent		= kResults.GetInt("GreatPeoplePercent");

	push	OFFSET $SG223009
	mov	ecx, edi
	mov	DWORD PTR [esi+332], eax
	call	ebx

; 6819 : 	m_iEventChancePerTurn		= kResults.GetInt("EventChancePerTurn");

	push	OFFSET $SG223010
	mov	ecx, edi
	mov	DWORD PTR [esi+336], eax
	call	ebx

; 6820 : 	m_iSpiesGrantedForPlayer    = kResults.GetInt("SpiesGrantedForPlayer");

	push	OFFSET $SG223011
	mov	ecx, edi
	mov	DWORD PTR [esi+340], eax
	call	ebx

; 6821 : 	m_iSpiesGrantedForEveryone  = kResults.GetInt("SpiesGrantedForEveryone");

	push	OFFSET $SG223012
	mov	ecx, edi
	mov	DWORD PTR [esi+344], eax
	call	ebx

; 6822 : 	m_iFaithCostMultiplier      = kResults.GetInt("FaithCostMultiplier");

	push	OFFSET $SG223013
	mov	ecx, edi
	mov	DWORD PTR [esi+348], eax
	call	ebx

; 6823 : 	m_iDiploEmphasisReligion    = kResults.GetInt("DiploEmphasisReligion");

	push	OFFSET $SG223014
	mov	ecx, edi
	mov	DWORD PTR [esi+352], eax
	call	ebx

; 6824 : 	m_iDiplpEmphasisLatePolicies= kResults.GetInt("DiploEmphasisLatePolicies");

	push	OFFSET $SG223015
	mov	ecx, edi
	mov	DWORD PTR [esi+356], eax
	call	ebx

; 6825 : 	m_iTradeRouteFoodBonusTimes100 = kResults.GetInt("TradeRouteFoodBonusTimes100");

	push	OFFSET $SG223016
	mov	ecx, edi
	mov	DWORD PTR [esi+360], eax
	call	ebx

; 6826 : 	m_iTradeRouteProductionBonusTimes100 = kResults.GetInt("TradeRouteProductionBonusTimes100");

	push	OFFSET $SG223017
	mov	ecx, edi
	mov	DWORD PTR [esi+364], eax
	call	ebx

; 6827 : 	m_iLeaguePercent			= kResults.GetInt("LeaguePercent");

	push	OFFSET $SG223018
	mov	ecx, edi
	mov	DWORD PTR [esi+368], eax
	call	ebx

; 6828 : 	m_iWarmongerPercent			= kResults.GetInt("WarmongerPercent");

	push	OFFSET $SG223019
	mov	ecx, edi
	mov	DWORD PTR [esi+372], eax
	call	ebx

; 6829 : 
; 6830 : 	m_strCityBombardEffectTag	= kResults.GetText("CityBombardEffectTag");

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG223020
	mov	ecx, edi
	mov	DWORD PTR [esi+376], eax
	call	ebx
	lea	ebp, DWORD PTR [esi+380]
	mov	ecx, ebp
	test	eax, eax
	je	SHORT $LN10@CacheResul@39
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN9@CacheResul@39
$LN10@CacheResul@39:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN9@CacheResul@39:

; 6831 : 	m_uiCityBombardEffectTagHash = FString::Hash(m_strCityBombardEffectTag);

	mov	ecx, ebp
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ebp, eax
	test	ebp, ebp
	je	SHORT $LN19@CacheResul@39
	mov	ecx, ebp
	lea	edx, DWORD PTR [ecx+1]
	npad	4
$LL67@CacheResul@39:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL67@CacheResul@39
	sub	ecx, edx
	jmp	SHORT $LN20@CacheResul@39
$LN19@CacheResul@39:
	xor	ecx, ecx
$LN20@CacheResul@39:
	push	-1
	push	ecx
	push	ebp
	mov	ecx, OFFSET ?g_CRC32@@3VFCRC@@A		; g_CRC32
	call	?Calc@FCRC@@QBEKPBXHK@Z			; FCRC::Calc

; 6832 : 
; 6833 : 	m_strAudioUnitVictoryScript	= kResults.GetText("AudioUnitVictoryScript");

	push	OFFSET $SG223021
	mov	ecx, edi
	mov	DWORD PTR [esi+548], eax
	call	ebx
	lea	ecx, DWORD PTR [esi+408]
	test	eax, eax
	je	SHORT $LN22@CacheResul@39
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN21@CacheResul@39
$LN22@CacheResul@39:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN21@CacheResul@39:

; 6834 : 	m_strAudioUnitDefeatScript	= kResults.GetText("AudioUnitDefeatScript");

	push	OFFSET $SG223022
	mov	ecx, edi
	call	ebx
	lea	ecx, DWORD PTR [esi+436]
	test	eax, eax
	je	SHORT $LN26@CacheResul@39
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN25@CacheResul@39
$LN26@CacheResul@39:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN25@CacheResul@39:

; 6835 : 
; 6836 : 	m_strArtPrefix	= kResults.GetText("ArtPrefix");

	push	OFFSET $SG223023
	mov	ecx, edi
	call	ebx
	lea	ecx, DWORD PTR [esi+464]
	test	eax, eax
	je	SHORT $LN30@CacheResul@39
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN29@CacheResul@39
$LN30@CacheResul@39:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN29@CacheResul@39:

; 6837 : 
; 6838 : 	m_strShortDesc = kResults.GetText("ShortDescription");

	push	OFFSET $SG223024
	mov	ecx, edi
	call	ebx
	lea	ecx, DWORD PTR [esi+492]
	test	eax, eax
	je	SHORT $LN34@CacheResul@39
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN33@CacheResul@39
$LN34@CacheResul@39:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN33@CacheResul@39:

; 6839 : 	m_strAbbreviation = kResults.GetText("Abbreviation");

	push	OFFSET $SG223025
	mov	ecx, edi
	call	ebx
	lea	ecx, DWORD PTR [esi+520]
	test	eax, eax
	je	SHORT $LN38@CacheResul@39
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN37@CacheResul@39
$LN38@CacheResul@39:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN37@CacheResul@39:

; 6840 : 
; 6841 : 	//City Names
; 6842 : 	{
; 6843 : 		m_vEraVOs.clear();

	mov	eax, DWORD PTR [esi+564]
	mov	ecx, DWORD PTR [esi+560]
	lea	ebx, DWORD PTR [esi+556]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T248698[esp+88]
	push	ecx
	mov	ecx, ebx
	call	?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ; std::vector<CvString,std::allocator<CvString> >::erase

; 6844 : 
; 6845 : 		std::string strKey = "Era - NewEraVOs";

	push	OFFSET $SG223027
	lea	ecx, DWORD PTR _strKey$223026[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 6846 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	mov	ebp, DWORD PTR _kUtility$[esp+80]
	lea	edx, DWORD PTR _strKey$223026[esp+84]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 6847 : 		if(pResults == NULL)

	test	edi, edi
	jne	SHORT $LN3@CacheResul@39

; 6848 : 		{
; 6849 : 			pResults = kUtility.PrepareResults(strKey, "select VOScript from Era_NewEraVOs where EraType = ?");

	push	OFFSET $SG223030
	lea	eax, DWORD PTR _strKey$223026[esp+88]
	push	eax
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax
$LN3@CacheResul@39:

; 6850 : 		}
; 6851 : 
; 6852 : 		pResults->Bind(1, GetType(), -1, false);

	push	0
	push	-1
	lea	ecx, DWORD PTR [esi+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 6853 : 
; 6854 : 		while(pResults->Step())

	mov	esi, DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	mov	ecx, edi
	call	esi
	test	al, al
	je	SHORT $LN1@CacheResul@39
	mov	ebp, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDH@Z
	npad	6
$LL2@CacheResul@39:

; 6855 : 		{
; 6856 : 			m_vEraVOs.push_back(pResults->GetText(0));

	push	0
	mov	ecx, edi
	call	ebp
	test	eax, eax
	jne	SHORT $LN60@CacheResul@39
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN60@CacheResul@39:
	push	eax
	lea	ecx, DWORD PTR $T248591[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T248591[esp+84]
	push	ecx
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+96], 1
	call	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
	lea	ecx, DWORD PTR $T248591[esp+84]
	mov	BYTE PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, edi
	call	esi
	test	al, al
	jne	SHORT $LL2@CacheResul@39
$LN1@CacheResul@39:

; 6857 : 		}
; 6858 : 
; 6859 : 		pResults->Reset();

	mov	ecx, edi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 6860 : 	}

	lea	ecx, DWORD PTR _strKey$223026[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6861 : 
; 6862 : 	return true;
; 6863 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	ebp
	pop	ebx
	pop	edi
	mov	al, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvEraInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _strKey$223026[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvEraInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR $T248591[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?CacheResults@CvEraInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvEraInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvEraInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvEraInfo::CacheResults
PUBLIC	?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z
_TEXT	SEGMENT
$T248743 = -16						; size = 8
$T248741 = -16						; size = 8
__Tmp$248967 = -8					; size = 8
$T248747 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 1
?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z PROC ; std::vector<bool,std::allocator<bool> >::resize, COMDAT
; _this$ = ecx

; 2039 : 		{	// determine new length, padding with _Val elements as needed

	sub	esp, 16					; 00000010H
	push	ebx

; 2040 : 		if (size() < _Newsize)

	mov	ebx, DWORD PTR __Newsize$[esp+16]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi]
	cmp	ebx, esi
	jbe	SHORT $LN68@resize@2

; 2041 : 			_Insert_n(end(), _Newsize - size(), _Val);

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR $T248741[esp+28], eax
	mov	DWORD PTR $T248741[esp+32], 0
	test	esi, esi
	jbe	SHORT $LN25@resize@2
	push	esi
	lea	ecx, DWORD PTR $T248741[esp+32]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN25@resize@2:
	mov	ecx, DWORD PTR __Val$[esp+24]
	mov	edx, DWORD PTR $T248741[esp+32]
	mov	eax, DWORD PTR $T248741[esp+28]
	push	ecx
	sub	ebx, esi
	push	ebx
	push	edx
	push	eax
	mov	ecx, edi
	call	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
	pop	edi
	pop	esi
	pop	ebx

; 2044 : 		}

	add	esp, 16					; 00000010H
	ret	8
$LN68@resize@2:

; 2042 : 		else if (_Newsize < size())

	jae	SHORT $LN1@resize@2
	push	ebp

; 2043 : 			erase(begin() + _Newsize, end());

	mov	ebp, DWORD PTR [edi+8]
	mov	DWORD PTR $T248743[esp+32], ebp
	mov	DWORD PTR $T248743[esp+36], 0
	test	esi, esi
	jbe	SHORT $LN48@resize@2
	push	esi
	lea	ecx, DWORD PTR $T248743[esp+36]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN48@resize@2:
	xor	eax, eax
	push	ebx
	lea	ecx, DWORD PTR __Tmp$248967[esp+36]
	mov	DWORD PTR __Tmp$248967[esp+36], ebp
	mov	DWORD PTR __Tmp$248967[esp+40], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR $T248743[esp+36]
	mov	edx, DWORD PTR $T248743[esp+32]
	mov	eax, DWORD PTR __Tmp$248967[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __Tmp$248967[esp+36]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T248747[esp+48]
	push	edx
	mov	ecx, edi
	call	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
	pop	ebp
$LN1@resize@2:
	pop	edi
	pop	esi
	pop	ebx

; 2044 : 		}

	add	esp, 16					; 00000010H
	ret	8
?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::resize
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	ebp
	push	esi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	esi, DWORD PTR __Rootnode$[esp+8]
	xor	ebx, ebx
	push	edi
	mov	ebp, ecx
	mov	edi, esi
	cmp	BYTE PTR [esi+33], bl
	jne	SHORT $LN1@Erase
$LL3@Erase:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [edi+8]
	push	eax
	mov	ecx, ebp
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);
; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	eax, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [edi]
	cmp	eax, ebx
	je	SHORT $LN28@Erase
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN28@Erase:

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	esi
	mov	DWORD PTR [esi+20], ebx
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+28], ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	esi, edi
	cmp	BYTE PTR [edi+33], bl
	je	SHORT $LL3@Erase
$LN1@Erase:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T249090 = 12						; size = 4
$T249088 = 12						; size = 4
__Where$224467 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+33], 0
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+16], cl
	jne	SHORT $LN9@insert@5
	mov	edx, DWORD PTR [ebp]
	npad	1
$LL10@insert@5:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+12]
	mov	esi, eax
	setl	cl
	mov	BYTE PTR __Addleft$[esp+16], cl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	cl, cl
	je	SHORT $LN13@insert@5
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert@5
$LN13@insert@5:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert@5:

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL10@insert@5
$LN9@insert@5:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, esi
	mov	DWORD PTR __Where$224467[esp+12], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN57@insert@5

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	lea	ecx, DWORD PTR $T249088[esp+12]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN4@insert@5
	push	ebp
	push	esi
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN4@insert@5:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$224467[esp+12]
$LN57@insert@5:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR [ebp]
	jge	SHORT $LN2@insert@5

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Addleft$[esp+16]
	push	ebp
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T249090[esp+24]
	push	edx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN2@insert@5:

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Copy
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node
; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	ebx, DWORD PTR __Rootnode$[ebp]
	cmp	BYTE PTR [ebx+33], 0
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR __Newroot$[ebp], eax
	jne	SHORT $LN8@Copy

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	movzx	ecx, BYTE PTR [ebx+32]
	push	ecx
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	lea	edx, DWORD PTR [ebx+12]
	push	edx
	push	eax
	push	ecx
	push	eax
	mov	ecx, esi
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Buynode

; 1082 : 			if (_Isnil(_Newroot))

	mov	edx, DWORD PTR __Newroot$[ebp]
	cmp	BYTE PTR [edx+33], 0
	mov	edi, eax
	je	SHORT $LN2@Copy

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	DWORD PTR __Newroot$[ebp], edi
$LN2@Copy:

; 1084 : 
; 1085 : 			_TRY_BEGIN
; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR [ebx]
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Copy
	mov	DWORD PTR [edi], eax

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR [ebx+8]
	push	edi
	push	ecx
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Copy
	mov	DWORD PTR [edi+8], eax
$LN8@Copy:

; 1091 : 			_CATCH_END
; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree
; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, DWORD PTR __Newroot$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN29@Copy:
$LN28@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Copy
EXTRN	__imp_?GetBool@Results@Database@@QAE_NH@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$8
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_maxUnitClasses$ = -108					; size = 4
_iUnitAITypeID$220173 = -104				; size = 4
_maxBuildingClasses$ = -104				; size = 4
$T249371 = -100						; size = 4
_strKey$220164 = -96					; size = 28
_key$220153 = -96					; size = 28
_key$220142 = -96					; size = 28
_strKey$220133 = -96					; size = 28
_strKey$220125 = -96					; size = 28
_strKey$220117 = -96					; size = 28
_strKey$220195 = -68					; size = 28
$T249260 = -68						; size = 28
$T249263 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_szType$ = 8						; size = 4
_kResults$ = 8						; size = 4
$T249806 = 12						; size = 4
_iUnitClassID$220172 = 12				; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvCivilizationInfo::CacheResults, COMDAT
; _this$ = ecx

; 2261 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 96					; 00000060H
	push	ebx

; 2262 : 	if(!CvCivilizationBaseInfo::CacheResults(kResults, kUtility))

	mov	ebx, DWORD PTR _kResults$[esp+108]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kUtility$[esp+116]
	push	edi
	push	ebx
	mov	esi, ecx
	call	?CacheResults@CvCivilizationBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvCivilizationBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN22@CacheResul@40
	pop	edi
	pop	esi
	pop	ebx

; 2494 : 
; 2495 : 	return true;
; 2496 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	mov	DWORD PTR fs:0, ecx
	add	esp, 108				; 0000006cH
	ret	8
$LN22@CacheResul@40:
	push	ebp

; 2263 : 		return false;
; 2264 : 
; 2265 : 	const size_t maxUnitClasses = kUtility.MaxRows("UnitClasses");

	push	OFFSET $SG220104
	mov	ecx, edi
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 2266 : 	const size_t maxBuildingClasses = kUtility.MaxRows("BuildingClasses");

	push	OFFSET $SG220106
	mov	ecx, edi
	mov	DWORD PTR _maxUnitClasses$[esp+128], eax
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 2267 : 
; 2268 : 	const char* szTextVal = NULL;	//! temporary val
; 2269 : 
; 2270 : 	//Basic Properties
; 2271 : 	szTextVal = kResults.GetText("Adjective");

	mov	ebp, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG220108
	mov	ecx, ebx
	mov	DWORD PTR _maxBuildingClasses$[esp+128], eax
	call	ebp

; 2272 : 	setAdjectiveKey(szTextVal);

	push	eax
	mov	ecx, esi
	call	?setAdjectiveKey@CvCivilizationInfo@@QAEXPBD@Z ; CvCivilizationInfo::setAdjectiveKey

; 2273 : 
; 2274 : 	//References
; 2275 : 	szTextVal = kResults.GetText("DefaultPlayerColor");

	push	OFFSET $SG220109
	mov	ecx, ebx
	call	ebp

; 2276 : 	m_iDefaultPlayerColor = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2277 : 
; 2278 : 	szTextVal = kResults.GetText("ArtDefineTag");

	push	OFFSET $SG220110
	mov	ecx, ebx
	mov	DWORD PTR [esi+336], eax
	call	ebp

; 2279 : 	setArtDefineTag(szTextVal);

	lea	ecx, DWORD PTR [esi+348]
	test	eax, eax
	je	SHORT $LN37@CacheResul@40
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN36@CacheResul@40
$LN37@CacheResul@40:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN36@CacheResul@40:

; 2280 : 
; 2281 : 	szTextVal = kResults.GetText("ArtStyleType");

	push	OFFSET $SG220111
	mov	ecx, ebx
	call	ebp

; 2282 : 	m_iArtStyleType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2283 : 
; 2284 : 	szTextVal = kResults.GetText("ArtStylePrefix");

	push	OFFSET $SG220112
	mov	ecx, ebx
	mov	DWORD PTR [esi+340], eax
	call	ebp

; 2285 : 	setArtStylePrefix(szTextVal);

	lea	ecx, DWORD PTR [esi+376]
	test	eax, eax
	je	SHORT $LN43@CacheResul@40
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN42@CacheResul@40
$LN43@CacheResul@40:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN42@CacheResul@40:

; 2286 : 
; 2287 : 	szTextVal = kResults.GetText("ArtStyleSuffix");

	push	OFFSET $SG220113
	mov	ecx, ebx
	call	ebp

; 2288 : 	setArtStyleSuffix(szTextVal);

	lea	ecx, DWORD PTR [esi+404]
	test	eax, eax
	je	SHORT $LN49@CacheResul@40
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN48@CacheResul@40
$LN49@CacheResul@40:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN48@CacheResul@40:

; 2289 : 
; 2290 : 	szTextVal = kResults.GetText("DawnOfManAudio");

	push	OFFSET $SG220114
	mov	ecx, ebx
	call	ebp

; 2291 : 	m_strDawnOfManAudio = szTextVal;

	lea	ecx, DWORD PTR [esi+488]
	test	eax, eax
	je	SHORT $LN53@CacheResul@40
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN52@CacheResul@40
$LN53@CacheResul@40:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN52@CacheResul@40:

; 2292 : 
; 2293 : 	szTextVal = kResults.GetText("SoundtrackTag");

	push	OFFSET $SG220115
	mov	ecx, ebx
	call	ebp

; 2294 : 	m_strSoundtrackKey = szTextVal;

	lea	ecx, DWORD PTR [esi+516]
	test	eax, eax
	je	SHORT $LN57@CacheResul@40
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN56@CacheResul@40
$LN57@CacheResul@40:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN56@CacheResul@40:

; 2295 : 
; 2296 : 	const char* szType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ebp, eax

; 2297 : 
; 2298 : 	//coastal start
; 2299 : 	{
; 2300 : 		m_bCoastalCiv = false;
; 2301 : 
; 2302 : 		std::string strKey = "Civilization_Start_Along_Ocean";

	push	OFFSET $SG220118
	lea	ecx, DWORD PTR _strKey$220117[esp+128]
	mov	DWORD PTR _szType$[esp+124], ebp
	mov	BYTE PTR [esi+580], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2303 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$220117[esp+124]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+136], 0
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebx, eax

; 2304 : 		if(pResults == NULL)

	test	ebx, ebx
	jne	SHORT $LN21@CacheResul@40

; 2305 : 		{
; 2306 : 			pResults = kUtility.PrepareResults(strKey, "select StartAlongOcean from Civilization_Start_Along_Ocean where CivilizationType = ?");

	push	OFFSET $SG220121
	lea	ecx, DWORD PTR _strKey$220117[esp+128]
	push	ecx
	mov	ecx, edi
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebx, eax
$LN21@CacheResul@40:

; 2307 : 		}
; 2308 : 
; 2309 : 		pResults->Bind(1, szType, -1, false);

	push	0
	push	-1
	push	ebp
	push	1
	mov	ecx, ebx
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 2310 : 
; 2311 : 		while(pResults->Step())

	mov	ebp, DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	mov	ecx, ebx
	call	ebp
	test	al, al
	je	SHORT $LN19@CacheResul@40
$LL20@CacheResul@40:

; 2312 : 		{
; 2313 : 			m_bCoastalCiv = pResults->GetBool(0);

	push	0
	mov	ecx, ebx
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NH@Z
	mov	ecx, ebx
	mov	BYTE PTR [esi+580], al
	call	ebp
	test	al, al
	jne	SHORT $LL20@CacheResul@40
$LN19@CacheResul@40:

; 2314 : 		}
; 2315 : 
; 2316 : 		pResults->Reset();

	mov	ecx, ebx
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 2317 : 	}

	lea	ecx, DWORD PTR _strKey$220117[esp+124]
	mov	DWORD PTR __$EHRec$[esp+132], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2318 : 
; 2319 : 	//place first
; 2320 : 	{
; 2321 : 		m_bPlaceFirst = false;
; 2322 : 
; 2323 : 		std::string strKey = "Civilization_Start_Place_First";

	push	OFFSET $SG220126
	lea	ecx, DWORD PTR _strKey$220125[esp+128]
	mov	BYTE PTR [esi+581], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2324 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$220125[esp+124]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+136], 1
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebx, eax

; 2325 : 		if(pResults == NULL)

	test	ebx, ebx
	jne	SHORT $LN18@CacheResul@40

; 2326 : 		{
; 2327 : 			pResults = kUtility.PrepareResults(strKey, "select PlaceFirst from Civilization_Start_Place_First_Along_Ocean where CivilizationType = ?");

	push	OFFSET $SG220129
	lea	eax, DWORD PTR _strKey$220125[esp+128]
	push	eax
	mov	ecx, edi
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebx, eax
$LN18@CacheResul@40:

; 2328 : 		}
; 2329 : 
; 2330 : 		pResults->Bind(1, szType, -1, false);

	mov	ecx, DWORD PTR _szType$[esp+120]
	push	0
	push	-1
	push	ecx
	push	1
	mov	ecx, ebx
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 2331 : 
; 2332 : 		while(pResults->Step())

	mov	ecx, ebx
	call	ebp
	test	al, al
	je	SHORT $LN16@CacheResul@40
	npad	7
$LL17@CacheResul@40:

; 2333 : 		{
; 2334 : 			m_bPlaceFirst = pResults->GetBool(0);

	push	0
	mov	ecx, ebx
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NH@Z
	mov	ecx, ebx
	mov	BYTE PTR [esi+581], al
	call	ebp
	test	al, al
	jne	SHORT $LL17@CacheResul@40
$LN16@CacheResul@40:

; 2335 : 		}
; 2336 : 
; 2337 : 		pResults->Reset();

	mov	ecx, ebx
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 2338 : 	}

	lea	ecx, DWORD PTR _strKey$220125[esp+124]
	mov	DWORD PTR __$EHRec$[esp+132], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2339 : 
; 2340 : 	//Arrays
; 2341 : 
; 2342 : 	//City Names
; 2343 : 	{
; 2344 : 		m_vCityNames.clear();

	mov	eax, DWORD PTR [esi+592]
	mov	ecx, DWORD PTR [esi+588]
	lea	ebx, DWORD PTR [esi+584]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T249371[esp+132]
	push	edx
	mov	ecx, ebx
	call	?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ; std::vector<CvString,std::allocator<CvString> >::erase

; 2345 : 
; 2346 : 		std::string strKey = "Civilization - CityNames";

	push	OFFSET $SG220134
	lea	ecx, DWORD PTR _strKey$220133[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2347 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$220133[esp+124]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+136], 2
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebp, eax

; 2348 : 		if(pResults == NULL)

	test	ebp, ebp
	jne	SHORT $LN15@CacheResul@40

; 2349 : 		{
; 2350 : 			pResults = kUtility.PrepareResults(strKey, "select CityName from Civilization_CityNames where CivilizationType = ?");

	push	OFFSET $SG220137
	lea	ecx, DWORD PTR _strKey$220133[esp+128]
	push	ecx
	mov	ecx, edi
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebp, eax
$LN15@CacheResul@40:

; 2351 : 		}
; 2352 : 
; 2353 : 		pResults->Bind(1, szType, -1, false);

	mov	edx, DWORD PTR _szType$[esp+120]
	push	0
	push	-1
	push	edx
	push	1
	mov	ecx, ebp
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 2354 : 
; 2355 : 		while(pResults->Step())

	mov	ecx, ebp
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN13@CacheResul@40
$LL14@CacheResul@40:

; 2356 : 		{
; 2357 : 			m_vCityNames.push_back(pResults->GetText(0));

	push	0
	mov	ecx, ebp
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDH@Z
	test	eax, eax
	jne	SHORT $LN79@CacheResul@40
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN79@CacheResul@40:
	push	eax
	lea	ecx, DWORD PTR $T249260[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR $T249260[esp+124]
	push	eax
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+136], 3
	call	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
	lea	ecx, DWORD PTR $T249260[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, ebp
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL14@CacheResul@40
$LN13@CacheResul@40:

; 2358 : 		}
; 2359 : 
; 2360 : 		pResults->Reset();

	mov	ecx, ebp
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 2361 : 	}

	lea	ecx, DWORD PTR _strKey$220133[esp+124]
	mov	DWORD PTR __$EHRec$[esp+132], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2362 : 
; 2363 : 	//Building Types
; 2364 : 	{
; 2365 : 		// call the function that sets the default civilization buildings
; 2366 : 		InitBuildingDefaults(m_piCivilizationBuildings, kUtility);

	lea	eax, DWORD PTR [esi+544]
	push	edi
	push	eax
	mov	ecx, esi
	call	?InitBuildingDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z ; CvCivilizationInfo::InitBuildingDefaults

; 2367 : 
; 2368 : 		m_CivilizationBuildingOverridden.reserve(maxBuildingClasses);

	mov	ebp, DWORD PTR _maxBuildingClasses$[esp+124]
	lea	ecx, DWORD PTR [ebp+31]
	shr	ecx, 5
	push	ecx
	lea	ecx, DWORD PTR [esi+620]
	call	?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::reserve

; 2369 : 		m_CivilizationBuildingOverridden.clear();

	lea	ebx, DWORD PTR [esi+616]
	mov	ecx, ebx
	call	?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<bool,std::allocator<bool> >::clear

; 2370 : 		m_CivilizationBuildingOverridden.resize(maxBuildingClasses, false);

	push	0
	push	ebp
	mov	ecx, ebx
	call	?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize

; 2371 : 
; 2372 : 		std::string key = "Civilization_BuildingClassOverrides";

	push	OFFSET $SG220143
	lea	ecx, DWORD PTR _key$220142[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2373 : 		Database::Results* pResults = kUtility.GetResults(key);

	lea	edx, DWORD PTR _key$220142[esp+124]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+136], 4
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebp, eax

; 2374 : 		if(pResults == NULL)

	test	ebp, ebp
	jne	SHORT $LN12@CacheResul@40

; 2375 : 		{
; 2376 : 			pResults = kUtility.PrepareResults(key, "select BuildingClasses.ID, coalesce(Buildings.ID, -1) from Civilization_BuildingClassOverrides inner join BuildingClasses on BuildingClassType = BuildingClasses.Type left outer join Buildings on BuildingType = Buildings.Type where CivilizationType = ?");

	push	OFFSET $SG220146
	lea	eax, DWORD PTR _key$220142[esp+128]
	push	eax
	mov	ecx, edi
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebp, eax
$LN12@CacheResul@40:

; 2377 : 
; 2378 : 		}
; 2379 : 
; 2380 : 		pResults->Bind(1, szType);

	mov	ecx, DWORD PTR _szType$[esp+120]
	push	1
	push	ecx
	push	1
	mov	ecx, ebp
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 2381 : 
; 2382 : 		while(pResults->Step())

	mov	ecx, ebp
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	test	al, al
	je	SHORT $LN10@CacheResul@40
$LL11@CacheResul@40:

; 2383 : 		{
; 2384 : 			const int idx = pResults->GetInt(0);

	push	0
	mov	ecx, ebp
	call	ebx

; 2385 : 			const int buildingID = pResults->GetInt(1);

	push	1
	mov	ecx, ebp
	mov	edi, eax
	call	ebx

; 2386 : 
; 2387 : 			m_piCivilizationBuildings[idx] = buildingID;

	mov	edx, DWORD PTR [esi+544]

; 2388 : 			m_CivilizationBuildingOverridden[idx] = true;

	xor	ecx, ecx
	mov	DWORD PTR [edx+edi*4], eax
	mov	eax, DWORD PTR [esi+624]
	test	edi, edi
	je	SHORT $LN108@CacheResul@40
	jge	SHORT $LN109@CacheResul@40
	mov	ecx, edi
	neg	ecx
	je	SHORT $LN109@CacheResul@40
	or	edx, -1
	sub	edx, edi
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	mov	ecx, -4					; fffffffcH
	sub	ecx, edx
	add	eax, ecx
	jmp	SHORT $LN237@CacheResul@40
$LN109@CacheResul@40:
	mov	edx, edi
	shr	edx, 5
	lea	eax, DWORD PTR [eax+edx*4]
$LN237@CacheResul@40:
	and	edi, 31					; 0000001fH
	mov	ecx, edi
$LN108@CacheResul@40:
	mov	edx, 1
	shl	edx, cl
	mov	ecx, ebp
	or	DWORD PTR [eax], edx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL11@CacheResul@40

; 2381 : 
; 2382 : 		while(pResults->Step())

	mov	edi, DWORD PTR _kUtility$[esp+120]
$LN10@CacheResul@40:

; 2389 : 		}
; 2390 : 
; 2391 : 		pResults->Reset();

	mov	ecx, ebp
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 2392 : 	}

	lea	ecx, DWORD PTR _key$220142[esp+124]
	mov	DWORD PTR __$EHRec$[esp+132], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2393 : 
; 2394 : 	//Unit Types
; 2395 : 	{
; 2396 : 		// call the function that sets the default civilization units
; 2397 : 		InitUnitDefaults(m_piCivilizationUnits, kUtility);

	lea	eax, DWORD PTR [esi+548]
	push	edi
	push	eax
	mov	ecx, esi
	call	?InitUnitDefaults@CvCivilizationInfo@@IAEXAAPAHAAVCvDatabaseUtility@@@Z ; CvCivilizationInfo::InitUnitDefaults

; 2398 : 
; 2399 : 		m_CivilizationUnitOverridden.reserve(maxUnitClasses);

	mov	eax, DWORD PTR _maxUnitClasses$[esp+124]
	add	eax, 31					; 0000001fH
	shr	eax, 5
	push	eax
	lea	ecx, DWORD PTR [esi+640]
	call	?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::reserve

; 2400 : 		m_CivilizationUnitOverridden.clear();

	lea	ebp, DWORD PTR [esi+636]
	mov	ecx, ebp
	call	?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<bool,std::allocator<bool> >::clear

; 2401 : 		m_CivilizationUnitOverridden.resize(maxUnitClasses,false);

	mov	ecx, DWORD PTR _maxUnitClasses$[esp+124]
	push	0
	push	ecx
	mov	ecx, ebp
	call	?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize

; 2402 : 
; 2403 : 		std::string key = "Civilization_UnitClassOverrides";

	push	OFFSET $SG220154
	lea	ecx, DWORD PTR _key$220153[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2404 : 		Database::Results* pResults = kUtility.GetResults(key);

	lea	edx, DWORD PTR _key$220153[esp+124]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+136], 5
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebp, eax

; 2405 : 		if(pResults == NULL)

	test	ebp, ebp
	jne	SHORT $LN9@CacheResul@40

; 2406 : 		{
; 2407 : 			pResults = kUtility.PrepareResults(key, "select UnitClasses.ID, coalesce(Units.ID, -1) from Civilization_UnitClassOverrides inner join UnitClasses on UnitClassType = UnitClasses.Type left outer join Units on UnitType = Units.Type where CivilizationType = ?");

	push	OFFSET $SG220157
	lea	eax, DWORD PTR _key$220153[esp+128]
	push	eax
	mov	ecx, edi
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebp, eax
$LN9@CacheResul@40:

; 2408 : 		}
; 2409 : 
; 2410 : 		pResults->Bind(1, szType);

	mov	ecx, DWORD PTR _szType$[esp+120]
	push	1
	push	ecx
	push	1
	mov	ecx, ebp
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 2411 : 
; 2412 : 		while(pResults->Step())

	mov	ecx, ebp
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN7@CacheResul@40
$LL8@CacheResul@40:

; 2413 : 		{
; 2414 : 			const int idx = pResults->GetInt(0);

	push	0
	mov	ecx, ebp
	call	ebx

; 2415 : 			const int unitID = pResults->GetInt(1);

	push	1
	mov	ecx, ebp
	mov	edi, eax
	call	ebx

; 2416 : 
; 2417 : 			m_piCivilizationUnits[idx] = unitID;

	mov	edx, DWORD PTR [esi+548]

; 2418 : 			m_CivilizationUnitOverridden[idx] = true;

	xor	ecx, ecx
	mov	DWORD PTR [edx+edi*4], eax
	mov	eax, DWORD PTR [esi+644]
	test	edi, edi
	je	SHORT $LN157@CacheResul@40
	jge	SHORT $LN158@CacheResul@40
	mov	ecx, edi
	neg	ecx
	je	SHORT $LN158@CacheResul@40
	or	edx, -1
	sub	edx, edi
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	mov	ecx, -4					; fffffffcH
	sub	ecx, edx
	add	eax, ecx
	jmp	SHORT $LN238@CacheResul@40
$LN158@CacheResul@40:
	mov	edx, edi
	shr	edx, 5
	lea	eax, DWORD PTR [eax+edx*4]
$LN238@CacheResul@40:
	and	edi, 31					; 0000001fH
	mov	ecx, edi
$LN157@CacheResul@40:
	mov	edx, 1
	shl	edx, cl
	mov	ecx, ebp
	or	DWORD PTR [eax], edx
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL8@CacheResul@40
$LN7@CacheResul@40:

; 2419 : 		}
; 2420 : 
; 2421 : 		pResults->Reset();

	mov	ecx, ebp
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 2422 : 
; 2423 : 	}

	lea	ecx, DWORD PTR _key$220153[esp+124]
	mov	DWORD PTR __$EHRec$[esp+132], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2424 : 
; 2425 : 	//FreeUnits
; 2426 : 	{
; 2427 : 		kUtility.InitializeArray(m_piCivilizationFreeUnitsClass, maxUnitClasses, -1);

	mov	eax, DWORD PTR _maxUnitClasses$[esp+124]
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edi, DWORD PTR _maxUnitClasses$[esp+128]
	add	esp, 4
	xor	ecx, ecx
	mov	DWORD PTR [esi+552], eax
	test	edi, edi
	jbe	SHORT $LN182@CacheResul@40
	npad	2
$LL184@CacheResul@40:
	mov	eax, DWORD PTR [esi+552]
	mov	DWORD PTR [eax+ecx*4], -1
	inc	ecx
	cmp	ecx, edi
	jb	SHORT $LL184@CacheResul@40
$LN182@CacheResul@40:

; 2428 : 		kUtility.InitializeArray(m_piCivilizationFreeUnitsDefaultUnitAI, maxUnitClasses, -1);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+556], eax
	mov	ecx, edi
	add	esp, 4
	xor	eax, eax
	test	ecx, ecx
	jbe	SHORT $LN189@CacheResul@40
	npad	5
$LL191@CacheResul@40:
	mov	edx, DWORD PTR [esi+556]
	mov	DWORD PTR [edx+eax*4], -1
	inc	eax
	cmp	eax, ecx
	jb	SHORT $LL191@CacheResul@40
$LN189@CacheResul@40:

; 2429 : 
; 2430 : 		std::string strKey = "Civilizations - FreeUnits";

	push	OFFSET $SG220165
	lea	ecx, DWORD PTR _strKey$220164[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2431 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	mov	ebp, DWORD PTR _kUtility$[esp+120]
	lea	eax, DWORD PTR _strKey$220164[esp+124]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+136], 6
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 2432 : 		if(pResults == NULL)

	test	edi, edi
	jne	SHORT $LN6@CacheResul@40

; 2433 : 		{
; 2434 : 			pResults = kUtility.PrepareResults(strKey, "select UnitClasses.ID as UnitClassID, UnitAIInfos.ID as UnitAITypeID, Count from Civilization_FreeUnits inner join UnitClasses on UnitClassType = UnitClasses.Type inner join UnitAIInfos on UnitAIType = UnitAIInfos.Type where CivilizationType = ?");

	push	OFFSET $SG220168
	lea	ecx, DWORD PTR _strKey$220164[esp+128]
	push	ecx
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax
$LN6@CacheResul@40:

; 2435 : 		}
; 2436 : 
; 2437 : 		pResults->Bind(1, szType, -1, false);

	mov	edx, DWORD PTR _szType$[esp+120]
	push	0
	push	-1
	push	edx
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 2438 : 
; 2439 : 		while(pResults->Step())

	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN4@CacheResul@40
$LL5@CacheResul@40:

; 2440 : 		{
; 2441 : 			const int iUnitClassID = pResults->GetInt(0);

	push	0
	mov	ecx, edi
	call	ebx

; 2442 : 			const int iUnitAITypeID = pResults->GetInt(1);

	push	1
	mov	ecx, edi
	mov	DWORD PTR _iUnitClassID$220172[esp+124], eax
	call	ebx

; 2443 : 			const int iCount = pResults->GetInt(2);

	push	2
	mov	ecx, edi
	mov	DWORD PTR _iUnitAITypeID$220173[esp+128], eax
	call	ebx

; 2444 : 
; 2445 : 			m_piCivilizationFreeUnitsClass[iUnitClassID] = iCount;

	mov	edx, DWORD PTR [esi+552]
	mov	ecx, DWORD PTR _iUnitClassID$220172[esp+120]
	mov	DWORD PTR [edx+ecx*4], eax

; 2446 : 			m_piCivilizationFreeUnitsDefaultUnitAI[iUnitClassID] = iUnitAITypeID;

	mov	eax, DWORD PTR [esi+556]
	mov	edx, DWORD PTR _iUnitAITypeID$220173[esp+124]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL5@CacheResul@40
$LN4@CacheResul@40:

; 2447 : 		}
; 2448 : 
; 2449 : 		pResults->Reset();

	mov	ecx, edi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 2450 : 
; 2451 : 	}

	lea	ecx, DWORD PTR _strKey$220164[esp+124]
	mov	DWORD PTR __$EHRec$[esp+132], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2452 : 
; 2453 : 	kUtility.PopulateArrayByExistence(m_pbCivilizationFreeBuildingClass,
; 2454 : 	                                  "BuildingClasses", "Civilization_FreeBuildingClasses",
; 2455 : 	                                  "BuildingClassType", "CivilizationType", szType);

	mov	edi, DWORD PTR _szType$[esp+120]
	push	edi
	push	OFFSET $SG220175
	push	OFFSET $SG220176
	push	OFFSET $SG220177
	push	OFFSET $SG220178
	lea	eax, DWORD PTR [esi+564]
	push	eax
	mov	ecx, ebp
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 2456 : 
; 2457 : 
; 2458 : 	kUtility.PopulateArrayByExistence(m_pbCivilizationFreeTechs, "Technologies",
; 2459 : 	                                  "Civilization_FreeTechs", "TechType",
; 2460 : 	                                  "CivilizationType", szType);

	push	edi
	push	OFFSET $SG220179
	push	OFFSET $SG220180
	push	OFFSET $SG220181
	push	OFFSET $SG220182
	lea	ecx, DWORD PTR [esi+568]
	push	ecx
	mov	ecx, ebp
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 2461 : 
; 2462 : 
; 2463 : 	kUtility.PopulateArrayByExistence(m_pbCivilizationDisableTechs, "Technologies",
; 2464 : 	                                  "Civilization_DisableTechs", "TechType",
; 2465 : 	                                  "CivilizationType", szType);

	push	edi
	push	OFFSET $SG220183
	push	OFFSET $SG220184
	push	OFFSET $SG220185
	push	OFFSET $SG220186
	lea	edx, DWORD PTR [esi+572]
	push	edx
	mov	ecx, ebp
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 2466 : 
; 2467 : 
; 2468 : 	kUtility.PopulateArrayByExistence(m_pbLeaders, "Leaders", "Civilization_Leaders",
; 2469 : 	                                  "LeaderheadType", "CivilizationType", szType);

	push	edi
	push	OFFSET $SG220187
	push	OFFSET $SG220188
	push	OFFSET $SG220189
	push	OFFSET $SG220190
	lea	eax, DWORD PTR [esi+560]
	push	eax
	mov	ecx, ebp
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 2470 : 
; 2471 : 	kUtility.PopulateArrayByExistence(m_pbReligions, "Religions", "Civilization_Religions",
; 2472 : 	                                  "ReligionType", "CivilizationType", szType);

	push	edi
	push	OFFSET $SG220191
	push	OFFSET $SG220192
	push	OFFSET $SG220193
	push	OFFSET $SG220194
	lea	ecx, DWORD PTR [esi+576]
	push	ecx
	mov	ecx, ebp
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 2473 : 
; 2474 : 	//Spy Names
; 2475 : 	{
; 2476 : 		m_vSpyNames.clear();

	mov	eax, DWORD PTR [esi+608]
	mov	ecx, DWORD PTR [esi+604]
	lea	ebx, DWORD PTR [esi+600]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T249806[esp+128]
	push	edx
	mov	ecx, ebx
	call	?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ; std::vector<CvString,std::allocator<CvString> >::erase

; 2477 : 
; 2478 : 		std::string strKey = "Civilization - SpyNames";

	push	OFFSET $SG220196
	lea	ecx, DWORD PTR _strKey$220195[esp+128]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2479 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$220195[esp+124]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+136], 7
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	esi, eax

; 2480 : 		if(pResults == NULL)

	test	esi, esi
	jne	SHORT $LN3@CacheResul@40

; 2481 : 		{
; 2482 : 			pResults = kUtility.PrepareResults(strKey, "select SpyName from Civilization_SpyNames where CivilizationType = ?");

	push	OFFSET $SG220199
	lea	ecx, DWORD PTR _strKey$220195[esp+128]
	push	ecx
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	esi, eax
$LN3@CacheResul@40:

; 2483 : 		}
; 2484 : 
; 2485 : 		pResults->Bind(1, szType, -1, false);

	push	0
	push	-1
	push	edi
	push	1
	mov	ecx, esi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 2486 : 
; 2487 : 		while(pResults->Step())

	mov	edi, DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	mov	ecx, esi
	call	edi
	pop	ebp
	test	al, al
	je	SHORT $LN1@CacheResul@40
	npad	6
$LL2@CacheResul@40:

; 2488 : 		{
; 2489 : 			m_vSpyNames.push_back(pResults->GetText(0));

	push	0
	mov	ecx, esi
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDH@Z
	test	eax, eax
	jne	SHORT $LN213@CacheResul@40
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN213@CacheResul@40:
	push	eax
	lea	ecx, DWORD PTR $T249263[esp+124]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR $T249263[esp+120]
	push	edx
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+132], 8
	call	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
	lea	ecx, DWORD PTR $T249263[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	edi
	test	al, al
	jne	SHORT $LL2@CacheResul@40
$LN1@CacheResul@40:

; 2490 : 		}
; 2491 : 
; 2492 : 		pResults->Reset();

	mov	ecx, esi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 2493 : 	}

	lea	ecx, DWORD PTR _strKey$220195[esp+120]
	mov	DWORD PTR __$EHRec$[esp+128], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2494 : 
; 2495 : 	return true;
; 2496 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+120]
	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 108				; 0000006cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _strKey$220117[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _strKey$220125[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2:
	lea	ecx, DWORD PTR _strKey$220133[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3:
	lea	ecx, DWORD PTR $T249260[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4:
	lea	ecx, DWORD PTR _key$220142[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5:
	lea	ecx, DWORD PTR _key$220153[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6:
	lea	ecx, DWORD PTR _strKey$220164[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$7:
	lea	ecx, DWORD PTR _strKey$220195[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$8:
	lea	ecx, DWORD PTR $T249263[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvCivilizationInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvCivilizationInfo::CacheResults
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::clear
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T249904 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;
; 672  : 
; 673  : 		if (size() == 0)

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN32@insert@6

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	eax, DWORD PTR __Val$[esp+12]
	mov	ecx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	push	eax
	push	ecx
	push	1
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Insert
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN32@insert@6:

; 675  : 		else if (this->_Multi)
; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())
; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,
; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 682  : 				}
; 683  : 			else if (_Where == end())
; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,
; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));
; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,
; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))
; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 696  : 				else
; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,
; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,
; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))
; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 707  : 				else
; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 709  : 				}
; 710  : 			}
; 711  : 		else
; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	esi, DWORD PTR __Val$[esp+12]
	push	ebx
	mov	ebx, DWORD PTR __Where$[esp+16]
	push	ebp
	cmp	ebx, DWORD PTR [eax]
	jne	SHORT $LN14@insert@6
	mov	edx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [ebx+12]
	jge	$LN1@insert@6

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN14@insert@6:

; 718  : 				}
; 719  : 			else if (_Where == end())

	cmp	ebx, eax
	jne	SHORT $LN11@insert@6

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR [esi]
	jge	$LN1@insert@6

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	eax
	push	0
	push	esi
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN11@insert@6:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,
; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	ebp, DWORD PTR [esi]
	cmp	DWORD PTR [ebx+12], ebp
	jle	SHORT $LN305@insert@6
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	DWORD PTR [eax+12], ebp
	jge	SHORT $LN8@insert@6

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+33], 0

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN7@insert@6
	push	eax
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN7@insert@6:

; 732  : 				else
; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	ebx
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN8@insert@6:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,
; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

	cmp	DWORD PTR [ebx+12], ebp
$LN305@insert@6:
	jge	SHORT $LN1@insert@6
	lea	ecx, DWORD PTR __Next$[esp+20]
	mov	DWORD PTR __Next$[esp+20], ebx
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::const_iterator::_Inc
	mov	eax, DWORD PTR __Next$[esp+20]
	cmp	eax, DWORD PTR [edi+4]
	je	SHORT $LN3@insert@6
	cmp	ebp, DWORD PTR [eax+12]
	jge	SHORT $LN1@insert@6
$LN3@insert@6:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	ecx, DWORD PTR [ebx+8]
	cmp	BYTE PTR [ecx+33], 0

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	ecx, edi
	je	SHORT $LN2@insert@6
	push	ebx
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN2@insert@6:

; 743  : 				else
; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	push	eax
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Insert
	pop	ebp
	pop	ebx
	pop	edi
	mov	eax, esi
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
$LN1@insert@6:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	push	esi
	lea	edx, DWORD PTR $T249904[esp+28]
	push	edx
	mov	ecx, edi
	call	?insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 749  : 		}

	add	esp, 8
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Copy
; Function compile flags: /Ogtpy
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	ebx, DWORD PTR __Right$[esp]
	mov	eax, DWORD PTR [ebx+4]
	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, DWORD PTR [esi+4]
	add	eax, 4
	mov	eax, DWORD PTR [eax]
	push	edi
	push	eax
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Copy
	mov	DWORD PTR [edi+4], eax

; 1064 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR [ebx+8]

; 1065 : 		if (!_Isnil(_Root()))

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], ecx
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN2@Copy@2

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN25@Copy@2
$LL26@Copy@2:
	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LL26@Copy@2
$LN25@Copy@2:
	mov	DWORD PTR [edx], eax

; 1068 : 			_Rmost() = _Max(_Root());

	mov	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN43@Copy@2
$LL44@Copy@2:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL44@Copy@2
$LN43@Copy@2:
	pop	edi
	mov	DWORD PTR [esi+8], ecx
	pop	esi
	pop	ebx

; 1072 : 		}

	ret	4
$LN2@Copy@2:

; 1069 : 			}
; 1070 : 		else
; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	DWORD PTR [edx], edx
	mov	esi, DWORD PTR [esi+4]
	pop	edi
	mov	DWORD PTR [esi+8], esi
	pop	esi
	pop	ebx

; 1072 : 		}

	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Copy
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T250561 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN101@erase@6
	cmp	edx, eax
	jne	SHORT $LN101@erase@6

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN101@erase@6:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	cmp	ecx, edx
	je	SHORT $LN1@erase@6
	npad	2
$LL2@erase@6:

; 943  : 				erase(_First++);

	cmp	BYTE PTR [ecx+33], 0
	mov	edx, ecx
	jne	SHORT $LN65@erase@6
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN103@erase@6
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN79@erase@6
	npad	5
$LL80@erase@6:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL80@erase@6
$LN79@erase@6:
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LN65@erase@6
$LN103@erase@6:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN63@erase@6
	npad	7
$LL64@erase@6:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN63@erase@6
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+4], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL64@erase@6
$LN63@erase@6:
	mov	DWORD PTR __First$[esp+4], eax
$LN65@erase@6:
	push	edx
	lea	eax, DWORD PTR $T250561[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::erase
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR __Last$[esp+4]
	jne	SHORT $LL2@erase@6
$LN1@erase@6:

; 944  : 			return (_Make_iter(_First));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::erase
_TEXT	ENDS
PUBLIC	??A?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAEAAV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@ABH@Z ; std::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::operator[]
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??A?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAEAAV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@ABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAEAAV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@ABH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAEAAV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@ABH@Z$1
__ehfuncinfo$??A?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAEAAV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@ABH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??A?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAEAAV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@ABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
xdata$x	ENDS
;	COMDAT ??A?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAEAAV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@ABH@Z
_TEXT	SEGMENT
$T250882 = -48						; size = 16
$T250881 = -32						; size = 20
__$EHRec$ = -12						; size = 12
$T250884 = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAEAAV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@ABH@Z PROC ; std::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::operator[], COMDAT
; _this$ = ecx

; 168  : 		{	// find element matching _Keyval or insert with default mapped

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??A?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAEAAV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@ABH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [ecx+4]
	xor	ebx, ebx
	mov	esi, ecx
	mov	ecx, DWORD PTR __Keyval$[esp+56]
	cmp	BYTE PTR [eax+33], bl
	jne	SHORT $LN11@operator@14
	mov	edx, DWORD PTR [ecx]
$LL12@operator@14:
	cmp	DWORD PTR [eax+12], edx
	jge	SHORT $LN10@operator@14
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN9@operator@14
$LN10@operator@14:
	mov	esi, eax
	mov	eax, DWORD PTR [eax]
$LN9@operator@14:
	cmp	BYTE PTR [eax+33], bl
	je	SHORT $LL12@operator@14
$LN11@operator@14:

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN1@operator@14
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [esi+12]
	jge	SHORT $LN119@operator@14
$LN1@operator@14:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	DWORD PTR $T250882[esp+64], ebx
	mov	DWORD PTR $T250882[esp+68], ebx
	mov	DWORD PTR $T250882[esp+72], ebx
	mov	ecx, DWORD PTR [ecx]
	lea	edx, DWORD PTR $T250882[esp+60]
	mov	DWORD PTR $T250881[esp+60], ecx
	push	edx
	lea	ecx, DWORD PTR $T250881[esp+68]
	mov	DWORD PTR __$EHRec$[esp+72], ebx
	call	??0?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@ABV01@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
	lea	eax, DWORD PTR $T250881[esp+60]
	push	eax
	push	esi
	lea	ecx, DWORD PTR $T250884[esp+64]
	push	ecx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+80], 1
	call	?insert@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::insert
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR $T250881[esp+68]
	cmp	eax, ebx
	je	SHORT $LN119@operator@14
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN119@operator@14:

; 174  : 		return ((*_Where).second);
; 175  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	edi
	lea	eax, DWORD PTR [esi+16]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAEAAV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@ABH@Z$0:
	lea	ecx, DWORD PTR $T250882[ebp]
	jmp	??1?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@XZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::~vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
__unwindfunclet$??A?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAEAAV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@ABH@Z$1:
	lea	ecx, DWORD PTR $T250881[ebp]
	jmp	??1?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??A?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAEAAV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@ABH@Z:
	mov	eax, OFFSET __ehfuncinfo$??A?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAEAAV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@ABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??A?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAEAAV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@ABH@Z ENDP ; std::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::operator[]
PUBLIC	??4?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T251249 = 8						; size = 4
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	esi
	push	edi

; 545  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN20@operator@15

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T251249[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Copy
$LN20@operator@15:
	pop	edi

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, esi
	pop	esi

; 552  : 		}

	ret	4
??4?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::operator=
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T251303 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T251303[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1427 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi

; 529  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 530  : 		_TRY_BEGIN
; 531  : 		_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Copy

; 535  : 		_CATCH_END
; 536  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN57@Tree:
$LN56@Tree:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T251623 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 540  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T251623[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 541  : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::~_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
_TEXT	ENDS
PUBLIC	?swap@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::swap
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z DD 0ffffffffH
	DD	00H
__ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?swap@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?swap@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::swap, COMDAT
; _this$ = ecx

; 1033 : 		{	// exchange contents with _Right

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi

; 1034 : 		if (this == &_Right)

	mov	esi, DWORD PTR __Right$[esp+16]
	push	edi
	cmp	ecx, esi
	je	SHORT $LN23@swap@4

; 1035 : 			;	// same object, do nothing
; 1036 : 		else if (get_allocator() == _Right.get_allocator())
; 1037 : 			{	// same allocator, swap control information
; 1038 : 
; 1039 :  #if _HAS_ITERATOR_DEBUGGING
; 1040 : 			this->_Swap_all(_Right);
; 1041 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1042 : 
; 1043 : 			this->_Swap_aux(_Right);
; 1044 : 
; 1045 : 			_STD _Swap_adl(this->comp, _Right.comp);
; 1046 : 			_STD swap(_Myhead, _Right._Myhead);

	lea	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	je	SHORT $LN20@swap@4
	mov	ebx, DWORD PTR [eax]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [edx], ebx
	mov	DWORD PTR [eax], edi
$LN20@swap@4:

; 1047 : 			_STD swap(_Mysize, _Right._Mysize);

	lea	eax, DWORD PTR [esi+8]
	add	ecx, 8
	cmp	ecx, eax
	je	SHORT $LN23@swap@4
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
$LN23@swap@4:

; 1048 : 			}
; 1049 : 		else
; 1050 : 			{	// different allocator, do multiple assigns
; 1051 : 			this->_Swap_aux(_Right);
; 1052 : 
; 1053 : 			_Myt _Tmp = *this;
; 1054 : 
; 1055 : 			*this = _Right;
; 1056 : 			_Right = _Tmp;
; 1057 : 			}
; 1058 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?swap@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::swap
PUBLIC	??1?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::~map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T252087 = -4						; size = 4
??1?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::~map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T252087[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ecx
	ret	0
??1?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::~map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >
_TEXT	ENDS
PUBLIC	??_7CvResourceInfo@@6B@				; CvResourceInfo::`vftable'
PUBLIC	??1CvResourceInfo@@UAE@XZ			; CvResourceInfo::~CvResourceInfo
PUBLIC	??_R4CvResourceInfo@@6B@			; CvResourceInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvResourceInfo@@@8			; CvResourceInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvResourceInfo@@8				; CvResourceInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvResourceInfo@@8				; CvResourceInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvResourceInfo@@8			; CvResourceInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvResourceInfo::CacheResults
EXTRN	??_ECvResourceInfo@@UAEPAXI@Z:PROC		; CvResourceInfo::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvResourceInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvResourceInfo@@8 DD FLAT:??_R0?AVCvResourceInfo@@@8 ; CvResourceInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvResourceInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvResourceInfo@@8
rdata$r	SEGMENT
??_R2CvResourceInfo@@8 DD FLAT:??_R1A@?0A@EA@CvResourceInfo@@8 ; CvResourceInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvResourceInfo@@8
rdata$r	SEGMENT
??_R3CvResourceInfo@@8 DD 00H				; CvResourceInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvResourceInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvResourceInfo@@@8
_DATA	SEGMENT
??_R0?AVCvResourceInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvResourceInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvResourceInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvResourceInfo@@6B@
rdata$r	SEGMENT
??_R4CvResourceInfo@@6B@ DD 00H				; CvResourceInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvResourceInfo@@@8
	DD	FLAT:??_R3CvResourceInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvResourceInfo@@6B@
CONST	SEGMENT
??_7CvResourceInfo@@6B@ DD FLAT:??_R4CvResourceInfo@@6B@ ; CvResourceInfo::`vftable'
	DD	FLAT:?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvResourceInfo@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvResourceInfo@@UAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvResourceInfo@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvResourceInfo@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvResourceInfo@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvResourceInfo@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvResourceInfo@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvResourceInfo@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvResourceInfo@@UAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvResourceInfo@@UAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvResourceInfo@@UAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvResourceInfo@@UAE@XZ$7
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??1CvResourceInfo@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T252439 = -16						; size = 4
$T252227 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvResourceInfo@@UAE@XZ PROC				; CvResourceInfo::~CvResourceInfo, COMDAT
; _this$ = ecx

; 4372 : {

	push	-1
	push	__ehhandler$??1CvResourceInfo@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+36], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvResourceInfo@@6B@

; 4373 : 	SAFE_DELETE_ARRAY(m_piYieldChange);

	mov	eax, DWORD PTR [esi+528]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+48], 7
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+528], ebx

; 4374 : #if defined(MOD_RESOURCES_PRODUCTION_COST_MODIFIERS)
; 4375 : 	m_piiiUnitCombatProductionCostModifiersLocal.clear();

	mov	eax, DWORD PTR [esi+536]
	mov	ecx, DWORD PTR [eax+4]
	lea	edi, DWORD PTR [esi+532]
	add	esp, 4
	push	ecx
	mov	ecx, edi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Erase
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edi+8], ebx
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [edi+4]

; 4376 : 	m_aiiiBuildingProductionCostModifiersLocal.clear();

	lea	ebp, DWORD PTR [esi+544]
	mov	DWORD PTR [eax+8], eax
	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebp+4]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T252227[esp+44]
	push	edx
	mov	ecx, ebp
	call	?erase@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE?AV?$_Vector_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@V?$_Vector_const_iterator@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@2@0@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::erase

; 4377 : #endif
; 4378 : 	SAFE_DELETE_ARRAY(m_piResourceQuantityTypes);

	mov	eax, DWORD PTR [esi+560]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+560], ebx

; 4379 : 	SAFE_DELETE_ARRAY(m_piFlavor);

	mov	eax, DWORD PTR [esi+568]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+568], ebx

; 4380 : 	SAFE_DELETE_ARRAY(m_piImprovementChange);

	mov	eax, DWORD PTR [esi+564]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+564], ebx

; 4381 : 	SAFE_DELETE_ARRAY(m_pbTerrain);

	mov	eax, DWORD PTR [esi+572]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+572], ebx

; 4382 : 	SAFE_DELETE_ARRAY(m_pbFeature);

	mov	eax, DWORD PTR [esi+576]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+576], ebx

; 4383 : 	SAFE_DELETE_ARRAY(m_pbFeatureTerrain);	// free memory - MT

	mov	eax, DWORD PTR [esi+580]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+580], ebx

; 4384 : }

	mov	eax, DWORD PTR [ebp+4]
	add	esp, 24					; 00000018H
	cmp	eax, ebx
	je	SHORT $LN62@CvResource
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN62@CvResource:
	mov	DWORD PTR [ebp+4], ebx
	mov	DWORD PTR [ebp+8], ebx
	mov	DWORD PTR [ebp+12], ebx
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T252439[esp+44]
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+56], 5
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::erase
	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	lea	ecx, DWORD PTR [esi+500]
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi+8], ebx
	mov	BYTE PTR __$EHRec$[esp+44], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+472]
	mov	BYTE PTR __$EHRec$[esp+44], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+444]
	mov	BYTE PTR __$EHRec$[esp+44], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+416]
	mov	BYTE PTR __$EHRec$[esp+44], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+388]
	mov	BYTE PTR __$EHRec$[esp+44], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+44], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvResourceInfo@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvResourceInfo@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388				; 00000184H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvResourceInfo@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvResourceInfo@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvResourceInfo@@UAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 472				; 000001d8H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvResourceInfo@@UAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 500				; 000001f4H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvResourceInfo@@UAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	jmp	??1?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??1CvResourceInfo@@UAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 544				; 00000220H
	jmp	??1?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAE@XZ ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::~vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >
__ehhandler$??1CvResourceInfo@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvResourceInfo@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvResourceInfo@@UAE@XZ ENDP				; CvResourceInfo::~CvResourceInfo
PUBLIC	??0?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z ; std::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
	mov	eax, esi
	pop	esi
	ret	4
??0?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >
_TEXT	ENDS
PUBLIC	??0?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >, COMDAT
; _this$ = ecx

; 103  : 		{	// construct empty map from defaults

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 104  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >
_TEXT	ENDS
PUBLIC	??0CvResourceInfo@@QAE@XZ			; CvResourceInfo::CvResourceInfo
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__ehfuncinfo$??0CvResourceInfo@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0CvResourceInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvResourceInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvResourceInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvResourceInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvResourceInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvResourceInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvResourceInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvResourceInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvResourceInfo@@QAE@XZ$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ??0CvResourceInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvResourceInfo@@QAE@XZ PROC				; CvResourceInfo::CvResourceInfo, COMDAT
; _this$ = ecx

; 4368 : {

	push	-1
	push	__ehhandler$??0CvResourceInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	ebx, ebx
	or	eax, -1
	lea	ecx, DWORD PTR [esi+388]
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	mov	DWORD PTR [esi], OFFSET ??_7CvResourceInfo@@6B@
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], ebx
	mov	DWORD PTR [esi+268], ebx
	mov	DWORD PTR [esi+272], eax
	mov	DWORD PTR [esi+276], ebx
	mov	DWORD PTR [esi+280], ebx
	mov	DWORD PTR [esi+284], eax
	mov	DWORD PTR [esi+288], ebx
	mov	DWORD PTR [esi+292], ebx
	mov	DWORD PTR [esi+296], ebx
	mov	DWORD PTR [esi+300], ebx
	mov	DWORD PTR [esi+304], ebx
	mov	DWORD PTR [esi+308], ebx
	mov	DWORD PTR [esi+312], ebx
	mov	DWORD PTR [esi+316], ebx
	mov	DWORD PTR [esi+320], ebx
	mov	DWORD PTR [esi+324], ebx
	mov	DWORD PTR [esi+328], ebx
	mov	DWORD PTR [esi+332], ebx
	mov	DWORD PTR [esi+336], ebx
	mov	DWORD PTR [esi+340], ebx
	mov	DWORD PTR [esi+344], ebx
	mov	DWORD PTR [esi+348], ebx
	mov	DWORD PTR [esi+352], ebx
	mov	DWORD PTR [esi+356], ebx
	mov	DWORD PTR [esi+360], ebx
	mov	DWORD PTR [esi+364], ebx
	mov	BYTE PTR [esi+368], bl
	mov	BYTE PTR [esi+369], bl
	mov	BYTE PTR [esi+370], bl
	mov	BYTE PTR [esi+371], bl
	mov	BYTE PTR [esi+372], bl
	mov	BYTE PTR [esi+373], bl
	mov	BYTE PTR [esi+374], bl
	mov	DWORD PTR [esi+376], eax
	mov	DWORD PTR [esi+380], ebx
	mov	DWORD PTR [esi+384], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+416]
	mov	BYTE PTR __$EHRec$[esp+36], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+444]
	mov	BYTE PTR __$EHRec$[esp+36], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+472]
	mov	BYTE PTR __$EHRec$[esp+36], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+500]
	mov	BYTE PTR __$EHRec$[esp+36], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	edi, DWORD PTR [esi+532]
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+36], 5
	mov	DWORD PTR [esi+528], ebx
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Buynode
	mov	DWORD PTR [edi+4], eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [edi+8], ebx

; 4369 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi+548], ebx
	mov	DWORD PTR [esi+552], ebx
	mov	DWORD PTR [esi+556], ebx
	mov	DWORD PTR [esi+560], ebx
	mov	DWORD PTR [esi+564], ebx
	mov	DWORD PTR [esi+568], ebx
	mov	DWORD PTR [esi+572], ebx
	mov	DWORD PTR [esi+576], ebx
	mov	DWORD PTR [esi+580], ebx
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvResourceInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvResourceInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388				; 00000184H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvResourceInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvResourceInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvResourceInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 472				; 000001d8H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvResourceInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 500				; 000001f4H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvResourceInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	jmp	??1?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__ehhandler$??0CvResourceInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvResourceInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvResourceInfo@@QAE@XZ ENDP				; CvResourceInfo::CvResourceInfo
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvResourceInfo@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvResourceInfo@@UAEPAXI@Z PROC			; CvResourceInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvResourceInfo@@UAE@XZ		; CvResourceInfo::~CvResourceInfo
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@25
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@25:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvResourceInfo@@UAEPAXI@Z ENDP			; CvResourceInfo::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3
__ehfuncinfo$?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_sElement$221946 = -668					; size = 12
$T253183 = -668						; size = 12
_sElement$221915 = -668					; size = 12
$T253423 = -656						; size = 4
_iUnitCombat$221911 = -656				; size = 4
_iObsoleteEra$221913 = -652				; size = 4
_iRequiredEra$221912 = -648				; size = 4
_sqlKey$221902 = -644					; size = 28
_sqlKey$221934 = -616					; size = 28
_kArrayResults$221893 = -588				; size = 64
_szQuery$221894 = -524					; size = 512
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvResourceInfo::CacheResults, COMDAT
; _this$ = ecx

; 4792 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax

; 4793 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 656				; 00000290H
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+672]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	je	$LN11@CacheResul@41
$LN10@CacheResul@41:
	push	ebx
	push	ebp

; 4794 : 		return false;
; 4795 : 
; 4796 : 	//Basic properties
; 4797 : 	m_iStartingResourceQuantity = kResults.GetInt("StartingResourceQuantity");

	mov	ebp, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG221818
	mov	ecx, edi
	call	ebp

; 4798 : 	m_iAITradeModifier = kResults.GetInt("AITradeModifier");

	push	OFFSET $SG221819
	mov	ecx, edi
	mov	DWORD PTR [esi+288], eax
	call	ebp

; 4799 : 	m_iAIObjective = kResults.GetInt("AIObjective");

	push	OFFSET $SG221820
	mov	ecx, edi
	mov	DWORD PTR [esi+292], eax
	call	ebp

; 4800 : 	m_iHappiness = kResults.GetInt("Happiness");

	push	OFFSET $SG221821
	mov	ecx, edi
	mov	DWORD PTR [esi+296], eax
	call	ebp

; 4801 : 	m_iWonderProductionMod = kResults.GetInt("WonderProductionMod");

	push	OFFSET $SG221822
	mov	ecx, edi
	mov	DWORD PTR [esi+300], eax
	call	ebp

; 4802 : 
; 4803 : 	const char* szEraType = kResults.GetText("WonderProductionModObsoleteEra");

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG221824
	mov	ecx, edi
	mov	DWORD PTR [esi+304], eax
	call	ebx

; 4804 : 	m_eWonderProductionModObsoleteEra = (EraTypes)GC.getInfoTypeForString(szEraType, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4805 : 
; 4806 : 	m_iMinAreaSize = kResults.GetInt("MinAreaSize");

	push	OFFSET $SG221826
	mov	ecx, edi
	mov	DWORD PTR [esi+384], eax
	call	ebp

; 4807 : 	m_iMinLatitude = kResults.GetInt("MinLatitude");

	push	OFFSET $SG221827
	mov	ecx, edi
	mov	DWORD PTR [esi+308], eax
	call	ebp

; 4808 : 	m_iMaxLatitude = kResults.GetInt("MaxLatitude");

	push	OFFSET $SG221828
	mov	ecx, edi
	mov	DWORD PTR [esi+312], eax
	call	ebp

; 4809 : 	m_iPlacementOrder = kResults.GetInt("PlacementOrder");

	push	OFFSET $SG221829
	mov	ecx, edi
	mov	DWORD PTR [esi+316], eax
	call	ebp

; 4810 : 	m_iConstAppearance = kResults.GetInt("ConstAppearance");

	push	OFFSET $SG221830
	mov	ecx, edi
	mov	DWORD PTR [esi+320], eax
	call	ebp

; 4811 : 
; 4812 : 	m_iPercentPerPlayer = kResults.GetInt("Player");

	push	OFFSET $SG221831
	mov	ecx, edi
	mov	DWORD PTR [esi+324], eax
	call	ebp

; 4813 : 	m_iTilesPer = kResults.GetInt("TilesPer");

	push	OFFSET $SG221832
	mov	ecx, edi
	mov	DWORD PTR [esi+344], eax
	call	ebp

; 4814 : 	m_iMinLandPercent = kResults.GetInt("MinLandPercent");

	push	OFFSET $SG221833
	mov	ecx, edi
	mov	DWORD PTR [esi+348], eax
	call	ebp

; 4815 : 	m_iUniqueRange = kResults.GetInt("Unique");

	push	OFFSET $SG221834
	mov	ecx, edi
	mov	DWORD PTR [esi+352], eax
	call	ebp

; 4816 : 	m_iGroupRange = kResults.GetInt("GroupRange");

	push	OFFSET $SG221835
	mov	ecx, edi
	mov	DWORD PTR [esi+356], eax
	call	ebp

; 4817 : 	m_iGroupRand = kResults.GetInt("GroupRand");

	push	OFFSET $SG221836
	mov	ecx, edi
	mov	DWORD PTR [esi+360], eax
	call	ebp

; 4818 : 	m_bPresentOnAllValidPlots = kResults.GetBool("PresentOnAllValidPlots");

	push	OFFSET $SG221837
	mov	ecx, edi
	mov	DWORD PTR [esi+364], eax
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	BYTE PTR [esi+368], al

; 4819 : 	m_bOneArea = kResults.GetBool("Area");

	push	OFFSET $SG221838
	mov	ecx, edi
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 4820 : 	m_bHills = kResults.GetBool("Hills");

	push	OFFSET $SG221839
	mov	ecx, edi
	mov	BYTE PTR [esi+369], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 4821 : 	m_bFlatlands = kResults.GetBool("Flatlands");

	push	OFFSET $SG221840
	mov	ecx, edi
	mov	BYTE PTR [esi+370], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 4822 : 	m_bNoRiverSide = kResults.GetBool("NoRiverSide");

	push	OFFSET $SG221841
	mov	ecx, edi
	mov	BYTE PTR [esi+371], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 4823 : 	m_bNormalize = kResults.GetBool("Normalize");

	push	OFFSET $SG221842
	mov	ecx, edi
	mov	BYTE PTR [esi+372], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 4824 : 	m_bOnlyMinorCivs = kResults.GetBool("OnlyMinorCivs");

	push	OFFSET $SG221843
	mov	ecx, edi
	mov	BYTE PTR [esi+373], al
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 4825 : 
; 4826 : 	const char* szCivilizationType = kResults.GetText("CivilizationType");

	push	OFFSET $SG221845
	mov	ecx, edi
	mov	BYTE PTR [esi+374], al
	call	ebx

; 4827 : 	m_eRequiredCivilization = (CivilizationTypes)GC.getInfoTypeForString(szCivilizationType, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4828 : 
; 4829 : 	m_iRandAppearance1 = kResults.GetInt("RandApp1");

	push	OFFSET $SG221847
	mov	ecx, edi
	mov	DWORD PTR [esi+376], eax
	call	ebp

; 4830 : 	m_iRandAppearance2 = kResults.GetInt("RandApp2");

	push	OFFSET $SG221848
	mov	ecx, edi
	mov	DWORD PTR [esi+328], eax
	call	ebp

; 4831 : 	m_iRandAppearance3 = kResults.GetInt("RandApp3");

	push	OFFSET $SG221849
	mov	ecx, edi
	mov	DWORD PTR [esi+332], eax
	call	ebp

; 4832 : 	m_iRandAppearance4 = kResults.GetInt("RandApp4");

	push	OFFSET $SG221850
	mov	ecx, edi
	mov	DWORD PTR [esi+336], eax
	call	ebp

; 4833 : 
; 4834 : 	m_eResourceUsage   = (ResourceUsageTypes)kResults.GetInt("ResourceUsage");

	push	OFFSET $SG221852
	mov	ecx, edi
	mov	DWORD PTR [esi+340], eax
	call	ebp

; 4835 : 
; 4836 : 	//Basic references
; 4837 : 	const char* szResourceClassType = kResults.GetText("ResourceClassType");

	push	OFFSET $SG221854
	mov	ecx, edi
	mov	DWORD PTR [esi+380], eax
	call	ebx

; 4838 : 	m_iResourceClassType = GC.getInfoTypeForString(szResourceClassType, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4839 : 
; 4840 : 	const char* szIconString = kResults.GetText("IconString");

	push	OFFSET $SG221856
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 4841 : 	SetIconString(szIconString);

	lea	ecx, DWORD PTR [esi+388]
	test	eax, eax
	je	SHORT $LN20@CacheResul@41
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN19@CacheResul@41
$LN20@CacheResul@41:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN19@CacheResul@41:

; 4842 : 
; 4843 : 	const char* szArtDefineTag = kResults.GetText("ArtDefineTag");

	push	OFFSET $SG221858
	mov	ecx, edi
	call	ebx

; 4844 : 	setArtDefineTag(szArtDefineTag);

	lea	ecx, DWORD PTR [esi+416]
	test	eax, eax
	je	SHORT $LN26@CacheResul@41
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN25@CacheResul@41
$LN26@CacheResul@41:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN25@CacheResul@41:

; 4845 : 
; 4846 : 	const char* szArtDefineTagHeavy = kResults.GetText("ArtDefineTagHeavy");

	push	OFFSET $SG221860
	mov	ecx, edi
	call	ebx

; 4847 : 	setArtDefineTagHeavy(szArtDefineTagHeavy);

	lea	ecx, DWORD PTR [esi+444]
	test	eax, eax
	je	SHORT $LN32@CacheResul@41
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN31@CacheResul@41
$LN32@CacheResul@41:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN31@CacheResul@41:

; 4848 : 
; 4849 : 	const char* szAltArtDefineTag = kResults.GetText("AltArtDefineTag");

	push	OFFSET $SG221862
	mov	ecx, edi
	call	ebx

; 4850 : 	setAltArtDefineTag(szAltArtDefineTag);

	lea	ecx, DWORD PTR [esi+472]
	test	eax, eax
	je	SHORT $LN38@CacheResul@41
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN37@CacheResul@41
$LN38@CacheResul@41:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN37@CacheResul@41:

; 4851 : 
; 4852 : 	const char* szAltArtDefineTagHeavy = kResults.GetText("AltArtDefineTagHeavy");

	push	OFFSET $SG221864
	mov	ecx, edi
	call	ebx

; 4853 : 	setAltArtDefineTagHeavy(szAltArtDefineTagHeavy);

	lea	ecx, DWORD PTR [esi+500]
	test	eax, eax
	je	SHORT $LN44@CacheResul@41
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN43@CacheResul@41
$LN44@CacheResul@41:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN43@CacheResul@41:

; 4854 : 
; 4855 : 	const char* szTechReveal = kResults.GetText("TechReveal");

	push	OFFSET $SG221866
	mov	ecx, edi
	call	ebx

; 4856 : 	m_iTechReveal = GC.getInfoTypeForString(szTechReveal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4857 : 
; 4858 : 	const char* szPolicyReveal = kResults.GetText("PolicyReveal");

	push	OFFSET $SG221868
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 4859 : 	m_iPolicyReveal = GC.getInfoTypeForString(szPolicyReveal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4860 : 
; 4861 : 	const char* szTechCityTrade = kResults.GetText("TechCityTrade");

	push	OFFSET $SG221870
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebx

; 4862 : 	m_iTechCityTrade = GC.getInfoTypeForString(szTechCityTrade, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4863 : 
; 4864 : 	const char* szTechObsolete = kResults.GetText("TechObsolete");

	push	OFFSET $SG221872
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebx

; 4865 : 	m_iTechObsolete = GC.getInfoTypeForString(szTechObsolete, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4866 : 
; 4867 : 	const char* szAIStopTradingEra = kResults.GetText("AIStopTradingEra");

	push	OFFSET $SG221874
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebx

; 4868 : 	m_iAIStopTradingEra = GC.getInfoTypeForString(szAIStopTradingEra, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4869 : 
; 4870 : 	//Arrays
; 4871 : 	const char* szResourceType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+284], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 4872 : 	kUtility.SetYields(m_piYieldChange, "Resource_YieldChanges", "ResourceType", szResourceType);

	mov	ebx, DWORD PTR _kUtility$[esp+680]
	mov	ebp, eax
	push	ebp
	push	OFFSET $SG221876
	push	OFFSET $SG221877
	lea	ecx, DWORD PTR [esi+528]
	push	ecx
	mov	ecx, ebx
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 4873 : 	kUtility.SetFlavors(m_piFlavor, "Resource_Flavors", "ResourceType", szResourceType);

	push	0
	push	ebp
	push	OFFSET $SG221878
	push	OFFSET $SG221879
	lea	edx, DWORD PTR [esi+568]
	push	edx
	mov	ecx, ebx
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 4874 : 
; 4875 : 	kUtility.PopulateArrayByExistence(m_pbTerrain, "Terrains", "Resource_TerrainBooleans", "TerrainType", "ResourceType", szResourceType);

	push	ebp
	push	OFFSET $SG221880
	push	OFFSET $SG221881
	push	OFFSET $SG221882
	push	OFFSET $SG221883
	lea	eax, DWORD PTR [esi+572]
	push	eax
	mov	ecx, ebx
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 4876 : 	kUtility.PopulateArrayByExistence(m_pbFeature, "Features", "Resource_FeatureBooleans", "FeatureType", "ResourceType", szResourceType);

	push	ebp
	push	OFFSET $SG221884
	push	OFFSET $SG221885
	push	OFFSET $SG221886
	push	OFFSET $SG221887
	lea	ecx, DWORD PTR [esi+576]
	push	ecx
	mov	ecx, ebx
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 4877 : 	kUtility.PopulateArrayByExistence(m_pbFeatureTerrain, "Terrains", "Resource_FeatureTerrainBooleans", "TerrainType", "ResourceType", szResourceType);

	push	ebp
	push	OFFSET $SG221888
	push	OFFSET $SG221889
	push	OFFSET $SG221890
	push	OFFSET $SG221891
	lea	edx, DWORD PTR [esi+580]
	push	edx
	mov	ecx, ebx
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 4878 : 
; 4879 : 	//Resource_QuantityTypes
; 4880 : 	{
; 4881 : 		const int iNumQuantityTypes = GC.getNUM_RESOURCE_QUANTITY_TYPES();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7016

; 4882 : 		kUtility.InitializeArray(m_piResourceQuantityTypes, iNumQuantityTypes);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	xor	edi, edi
	push	edi
	push	eax
	mov	DWORD PTR [esi+560], eax
	call	_memset

; 4883 : 
; 4884 : 		//Default it to 1
; 4885 : 		m_piResourceQuantityTypes[0] = 1;

	mov	edx, DWORD PTR [esi+560]
	add	esp, 16					; 00000010H

; 4886 : 
; 4887 : 		Database::Results kArrayResults;

	push	edi
	lea	ecx, DWORD PTR _kArrayResults$221893[esp+688]
	mov	DWORD PTR [edx], 1
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z

; 4888 : 		char szQuery[512];
; 4889 : 		sprintf_s(szQuery, "select Quantity from Resource_QuantityTypes where ResourceType = '%s';", szResourceType);

	push	ebp
	lea	eax, DWORD PTR _szQuery$221894[esp+688]
	push	OFFSET $SG221895
	push	eax
	mov	DWORD PTR __$EHRec$[esp+704], edi
	call	??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ	; sprintf_s<512>
	add	esp, 12					; 0000000cH

; 4890 : 
; 4891 : 		if(DB.Execute(kArrayResults, szQuery))

	push	-1
	lea	ecx, DWORD PTR _szQuery$221894[esp+688]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	lea	edx, DWORD PTR _kArrayResults$221893[esp+692]
	push	edx
	call	DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z
	test	al, al
	je	SHORT $LN7@CacheResul@41

; 4892 : 		{
; 4893 : 			int i = 0;
; 4894 : 			while(kArrayResults.Step())

	lea	ecx, DWORD PTR _kArrayResults$221893[esp+684]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN7@CacheResul@41
	npad	4
$LL8@CacheResul@41:

; 4895 : 			{
; 4896 : 				CvAssertMsg(i < iNumQuantityTypes, "Too many resource quantities.");
; 4897 : 				const int quantity = kArrayResults.GetInt(0);

	push	0
	lea	ecx, DWORD PTR _kArrayResults$221893[esp+688]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 4898 : 				m_piResourceQuantityTypes[i++] = quantity;

	mov	ecx, DWORD PTR [esi+560]
	mov	DWORD PTR [edi+ecx], eax
	lea	ecx, DWORD PTR _kArrayResults$221893[esp+684]
	add	edi, 4
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL8@CacheResul@41
$LN7@CacheResul@41:

; 4899 : 			}
; 4900 : 		}
; 4901 : 
; 4902 : 	}

	lea	ecx, DWORD PTR _kArrayResults$221893[esp+684]
	mov	DWORD PTR __$EHRec$[esp+692], -1
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ

; 4903 : 
; 4904 : #if defined(MOD_RESOURCES_PRODUCTION_COST_MODIFIERS) // From Community Patch DLL - Resource additions for v28
; 4905 : 	//Resource_UnitCombatProductionCostModifiersLocal
; 4906 : 	{
; 4907 : 
; 4908 : 		std::string sqlKey = "Resource_UnitCombatProductionCostModifiersLocal";

	push	OFFSET $SG221903
	lea	ecx, DWORD PTR _sqlKey$221902[esp+688]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 4909 : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	edx, DWORD PTR _sqlKey$221902[esp+684]
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+696], 1
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 4910 : 		if (pResults == NULL)

	test	edi, edi
	jne	SHORT $LN6@CacheResul@41

; 4911 : 		{
; 4912 : 			const char* szSQL = "select UnitCombatInfos.ID as UnitCombatInfosID, RequiredEra, ObsoleteEra, CostModifier from Resource_UnitCombatProductionCostModifiersLocal inner join UnitCombatInfos on UnitCombatType = UnitCombatInfos.Type where ResourceType = ?";
; 4913 : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	push	OFFSET $SG221907
	lea	eax, DWORD PTR _sqlKey$221902[esp+688]
	push	eax
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax
$LN6@CacheResul@41:

; 4914 : 		}
; 4915 : 
; 4916 : 		pResults->Bind(1, szResourceType);

	push	1
	push	ebp
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 4917 : 
; 4918 : 		while (pResults->Step())

	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	$LN4@CacheResul@41
	npad	9
$LL5@CacheResul@41:

; 4919 : 		{
; 4920 : 			const int iUnitCombat = pResults->GetInt(0);

	push	0
	mov	ecx, edi
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 4921 : 			const int iRequiredEra = GC.getInfoTypeForString(pResults->GetText(1), true);

	push	1
	push	1
	mov	ecx, edi
	mov	DWORD PTR _iUnitCombat$221911[esp+692], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDH@Z
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4922 : 			const int iObsoleteEra = GC.getInfoTypeForString(pResults->GetText(2), true);

	push	1
	push	2
	mov	ecx, edi
	mov	DWORD PTR _iRequiredEra$221912[esp+692], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDH@Z
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4923 : 			const int iCostMod = pResults->GetInt(3);

	push	3
	mov	ecx, edi
	mov	DWORD PTR _iObsoleteEra$221913[esp+688], eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 4924 : 
; 4925 : 			ProductionCostModifiers sElement;
; 4926 : 			sElement.m_iRequiredEra = iRequiredEra;

	mov	ecx, DWORD PTR _iRequiredEra$221912[esp+684]

; 4927 : 			sElement.m_iObsoleteEra = iObsoleteEra;

	mov	edx, DWORD PTR _iObsoleteEra$221913[esp+684]

; 4928 : 			sElement.m_iCostModifier = iCostMod;

	mov	DWORD PTR _sElement$221915[esp+692], eax
	mov	DWORD PTR _sElement$221915[esp+684], ecx

; 4929 : 
; 4930 : 			m_piiiUnitCombatProductionCostModifiersLocal[iUnitCombat].push_back(sElement);

	lea	eax, DWORD PTR _sElement$221915[esp+684]
	push	eax
	lea	ecx, DWORD PTR _iUnitCombat$221911[esp+688]
	push	ecx
	lea	ecx, DWORD PTR [esi+532]
	mov	DWORD PTR _sElement$221915[esp+696], edx
	call	??A?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAEAAV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@1@ABH@Z ; std::map<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > > >::operator[]
	mov	ecx, eax
	call	?push_back@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEXABUProductionCostModifiers@@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::push_back
	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	$LL5@CacheResul@41
$LN4@CacheResul@41:

; 4931 : 		}
; 4932 : 
; 4933 : 		pResults->Reset();

	mov	ecx, edi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 4934 : 
; 4935 : 		//Trim extra memory off container since this is mostly read-only.
; 4936 : 		std::map<int, std::vector<ProductionCostModifiers>>(m_piiiUnitCombatProductionCostModifiersLocal).swap(m_piiiUnitCombatProductionCostModifiersLocal);

	lea	edi, DWORD PTR [esi+532]
	push	edi
	lea	ecx, DWORD PTR $T253183[esp+688]
	call	??0?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >
	push	edi
	lea	ecx, DWORD PTR $T253183[esp+688]
	mov	BYTE PTR __$EHRec$[esp+696], 2
	call	?swap@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::swap
	mov	eax, DWORD PTR $T253183[esp+688]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T253423[esp+692]
	push	edx
	lea	ecx, DWORD PTR $T253183[esp+696]
	mov	BYTE PTR __$EHRec$[esp+704], 1
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >,std::less<int>,std::allocator<std::pair<int const ,std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> > > >,0> >::erase
	mov	eax, DWORD PTR $T253183[esp+688]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 4937 : 	}

	lea	ecx, DWORD PTR _sqlKey$221902[esp+684]
	mov	DWORD PTR __$EHRec$[esp+692], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4938 : 
; 4939 : 	//Resource_BuildingProductionCostModifiersLocal
; 4940 : 		{
; 4941 : 
; 4942 : 			std::string sqlKey = "Resource_BuildingProductionCostModifiersLocal";

	push	OFFSET $SG221935
	lea	ecx, DWORD PTR _sqlKey$221934[esp+688]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 4943 : 			Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	ecx, DWORD PTR _sqlKey$221934[esp+684]
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+696], 3
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 4944 : 			if (pResults == NULL)

	test	edi, edi
	jne	SHORT $LN3@CacheResul@41

; 4945 : 			{
; 4946 : 				const char* szSQL = "select RequiredEra, ObsoleteEra, CostModifier from Resource_BuildingProductionCostModifiersLocal where ResourceType = ?";
; 4947 : 				pResults = kUtility.PrepareResults(sqlKey, szSQL);

	push	OFFSET $SG221939
	lea	edx, DWORD PTR _sqlKey$221934[esp+688]
	push	edx
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax
$LN3@CacheResul@41:

; 4948 : 			}
; 4949 : 
; 4950 : 			pResults->Bind(1, szResourceType);

	push	1
	push	ebp
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 4951 : 
; 4952 : 			while (pResults->Step())

	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN1@CacheResul@41
	lea	ebp, DWORD PTR [esi+544]
$LL2@CacheResul@41:

; 4953 : 			{
; 4954 : 				const int iRequiredEra = GC.getInfoTypeForString(pResults->GetText(0), true);

	mov	esi, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDH@Z
	push	1
	push	0
	mov	ecx, edi
	call	esi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4955 : 				const int iObsoleteEra = GC.getInfoTypeForString(pResults->GetText(1), true);

	push	1
	push	1
	mov	ecx, edi
	mov	ebx, eax
	call	esi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4956 : 				const int iCostMod = pResults->GetInt(2);

	push	2
	mov	ecx, edi
	mov	esi, eax
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 4957 : 
; 4958 : 				ProductionCostModifiers sElement;
; 4959 : 				sElement.m_iRequiredEra = iRequiredEra;
; 4960 : 				sElement.m_iObsoleteEra = iObsoleteEra;
; 4961 : 				sElement.m_iCostModifier = iCostMod;

	mov	DWORD PTR _sElement$221946[esp+692], eax

; 4962 : 
; 4963 : 				m_aiiiBuildingProductionCostModifiersLocal.push_back(sElement);

	lea	eax, DWORD PTR _sElement$221946[esp+684]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR _sElement$221946[esp+688], ebx
	mov	DWORD PTR _sElement$221946[esp+692], esi
	call	?push_back@?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@QAEXABUProductionCostModifiers@@@Z ; std::vector<ProductionCostModifiers,std::allocator<ProductionCostModifiers> >::push_back
	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL2@CacheResul@41
$LN1@CacheResul@41:

; 4964 : 			}
; 4965 : 
; 4966 : 			pResults->Reset();

	mov	ecx, edi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 4967 : 		}

	lea	ecx, DWORD PTR _sqlKey$221934[esp+684]
	mov	DWORD PTR __$EHRec$[esp+692], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	ebp

; 4968 : #endif
; 4969 : 
; 4970 : 	return true;

	mov	al, 1
	pop	ebx
$LN11@CacheResul@41:

; 4971 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+676]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 668				; 0000029cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _kArrayResults$221893[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__unwindfunclet$?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _sqlKey$221902[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2:
	lea	ecx, DWORD PTR $T253183[ebp]
	jmp	??1?$map@HV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$vector@UProductionCostModifiers@@V?$allocator@UProductionCostModifiers@@@std@@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3:
	lea	ecx, DWORD PTR _sqlKey$221934[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvResourceInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvResourceInfo::CacheResults
END
