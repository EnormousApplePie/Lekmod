; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvEconomicAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG225666 DB	'NoMinorCivs', 00H
$SG225667 DB	'CheckTriggerTurnCount', 00H
$SG226930 DB	00H
$SG226931 DB	00H
$SG225668 DB	'MinimumNumTurnsExecuted', 00H
$SG225669 DB	'WeightThreshold', 00H
$SG225670 DB	'FirstTurnExecuted', 00H
	ORG $+2
$SG225672 DB	'Advisor', 00H
$SG225675 DB	'MILITARY', 00H
	ORG $+3
$SG225678 DB	'ECONOMIC', 00H
	ORG $+3
$SG225681 DB	'FOREIGN', 00H
$SG225684 DB	'SCIENCE', 00H
$SG225685 DB	'AdvisorCounsel', 00H
	ORG $+1
$SG225686 DB	'AdvisorCounselImportance', 00H
	ORG $+3
$SG225688 DB	'TechPrereq', 00H
	ORG $+1
$SG225689 DB	'TechObsolete', 00H
	ORG $+3
$SG225691 DB	'AIEconomicStrategyType', 00H
	ORG $+1
$SG225692 DB	'AIEconomicStrategy_Player_Flavors', 00H
	ORG $+2
$SG225693 DB	'AIEconomicStrategyType', 00H
	ORG $+1
$SG225694 DB	'AIEconomicStrategy_City_Flavors', 00H
$SG225695 DB	'AIEconomicStrategyType', 00H
	ORG $+1
$SG225696 DB	'AIEconomicStrategy_PersonalityFlavorThresholdMods', 00H
	ORG $+2
$SG226226 DB	'ECONOMICAISTRATEGY_NEED_RECON', 00H
	ORG $+2
$SG226229 DB	'ECONOMICAISTRATEGY_ENOUGH_RECON', 00H
$SG226232 DB	'ECONOMICAISTRATEGY_REALLY_NEED_RECON_SEA', 00H
	ORG $+3
$SG226235 DB	'ECONOMICAISTRATEGY_NEED_RECON_SEA', 00H
	ORG $+2
$SG226238 DB	'ECONOMICAISTRATEGY_ENOUGH_RECON_SEA', 00H
$SG226241 DB	'ECONOMICAISTRATEGY_EARLY_EXPANSION', 00H
	ORG $+1
$SG226244 DB	'ECONOMICAISTRATEGY_ENOUGH_EXPANSION', 00H
$SG226247 DB	'ECONOMICAISTRATEGY_NEED_HAPPINESS', 00H
	ORG $+2
$SG226250 DB	'ECONOMICAISTRATEGY_NEED_HAPPINESS_CRITICAL', 00H
	ORG $+1
$SG226253 DB	'ECONOMICAISTRATEGY_CITIES_NEED_NAVAL_GROWTH', 00H
$SG226256 DB	'ECONOMICAISTRATEGY_CITIES_NEED_NAVAL_TILE_IMPROVEMENT', 00H
	ORG $+2
$SG226259 DB	'ECONOMICAISTRATEGY_FOUND_CITY', 00H
	ORG $+2
$SG226262 DB	'ECONOMICAISTRATEGY_TRADE_WITH_CITY_STATE', 00H
	ORG $+3
$SG226265 DB	'ECONOMICAISTRATEGY_NEED_IMPROVEMENT_FOOD', 00H
	ORG $+3
$SG226268 DB	'ECONOMICAISTRATEGY_NEED_IMPROVEMENT_PRODUCTION', 00H
	ORG $+1
$SG226271 DB	'ECONOMICAISTRATEGY_ONE_OR_FEWER_COASTAL_CITIES', 00H
	ORG $+1
$SG226274 DB	'ECONOMICAISTRATEGY_LOSING_MONEY', 00H
$SG226277 DB	'ECONOMICAISTRATEGY_HALT_GROWTH_BUILDINGS', 00H
	ORG $+3
$SG226280 DB	'ECONOMICAISTRATEGY_TOO_MANY_UNITS', 00H
	ORG $+2
$SG226283 DB	'ECONOMICAISTRATEGY_ISLAND_START', 00H
$SG226286 DB	'ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS', 00H
	ORG $+2
$SG226289 DB	'ECONOMICAISTRATEGY_REALLY_EXPAND_TO_OTHER_CONTINENTS', 00H
	ORG $+3
$SG226292 DB	'ECONOMICAISTRATEGY_MOSTLY_ON_THE_COAST', 00H
	ORG $+1
$SG226295 DB	'ECONOMICAISTRATEGY_EXPAND_LIKE_CRAZY', 00H
	ORG $+3
$SG226298 DB	'ECONOMICAISTRATEGY_GROW_LIKE_CRAZY', 00H
	ORG $+1
$SG226301 DB	'ECONOMICAISTRATEGY_GS_CULTURE', 00H
	ORG $+2
$SG226304 DB	'ECONOMICAISTRATEGY_GS_CONQUEST', 00H
	ORG $+1
$SG226307 DB	'ECONOMICAISTRATEGY_GS_DIPLOMACY', 00H
$SG226310 DB	'ECONOMICAISTRATEGY_GS_SPACESHIP', 00H
$SG226313 DB	'ECONOMICAISTRATEGY_GS_SPACESHIP_HOMESTRETCH', 00H
$SG226316 DB	'ECONOMICAISTRATEGY_NAVAL_MAP', 00H
	ORG $+3
$SG226319 DB	'ECONOMICAISTRATEGY_OFFSHORE_EXPANSION_MAP', 00H
	ORG $+2
$SG226322 DB	'ECONOMICAISTRATEGY_DEVELOPING_RELIGION', 00H
	ORG $+1
$SG226325 DB	'ECONOMICAISTRATEGY_TECH_LEADER', 00H
	ORG $+1
$SG226328 DB	'ECONOMICAISTRATEGY_NEED_ARCHAEOLOGISTS', 00H
	ORG $+1
$SG226331 DB	'ECONOMICAISTRATEGY_ENOUGH_ARCHAEOLOGISTS', 00H
	ORG $+3
$SG226334 DB	'ECONOMICAISTRATEGY_NEED_MUSEUMS', 00H
$SG226337 DB	'ECONOMICAISTRATEGY_NEED_GUILDS', 00H
	ORG $+1
$SG226340 DB	'ECONOMICAISTRATEGY_CONCERT_TOUR', 00H
$SG226343 DB	'ECONOMICAISTRATEGY_STARTED_PIETY', 00H
	ORG $+3
$SG226350 DB	'EconomicStrategyCanActivate', 00H
$SG226403 DB	',', 00H
	ORG $+2
$SG226404 DB	',', 00H
	ORG $+2
$SG226412 DB	',', 00H
	ORG $+2
$SG226414 DB	'%d,', 00H
$SG226422 DB	',', 00H
	ORG $+2
$SG226424 DB	'%.2f,', 00H
	ORG $+2
$SG226654 DB	'.csv', 00H
	ORG $+3
$SG226655 DB	'EconomicMonitorLog_', 00H
$SG226657 DB	'EconomicMonitorLog.csv', 00H
	ORG $+1
$SG226662 DB	'Civ Name', 00H
	ORG $+3
$SG226664 DB	'Turn', 00H
	ORG $+3
$SG226666 DB	'# Cities', 00H
	ORG $+3
$SG226674 DB	'Pop', 00H
$SG226686 DB	'Food', 00H
	ORG $+3
$SG226690 DB	'Production', 00H
	ORG $+1
$SG226694 DB	'City Gold', 00H
	ORG $+2
$SG226698 DB	'Science', 00H
$SG226701 DB	'Culture', 00H
$SG226704 DB	'Faith', 00H
	ORG $+2
$SG226706 DB	'Num Techs', 00H
	ORG $+2
$SG226708 DB	'Policies', 00H
	ORG $+3
$SG226710 DB	'Culture (lifetime)', 00H
	ORG $+1
$SG226712 DB	'Faith', 00H
	ORG $+2
$SG226721 DB	'# Workers', 00H
	ORG $+2
$SG226723 DB	'Positive Happiness', 00H
	ORG $+1
$SG226725 DB	'Negative Happiness', 00H
	ORG $+1
$SG226727 DB	'Net Happiness', 00H
	ORG $+2
$SG226821 DB	'Tiles', 00H
	ORG $+2
$SG226823 DB	'Worked (non-city) tiles', 00H
$SG226825 DB	'Improved tiles', 00H
	ORG $+1
$SG226827 DB	'Trade Routes established', 00H
	ORG $+3
$SG226830 DB	'Trade Routes available', 00H
	ORG $+1
$SG226834 DB	'Gold From Cities', 00H
	ORG $+3
$SG226837 DB	'Gold From Trade Routes', 00H
	ORG $+1
$SG226839 DB	'Treasury', 00H
	ORG $+3
$SG226841 DB	'GPT - Connects', 00H
	ORG $+1
$SG226843 DB	'GPT - Diplo', 00H
$SG226845 DB	'GPT - Religion', 00H
	ORG $+1
$SG226847 DB	'GPT - Traits', 00H
	ORG $+3
$SG226857 DB	'Total Income', 00H
	ORG $+3
$SG226860 DB	'Unit Maint', 00H
	ORG $+1
$SG226862 DB	'Build Maint', 00H
$SG226864 DB	'Improve Maint', 00H
	ORG $+2
$SG226866 DB	'Total Expenses', 00H
	ORG $+1
$SG226868 DB	'Net GPT', 00H
$SG226888 DB	'.csv', 00H
	ORG $+3
$SG226889 DB	'EconomicCityMonitorLog_', 00H
$SG226891 DB	'EconomicCityMonitorLog.csv', 00H
	ORG $+1
$SG226934 DB	'Civ Name', 00H
	ORG $+3
$SG226936 DB	'Turn', 00H
	ORG $+3
$SG226940 DB	'City Name', 00H
	ORG $+2
$SG226942 DB	'Population', 00H
	ORG $+1
$SG226954 DB	'food', 00H
	ORG $+3
$SG226957 DB	'production', 00H
	ORG $+1
$SG226960 DB	'science', 00H
$SG226963 DB	'city gold', 00H
	ORG $+2
$SG226966 DB	'culture', 00H
$SG226969 DB	'faith', 00H
	ORG $+2
$SG226982 DB	'food / pop', 00H
	ORG $+1
$SG226985 DB	'production / pop', 00H
	ORG $+3
$SG226988 DB	'science / pop', 00H
	ORG $+2
$SG226991 DB	'gold / pop', 00H
	ORG $+1
$SG226994 DB	'culture / pop', 00H
	ORG $+2
$SG226997 DB	'faith / pop', 00H
$SG227009 DB	'food specialist', 00H
$SG227012 DB	'production specialist', 00H
	ORG $+2
$SG227015 DB	'science specialist', 00H
	ORG $+1
$SG227018 DB	'gold specialist', 00H
$SG227021 DB	'culture specialist', 00H
	ORG $+1
$SG227024 DB	'faith specialist', 00H
	ORG $+3
$SG227037 DB	'food specialist / food', 00H
	ORG $+1
$SG227040 DB	'production specialist / production', 00H
	ORG $+1
$SG227043 DB	'science specialist / science', 00H
	ORG $+3
$SG227046 DB	'gold specialist / gold', 00H
	ORG $+1
$SG227049 DB	'culture specialist / culture', 00H
	ORG $+3
$SG227052 DB	'faith specialist / faith', 00H
	ORG $+3
$SG227068 DB	'Tiles', 00H
	ORG $+2
$SG227070 DB	'Worked (non-city) tiles', 00H
$SG227072 DB	'Improved tiles', 00H
	ORG $+1
$SG227076 DB	'improved / worked', 00H
	ORG $+2
$SG227128 DB	'MILITARYAISTRATEGY_AT_WAR', 00H
	ORG $+2
$SG227148 DB	'Buying plot, X: %d, Y: %d, Cost: %d, Balance (before buy'
	DB	'): %d, Priority: %d', 00H
$SG227188 DB	'FLAVOR_RECON', 00H
	ORG $+3
$SG227207 DB	'Assigning exploring %s back to attack AI, X: %d, Y: %d', 00H
	ORG $+1
$SG227218 DB	'FLAVOR_NAVAL_RECON', 00H
	ORG $+1
$SG227236 DB	'Assigning naval explorer back to attack sea AI to %s, X:'
	DB	' %d, Y: %d', 00H
	ORG $+1
$SG227258 DB	'ECONOMICAISTRATEGY_LOSING_MONEY', 00H
$SG227315 DB	'POLICY_EXPLORATION_FINISHER', 00H
$SG227321 DB	'UNIT_ARCHAEOLOGIST', 00H
	ORG $+1
$SG227716 DB	'UNIT_WORKER', 00H
$SG227729 DB	'UNIT_ARCHAEOLOGIST', 00H
	ORG $+1
$SG227739 DB	'FlavorAILog.csv', 00H
$SG227743 DB	'.csv', 00H
	ORG $+3
$SG227744 DB	'FlavorAILog_', 00H
	ORG $+3
$SG227747 DB	'%03d, ', 00H
	ORG $+1
$SG227749 DB	', ', 00H
	ORG $+1
$SG227754 DB	'%s, %d', 00H
	ORG $+1
$SG227758 DB	'.csv', 00H
	ORG $+3
$SG227759 DB	'TechAILog_', 00H
	ORG $+1
$SG227771 DB	'.csv', 00H
	ORG $+3
$SG227772 DB	'_', 00H
	ORG $+2
$SG227773 DB	'CityStrategyAILog_', 00H
	ORG $+1
$SG227775 DB	'CityStrategyAILog.csv', 00H
	ORG $+2
$SG227776 DB	'TechAILog.csv', 00H
	ORG $+6
$SG227789 DB	'Disbanding worker. %s, X: %d, Y: %d, iNumWorkers: %d, iN'
	DB	'umCities: %d, improved/valid plots: %d/%d', 00H
	ORG $+2
$SG227849 DB	'MILITARYAISTRATEGY_AT_WAR', 00H
	ORG $+2
$SG227906 DB	'MILITARYAISTRATEGY_LOSING_WARS', 00H
	ORG $+1
$SG227955 DB	'FLAVOR_ESPIONAGE', 00H
	ORG $+3
$SG227972 DB	'GAMEOPTION_AI_TWEAKS', 00H
	ORG $+3
$SG227973 DB	'GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS', 00H
$SG227981 DB	'FLAVOR_EXPANSION', 00H
	ORG $+3
$SG227986 DB	'FLAVOR_GROWTH', 00H
	ORG $+2
$SG228018 DB	'GAMEOPTION_AI_TWEAKS', 00H
	ORG $+3
$SG228019 DB	'GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS', 00H
$SG228026 DB	'ECONOMICAISTRATEGY_REALLY_EXPAND_TO_OTHER_CONTINENTS', 00H
	ORG $+3
$SG228032 DB	'FLAVOR_EXPANSION', 00H
	ORG $+3
$SG228070 DB	'AICITYSTRATEGY_NEED_NAVAL_GROWTH', 00H
	ORG $+3
$SG228091 DB	'AICITYSTRATEGY_NEED_NAVAL_TILE_IMPROVEMENT', 00H
	ORG $+1
$SG228120 DB	'GAMEOPTION_AI_TWEAKS', 00H
	ORG $+3
$SG228121 DB	'GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS', 00H
$SG228135 DB	'Randomly choose an area to settle', 00H
	ORG $+2
$SG228194 DB	'AICITYSTRATEGY_NEED_IMPROVEMENT_FOOD', 00H
	ORG $+3
$SG228197 DB	'AICITYSTRATEGY_NEED_IMPROVEMENT_PRODUCTION', 00H
	ORG $+1
$SG228310 DB	'GAMEOPTION_AI_TWEAKS', 00H
	ORG $+3
$SG228311 DB	'GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS', 00H
$SG228314 DB	'ECONOMICAISTRATEGY_ISLAND_START', 00H
$SG228319 DB	'ECONOMICAISTRATEGY_EARLY_EXPANSION', 00H
	ORG $+1
$SG228324 DB	'MILITARYAISTRATEGY_LOSING_WARS', 00H
	ORG $+1
$SG228341 DB	'GAMEOPTION_AI_TWEAKS', 00H
	ORG $+3
$SG228342 DB	'GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS', 00H
$SG228345 DB	'ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS', 00H
	ORG $+2
$SG228350 DB	'MILITARYAISTRATEGY_LOSING_WARS', 00H
	ORG $+1
$SG228356 DB	'MILITARYAISTRATEGY_AT_WAR', 00H
	ORG $+2
$SG228361 DB	'FLAVOR_GROWTH', 00H
	ORG $+2
$SG228364 DB	'FLAVOR_EXPANSION', 00H
	ORG $+3
$SG228389 DB	'GAMEOPTION_AI_TWEAKS', 00H
	ORG $+3
$SG228390 DB	'GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS', 00H
$SG228393 DB	'AIGRANDSTRATEGY_CULTURE', 00H
$SG228399 DB	'FLAVOR_EXPANSION', 00H
	ORG $+3
$SG228408 DB	'FLAVOR_GROWTH', 00H
	ORG $+2
$SG228416 DB	'AIGRANDSTRATEGY_CULTURE', 00H
$SG228424 DB	'AIGRANDSTRATEGY_CONQUEST', 00H
	ORG $+3
$SG228432 DB	'AIGRANDSTRATEGY_UNITED_NATIONS', 00H
	ORG $+1
$SG228440 DB	'AIGRANDSTRATEGY_SPACESHIP', 00H
	ORG $+2
$SG228448 DB	'PROJECT_APOLLO_PROGRAM', 00H
	ORG $+1
$SG228465 DB	'POLICY_EXPLORATION_FINISHER', 00H
$SG228483 DB	'BUILDING_WRITERS_GUILD', 00H
	ORG $+1
$SG228486 DB	'BUILDING_ARTISTS_GUILD', 00H
	ORG $+1
$SG228489 DB	'BUILDING_MUSICIANS_GUILD', 00H
	ORG $+3
$SG228512 DB	'POLICY_BRANCH_PIETY', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??0CvPurchaseRequest@@QAE@XZ			; CvPurchaseRequest::CvPurchaseRequest
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.h
;	COMDAT ??0CvPurchaseRequest@@QAE@XZ
_TEXT	SEGMENT
??0CvPurchaseRequest@@QAE@XZ PROC			; CvPurchaseRequest::CvPurchaseRequest, COMDAT
; _this$ = ecx

; 36   : 	CvPurchaseRequest()

	mov	eax, ecx

; 37   : 	{
; 38   : 		m_eType = NO_PURCHASE_TYPE;
; 39   : 		m_iAmount = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], ecx

; 40   : 		m_iPriority = 0;

	mov	DWORD PTR [eax+8], ecx

; 41   : 	}

	ret	0
??0CvPurchaseRequest@@QAE@XZ ENDP			; CvPurchaseRequest::CvPurchaseRequest
_TEXT	ENDS
PUBLIC	??MCvPurchaseRequest@@QBE_NABV0@@Z		; CvPurchaseRequest::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MCvPurchaseRequest@@QBE_NABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??MCvPurchaseRequest@@QBE_NABV0@@Z PROC			; CvPurchaseRequest::operator<, COMDAT
; _this$ = ecx

; 45   : 		return (m_iPriority > rhs.m_iPriority);

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _rhs$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+8]
	setg	cl
	mov	al, cl

; 46   : 	}

	ret	4
??MCvPurchaseRequest@@QBE_NABV0@@Z ENDP			; CvPurchaseRequest::operator<
_TEXT	ENDS
PUBLIC	?GetEarlyCityNumberTarget@CvEconomicAI@@QBEHXZ	; CvEconomicAI::GetEarlyCityNumberTarget
; Function compile flags: /Ogtpy
;	COMDAT ?GetEarlyCityNumberTarget@CvEconomicAI@@QBEHXZ
_TEXT	SEGMENT
?GetEarlyCityNumberTarget@CvEconomicAI@@QBEHXZ PROC	; CvEconomicAI::GetEarlyCityNumberTarget, COMDAT
; _this$ = ecx

; 207  : 		return m_iEarlyCityNumberTarget;

	mov	eax, DWORD PTR [ecx+24]

; 208  : 	}

	ret	0
?GetEarlyCityNumberTarget@CvEconomicAI@@QBEHXZ ENDP	; CvEconomicAI::GetEarlyCityNumberTarget
_TEXT	ENDS
PUBLIC	?GetMinimumSettleFertility@CvEconomicAI@@QBEHXZ	; CvEconomicAI::GetMinimumSettleFertility
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinimumSettleFertility@CvEconomicAI@@QBEHXZ
_TEXT	SEGMENT
?GetMinimumSettleFertility@CvEconomicAI@@QBEHXZ PROC	; CvEconomicAI::GetMinimumSettleFertility, COMDAT
; _this$ = ecx

; 211  : 		return m_iMinimumSettleFertility;

	mov	eax, DWORD PTR [ecx+48]

; 212  : 	};

	ret	0
?GetMinimumSettleFertility@CvEconomicAI@@QBEHXZ ENDP	; CvEconomicAI::GetMinimumSettleFertility
_TEXT	ENDS
PUBLIC	?GetReconState@CvEconomicAI@@QBE?AW4ReconState@@XZ ; CvEconomicAI::GetReconState
; Function compile flags: /Ogtpy
;	COMDAT ?GetReconState@CvEconomicAI@@QBE?AW4ReconState@@XZ
_TEXT	SEGMENT
?GetReconState@CvEconomicAI@@QBE?AW4ReconState@@XZ PROC	; CvEconomicAI::GetReconState, COMDAT
; _this$ = ecx

; 216  : 		return m_eReconState;

	mov	eax, DWORD PTR [ecx+28]

; 217  : 	};

	ret	0
?GetReconState@CvEconomicAI@@QBE?AW4ReconState@@XZ ENDP	; CvEconomicAI::GetReconState
_TEXT	ENDS
PUBLIC	?GetNavalReconState@CvEconomicAI@@QBE?AW4ReconState@@XZ ; CvEconomicAI::GetNavalReconState
; Function compile flags: /Ogtpy
;	COMDAT ?GetNavalReconState@CvEconomicAI@@QBE?AW4ReconState@@XZ
_TEXT	SEGMENT
?GetNavalReconState@CvEconomicAI@@QBE?AW4ReconState@@XZ PROC ; CvEconomicAI::GetNavalReconState, COMDAT
; _this$ = ecx

; 220  : 		return m_eNavalReconState;

	mov	eax, DWORD PTR [ecx+32]

; 221  : 	};

	ret	0
?GetNavalReconState@CvEconomicAI@@QBE?AW4ReconState@@XZ ENDP ; CvEconomicAI::GetNavalReconState
_TEXT	ENDS
PUBLIC	?GetVisibleAntiquitySites@CvEconomicAI@@QBEHXZ	; CvEconomicAI::GetVisibleAntiquitySites
; Function compile flags: /Ogtpy
;	COMDAT ?GetVisibleAntiquitySites@CvEconomicAI@@QBEHXZ
_TEXT	SEGMENT
?GetVisibleAntiquitySites@CvEconomicAI@@QBEHXZ PROC	; CvEconomicAI::GetVisibleAntiquitySites, COMDAT
; _this$ = ecx

; 236  : 		return m_iVisibleAntiquitySites;

	mov	eax, DWORD PTR [ecx+44]

; 237  : 	};

	ret	0
?GetVisibleAntiquitySites@CvEconomicAI@@QBEHXZ ENDP	; CvEconomicAI::GetVisibleAntiquitySites
_TEXT	ENDS
PUBLIC	??0GoodyHutUnitAssignment@CvEconomicAI@@QAE@HH@Z ; CvEconomicAI::GoodyHutUnitAssignment::GoodyHutUnitAssignment
; Function compile flags: /Ogtpy
;	COMDAT ??0GoodyHutUnitAssignment@CvEconomicAI@@QAE@HH@Z
_TEXT	SEGMENT
_unitID$ = 8						; size = 4
_plotID$ = 12						; size = 4
??0GoodyHutUnitAssignment@CvEconomicAI@@QAE@HH@Z PROC	; CvEconomicAI::GoodyHutUnitAssignment::GoodyHutUnitAssignment, COMDAT
; _this$ = ecx

; 289  : 		GoodyHutUnitAssignment(int unitID, int plotID) : m_iUnitID(unitID), m_iStepPlotID(plotID) {}

	mov	edx, DWORD PTR _plotID$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _unitID$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0GoodyHutUnitAssignment@CvEconomicAI@@QAE@HH@Z ENDP	; CvEconomicAI::GoodyHutUnitAssignment::GoodyHutUnitAssignment
_TEXT	ENDS
PUBLIC	?Clear@GoodyHutUnitAssignment@CvEconomicAI@@QAEXXZ ; CvEconomicAI::GoodyHutUnitAssignment::Clear
; Function compile flags: /Ogtpy
;	COMDAT ?Clear@GoodyHutUnitAssignment@CvEconomicAI@@QAEXXZ
_TEXT	SEGMENT
?Clear@GoodyHutUnitAssignment@CvEconomicAI@@QAEXXZ PROC	; CvEconomicAI::GoodyHutUnitAssignment::Clear, COMDAT
; _this$ = ecx

; 290  : 		void Clear() { m_iUnitID = -1; m_iStepPlotID = -1; }

	mov	DWORD PTR [ecx], -1
	mov	DWORD PTR [ecx+4], -1
	ret	0
?Clear@GoodyHutUnitAssignment@CvEconomicAI@@QAEXXZ ENDP	; CvEconomicAI::GoodyHutUnitAssignment::Clear
_TEXT	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	?GetNextWonderDesired@CvCitySpecializationAI@@QBE?AW4BuildingTypes@@XZ ; CvCitySpecializationAI::GetNextWonderDesired
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcityspecializationai.h
;	COMDAT ?GetNextWonderDesired@CvCitySpecializationAI@@QBE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
?GetNextWonderDesired@CvCitySpecializationAI@@QBE?AW4BuildingTypes@@XZ PROC ; CvCitySpecializationAI::GetNextWonderDesired, COMDAT
; _this$ = ecx

; 146  : 		return m_eNextWonderDesired;

	mov	eax, DWORD PTR [ecx+196]

; 147  : 	};

	ret	0
?GetNextWonderDesired@CvCitySpecializationAI@@QBE?AW4BuildingTypes@@XZ ENDP ; CvCitySpecializationAI::GetNextWonderDesired
_TEXT	ENDS
PUBLIC	?GetPlayerFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ; CvEconomicAIStrategyXMLEntry::GetPlayerFlavorValue
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
;	COMDAT ?GetPlayerFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPlayerFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z PROC ; CvEconomicAIStrategyXMLEntry::GetPlayerFlavorValue, COMDAT
; _this$ = ecx

; 117  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 118  : 	FAssertMsg(i > -1, "Index out of bounds");
; 119  : 	return m_piPlayerFlavorValue ? m_piPlayerFlavorValue[i] : -1;

	mov	eax, DWORD PTR [ecx+260]
	test	eax, eax
	je	SHORT $LN3@GetPlayerF
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 120  : }

	ret	4
$LN3@GetPlayerF:

; 117  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 118  : 	FAssertMsg(i > -1, "Index out of bounds");
; 119  : 	return m_piPlayerFlavorValue ? m_piPlayerFlavorValue[i] : -1;

	or	eax, -1

; 120  : }

	ret	4
?GetPlayerFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ENDP ; CvEconomicAIStrategyXMLEntry::GetPlayerFlavorValue
_TEXT	ENDS
PUBLIC	?GetCityFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ; CvEconomicAIStrategyXMLEntry::GetCityFlavorValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetCityFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z PROC ; CvEconomicAIStrategyXMLEntry::GetCityFlavorValue, COMDAT
; _this$ = ecx

; 125  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 126  : 	FAssertMsg(i > -1, "Index out of bounds");
; 127  : 	return m_piCityFlavorValue ? m_piCityFlavorValue[i] : -1;

	mov	eax, DWORD PTR [ecx+264]
	test	eax, eax
	je	SHORT $LN3@GetCityFla
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 128  : }

	ret	4
$LN3@GetCityFla:

; 125  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 126  : 	FAssertMsg(i > -1, "Index out of bounds");
; 127  : 	return m_piCityFlavorValue ? m_piCityFlavorValue[i] : -1;

	or	eax, -1

; 128  : }

	ret	4
?GetCityFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ENDP ; CvEconomicAIStrategyXMLEntry::GetCityFlavorValue
_TEXT	ENDS
PUBLIC	?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ PROC ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold, COMDAT
; _this$ = ecx

; 133  : 	return m_iWeightThreshold;

	mov	eax, DWORD PTR [ecx+268]

; 134  : }

	ret	0
?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold
_TEXT	ENDS
PUBLIC	?GetPersonalityFlavorThresholdMod@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ; CvEconomicAIStrategyXMLEntry::GetPersonalityFlavorThresholdMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetPersonalityFlavorThresholdMod@CvEconomicAIStrategyXMLEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPersonalityFlavorThresholdMod@CvEconomicAIStrategyXMLEntry@@QBEHH@Z PROC ; CvEconomicAIStrategyXMLEntry::GetPersonalityFlavorThresholdMod, COMDAT
; _this$ = ecx

; 139  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 140  : 	FAssertMsg(i > -1, "Index out of bounds");
; 141  : 	return m_piPersonalityFlavorThresholdMod ? m_piPersonalityFlavorThresholdMod[i] : -1;

	mov	eax, DWORD PTR [ecx+272]
	test	eax, eax
	je	SHORT $LN3@GetPersona
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 142  : }

	ret	4
$LN3@GetPersona:

; 139  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 140  : 	FAssertMsg(i > -1, "Index out of bounds");
; 141  : 	return m_piPersonalityFlavorThresholdMod ? m_piPersonalityFlavorThresholdMod[i] : -1;

	or	eax, -1

; 142  : }

	ret	4
?GetPersonalityFlavorThresholdMod@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ENDP ; CvEconomicAIStrategyXMLEntry::GetPersonalityFlavorThresholdMod
_TEXT	ENDS
PUBLIC	?IsNoMinorCivs@CvEconomicAIStrategyXMLEntry@@QBE_NXZ ; CvEconomicAIStrategyXMLEntry::IsNoMinorCivs
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoMinorCivs@CvEconomicAIStrategyXMLEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNoMinorCivs@CvEconomicAIStrategyXMLEntry@@QBE_NXZ PROC ; CvEconomicAIStrategyXMLEntry::IsNoMinorCivs, COMDAT
; _this$ = ecx

; 147  : 	return m_bNoMinorCivs;

	mov	al, BYTE PTR [ecx+276]

; 148  : }

	ret	0
?IsNoMinorCivs@CvEconomicAIStrategyXMLEntry@@QBE_NXZ ENDP ; CvEconomicAIStrategyXMLEntry::IsNoMinorCivs
_TEXT	ENDS
PUBLIC	?GetTechPrereq@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetTechPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechPrereq@CvEconomicAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTechPrereq@CvEconomicAIStrategyXMLEntry@@QBEHXZ PROC ; CvEconomicAIStrategyXMLEntry::GetTechPrereq, COMDAT
; _this$ = ecx

; 153  : 	return m_iTechPrereq;

	mov	eax, DWORD PTR [ecx+280]

; 154  : }

	ret	0
?GetTechPrereq@CvEconomicAIStrategyXMLEntry@@QBEHXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetTechPrereq
_TEXT	ENDS
PUBLIC	?GetTechObsolete@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetTechObsolete
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechObsolete@CvEconomicAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTechObsolete@CvEconomicAIStrategyXMLEntry@@QBEHXZ PROC ; CvEconomicAIStrategyXMLEntry::GetTechObsolete, COMDAT
; _this$ = ecx

; 159  : 	return m_iTechObsolete;

	mov	eax, DWORD PTR [ecx+284]

; 160  : }

	ret	0
?GetTechObsolete@CvEconomicAIStrategyXMLEntry@@QBEHXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetTechObsolete
_TEXT	ENDS
PUBLIC	?GetMinimumNumTurnsExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetMinimumNumTurnsExecuted
; Function compile flags: /Ogtpy
;	COMDAT ?GetMinimumNumTurnsExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMinimumNumTurnsExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ PROC ; CvEconomicAIStrategyXMLEntry::GetMinimumNumTurnsExecuted, COMDAT
; _this$ = ecx

; 165  : 	return m_iMinimumNumTurnsExecuted;

	mov	eax, DWORD PTR [ecx+288]

; 166  : }

	ret	0
?GetMinimumNumTurnsExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetMinimumNumTurnsExecuted
_TEXT	ENDS
PUBLIC	?GetCheckTriggerTurnCount@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetCheckTriggerTurnCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetCheckTriggerTurnCount@CvEconomicAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCheckTriggerTurnCount@CvEconomicAIStrategyXMLEntry@@QBEHXZ PROC ; CvEconomicAIStrategyXMLEntry::GetCheckTriggerTurnCount, COMDAT
; _this$ = ecx

; 171  : 	return m_iCheckTriggerTurnCount;

	mov	eax, DWORD PTR [ecx+292]

; 172  : }

	ret	0
?GetCheckTriggerTurnCount@CvEconomicAIStrategyXMLEntry@@QBEHXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetCheckTriggerTurnCount
_TEXT	ENDS
PUBLIC	?GetFirstTurnExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetFirstTurnExecuted
; Function compile flags: /Ogtpy
;	COMDAT ?GetFirstTurnExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFirstTurnExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ PROC ; CvEconomicAIStrategyXMLEntry::GetFirstTurnExecuted, COMDAT
; _this$ = ecx

; 177  : 	return m_iFirstTurnExecuted;

	mov	eax, DWORD PTR [ecx+296]

; 178  : }

	ret	0
?GetFirstTurnExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetFirstTurnExecuted
_TEXT	ENDS
PUBLIC	?GetAdvisor@CvEconomicAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ ; CvEconomicAIStrategyXMLEntry::GetAdvisor
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdvisor@CvEconomicAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ
_TEXT	SEGMENT
?GetAdvisor@CvEconomicAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ PROC ; CvEconomicAIStrategyXMLEntry::GetAdvisor, COMDAT
; _this$ = ecx

; 182  : 	return m_eAdvisor;

	mov	eax, DWORD PTR [ecx+300]

; 183  : }

	ret	0
?GetAdvisor@CvEconomicAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ ENDP ; CvEconomicAIStrategyXMLEntry::GetAdvisor
_TEXT	ENDS
PUBLIC	?GetAdvisorCounselText@CvEconomicAIStrategyXMLEntry@@QBEPBDXZ ; CvEconomicAIStrategyXMLEntry::GetAdvisorCounselText
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdvisorCounselText@CvEconomicAIStrategyXMLEntry@@QBEPBDXZ
_TEXT	SEGMENT
?GetAdvisorCounselText@CvEconomicAIStrategyXMLEntry@@QBEPBDXZ PROC ; CvEconomicAIStrategyXMLEntry::GetAdvisorCounselText, COMDAT
; _this$ = ecx

; 187  : 	return m_strAdvisorCounselText.c_str();

	add	ecx, 304				; 00000130H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetAdvisorCounselText@CvEconomicAIStrategyXMLEntry@@QBEPBDXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetAdvisorCounselText
_TEXT	ENDS
PUBLIC	?GetAdvisorCounselImportance@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetAdvisorCounselImportance
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdvisorCounselImportance@CvEconomicAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAdvisorCounselImportance@CvEconomicAIStrategyXMLEntry@@QBEHXZ PROC ; CvEconomicAIStrategyXMLEntry::GetAdvisorCounselImportance, COMDAT
; _this$ = ecx

; 192  : 	return m_iAdvisorCounselImportance;

	mov	eax, DWORD PTR [ecx+332]

; 193  : }

	ret	0
?GetAdvisorCounselImportance@CvEconomicAIStrategyXMLEntry@@QBEHXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetAdvisorCounselImportance
_TEXT	ENDS
PUBLIC	?GetEconomicAIStrategyEntries@CvEconomicAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ ; CvEconomicAIStrategyXMLEntries::GetEconomicAIStrategyEntries
; Function compile flags: /Ogtpy
;	COMDAT ?GetEconomicAIStrategyEntries@CvEconomicAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetEconomicAIStrategyEntries@CvEconomicAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ PROC ; CvEconomicAIStrategyXMLEntries::GetEconomicAIStrategyEntries, COMDAT
; _this$ = ecx

; 212  : {

	mov	eax, ecx

; 213  : 	return m_paAIStrategyEntries;
; 214  : }

	ret	0
?GetEconomicAIStrategyEntries@CvEconomicAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ ENDP ; CvEconomicAIStrategyXMLEntries::GetEconomicAIStrategyEntries
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ	; CvEconomicAI::GetPlayer
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
;	COMDAT ?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ
_TEXT	SEGMENT
?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ PROC	; CvEconomicAI::GetPlayer, COMDAT
; _this$ = ecx

; 489  : 	return m_pPlayer;

	mov	eax, DWORD PTR [ecx+4]

; 490  : }

	ret	0
?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ENDP	; CvEconomicAI::GetPlayer
_TEXT	ENDS
PUBLIC	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
; Function compile flags: /Ogtpy
;	COMDAT ?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ
_TEXT	SEGMENT
?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ PROC ; CvEconomicAI::GetEconomicAIStrategies, COMDAT
; _this$ = ecx

; 495  : 	return m_pAIStrategies;

	mov	eax, DWORD PTR [ecx+8]

; 496  : }

	ret	0
?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ENDP ; CvEconomicAI::GetEconomicAIStrategies
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
PUBLIC	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
;	COMDAT ?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z PROC ; CvEconomicAI::IsUsingStrategy, COMDAT
; _this$ = ecx

; 505  : 	return m_pabUsingStrategy[(int) eStrategy];

	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _eStrategy$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 506  : }

	ret	4
?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ENDP ; CvEconomicAI::IsUsingStrategy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetTurnStrategyAdopted@CvEconomicAI@@QAEHW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::GetTurnStrategyAdopted
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
;	COMDAT ?GetTurnStrategyAdopted@CvEconomicAI@@QAEHW4EconomicAIStrategyTypes@@@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
?GetTurnStrategyAdopted@CvEconomicAI@@QAEHW4EconomicAIStrategyTypes@@@Z PROC ; CvEconomicAI::GetTurnStrategyAdopted, COMDAT
; _this$ = ecx

; 535  : 	return m_paiTurnStrategyAdopted[(int) eStrategy];

	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _eStrategy$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 536  : }

	ret	4
?GetTurnStrategyAdopted@CvEconomicAI@@QAEHW4EconomicAIStrategyTypes@@@Z ENDP ; CvEconomicAI::GetTurnStrategyAdopted
_TEXT	ENDS
PUBLIC	?SetTurnStrategyAdopted@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@H@Z ; CvEconomicAI::SetTurnStrategyAdopted
; Function compile flags: /Ogtpy
;	COMDAT ?SetTurnStrategyAdopted@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@H@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
_iValue$ = 12						; size = 4
?SetTurnStrategyAdopted@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@H@Z PROC ; CvEconomicAI::SetTurnStrategyAdopted, COMDAT
; _this$ = ecx

; 541  : 	if(m_paiTurnStrategyAdopted[(int) eStrategy] != iValue)

	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _eStrategy$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _iValue$[esp-4]
	cmp	DWORD PTR [eax], ecx
	je	SHORT $LN1@SetTurnStr

; 542  : 	{
; 543  : 		m_paiTurnStrategyAdopted[(int) eStrategy] = iValue;

	mov	DWORD PTR [eax], ecx
$LN1@SetTurnStr:

; 544  : 	}
; 545  : }

	ret	8
?SetTurnStrategyAdopted@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@H@Z ENDP ; CvEconomicAI::SetTurnStrategyAdopted
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetWorkersToCitiesRatio@CvEconomicAI@@QAENXZ	; CvEconomicAI::GetWorkersToCitiesRatio
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z:PROC ; CvPlayer::GetNumUnitsWithUnitAI
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
;	COMDAT ?GetWorkersToCitiesRatio@CvEconomicAI@@QAENXZ
_TEXT	SEGMENT
tv132 = -12						; size = 4
_iNumWorkers$ = -12					; size = 4
tv129 = -8						; size = 8
_fCurrentRatio$ = -8					; size = 8
?GetWorkersToCitiesRatio@CvEconomicAI@@QAENXZ PROC	; CvEconomicAI::GetWorkersToCitiesRatio, COMDAT
; _this$ = ecx

; 1261 : {

	sub	esp, 12					; 0000000cH
	push	esi

; 1262 : 	int iNumWorkers = m_pPlayer->GetNumUnitsWithUnitAI(UNITAI_WORKER, true, false); // includes workers currently being produced

	push	0
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+4]
	push	1
	push	2
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI

; 1263 : 	int iNumCities = m_pPlayer->getNumCities();

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _iNumWorkers$[esp+16], eax

; 1264 : 	double fCurrentRatio = iNumWorkers / (double)iNumCities;

	fild	DWORD PTR _iNumWorkers$[esp+16]
	fstp	QWORD PTR tv129[esp+16]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	DWORD PTR tv132[esp+16], eax
	fild	DWORD PTR tv132[esp+16]
	pop	esi
	fdivr	QWORD PTR tv129[esp+12]
	fstp	QWORD PTR _fCurrentRatio$[esp+12]

; 1265 : 
; 1266 : 	return fCurrentRatio;

	fld	QWORD PTR _fCurrentRatio$[esp+12]

; 1267 : }

	add	esp, 12					; 0000000cH
	ret	0
?GetWorkersToCitiesRatio@CvEconomicAI@@QAENXZ ENDP	; CvEconomicAI::GetWorkersToCitiesRatio
_TEXT	ENDS
PUBLIC	?DoHurry@CvEconomicAI@@AAEXXZ			; CvEconomicAI::DoHurry
EXTRN	?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z:PROC ; CvCityStrategyAI::LogHurry
EXTRN	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ:PROC ; CvCity::GetCityStrategyAI
EXTRN	?hurry@CvCity@@QAEXW4HurryTypes@@@Z:PROC	; CvCity::hurry
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?hurryPopulation@CvCity@@QBEHW4HurryTypes@@@Z:PROC ; CvCity::hurryPopulation
EXTRN	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::IsEmpireUnhappy
EXTRN	?getProductionPerPopulation@CvHurryInfo@@QBEHXZ:PROC ; CvHurryInfo::getProductionPerPopulation
EXTRN	?getGoldPerProduction@CvHurryInfo@@QBEHXZ:PROC	; CvHurryInfo::getGoldPerProduction
EXTRN	?getHurryInfo@CvGlobals@@QAEPAVCvHurryInfo@@W4HurryTypes@@@Z:PROC ; CvGlobals::getHurryInfo
EXTRN	?getProductionTurnsLeft@CvCity@@QBEHXZ:PROC	; CvCity::getProductionTurnsLeft
EXTRN	?hurryProduction@CvCity@@QBEHW4HurryTypes@@@Z:PROC ; CvCity::hurryProduction
EXTRN	?canHurry@CvCity@@QBE_NW4HurryTypes@@_N@Z:PROC	; CvCity::canHurry
EXTRN	?getNumHurryInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumHurryInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	?getOrderFromQueue@CvCity@@QAEPAUOrderData@@H@Z:PROC ; CvCity::getOrderFromQueue
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
; Function compile flags: /Ogtpy
;	COMDAT ?DoHurry@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
_iBestHurryTurnsSaved$ = -28				; size = 4
_pBestHurryCity$ = -24					; size = 4
_this$ = -20						; size = 4
_iLoop$ = -16						; size = 4
_eBestHurryType$ = -12					; size = 4
_iBestHurryAmountAvailable$ = -8			; size = 4
_iBestHurryAmount$ = -4					; size = 4
?DoHurry@CvEconomicAI@@AAEXXZ PROC			; CvEconomicAI::DoHurry, COMDAT
; _this$ = ecx

; 1790 : {

	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1791 : 	int iLoop = 0;

	xor	edi, edi
	mov	ebp, ecx

; 1792 : 	OrderData* pOrder = 0;
; 1793 : 
; 1794 : 	CvCity* pLoopCity = 0;
; 1795 : 	int iTurnsSaved = 0;
; 1796 : 	int iHurryAmount = 0;
; 1797 : 	int iHurryAmountAvailable = 0;
; 1798 : #ifdef AUI_WARNING_FIXES
; 1799 : 	uint iI = 0;
; 1800 : #else
; 1801 : 	int iI = 0;
; 1802 : #endif
; 1803 : 
; 1804 : 	CvCity* pBestHurryCity = NULL;
; 1805 : 	int iBestHurryTurnsSaved = 0;
; 1806 : 	int iBestHurryAmount = 0;
; 1807 : 	int iBestHurryAmountAvailable = 0;
; 1808 : 	HurryTypes eBestHurryType = NO_HURRY;
; 1809 : 
; 1810 : 	// Look at each of our cities
; 1811 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [ebp+4]
	push	edi
	lea	eax, DWORD PTR _iLoop$[esp+48]
	xor	ebx, ebx
	push	eax
	mov	DWORD PTR _this$[esp+52], ebp
	mov	DWORD PTR _iLoop$[esp+52], edi
	mov	DWORD PTR _pBestHurryCity$[esp+52], ebx
	mov	DWORD PTR _iBestHurryTurnsSaved$[esp+52], edi
	mov	DWORD PTR _iBestHurryAmount$[esp+52], edi
	mov	DWORD PTR _iBestHurryAmountAvailable$[esp+52], edi
	mov	DWORD PTR _eBestHurryType$[esp+52], -1
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	cmp	esi, edi
	je	$LN1@DoHurry
$LL15@DoHurry:

; 1812 : 	{
; 1813 : 		// What are we currently working on?
; 1814 : 		pOrder = pLoopCity->getOrderFromQueue(0);

	push	edi
	mov	ecx, esi
	call	?getOrderFromQueue@CvCity@@QAEPAUOrderData@@H@Z ; CvCity::getOrderFromQueue

; 1815 : 
; 1816 : 		// Did we want to rush it?
; 1817 : 		if(pOrder != NULL && pOrder->bRush)

	cmp	eax, edi
	je	$LN14@DoHurry
	cmp	BYTE PTR [eax+13], 0
	je	$LN14@DoHurry

; 1818 : 		{
; 1819 : 			for(iI = 0; iI < GC.getNumHurryInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumHurryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumHurryInfos
	test	eax, eax
	jle	$LN14@DoHurry
$LL11@DoHurry:

; 1820 : 			{
; 1821 : 				iHurryAmount = 0;
; 1822 : 
; 1823 : 				if(pLoopCity->canHurry((HurryTypes)iI) &&
; 1824 : 					pLoopCity->hurryProduction((HurryTypes)iI) > 0)

	push	0
	push	edi
	mov	ecx, esi
	call	?canHurry@CvCity@@QBE_NW4HurryTypes@@_N@Z ; CvCity::canHurry
	test	al, al
	je	$LN10@DoHurry
	push	edi
	mov	ecx, esi
	call	?hurryProduction@CvCity@@QBEHW4HurryTypes@@@Z ; CvCity::hurryProduction
	test	eax, eax
	jle	SHORT $LN10@DoHurry

; 1825 : 				{
; 1826 : 					iTurnsSaved = pLoopCity->getProductionTurnsLeft() - 1;

	mov	ecx, esi
	call	?getProductionTurnsLeft@CvCity@@QBEHXZ	; CvCity::getProductionTurnsLeft
	mov	ebx, eax
	dec	ebx

; 1827 : 					if(iTurnsSaved > 0)

	test	ebx, ebx
	jle	SHORT $LN10@DoHurry

; 1828 : 					{
; 1829 : #ifdef AUI_WARNING_FIXES
; 1830 : 						CvHurryInfo* pHurryInfo = GC.getHurryInfo((HurryTypes)iI);
; 1831 : 						if (!pHurryInfo)
; 1832 : 							continue;
; 1833 : 						if (pHurryInfo->getGoldPerProduction() > 0)
; 1834 : #else
; 1835 : 						if(GC.getHurryInfo((HurryTypes)iI)->getGoldPerProduction() > 0)

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getHurryInfo@CvGlobals@@QAEPAVCvHurryInfo@@W4HurryTypes@@@Z ; CvGlobals::getHurryInfo
	mov	ecx, eax
	call	?getGoldPerProduction@CvHurryInfo@@QBEHXZ ; CvHurryInfo::getGoldPerProduction
	test	eax, eax
	jg	SHORT $LN10@DoHurry

; 1836 : #endif
; 1837 : 						{
; 1838 : 							// Don't gold rush at all anymore (save gold to buy tiles)
; 1839 : 
; 1840 : 							// iHurryAmount = pLoopCity->hurryGold((HurryTypes)iI);
; 1841 : 							// iHurryAmountAvailable = m_pPlayer->getGold();
; 1842 : 						}
; 1843 : #ifdef AUI_WARNING_FIXES
; 1844 : 						else if (pHurryInfo->getProductionPerPopulation() > 0)
; 1845 : #else
; 1846 : 						else if(GC.getHurryInfo((HurryTypes)iI)->getProductionPerPopulation() > 0)

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getHurryInfo@CvGlobals@@QAEPAVCvHurryInfo@@W4HurryTypes@@@Z ; CvGlobals::getHurryInfo
	mov	ecx, eax
	call	?getProductionPerPopulation@CvHurryInfo@@QBEHXZ ; CvHurryInfo::getProductionPerPopulation
	test	eax, eax
	jle	SHORT $LN10@DoHurry

; 1847 : #endif
; 1848 : 						{
; 1849 : 							// Only pop rush if over our current Happiness limit
; 1850 : 							if(m_pPlayer->IsEmpireUnhappy())

	mov	ecx, DWORD PTR [ebp+4]
	call	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ	; CvPlayer::IsEmpireUnhappy
	test	al, al
	je	SHORT $LN10@DoHurry

; 1851 : 							{
; 1852 : 								iHurryAmount = pLoopCity->hurryPopulation((HurryTypes)iI);

	push	edi
	mov	ecx, esi
	call	?hurryPopulation@CvCity@@QBEHW4HurryTypes@@@Z ; CvCity::hurryPopulation

; 1853 : 								iHurryAmountAvailable = pLoopCity->getPopulation();

	mov	ecx, esi
	mov	ebp, eax
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation

; 1854 : 							}
; 1855 : 						}
; 1856 : 
; 1857 : 						// Current hurry heuristic is to hurry whichever item has the most turns still to complete
; 1858 : 						if(iHurryAmount > 0 && iTurnsSaved >= iBestHurryTurnsSaved)

	test	ebp, ebp
	jle	SHORT $LN10@DoHurry
	cmp	ebx, DWORD PTR _iBestHurryTurnsSaved$[esp+44]
	jl	SHORT $LN10@DoHurry

; 1859 : 						{
; 1860 : 							iBestHurryTurnsSaved = iTurnsSaved;

	mov	DWORD PTR _iBestHurryTurnsSaved$[esp+44], ebx

; 1861 : 							iBestHurryAmount = iHurryAmount;

	mov	DWORD PTR _iBestHurryAmount$[esp+44], ebp

; 1862 : 							iBestHurryAmountAvailable = iHurryAmountAvailable;

	mov	DWORD PTR _iBestHurryAmountAvailable$[esp+44], eax

; 1863 : 							pBestHurryCity = pLoopCity;

	mov	DWORD PTR _pBestHurryCity$[esp+44], esi

; 1864 : 							eBestHurryType = (HurryTypes)iI;

	mov	DWORD PTR _eBestHurryType$[esp+44], edi
$LN10@DoHurry:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumHurryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumHurryInfos
	cmp	edi, eax
	mov	ebp, DWORD PTR _this$[esp+44]
	jl	$LL11@DoHurry

; 1818 : 		{
; 1819 : 			for(iI = 0; iI < GC.getNumHurryInfos(); iI++)

	mov	ebx, DWORD PTR _pBestHurryCity$[esp+44]
$LN14@DoHurry:

; 1792 : 	OrderData* pOrder = 0;
; 1793 : 
; 1794 : 	CvCity* pLoopCity = 0;
; 1795 : 	int iTurnsSaved = 0;
; 1796 : 	int iHurryAmount = 0;
; 1797 : 	int iHurryAmountAvailable = 0;
; 1798 : #ifdef AUI_WARNING_FIXES
; 1799 : 	uint iI = 0;
; 1800 : #else
; 1801 : 	int iI = 0;
; 1802 : #endif
; 1803 : 
; 1804 : 	CvCity* pBestHurryCity = NULL;
; 1805 : 	int iBestHurryTurnsSaved = 0;
; 1806 : 	int iBestHurryAmount = 0;
; 1807 : 	int iBestHurryAmountAvailable = 0;
; 1808 : 	HurryTypes eBestHurryType = NO_HURRY;
; 1809 : 
; 1810 : 	// Look at each of our cities
; 1811 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	xor	edi, edi
	push	edi
	lea	ecx, DWORD PTR _iLoop$[esp+48]
	push	ecx
	mov	ecx, DWORD PTR [ebp+4]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	cmp	esi, edi
	jne	$LL15@DoHurry

; 1865 : 						}
; 1866 : 					}
; 1867 : 				}
; 1868 : 			}
; 1869 : 		}
; 1870 : 	}
; 1871 : 
; 1872 : 	// Now enact the best hurry we've found (only hurry one item per turn for now)
; 1873 : 	if(pBestHurryCity != NULL)

	cmp	ebx, edi
	je	SHORT $LN1@DoHurry

; 1874 : 	{
; 1875 : 		pBestHurryCity->hurry(eBestHurryType);

	mov	esi, DWORD PTR _eBestHurryType$[esp+44]
	push	esi
	mov	ecx, ebx
	call	?hurry@CvCity@@QAEXW4HurryTypes@@@Z	; CvCity::hurry

; 1876 : 		pBestHurryCity->GetCityStrategyAI()->LogHurry(eBestHurryType, iBestHurryAmount, iBestHurryAmountAvailable, iBestHurryTurnsSaved);

	mov	edx, DWORD PTR _iBestHurryTurnsSaved$[esp+44]
	mov	eax, DWORD PTR _iBestHurryAmountAvailable$[esp+44]
	mov	ecx, DWORD PTR _iBestHurryAmount$[esp+44]
	push	edx
	push	eax
	push	ecx
	push	esi
	mov	ecx, ebx
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z ; CvCityStrategyAI::LogHurry
$LN1@DoHurry:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1877 : 	}
; 1878 : }

	add	esp, 28					; 0000001cH
	ret	0
?DoHurry@CvEconomicAI@@AAEXXZ ENDP			; CvEconomicAI::DoHurry
_TEXT	ENDS
PUBLIC	?FindArchaeologistToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ ; CvEconomicAI::FindArchaeologistToScrap
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
; Function compile flags: /Ogtpy
;	COMDAT ?FindArchaeologistToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ
_TEXT	SEGMENT
_iUnitLoop$ = -4					; size = 4
?FindArchaeologistToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ PROC ; CvEconomicAI::FindArchaeologistToScrap, COMDAT
; _this$ = ecx

; 2701 : {

	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx

; 2702 : 	CvUnit* pLoopUnit = NULL;
; 2703 : 	int iUnitLoop = 0;
; 2704 : 
; 2705 : 	// Look at map for loose archaeologists
; 2706 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))

	mov	ecx, DWORD PTR [ebx+4]
	push	0
	lea	eax, DWORD PTR _iUnitLoop$[esp+20]
	push	eax
	mov	DWORD PTR _iUnitLoop$[esp+24], 0
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN3@FindArchae
$LN12@FindArchae:

; 2707 : 	{
; 2708 : 		if(!pLoopUnit)
; 2709 : 		{
; 2710 : 			continue;
; 2711 : 		}
; 2712 : 		UnitTypes eArch = (UnitTypes) GC.getInfoTypeForString("UNIT_ARCHAEOLOGIST", true);

	push	1
	push	OFFSET $SG227729
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2713 : 		if(pLoopUnit->getUnitType() == eArch)

	mov	ecx, esi
	mov	edi, eax
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	cmp	eax, edi
	je	SHORT $LN9@FindArchae
	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR [ebx+4]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN12@FindArchae
$LN3@FindArchae:
	pop	edi
	pop	esi

; 2716 : 		}
; 2717 : 	}
; 2718 : 
; 2719 : 	return NULL;

	xor	eax, eax
	pop	ebx

; 2720 : }

	pop	ecx
	ret	0
$LN9@FindArchae:
	pop	edi

; 2714 : 		{
; 2715 : 			return pLoopUnit;

	mov	eax, esi
	pop	esi
	pop	ebx

; 2720 : }

	pop	ecx
	ret	0
?FindArchaeologistToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ ENDP ; CvEconomicAI::FindArchaeologistToScrap
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedRecon
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
EXTRN	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z:PROC ; CvMilitaryAI::IsUsingStrategy
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedRecon, COMDAT

; 2894 : {

	push	esi

; 2895 : 	// Never desperate for explorers if we are at war
; 2896 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	push	OFFSET $SG227849
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2897 : 	if(eStrategyAtWar != NO_MILITARYAISTRATEGY)

	mov	esi, DWORD PTR _pPlayer$[esp]
	cmp	eax, -1
	je	SHORT $LN1@IsTestStra

; 2898 : 	{
; 2899 : 		if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyAtWar))

	push	eax
	mov	ecx, esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	test	al, al
	je	SHORT $LN1@IsTestStra

; 2900 : 		{
; 2901 : 			return false;

	xor	al, al
	pop	esi

; 2906 : }

	ret	0
$LN1@IsTestStra:

; 2902 : 		}
; 2903 : 	}
; 2904 : 
; 2905 : 	return (pPlayer->GetEconomicAI()->GetReconState() == RECON_STATE_NEEDED);

	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	xor	ecx, ecx
	cmp	DWORD PTR [eax+28], 2
	pop	esi
	sete	cl
	mov	al, cl

; 2906 : }

	ret	0
?IsTestStrategy_NeedRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedRecon
_TEXT	ENDS
PUBLIC	?IsTestStrategy_EnoughRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EnoughRecon
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_EnoughRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EnoughRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_EnoughRecon, COMDAT

; 2911 : 	return (pPlayer->GetEconomicAI()->GetReconState() == RECON_STATE_ENOUGH);

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	xor	ecx, ecx
	cmp	DWORD PTR [eax+28], ecx
	sete	cl
	mov	al, cl

; 2912 : }

	ret	0
?IsTestStrategy_EnoughRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_EnoughRecon
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedReconSea
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedReconSea, COMDAT

; 3013 : {

	push	esi

; 3014 : 	// Never desperate for explorers if we are at war
; 3015 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_LOSING_WARS");

	push	0
	push	OFFSET $SG227906
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 3016 : 	if(eStrategyAtWar != NO_MILITARYAISTRATEGY)

	mov	esi, DWORD PTR _pPlayer$[esp]
	cmp	eax, -1
	je	SHORT $LN1@IsTestStra@2

; 3017 : 	{
; 3018 : 		if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyAtWar))

	push	eax
	mov	ecx, esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	test	al, al
	je	SHORT $LN1@IsTestStra@2

; 3019 : 		{
; 3020 : 			return false;

	xor	al, al
	pop	esi

; 3025 : }

	ret	0
$LN1@IsTestStra@2:

; 3021 : 		}
; 3022 : 	}
; 3023 : 
; 3024 : 	return (pPlayer->GetEconomicAI()->GetNavalReconState() == RECON_STATE_NEEDED);

	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	xor	ecx, ecx
	cmp	DWORD PTR [eax+32], 2
	pop	esi
	sete	cl
	mov	al, cl

; 3025 : }

	ret	0
?IsTestStrategy_NeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedReconSea
_TEXT	ENDS
PUBLIC	?IsTestStrategy_EnoughReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EnoughReconSea
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_EnoughReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EnoughReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_EnoughReconSea, COMDAT

; 3030 : 	return (pPlayer->GetEconomicAI()->GetNavalReconState() == RECON_STATE_ENOUGH);

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	xor	ecx, ecx
	cmp	DWORD PTR [eax+32], ecx
	sete	cl
	mov	al, cl

; 3031 : }

	ret	0
?IsTestStrategy_EnoughReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_EnoughReconSea
_TEXT	ENDS
PUBLIC	?IsTestStrategy_OneOrFewerCoastalCities@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_OneOrFewerCoastalCities
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_OneOrFewerCoastalCities@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_iCityLoop$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_OneOrFewerCoastalCities@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_OneOrFewerCoastalCities, COMDAT

; 3758 : {

	push	ecx
	push	esi

; 3759 : 	int iCityLoop = 0;
; 3760 : 	CvCity* pLoopCity = NULL;
; 3761 : 	int iNumCoastalCities = 0;
; 3762 : 	for(pLoopCity = pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iCityLoop))

	mov	esi, DWORD PTR _pPlayer$[esp+4]
	push	edi
	xor	edi, edi
	push	edi
	lea	eax, DWORD PTR _iCityLoop$[esp+16]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _iCityLoop$[esp+20], 0
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN2@IsTestStra@3
$LL4@IsTestStra@3:

; 3763 : 	{
; 3764 : 		if(pLoopCity->isCoastal())

	push	-1
	mov	ecx, eax
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	SHORT $LN3@IsTestStra@3

; 3765 : 		{
; 3766 : 			iNumCoastalCities++;

	inc	edi
$LN3@IsTestStra@3:

; 3759 : 	int iCityLoop = 0;
; 3760 : 	CvCity* pLoopCity = NULL;
; 3761 : 	int iNumCoastalCities = 0;
; 3762 : 	for(pLoopCity = pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iCityLoop))

	push	0
	lea	ecx, DWORD PTR _iCityLoop$[esp+16]
	push	ecx
	mov	ecx, esi
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL4@IsTestStra@3
$LN2@IsTestStra@3:

; 3767 : 		}
; 3768 : 	}
; 3769 : 	return iNumCoastalCities <= 1;

	xor	eax, eax
	cmp	edi, 1
	pop	edi
	setle	al
	pop	esi

; 3770 : }

	pop	ecx
	ret	0
?IsTestStrategy_OneOrFewerCoastalCities@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_OneOrFewerCoastalCities
_TEXT	ENDS
PUBLIC	?IsTestStrategy_HaltGrowthBuildings@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_HaltGrowthBuildings
EXTRN	?GetYieldChange@CvBuildingEntry@@QBEHH@Z:PROC	; CvBuildingEntry::GetYieldChange
EXTRN	?getDefaultBuildingIndex@CvBuildingClassInfo@@QBEHXZ:PROC ; CvBuildingClassInfo::getDefaultBuildingIndex
EXTRN	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z:PROC ; CvGlobals::getBuildingClassInfo
EXTRN	?GetFreeBuildingClass@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetFreeBuildingClass
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
EXTRN	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ:PROC ; CvPlayer::GetCitySpecializationAI
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_HaltGrowthBuildings@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_HaltGrowthBuildings@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_HaltGrowthBuildings, COMDAT

; 3791 : 	BuildingTypes eNextDesiredWonder = pPlayer->GetCitySpecializationAI()->GetNextWonderDesired();

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	push	esi
	push	edi
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	esi, DWORD PTR [eax+196]

; 3792 : 
; 3793 : 	// Is average income below desired threshold over past X turns?
; 3794 : 	if(eNextDesiredWonder != NO_BUILDING)

	cmp	esi, -1
	je	SHORT $LN1@IsTestStra@4

; 3795 : 	{
; 3796 : 		CvBuildingXMLEntries* pkGameBuildings = GC.GetGameBuildings();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	edi, eax

; 3797 : 		CvBuildingEntry* pkBuildingInfo = pkGameBuildings->GetEntry(eNextDesiredWonder);

	push	esi
	mov	ecx, edi
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry

; 3798 : 		if(pkBuildingInfo)

	test	eax, eax
	je	SHORT $LN1@IsTestStra@4

; 3799 : 		{
; 3800 : 			BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkBuildingInfo->GetFreeBuildingClass();

	mov	ecx, eax
	call	?GetFreeBuildingClass@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetFreeBuildingClass

; 3801 : 			if(eBuildingClass != NO_BUILDINGCLASS)

	cmp	eax, -1
	je	SHORT $LN1@IsTestStra@4

; 3802 : 			{
; 3803 : 				CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo

; 3804 : 				{
; 3805 : 					if(pkBuildingClassInfo)

	test	eax, eax
	je	SHORT $LN1@IsTestStra@4

; 3806 : 					{
; 3807 : 						BuildingTypes eBuilding = (BuildingTypes)pkBuildingClassInfo->getDefaultBuildingIndex();

	mov	ecx, eax
	call	?getDefaultBuildingIndex@CvBuildingClassInfo@@QBEHXZ ; CvBuildingClassInfo::getDefaultBuildingIndex

; 3808 : 						if(eBuilding != NO_BUILDING)

	cmp	eax, -1
	je	SHORT $LN1@IsTestStra@4

; 3809 : 						{
; 3810 : 							CvBuildingEntry* pkFreeBuildingInfo = pkGameBuildings->GetEntry(eBuilding);

	push	eax
	mov	ecx, edi
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry

; 3811 : 							if(pkFreeBuildingInfo)

	test	eax, eax
	je	SHORT $LN1@IsTestStra@4

; 3812 : 							{
; 3813 : 								if(pkFreeBuildingInfo->GetYieldChange(YIELD_FOOD) > 0)

	push	0
	mov	ecx, eax
	call	?GetYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetYieldChange
	test	eax, eax
	jle	SHORT $LN1@IsTestStra@4
	pop	edi

; 3814 : 								{
; 3815 : 									return true;

	mov	al, 1
	pop	esi

; 3825 : }

	ret	0
$LN1@IsTestStra@4:
	pop	edi

; 3816 : 								}
; 3817 : 							}
; 3818 : 						}
; 3819 : 					}
; 3820 : 				}
; 3821 : 			}
; 3822 : 		}
; 3823 : 	}
; 3824 : 	return false;

	xor	al, al
	pop	esi

; 3825 : }

	ret	0
?IsTestStrategy_HaltGrowthBuildings@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_HaltGrowthBuildings
_TEXT	ENDS
PUBLIC	?IsTestStrategy_TooManyUnits@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_TooManyUnits
EXTRN	?GetUnitProductionMaintenanceMod@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetUnitProductionMaintenanceMod
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_TooManyUnits@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_TooManyUnits@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_TooManyUnits, COMDAT

; 3830 : 	return (pPlayer->GetUnitProductionMaintenanceMod()) != 0;

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	call	?GetUnitProductionMaintenanceMod@CvPlayer@@QBEHXZ ; CvPlayer::GetUnitProductionMaintenanceMod
	neg	eax
	sbb	eax, eax
	neg	eax

; 3831 : }

	ret	0
?IsTestStrategy_TooManyUnits@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_TooManyUnits
_TEXT	ENDS
PUBLIC	?IsTestStrategy_MostlyOnTheCoast@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_MostlyOnTheCoast
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_MostlyOnTheCoast@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_iLoopCity$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_MostlyOnTheCoast@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_MostlyOnTheCoast, COMDAT

; 4006 : {

	push	ecx
	push	ebx

; 4007 : 	// total pop
; 4008 : 	int iInlandPop = 0;
; 4009 : 	int iCoastalPop = 0;
; 4010 : 	int iLoopCity = 0;
; 4011 : 	CvCity* pLoopCity = NULL;
; 4012 : 	for(pLoopCity = pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoopCity))

	mov	ebx, DWORD PTR _pPlayer$[esp+4]
	push	ebp
	push	esi
	push	edi
	xor	edi, edi
	push	edi
	lea	eax, DWORD PTR _iLoopCity$[esp+24]
	push	eax
	mov	ecx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _iLoopCity$[esp+28], edi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN12@IsTestStra@5
$LL5@IsTestStra@5:

; 4013 : 	{
; 4014 : 		if(pLoopCity->isCoastal(100))  // don't run this for lakes or even small inland seas

	push	100					; 00000064H
	mov	ecx, esi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal

; 4015 : 		{
; 4016 : 			iCoastalPop += pLoopCity->getPopulation();

	mov	ecx, esi
	test	al, al
	je	SHORT $LN2@IsTestStra@5
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	add	edi, eax

; 4017 : 		}
; 4018 : 		else

	jmp	SHORT $LN4@IsTestStra@5
$LN2@IsTestStra@5:

; 4019 : 		{
; 4020 : 			iInlandPop += pLoopCity->getPopulation();

	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	add	ebp, eax
$LN4@IsTestStra@5:
	push	0
	lea	ecx, DWORD PTR _iLoopCity$[esp+24]
	push	ecx
	mov	ecx, ebx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL5@IsTestStra@5

; 4021 : 		}
; 4022 : 	}
; 4023 : 	return (iCoastalPop > 0 && iCoastalPop >= iInlandPop);

	test	edi, edi
	jle	SHORT $LN12@IsTestStra@5
	cmp	edi, ebp
	jl	SHORT $LN12@IsTestStra@5
	pop	edi
	lea	eax, DWORD PTR [esi+1]
	pop	esi
	pop	ebp
	pop	ebx

; 4024 : }

	pop	ecx
	ret	0
$LN12@IsTestStra@5:
	pop	edi
	pop	esi
	pop	ebp

; 4021 : 		}
; 4022 : 	}
; 4023 : 	return (iCoastalPop > 0 && iCoastalPop >= iInlandPop);

	xor	eax, eax
	pop	ebx

; 4024 : }

	pop	ecx
	ret	0
?IsTestStrategy_MostlyOnTheCoast@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_MostlyOnTheCoast
_TEXT	ENDS
PUBLIC	?IsTestStrategy_GS_Culture@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Culture
EXTRN	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ:PROC ; CvGrandStrategyAI::GetActiveGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_GS_Culture@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_GS_Culture@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_GS_Culture, COMDAT

; 4078 : {

	push	esi

; 4079 : 	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");

	push	0
	push	OFFSET $SG228416
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, eax

; 4080 : 
; 4081 : 	if(eGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	esi, -1
	je	SHORT $LN1@IsTestStra@6

; 4082 : 	{
; 4083 : 		if(pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)

	mov	ecx, DWORD PTR _pPlayer$[esp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, esi
	jne	SHORT $LN1@IsTestStra@6

; 4084 : 		{
; 4085 : 			return true;

	mov	al, 1
	pop	esi

; 4090 : }

	ret	0
$LN1@IsTestStra@6:

; 4086 : 		}
; 4087 : 	}
; 4088 : 
; 4089 : 	return false;

	xor	al, al
	pop	esi

; 4090 : }

	ret	0
?IsTestStrategy_GS_Culture@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_GS_Culture
_TEXT	ENDS
PUBLIC	?IsTestStrategy_GS_Conquest@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Conquest
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_GS_Conquest@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_GS_Conquest@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_GS_Conquest, COMDAT

; 4094 : {

	push	esi

; 4095 : 	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");

	push	0
	push	OFFSET $SG228424
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, eax

; 4096 : 
; 4097 : 	if(eGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	esi, -1
	je	SHORT $LN1@IsTestStra@7

; 4098 : 	{
; 4099 : 		if(pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)

	mov	ecx, DWORD PTR _pPlayer$[esp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, esi
	jne	SHORT $LN1@IsTestStra@7

; 4100 : 		{
; 4101 : 			return true;

	mov	al, 1
	pop	esi

; 4106 : }

	ret	0
$LN1@IsTestStra@7:

; 4102 : 		}
; 4103 : 	}
; 4104 : 
; 4105 : 	return false;

	xor	al, al
	pop	esi

; 4106 : }

	ret	0
?IsTestStrategy_GS_Conquest@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_GS_Conquest
_TEXT	ENDS
PUBLIC	?IsTestStrategy_GS_Diplomacy@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Diplomacy
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_GS_Diplomacy@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_GS_Diplomacy@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_GS_Diplomacy, COMDAT

; 4110 : {

	push	esi

; 4111 : 	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS");

	push	0
	push	OFFSET $SG228432
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, eax

; 4112 : 
; 4113 : 	if(eGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	esi, -1
	je	SHORT $LN1@IsTestStra@8

; 4114 : 	{
; 4115 : 		if(pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)

	mov	ecx, DWORD PTR _pPlayer$[esp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, esi
	jne	SHORT $LN1@IsTestStra@8

; 4116 : 		{
; 4117 : 			return true;

	mov	al, 1
	pop	esi

; 4122 : }

	ret	0
$LN1@IsTestStra@8:

; 4118 : 		}
; 4119 : 	}
; 4120 : 
; 4121 : 	return false;

	xor	al, al
	pop	esi

; 4122 : }

	ret	0
?IsTestStrategy_GS_Diplomacy@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_GS_Diplomacy
_TEXT	ENDS
PUBLIC	?IsTestStrategy_GS_Spaceship@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Spaceship
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_GS_Spaceship@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_GS_Spaceship@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_GS_Spaceship, COMDAT

; 4126 : {

	push	esi

; 4127 : 	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP");

	push	0
	push	OFFSET $SG228440
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, eax

; 4128 : 
; 4129 : 	if(eGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	esi, -1
	je	SHORT $LN1@IsTestStra@9

; 4130 : 	{
; 4131 : 		if(pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)

	mov	ecx, DWORD PTR _pPlayer$[esp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, esi
	jne	SHORT $LN1@IsTestStra@9

; 4132 : 		{
; 4133 : 			return true;

	mov	al, 1
	pop	esi

; 4138 : }

	ret	0
$LN1@IsTestStra@9:

; 4134 : 		}
; 4135 : 	}
; 4136 : 
; 4137 : 	return false;

	xor	al, al
	pop	esi

; 4138 : }

	ret	0
?IsTestStrategy_GS_Spaceship@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_GS_Spaceship
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedArchaeologists
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedArchaeologists, COMDAT

; 4158 : {

	push	esi

; 4159 : 	int iNumSites = pPlayer->GetEconomicAI()->GetVisibleAntiquitySites();

	mov	esi, DWORD PTR _pPlayer$[esp]
	push	edi
	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	edi, DWORD PTR [eax+44]

; 4160 : 	int iNumArchaeologists = pPlayer->GetNumUnitsWithUnitAI(UNITAI_ARCHAEOLOGIST, true);

	push	1
	push	1
	push	39					; 00000027H
	mov	ecx, esi
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI

; 4161 : 
; 4162 : 	if (iNumSites > iNumArchaeologists)

	cmp	edi, eax
	pop	edi
	setg	al
	pop	esi

; 4163 : 	{
; 4164 : 		return true;
; 4165 : 	}
; 4166 : 
; 4167 : 	return false;
; 4168 : }

	ret	0
?IsTestStrategy_NeedArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedArchaeologists
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedMuseums@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedMuseums
EXTRN	?GetNumAvailableGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z:PROC ; CvPlayerCulture::GetNumAvailableGreatWorkSlots
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ:PROC ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedMuseums@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedMuseums@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedMuseums, COMDAT

; 4196 : {

	push	esi

; 4197 : 	int iNumSites = pPlayer->GetEconomicAI()->GetVisibleAntiquitySites();

	mov	esi, DWORD PTR _pPlayer$[esp]
	push	edi
	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	edi, DWORD PTR [eax+44]

; 4198 : 	GreatWorkSlotType eArtArtifactSlot = CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT();

	call	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT

; 4199 : 	int iNumGreatWorkSlots = pPlayer->GetCulture()->GetNumAvailableGreatWorkSlots(eArtArtifactSlot);

	push	eax
	mov	ecx, esi
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetNumAvailableGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z ; CvPlayerCulture::GetNumAvailableGreatWorkSlots

; 4200 : 
; 4201 : 	if (iNumSites > iNumGreatWorkSlots)

	cmp	edi, eax
	pop	edi
	setg	al
	pop	esi

; 4202 : 	{
; 4203 : 		return true;
; 4204 : 	}
; 4205 : 
; 4206 : 	return false;
; 4207 : }

	ret	0
?IsTestStrategy_NeedMuseums@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedMuseums
_TEXT	ENDS
PUBLIC	?IsTestStrategy_StartedPiety@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_StartedPiety
EXTRN	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z:PROC ; CvPlayerPolicies::IsPolicyBranchUnlocked
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_StartedPiety@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_StartedPiety@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_StartedPiety, COMDAT

; 4259 : 	bool bRtnValue = false;
; 4260 : 
; 4261 : 	PolicyBranchTypes eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PIETY", true);

	push	1
	push	OFFSET $SG228512
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4262 : 	if (eBranch != NO_POLICY_BRANCH_TYPE)

	cmp	eax, -1
	je	SHORT $LN1@IsTestStra@10

; 4263 : 	{
; 4264 : 		if (pPlayer->GetPlayerPolicies()->IsPolicyBranchUnlocked(eBranch))

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	push	eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	test	al, al
	je	SHORT $LN1@IsTestStra@10

; 4265 : 		{
; 4266 : 			return true;

	mov	al, 1

; 4271 : }

	ret	0
$LN1@IsTestStra@10:

; 4267 : 		}
; 4268 : 	}
; 4269 : 
; 4270 : 	return bRtnValue;

	xor	al, al

; 4271 : }

	ret	0
?IsTestStrategy_StartedPiety@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_StartedPiety
_TEXT	ENDS
PUBLIC	??A?$BaseVector@H$00@@QAEAAHI@Z			; BaseVector<int,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@H$00@@QAEAAHI@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@H$00@@QAEAAHI@Z PROC			; BaseVector<int,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@H$00@@QAEAAHI@Z ENDP			; BaseVector<int,1>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@H$00@@QBEABHI@Z			; BaseVector<int,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@H$00@@QBEABHI@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@H$00@@QBEABHI@Z PROC			; BaseVector<int,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 137  : 	};

	ret	4
??A?$BaseVector@H$00@@QBEABHI@Z ENDP			; BaseVector<int,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@H$00@@QBEIXZ			; BaseVector<int,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@H$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@H$00@@QBEIXZ PROC			; BaseVector<int,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@H$00@@QBEIXZ ENDP			; BaseVector<int,1>::size
_TEXT	ENDS
PUBLIC	??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator->
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator->, COMDAT
; _this$ = ecx

; 88   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 89   : 	}

	ret	0
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator->
_TEXT	ENDS
PUBLIC	??A?$BaseVector@H$0A@@@QAEAAHI@Z		; BaseVector<int,0>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@H$0A@@@QAEAAHI@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@H$0A@@@QAEAAHI@Z PROC			; BaseVector<int,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@H$0A@@@QAEAAHI@Z ENDP			; BaseVector<int,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@H$0A@@@QBEIXZ		; BaseVector<int,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@H$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@H$0A@@@QBEIXZ PROC			; BaseVector<int,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@H$0A@@@QBEIXZ ENDP			; BaseVector<int,0>::size
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvEconomicAIStrategyXMLEntry@@I@Z ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvEconomicAIStrategyXMLEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvEconomicAIStrategyXMLEntry@@I@Z PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAPAVCvEconomicAIStrategyXMLEntry@@I@Z ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@I$0A@@@QAEAAII@Z		; BaseVector<unsigned int,0>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@I$0A@@@QAEAAII@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@I$0A@@@QAEAAII@Z PROC			; BaseVector<unsigned int,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@I$0A@@@QAEAAII@Z ENDP			; BaseVector<unsigned int,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@I$0A@@@QBEIXZ		; BaseVector<unsigned int,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@I$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@I$0A@@@QBEIXZ PROC			; BaseVector<unsigned int,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@I$0A@@@QBEIXZ ENDP			; BaseVector<unsigned int,0>::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QAEAAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QAEAAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QAEAAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z PROC ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 131  : 	};

	ret	4
??A?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QAEAAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z ENDP ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QBEIXZ ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QBEIXZ PROC ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QBEIXZ ENDP ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvPurchaseRequest@@$00@@QAEAAVCvPurchaseRequest@@I@Z ; BaseVector<CvPurchaseRequest,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@VCvPurchaseRequest@@$00@@QAEAAVCvPurchaseRequest@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvPurchaseRequest@@$00@@QAEAAVCvPurchaseRequest@@I@Z PROC ; BaseVector<CvPurchaseRequest,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvPurchaseRequest@@$00@@QAEAAVCvPurchaseRequest@@I@Z ENDP ; BaseVector<CvPurchaseRequest,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvPurchaseRequest@@$00@@QBEIXZ ; BaseVector<CvPurchaseRequest,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@VCvPurchaseRequest@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvPurchaseRequest@@$00@@QBEIXZ PROC	; BaseVector<CvPurchaseRequest,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvPurchaseRequest@@$00@@QBEIXZ ENDP	; BaseVector<CvPurchaseRequest,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvPurchaseRequest@@$00@@QAEPAVCvPurchaseRequest@@XZ ; BaseVector<CvPurchaseRequest,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@VCvPurchaseRequest@@$00@@QAEPAVCvPurchaseRequest@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvPurchaseRequest@@$00@@QAEPAVCvPurchaseRequest@@XZ PROC ; BaseVector<CvPurchaseRequest,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@VCvPurchaseRequest@@$00@@QAEPAVCvPurchaseRequest@@XZ ENDP ; BaseVector<CvPurchaseRequest,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvPurchaseRequest@@$00@@QAEPAVCvPurchaseRequest@@XZ ; BaseVector<CvPurchaseRequest,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvPurchaseRequest@@$00@@QAEPAVCvPurchaseRequest@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvPurchaseRequest@@$00@@QAEPAVCvPurchaseRequest@@XZ PROC ; BaseVector<CvPurchaseRequest,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 198  :     };

	ret	0
?end@?$BaseVector@VCvPurchaseRequest@@$00@@QAEPAVCvPurchaseRequest@@XZ ENDP ; BaseVector<CvPurchaseRequest,1>::end
_TEXT	ENDS
PUBLIC	??A?$BaseVector@PAVCvUnit@@$0A@@@QAEAAPAVCvUnit@@I@Z ; BaseVector<CvUnit *,0>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@PAVCvUnit@@$0A@@@QAEAAPAVCvUnit@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@PAVCvUnit@@$0A@@@QAEAAPAVCvUnit@@I@Z PROC ; BaseVector<CvUnit *,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@PAVCvUnit@@$0A@@@QAEAAPAVCvUnit@@I@Z ENDP ; BaseVector<CvUnit *,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@PAVCvUnit@@$0A@@@QBEIXZ	; BaseVector<CvUnit *,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@PAVCvUnit@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@PAVCvUnit@@$0A@@@QBEIXZ PROC		; BaseVector<CvUnit *,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@PAVCvUnit@@$0A@@@QBEIXZ ENDP		; BaseVector<CvUnit *,0>::size
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapper@_N@@QAE@HPA_N@Z		; ArrayWrapper<bool>::ArrayWrapper<bool>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??0?$ArrayWrapper@_N@@QAE@HPA_N@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapper@_N@@QAE@HPA_N@Z PROC			; ArrayWrapper<bool>::ArrayWrapper<bool>, COMDAT
; _this$ = ecx

; 378  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapper@_N@@QAE@HPA_N@Z ENDP			; ArrayWrapper<bool>::ArrayWrapper<bool>
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapper@H@@QAE@HPAH@Z			; ArrayWrapper<int>::ArrayWrapper<int>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$ArrayWrapper@H@@QAE@HPAH@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapper@H@@QAE@HPAH@Z PROC			; ArrayWrapper<int>::ArrayWrapper<int>, COMDAT
; _this$ = ecx

; 378  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapper@H@@QAE@HPAH@Z ENDP			; ArrayWrapper<int>::ArrayWrapper<int>
_TEXT	ENDS
PUBLIC	??1?$BaseVector@H$00@@QAE@XZ			; BaseVector<int,1>::~BaseVector<int,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@H$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@H$00@@QAE@XZ PROC			; BaseVector<int,1>::~BaseVector<int,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@H$00@@QAE@XZ ENDP			; BaseVector<int,1>::~BaseVector<int,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@H$00@@IAE@XZ			; BaseVector<int,1>::BaseVector<int,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@H$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@H$00@@IAE@XZ PROC			; BaseVector<int,1>::BaseVector<int,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@H$00@@IAE@XZ ENDP			; BaseVector<int,1>::BaseVector<int,1>
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	??1?$BaseVector@H$0A@@@QAE@XZ			; BaseVector<int,0>::~BaseVector<int,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@H$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@H$0A@@@QAE@XZ PROC			; BaseVector<int,0>::~BaseVector<int,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@H$0A@@@QAE@XZ ENDP			; BaseVector<int,0>::~BaseVector<int,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@H$0A@@@IAE@XZ			; BaseVector<int,0>::BaseVector<int,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@H$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@H$0A@@@IAE@XZ PROC			; BaseVector<int,0>::BaseVector<int,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@H$0A@@@IAE@XZ ENDP			; BaseVector<int,0>::BaseVector<int,0>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvEconomicAIStrategyXMLEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvEconomicAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvEconomicAIStrategyXMLEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvEconomicAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvEconomicAIStrategyXMLEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvEconomicAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAE@XZ ; std::allocator<CvEconomicAIStrategyXMLEntry *>::allocator<CvEconomicAIStrategyXMLEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAE@XZ PROC ; std::allocator<CvEconomicAIStrategyXMLEntry *>::allocator<CvEconomicAIStrategyXMLEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAE@XZ ENDP ; std::allocator<CvEconomicAIStrategyXMLEntry *>::allocator<CvEconomicAIStrategyXMLEntry *>
_TEXT	ENDS
PUBLIC	??1?$BaseVector@I$0A@@@QAE@XZ			; BaseVector<unsigned int,0>::~BaseVector<unsigned int,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@I$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@I$0A@@@QAE@XZ PROC			; BaseVector<unsigned int,0>::~BaseVector<unsigned int,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@I$0A@@@QAE@XZ ENDP			; BaseVector<unsigned int,0>::~BaseVector<unsigned int,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@I$0A@@@IAE@XZ			; BaseVector<unsigned int,0>::BaseVector<unsigned int,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@I$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@I$0A@@@IAE@XZ PROC			; BaseVector<unsigned int,0>::BaseVector<unsigned int,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@I$0A@@@IAE@XZ ENDP			; BaseVector<unsigned int,0>::BaseVector<unsigned int,0>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@I$0A@@@IAEXPAII@Z		; BaseVector<unsigned int,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@I$0A@@@IAEXPAII@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@I$0A@@@IAEXPAII@Z PROC		; BaseVector<unsigned int,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@I$0A@@@IAEXPAII@Z ENDP		; BaseVector<unsigned int,0>::Destroy
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@I$0A@@@IAEXABV1@@Z		; BaseVector<unsigned int,0>::Copy
; Function compile flags: /Ogtpy
;	COMDAT ?Copy@?$BaseVector@I$0A@@@IAEXABV1@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@I$0A@@@IAEXABV1@@Z PROC		; BaseVector<unsigned int,0>::Copy, COMDAT
; _this$ = ecx

; 229  : 	void Copy(const THIS_TYPE& RHS){

	push	esi
	push	edi

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	edi, DWORD PTR _RHS$[esp+4]
	mov	eax, DWORD PTR [edi+4]

; 231  : 		if( bPODType ){
; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);
; 233  : 		}else{
; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){

	xor	esi, esi
	mov	DWORD PTR [ecx+4], eax
	test	eax, eax
	jbe	SHORT $LN1@Copy
	push	ebx
$LL3@Copy:
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [esi*4]
	add	eax, edx

; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );

	je	SHORT $LN2@Copy
	mov	ebx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+ebx]
	mov	DWORD PTR [eax], edx
$LN2@Copy:
	inc	esi
	cmp	esi, DWORD PTR [ecx+4]
	jb	SHORT $LL3@Copy
	pop	ebx
$LN1@Copy:
	pop	edi
	pop	esi

; 236  : 			}
; 237  : 		}
; 238  : 	};

	ret	4
?Copy@?$BaseVector@I$0A@@@IAEXABV1@@Z ENDP		; BaseVector<unsigned int,0>::Copy
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QAE@XZ ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::~BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QAE@XZ PROC ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::~BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QAE@XZ ENDP ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::~BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@IAE@XZ ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@IAE@XZ PROC ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@IAE@XZ ENDP ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEPAVCvPurchaseRequest@@I@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEPAVCvPurchaseRequest@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEPAVCvPurchaseRequest@@I@Z PROC ; FStaticVector<CvPurchaseRequest,6,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 6
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	lea	eax, DWORD PTR [edi+edi*2]
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 6
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEPAVCvPurchaseRequest@@I@Z ENDP ; FStaticVector<CvPurchaseRequest,6,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvPurchaseRequest@@$00@@QAE@XZ	; BaseVector<CvPurchaseRequest,1>::~BaseVector<CvPurchaseRequest,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvPurchaseRequest@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvPurchaseRequest@@$00@@QAE@XZ PROC	; BaseVector<CvPurchaseRequest,1>::~BaseVector<CvPurchaseRequest,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvPurchaseRequest@@$00@@QAE@XZ ENDP	; BaseVector<CvPurchaseRequest,1>::~BaseVector<CvPurchaseRequest,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvPurchaseRequest@@$00@@IAE@XZ	; BaseVector<CvPurchaseRequest,1>::BaseVector<CvPurchaseRequest,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvPurchaseRequest@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvPurchaseRequest@@$00@@IAE@XZ PROC	; BaseVector<CvPurchaseRequest,1>::BaseVector<CvPurchaseRequest,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvPurchaseRequest@@$00@@IAE@XZ ENDP	; BaseVector<CvPurchaseRequest,1>::BaseVector<CvPurchaseRequest,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvPurchaseRequest@@$00@@IAEXPAVCvPurchaseRequest@@I@Z ; BaseVector<CvPurchaseRequest,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvPurchaseRequest@@$00@@IAEXPAVCvPurchaseRequest@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvPurchaseRequest@@$00@@IAEXPAVCvPurchaseRequest@@I@Z PROC ; BaseVector<CvPurchaseRequest,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvPurchaseRequest@@$00@@IAEXPAVCvPurchaseRequest@@I@Z ENDP ; BaseVector<CvPurchaseRequest,1>::Destroy
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@VCvPurchaseRequest@@$00@@IAEXABV1@@Z ; BaseVector<CvPurchaseRequest,1>::Copy
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Copy@?$BaseVector@VCvPurchaseRequest@@$00@@IAEXABV1@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@VCvPurchaseRequest@@$00@@IAEXABV1@@Z PROC ; BaseVector<CvPurchaseRequest,1>::Copy, COMDAT
; _this$ = ecx

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _RHS$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 231  : 		if( bPODType ){
; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	lea	edx, DWORD PTR [edx+edx*2]
	add	edx, edx
	add	edx, edx
	push	edx
	push	eax
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 233  : 		}else{
; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){
; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );
; 236  : 			}
; 237  : 		}
; 238  : 	};

	ret	4
?Copy@?$BaseVector@VCvPurchaseRequest@@$00@@IAEXABV1@@Z ENDP ; BaseVector<CvPurchaseRequest,1>::Copy
_TEXT	ENDS
PUBLIC	??1?$BaseVector@PAVCvUnit@@$0A@@@QAE@XZ		; BaseVector<CvUnit *,0>::~BaseVector<CvUnit *,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@PAVCvUnit@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@PAVCvUnit@@$0A@@@QAE@XZ PROC		; BaseVector<CvUnit *,0>::~BaseVector<CvUnit *,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@PAVCvUnit@@$0A@@@QAE@XZ ENDP		; BaseVector<CvUnit *,0>::~BaseVector<CvUnit *,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@PAVCvUnit@@$0A@@@IAE@XZ		; BaseVector<CvUnit *,0>::BaseVector<CvUnit *,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@PAVCvUnit@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@PAVCvUnit@@$0A@@@IAE@XZ PROC		; BaseVector<CvUnit *,0>::BaseVector<CvUnit *,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@PAVCvUnit@@$0A@@@IAE@XZ ENDP		; BaseVector<CvUnit *,0>::BaseVector<CvUnit *,0>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXPAPAVCvUnit@@I@Z ; BaseVector<CvUnit *,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXPAPAVCvUnit@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXPAPAVCvUnit@@I@Z PROC ; BaseVector<CvUnit *,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXPAPAVCvUnit@@I@Z ENDP ; BaseVector<CvUnit *,0>::Destroy
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXABV1@@Z	; BaseVector<CvUnit *,0>::Copy
; Function compile flags: /Ogtpy
;	COMDAT ?Copy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXABV1@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXABV1@@Z PROC	; BaseVector<CvUnit *,0>::Copy, COMDAT
; _this$ = ecx

; 229  : 	void Copy(const THIS_TYPE& RHS){

	push	esi
	push	edi

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	edi, DWORD PTR _RHS$[esp+4]
	mov	eax, DWORD PTR [edi+4]

; 231  : 		if( bPODType ){
; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);
; 233  : 		}else{
; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){

	xor	esi, esi
	mov	DWORD PTR [ecx+4], eax
	test	eax, eax
	jbe	SHORT $LN1@Copy@2
	push	ebx
$LL3@Copy@2:
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [esi*4]
	add	eax, edx

; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );

	je	SHORT $LN2@Copy@2
	mov	ebx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+ebx]
	mov	DWORD PTR [eax], edx
$LN2@Copy@2:
	inc	esi
	cmp	esi, DWORD PTR [ecx+4]
	jb	SHORT $LL3@Copy@2
	pop	ebx
$LN1@Copy@2:
	pop	edi
	pop	esi

; 236  : 			}
; 237  : 		}
; 238  : 	};

	ret	4
?Copy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXABV1@@Z ENDP	; BaseVector<CvUnit *,0>::Copy
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEABQAVCvEconomicAIStrategyXMLEntry@@XZ ; std::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEABQAVCvEconomicAIStrategyXMLEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEABQAVCvEconomicAIStrategyXMLEntry@@XZ PROC ; std::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEABQAVCvEconomicAIStrategyXMLEntry@@XZ ENDP ; std::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator==
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@XZ ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@XZ PROC ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@XZ ENDP ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@XZ ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@XZ PROC ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@XZ ENDP ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ ; CvWeightedVector<CvUnit *,50,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ PROC ; CvWeightedVector<CvUnit *,50,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ ENDP ; CvWeightedVector<CvUnit *,50,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@H$00@@IAEXPAHI@Z		; BaseVector<int,1>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@H$00@@IAEXPAHI@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@H$00@@IAEXPAHI@Z PROC		; BaseVector<int,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@H$00@@IAEXPAHI@Z ENDP		; BaseVector<int,1>::Destroy
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z		; BaseVector<int,0>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z PROC		; BaseVector<int,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z ENDP		; BaseVector<int,0>::Destroy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T232159 = -80						; size = 28
$T232158 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T232159[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T232158[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T232159[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T232158[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T232158[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T232158[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T232158[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T232159[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T232158[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvEconomicAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvEconomicAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvEconomicAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvEconomicAIStrategyXMLEntry *>::allocator<CvEconomicAIStrategyXMLEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvEconomicAIStrategyXMLEntry *>::allocator<CvEconomicAIStrategyXMLEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvEconomicAIStrategyXMLEntry *>::allocator<CvEconomicAIStrategyXMLEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAEXPAPAVCvEconomicAIStrategyXMLEntry@@I@Z ; std::allocator<CvEconomicAIStrategyXMLEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAEXPAPAVCvEconomicAIStrategyXMLEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAEXPAPAVCvEconomicAIStrategyXMLEntry@@I@Z PROC ; std::allocator<CvEconomicAIStrategyXMLEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAEXPAPAVCvEconomicAIStrategyXMLEntry@@I@Z ENDP ; std::allocator<CvEconomicAIStrategyXMLEntry *>::deallocate
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@IAEXPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@IAEXPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@IAEXPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z PROC ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@IAEXPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z ENDP ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::Destroy
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvEconomicAIStrategyXMLEntry@@@Z ; std::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvEconomicAIStrategyXMLEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvEconomicAIStrategyXMLEntry@@@Z PROC ; std::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvEconomicAIStrategyXMLEntry@@@Z ENDP ; std::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 50					; 00000032H
	jbe	SHORT $LN2@Alloc@2

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@2:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 50			; 00000032H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@ABU01@@Z ; CvWeightedVector<CvUnit *,50,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<CvUnit *,50,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<CvUnit *,50,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@I$0A@@@SAPAXIIII@Z ; BaseVector<unsigned int,0>::FDefaultFastVectorAllocator::AllocAligned
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@I$0A@@@SAPAXIIII@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_nAlign$ = 12						; size = 4
_nAllocPool$ = 16					; size = 4
_nAllocSubID$ = 20					; size = 4
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@I$0A@@@SAPAXIIII@Z PROC ; BaseVector<unsigned int,0>::FDefaultFastVectorAllocator::AllocAligned, COMDAT

; 85   : 			return FMALLOCALIGNED( nBytes, nAlign, nAllocPool, nAllocSubID );

	mov	DWORD PTR _nAllocSubID$[esp-4], 85	; 00000055H
	mov	DWORD PTR _nAllocPool$[esp-4], OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	jmp	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@I$0A@@@SAPAXIIII@Z ENDP ; BaseVector<unsigned int,0>::FDefaultFastVectorAllocator::AllocAligned
_TEXT	ENDS
PUBLIC	?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@I$0A@@@SAXPAX@Z ; BaseVector<unsigned int,0>::FDefaultFastVectorAllocator::FreeAligned
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@I$0A@@@SAXPAX@Z
_TEXT	SEGMENT
_pBlock$ = 8						; size = 4
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@I$0A@@@SAXPAX@Z PROC ; BaseVector<unsigned int,0>::FDefaultFastVectorAllocator::FreeAligned, COMDAT

; 90   : 			FFREEALIGNED( pBlock );

	jmp	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@I$0A@@@SAXPAX@Z ENDP ; BaseVector<unsigned int,0>::FDefaultFastVectorAllocator::FreeAligned
_TEXT	ENDS
PUBLIC	?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@H$0A@@@SAPAXIIII@Z ; BaseVector<int,0>::FDefaultFastVectorAllocator::AllocAligned
; Function compile flags: /Ogtpy
;	COMDAT ?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@H$0A@@@SAPAXIIII@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_nAlign$ = 12						; size = 4
_nAllocPool$ = 16					; size = 4
_nAllocSubID$ = 20					; size = 4
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@H$0A@@@SAPAXIIII@Z PROC ; BaseVector<int,0>::FDefaultFastVectorAllocator::AllocAligned, COMDAT

; 85   : 			return FMALLOCALIGNED( nBytes, nAlign, nAllocPool, nAllocSubID );

	mov	DWORD PTR _nAllocSubID$[esp-4], 85	; 00000055H
	mov	DWORD PTR _nAllocPool$[esp-4], OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	jmp	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@H$0A@@@SAPAXIIII@Z ENDP ; BaseVector<int,0>::FDefaultFastVectorAllocator::AllocAligned
_TEXT	ENDS
PUBLIC	?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@H$0A@@@SAXPAX@Z ; BaseVector<int,0>::FDefaultFastVectorAllocator::FreeAligned
; Function compile flags: /Ogtpy
;	COMDAT ?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@H$0A@@@SAXPAX@Z
_TEXT	SEGMENT
_pBlock$ = 8						; size = 4
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@H$0A@@@SAXPAX@Z PROC ; BaseVector<int,0>::FDefaultFastVectorAllocator::FreeAligned, COMDAT

; 90   : 			FFREEALIGNED( pBlock );

	jmp	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@H$0A@@@SAXPAX@Z ENDP ; BaseVector<int,0>::FDefaultFastVectorAllocator::FreeAligned
_TEXT	ENDS
PUBLIC	?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@SAPAXIIII@Z ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator::AllocAligned
; Function compile flags: /Ogtpy
;	COMDAT ?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@SAPAXIIII@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_nAlign$ = 12						; size = 4
_nAllocPool$ = 16					; size = 4
_nAllocSubID$ = 20					; size = 4
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@SAPAXIIII@Z PROC ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator::AllocAligned, COMDAT

; 85   : 			return FMALLOCALIGNED( nBytes, nAlign, nAllocPool, nAllocSubID );

	mov	DWORD PTR _nAllocSubID$[esp-4], 85	; 00000055H
	mov	DWORD PTR _nAllocPool$[esp-4], OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	jmp	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@SAPAXIIII@Z ENDP ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator::AllocAligned
_TEXT	ENDS
PUBLIC	?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@SAXPAX@Z ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator::FreeAligned
; Function compile flags: /Ogtpy
;	COMDAT ?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@SAXPAX@Z
_TEXT	SEGMENT
_pBlock$ = 8						; size = 4
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@SAXPAX@Z PROC ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator::FreeAligned, COMDAT

; 90   : 			FFREEALIGNED( pBlock );

	jmp	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@SAXPAX@Z ENDP ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator::FreeAligned
_TEXT	ENDS
PUBLIC	?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@SAPAXIIII@Z ; BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator::AllocAligned
; Function compile flags: /Ogtpy
;	COMDAT ?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@SAPAXIIII@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_nAlign$ = 12						; size = 4
_nAllocPool$ = 16					; size = 4
_nAllocSubID$ = 20					; size = 4
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@SAPAXIIII@Z PROC ; BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator::AllocAligned, COMDAT

; 85   : 			return FMALLOCALIGNED( nBytes, nAlign, nAllocPool, nAllocSubID );

	mov	DWORD PTR _nAllocSubID$[esp-4], 85	; 00000055H
	mov	DWORD PTR _nAllocPool$[esp-4], OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	jmp	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@SAPAXIIII@Z ENDP ; BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator::AllocAligned
_TEXT	ENDS
PUBLIC	?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@SAXPAX@Z ; BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator::FreeAligned
; Function compile flags: /Ogtpy
;	COMDAT ?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@SAXPAX@Z
_TEXT	SEGMENT
_pBlock$ = 8						; size = 4
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@SAXPAX@Z PROC ; BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator::FreeAligned, COMDAT

; 90   : 			FFREEALIGNED( pBlock );

	jmp	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@SAXPAX@Z ENDP ; BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator::FreeAligned
_TEXT	ENDS
PUBLIC	?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@H$00@@SAPAXIIII@Z ; BaseVector<int,1>::FDefaultFastVectorAllocator::AllocAligned
; Function compile flags: /Ogtpy
;	COMDAT ?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@H$00@@SAPAXIIII@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_nAlign$ = 12						; size = 4
_nAllocPool$ = 16					; size = 4
_nAllocSubID$ = 20					; size = 4
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@H$00@@SAPAXIIII@Z PROC ; BaseVector<int,1>::FDefaultFastVectorAllocator::AllocAligned, COMDAT

; 85   : 			return FMALLOCALIGNED( nBytes, nAlign, nAllocPool, nAllocSubID );

	mov	DWORD PTR _nAllocSubID$[esp-4], 85	; 00000055H
	mov	DWORD PTR _nAllocPool$[esp-4], OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	jmp	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@H$00@@SAPAXIIII@Z ENDP ; BaseVector<int,1>::FDefaultFastVectorAllocator::AllocAligned
_TEXT	ENDS
PUBLIC	?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@H$00@@SAXPAX@Z ; BaseVector<int,1>::FDefaultFastVectorAllocator::FreeAligned
; Function compile flags: /Ogtpy
;	COMDAT ?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@H$00@@SAXPAX@Z
_TEXT	SEGMENT
_pBlock$ = 8						; size = 4
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@H$00@@SAXPAX@Z PROC ; BaseVector<int,1>::FDefaultFastVectorAllocator::FreeAligned, COMDAT

; 90   : 			FFREEALIGNED( pBlock );

	jmp	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@H$00@@SAXPAX@Z ENDP ; BaseVector<int,1>::FDefaultFastVectorAllocator::FreeAligned
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QBEIXZ ; std::allocator<CvEconomicAIStrategyXMLEntry *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QBEIXZ PROC ; std::allocator<CvEconomicAIStrategyXMLEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvEconomicAIStrategyXMLEntry *>::max_size
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvEconomicAIStrategyXMLEntry@@@@YAXAAPAVCvEconomicAIStrategyXMLEntry@@@Z ; SAFE_DELETE<CvEconomicAIStrategyXMLEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE@VCvEconomicAIStrategyXMLEntry@@@@YAXAAPAVCvEconomicAIStrategyXMLEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvEconomicAIStrategyXMLEntry@@@@YAXAAPAVCvEconomicAIStrategyXMLEntry@@@Z PROC ; SAFE_DELETE<CvEconomicAIStrategyXMLEntry>, COMDAT

; 305  : {

	push	esi

; 306  : 	delete pkInstance;

	mov	esi, DWORD PTR _pkInstance$[esp]
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@SAFE_DELET
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN5@SAFE_DELET:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvEconomicAIStrategyXMLEntry@@@@YAXAAPAVCvEconomicAIStrategyXMLEntry@@@Z ENDP ; SAFE_DELETE<CvEconomicAIStrategyXMLEntry>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z		; SAFE_DELETE_ARRAY<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z PROC		; SAFE_DELETE_ARRAY<bool>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z ENDP		; SAFE_DELETE_ARRAY<bool>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jb	SHORT $LN4@min@2
	mov	eax, ecx
$LN4@min@2:

; 3400 : 	}

	ret	0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVCvEconomicAIStrategyXMLEntry@@@std@@YAPAPAVCvEconomicAIStrategyXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvEconomicAIStrategyXMLEntry *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVCvEconomicAIStrategyXMLEntry@@@std@@YAPAPAVCvEconomicAIStrategyXMLEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T232300 = -12						; size = 12
$T232304 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvEconomicAIStrategyXMLEntry@@@std@@YAPAPAVCvEconomicAIStrategyXMLEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvEconomicAIStrategyXMLEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T232304[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T232300[esp+16]
	mov	DWORD PTR $T232304[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T232300[esp+16]
	push	ecx
	mov	DWORD PTR $T232300[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@PAVCvEconomicAIStrategyXMLEntry@@@std@@YAPAPAVCvEconomicAIStrategyXMLEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvEconomicAIStrategyXMLEntry *>
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@_N@@QAEPA_NXZ		; ArrayWrapper<bool>::getArray
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ?getArray@?$ArrayWrapper@_N@@QAEPA_NXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@_N@@QAEPA_NXZ PROC		; ArrayWrapper<bool>::getArray, COMDAT
; _this$ = ecx

; 382  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 383  : 	}

	ret	0
?getArray@?$ArrayWrapper@_N@@QAEPA_NXZ ENDP		; ArrayWrapper<bool>::getArray
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@_N@@QBEPB_NXZ		; ArrayWrapper<bool>::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapper@_N@@QBEPB_NXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@_N@@QBEPB_NXZ PROC		; ArrayWrapper<bool>::getArray, COMDAT
; _this$ = ecx

; 386  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 387  : 	}

	ret	0
?getArray@?$ArrayWrapper@_N@@QBEPB_NXZ ENDP		; ArrayWrapper<bool>::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapper@_N@@QBEHXZ		; ArrayWrapper<bool>::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapper@_N@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapper@_N@@QBEHXZ PROC		; ArrayWrapper<bool>::getCount, COMDAT
; _this$ = ecx

; 391  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 392  : 	}

	ret	0
?getCount@?$ArrayWrapper@_N@@QBEHXZ ENDP		; ArrayWrapper<bool>::getCount
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@H@@QAEPAHXZ		; ArrayWrapper<int>::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapper@H@@QAEPAHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@H@@QAEPAHXZ PROC		; ArrayWrapper<int>::getArray, COMDAT
; _this$ = ecx

; 382  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 383  : 	}

	ret	0
?getArray@?$ArrayWrapper@H@@QAEPAHXZ ENDP		; ArrayWrapper<int>::getArray
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@H@@QBEPBHXZ		; ArrayWrapper<int>::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapper@H@@QBEPBHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@H@@QBEPBHXZ PROC		; ArrayWrapper<int>::getArray, COMDAT
; _this$ = ecx

; 386  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 387  : 	}

	ret	0
?getArray@?$ArrayWrapper@H@@QBEPBHXZ ENDP		; ArrayWrapper<int>::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapper@H@@QBEHXZ		; ArrayWrapper<int>::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapper@H@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapper@H@@QBEHXZ PROC			; ArrayWrapper<int>::getCount, COMDAT
; _this$ = ecx

; 391  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 392  : 	}

	ret	0
?getCount@?$ArrayWrapper@H@@QBEHXZ ENDP			; ArrayWrapper<int>::getCount
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAVCvPurchaseRequest@@@std@@YAPAHPAVCvPurchaseRequest@@@Z ; std::_Dist_type<CvPurchaseRequest *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@PAVCvPurchaseRequest@@@std@@YAPAHPAVCvPurchaseRequest@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAVCvPurchaseRequest@@@std@@YAPAHPAVCvPurchaseRequest@@@Z PROC ; std::_Dist_type<CvPurchaseRequest *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAVCvPurchaseRequest@@@std@@YAPAHPAVCvPurchaseRequest@@@Z ENDP ; std::_Dist_type<CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAVCvPurchaseRequest@@@std@@YAPAVCvPurchaseRequest@@PAV1@@Z ; std::_Val_type<CvPurchaseRequest *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAVCvPurchaseRequest@@@std@@YAPAVCvPurchaseRequest@@PAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAVCvPurchaseRequest@@@std@@YAPAVCvPurchaseRequest@@PAV1@@Z PROC ; std::_Val_type<CvPurchaseRequest *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAVCvPurchaseRequest@@@std@@YAPAVCvPurchaseRequest@@PAV1@@Z ENDP ; std::_Val_type<CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEconomicAIStrategyXMLEntry@@0@Z ; std::_Iter_random<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEconomicAIStrategyXMLEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEconomicAIStrategyXMLEntry@@0@Z PROC ; std::_Iter_random<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvEconomicAIStrategyXMLEntry@@0@Z ENDP ; std::_Iter_random<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEconomicAIStrategyXMLEntry@@0@Z ; std::_Ptr_cat<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEconomicAIStrategyXMLEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEconomicAIStrategyXMLEntry@@0@Z PROC ; std::_Ptr_cat<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvEconomicAIStrategyXMLEntry@@0@Z ENDP ; std::_Ptr_cat<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvEconomicAIStrategyXMLEntry@@0AAV?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvEconomicAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvEconomicAIStrategyXMLEntry@@0AAV?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvEconomicAIStrategyXMLEntry@@0AAV?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvEconomicAIStrategyXMLEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvEconomicAIStrategyXMLEntry@@0AAV?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvEconomicAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@H@Z ; std::_Temp_iterator<CvPurchaseRequest>::_Temp_iterator<CvPurchaseRequest>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@H@Z PROC ; std::_Temp_iterator<CvPurchaseRequest>::_Temp_iterator<CvPurchaseRequest>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@H@Z ENDP ; std::_Temp_iterator<CvPurchaseRequest>::_Temp_iterator<CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@@Z ; std::_Destroy<CvPurchaseRequest>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@VCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@@Z PROC ; std::_Destroy<CvPurchaseRequest>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@@Z ENDP ; std::_Destroy<CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@VCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@@Z ; std::return_temporary_buffer<CvPurchaseRequest>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$return_temporary_buffer@VCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@VCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@@Z PROC ; std::return_temporary_buffer<CvPurchaseRequest>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@VCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@@Z ENDP ; std::return_temporary_buffer<CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QBE_NABU01@@Z ; CvWeightedVector<CvUnit *,50,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??MWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<CvUnit *,50,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<CvUnit *,50,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::pair<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>::pair<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z PROC ; std::pair<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>::pair<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ENDP ; std::pair<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>::pair<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAVCvPurchaseRequest@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPurchaseRequest@@@Z ; std::_Iter_cat<CvPurchaseRequest *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAVCvPurchaseRequest@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPurchaseRequest@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAVCvPurchaseRequest@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPurchaseRequest@@@Z PROC ; std::_Iter_cat<CvPurchaseRequest *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAVCvPurchaseRequest@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPurchaseRequest@@@Z ENDP ; std::_Iter_cat<CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	??$_Distance2@PAVCvPurchaseRequest@@H@std@@YAXPAVCvPurchaseRequest@@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<CvPurchaseRequest *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Distance2@PAVCvPurchaseRequest@@H@std@@YAXPAVCvPurchaseRequest@@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PAVCvPurchaseRequest@@H@std@@YAXPAVCvPurchaseRequest@@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<CvPurchaseRequest *,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@PAVCvPurchaseRequest@@H@std@@YAXPAVCvPurchaseRequest@@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<CvPurchaseRequest *,int>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@Z ; std::_Dist_type<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<CvPurchaseRequest>::_Init
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Init@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<CvPurchaseRequest>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<CvPurchaseRequest>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QBEPAVCvPurchaseRequest@@XZ ; std::_Temp_iterator<CvPurchaseRequest>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QBEPAVCvPurchaseRequest@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QBEPAVCvPurchaseRequest@@XZ PROC ; std::_Temp_iterator<CvPurchaseRequest>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QBEPAVCvPurchaseRequest@@XZ ENDP ; std::_Temp_iterator<CvPurchaseRequest>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QBEPAVCvPurchaseRequest@@XZ ; std::_Temp_iterator<CvPurchaseRequest>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QBEPAVCvPurchaseRequest@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QBEPAVCvPurchaseRequest@@XZ PROC ; std::_Temp_iterator<CvPurchaseRequest>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QBEPAVCvPurchaseRequest@@XZ ENDP ; std::_Temp_iterator<CvPurchaseRequest>::_Last
_TEXT	ENDS
PUBLIC	??0?$pair@PAVCvPurchaseRequest@@H@std@@QAE@ABQAVCvPurchaseRequest@@ABH@Z ; std::pair<CvPurchaseRequest *,int>::pair<CvPurchaseRequest *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAVCvPurchaseRequest@@H@std@@QAE@ABQAVCvPurchaseRequest@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAVCvPurchaseRequest@@H@std@@QAE@ABQAVCvPurchaseRequest@@ABH@Z PROC ; std::pair<CvPurchaseRequest *,int>::pair<CvPurchaseRequest *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAVCvPurchaseRequest@@H@std@@QAE@ABQAVCvPurchaseRequest@@ABH@Z ENDP ; std::pair<CvPurchaseRequest *,int>::pair<CvPurchaseRequest *,int>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<CvPurchaseRequest>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<CvPurchaseRequest>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<CvPurchaseRequest>::operator=
_TEXT	ENDS
PUBLIC	??$_Advance@PAVCvPurchaseRequest@@H@std@@YAXAAPAVCvPurchaseRequest@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CvPurchaseRequest *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Advance@PAVCvPurchaseRequest@@H@std@@YAXAAPAVCvPurchaseRequest@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAVCvPurchaseRequest@@H@std@@YAXAAPAVCvPurchaseRequest@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CvPurchaseRequest *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAVCvPurchaseRequest@@H@std@@YAXAAPAVCvPurchaseRequest@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CvPurchaseRequest *,int>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::swap<CvWeightedVector<CvUnit *,50,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z PROC ; std::swap<CvWeightedVector<CvUnit *,50,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ENDP ; std::swap<CvWeightedVector<CvUnit *,50,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$swap@VCvPurchaseRequest@@@std@@YAXAAVCvPurchaseRequest@@0@Z ; std::swap<CvPurchaseRequest>
; Function compile flags: /Ogtpy
;	COMDAT ??$swap@VCvPurchaseRequest@@@std@@YAXAAVCvPurchaseRequest@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvPurchaseRequest@@@std@@YAXAAVCvPurchaseRequest@@0@Z PROC ; std::swap<CvPurchaseRequest>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	ebx

; 21   : 
; 22   : 		_Left = _Right;

	mov	ebx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebx

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	pop	edi
	pop	esi
	pop	ebx
$LN1@swap@2:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@VCvPurchaseRequest@@@std@@YAXAAVCvPurchaseRequest@@0@Z ENDP ; std::swap<CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvPurchaseRequest@@ABV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Iter_random<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvPurchaseRequest@@ABV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvPurchaseRequest@@ABV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z PROC ; std::_Iter_random<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvPurchaseRequest@@ABV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ENDP ; std::_Iter_random<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvPurchaseRequest@@AAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Ptr_cat<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvPurchaseRequest@@AAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvPurchaseRequest@@AAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z PROC ; std::_Ptr_cat<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvPurchaseRequest@@AAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ENDP ; std::_Ptr_cat<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvPurchaseRequest@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPurchaseRequest@@00@Z ; std::_Iter_random<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvPurchaseRequest@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPurchaseRequest@@00@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvPurchaseRequest@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPurchaseRequest@@00@Z PROC ; std::_Iter_random<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvPurchaseRequest@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPurchaseRequest@@00@Z ENDP ; std::_Iter_random<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap
	npad	1
$LL3@Push_heap:
	cmp	DWORD PTR [esi+eax*8+4], ebx
	jle	SHORT $LN1@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	edx, DWORD PTR [esi+eax*8+4]
	mov	DWORD PTR [esi+ecx*8+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap
$LN1@Push_heap:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [esi+ecx*8+4], ebx
	mov	DWORD PTR [esi+ecx*8], eax
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::_Iter_random<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvPurchaseRequest>::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??D?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvPurchaseRequest>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvPurchaseRequest>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvPurchaseRequest>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvPurchaseRequest>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvPurchaseRequest>::operator++
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvPurchaseRequest@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPurchaseRequest@@0@Z ; std::_Iter_random<CvPurchaseRequest *,CvPurchaseRequest *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvPurchaseRequest@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPurchaseRequest@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvPurchaseRequest@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPurchaseRequest@@0@Z PROC ; std::_Iter_random<CvPurchaseRequest *,CvPurchaseRequest *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvPurchaseRequest@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvPurchaseRequest@@0@Z ENDP ; std::_Iter_random<CvPurchaseRequest *,CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvPurchaseRequest@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvPurchaseRequest@@0@Z ; std::_Ptr_cat<CvPurchaseRequest *,CvPurchaseRequest *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvPurchaseRequest@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvPurchaseRequest@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvPurchaseRequest@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvPurchaseRequest@@0@Z PROC ; std::_Ptr_cat<CvPurchaseRequest *,CvPurchaseRequest *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvPurchaseRequest@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvPurchaseRequest@@0@Z ENDP ; std::_Ptr_cat<CvPurchaseRequest *,CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvPurchaseRequest@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvPurchaseRequest@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvPurchaseRequest@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@2
	push	esi
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@2
	pop	esi
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvPurchaseRequest@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvPurchaseRequest@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvPurchaseRequest@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvPurchaseRequest@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@2
	push	esi
$LL3@Copy_opt@2:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@2
	pop	esi
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvPurchaseRequest@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@ABV1@@Z ; std::_Construct<CvPurchaseRequest,CvPurchaseRequest>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@VCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@ABV1@@Z PROC ; std::_Construct<CvPurchaseRequest,CvPurchaseRequest>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@VCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@ABV1@@Z ENDP ; std::_Construct<CvPurchaseRequest,CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvPurchaseRequest@@0ABV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Iter_random<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvPurchaseRequest@@0ABV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvPurchaseRequest@@0ABV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z PROC ; std::_Iter_random<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvPurchaseRequest@@0ABV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ENDP ; std::_Iter_random<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00PAH0@Z ; std::_Rotate<CvPurchaseRequest *,int,CvPurchaseRequest>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00PAH0@Z
_TEXT	SEGMENT
__Holeval$230988 = -12					; size = 12
__First$ = 8						; size = 4
tv172 = 12						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00PAH0@Z PROC ; std::_Rotate<CvPurchaseRequest *,int,CvPurchaseRequest>, COMDAT

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	ecx, DWORD PTR __Mid$[esp-4]
	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, DWORD PTR __First$[esp+12]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp+12]
	push	ebp
	sar	edx, 1
	push	esi
	push	edi
	mov	edi, edx
	sub	ecx, ebx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	ebp, ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	esi, edi
	test	edi, edi
	je	SHORT $LN7@Rotate
	npad	1
$LL8@Rotate:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, ebp
	cdq
	idiv	esi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	ebp, esi
	mov	esi, edx
	test	edx, edx
	jne	SHORT $LL8@Rotate
$LN7@Rotate:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	ebp, ecx
	jge	$LN3@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	test	ebp, ebp
	jle	$LN3@Rotate
	lea	eax, DWORD PTR [edi+edi*2]
	add	eax, eax
	add	eax, eax
	lea	ecx, DWORD PTR [ebp+ebp*2]
	mov	DWORD PTR tv172[esp+24], eax
	lea	ebx, DWORD PTR [ebx+ecx*4]
	npad	1
$LL5@Rotate:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;
; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx]
	mov	DWORD PTR __Holeval$230988[esp+32], ecx
	mov	DWORD PTR __Holeval$230988[esp+28], edx
	mov	edx, DWORD PTR [ebx+8]

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	lea	ecx, DWORD PTR [ebx+eax]
	mov	esi, ebx
	mov	DWORD PTR __Holeval$230988[esp+36], edx
	cmp	ecx, DWORD PTR __Last$[esp+24]
	jne	SHORT $LN11@Rotate
	mov	ecx, DWORD PTR __First$[esp+24]
$LN11@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, ebx
	je	SHORT $LN22@Rotate
$LL2@Rotate:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], edx
	mov	eax, DWORD PTR [ecx+8]

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edx, DWORD PTR __Last$[esp+24]
	mov	DWORD PTR [esi+8], eax
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	mov	esi, ecx
	jge	SHORT $LN13@Rotate
	add	ecx, DWORD PTR tv172[esp+24]
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	mov	edx, DWORD PTR __First$[esp+24]
	mov	ecx, edi
	sub	ecx, eax
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [edx+ecx*4]
$LN14@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, ebx
	jne	SHORT $LL2@Rotate
	mov	eax, DWORD PTR tv172[esp+24]
$LN22@Rotate:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	ecx, DWORD PTR __Holeval$230988[esp+28]
	mov	edx, DWORD PTR __Holeval$230988[esp+32]
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR __Holeval$230988[esp+36]
	dec	ebp
	sub	ebx, 12					; 0000000cH
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+8], ecx
	test	ebp, ebp
	jg	$LL5@Rotate
$LN3@Rotate:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1706 : 			}
; 1707 : 	}

	add	esp, 12					; 0000000cH
	ret	0
??$_Rotate@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00PAH0@Z ENDP ; std::_Rotate<CvPurchaseRequest *,int,CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?GetCString@CvString@@QBEPBDXZ			; CvString::GetCString
; Function compile flags: /Ogtpy
;	COMDAT ?GetCString@CvString@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@CvString@@QBEPBDXZ PROC			; CvString::GetCString, COMDAT
; _this$ = ecx

; 42   : 	const char* GetCString() const 	{ return c_str(); }

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCString@CvString@@QBEPBDXZ ENDP			; CvString::GetCString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::operator->
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
;	COMDAT ??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::operator->, COMDAT
; _this$ = ecx

; 40   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 41   : }

	ret	0
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::operator->
_TEXT	ENDS
PUBLIC	?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::get, COMDAT
; _this$ = ecx

; 45   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 46   : }

	ret	0
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::get
_TEXT	ENDS
PUBLIC	?GetID@CvBaseInfo@@QBEHXZ			; CvBaseInfo::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetID@CvBaseInfo@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvBaseInfo@@QBEHXZ PROC				; CvBaseInfo::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvBaseInfo@@QBEHXZ ENDP				; CvBaseInfo::GetID
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getNumFlavorTypes@CvGlobals@@QAEHXZ		; CvGlobals::getNumFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getNumFlavorTypes@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumFlavorTypes@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumFlavorTypes, COMDAT
; _this$ = ecx

; 804  : 		return m_iNumFlavorTypes;

	mov	eax, DWORD PTR [ecx+1764]

; 805  : 	}

	ret	0
?getNumFlavorTypes@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumFlavorTypes
_TEXT	ENDS
PUBLIC	?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z ; CvGlobals::getFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z PROC ; CvGlobals::getFlavorTypes, COMDAT
; _this$ = ecx

; 812  : 		CvAssert(e > -1); /*CvAssert(e < GC.getNumFlavorTypes())*/;
; 813  : 		return m_paszFlavorTypes[e];

	mov	eax, DWORD PTR _e$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+1760]
	lea	eax, DWORD PTR [eax+edx*4]

; 814  : 	}

	ret	4
?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z ENDP ; CvGlobals::getFlavorTypes
_TEXT	ENDS
PUBLIC	?getAI_STRATEGY_EARLY_EXPLORATION_STARTING_WEIGHT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_STRATEGY_EARLY_EXPLORATION_STARTING_WEIGHT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_STRATEGY_EARLY_EXPLORATION_STARTING_WEIGHT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_STRATEGY_EARLY_EXPLORATION_STARTING_WEIGHT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_STRATEGY_EARLY_EXPLORATION_STARTING_WEIGHT, COMDAT
; _this$ = ecx

; 1061 : 		return m_iAI_STRATEGY_EARLY_EXPLORATION_STARTING_WEIGHT;

	mov	eax, DWORD PTR [ecx+1996]

; 1062 : 	}

	ret	0
?getAI_STRATEGY_EARLY_EXPLORATION_STARTING_WEIGHT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_STRATEGY_EARLY_EXPLORATION_STARTING_WEIGHT
_TEXT	ENDS
PUBLIC	?getAI_STRATEGY_EARLY_EXPLORATION_EXPLORERS_WEIGHT_DIVISOR@CvGlobals@@QAEHXZ ; CvGlobals::getAI_STRATEGY_EARLY_EXPLORATION_EXPLORERS_WEIGHT_DIVISOR
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_STRATEGY_EARLY_EXPLORATION_EXPLORERS_WEIGHT_DIVISOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_STRATEGY_EARLY_EXPLORATION_EXPLORERS_WEIGHT_DIVISOR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_STRATEGY_EARLY_EXPLORATION_EXPLORERS_WEIGHT_DIVISOR, COMDAT
; _this$ = ecx

; 1065 : 		return m_iAI_STRATEGY_EARLY_EXPLORATION_EXPLORERS_WEIGHT_DIVISOR;

	mov	eax, DWORD PTR [ecx+2000]

; 1066 : 	}

	ret	0
?getAI_STRATEGY_EARLY_EXPLORATION_EXPLORERS_WEIGHT_DIVISOR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_STRATEGY_EARLY_EXPLORATION_EXPLORERS_WEIGHT_DIVISOR
_TEXT	ENDS
PUBLIC	?getAI_STRATEGY_EARLY_EXPLORATION_WEIGHT_PER_FLAVOR@CvGlobals@@QAEHXZ ; CvGlobals::getAI_STRATEGY_EARLY_EXPLORATION_WEIGHT_PER_FLAVOR
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_STRATEGY_EARLY_EXPLORATION_WEIGHT_PER_FLAVOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_STRATEGY_EARLY_EXPLORATION_WEIGHT_PER_FLAVOR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_STRATEGY_EARLY_EXPLORATION_WEIGHT_PER_FLAVOR, COMDAT
; _this$ = ecx

; 1069 : 		return m_iAI_STRATEGY_EARLY_EXPLORATION_WEIGHT_PER_FLAVOR;

	mov	eax, DWORD PTR [ecx+2004]

; 1070 : 	}

	ret	0
?getAI_STRATEGY_EARLY_EXPLORATION_WEIGHT_PER_FLAVOR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_STRATEGY_EARLY_EXPLORATION_WEIGHT_PER_FLAVOR
_TEXT	ENDS
PUBLIC	?getAI_STRATEGY_EARLY_EXPANSION_NUM_UNOWNED_TILES_REQUIRED@CvGlobals@@QAEHXZ ; CvGlobals::getAI_STRATEGY_EARLY_EXPANSION_NUM_UNOWNED_TILES_REQUIRED
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_STRATEGY_EARLY_EXPANSION_NUM_UNOWNED_TILES_REQUIRED@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_STRATEGY_EARLY_EXPANSION_NUM_UNOWNED_TILES_REQUIRED@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_STRATEGY_EARLY_EXPANSION_NUM_UNOWNED_TILES_REQUIRED, COMDAT
; _this$ = ecx

; 1073 : 		return m_iAI_STRATEGY_EARLY_EXPANSION_NUM_UNOWNED_TILES_REQUIRED;

	mov	eax, DWORD PTR [ecx+2008]

; 1074 : 	}

	ret	0
?getAI_STRATEGY_EARLY_EXPANSION_NUM_UNOWNED_TILES_REQUIRED@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_STRATEGY_EARLY_EXPANSION_NUM_UNOWNED_TILES_REQUIRED
_TEXT	ENDS
PUBLIC	?getAI_STRATEGY_EARLY_EXPANSION_NUM_CITIES_LIMIT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_STRATEGY_EARLY_EXPANSION_NUM_CITIES_LIMIT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_STRATEGY_EARLY_EXPANSION_NUM_CITIES_LIMIT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_STRATEGY_EARLY_EXPANSION_NUM_CITIES_LIMIT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_STRATEGY_EARLY_EXPANSION_NUM_CITIES_LIMIT, COMDAT
; _this$ = ecx

; 1077 : 		return m_iAI_STRATEGY_EARLY_EXPANSION_NUM_CITIES_LIMIT;

	mov	eax, DWORD PTR [ecx+2012]

; 1078 : 	}

	ret	0
?getAI_STRATEGY_EARLY_EXPANSION_NUM_CITIES_LIMIT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_STRATEGY_EARLY_EXPANSION_NUM_CITIES_LIMIT
_TEXT	ENDS
PUBLIC	?getAI_STRATEGY_NEED_IMPROVEMENT_CITY_RATIO@CvGlobals@@QAEMXZ ; CvGlobals::getAI_STRATEGY_NEED_IMPROVEMENT_CITY_RATIO
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_STRATEGY_NEED_IMPROVEMENT_CITY_RATIO@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_STRATEGY_NEED_IMPROVEMENT_CITY_RATIO@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_STRATEGY_NEED_IMPROVEMENT_CITY_RATIO, COMDAT
; _this$ = ecx

; 1081 : 		return m_fAI_STRATEGY_NEED_IMPROVEMENT_CITY_RATIO;

	fld	DWORD PTR [ecx+2016]

; 1082 : 	}

	ret	0
?getAI_STRATEGY_NEED_IMPROVEMENT_CITY_RATIO@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_STRATEGY_NEED_IMPROVEMENT_CITY_RATIO
_TEXT	ENDS
PUBLIC	?getAI_STRATEGY_ISLAND_START_COAST_REVEAL_PERCENT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_STRATEGY_ISLAND_START_COAST_REVEAL_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_STRATEGY_ISLAND_START_COAST_REVEAL_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_STRATEGY_ISLAND_START_COAST_REVEAL_PERCENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_STRATEGY_ISLAND_START_COAST_REVEAL_PERCENT, COMDAT
; _this$ = ecx

; 1085 : 		return m_iAI_STRATEGY_ISLAND_START_COAST_REVEAL_PERCENT;

	mov	eax, DWORD PTR [ecx+2020]

; 1086 : 	}

	ret	0
?getAI_STRATEGY_ISLAND_START_COAST_REVEAL_PERCENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_STRATEGY_ISLAND_START_COAST_REVEAL_PERCENT
_TEXT	ENDS
PUBLIC	?getAI_STRATEGY_AREA_IS_FULL_PERCENT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_STRATEGY_AREA_IS_FULL_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_STRATEGY_AREA_IS_FULL_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_STRATEGY_AREA_IS_FULL_PERCENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_STRATEGY_AREA_IS_FULL_PERCENT, COMDAT
; _this$ = ecx

; 1089 : 		return m_iAI_STRATEGY_AREA_IS_FULL_PERCENT;

	mov	eax, DWORD PTR [ecx+2024]

; 1090 : 	}

	ret	0
?getAI_STRATEGY_AREA_IS_FULL_PERCENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_STRATEGY_AREA_IS_FULL_PERCENT
_TEXT	ENDS
PUBLIC	?getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY@CvGlobals@@QAEHXZ ; CvGlobals::getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY, COMDAT
; _this$ = ecx

; 1093 : 		return m_iAI_STRATEGY_MINIMUM_SETTLE_FERTILITY;

	mov	eax, DWORD PTR [ecx+2028]

; 1094 : 	}

	ret	0
?getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY
_TEXT	ENDS
PUBLIC	?getAI_GOLD_PRIORITY_MINIMUM_PLOT_BUY_VALUE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GOLD_PRIORITY_MINIMUM_PLOT_BUY_VALUE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GOLD_PRIORITY_MINIMUM_PLOT_BUY_VALUE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GOLD_PRIORITY_MINIMUM_PLOT_BUY_VALUE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GOLD_PRIORITY_MINIMUM_PLOT_BUY_VALUE, COMDAT
; _this$ = ecx

; 1133 : 		return m_iAI_GOLD_PRIORITY_MINIMUM_PLOT_BUY_VALUE;

	mov	eax, DWORD PTR [ecx+2068]

; 1134 : 	}

	ret	0
?getAI_GOLD_PRIORITY_MINIMUM_PLOT_BUY_VALUE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GOLD_PRIORITY_MINIMUM_PLOT_BUY_VALUE
_TEXT	ENDS
PUBLIC	?getAI_GOLD_BALANCE_TO_HALVE_PLOT_BUY_MINIMUM@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GOLD_BALANCE_TO_HALVE_PLOT_BUY_MINIMUM
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_GOLD_BALANCE_TO_HALVE_PLOT_BUY_MINIMUM@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GOLD_BALANCE_TO_HALVE_PLOT_BUY_MINIMUM@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GOLD_BALANCE_TO_HALVE_PLOT_BUY_MINIMUM, COMDAT
; _this$ = ecx

; 1137 : 		return m_iAI_GOLD_BALANCE_TO_HALVE_PLOT_BUY_MINIMUM;

	mov	eax, DWORD PTR [ecx+2072]

; 1138 : 	}

	ret	0
?getAI_GOLD_BALANCE_TO_HALVE_PLOT_BUY_MINIMUM@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GOLD_BALANCE_TO_HALVE_PLOT_BUY_MINIMUM
_TEXT	ENDS
PUBLIC	?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ		; CvGlobals::getMOVE_DENOMINATOR
; Function compile flags: /Ogtpy
;	COMDAT ?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMOVE_DENOMINATOR, COMDAT
; _this$ = ecx

; 5312 : 		return m_iMOVE_DENOMINATOR;

	mov	eax, DWORD PTR [ecx+6236]

; 5313 : 	}

	ret	0
?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMOVE_DENOMINATOR
_TEXT	ENDS
PUBLIC	?getARTIFACT_RESOURCE@CvGlobals@@QAEHXZ		; CvGlobals::getARTIFACT_RESOURCE
; Function compile flags: /Ogtpy
;	COMDAT ?getARTIFACT_RESOURCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getARTIFACT_RESOURCE@CvGlobals@@QAEHXZ PROC		; CvGlobals::getARTIFACT_RESOURCE, COMDAT
; _this$ = ecx

; 7191 : 		return m_iARTIFACT_RESOURCE;

	mov	eax, DWORD PTR [ecx+8408]

; 7192 : 	}

	ret	0
?getARTIFACT_RESOURCE@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getARTIFACT_RESOURCE
_TEXT	ENDS
PUBLIC	?getHIDDEN_ARTIFACT_RESOURCE@CvGlobals@@QAEHXZ	; CvGlobals::getHIDDEN_ARTIFACT_RESOURCE
; Function compile flags: /Ogtpy
;	COMDAT ?getHIDDEN_ARTIFACT_RESOURCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getHIDDEN_ARTIFACT_RESOURCE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getHIDDEN_ARTIFACT_RESOURCE, COMDAT
; _this$ = ecx

; 7195 : 		return m_iHIDDEN_ARTIFACT_RESOURCE;

	mov	eax, DWORD PTR [ecx+8412]

; 7196 : 	}

	ret	0
?getHIDDEN_ARTIFACT_RESOURCE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getHIDDEN_ARTIFACT_RESOURCE
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?GetExpensePerTurnUnitMaintenance@CvTreasury@@QAEHXZ ; CvTreasury::GetExpensePerTurnUnitMaintenance
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.h
;	COMDAT ?GetExpensePerTurnUnitMaintenance@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
?GetExpensePerTurnUnitMaintenance@CvTreasury@@QAEHXZ PROC ; CvTreasury::GetExpensePerTurnUnitMaintenance, COMDAT
; _this$ = ecx

; 91   : 		return m_iExpensePerTurnUnitMaintenance;

	mov	eax, DWORD PTR [ecx+16]

; 92   : 	}

	ret	0
?GetExpensePerTurnUnitMaintenance@CvTreasury@@QAEHXZ ENDP ; CvTreasury::GetExpensePerTurnUnitMaintenance
_TEXT	ENDS
PUBLIC	?GetID@CvArea@@QBEHXZ				; CvArea::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarea.h
;	COMDAT ?GetID@CvArea@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvArea@@QBEHXZ PROC				; CvArea::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvArea@@QBEHXZ ENDP				; CvArea::GetID
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?isHills@CvPlot@@QBE_NXZ			; CvPlot::isHills
; Function compile flags: /Ogtpy
;	COMDAT ?isHills@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isHills@CvPlot@@QBE_NXZ PROC				; CvPlot::isHills, COMDAT
; _this$ = ecx

; 413  : 		return (PlotTypes)m_ePlotType == PLOT_HILLS;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 1
	sete	al

; 414  : 	};

	ret	0
?isHills@CvPlot@@QBE_NXZ ENDP				; CvPlot::isHills
_TEXT	ENDS
PUBLIC	?isMountain@CvPlot@@QBE_NXZ			; CvPlot::isMountain
; Function compile flags: /Ogtpy
;	COMDAT ?isMountain@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isMountain@CvPlot@@QBE_NXZ PROC			; CvPlot::isMountain, COMDAT
; _this$ = ecx

; 422  : 		return (PlotTypes)m_ePlotType == PLOT_MOUNTAIN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], al
	sete	al

; 423  : 	};

	ret	0
?isMountain@CvPlot@@QBE_NXZ ENDP			; CvPlot::isMountain
_TEXT	ENDS
PUBLIC	?isImpassable@CvPlot@@QBE_NXZ			; CvPlot::isImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?isImpassable@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isImpassable@CvPlot@@QBE_NXZ PROC			; CvPlot::isImpassable, COMDAT
; _this$ = ecx

; 444  : 		return m_bIsImpassable;

	mov	al, BYTE PTR [ecx+462]
	shr	al, 7

; 445  : 	}

	ret	0
?isImpassable@CvPlot@@QBE_NXZ ENDP			; CvPlot::isImpassable
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z		; CvMap::plotByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z PROC		; CvMap::plotByIndex, COMDAT
; _this$ = ecx

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	mov	eax, DWORD PTR _iIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@plotByInde
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN3@plotByInde
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 264  : 	}

	ret	4
$LN3@plotByInde:

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	xor	eax, eax

; 264  : 	}

	ret	4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z ENDP		; CvMap::plotByIndex
_TEXT	ENDS
PUBLIC	?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z	; CvMap::plotByIndexUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z PROC	; CvMap::plotByIndexUnchecked, COMDAT
; _this$ = ecx

; 268  : 		return &m_pMapPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 269  : 	}

	ret	4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z ENDP	; CvMap::plotByIndexUnchecked
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?IsEmbarkedAllWater@CvPlayerTraits@@QBE_NXZ	; CvPlayerTraits::IsEmbarkedAllWater
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?IsEmbarkedAllWater@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
?IsEmbarkedAllWater@CvPlayerTraits@@QBE_NXZ PROC	; CvPlayerTraits::IsEmbarkedAllWater, COMDAT
; _this$ = ecx

; 765  : 		return m_bEmbarkedAllWater;

	mov	al, BYTE PTR [ecx+336]

; 766  : 	};

	ret	0
?IsEmbarkedAllWater@CvPlayerTraits@@QBE_NXZ ENDP	; CvPlayerTraits::IsEmbarkedAllWater
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovector.h
;	COMDAT ??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z PROC ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[], COMDAT
; _this$ = ecx

; 329  : 	return m_value[index];

	mov	eax, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR _index$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 330  : }

	ret	4
??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ENDP ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ
_TEXT	SEGMENT
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ PROC		; FAutoVariable<char,CvPlot>::operator char const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ ENDP		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_7CvEconomicAIStrategyXMLEntry@@6B@		; CvEconomicAIStrategyXMLEntry::`vftable'
PUBLIC	??1CvEconomicAIStrategyXMLEntry@@UAE@XZ		; CvEconomicAIStrategyXMLEntry::~CvEconomicAIStrategyXMLEntry
PUBLIC	??_R4CvEconomicAIStrategyXMLEntry@@6B@		; CvEconomicAIStrategyXMLEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvEconomicAIStrategyXMLEntry@@@8	; CvEconomicAIStrategyXMLEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvEconomicAIStrategyXMLEntry@@8		; CvEconomicAIStrategyXMLEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvEconomicAIStrategyXMLEntry@@8		; CvEconomicAIStrategyXMLEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvEconomicAIStrategyXMLEntry@@8	; CvEconomicAIStrategyXMLEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvEconomicAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvEconomicAIStrategyXMLEntry::CacheResults
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
EXTRN	??_ECvEconomicAIStrategyXMLEntry@@UAEPAXI@Z:PROC ; CvEconomicAIStrategyXMLEntry::`vector deleting destructor'
;	COMDAT ??_R2CvBaseInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvEconomicAIStrategyXMLEntry@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvEconomicAIStrategyXMLEntry@@8 DD FLAT:??_R0?AVCvEconomicAIStrategyXMLEntry@@@8 ; CvEconomicAIStrategyXMLEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvEconomicAIStrategyXMLEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvEconomicAIStrategyXMLEntry@@8
rdata$r	SEGMENT
??_R2CvEconomicAIStrategyXMLEntry@@8 DD FLAT:??_R1A@?0A@EA@CvEconomicAIStrategyXMLEntry@@8 ; CvEconomicAIStrategyXMLEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvEconomicAIStrategyXMLEntry@@8
rdata$r	SEGMENT
??_R3CvEconomicAIStrategyXMLEntry@@8 DD 00H		; CvEconomicAIStrategyXMLEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvEconomicAIStrategyXMLEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvEconomicAIStrategyXMLEntry@@@8
_DATA	SEGMENT
??_R0?AVCvEconomicAIStrategyXMLEntry@@@8 DD FLAT:??_7type_info@@6B@ ; CvEconomicAIStrategyXMLEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvEconomicAIStrategyXMLEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvEconomicAIStrategyXMLEntry@@6B@
rdata$r	SEGMENT
??_R4CvEconomicAIStrategyXMLEntry@@6B@ DD 00H		; CvEconomicAIStrategyXMLEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvEconomicAIStrategyXMLEntry@@@8
	DD	FLAT:??_R3CvEconomicAIStrategyXMLEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvEconomicAIStrategyXMLEntry@@6B@
CONST	SEGMENT
??_7CvEconomicAIStrategyXMLEntry@@6B@ DD FLAT:??_R4CvEconomicAIStrategyXMLEntry@@6B@ ; CvEconomicAIStrategyXMLEntry::`vftable'
	DD	FLAT:?CacheResults@CvEconomicAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvEconomicAIStrategyXMLEntry@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ$0
__ehfuncinfo$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ??1CvEconomicAIStrategyXMLEntry@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvEconomicAIStrategyXMLEntry@@UAE@XZ PROC		; CvEconomicAIStrategyXMLEntry::~CvEconomicAIStrategyXMLEntry, COMDAT
; _this$ = ecx

; 47   : {

	push	-1
	push	__ehhandler$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvEconomicAIStrategyXMLEntry@@6B@

; 48   : 	SAFE_DELETE_ARRAY(m_piPlayerFlavorValue);

	mov	eax, DWORD PTR [esi+260]
	xor	edi, edi
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], edi
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+260], edi

; 49   : 	SAFE_DELETE_ARRAY(m_piCityFlavorValue);

	mov	eax, DWORD PTR [esi+264]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+264], edi

; 50   : 	SAFE_DELETE_ARRAY(m_piPersonalityFlavorThresholdMod);

	mov	eax, DWORD PTR [esi+272]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH

; 51   : }

	lea	ecx, DWORD PTR [esi+304]
	mov	DWORD PTR [esi+272], edi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvEconomicAIStrategyXMLEntry@@UAE@XZ ENDP		; CvEconomicAIStrategyXMLEntry::~CvEconomicAIStrategyXMLEntry
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
; Function compile flags: /Ogtpy
;	COMDAT ?CacheResults@CvEconomicAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvEconomicAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvEconomicAIStrategyXMLEntry::CacheResults, COMDAT
; _this$ = ecx

; 55   : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN9@CacheResul
	pop	edi
	pop	esi

; 112  : }

	ret	8
$LN9@CacheResul:
	push	ebx
	push	ebp

; 56   : 		return false;
; 57   : 
; 58   : 	//Basic Properties
; 59   : 	m_bNoMinorCivs					= kResults.GetBool("NoMinorCivs");

	push	OFFSET $SG225666
	mov	ecx, edi
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z

; 60   : 	m_iCheckTriggerTurnCount		= kResults.GetInt("CheckTriggerTurnCount");

	mov	ebp, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG225667
	mov	ecx, edi
	mov	BYTE PTR [esi+276], al
	call	ebp

; 61   : 	m_iMinimumNumTurnsExecuted		= kResults.GetInt("MinimumNumTurnsExecuted");

	push	OFFSET $SG225668
	mov	ecx, edi
	mov	DWORD PTR [esi+292], eax
	call	ebp

; 62   : 	m_iWeightThreshold				= kResults.GetInt("WeightThreshold");

	push	OFFSET $SG225669
	mov	ecx, edi
	mov	DWORD PTR [esi+288], eax
	call	ebp

; 63   : 	m_iFirstTurnExecuted            = kResults.GetInt("FirstTurnExecuted");

	push	OFFSET $SG225670
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebp

; 64   : 
; 65   : 	const char* strAdvisor = kResults.GetText("Advisor");

	push	OFFSET $SG225672
	mov	ecx, edi
	mov	DWORD PTR [esi+296], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 66   : 	m_eAdvisor = NO_ADVISOR_TYPE;

	mov	DWORD PTR [esi+300], -1

; 67   : 	if(strAdvisor)

	test	eax, eax
	je	$LN35@CacheResul

; 68   : 	{
; 69   : 		if(strcmp(strAdvisor, "MILITARY") == 0)

	mov	edx, OFFSET $SG225675
	mov	ecx, eax
	npad	7
$LL18@CacheResul:
	mov	bl, BYTE PTR [ecx]
	cmp	bl, BYTE PTR [edx]
	jne	SHORT $LN19@CacheResul
	test	bl, bl
	je	SHORT $LN20@CacheResul
	mov	bl, BYTE PTR [ecx+1]
	cmp	bl, BYTE PTR [edx+1]
	jne	SHORT $LN19@CacheResul
	add	ecx, 2
	add	edx, 2
	test	bl, bl
	jne	SHORT $LL18@CacheResul
$LN20@CacheResul:
	xor	ecx, ecx
	jmp	SHORT $LN21@CacheResul
$LN19@CacheResul:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN21@CacheResul:
	test	ecx, ecx
	jne	SHORT $LN7@CacheResul

; 70   : 		{
; 71   : 			m_eAdvisor = ADVISOR_MILITARY;

	mov	DWORD PTR [esi+300], ecx
	jmp	$LN35@CacheResul
$LN7@CacheResul:

; 72   : 		}
; 73   : 		else if(strcmp(strAdvisor, "ECONOMIC") == 0)

	mov	edx, OFFSET $SG225678
	mov	ecx, eax
	npad	5
$LL22@CacheResul:
	mov	bl, BYTE PTR [ecx]
	cmp	bl, BYTE PTR [edx]
	jne	SHORT $LN23@CacheResul
	test	bl, bl
	je	SHORT $LN24@CacheResul
	mov	bl, BYTE PTR [ecx+1]
	cmp	bl, BYTE PTR [edx+1]
	jne	SHORT $LN23@CacheResul
	add	ecx, 2
	add	edx, 2
	test	bl, bl
	jne	SHORT $LL22@CacheResul
$LN24@CacheResul:
	xor	ecx, ecx
	jmp	SHORT $LN25@CacheResul
$LN23@CacheResul:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN25@CacheResul:
	test	ecx, ecx
	jne	SHORT $LN5@CacheResul

; 74   : 		{
; 75   : 			m_eAdvisor = ADVISOR_ECONOMIC;

	mov	DWORD PTR [esi+300], 1
	jmp	SHORT $LN35@CacheResul
$LN5@CacheResul:

; 76   : 		}
; 77   : 		else if(strcmp(strAdvisor, "FOREIGN") == 0)

	mov	edx, OFFSET $SG225681
	mov	ecx, eax
	npad	4
$LL26@CacheResul:
	mov	bl, BYTE PTR [ecx]
	cmp	bl, BYTE PTR [edx]
	jne	SHORT $LN27@CacheResul
	test	bl, bl
	je	SHORT $LN28@CacheResul
	mov	bl, BYTE PTR [ecx+1]
	cmp	bl, BYTE PTR [edx+1]
	jne	SHORT $LN27@CacheResul
	add	ecx, 2
	add	edx, 2
	test	bl, bl
	jne	SHORT $LL26@CacheResul
$LN28@CacheResul:
	xor	ecx, ecx
	jmp	SHORT $LN29@CacheResul
$LN27@CacheResul:
	sbb	ecx, ecx
	sbb	ecx, -1
$LN29@CacheResul:
	test	ecx, ecx
	jne	SHORT $LN3@CacheResul

; 78   : 		{
; 79   : 			m_eAdvisor = ADVISOR_FOREIGN;

	mov	DWORD PTR [esi+300], 2
	jmp	SHORT $LN35@CacheResul
$LN3@CacheResul:

; 80   : 		}
; 81   : 		else if(strcmp(strAdvisor, "SCIENCE") == 0)

	mov	ecx, OFFSET $SG225684
	npad	6
$LL30@CacheResul:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN31@CacheResul
	test	dl, dl
	je	SHORT $LN32@CacheResul
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN31@CacheResul
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL30@CacheResul
$LN32@CacheResul:
	xor	eax, eax
	jmp	SHORT $LN33@CacheResul
$LN31@CacheResul:
	sbb	eax, eax
	sbb	eax, -1
$LN33@CacheResul:
	test	eax, eax
	jne	SHORT $LN35@CacheResul

; 82   : 		{
; 83   : 			m_eAdvisor = ADVISOR_SCIENCE;

	mov	DWORD PTR [esi+300], 3
$LN35@CacheResul:

; 84   : 		}
; 85   : 	}
; 86   : 
; 87   : 	m_strAdvisorCounselText = kResults.GetText("AdvisorCounsel");

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG225685
	mov	ecx, edi
	call	ebx
	lea	ecx, DWORD PTR [esi+304]
	test	eax, eax
	je	SHORT $LN13@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN12@CacheResul
$LN13@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN12@CacheResul:

; 88   : 	m_iAdvisorCounselImportance = kResults.GetInt("AdvisorCounselImportance");

	push	OFFSET $SG225686
	mov	ecx, edi
	call	ebp

; 89   : 
; 90   : 	//References
; 91   : 	const char* szTextVal = NULL;
; 92   : 	szTextVal = kResults.GetText("TechPrereq");

	push	OFFSET $SG225688
	mov	ecx, edi
	mov	DWORD PTR [esi+332], eax
	call	ebx

; 93   : 	m_iTechPrereq = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 94   : 
; 95   : 	szTextVal = kResults.GetText("TechObsolete");

	push	OFFSET $SG225689
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebx

; 96   : 	m_iTechObsolete = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 97   : 
; 98   : 	//Arrays
; 99   : 	//Arrays
; 100  : 	const char* szType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+284], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 101  : 	kUtility.SetFlavors(m_piPlayerFlavorValue, "AIEconomicStrategy_Player_Flavors",
; 102  : 	                    "AIEconomicStrategyType", szType);

	mov	ebx, DWORD PTR _kUtility$[esp+12]
	push	0
	mov	edi, eax
	push	edi
	push	OFFSET $SG225691
	push	OFFSET $SG225692
	lea	ecx, DWORD PTR [esi+260]
	push	ecx
	mov	ecx, ebx
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 103  : 	kUtility.SetFlavors(m_piCityFlavorValue, "AIEconomicStrategy_City_Flavors",
; 104  : 		"AIEconomicStrategyType", szType);

	push	0
	push	edi
	push	OFFSET $SG225693
	push	OFFSET $SG225694
	lea	edx, DWORD PTR [esi+264]
	push	edx
	mov	ecx, ebx
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 105  : 
; 106  : 
; 107  : 	kUtility.SetFlavors(m_piPersonalityFlavorThresholdMod,
; 108  : 	                    "AIEconomicStrategy_PersonalityFlavorThresholdMods",
; 109  : 	                    "AIEconomicStrategyType", szType);

	push	0
	push	edi
	push	OFFSET $SG225695
	push	OFFSET $SG225696
	add	esi, 272				; 00000110H
	push	esi
	mov	ecx, ebx
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors
	pop	ebp
	pop	ebx
	pop	edi

; 110  : 
; 111  : 	return true;

	mov	al, 1
	pop	esi

; 112  : }

	ret	8
?CacheResults@CvEconomicAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvEconomicAIStrategyXMLEntry::CacheResults
_TEXT	ENDS
PUBLIC	?GetNumEconomicAIStrategies@CvEconomicAIStrategyXMLEntries@@QAEHXZ ; CvEconomicAIStrategyXMLEntries::GetNumEconomicAIStrategies
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumEconomicAIStrategies@CvEconomicAIStrategyXMLEntries@@QAEHXZ
_TEXT	SEGMENT
?GetNumEconomicAIStrategies@CvEconomicAIStrategyXMLEntries@@QAEHXZ PROC ; CvEconomicAIStrategyXMLEntries::GetNumEconomicAIStrategies, COMDAT
; _this$ = ecx

; 219  : 	return m_paAIStrategyEntries.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 220  : }

	ret	0
?GetNumEconomicAIStrategies@CvEconomicAIStrategyXMLEntries@@QAEHXZ ENDP ; CvEconomicAIStrategyXMLEntries::GetNumEconomicAIStrategies
_TEXT	ENDS
PUBLIC	?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ; CvEconomicAIStrategyXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z PROC ; CvEconomicAIStrategyXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 236  : 	return m_paAIStrategyEntries[index];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 237  : }

	ret	4
?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ENDP ; CvEconomicAIStrategyXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	?Uninit@CvEconomicAI@@QAEXXZ			; CvEconomicAI::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvEconomicAI@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvEconomicAI@@QAEXXZ PROC			; CvEconomicAI::Uninit, COMDAT
; _this$ = ecx

; 289  : {

	push	esi
	mov	esi, ecx

; 290  : 	SAFE_DELETE_ARRAY(m_pabUsingStrategy);

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+12], 0

; 291  : 	SAFE_DELETE_ARRAY(m_paiTurnStrategyAdopted);

	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+16], 0

; 292  : 	SAFE_DELETE_ARRAY(m_aiTempFlavors);

	mov	edx, DWORD PTR [esi+20]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+20], 0
	pop	esi

; 293  : }

	ret	0
?Uninit@CvEconomicAI@@QAEXXZ ENDP			; CvEconomicAI::Uninit
_TEXT	ENDS
PUBLIC	?AppendToLog@@YAXAAVCvString@@0V1@1@Z		; AppendToLog
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AppendToLog@@YAXAAVCvString@@0V1@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@1@Z$1
__ehfuncinfo$?AppendToLog@@YAXAAVCvString@@0V1@1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendToLog@@YAXAAVCvString@@0V1@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?AppendToLog@@YAXAAVCvString@@0V1@1@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_strHeader$ = 8						; size = 4
_strLog$ = 12						; size = 4
_strHeaderValue$ = 16					; size = 28
_strValue$ = 44						; size = 28
?AppendToLog@@YAXAAVCvString@@0V1@1@Z PROC		; AppendToLog, COMDAT

; 877  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?AppendToLog@@YAXAAVCvString@@0V1@1@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi

; 878  : 	strHeader += strHeaderValue;

	mov	esi, DWORD PTR _strHeader$[esp+12]
	lea	eax, DWORD PTR _strHeaderValue$[esp+12]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 879  : 	strHeader += ",";

	push	OFFSET $SG226403
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 880  : 	strLog += strValue;

	mov	esi, DWORD PTR _strLog$[esp+12]
	lea	ecx, DWORD PTR _strValue$[esp+12]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 881  : 	strLog += ",";

	push	OFFSET $SG226404
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 882  : }

	lea	ecx, DWORD PTR _strHeaderValue$[esp+12]
	mov	BYTE PTR __$EHRec$[esp+24], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strValue$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@1@Z$0:
	lea	ecx, DWORD PTR _strValue$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@1@Z$1:
	lea	ecx, DWORD PTR _strHeaderValue$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AppendToLog@@YAXAAVCvString@@0V1@1@Z:
	mov	eax, OFFSET __ehfuncinfo$?AppendToLog@@YAXAAVCvString@@0V1@1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AppendToLog@@YAXAAVCvString@@0V1@1@Z ENDP		; AppendToLog
PUBLIC	?AppendToLog@@YAXAAVCvString@@0V1@H@Z		; AppendToLog
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AppendToLog@@YAXAAVCvString@@0V1@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@H@Z$1
__ehfuncinfo$?AppendToLog@@YAXAAVCvString@@0V1@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendToLog@@YAXAAVCvString@@0V1@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?AppendToLog@@YAXAAVCvString@@0V1@H@Z
_TEXT	SEGMENT
_str$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strHeader$ = 8						; size = 4
_strLog$ = 12						; size = 4
_strHeaderValue$ = 16					; size = 28
_iValue$ = 44						; size = 4
?AppendToLog@@YAXAAVCvString@@0V1@H@Z PROC		; AppendToLog, COMDAT

; 889  : {

	push	-1
	push	__ehhandler$?AppendToLog@@YAXAAVCvString@@0V1@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 890  : 	strHeader += strHeaderValue;

	mov	esi, DWORD PTR _strHeader$[esp+40]
	lea	eax, DWORD PTR _strHeaderValue$[esp+40]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+56], 0
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 891  : 	strHeader += ",";

	push	OFFSET $SG226412
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 892  : 	CvString str;

	lea	ecx, DWORD PTR _str$[esp+44]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 893  : 	str.Format("%d,", iValue);

	mov	ecx, DWORD PTR _iValue$[esp+40]
	push	ecx
	lea	edx, DWORD PTR _str$[esp+48]
	push	OFFSET $SG226414
	push	edx
	mov	BYTE PTR __$EHRec$[esp+64], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 894  : 	strLog += str;

	mov	ecx, DWORD PTR _strLog$[esp+52]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR _str$[esp+44]
	push	eax
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 895  : }

	lea	ecx, DWORD PTR _str$[esp+44]
	mov	BYTE PTR __$EHRec$[esp+52], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strHeaderValue$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@H@Z$0:
	lea	ecx, DWORD PTR _strHeaderValue$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@H@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AppendToLog@@YAXAAVCvString@@0V1@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?AppendToLog@@YAXAAVCvString@@0V1@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AppendToLog@@YAXAAVCvString@@0V1@H@Z ENDP		; AppendToLog
PUBLIC	?AppendToLog@@YAXAAVCvString@@0V1@M@Z		; AppendToLog
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AppendToLog@@YAXAAVCvString@@0V1@M@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@M@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@M@Z$1
__ehfuncinfo$?AppendToLog@@YAXAAVCvString@@0V1@M@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendToLog@@YAXAAVCvString@@0V1@M@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?AppendToLog@@YAXAAVCvString@@0V1@M@Z
_TEXT	SEGMENT
_str$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strHeader$ = 8						; size = 4
_strLog$ = 12						; size = 4
_strHeaderValue$ = 16					; size = 28
_fValue$ = 44						; size = 4
?AppendToLog@@YAXAAVCvString@@0V1@M@Z PROC		; AppendToLog, COMDAT

; 902  : {

	push	-1
	push	__ehhandler$?AppendToLog@@YAXAAVCvString@@0V1@M@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 903  : 	strHeader += strHeaderValue;

	mov	esi, DWORD PTR _strHeader$[esp+40]
	lea	eax, DWORD PTR _strHeaderValue$[esp+40]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+56], 0
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 904  : 	strHeader += ",";

	push	OFFSET $SG226422
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 905  : 	CvString str;

	lea	ecx, DWORD PTR _str$[esp+44]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 906  : 	str.Format("%.2f,", fValue);

	fld	DWORD PTR _fValue$[esp+40]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	ecx, DWORD PTR _str$[esp+52]
	push	OFFSET $SG226424
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+68], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 907  : 	strLog += str;

	mov	ecx, DWORD PTR _strLog$[esp+56]
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR _str$[esp+44]
	push	edx
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 908  : }

	lea	ecx, DWORD PTR _str$[esp+44]
	mov	BYTE PTR __$EHRec$[esp+52], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strHeaderValue$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@M@Z$0:
	lea	ecx, DWORD PTR _strHeaderValue$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@M@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AppendToLog@@YAXAAVCvString@@0V1@M@Z:
	mov	eax, OFFSET __ehfuncinfo$?AppendToLog@@YAXAAVCvString@@0V1@M@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AppendToLog@@YAXAAVCvString@@0V1@M@Z ENDP		; AppendToLog
PUBLIC	?StartSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@HH@Z ; CvEconomicAI::StartSaveForPurchase
; Function compile flags: /Ogtpy
;	COMDAT ?StartSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@HH@Z
_TEXT	SEGMENT
_ePurchase$ = 8						; size = 4
_iAmount$ = 12						; size = 4
_iPriority$ = 16					; size = 4
?StartSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@HH@Z PROC ; CvEconomicAI::StartSaveForPurchase, COMDAT
; _this$ = ecx

; 1129 : 	int iIndex = (int)ePurchase;
; 1130 : 	CvPurchaseRequest request;
; 1131 : 	request.m_eType = ePurchase;

	mov	edx, DWORD PTR _ePurchase$[esp-4]

; 1132 : 	request.m_iAmount = iAmount;
; 1133 : 	request.m_iPriority = iPriority;
; 1134 : 	m_RequestedSavings[iIndex] = request;

	mov	ecx, DWORD PTR [ecx+112]
	push	esi
	mov	esi, DWORD PTR _iAmount$[esp]
	lea	eax, DWORD PTR [edx+edx*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	push	edi
	mov	edi, DWORD PTR _iPriority$[esp+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], edi
	pop	edi
	pop	esi

; 1135 : }

	ret	12					; 0000000cH
?StartSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@HH@Z ENDP ; CvEconomicAI::StartSaveForPurchase
_TEXT	ENDS
PUBLIC	?IsSavingForThisPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@@Z ; CvEconomicAI::IsSavingForThisPurchase
; Function compile flags: /Ogtpy
;	COMDAT ?IsSavingForThisPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@@Z
_TEXT	SEGMENT
_ePurchase$ = 8						; size = 4
?IsSavingForThisPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@@Z PROC ; CvEconomicAI::IsSavingForThisPurchase, COMDAT
; _this$ = ecx

; 1144 : 	return (m_RequestedSavings[(int)ePurchase].m_iAmount > 0);

	mov	eax, DWORD PTR _ePurchase$[esp-4]
	mov	ecx, DWORD PTR [ecx+112]
	lea	eax, DWORD PTR [eax+eax*2]
	xor	edx, edx
	cmp	DWORD PTR [ecx+eax*4+4], edx
	setg	dl
	mov	al, dl

; 1145 : }

	ret	4
?IsSavingForThisPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@@Z ENDP ; CvEconomicAI::IsSavingForThisPurchase
_TEXT	ENDS
PUBLIC	?CancelSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@@Z ; CvEconomicAI::CancelSaveForPurchase
; Function compile flags: /Ogtpy
;	COMDAT ?CancelSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@@Z
_TEXT	SEGMENT
_ePurchase$ = 8						; size = 4
?CancelSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@@Z PROC ; CvEconomicAI::CancelSaveForPurchase, COMDAT
; _this$ = ecx

; 1150 : 	int iIndex = (int)ePurchase;
; 1151 : 	CvPurchaseRequest request;
; 1152 : 	request.m_eType = ePurchase;

	mov	edx, DWORD PTR _ePurchase$[esp-4]

; 1153 : 	request.m_iAmount = 0;
; 1154 : 	request.m_iPriority = 0;
; 1155 : 	m_RequestedSavings[iIndex] = request;

	mov	ecx, DWORD PTR [ecx+112]
	push	esi
	lea	eax, DWORD PTR [edx+edx*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	push	edi
	xor	esi, esi
	xor	edi, edi
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], edi
	pop	edi
	pop	esi

; 1156 : }

	ret	4
?CancelSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@@Z ENDP ; CvEconomicAI::CancelSaveForPurchase
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	?GetImprovedToImprovablePlotsRatio@CvEconomicAI@@QAENXZ ; CvEconomicAI::GetImprovedToImprovablePlotsRatio
EXTRN	?IsImprovementPillaged@CvPlot@@QBE_NXZ:PROC	; CvPlot::IsImprovementPillaged
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ:PROC ; CvPlayer::GetPlots
;	COMDAT __real@3ff0000000000000
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?GetImprovedToImprovablePlotsRatio@CvEconomicAI@@QAENXZ
_TEXT	SEGMENT
_iNumImprovedPlots$ = -12				; size = 4
_fCurrentRatio$ = -8					; size = 8
_iNumValidPlots$ = -8					; size = 4
?GetImprovedToImprovablePlotsRatio@CvEconomicAI@@QAENXZ PROC ; CvEconomicAI::GetImprovedToImprovablePlotsRatio, COMDAT
; _this$ = ecx

; 1275 : {

	sub	esp, 12					; 0000000cH

; 1276 : 	const CvPlotsVector& aiPlots = m_pPlayer->GetPlots();

	mov	ecx, DWORD PTR [ecx+4]
	push	ebx
	push	ebp
	push	edi
	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots

; 1277 : 	int iNumValidPlots = 0;

	xor	edi, edi
	mov	ebp, eax
	xor	ebx, ebx

; 1278 : 	int iNumImprovedPlots = 0;

	mov	DWORD PTR _iNumImprovedPlots$[esp+24], edi

; 1279 : 	for(uint ui = 0; ui < aiPlots.size(); ui++)

	cmp	DWORD PTR [ebp+4], edi
	jbe	SHORT $LN34@GetImprove
	push	esi
	npad	2
$LL37@GetImprove:

; 1280 : 	{
; 1281 : 		if(aiPlots[ui] == -1)

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+edi*4]
	cmp	eax, -1
	je	SHORT $LN8@GetImprove

; 1282 : 		{
; 1283 : 			continue;
; 1284 : 		}
; 1285 : 
; 1286 : 		const CvPlot* pPlot = GC.getMap().plotByIndex(aiPlots[ui]);

	test	eax, eax
	jl	SHORT $LN8@GetImprove
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN8@GetImprove
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	mov	esi, eax

; 1287 : 		if(!pPlot)

	je	SHORT $LN8@GetImprove

; 1288 : 		{
; 1289 : 			continue;
; 1290 : 		}
; 1291 : 
; 1292 : 		if(pPlot->isWater() || pPlot->isImpassable() || pPlot->isMountain() || pPlot->isCity())

	mov	al, BYTE PTR [esi+5]
	cmp	al, 3
	je	SHORT $LN8@GetImprove
	test	BYTE PTR [esi+462], 128			; 00000080H
	jne	SHORT $LN8@GetImprove
	test	al, al
	je	SHORT $LN8@GetImprove
	mov	ecx, esi
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	test	al, al
	jne	SHORT $LN8@GetImprove

; 1298 : 
; 1299 : 		if(pPlot->getImprovementType() != NO_IMPROVEMENT && !pPlot->IsImprovementPillaged())

	mov	ecx, esi
	inc	ebx
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN8@GetImprove
	mov	ecx, esi
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	test	al, al
	jne	SHORT $LN8@GetImprove

; 1300 : 		{
; 1301 : 			iNumImprovedPlots++;

	inc	DWORD PTR _iNumImprovedPlots$[esp+28]
$LN8@GetImprove:

; 1279 : 	for(uint ui = 0; ui < aiPlots.size(); ui++)

	inc	edi
	cmp	edi, DWORD PTR [ebp+4]
	jb	SHORT $LL37@GetImprove

; 1293 : 		{
; 1294 : 			continue;
; 1295 : 		}
; 1296 : 
; 1297 : 		iNumValidPlots++;

	mov	DWORD PTR _iNumValidPlots$[esp+28], ebx
	pop	esi

; 1302 : 		}
; 1303 : 	}
; 1304 : 	// Avoid potential division by 0
; 1305 : 	if(iNumValidPlots <= 0)

	test	ebx, ebx
	jg	SHORT $LN1@GetImprove
$LN34@GetImprove:

; 1306 : 	{
; 1307 : 		return 1.0;

	fld1
	pop	edi
	pop	ebp
	pop	ebx

; 1312 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN1@GetImprove:

; 1308 : 	}
; 1309 : 	double fCurrentRatio = iNumImprovedPlots / (double)iNumValidPlots;

	fild	DWORD PTR _iNumImprovedPlots$[esp+24]
	pop	edi
	pop	ebp
	pop	ebx
	fidiv	DWORD PTR _iNumValidPlots$[esp+12]
	fstp	QWORD PTR _fCurrentRatio$[esp+12]

; 1310 : 
; 1311 : 	return fCurrentRatio;

	fld	QWORD PTR _fCurrentRatio$[esp+12]

; 1312 : }

	add	esp, 12					; 0000000cH
	ret	0
?GetImprovedToImprovablePlotsRatio@CvEconomicAI@@QAENXZ ENDP ; CvEconomicAI::GetImprovedToImprovablePlotsRatio
_TEXT	ENDS
PUBLIC	?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z ; CvEconomicAI::LogStrategy
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	?getEconomicAIStrategyInfo@CvGlobals@@QAEPAVCvEconomicAIStrategyXMLEntry@@W4EconomicAIStrategyTypes@@@Z:PROC ; CvGlobals::getEconomicAIStrategyInfo
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$9
	DD	06H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$11
	DD	0aH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$12
	DD	0cH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$14
	DD	0eH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$15
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -272						; size = 4
_iLoop$227762 = -268					; size = 4
_cityName$227760 = -264					; size = 28
_strTemp$227753 = -264					; size = 28
$T233252 = -264						; size = 28
_strLogName$227738 = -236				; size = 28
_strOutBuf$227750 = -208				; size = 28
$T233259 = -180						; size = 28
$T233255 = -180						; size = 28
$T233253 = -180						; size = 28
$T233251 = -180						; size = 28
$T233260 = -152						; size = 28
$T233256 = -152						; size = 28
$T233254 = -152						; size = 28
_playerName$227737 = -124				; size = 28
_strBaseString$227746 = -96				; size = 28
$T233258 = -68						; size = 28
$T233257 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_eStrategy$ = 8						; size = 4
_bValue$ = 12						; size = 1
?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z PROC ; CvEconomicAI::LogStrategy, COMDAT
; _this$ = ecx

; 2724 : {

	push	-1
	push	__ehhandler$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 260				; 00000104H
	push	esi
	mov	esi, ecx

; 2725 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+276], esi
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN8@LogStrateg
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN8@LogStrateg

; 2726 : 	{
; 2727 : 		// Find the name of this civ and city
; 2728 : 		CvString playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [esi+4]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	test	eax, eax
	jne	SHORT $LN32@LogStrateg
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN32@LogStrateg:
	push	ebx
	push	ebp
	push	edi
	push	eax
	lea	ecx, DWORD PTR _playerName$227737[esp+292]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2729 : 
; 2730 : 		// Open the log file
; 2731 : 		CvString strLogName = "FlavorAILog.csv";

	push	OFFSET $SG227739
	lea	ecx, DWORD PTR _strLogName$227738[esp+292]
	mov	DWORD PTR __$EHRec$[esp+300], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 2732 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR __$EHRec$[esp+296], 1
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	mov	edi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	test	al, al
	je	SHORT $LN7@LogStrateg

; 2733 : 		{
; 2734 : 			strLogName = "FlavorAILog_" + playerName + ".csv";

	lea	eax, DWORD PTR _playerName$227737[esp+288]
	push	eax
	lea	ecx, DWORD PTR $T233251[esp+292]
	push	OFFSET $SG227744
	push	ecx
	call	ebp
	push	OFFSET $SG227743
	push	eax
	lea	edx, DWORD PTR $T233252[esp+308]
	mov	bl, 2
	push	edx
	mov	BYTE PTR __$EHRec$[esp+320], bl
	call	edi
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+296], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$227738[esp+292]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T233252[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T233251[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@LogStrateg:

; 2735 : 		}
; 2736 : 
; 2737 : 		FILogFile* pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strLogName$227738[esp+288]
	mov	ebx, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [ebx]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, ebx
	call	eax

; 2738 : 
; 2739 : 		// Get the leading info for this line
; 2740 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$227746[esp+288]
	mov	esi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2741 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR __$EHRec$[esp+296], 4
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227746[esp+292]
	push	OFFSET $SG227747
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2742 : 		strBaseString += playerName + ", ";

	push	OFFSET $SG227749
	lea	edx, DWORD PTR _playerName$227737[esp+304]
	push	edx
	lea	eax, DWORD PTR $T233253[esp+308]
	push	eax
	call	edi
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$227746[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 5
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T233253[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2743 : 
; 2744 : 		CvString strOutBuf = strBaseString;

	lea	ecx, DWORD PTR _strBaseString$227746[esp+288]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$227750[esp+292]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 2745 : 
; 2746 : 		// Strategy Info
; 2747 : 		CvEconomicAIStrategyXMLEntry* pEconomicAIStrategyEntry = GC.getEconomicAIStrategyInfo(eStrategy);

	mov	edx, DWORD PTR _eStrategy$[esp+284]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR __$EHRec$[esp+300], 6
	call	?getEconomicAIStrategyInfo@CvGlobals@@QAEPAVCvEconomicAIStrategyXMLEntry@@W4EconomicAIStrategyTypes@@@Z ; CvGlobals::getEconomicAIStrategyInfo
	mov	ebx, eax

; 2748 : 		if(pEconomicAIStrategyEntry != NULL)

	test	ebx, ebx
	je	SHORT $LN6@LogStrateg

; 2749 : 		{
; 2750 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227753[esp+288]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2751 : 			strTemp.Format("%s, %d", pEconomicAIStrategyEntry->GetType(), bValue);

	movzx	eax, BYTE PTR _bValue$[esp+284]
	push	eax
	lea	ecx, DWORD PTR [ebx+176]
	mov	BYTE PTR __$EHRec$[esp+300], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$227753[esp+296]
	push	OFFSET $SG227754
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2752 : 			strOutBuf += strTemp;

	lea	edx, DWORD PTR _strTemp$227753[esp+288]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$227750[esp+292]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2753 : 		}

	lea	ecx, DWORD PTR _strTemp$227753[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@LogStrateg:

; 2754 : 
; 2755 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227750[esp+288]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 2756 : 
; 2757 : 		// Also - write to Other Logs, so that we know what the player is doing in there as well
; 2758 : 
; 2759 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	test	al, al
	je	$LN5@LogStrateg

; 2760 : 		{
; 2761 : 			strLogName = "TechAILog_" + playerName + ".csv";

	lea	eax, DWORD PTR _playerName$227737[esp+288]
	push	eax
	lea	ecx, DWORD PTR $T233254[esp+292]
	push	OFFSET $SG227759
	push	ecx
	call	ebp
	push	OFFSET $SG227758
	push	eax
	lea	edx, DWORD PTR $T233255[esp+308]
	mov	bl, 8
	push	edx
	mov	BYTE PTR __$EHRec$[esp+320], bl
	call	edi
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+296], 9
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$227738[esp+292]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T233255[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T233254[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2762 : 			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strLogName$227738[esp+288]
	mov	ebx, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [ebx]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, ebx
	call	eax

; 2763 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227750[esp+288]
	mov	ebx, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	ebx
	call	edx
	add	esp, 8

; 2764 : 
; 2765 : 			CvString cityName;

	lea	ecx, DWORD PTR _cityName$227760[esp+288]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2766 : 
; 2767 : 			CvCity* pLoopCity;
; 2768 : 			int iLoop;
; 2769 : 
; 2770 : 			for(pLoopCity = GetPlayer()->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iLoop))

	mov	eax, DWORD PTR _this$[esp+288]
	mov	ecx, DWORD PTR [eax+4]
	push	0
	lea	edx, DWORD PTR _iLoop$227762[esp+292]
	mov	bl, 10					; 0000000aH
	push	edx
	mov	BYTE PTR __$EHRec$[esp+304], bl
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	$LN2@LogStrateg
$LL4@LogStrateg:

; 2771 : 			{
; 2772 : 				cityName = pLoopCity->getName();

	lea	ecx, DWORD PTR $T233256[esp+288]
	push	ecx
	mov	ecx, eax
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _cityName$227760[esp+292]
	mov	BYTE PTR __$EHRec$[esp+300], 11		; 0000000bH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T233256[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2773 : 				strLogName = "CityStrategyAILog_" + playerName + "_" + cityName + ".csv";

	lea	edx, DWORD PTR _playerName$227737[esp+288]
	push	edx
	lea	eax, DWORD PTR $T233257[esp+292]
	push	OFFSET $SG227773
	push	eax
	call	ebp
	push	OFFSET $SG227772
	push	eax
	lea	ecx, DWORD PTR $T233258[esp+308]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+320], 12		; 0000000cH
	call	edi
	lea	edx, DWORD PTR _cityName$227760[esp+312]
	push	edx
	push	eax
	lea	eax, DWORD PTR $T233259[esp+320]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+332], 13		; 0000000dH
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	push	OFFSET $SG227771
	push	eax
	lea	ecx, DWORD PTR $T233260[esp+332]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+344], 14		; 0000000eH
	call	edi
	add	esp, 48					; 00000030H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+296], 15		; 0000000fH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$227738[esp+292]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T233260[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], 14		; 0000000eH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T233259[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], 13		; 0000000dH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T233258[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], 12		; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T233257[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2774 : 				pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strLogName$227738[esp+288]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 2775 : 				pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227750[esp+288]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	mov	eax, DWORD PTR _this$[esp+296]
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	0
	lea	edx, DWORD PTR _iLoop$227762[esp+292]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	$LL4@LogStrateg
$LN2@LogStrateg:

; 2776 : 			}
; 2777 : 		}

	lea	ecx, DWORD PTR _cityName$227760[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2778 : 		else

	jmp	SHORT $LN1@LogStrateg
$LN5@LogStrateg:

; 2779 : 		{
; 2780 : 			pLog = LOGFILEMGR.GetLog("CityStrategyAILog.csv", FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	edx, DWORD PTR [eax]
	push	0
	push	1
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+12]
	push	OFFSET $SG227775
	call	eax

; 2781 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227750[esp+288]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 2782 : 			pLog = LOGFILEMGR.GetLog("TechAILog.csv", FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	edx, DWORD PTR [eax]
	push	0
	push	1
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+12]
	push	OFFSET $SG227776
	call	eax

; 2783 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$227750[esp+288]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8
$LN1@LogStrateg:

; 2784 : 		}
; 2785 : 	}

	lea	ecx, DWORD PTR _strOutBuf$227750[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$227746[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogName$227738[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$227737[esp+288]
	mov	DWORD PTR __$EHRec$[esp+296], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	ebp
	pop	ebx
$LN8@LogStrateg:

; 2786 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+276]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 272				; 00000110H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _playerName$227737[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _strLogName$227738[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$2:
	lea	ecx, DWORD PTR $T233251[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$3:
	lea	ecx, DWORD PTR $T233252[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$4:
	lea	ecx, DWORD PTR _strBaseString$227746[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$5:
	lea	ecx, DWORD PTR $T233253[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$6:
	lea	ecx, DWORD PTR _strOutBuf$227750[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$7:
	lea	ecx, DWORD PTR _strTemp$227753[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$8:
	lea	ecx, DWORD PTR $T233254[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$9:
	lea	ecx, DWORD PTR $T233255[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$10:
	lea	ecx, DWORD PTR _cityName$227760[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$11:
	lea	ecx, DWORD PTR $T233256[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$12:
	lea	ecx, DWORD PTR $T233257[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$13:
	lea	ecx, DWORD PTR $T233258[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$14:
	lea	ecx, DWORD PTR $T233259[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$15:
	lea	ecx, DWORD PTR $T233260[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z ENDP ; CvEconomicAI::LogStrategy
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvPurchaseRequest@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvPurchaseRequest@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T233416 = 12						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvPurchaseRequest@@@Z PROC ; operator<<, COMDAT

; 2802 : {

	push	esi

; 2803 : 	saveTo << (int)readFrom.m_eType;

	mov	esi, DWORD PTR _saveTo$[esp]
	push	edi
	mov	edi, DWORD PTR _readFrom$[esp+4]
	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR $T233416[esp+4]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T233416[esp+8], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2804 : 	saveTo << readFrom.m_iAmount;

	lea	edx, DWORD PTR [edi+4]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2805 : 	saveTo << readFrom.m_iPriority;

	add	edi, 8
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi

; 2806 : 	return saveTo;

	mov	eax, esi
	pop	esi

; 2807 : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvPurchaseRequest@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvPurchaseRequest@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvPurchaseRequest@@@Z
_TEXT	SEGMENT
_iTemp$ = 8						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvPurchaseRequest@@@Z PROC ; operator>>, COMDAT

; 2810 : {

	push	esi

; 2811 : 	int iTemp;
; 2812 : 	loadFrom >> iTemp;

	mov	esi, DWORD PTR _loadFrom$[esp]
	push	edi
	lea	eax, DWORD PTR _iTemp$[esp+4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2813 : 	writeTo.m_eType = (PurchaseType)iTemp;

	mov	edi, DWORD PTR _writeTo$[esp+4]
	mov	ecx, DWORD PTR _iTemp$[esp+4]

; 2814 : 	loadFrom >> writeTo.m_iAmount;

	lea	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [edi], ecx
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2815 : 	loadFrom >> writeTo.m_iPriority;

	add	edi, 8
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi

; 2816 : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 2817 : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvPurchaseRequest@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::GetWeightThresholdModifier
EXTRN	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z:PROC ; CvFlavorManager::GetPersonalityIndividualFlavor
EXTRN	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ:PROC ; CvPlayer::GetFlavorManager
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_iWeightThresholdModifier$ = -4				; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::GetWeightThresholdModifier, COMDAT

; 2828 : {

	push	ecx

; 2829 : 	int iWeightThresholdModifier = 0;

	xor	eax, eax
	push	esi

; 2830 : 
; 2831 : 	// Look at all Flavors for the Player & this Strategy
; 2832 : 	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	esi, esi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, eax
	mov	DWORD PTR _iWeightThresholdModifier$[esp+8], eax
	jle	SHORT $LN1@GetWeightT
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _eStrategy$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pPlayer$[esp+16]
	npad	3
$LL3@GetWeightT:

; 2833 : 	{
; 2834 : 		FlavorTypes eFlavor = (FlavorTypes) iFlavorLoop;
; 2835 : 		int iPersonalityFlavor = pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor);

	push	esi
	mov	ecx, edi
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor

; 2836 : 		int iStrategyFlavorMod = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy)->GetPersonalityFlavorThresholdMod(eFlavor);

	mov	ecx, edi
	mov	ebx, eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+ebp*4]
	mov	eax, DWORD PTR [eax+272]
	test	eax, eax
	je	SHORT $LN16@GetWeightT
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN17@GetWeightT
$LN16@GetWeightT:
	or	eax, -1
$LN17@GetWeightT:

; 2837 : 
; 2838 : 		iWeightThresholdModifier += (iPersonalityFlavor * iStrategyFlavorMod);

	imul	eax, ebx
	add	DWORD PTR _iWeightThresholdModifier$[esp+20], eax
	inc	esi
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL3@GetWeightT

; 2839 : 	}
; 2840 : 
; 2841 : 	return iWeightThresholdModifier;

	mov	eax, DWORD PTR _iWeightThresholdModifier$[esp+20]
	pop	edi
	pop	ebp
	pop	ebx
$LN1@GetWeightT:
	pop	esi

; 2842 : }

	pop	ecx
	ret	0
?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::GetWeightThresholdModifier
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NavalMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NavalMap
EXTRN	?GetAIMapHint@CvMap@@QAEHXZ:PROC		; CvMap::GetAIMapHint
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NavalMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NavalMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NavalMap, COMDAT

; 3036 : 	if(pPlayer->isHuman())

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN1@IsTestStra@11

; 3037 : 	{
; 3038 : 		return false;

	xor	al, al

; 3042 : }

	ret	0
$LN1@IsTestStra@11:

; 3039 : 	}
; 3040 : 
; 3041 : 	return (GC.getMap().GetAIMapHint() & 1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	and	eax, 1

; 3042 : }

	ret	0
?IsTestStrategy_NavalMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NavalMap
_TEXT	ENDS
PUBLIC	?IsTestStrategy_OffshoreExpansionMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_OffshoreExpansionMap
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_OffshoreExpansionMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_OffshoreExpansionMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_OffshoreExpansionMap, COMDAT

; 3047 : 	if(pPlayer->isHuman())

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN1@IsTestStra@12

; 3048 : 	{
; 3049 : 		return false;

	xor	al, al

; 3053 : }

	ret	0
$LN1@IsTestStra@12:

; 3050 : 	}
; 3051 : 
; 3052 : 	return (GC.getMap().GetAIMapHint() & 4);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	shr	eax, 2
	and	al, 1

; 3053 : }

	ret	0
?IsTestStrategy_OffshoreExpansionMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_OffshoreExpansionMap
_TEXT	ENDS
PUBLIC	?IsTestStrategy_EarlyExpansion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EarlyExpansion
EXTRN	?GetNumPuppetCities@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetNumPuppetCities
EXTRN	?getNumTiles@CvArea@@QBEHXZ:PROC		; CvArea::getNumTiles
EXTRN	?getNumUnownedTiles@CvArea@@QBEHXZ:PROC		; CvArea::getNumUnownedTiles
EXTRN	?getNumOwnedTiles@CvArea@@QBEHXZ:PROC		; CvArea::getNumOwnedTiles
EXTRN	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z:PROC	; CvPlayer::GetBestSettleAreas
EXTRN	?getArea@CvMap@@QAEPAVCvArea@@H@Z:PROC		; CvMap::getArea
EXTRN	?getArea@CvCity@@QBEHXZ:PROC			; CvCity::getArea
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z:PROC ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	?isOption@CvGame@@QBE_NPBD@Z:PROC		; CvGame::isOption
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_EarlyExpansion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T233489 = -24						; size = 4
_iFlavorGrowth$ = -24					; size = 4
$T233576 = -20						; size = 4
_iFlavorExpansion$ = -20				; size = 4
_iSecondBestArea$227996 = -16				; size = 4
$T233488 = -16						; size = 4
$T233486 = -16						; size = 4
_iBestArea$227995 = -12					; size = 4
$T233487 = -12						; size = 4
_iDesiredCities$ = -12					; size = 4
$T233490 = -8						; size = 4
_iNumUnownedTiles$228000 = -4				; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EarlyExpansion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_EarlyExpansion, COMDAT

; 3154 : {

	sub	esp, 24					; 00000018H
	push	esi

; 3155 : 	int iDesiredCities;
; 3156 : 	int iFlavorExpansion = 0;
; 3157 : 	int iFlavorGrowth = 0;
; 3158 : 
; 3159 : #ifdef NQM_AI_GIMP_NO_BUILDING_SETTLERS
; 3160 : 	if ((pPlayer->isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE)) || (!pPlayer->isHuman() && (GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS"))))

	mov	esi, DWORD PTR _pPlayer$[esp+24]
	push	edi
	xor	edi, edi
	mov	ecx, esi
	mov	DWORD PTR _iFlavorExpansion$[esp+32], edi
	mov	DWORD PTR _iFlavorGrowth$[esp+32], edi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN13@IsTestStra@13
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	5
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	jne	SHORT $LN12@IsTestStra@13
$LN13@IsTestStra@13:
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN15@IsTestStra@13
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG227972
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	jne	SHORT $LN12@IsTestStra@13
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG227973
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	je	SHORT $LN15@IsTestStra@13
$LN12@IsTestStra@13:
	pop	edi

; 3161 : #else
; 3162 : 	if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && pPlayer->isHuman())
; 3163 : #endif
; 3164 : 	{
; 3165 : 		return false;

	xor	al, al
	pop	esi

; 3221 : }

	add	esp, 24					; 00000018H
	ret	0
$LN15@IsTestStra@13:
	push	ebx
	push	ebp

; 3166 : 	}
; 3167 : 
; 3168 : 	iDesiredCities = pPlayer->GetEconomicAI()->GetEarlyCityNumberTarget();

	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	eax, DWORD PTR [eax+24]

; 3169 : 	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes() && (iFlavorExpansion == 0 || iFlavorGrowth == 0); iFlavorLoop++)

	xor	ebp, ebp
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, edi
	mov	DWORD PTR _iDesiredCities$[esp+40], eax
	jle	SHORT $LN67@IsTestStra@13

; 3166 : 	}
; 3167 : 
; 3168 : 	iDesiredCities = pPlayer->GetEconomicAI()->GetEarlyCityNumberTarget();

	mov	ebx, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	npad	6
$LL66@IsTestStra@13:

; 3169 : 	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes() && (iFlavorExpansion == 0 || iFlavorGrowth == 0); iFlavorLoop++)

	cmp	DWORD PTR _iFlavorExpansion$[esp+40], 0
	je	SHORT $LN8@IsTestStra@13
	cmp	DWORD PTR _iFlavorGrowth$[esp+40], 0
	jne	SHORT $LN67@IsTestStra@13
$LN8@IsTestStra@13:

; 3170 : 	{
; 3171 : 		if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_EXPANSION")

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [edi+ecx]
	push	OFFSET $SG227981
	push	eax
	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN7@IsTestStra@13

; 3172 : 		{
; 3173 : 			iFlavorExpansion = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)iFlavorLoop);

	push	ebp
	mov	ecx, esi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorExpansion$[esp+40], eax
	jmp	SHORT $LN10@IsTestStra@13
$LN7@IsTestStra@13:

; 3174 : 		}
; 3175 : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_GROWTH")

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [edi+edx]
	push	OFFSET $SG227986
	push	eax
	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN10@IsTestStra@13

; 3176 : 		{
; 3177 : 			iFlavorGrowth = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)iFlavorLoop);

	push	ebp
	mov	ecx, esi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorGrowth$[esp+40], eax
$LN10@IsTestStra@13:
	inc	ebp
	add	edi, 28					; 0000001cH
	cmp	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL66@IsTestStra@13
$LN67@IsTestStra@13:

; 3178 : 		}
; 3179 : 	}
; 3180 : 
; 3181 : 	iDesiredCities = (iDesiredCities * iFlavorExpansion) / max(iFlavorGrowth, 1);

	mov	eax, 1
	cmp	DWORD PTR _iFlavorGrowth$[esp+40], eax
	mov	DWORD PTR $T233486[esp+40], eax
	lea	ecx, DWORD PTR $T233486[esp+40]
	jl	SHORT $LN35@IsTestStra@13
	lea	ecx, DWORD PTR _iFlavorGrowth$[esp+40]
$LN35@IsTestStra@13:
	mov	eax, DWORD PTR _iDesiredCities$[esp+40]
	imul	eax, DWORD PTR _iFlavorExpansion$[esp+40]
	cdq
	idiv	DWORD PTR [ecx]

; 3182 : 	int iDifficulty = max(0,GC.getGame().getHandicapInfo().GetID() - 3);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, eax
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	eax, DWORD PTR [eax+4]
	sub	eax, 3
	mov	DWORD PTR $T233487[esp+40], eax
	test	eax, eax
	mov	DWORD PTR $T233488[esp+40], 0
	lea	eax, DWORD PTR $T233487[esp+40]
	jg	SHORT $LN43@IsTestStra@13
	lea	eax, DWORD PTR $T233488[esp+40]
$LN43@IsTestStra@13:

; 3183 : 	iDesiredCities += iDifficulty;

	mov	ecx, DWORD PTR [eax]

; 3184 : 
; 3185 : 	// scale this based on world size
; 3186 : 	const int iDefaultNumTiles = 80*52;
; 3187 : 	iDesiredCities = (iDesiredCities * GC.getMap().numPlots()) / iDefaultNumTiles;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	imul	ecx, DWORD PTR [eax+4028]
	mov	eax, 2114445439				; 7e07e07fH
	imul	ecx
	sar	edx, 11					; 0000000bH
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH

; 3188 : 
; 3189 : 	// See how many unowned Tiles there are on this player's landmass
; 3190 : 	if(pPlayer->getCapitalCity() != NULL)

	mov	ecx, esi
	add	ebp, edx
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	je	$LN1@IsTestStra@13

; 3191 : 	{
; 3192 : 		// Make sure city specialization has gotten one chance to specialize the capital before we adopt this
; 3193 : 		//if(GC.getGame().getGameTurn() > GC.getAI_CITY_SPECIALIZATION_EARLIEST_TURN())
; 3194 : 		{
; 3195 : 			CvArea* pArea = GC.getMap().getArea(pPlayer->getCapitalCity()->getArea());

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	mov	ecx, edi
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea

; 3196 : 
; 3197 : 			// Is this area still one of the best to settle?
; 3198 : 			int iBestArea, iSecondBestArea;
; 3199 : 			pPlayer->GetBestSettleAreas(pPlayer->GetEconomicAI()->GetMinimumSettleFertility(), iBestArea, iSecondBestArea);

	mov	ecx, esi
	mov	edi, eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	eax, DWORD PTR [eax+48]
	lea	ecx, DWORD PTR _iSecondBestArea$227996[esp+40]
	push	ecx
	lea	edx, DWORD PTR _iBestArea$227995[esp+44]
	push	edx
	push	eax
	mov	ecx, esi
	call	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z ; CvPlayer::GetBestSettleAreas

; 3200 : 			if(iBestArea == pArea->GetID() || iSecondBestArea == pArea->GetID())

	mov	eax, DWORD PTR [edi+4]
	cmp	DWORD PTR _iBestArea$227995[esp+40], eax
	je	SHORT $LN2@IsTestStra@13
	cmp	DWORD PTR _iSecondBestArea$227996[esp+40], eax
	jne	$LN1@IsTestStra@13
$LN2@IsTestStra@13:

; 3201 : 			{
; 3202 : 				int iNumOwnedTiles = pArea->getNumOwnedTiles();

	mov	ecx, edi
	call	?getNumOwnedTiles@CvArea@@QBEHXZ	; CvArea::getNumOwnedTiles

; 3203 : 				int iNumUnownedTiles = pArea->getNumUnownedTiles();

	mov	ecx, edi
	mov	ebx, eax
	call	?getNumUnownedTiles@CvArea@@QBEHXZ	; CvArea::getNumUnownedTiles

; 3204 : 				int iNumTiles = max(1,pArea->getNumTiles());

	mov	ecx, edi
	mov	DWORD PTR _iNumUnownedTiles$228000[esp+40], eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	cmp	eax, 1
	mov	DWORD PTR $T233489[esp+40], eax
	mov	DWORD PTR $T233490[esp+40], 1
	jle	SHORT $LN58@IsTestStra@13
	lea	ecx, DWORD PTR $T233489[esp+40]
	mov	DWORD PTR $T233576[esp+40], ecx
	jmp	SHORT $LN59@IsTestStra@13
$LN58@IsTestStra@13:
	lea	edx, DWORD PTR $T233490[esp+40]
	mov	DWORD PTR $T233576[esp+40], edx
$LN59@IsTestStra@13:

; 3205 : 
; 3206 : 				int iOwnageRatio = iNumOwnedTiles * 100 / iNumTiles;
; 3207 : 				int iNumCities = pPlayer->getNumCities() - pPlayer->GetNumPuppetCities();

	mov	ecx, esi
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	ecx, esi
	mov	edi, eax
	call	?GetNumPuppetCities@CvPlayer@@QBEHXZ	; CvPlayer::GetNumPuppetCities

; 3208 : 				int iSettlersOnMap = pPlayer->GetNumUnitsWithUnitAI(UNITAI_SETTLE, true);

	push	1
	push	1
	push	1
	mov	ecx, esi
	sub	edi, eax
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	esi, DWORD PTR $T233576[esp+40]
	mov	ecx, eax
	mov	eax, ebx
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR [esi]

; 3209 : 
; 3210 : 				if(iOwnageRatio < GC.getAI_STRATEGY_AREA_IS_FULL_PERCENT()
; 3211 : 				        && (iNumCities + iSettlersOnMap) < iDesiredCities
; 3212 : 				        && iNumUnownedTiles >= GC.getAI_STRATEGY_EARLY_EXPANSION_NUM_UNOWNED_TILES_REQUIRED())

	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2024
	jge	SHORT $LN1@IsTestStra@13
	add	ecx, edi
	cmp	ecx, ebp
	jge	SHORT $LN1@IsTestStra@13
	mov	eax, DWORD PTR _iNumUnownedTiles$228000[esp+40]
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2008
	jl	SHORT $LN1@IsTestStra@13
	pop	ebp
	pop	ebx
	pop	edi

; 3213 : 				{
; 3214 : 					return true;

	mov	al, 1
	pop	esi

; 3221 : }

	add	esp, 24					; 00000018H
	ret	0
$LN1@IsTestStra@13:
	pop	ebp
	pop	ebx
	pop	edi

; 3215 : 				}
; 3216 : 			}
; 3217 : 		}
; 3218 : 	}
; 3219 : 
; 3220 : 	return false;

	xor	al, al
	pop	esi

; 3221 : }

	add	esp, 24					; 00000018H
	ret	0
?IsTestStrategy_EarlyExpansion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_EarlyExpansion
_TEXT	ENDS
PUBLIC	?IsTestStrategy_EnoughExpansion@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EnoughExpansion
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_EnoughExpansion@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_iSecondBestArea$ = -8					; size = 4
_iBestArea$ = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_EnoughExpansion@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_EnoughExpansion, COMDAT

; 3225 : {

	sub	esp, 8
	push	esi

; 3226 : 	int iBestArea;
; 3227 : 	int iSecondBestArea;
; 3228 : 
; 3229 : #ifdef NQM_AI_GIMP_NO_BUILDING_SETTLERS
; 3230 : 	if ((pPlayer->isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE)) || (!pPlayer->isHuman() && (GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS"))))

	mov	esi, DWORD PTR _pPlayer$[esp+8]
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN10@IsTestStra@14
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	5
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	jne	SHORT $LN9@IsTestStra@14
$LN10@IsTestStra@14:
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN12@IsTestStra@14
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG228018
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	jne	SHORT $LN9@IsTestStra@14
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG228019
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	je	SHORT $LN12@IsTestStra@14
$LN9@IsTestStra@14:

; 3231 : #else
; 3232 : 	if (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && pPlayer->isHuman())
; 3233 : #endif
; 3234 : 	{
; 3235 : 		return true;

	mov	al, 1
	pop	esi

; 3282 : 	{
; 3283 : 		return true;
; 3284 : 	}
; 3285 : 
; 3286 : 	return false;
; 3287 : }

	add	esp, 8
	ret	0
$LN12@IsTestStra@14:

; 3236 : 	}
; 3237 : 
; 3238 : 	int iNumSettleAreas = pPlayer->GetBestSettleAreas(pPlayer->GetEconomicAI()->GetMinimumSettleFertility(), iBestArea, iSecondBestArea);

	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	eax, DWORD PTR [eax+48]
	lea	ecx, DWORD PTR _iSecondBestArea$[esp+12]
	push	ecx
	lea	edx, DWORD PTR _iBestArea$[esp+16]
	push	edx
	push	eax
	mov	ecx, esi
	call	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z ; CvPlayer::GetBestSettleAreas

; 3239 : 	if (iNumSettleAreas == 0)

	test	eax, eax

; 3240 : 	{
; 3241 : 		return true;

	je	SHORT $LN9@IsTestStra@14
	push	ebx
	push	edi

; 3242 : 	}
; 3243 : 
; 3244 : 	int iNumExtraSettlers = 0;
; 3245 : 
; 3246 : 	if (!pPlayer->IsEmpireUnhappy())

	mov	ecx, esi
	xor	ebx, ebx
	call	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ	; CvPlayer::IsEmpireUnhappy
	test	al, al
	jne	SHORT $LN2@IsTestStra@14

; 3247 : 	{
; 3248 : 
; 3249 : 		// If we are running "ReallyExpandToOtherContinents"
; 3250 : 		EconomicAIStrategyTypes eStrategyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_REALLY_EXPAND_TO_OTHER_CONTINENTS");

	push	0
	push	OFFSET $SG228026
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 3251 : 		if (eStrategyExpandToOtherContinents != NO_ECONOMICAISTRATEGY)

	cmp	edi, -1
	je	SHORT $LN4@IsTestStra@14

; 3252 : 		{
; 3253 : 			if (pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyExpandToOtherContinents))

	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	eax, DWORD PTR [eax+12]
	cmp	BYTE PTR [edi+eax], bl
	je	SHORT $LN4@IsTestStra@14

; 3254 : 			{
; 3255 : 				++iNumExtraSettlers;
; 3256 : 				if (GC.getMap().GetAIMapHint() & 4)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ebx, 1
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	test	al, 4
	je	SHORT $LN4@IsTestStra@14

; 3257 : 				{
; 3258 : 					++iNumExtraSettlers;

	mov	ebx, 2
$LN4@IsTestStra@14:

; 3259 : 				}
; 3260 : 			}
; 3261 : 		}
; 3262 : 
; 3263 : 		// if we are generally expansionistic
; 3264 : 		int iFlavorExpansion = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_EXPANSION"));

	push	0
	push	OFFSET $SG228032
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, esi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 3265 : 		if (iFlavorExpansion > 6)

	cmp	eax, 6
	jle	SHORT $LN3@IsTestStra@14

; 3266 : 		{
; 3267 : 			++iNumExtraSettlers;

	inc	ebx
$LN3@IsTestStra@14:

; 3268 : 		}
; 3269 : 		if (iFlavorExpansion > 8)

	cmp	eax, 8
	jle	SHORT $LN2@IsTestStra@14

; 3270 : 		{
; 3271 : 			++iNumExtraSettlers;

	inc	ebx
$LN2@IsTestStra@14:

; 3272 : 		}
; 3273 : 
; 3274 : 	}
; 3275 : 
; 3276 : 	int iSettlersOnMap = pPlayer->GetNumUnitsWithUnitAI(UNITAI_SETTLE, true);

	push	1
	push	1
	push	1
	mov	ecx, esi
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI

; 3277 : 
; 3278 : 	CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	ecx, esi
	mov	edi, eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI

; 3279 : 	int iMaxSettlers = /*1*/ pStrategy->GetWeightThreshold();
; 3280 : 
; 3281 : 	if (iSettlersOnMap >= iMaxSettlers + iNumExtraSettlers)

	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _eStrategy$[esp+16]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+268]
	add	edx, ebx
	cmp	edi, edx
	pop	edi
	pop	ebx
	setge	al
	pop	esi

; 3282 : 	{
; 3283 : 		return true;
; 3284 : 	}
; 3285 : 
; 3286 : 	return false;
; 3287 : }

	add	esp, 8
	ret	0
?IsTestStrategy_EnoughExpansion@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_EnoughExpansion
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedHappiness@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedHappiness
EXTRN	?GetExcessHappiness@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetExcessHappiness
EXTRN	?GetUnhappiness@CvPlayer@@QBEHPAVCvCity@@0@Z:PROC ; CvPlayer::GetUnhappiness
EXTRN	?getTotalPopulation@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getTotalPopulation
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedHappiness@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_NeedHappiness@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedHappiness, COMDAT

; 3292 : 	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	19					; 00000013H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	je	SHORT $LN3@IsTestStra@15

; 3293 : 	{
; 3294 : 		return false;

	xor	al, al

; 3313 : }

	ret	0
$LN3@IsTestStra@15:
	push	esi

; 3295 : 	}
; 3296 : 
; 3297 : 	if(pPlayer->getTotalPopulation() > 0 && pPlayer->GetUnhappiness() > 0)

	mov	esi, DWORD PTR _pPlayer$[esp]
	mov	ecx, esi
	call	?getTotalPopulation@CvPlayer@@QBEHXZ	; CvPlayer::getTotalPopulation
	test	eax, eax
	jle	SHORT $LN1@IsTestStra@15
	push	0
	push	0
	mov	ecx, esi
	call	?GetUnhappiness@CvPlayer@@QBEHPAVCvCity@@0@Z ; CvPlayer::GetUnhappiness
	test	eax, eax
	jle	SHORT $LN1@IsTestStra@15
	push	ebx
	push	edi

; 3298 : 	{
; 3299 : 		int iExcessHappiness = pPlayer->GetExcessHappiness();

	mov	ecx, esi
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness

; 3300 : 
; 3301 : 		CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	ecx, esi
	mov	edi, eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _eStrategy$[esp+8]
	mov	ebx, DWORD PTR [ecx+eax*4]

; 3302 : 		int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pPlayer);	// 1 Weight per HAPPINESS Flavor

	push	esi
	push	eax
	call	?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::GetWeightThresholdModifier

; 3303 : 
; 3304 : 		// This will range from 0 to 5. If Happiness is less than this we will activate the strategy
; 3305 : 		int iDivisor = /*2*/ pStrategy->GetWeightThreshold();
; 3306 : 		iWeightThresholdModifier /= iDivisor;

	cdq
	idiv	DWORD PTR [ebx+268]
	add	esp, 8

; 3307 : 
; 3308 : 		if(iExcessHappiness <= iWeightThresholdModifier)

	cmp	edi, eax
	pop	edi
	pop	ebx
	jg	SHORT $LN1@IsTestStra@15

; 3309 : 			return true;

	mov	al, 1
	pop	esi

; 3313 : }

	ret	0
$LN1@IsTestStra@15:

; 3310 : 	}
; 3311 : 
; 3312 : 	return false;

	xor	al, al
	pop	esi

; 3313 : }

	ret	0
?IsTestStrategy_NeedHappiness@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedHappiness
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedHappinessCritical@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedHappinessCritical
EXTRN	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ:PROC ; CvDiplomacyAI::GetStateAllWars
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedHappinessCritical@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_NeedHappinessCritical@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedHappinessCritical, COMDAT

; 3318 : 	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	19					; 00000013H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	je	SHORT $LN4@IsTestStra@16

; 3319 : 	{
; 3320 : 		return false;

	xor	al, al

; 3339 : }

	ret	0
$LN4@IsTestStra@16:
	push	esi

; 3321 : 	}
; 3322 : 
; 3323 : 	// If we're losing at war, return false
; 3324 : 	if(pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING)

	mov	esi, DWORD PTR _pPlayer$[esp]
	mov	ecx, esi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 2

; 3325 : 		return false;

	je	SHORT $LN1@IsTestStra@16

; 3326 : 
; 3327 : 	if(pPlayer->getTotalPopulation() > 0 && pPlayer->GetUnhappiness() > 0)

	mov	ecx, esi
	call	?getTotalPopulation@CvPlayer@@QBEHXZ	; CvPlayer::getTotalPopulation
	test	eax, eax
	jle	SHORT $LN1@IsTestStra@16
	push	0
	push	0
	mov	ecx, esi
	call	?GetUnhappiness@CvPlayer@@QBEHPAVCvCity@@0@Z ; CvPlayer::GetUnhappiness
	test	eax, eax
	jle	SHORT $LN1@IsTestStra@16
	push	edi

; 3328 : 	{
; 3329 : 		int iExcessHappiness = pPlayer->GetExcessHappiness();

	mov	ecx, esi
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness

; 3330 : 
; 3331 : 		CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	ecx, esi
	mov	edi, eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI

; 3332 : 		int iThreshold = /*-3*/ pStrategy->GetWeightThreshold();
; 3333 : 
; 3334 : 		if(iExcessHappiness <= iThreshold)

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _eStrategy$[esp+4]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	edi, DWORD PTR [eax+268]
	pop	edi
	jg	SHORT $LN1@IsTestStra@16

; 3335 : 			return true;

	mov	al, 1
	pop	esi

; 3339 : }

	ret	0
$LN1@IsTestStra@16:

; 3336 : 	}
; 3337 : 
; 3338 : 	return false;

	xor	al, al
	pop	esi

; 3339 : }

	ret	0
?IsTestStrategy_NeedHappinessCritical@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedHappinessCritical
_TEXT	ENDS
PUBLIC	?IsTestStrategy_CitiesNeedNavalGrowth@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalGrowth
EXTRN	?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z:PROC ; CvCityStrategyAI::IsUsingCityStrategy
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_CitiesNeedNavalGrowth@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_CitiesNeedNavalGrowth@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalGrowth, COMDAT

; 3343 : {

	push	ecx
	push	ebp
	push	edi

; 3344 : 	int iNumCitiesNeedNavalGrowth = 0;

	xor	ebp, ebp

; 3345 : 
; 3346 : 	CvCity* pLoopCity;
; 3347 : 	int iLoop;
; 3348 : 
; 3349 : 	AICityStrategyTypes eStrategyNeedNavalGrowth = (AICityStrategyTypes) GC.getInfoTypeForString("AICITYSTRATEGY_NEED_NAVAL_GROWTH");

	push	ebp
	push	OFFSET $SG228070
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 3350 : 
; 3351 : 	// CityStrategy doesn't exist in XML, so abort
; 3352 : 	if(eStrategyNeedNavalGrowth == NO_AICITYSTRATEGY)

	cmp	edi, -1
	jne	SHORT $LN7@IsTestStra@17
	pop	edi

; 3353 : 	{
; 3354 : 		return false;

	xor	al, al
	pop	ebp

; 3385 : }

	pop	ecx
	ret	0
$LN7@IsTestStra@17:
	push	esi

; 3355 : 	}
; 3356 : 
; 3357 : 	for(pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))

	mov	esi, DWORD PTR _pPlayer$[esp+12]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+20]
	push	eax
	mov	ecx, esi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN1@IsTestStra@17
	npad	7
$LL6@IsTestStra@17:

; 3358 : 	{
; 3359 : 		if(pLoopCity->GetCityStrategyAI()->IsUsingCityStrategy(eStrategyNeedNavalGrowth))

	push	edi
	mov	ecx, eax
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::IsUsingCityStrategy
	test	al, al
	je	SHORT $LN5@IsTestStra@17

; 3360 : 		{
; 3361 : 			iNumCitiesNeedNavalGrowth++;

	inc	ebp
$LN5@IsTestStra@17:

; 3355 : 	}
; 3356 : 
; 3357 : 	for(pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+20]
	push	ecx
	mov	ecx, esi
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL6@IsTestStra@17

; 3362 : 		}
; 3363 : 	}
; 3364 : 
; 3365 : 	if(iNumCitiesNeedNavalGrowth > 0)

	test	ebp, ebp
	jle	SHORT $LN1@IsTestStra@17
	push	ebx

; 3366 : 	{
; 3367 : 		CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _eStrategy$[esp+16]
	mov	ecx, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [ecx+eax*4]

; 3368 : 		int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pPlayer);	// 1 Weight per NAVAL_GROWTH Flavor

	push	esi
	push	eax
	call	?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::GetWeightThresholdModifier

; 3369 : 		int iWeightThreshold = pStrategy->GetWeightThreshold() + iWeightThresholdModifier;	// 25

	mov	edi, DWORD PTR [edi+268]
	add	esp, 8

; 3370 : 
; 3371 : 		int iCurrentWeight = (pPlayer->getNumCities() - 1) * 10;

	mov	ecx, esi
	mov	ebx, eax
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [eax+eax-10]
	add	edi, ebx

; 3372 : 		iCurrentWeight /= iWeightThreshold;

	cdq
	idiv	edi
	pop	ebx

; 3373 : 
; 3374 : 		// See CvStrategyAI::IsTestStrategy_CitiesNeedBorders for a couple examples on how the math here works
; 3375 : 
; 3376 : 		// Do enough of our Cities want NavalGrowth? [Average is 10/30; range is 10/25 to 10/35]
; 3377 : //		if (iNumCitiesNeedNavalGrowth > (GetPlayer()->getNumCities() - 1) / GC.getAI_STRATEGY_CITIES_NAVAL_GROWTH_DIVISOR())	// 3
; 3378 : 		if(iNumCitiesNeedNavalGrowth > iCurrentWeight)

	cmp	ebp, eax
	jle	SHORT $LN1@IsTestStra@17
	pop	esi
	pop	edi

; 3379 : 		{
; 3380 : 			return true;

	mov	al, 1
	pop	ebp

; 3385 : }

	pop	ecx
	ret	0
$LN1@IsTestStra@17:
	pop	esi
	pop	edi

; 3381 : 		}
; 3382 : 	}
; 3383 : 
; 3384 : 	return false;

	xor	al, al
	pop	ebp

; 3385 : }

	pop	ecx
	ret	0
?IsTestStrategy_CitiesNeedNavalGrowth@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalGrowth
_TEXT	ENDS
PUBLIC	?IsTestStrategy_CitiesNeedNavalTileImprovement@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalTileImprovement
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_CitiesNeedNavalTileImprovement@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_CitiesNeedNavalTileImprovement@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalTileImprovement, COMDAT

; 3389 : {

	push	ecx
	push	ebp
	push	edi

; 3390 : 	int iNumCitiesNeedNavalTileImprovement = 0;

	xor	ebp, ebp

; 3391 : 
; 3392 : 	CvCity* pLoopCity;
; 3393 : 	int iLoop;
; 3394 : 
; 3395 : 	AICityStrategyTypes eStrategyNeedNavalTileImprovement = (AICityStrategyTypes) GC.getInfoTypeForString("AICITYSTRATEGY_NEED_NAVAL_TILE_IMPROVEMENT");

	push	ebp
	push	OFFSET $SG228091
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 3396 : 
; 3397 : 	// CityStrategy doesn't exist in XML, so abort
; 3398 : 	if(eStrategyNeedNavalTileImprovement == NO_AICITYSTRATEGY)

	cmp	edi, -1
	jne	SHORT $LN7@IsTestStra@18
	pop	edi

; 3399 : 	{
; 3400 : 		return false;

	xor	al, al
	pop	ebp

; 3430 : }

	pop	ecx
	ret	0
$LN7@IsTestStra@18:
	push	esi

; 3401 : 	}
; 3402 : 
; 3403 : 	for(pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))

	mov	esi, DWORD PTR _pPlayer$[esp+12]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+20]
	push	eax
	mov	ecx, esi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN1@IsTestStra@18
	npad	7
$LL6@IsTestStra@18:

; 3404 : 	{
; 3405 : 		if(pLoopCity->GetCityStrategyAI()->IsUsingCityStrategy(eStrategyNeedNavalTileImprovement))

	push	edi
	mov	ecx, eax
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::IsUsingCityStrategy
	test	al, al
	je	SHORT $LN5@IsTestStra@18

; 3406 : 		{
; 3407 : 			iNumCitiesNeedNavalTileImprovement++;

	inc	ebp
$LN5@IsTestStra@18:

; 3401 : 	}
; 3402 : 
; 3403 : 	for(pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+20]
	push	ecx
	mov	ecx, esi
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL6@IsTestStra@18

; 3408 : 		}
; 3409 : 	}
; 3410 : 
; 3411 : 	if(iNumCitiesNeedNavalTileImprovement > 0)

	test	ebp, ebp
	jle	SHORT $LN1@IsTestStra@18
	push	ebx

; 3412 : 	{
; 3413 : 		CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _eStrategy$[esp+16]
	mov	ecx, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [ecx+eax*4]

; 3414 : 		int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pPlayer);	// 1 Weight per NAVAL_TILE_IMPROVEMENT Flavor

	push	esi
	push	eax
	call	?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::GetWeightThresholdModifier

; 3415 : 		int iWeightThreshold = pStrategy->GetWeightThreshold() + iWeightThresholdModifier;	// 25

	mov	edi, DWORD PTR [edi+268]
	add	esp, 8

; 3416 : 
; 3417 : 		int iCurrentWeight = (pPlayer->getNumCities() - 1) * 10;

	mov	ecx, esi
	mov	ebx, eax
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [eax+eax-10]
	add	edi, ebx

; 3418 : 		iCurrentWeight /= iWeightThreshold;

	cdq
	idiv	edi
	pop	ebx

; 3419 : 
; 3420 : 		// See CvStrategyAI::IsTestStrategy_CitiesNeedBorders for a couple examples on how the math here works
; 3421 : 
; 3422 : 		// Do enough of our Cities want NavalTileImprovement? [Average is 10/30; range is 10/25 to 10/35]
; 3423 : 		if(iNumCitiesNeedNavalTileImprovement > iCurrentWeight)

	cmp	ebp, eax
	jle	SHORT $LN1@IsTestStra@18
	pop	esi
	pop	edi

; 3424 : 		{
; 3425 : 			return true;

	mov	al, 1
	pop	ebp

; 3430 : }

	pop	ecx
	ret	0
$LN1@IsTestStra@18:
	pop	esi
	pop	edi

; 3426 : 		}
; 3427 : 	}
; 3428 : 
; 3429 : 	return false;

	xor	al, al
	pop	ebp

; 3430 : }

	pop	ecx
	ret	0
?IsTestStrategy_CitiesNeedNavalTileImprovement@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalTileImprovement
_TEXT	ENDS
PUBLIC	?IsTestStrategy_TradeWithCityState@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_TradeWithCityState
EXTRN	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z:PROC ; CvPlayer::addAIOperation
EXTRN	?getArmyID@CvUnit@@QBEHXZ:PROC			; CvUnit::getArmyID
EXTRN	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ:PROC ; CvUnit::GetGreatPeopleDirective
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_TradeWithCityState@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_iUnitLoop$ = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_TradeWithCityState@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_TradeWithCityState, COMDAT

; 3540 : {

	push	ecx
	push	ebx
	push	edi

; 3541 : 	int iUnitLoop;
; 3542 : 	CvUnit* pLoopUnit;
; 3543 : 	int iLooseMerchant = 0;
; 3544 : 	int iStrategyWeight = 0;
; 3545 : 
; 3546 : 	// Never run this strategy for a human player
; 3547 : 	if(!pPlayer->isHuman())

	mov	edi, DWORD PTR _pPlayer$[esp+8]
	mov	ecx, edi
	xor	ebx, ebx
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	$LN1@IsTestStra@19
	push	esi

; 3548 : 	{
; 3549 : 		// Look at map for loose merchants
; 3550 : 		for(pLoopUnit = pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	eax, DWORD PTR _iUnitLoop$[esp+20]
	push	eax
	mov	ecx, edi
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN5@IsTestStra@19
$LN22@IsTestStra@19:

; 3551 : 		{
; 3552 : 			if(pLoopUnit != NULL)
; 3553 : 			{
; 3554 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_MERCHANT && pLoopUnit->GetGreatPeopleDirective() == GREAT_PEOPLE_DIRECTIVE_USE_POWER)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN6@IsTestStra@19
	mov	ecx, esi
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	cmp	eax, 1
	jne	SHORT $LN6@IsTestStra@19

; 3555 : 				{
; 3556 : 					if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, esi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	SHORT $LN6@IsTestStra@19

; 3557 : 					{
; 3558 : 						iLooseMerchant++;

	inc	ebx
$LN6@IsTestStra@19:

; 3548 : 	{
; 3549 : 		// Look at map for loose merchants
; 3550 : 		for(pLoopUnit = pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[esp+20]
	push	ecx
	mov	ecx, edi
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN22@IsTestStra@19
$LN5@IsTestStra@19:

; 3559 : 					}
; 3560 : 				}
; 3561 : 			}
; 3562 : 		}
; 3563 : 
; 3564 : 		CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	ecx, edi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _eStrategy$[esp+12]
	mov	ecx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx+eax*4]

; 3565 : 		iStrategyWeight = iLooseMerchant * 10;   // Just one merchant will trigger this
; 3566 : 		int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pPlayer);

	push	edi
	push	eax
	call	?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::GetWeightThresholdModifier

; 3567 : 		int iWeightThreshold = pStrategy->GetWeightThreshold() + iWeightThresholdModifier;

	mov	edx, DWORD PTR [esi+268]
	add	edx, eax
	lea	eax, DWORD PTR [ebx+ebx*4]
	add	esp, 8
	add	eax, eax

; 3568 : 
; 3569 : 		if(iStrategyWeight >= iWeightThreshold)

	cmp	eax, edx
	pop	esi
	jl	SHORT $LN1@IsTestStra@19

; 3570 : 		{
; 3571 : 			// Launch an operation.
; 3572 : 			pPlayer->addAIOperation(AI_OPERATION_MERCHANT_DELEGATION);

	push	0
	push	0
	push	-1
	push	-1
	push	8
	mov	ecx, edi
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	pop	edi

; 3573 : 
; 3574 : 			// Set this strategy active
; 3575 : 			return true;

	mov	al, 1
	pop	ebx

; 3580 : }

	pop	ecx
	ret	0
$LN1@IsTestStra@19:
	pop	edi

; 3576 : 		}
; 3577 : 	}
; 3578 : 
; 3579 : 	return false;

	xor	al, al
	pop	ebx

; 3580 : }

	pop	ecx
	ret	0
?IsTestStrategy_TradeWithCityState@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_TradeWithCityState
_TEXT	ENDS
PUBLIC	?IsTestStrategy_ConcertTour@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ConcertTour
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_ConcertTour@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_iUnitLoop$ = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_ConcertTour@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_ConcertTour, COMDAT

; 3584 : {

	push	ecx
	push	ebx
	push	edi

; 3585 : 	int iUnitLoop;
; 3586 : 	CvUnit* pLoopUnit;
; 3587 : 	int iLooseMusician = 0;
; 3588 : 	int iStrategyWeight = 0;
; 3589 : 
; 3590 : 	// Never run this strategy for a human player
; 3591 : 	if(!pPlayer->isHuman())

	mov	edi, DWORD PTR _pPlayer$[esp+8]
	mov	ecx, edi
	xor	ebx, ebx
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	$LN1@IsTestStra@20
	push	esi

; 3592 : 	{
; 3593 : 		// Look at map for loose merchants
; 3594 : 		for(pLoopUnit = pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	eax, DWORD PTR _iUnitLoop$[esp+20]
	push	eax
	mov	ecx, edi
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN5@IsTestStra@20
$LN22@IsTestStra@20:

; 3595 : 		{
; 3596 : 			if(pLoopUnit != NULL)
; 3597 : 			{
; 3598 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_MUSICIAN && pLoopUnit->GetGreatPeopleDirective() == GREAT_PEOPLE_DIRECTIVE_TOURISM_BLAST)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN6@IsTestStra@20
	mov	ecx, esi
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	cmp	eax, 5
	jne	SHORT $LN6@IsTestStra@20

; 3599 : 				{
; 3600 : 					if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, esi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	SHORT $LN6@IsTestStra@20

; 3601 : 					{
; 3602 : 						iLooseMusician++;

	inc	ebx
$LN6@IsTestStra@20:

; 3592 : 	{
; 3593 : 		// Look at map for loose merchants
; 3594 : 		for(pLoopUnit = pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[esp+20]
	push	ecx
	mov	ecx, edi
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN22@IsTestStra@20
$LN5@IsTestStra@20:

; 3603 : 					}
; 3604 : 				}
; 3605 : 			}
; 3606 : 		}
; 3607 : 
; 3608 : 		CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	ecx, edi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _eStrategy$[esp+12]
	mov	ecx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx+eax*4]

; 3609 : 		iStrategyWeight = iLooseMusician * 10;   // Just one musician will trigger this
; 3610 : 		int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pPlayer);

	push	edi
	push	eax
	call	?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::GetWeightThresholdModifier

; 3611 : 		int iWeightThreshold = pStrategy->GetWeightThreshold() + iWeightThresholdModifier;

	mov	edx, DWORD PTR [esi+268]
	add	edx, eax
	lea	eax, DWORD PTR [ebx+ebx*4]
	add	esp, 8
	add	eax, eax

; 3612 : 
; 3613 : 		if(iStrategyWeight >= iWeightThreshold)

	cmp	eax, edx
	pop	esi
	jl	SHORT $LN1@IsTestStra@20

; 3614 : 		{
; 3615 : 			// Launch an operation.
; 3616 : 			pPlayer->addAIOperation(AI_OPERATION_CONCERT_TOUR);

	push	0
	push	0
	push	-1
	push	-1
	push	19					; 00000013H
	mov	ecx, edi
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	pop	edi

; 3617 : 
; 3618 : 			// Set this strategy active
; 3619 : 			return true;

	mov	al, 1
	pop	ebx

; 3624 : }

	pop	ecx
	ret	0
$LN1@IsTestStra@20:
	pop	edi

; 3620 : 		}
; 3621 : 	}
; 3622 : 
; 3623 : 	return false;

	xor	al, al
	pop	ebx

; 3624 : }

	pop	ecx
	ret	0
?IsTestStrategy_ConcertTour@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_ConcertTour
_TEXT	ENDS
PUBLIC	?IsTestStrategy_LosingMoney@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_LosingMoney
EXTRN	?AverageIncome@CvTreasury@@QAENH@Z:PROC		; CvTreasury::AverageIncome
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_LosingMoney@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
$T233810 = 8						; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_LosingMoney@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_LosingMoney, COMDAT

; 3774 : {

	push	ebx

; 3775 : 	CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	ebx, DWORD PTR _pPlayer$[esp]
	push	esi
	push	edi
	mov	ecx, ebx
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _eStrategy$[esp+8]
	mov	esi, DWORD PTR [ecx+edx*4]

; 3776 : 	int iInterval = pStrategy->GetMinimumNumTurnsExecuted();
; 3777 : 
; 3778 : 	// Need a certain number of turns of history before we can turn this on
; 3779 : 	if(GC.getGame().getGameTurn() <= iInterval)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR [esi+288]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, edi
	jg	SHORT $LN1@IsTestStra@21
	pop	edi
	pop	esi

; 3780 : 	{
; 3781 : 		return false;

	xor	al, al
	pop	ebx

; 3786 : }

	ret	0
$LN1@IsTestStra@21:

; 3782 : 	}
; 3783 : 
; 3784 : 	// Is average income below desired threshold over past X turns?
; 3785 : 	return (pPlayer->GetTreasury()->AverageIncome(iInterval) < (double)pStrategy->GetWeightThreshold() /* 2 */);

	mov	eax, DWORD PTR [esi+268]
	push	edi
	mov	ecx, ebx
	mov	DWORD PTR $T233810[esp+12], eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?AverageIncome@CvTreasury@@QAENH@Z	; CvTreasury::AverageIncome
	fild	DWORD PTR $T233810[esp+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@IsTestStra@21
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 3786 : }

	ret	0
$LN4@IsTestStra@21:
	pop	edi
	pop	esi

; 3782 : 	}
; 3783 : 
; 3784 : 	// Is average income below desired threshold over past X turns?
; 3785 : 	return (pPlayer->GetTreasury()->AverageIncome(iInterval) < (double)pStrategy->GetWeightThreshold() /* 2 */);

	xor	eax, eax
	pop	ebx

; 3786 : }

	ret	0
?IsTestStrategy_LosingMoney@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_LosingMoney
_TEXT	ENDS
PUBLIC	?IsTestStrategy_ExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ExpandToOtherContinents
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_ExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_iBestArea$228329 = -8					; size = 4
_iSecondBestArea$228330 = -4				; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_ExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_ExpandToOtherContinents, COMDAT

; 3884 : {

	sub	esp, 8
	push	esi

; 3885 : #ifdef NQM_AI_GIMP_NO_BUILDING_SETTLERS
; 3886 : 	if ((pPlayer->isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE)) || (!pPlayer->isHuman() && (GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS"))))

	mov	esi, DWORD PTR _pPlayer$[esp+8]
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN12@IsTestStra@22
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	5
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	jne	SHORT $LN11@IsTestStra@22
$LN12@IsTestStra@22:
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN14@IsTestStra@22
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG228310
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	jne	SHORT $LN11@IsTestStra@22
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG228311
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	je	SHORT $LN14@IsTestStra@22
$LN11@IsTestStra@22:

; 3887 : #else
; 3888 : 	if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && pPlayer->isHuman())
; 3889 : #endif
; 3890 : 	{
; 3891 : 		return false;

	xor	al, al
	pop	esi

; 3939 : }

	add	esp, 8
	ret	0
$LN14@IsTestStra@22:
	push	edi

; 3892 : 	}
; 3893 : 
; 3894 : 	// Never run this at the same time as island start
; 3895 : 	EconomicAIStrategyTypes eStrategyIslandStart = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_ISLAND_START");

	push	0
	push	OFFSET $SG228314
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 3896 : 	if(eStrategyIslandStart != NO_ECONOMICAISTRATEGY)

	cmp	edi, -1
	je	SHORT $LN9@IsTestStra@22

; 3897 : 	{
; 3898 : 		if(pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyIslandStart))

	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	eax, DWORD PTR [eax+12]
	cmp	BYTE PTR [edi+eax], 0

; 3899 : 		{
; 3900 : 			return false;

	jne	$LN3@IsTestStra@22
$LN9@IsTestStra@22:

; 3901 : 		}
; 3902 : 	}
; 3903 : 
; 3904 : 	// we should settle our island first
; 3905 : 	EconomicAIStrategyTypes eEarlyExpansion = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EARLY_EXPANSION");

	push	0
	push	OFFSET $SG228319
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 3906 : 	if(eEarlyExpansion != NO_ECONOMICAISTRATEGY)

	cmp	edi, -1
	je	SHORT $LN7@IsTestStra@22

; 3907 : 	{
; 3908 : 		if(pPlayer->GetEconomicAI()->IsUsingStrategy(eEarlyExpansion))

	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, DWORD PTR [eax+12]
	cmp	BYTE PTR [edi+ecx], 0

; 3909 : 		{
; 3910 : 			return false;

	jne	$LN3@IsTestStra@22
$LN7@IsTestStra@22:

; 3911 : 		}
; 3912 : 	}
; 3913 : 
; 3914 : 	// Never desperate to settle distant lands if we are at war (unless we are doing okay at the war)
; 3915 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_LOSING_WARS");

	push	0
	push	OFFSET $SG228324
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 3916 : 	if(eStrategyAtWar != NO_MILITARYAISTRATEGY)

	cmp	eax, -1
	je	SHORT $LN5@IsTestStra@22

; 3917 : 	{
; 3918 : 		if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyAtWar))

	push	eax
	mov	ecx, esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	test	al, al

; 3919 : 		{
; 3920 : 			return false;

	jne	SHORT $LN3@IsTestStra@22
$LN5@IsTestStra@22:

; 3921 : 		}
; 3922 : 	}
; 3923 : 
; 3924 : 	if(pPlayer->getCapitalCity() != NULL)

	mov	ecx, esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	je	SHORT $LN3@IsTestStra@22

; 3925 : 	{
; 3926 : 		CvArea* pArea = GC.getMap().getArea(pPlayer->getCapitalCity()->getArea());

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	mov	ecx, edi
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea

; 3927 : 
; 3928 : 		// Do we have another area to settle (either first or second choice)?
; 3929 : 		int iBestArea, iSecondBestArea;
; 3930 : 		pPlayer->GetBestSettleAreas(pPlayer->GetEconomicAI()->GetMinimumSettleFertility(), iBestArea, iSecondBestArea);

	mov	ecx, esi
	mov	edi, eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	lea	edx, DWORD PTR _iSecondBestArea$228330[esp+16]
	push	edx
	mov	edx, DWORD PTR [eax+48]
	lea	ecx, DWORD PTR _iBestArea$228329[esp+20]
	push	ecx
	push	edx
	mov	ecx, esi
	call	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z ; CvPlayer::GetBestSettleAreas

; 3931 : 
; 3932 : 		if((iBestArea != pArea->GetID() && iBestArea != -1) || (iSecondBestArea != pArea->GetID() && iSecondBestArea != -1))

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR _iBestArea$228329[esp+16]
	cmp	ecx, eax
	je	SHORT $LN1@IsTestStra@22
	cmp	ecx, -1
	jne	SHORT $LN2@IsTestStra@22
$LN1@IsTestStra@22:
	mov	ecx, DWORD PTR _iSecondBestArea$228330[esp+16]
	cmp	ecx, eax
	je	SHORT $LN3@IsTestStra@22
	cmp	ecx, -1
	je	SHORT $LN3@IsTestStra@22
$LN2@IsTestStra@22:
	pop	edi

; 3933 : 		{
; 3934 : 			return true;

	mov	al, 1
	pop	esi

; 3939 : }

	add	esp, 8
	ret	0
$LN3@IsTestStra@22:
	pop	edi

; 3935 : 		}
; 3936 : 	}
; 3937 : 
; 3938 : 	return false;

	xor	al, al
	pop	esi

; 3939 : }

	add	esp, 8
	ret	0
?IsTestStrategy_ExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_ExpandToOtherContinents
_TEXT	ENDS
PUBLIC	?IsTestStrategy_ReallyExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ReallyExpandToOtherContinents
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_ReallyExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_iBestArea$228366 = -8					; size = 4
_iSecondBestArea$228367 = -4				; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_ReallyExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_ReallyExpandToOtherContinents, COMDAT

; 3944 : {

	sub	esp, 8
	push	esi

; 3945 : #ifdef NQM_AI_GIMP_NO_BUILDING_SETTLERS
; 3946 : 	if ((pPlayer->isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE)) || (!pPlayer->isHuman() && (GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS"))))

	mov	esi, DWORD PTR _pPlayer$[esp+8]
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN11@IsTestStra@23
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	5
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	jne	SHORT $LN10@IsTestStra@23
$LN11@IsTestStra@23:
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN13@IsTestStra@23
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG228341
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	jne	SHORT $LN10@IsTestStra@23
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG228342
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	je	SHORT $LN13@IsTestStra@23
$LN10@IsTestStra@23:

; 3947 : #else
; 3948 : 	if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && pPlayer->isHuman())
; 3949 : #endif
; 3950 : 	{
; 3951 : 		return false;

	xor	al, al
	pop	esi

; 4001 : }

	add	esp, 8
	ret	0
$LN13@IsTestStra@23:
	push	edi

; 3952 : 	}
; 3953 : 
; 3954 : 	// Only run this if we are running "ExpandToOtherContinents"
; 3955 : 	EconomicAIStrategyTypes eStrategyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS");

	push	0
	push	OFFSET $SG228345
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 3956 : 	if(eStrategyExpandToOtherContinents != NO_ECONOMICAISTRATEGY)

	cmp	edi, -1
	je	SHORT $LN8@IsTestStra@23

; 3957 : 	{
; 3958 : 		if(!pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyExpandToOtherContinents))

	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	eax, DWORD PTR [eax+12]
	cmp	BYTE PTR [edi+eax], 0

; 3959 : 		{
; 3960 : 			return false;

	je	$LN1@IsTestStra@23
$LN8@IsTestStra@23:

; 3961 : 		}
; 3962 : 	}
; 3963 : 
; 3964 : 	MilitaryAIStrategyTypes eStrategyLosingAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_LOSING_WARS");

	push	0
	push	OFFSET $SG228350
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 3965 : 	if(eStrategyLosingAtWar != NO_MILITARYAISTRATEGY)

	cmp	eax, -1
	je	SHORT $LN6@IsTestStra@23

; 3966 : 	{
; 3967 : 		if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyLosingAtWar))

	push	eax
	mov	ecx, esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	test	al, al

; 3968 : 		{
; 3969 : 			return false;

	jne	$LN1@IsTestStra@23
$LN6@IsTestStra@23:

; 3970 : 		}
; 3971 : 	}
; 3972 : 
; 3973 : 	// if we are at war probably shouldn't (unless the map is an offshore expansion map)
; 3974 : 	if ((GC.getMap().GetAIMapHint() & 4) == 0)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	test	al, 4
	jne	SHORT $LN3@IsTestStra@23

; 3975 : 	{
; 3976 : 		MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	push	OFFSET $SG228356
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 3977 : 		if(eStrategyAtWar != NO_MILITARYAISTRATEGY)

	cmp	eax, -1
	je	SHORT $LN3@IsTestStra@23

; 3978 : 		{
; 3979 : 			if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyAtWar))

	push	eax
	mov	ecx, esi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	test	al, al

; 3980 : 			{
; 3981 : 				return false;

	jne	$LN1@IsTestStra@23
$LN3@IsTestStra@23:

; 3982 : 			}
; 3983 : 		}
; 3984 : 	}
; 3985 : 
; 3986 : 	int iFlavorGrowth = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_GROWTH"));

	push	0
	push	OFFSET $SG228361
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, esi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 3987 : 	int iFlavorExpansion = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_EXPANSION"));

	push	0
	push	OFFSET $SG228364
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, esi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 3988 : 
; 3989 : 	if (iFlavorGrowth < iFlavorExpansion && pPlayer->getCapitalCity() != NULL && !pPlayer->IsEmpireUnhappy())

	cmp	edi, eax
	jge	SHORT $LN1@IsTestStra@23
	mov	ecx, esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	je	SHORT $LN1@IsTestStra@23
	mov	ecx, esi
	call	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ	; CvPlayer::IsEmpireUnhappy
	test	al, al
	jne	SHORT $LN1@IsTestStra@23

; 3990 : 	{
; 3991 : 		// If the other area is clearly better
; 3992 : 		int iBestArea, iSecondBestArea;
; 3993 : 		pPlayer->GetBestSettleAreas(pPlayer->GetEconomicAI()->GetMinimumSettleFertility(), iBestArea, iSecondBestArea);

	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	eax, DWORD PTR [eax+48]
	lea	ecx, DWORD PTR _iSecondBestArea$228367[esp+16]
	push	ecx
	lea	edx, DWORD PTR _iBestArea$228366[esp+20]
	push	edx
	push	eax
	mov	ecx, esi
	call	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z ; CvPlayer::GetBestSettleAreas

; 3994 : 		if ((iBestArea != pPlayer->getCapitalCity()->getArea() && iBestArea != -1))

	mov	ecx, esi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	mov	ecx, DWORD PTR _iBestArea$228366[esp+16]
	cmp	ecx, eax
	je	SHORT $LN1@IsTestStra@23
	cmp	ecx, -1
	je	SHORT $LN1@IsTestStra@23
	pop	edi

; 3995 : 		{
; 3996 : 			return true;

	mov	al, 1
	pop	esi

; 4001 : }

	add	esp, 8
	ret	0
$LN1@IsTestStra@23:
	pop	edi

; 3997 : 		}
; 3998 : 	}
; 3999 : 
; 4000 : 	return false;

	xor	al, al
	pop	esi

; 4001 : }

	add	esp, 8
	ret	0
?IsTestStrategy_ReallyExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_ReallyExpandToOtherContinents
_TEXT	ENDS
PUBLIC	?IsTestStrategy_ExpandLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ExpandLikeCrazy
EXTRN	?GetNumCitiesPolicyCostMod@CvWorldInfo@@QBEHXZ:PROC ; CvWorldInfo::GetNumCitiesPolicyCostMod
EXTRN	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ:PROC	; CvMap::getWorldInfo
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_ExpandLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_ExpandLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_ExpandLikeCrazy, COMDAT

; 4027 : {

	push	esi

; 4028 : #ifdef NQM_AI_GIMP_NO_BUILDING_SETTLERS
; 4029 : 	if ((pPlayer->isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE)) || (!pPlayer->isHuman() && (GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS"))))

	mov	esi, DWORD PTR _pPlayer$[esp]
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN6@IsTestStra@24
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	5
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	jne	SHORT $LN5@IsTestStra@24
$LN6@IsTestStra@24:
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN8@IsTestStra@24
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG228389
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	jne	SHORT $LN5@IsTestStra@24
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG228390
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	je	SHORT $LN8@IsTestStra@24
$LN5@IsTestStra@24:

; 4030 : #else
; 4031 : 	if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && pPlayer->isHuman())
; 4032 : #endif
; 4033 : 	{
; 4034 : 		return false;

	xor	al, al
	pop	esi

; 4054 : 	{
; 4055 : 		return true;
; 4056 : 	}
; 4057 : 
; 4058 : 	return false;
; 4059 : }

	ret	0
$LN8@IsTestStra@24:
	push	edi

; 4035 : 	}
; 4036 : 
; 4037 : 	// Never run this if we are going for a cultural victory since it will derail that
; 4038 : 	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");

	push	0
	push	OFFSET $SG228393
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edi, eax

; 4039 : 	if(eGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	edi, -1
	je	SHORT $LN2@IsTestStra@24

; 4040 : 	{
; 4041 : 		if(pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)

	mov	ecx, esi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, edi
	jne	SHORT $LN2@IsTestStra@24

; 4042 : 		{
; 4043 : 			// Does number of cities matter?
; 4044 : 			if(GC.getMap().getWorldInfo().GetNumCitiesPolicyCostMod() > 0)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	ecx, eax
	call	?GetNumCitiesPolicyCostMod@CvWorldInfo@@QBEHXZ ; CvWorldInfo::GetNumCitiesPolicyCostMod
	test	eax, eax
	jle	SHORT $LN2@IsTestStra@24
	pop	edi

; 4045 : 			{
; 4046 : 				return false;

	xor	al, al
	pop	esi

; 4054 : 	{
; 4055 : 		return true;
; 4056 : 	}
; 4057 : 
; 4058 : 	return false;
; 4059 : }

	ret	0
$LN2@IsTestStra@24:

; 4047 : 			}
; 4048 : 		}
; 4049 : 	}
; 4050 : 
; 4051 : 	int iFlavorExpansion = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_EXPANSION"));

	push	0
	push	OFFSET $SG228399
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, esi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 4052 : 	CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	ecx, esi
	mov	edi, eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI

; 4053 : 	if(iFlavorExpansion >= pStrategy->GetWeightThreshold())

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _eStrategy$[esp+4]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	edi, DWORD PTR [eax+268]
	pop	edi
	setge	al
	pop	esi

; 4054 : 	{
; 4055 : 		return true;
; 4056 : 	}
; 4057 : 
; 4058 : 	return false;
; 4059 : }

	ret	0
?IsTestStrategy_ExpandLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_ExpandLikeCrazy
_TEXT	ENDS
PUBLIC	?IsTestStrategy_GrowLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GrowLikeCrazy
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_GrowLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_GrowLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_GrowLikeCrazy, COMDAT

; 4062 : {

	push	esi
	push	edi

; 4063 : 	int iFlavorGrowth = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_GROWTH"));

	push	0
	push	OFFSET $SG228408
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, DWORD PTR _pPlayer$[esp+4]
	push	eax
	mov	ecx, esi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 4064 : 	CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	ecx, esi
	mov	edi, eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI

; 4065 : 	if(iFlavorGrowth >= pStrategy->GetWeightThreshold())

	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _eStrategy$[esp+4]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	edi, DWORD PTR [eax+268]
	pop	edi
	setge	al
	pop	esi

; 4066 : 	{
; 4067 : 		return true;
; 4068 : 	}
; 4069 : 
; 4070 : 	return false;
; 4071 : }

	ret	0
?IsTestStrategy_GrowLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_GrowLikeCrazy
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	?IsTestStrategy_EnoughArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EnoughArchaeologists
EXTRN	?GetNumHiddenArchaeologySites@CvGame@@QBEHXZ:PROC ; CvGame::GetNumHiddenArchaeologySites
EXTRN	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z:PROC ; CvPlayerPolicies::HasPolicy
EXTRN	?GetNumArchaeologySites@CvGame@@QBEHXZ:PROC	; CvGame::GetNumArchaeologySites
;	COMDAT __real@3fe0000000000000
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?IsTestStrategy_EnoughArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_iNumSites$ = -8					; size = 4
_iNumArchaeologists$ = -4				; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EnoughArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_EnoughArchaeologists, COMDAT

; 4172 : {

	sub	esp, 8

; 4173 : 	int iNumSites = GC.getGame().GetNumArchaeologySites();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	call	?GetNumArchaeologySites@CvGame@@QBEHXZ	; CvGame::GetNumArchaeologySites

; 4174 : 	double iMaxRatio = .5; //Ratio of archaeologists to sites
; 4175 : 	int iNumArchaeologists = pPlayer->GetNumUnitsWithUnitAI(UNITAI_ARCHAEOLOGIST, true);

	mov	esi, DWORD PTR _pPlayer$[esp+8]
	push	1
	push	1
	push	39					; 00000027H
	mov	ecx, esi
	mov	DWORD PTR _iNumSites$[esp+24], eax
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI

; 4176 : 	PolicyTypes eExpFinisher = (PolicyTypes) GC.getInfoTypeForString("POLICY_EXPLORATION_FINISHER", true /*bHideAssert*/);

	push	1
	push	OFFSET $SG228465
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iNumArchaeologists$[esp+20], eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4177 : 	
; 4178 : 	if (eExpFinisher != NO_POLICY)

	cmp	eax, -1
	je	SHORT $LN2@IsTestStra@25

; 4179 : 	{
; 4180 : 		if (pPlayer->GetPlayerPolicies()->HasPolicy(eExpFinisher))

	push	eax
	mov	ecx, esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	test	al, al
	je	SHORT $LN2@IsTestStra@25

; 4181 : 		{
; 4182 : 			iNumSites += GC.getGame().GetNumHiddenArchaeologySites();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetNumHiddenArchaeologySites@CvGame@@QBEHXZ ; CvGame::GetNumHiddenArchaeologySites
	add	DWORD PTR _iNumSites$[esp+12], eax
$LN2@IsTestStra@25:

; 4183 : 		}
; 4184 : 	}
; 4185 : 		
; 4186 : 	if ((double)iNumSites * iMaxRatio + 1 < iNumArchaeologists)

	fild	DWORD PTR _iNumSites$[esp+12]
	pop	esi
	fmul	QWORD PTR __real@3fe0000000000000
	fadd	QWORD PTR __real@3ff0000000000000
	fild	DWORD PTR _iNumArchaeologists$[esp+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@IsTestStra@25

; 4187 : 	{
; 4188 : 		return true;

	mov	al, 1

; 4192 : }

	add	esp, 8
	ret	0
$LN1@IsTestStra@25:

; 4189 : 	}
; 4190 : 
; 4191 : 	return false;

	xor	al, al

; 4192 : }

	add	esp, 8
	ret	0
?IsTestStrategy_EnoughArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_EnoughArchaeologists
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z PROC	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 156  : 	{

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx
	mov	BYTE PTR [esi+4], 0

; 157  : 		OBJECT_HANDLE_STACK;
; 158  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@2

; 159  : 		{
; 160  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@2:

; 161  : 		}
; 162  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ENDP	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@I$0A@@@QAEXXZ		; BaseVector<unsigned int,0>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?clear@?$BaseVector@I$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@I$0A@@@QAEXXZ PROC			; BaseVector<unsigned int,0>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@I$0A@@@QAEXXZ ENDP			; BaseVector<unsigned int,0>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::FStaticVector<CvPurchaseRequest,6,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvPurchaseRequest,6,1,297,0>::FStaticVector<CvPurchaseRequest,6,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 6
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvPurchaseRequest,6,1,297,0>::FStaticVector<CvPurchaseRequest,6,1,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@VCvPurchaseRequest@@$00@@QAEXXZ ; BaseVector<CvPurchaseRequest,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@VCvPurchaseRequest@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvPurchaseRequest@@$00@@QAEXXZ PROC ; BaseVector<CvPurchaseRequest,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvPurchaseRequest@@$00@@QAEXXZ ENDP ; BaseVector<CvPurchaseRequest,1>::clear
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@PAVCvUnit@@$0A@@@QAEXXZ	; BaseVector<CvUnit *,0>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@PAVCvUnit@@$0A@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@PAVCvUnit@@$0A@@@QAEXXZ PROC	; BaseVector<CvUnit *,0>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@PAVCvUnit@@$0A@@@QAEXXZ ENDP	; BaseVector<CvUnit *,0>::clear
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEAAPAVCvEconomicAIStrategyXMLEntry@@XZ ; std::_Vector_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEAAPAVCvEconomicAIStrategyXMLEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEAAPAVCvEconomicAIStrategyXMLEntry@@XZ PROC ; std::_Vector_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEAAPAVCvEconomicAIStrategyXMLEntry@@XZ ENDP ; std::_Vector_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QBEABQAVCvUnit@@I@Z ; CvWeightedVector<CvUnit *,50,1>::GetElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QBEABQAVCvUnit@@I@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QBEABQAVCvUnit@@I@Z PROC ; CvWeightedVector<CvUnit *,50,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QBEABQAVCvUnit@@I@Z ENDP ; CvWeightedVector<CvUnit *,50,1>::GetElement
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEHXZ ; CvWeightedVector<CvUnit *,50,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEHXZ PROC ; CvWeightedVector<CvUnit *,50,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEHXZ ENDP ; CvWeightedVector<CvUnit *,50,1>::size
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::~_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::~_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::~_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@1@@Z ; std::_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@1@@Z PROC ; std::_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@1@@Z ENDP ; std::_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	?Alloc@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEPAII@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEPAII@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEPAII@Z PROC ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 503  : 	T* Alloc( unsigned int uiSize ){

	push	esi

; 504  : 		if( uiSize > 0 ){

	mov	esi, DWORD PTR _uiSize$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jbe	SHORT $LN1@Alloc@3

; 505  :             
; 506  :             T* pRet = (T*)FAST_VEC_ALLOC::AllocAligned( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [esi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 507  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi

; 511  : 	};

	ret	4
$LN1@Alloc@3:
	pop	edi

; 508  : 			return pRet;
; 509  : 		}
; 510  : 		return NULL;

	xor	eax, eax
	pop	esi

; 511  : 	};

	ret	4
?Alloc@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEPAII@Z ENDP ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXPAII@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXPAII@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXPAII@Z PROC ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::Free, COMDAT
; _this$ = ecx

; 516  : 		if( !bPODType) 
; 517  :             Destroy(pVal, uiNumElements);
; 518  : 
; 519  : 		FAST_VEC_ALLOC::FreeAligned( (void*)pVal );

	mov	eax, DWORD PTR _pVal$[esp-4]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 520  : 	};

	ret	8
?Free@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXPAII@Z ENDP ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEPAHI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEPAHI@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEPAHI@Z PROC ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 503  : 	T* Alloc( unsigned int uiSize ){

	push	esi

; 504  : 		if( uiSize > 0 ){

	mov	esi, DWORD PTR _uiSize$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jbe	SHORT $LN1@Alloc@4

; 505  :             
; 506  :             T* pRet = (T*)FAST_VEC_ALLOC::AllocAligned( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [esi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 507  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi

; 511  : 	};

	ret	4
$LN1@Alloc@4:
	pop	edi

; 508  : 			return pRet;
; 509  : 		}
; 510  : 		return NULL;

	xor	eax, eax
	pop	esi

; 511  : 	};

	ret	4
?Alloc@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEPAHI@Z ENDP ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXPAHI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXPAHI@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXPAHI@Z PROC ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::Free, COMDAT
; _this$ = ecx

; 516  : 		if( !bPODType) 
; 517  :             Destroy(pVal, uiNumElements);
; 518  : 
; 519  : 		FAST_VEC_ALLOC::FreeAligned( (void*)pVal );

	mov	eax, DWORD PTR _pVal$[esp-4]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 520  : 	};

	ret	8
?Free@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXPAHI@Z ENDP ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z PROC ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 503  : 	T* Alloc( unsigned int uiSize ){

	push	esi

; 504  : 		if( uiSize > 0 ){

	mov	esi, DWORD PTR _uiSize$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jbe	SHORT $LN1@Alloc@5

; 505  :             
; 506  :             T* pRet = (T*)FAST_VEC_ALLOC::AllocAligned( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [esi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 507  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi

; 511  : 	};

	ret	4
$LN1@Alloc@5:
	pop	edi

; 508  : 			return pRet;
; 509  : 		}
; 510  : 		return NULL;

	xor	eax, eax
	pop	esi

; 511  : 	};

	ret	4
?Alloc@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z ENDP ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z PROC ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::Free, COMDAT
; _this$ = ecx

; 516  : 		if( !bPODType) 
; 517  :             Destroy(pVal, uiNumElements);
; 518  : 
; 519  : 		FAST_VEC_ALLOC::FreeAligned( (void*)pVal );

	mov	eax, DWORD PTR _pVal$[esp-4]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 520  : 	};

	ret	8
?Free@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z ENDP ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEXPAVCvPurchaseRequest@@I@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEXPAVCvPurchaseRequest@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEXPAVCvPurchaseRequest@@I@Z PROC ; FStaticVector<CvPurchaseRequest,6,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEXPAVCvPurchaseRequest@@I@Z ENDP ; FStaticVector<CvPurchaseRequest,6,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?Alloc@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEPAPAVCvUnit@@I@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEPAPAVCvUnit@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEPAPAVCvUnit@@I@Z PROC ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 503  : 	T* Alloc( unsigned int uiSize ){

	push	esi

; 504  : 		if( uiSize > 0 ){

	mov	esi, DWORD PTR _uiSize$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jbe	SHORT $LN1@Alloc@6

; 505  :             
; 506  :             T* pRet = (T*)FAST_VEC_ALLOC::AllocAligned( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [esi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 507  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi

; 511  : 	};

	ret	4
$LN1@Alloc@6:
	pop	edi

; 508  : 			return pRet;
; 509  : 		}
; 510  : 		return NULL;

	xor	eax, eax
	pop	esi

; 511  : 	};

	ret	4
?Alloc@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEPAPAVCvUnit@@I@Z ENDP ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXPAPAVCvUnit@@I@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXPAPAVCvUnit@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXPAPAVCvUnit@@I@Z PROC ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::Free, COMDAT
; _this$ = ecx

; 516  : 		if( !bPODType) 
; 517  :             Destroy(pVal, uiNumElements);
; 518  : 
; 519  : 		FAST_VEC_ALLOC::FreeAligned( (void*)pVal );

	mov	eax, DWORD PTR _pVal$[esp-4]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 520  : 	};

	ret	8
?Free@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXPAPAVCvUnit@@I@Z ENDP ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::Free
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvEconomicAIStrategyXMLEntry@@@Z ; std::_Vector_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Vector_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvEconomicAIStrategyXMLEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvEconomicAIStrategyXMLEntry@@@Z PROC ; std::_Vector_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Vector_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@PAPAVCvEconomicAIStrategyXMLEntry@@@Z ENDP ; std::_Vector_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Vector_iterator<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	?Alloc@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEPAHI@Z ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEPAHI@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEPAHI@Z PROC ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 503  : 	T* Alloc( unsigned int uiSize ){

	push	esi

; 504  : 		if( uiSize > 0 ){

	mov	esi, DWORD PTR _uiSize$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jbe	SHORT $LN1@Alloc@7

; 505  :             
; 506  :             T* pRet = (T*)FAST_VEC_ALLOC::AllocAligned( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [esi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 507  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi

; 511  : 	};

	ret	4
$LN1@Alloc@7:
	pop	edi

; 508  : 			return pRet;
; 509  : 		}
; 510  : 		return NULL;

	xor	eax, eax
	pop	esi

; 511  : 	};

	ret	4
?Alloc@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEPAHI@Z ENDP ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEXPAHI@Z ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEXPAHI@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEXPAHI@Z PROC ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::Free, COMDAT
; _this$ = ecx

; 516  : 		if( !bPODType) 
; 517  :             Destroy(pVal, uiNumElements);
; 518  : 
; 519  : 		FAST_VEC_ALLOC::FreeAligned( (void*)pVal );

	mov	eax, DWORD PTR _pVal$[esp-4]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 520  : 	};

	ret	8
?Free@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEXPAHI@Z ENDP ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::Free
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 50			; 00000032H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAEXXZ ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAEXXZ PROC ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAEXXZ ENDP ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::clear
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@@Z ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@@Z PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@@Z ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEIXZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAEPAPAVCvEconomicAIStrategyXMLEntry@@I@Z ; std::allocator<CvEconomicAIStrategyXMLEntry *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAEPAPAVCvEconomicAIStrategyXMLEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAEPAPAVCvEconomicAIStrategyXMLEntry@@I@Z PROC ; std::allocator<CvEconomicAIStrategyXMLEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvEconomicAIStrategyXMLEntry@@@std@@YAPAPAVCvEconomicAIStrategyXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvEconomicAIStrategyXMLEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@QAEPAPAVCvEconomicAIStrategyXMLEntry@@I@Z ENDP ; std::allocator<CvEconomicAIStrategyXMLEntry *>::allocate
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@2:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::Free
_TEXT	ENDS
PUBLIC	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z PROC ; operator>><bool>, COMDAT

; 516  : 	int i = 0;
; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	ebx

; 518  : 	ValueType * values = v.getArray();

	mov	ebx, DWORD PTR [eax]
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 519  : 	for(i = 0; i < count; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN14@operator@2
	push	ebp
	mov	ebp, DWORD PTR _loadFrom$[esp+12]
$LL3@operator@2:

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	lea	eax, DWORD PTR [ebx+esi]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL3@operator@2

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 524  : }

	ret	0
$LN14@operator@2:

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[esp+8]
	pop	edi
	pop	esi
	pop	ebx

; 524  : }

	ret	0
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ENDP ; operator>><bool>
_TEXT	ENDS
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 516  : 	int i = 0;
; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 518  : 	ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 519  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@3
	push	ebx
	mov	ebx, DWORD PTR _loadFrom$[esp+8]
$LL3@operator@3:

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	push	esi
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@3

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 524  : }

	ret	0
$LN14@operator@3:

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[esp+4]
	pop	edi
	pop	esi

; 524  : }

	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
_TEXT	ENDS
PUBLIC	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ; operator<<<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z PROC ; operator<<<bool>, COMDAT

; 503  : 	int i = 0;
; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	ebx

; 505  : 	const ValueType * values = v.getArray();

	mov	ebx, DWORD PTR [eax]
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 506  : 	for(i = 0; i < count; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN14@operator@4
	push	ebp
	mov	ebp, DWORD PTR _saveTo$[esp+12]
$LL3@operator@4:

; 507  : 	{
; 508  : 		saveTo << values[i];

	lea	eax, DWORD PTR [ebx+esi]
	push	eax
	mov	ecx, ebp
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL3@operator@4

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 511  : }

	ret	0
$LN14@operator@4:

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[esp+8]
	pop	edi
	pop	esi
	pop	ebx

; 511  : }

	ret	0
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ENDP ; operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z PROC ; operator<<<int>, COMDAT

; 503  : 	int i = 0;
; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 505  : 	const ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 506  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@5
	push	ebx
	mov	ebx, DWORD PTR _saveTo$[esp+8]
$LL3@operator@5:

; 507  : 	{
; 508  : 		saveTo << values[i];

	push	esi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@5

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 511  : }

	ret	0
$LN14@operator@5:

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[esp+4]
	pop	edi
	pop	esi

; 511  : }

	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvEconomicAIStrategyXMLEntry@@0AAV?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvEconomicAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvEconomicAIStrategyXMLEntry@@0AAV?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvEconomicAIStrategyXMLEntry@@0AAV?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvEconomicAIStrategyXMLEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@YAXPAPAVCvEconomicAIStrategyXMLEntry@@0AAV?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvEconomicAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ ; std::_Temp_iterator<CvPurchaseRequest>::~_Temp_iterator<CvPurchaseRequest>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ PROC ; std::_Temp_iterator<CvPurchaseRequest>::~_Temp_iterator<CvPurchaseRequest>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<CvPurchaseRequest>::~_Temp_iterator<CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??$_Distance@PAVCvPurchaseRequest@@H@std@@YAXPAVCvPurchaseRequest@@0AAH@Z ; std::_Distance<CvPurchaseRequest *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance@PAVCvPurchaseRequest@@H@std@@YAXPAVCvPurchaseRequest@@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@PAVCvPurchaseRequest@@H@std@@YAXPAVCvPurchaseRequest@@0AAH@Z PROC ; std::_Distance<CvPurchaseRequest *,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@PAVCvPurchaseRequest@@H@std@@YAXPAVCvPurchaseRequest@@0AAH@Z ENDP ; std::_Distance<CvPurchaseRequest *,int>
_TEXT	ENDS
PUBLIC	??$advance@PAVCvPurchaseRequest@@H@std@@YAXAAPAVCvPurchaseRequest@@H@Z ; std::advance<CvPurchaseRequest *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$advance@PAVCvPurchaseRequest@@H@std@@YAXAAPAVCvPurchaseRequest@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAVCvPurchaseRequest@@H@std@@YAXAAPAVCvPurchaseRequest@@H@Z PROC ; std::advance<CvPurchaseRequest *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAVCvPurchaseRequest@@H@std@@YAXAAPAVCvPurchaseRequest@@H@Z ENDP ; std::advance<CvPurchaseRequest *,int>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::iter_swap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvPurchaseRequest@@@std@@YA?AU?$pair@PAVCvPurchaseRequest@@H@0@H@Z ; std::get_temporary_buffer<CvPurchaseRequest>
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$get_temporary_buffer@VCvPurchaseRequest@@@std@@YA?AU?$pair@PAVCvPurchaseRequest@@H@0@H@Z
_TEXT	SEGMENT
$T234406 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T234410 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvPurchaseRequest@@@std@@YA?AU?$pair@PAVCvPurchaseRequest@@H@0@H@Z PROC ; std::get_temporary_buffer<CvPurchaseRequest>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor
$LL4@get_tempor:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	lea	edx, DWORD PTR [esi+esi*2]
	add	edx, edx
	add	edx, edx
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor
$LN15@get_tempor:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN5@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T234410[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T234406[esp+20]
	mov	DWORD PTR $T234410[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T234406[esp+20]
	push	ecx
	mov	DWORD PTR $T234406[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor:
$LN17@get_tempor:
	int	3
??$get_temporary_buffer@VCvPurchaseRequest@@@std@@YA?AU?$pair@PAVCvPurchaseRequest@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CvPurchaseRequest>::_Temp_iterator<CvPurchaseRequest>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<CvPurchaseRequest>::_Temp_iterator<CvPurchaseRequest>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<CvPurchaseRequest>::_Temp_iterator<CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAVCvPurchaseRequest@@PAV1@@std@@YAXPAVCvPurchaseRequest@@0@Z ; std::iter_swap<CvPurchaseRequest *,CvPurchaseRequest *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAVCvPurchaseRequest@@PAV1@@std@@YAXPAVCvPurchaseRequest@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAVCvPurchaseRequest@@PAV1@@std@@YAXPAVCvPurchaseRequest@@0@Z PROC ; std::iter_swap<CvPurchaseRequest *,CvPurchaseRequest *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap@2
	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	pop	edi
	pop	esi
	pop	ebx
$LN3@iter_swap@2:

; 595  : 	}

	ret	0
??$iter_swap@PAVCvPurchaseRequest@@PAV1@@std@@YAXPAVCvPurchaseRequest@@0@Z ENDP ; std::iter_swap<CvPurchaseRequest *,CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	jle	SHORT $LN10@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN10@Med3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN19@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3
	mov	edi, DWORD PTR [edx]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	pop	ebx
$LN19@Med3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN28@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN28@Med3:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	edx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	eax, esi
	push	edi
	mov	edi, edx
	jge	SHORT $LN14@Adjust_hea
	npad	7
$LL5@Adjust_hea:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [ecx+eax*8+4]
	cmp	ebx, DWORD PTR [ecx+eax*8-4]
	jle	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [ecx+edx*8+4], ebx
	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea
$LN14@Adjust_hea:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	edx, DWORD PTR [esi-1]
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	push	edi
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+24]
	push	edx
	push	ecx
	mov	DWORD PTR [eax+4], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@2
	push	esi
$LL8@unchecked_@2:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@2
	pop	esi
$LN7@unchecked_@2:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAVCvPurchaseRequest@@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvPurchaseRequest *,CvPurchaseRequest *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@PAVCvPurchaseRequest@@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAVCvPurchaseRequest@@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@00@Z PROC ; stdext::unchecked_copy_backward<CvPurchaseRequest *,CvPurchaseRequest *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@3
	push	esi
$LL8@unchecked_@3:
	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@3
	pop	esi
$LN7@unchecked_@3:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAVCvPurchaseRequest@@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@00@Z ENDP ; stdext::unchecked_copy_backward<CvPurchaseRequest *,CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@PAVCvPurchaseRequest@@PAV1@PAV1@@std@@YAPAVCvPurchaseRequest@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge_backward@PAVCvPurchaseRequest@@PAV1@PAV1@@std@@YAPAVCvPurchaseRequest@@PAV1@0000U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Merge_backward@PAVCvPurchaseRequest@@PAV1@PAV1@@std@@YAPAVCvPurchaseRequest@@PAV1@0000U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>, COMDAT

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	ecx, DWORD PTR __Last1$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	edx, DWORD PTR __Last2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __First1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __First2$[esp+8]
	cmp	esi, ecx
	je	SHORT $LN37@Merge_back
	npad	5
$LL8@Merge_back:

; 2714 : 		else if (_First2 == _Last2)

	cmp	edi, edx
	je	SHORT $LN38@Merge_back

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	ebx, DWORD PTR [edx-4]
	sub	edx, 12					; 0000000cH
	sub	ecx, 12					; 0000000cH

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	sub	eax, 12					; 0000000cH
	cmp	ebx, DWORD PTR [ecx+8]
	jle	SHORT $LN2@Merge_back
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	add	edx, 12					; 0000000cH

; 2718 : 		else

	jmp	SHORT $LN42@Merge_back
$LN2@Merge_back:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [edx+8]
	add	ecx, 12					; 0000000cH
$LN42@Merge_back:
	mov	DWORD PTR [eax+8], ebx
	cmp	esi, ecx
	jne	SHORT $LL8@Merge_back
$LN37@Merge_back:

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	ecx, edx
	cmp	edi, edx
	je	SHORT $LN7@Merge_back
$LL18@Merge_back:
	mov	edx, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	cmp	ecx, edi
	jne	SHORT $LL18@Merge_back
	pop	edi
	pop	esi
	pop	ebx

; 2720 : 	}

	ret	0
$LN38@Merge_back:

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	cmp	esi, ecx
	je	SHORT $LN7@Merge_back
$LL28@Merge_back:
	mov	edx, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	cmp	ecx, esi
	jne	SHORT $LL28@Merge_back
$LN7@Merge_back:
	pop	edi
	pop	esi
	pop	ebx

; 2720 : 	}

	ret	0
??$_Merge_backward@PAVCvPurchaseRequest@@PAV1@PAV1@@std@@YAPAVCvPurchaseRequest@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	??$_Lower_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvPurchaseRequest *,CvPurchaseRequest,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Lower_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Lower_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z PROC ; std::_Lower_bound<CvPurchaseRequest *,CvPurchaseRequest,int>, COMDAT

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;
; 2255 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN22@Lower_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+8]
$LL4@Lower_boun:

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2260 : 		_FwdIt _Mid = _First;
; 2261 : 		std::advance(_Mid, _Count2);

	lea	edx, DWORD PTR [eax+eax*2]

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	cmp	DWORD PTR [esi+edx*4+8], edi
	lea	edx, DWORD PTR [esi+edx*4]
	jle	SHORT $LN2@Lower_boun

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	esi, DWORD PTR [edx+12]
	or	edx, -1
	sub	edx, eax
	add	ecx, edx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2267 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Lower_boun:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Lower_boun
	pop	edi
$LN22@Lower_boun:

; 2268 : 		}
; 2269 : 	return (_First);

	mov	eax, esi
	pop	esi

; 2270 : 	}

	ret	0
??$_Lower_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z ENDP ; std::_Lower_bound<CvPurchaseRequest *,CvPurchaseRequest,int>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvPurchaseRequest *,CvPurchaseRequest,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Upper_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z PROC ; std::_Upper_bound<CvPurchaseRequest *,CvPurchaseRequest,int>, COMDAT

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;
; 2327 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN22@Upper_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+8]
$LL4@Upper_boun:

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2331 : 		_FwdIt _Mid = _First;
; 2332 : 		std::advance(_Mid, _Count2);

	lea	edx, DWORD PTR [eax+eax*2]

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	cmp	edi, DWORD PTR [esi+edx*4+8]
	lea	edx, DWORD PTR [esi+edx*4]
	jg	SHORT $LN2@Upper_boun

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	esi, DWORD PTR [edx+12]
	or	edx, -1
	sub	edx, eax
	add	ecx, edx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2338 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Upper_boun:

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Upper_boun
	pop	edi
$LN22@Upper_boun:

; 2339 : 		}
; 2340 : 	return (_First);

	mov	eax, esi
	pop	esi

; 2341 : 	}

	ret	0
??$_Upper_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z ENDP ; std::_Upper_bound<CvPurchaseRequest *,CvPurchaseRequest,int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvPurchaseRequest@@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@00@Z ; stdext::unchecked_copy<CvPurchaseRequest *,CvPurchaseRequest *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvPurchaseRequest@@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvPurchaseRequest@@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvPurchaseRequest *,CvPurchaseRequest *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@4
	push	esi
$LL9@unchecked_@4:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@4
	pop	esi
$LN7@unchecked_@4:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCvPurchaseRequest@@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvPurchaseRequest *,CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABVCvPurchaseRequest@@@Z ; std::_Temp_iterator<CvPurchaseRequest>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABVCvPurchaseRequest@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABVCvPurchaseRequest@@@Z PROC ; std::_Temp_iterator<CvPurchaseRequest>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	jae	SHORT $LN2@operator@6
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx
	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 12			; 0000000cH
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator@6:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	test	ecx, ecx
	je	SHORT $LN7@operator@6
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx
$LN7@operator@6:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 12			; 0000000cH
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABVCvPurchaseRequest@@@Z ENDP ; std::_Temp_iterator<CvPurchaseRequest>::operator=
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<CvPurchaseRequest *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<CvPurchaseRequest *>, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00PAH0@Z ; std::_Rotate<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, eax
	sar	ecx, 3
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	?GetID@CvUnit@@QBEHXZ				; CvUnit::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?GetID@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvUnit@@QBEHXZ PROC				; CvUnit::GetID, COMDAT
; _this$ = ecx

; 662  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+100]

; 663  : 	}

	ret	0
?GetID@CvUnit@@QBEHXZ ENDP				; CvUnit::GetID
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z ; CvUnit::isTerrainImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z PROC ; CvUnit::isTerrainImpassable, COMDAT
; _this$ = ecx

; 1125 : 		return m_terrainImpassableCount[eIndex] > 0;

	mov	eax, DWORD PTR [ecx+1996]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+edx*4], ecx
	setg	cl
	mov	al, cl

; 1126 : 	}

	ret	4
?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z ENDP ; CvUnit::isTerrainImpassable
_TEXT	ENDS
PUBLIC	?IsCombatUnit@CvUnit@@QBE_NXZ			; CvUnit::IsCombatUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsCombatUnit@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?IsCombatUnit@CvUnit@@QBE_NXZ PROC			; CvUnit::IsCombatUnit, COMDAT
; _this$ = ecx

; 1243 : 		return (m_iBaseCombat > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+1044], eax
	setg	al

; 1244 : 	}

	ret	0
?IsCombatUnit@CvUnit@@QBE_NXZ ENDP			; CvUnit::IsCombatUnit
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ	; CvPlot::getFeatureType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ
_TEXT	SEGMENT
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ PROC	; CvPlot::getFeatureType, COMDAT
; _this$ = ecx

; 435  : #ifdef AUI_WARNING_FIXES
; 436  : 		int f = m_eFeatureType;
; 437  : #else
; 438  : 		char f = m_eFeatureType;
; 439  : #endif
; 440  : 		return (FeatureTypes)f;

	movsx	eax, BYTE PTR [ecx+432]

; 441  : 	}

	ret	0
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ ENDP	; CvPlot::getFeatureType
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z	; CvMap::plotCheckInvalid
; Function compile flags: /Ogtpy
;	COMDAT ?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z PROC	; CvMap::plotCheckInvalid, COMDAT
; _this$ = ecx

; 282  : 	{

	push	esi

; 283  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	esi, DWORD PTR _iX$[esp]
	cmp	esi, -2147483647			; 80000001H
	je	SHORT $LN1@plotCheckI
	mov	edx, DWORD PTR _iY$[esp]
	cmp	edx, -2147483647			; 80000001H
	je	SHORT $LN1@plotCheckI

; 286  : 		}
; 287  : 		return &(m_pMapPlots[plotNum(iX, iY)]);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, edx
	add	eax, esi
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	pop	esi

; 288  : 	}

	ret	8
$LN1@plotCheckI:

; 284  : 		{
; 285  : 			return NULL;

	xor	eax, eax
	pop	esi

; 288  : 	}

	ret	8
?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z ENDP	; CvMap::plotCheckInvalid
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 194  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
$LN2@plotDirect:

; 197  : 	}
; 198  : 	else
; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Ogtpy
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN5@plotXY
	mov	eax, ecx
	jmp	SHORT $LN55@plotXY
$LN5@plotXY:
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
$LN55@plotXY:
	push	esi

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	esi, DWORD PTR _iX$[esp]
	sar	eax, 1
	sub	esi, eax

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iDY$[esp]
	add	esi, DWORD PTR _iDX$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+eax]

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	test	edi, edi
	jl	SHORT $LN9@plotXY
	mov	eax, edi
	jmp	SHORT $LN56@plotXY
$LN9@plotXY:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN56@plotXY:
	sar	eax, 1
	add	esi, eax

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN13@plotXY
	cmp	edi, -2147483647			; 80000001H
	je	$LN13@plotXY
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN23@plotXY
	test	esi, esi
	jge	SHORT $LN25@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN23@plotXY
$LN25@plotXY:
	cmp	esi, ecx
	jl	SHORT $LN23@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN23@plotXY:
	cmp	BYTE PTR [ebp+4057], 0
	push	ebx
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN52@plotXY
	test	edi, edi
	jge	SHORT $LN35@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@plotXY
$LN35@plotXY:
	cmp	edi, ebx
	jl	SHORT $LN52@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN37@plotXY
$LN52@plotXY:
	mov	edx, edi
$LN37@plotXY:
	test	esi, esi
	jl	SHORT $LN17@plotXY
	cmp	esi, ecx
	jge	SHORT $LN17@plotXY
	test	edx, edx
	jl	SHORT $LN17@plotXY
	cmp	edx, ebx
	jge	SHORT $LN17@plotXY
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebx
	pop	ebp
	pop	edi
	mov	eax, ecx
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN17@plotXY:
	pop	ebx
	pop	ebp
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN13@plotXY:
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
; Function compile flags: /Ogtpy
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iDX$[esp-4]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	test	esi, esi
	setge	cl
	cmp	eax, ecx

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	mov	ecx, edx
	jne	SHORT $LN3@plotXYWith
	test	edx, edx
	jge	SHORT $LN7@plotXYWith
	neg	ecx
$LN7@plotXYWith:

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN9@plotXYWith
	neg	eax
$LN9@plotXYWith:

; 245  : 		hexRange = iAbsDX + iAbsDY;

	add	eax, ecx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN14@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	edx, edx
	jge	SHORT $LN11@plotXYWith
	neg	ecx
$LN11@plotXYWith:

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN13@plotXYWith
	neg	eax
$LN13@plotXYWith:

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	ecx, eax
	jl	SHORT $LN14@plotXYWith
	mov	eax, ecx
$LN14@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	cmp	eax, DWORD PTR _iRange$[esp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	pop	esi

; 261  : }

	ret	0
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	eax, DWORD PTR _iX$[esp]
	push	esi
	push	edx
	mov	edx, DWORD PTR _iY$[esp+8]
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	pop	esi

; 261  : }

	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
_TEXT	ENDS
PUBLIC	??0CvEconomicAIStrategyXMLEntry@@QAE@XZ		; CvEconomicAIStrategyXMLEntry::CvEconomicAIStrategyXMLEntry
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ$0
__ehfuncinfo$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ??0CvEconomicAIStrategyXMLEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvEconomicAIStrategyXMLEntry@@QAE@XZ PROC		; CvEconomicAIStrategyXMLEntry::CvEconomicAIStrategyXMLEntry, COMDAT
; _this$ = ecx

; 43   : {

	push	-1
	push	__ehhandler$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	eax, eax
	or	ecx, -1
	mov	DWORD PTR [esi+280], ecx
	mov	DWORD PTR [esi+284], ecx
	mov	DWORD PTR [esi+300], ecx
	lea	ecx, DWORD PTR [esi+304]
	mov	DWORD PTR __$EHRec$[esp+28], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvEconomicAIStrategyXMLEntry@@6B@
	mov	DWORD PTR [esi+260], eax
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], eax
	mov	DWORD PTR [esi+272], eax
	mov	BYTE PTR [esi+276], al
	mov	DWORD PTR [esi+288], eax
	mov	DWORD PTR [esi+292], eax
	mov	DWORD PTR [esi+296], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 44   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR [esi+332], 1
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvEconomicAIStrategyXMLEntry@@QAE@XZ ENDP		; CvEconomicAIStrategyXMLEntry::CvEconomicAIStrategyXMLEntry
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvEconomicAIStrategyXMLEntry@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvEconomicAIStrategyXMLEntry@@UAEPAXI@Z PROC	; CvEconomicAIStrategyXMLEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvEconomicAIStrategyXMLEntry@@UAE@XZ	; CvEconomicAIStrategyXMLEntry::~CvEconomicAIStrategyXMLEntry
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvEconomicAIStrategyXMLEntry@@UAEPAXI@Z ENDP	; CvEconomicAIStrategyXMLEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Write@CvEconomicAI@@QAEXAAVFDataStream@@@Z	; CvEconomicAI::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvEconomicAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -12					; size = 4
$T235588 = -8						; size = 4
$T235413 = -8						; size = 8
tv547 = 8						; size = 4
$T235419 = 8						; size = 4
$T235418 = 8						; size = 4
$T235417 = 8						; size = 4
$T235416 = 8						; size = 4
$T235415 = 8						; size = 4
$T235412 = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvEconomicAI@@QAEXAAVFDataStream@@@Z PROC	; CvEconomicAI::Write, COMDAT
; _this$ = ecx

; 444  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi

; 447  : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+24]
	lea	eax, DWORD PTR _uiVersion$[esp+28]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+32], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 448  : 
; 449  : 	FAssertMsg(GC.getNumEconomicAIStrategyInfos() > 0, "Number of AIStrategies to serialize is expected to greater than 0");
; 450  : 	kStream << m_pAIStrategies->GetNumEconomicAIStrategies();

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	lea	edx, DWORD PTR $T235412[esp+24]
	sar	ecx, 2
	mov	DWORD PTR $T235412[esp+24], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 451  : 	kStream << ArrayWrapper<bool>(m_pAIStrategies->GetNumEconomicAIStrategies(), m_pabUsingStrategy);

	mov	eax, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR $T235413[esp+28]
	push	eax
	sar	edx, 2
	push	edi
	mov	DWORD PTR $T235413[esp+36], ecx
	mov	DWORD PTR $T235413[esp+40], edx
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ; operator<<<bool>

; 452  : 	kStream << ArrayWrapper<int>(m_pAIStrategies->GetNumEconomicAIStrategies(), m_paiTurnStrategyAdopted);

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [esi+16]
	sar	eax, 2
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN35@Write

; 445  : 	// Current version number
; 446  : 	uint uiVersion = 1;

	mov	ebp, eax

; 452  : 	kStream << ArrayWrapper<int>(m_pAIStrategies->GetNumEconomicAIStrategies(), m_paiTurnStrategyAdopted);

$LL37@Write:
	push	ebx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL37@Write
$LN35@Write:

; 453  : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	xor	ebx, ebx
	npad	7
$LL12@Write:

; 454  : 	{
; 455  : 		kStream << m_auiYields[ui];

	mov	ecx, DWORD PTR [esi+52]
	add	ecx, ebx
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	add	ebx, 4
	cmp	ebx, 24					; 00000018H
	jb	SHORT $LL12@Write

; 456  : 	}
; 457  : 
; 458  : 	kStream << m_bExplorationPlotsDirty;

	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 459  : 	kStream << m_aiExplorationPlots.size();

	mov	edx, DWORD PTR [esi+68]
	lea	eax, DWORD PTR $T235415[esp+24]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T235415[esp+28], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 460  : 	for(uint ui = 0; ui < m_aiExplorationPlots.size(); ui++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+68], ebx
	jbe	SHORT $LN7@Write
	npad	9
$LL9@Write:
	mov	ecx, DWORD PTR [esi+64]
	lea	ebp, DWORD PTR [ebx*4]
	add	ecx, ebp

; 461  : 	{
; 462  : 		kStream << m_aiExplorationPlots[ui];

	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	edx, DWORD PTR [esi+76]
	add	edx, ebp

; 463  : 		kStream << m_aiExplorationPlotRatings[ui];

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	ebx
	cmp	ebx, DWORD PTR [esi+68]
	jb	SHORT $LL9@Write
$LN7@Write:

; 464  : 	}
; 465  : 
; 466  : 	kStream << m_aiGoodyHutPlots.size();

	mov	eax, DWORD PTR [esi+92]
	lea	ecx, DWORD PTR $T235416[esp+24]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T235416[esp+28], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 467  : 	for(uint ui = 0; ui < m_aiGoodyHutPlots.size(); ui++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+92], ebx
	jbe	SHORT $LN4@Write
$LL6@Write:
	mov	edx, DWORD PTR [esi+88]
	lea	eax, DWORD PTR [edx+ebx*4]

; 468  : 	{
; 469  : 		kStream << m_aiGoodyHutPlots[ui];

	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	ecx, DWORD PTR [esi+100]
	lea	edx, DWORD PTR [ecx+ebx*8]

; 470  : 		kStream << m_aiGoodyHutUnitAssignments[ui].m_iUnitID;

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	ebx
	cmp	ebx, DWORD PTR [esi+92]
	jb	SHORT $LL6@Write
$LN4@Write:

; 471  : 	}
; 472  : 
; 473  : 	kStream << (int)m_eReconState;

	mov	eax, DWORD PTR [esi+28]
	lea	ecx, DWORD PTR $T235417[esp+24]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T235417[esp+28], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 474  : 	kStream << (int)m_eNavalReconState;

	mov	edx, DWORD PTR [esi+32]
	lea	eax, DWORD PTR $T235418[esp+24]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T235418[esp+28], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 475  : 	kStream << m_iExplorersDisbanded;

	lea	ecx, DWORD PTR [esi+36]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 476  : 	kStream << m_iLastTurnWorkerDisbanded;

	lea	edx, DWORD PTR [esi+40]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 477  : 	kStream << m_iVisibleAntiquitySites;

	lea	eax, DWORD PTR [esi+44]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 478  : 
; 479  : 	kStream << (int)m_RequestedSavings.size();

	mov	ecx, DWORD PTR [esi+116]
	lea	edx, DWORD PTR $T235419[esp+24]
	mov	DWORD PTR $T235419[esp+24], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 480  : 	for(uint ui = 0; ui < m_RequestedSavings.size(); ui++)

	xor	ebp, ebp
	cmp	DWORD PTR [esi+116], ebp
	jbe	SHORT $LN1@Write

; 471  : 	}
; 472  : 
; 473  : 	kStream << (int)m_eReconState;

	mov	DWORD PTR tv547[esp+24], ebp
	npad	8
$LL116@Write:

; 481  : 	{
; 482  : 		kStream << m_RequestedSavings[ui];

	mov	ebx, DWORD PTR [esi+112]
	add	ebx, DWORD PTR tv547[esp+24]
	lea	ecx, DWORD PTR $T235588[esp+28]
	mov	eax, DWORD PTR [ebx]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T235588[esp+32], eax
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	edx, DWORD PTR [ebx+4]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 8
	push	ebx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	DWORD PTR tv547[esp+24], 12		; 0000000cH
	inc	ebp
	cmp	ebp, DWORD PTR [esi+116]
	jb	SHORT $LL116@Write
$LN1@Write:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 483  : 	}
; 484  : }

	add	esp, 12					; 0000000cH
	ret	4
?Write@CvEconomicAI@@QAEXAAVFDataStream@@@Z ENDP	; CvEconomicAI::Write
_TEXT	ENDS
PUBLIC	?SetUsingStrategy@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@_N@Z ; CvEconomicAI::SetUsingStrategy
; Function compile flags: /Ogtpy
;	COMDAT ?SetUsingStrategy@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@_N@Z
_TEXT	SEGMENT
_eStrategy$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetUsingStrategy@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@_N@Z PROC ; CvEconomicAI::SetUsingStrategy, COMDAT
; _this$ = ecx

; 510  : {

	push	ebx

; 511  : 	if(m_pabUsingStrategy[eStrategy] != bValue)

	mov	ebx, DWORD PTR _bValue$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+12]
	push	edi
	mov	edi, DWORD PTR _eStrategy$[esp+8]
	add	eax, edi
	cmp	BYTE PTR [eax], bl
	je	SHORT $LN3@SetUsingSt

; 512  : 	{
; 513  : 		m_pabUsingStrategy[eStrategy] = bValue;

	mov	BYTE PTR [eax], bl

; 514  : 
; 515  : 		if(bValue)

	test	bl, bl
	je	SHORT $LN2@SetUsingSt

; 516  : 		{
; 517  : 			SetTurnStrategyAdopted(eStrategy, GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR [esi+16]
	cmp	DWORD PTR [ecx+edi*4], eax
	lea	ecx, DWORD PTR [ecx+edi*4]
	je	SHORT $LN11@SetUsingSt

; 522  : 		}
; 523  : 
; 524  : 		LogStrategy(eStrategy, bValue);

	push	ebx
	mov	DWORD PTR [ecx], eax
	push	edi
	mov	ecx, esi
	call	?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z ; CvEconomicAI::LogStrategy
	pop	edi
	pop	esi
	pop	ebx

; 525  : 	}
; 526  : }

	ret	8
$LN2@SetUsingSt:

; 518  : 		}
; 519  : 		else
; 520  : 		{
; 521  : 			SetTurnStrategyAdopted(eStrategy, -1);

	mov	edx, DWORD PTR [esi+16]
	cmp	DWORD PTR [edx+edi*4], -1
	lea	eax, DWORD PTR [edx+edi*4]
	je	SHORT $LN11@SetUsingSt
	mov	DWORD PTR [eax], -1
$LN11@SetUsingSt:

; 522  : 		}
; 523  : 
; 524  : 		LogStrategy(eStrategy, bValue);

	push	ebx
	push	edi
	mov	ecx, esi
	call	?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z ; CvEconomicAI::LogStrategy
$LN3@SetUsingSt:
	pop	edi
	pop	esi
	pop	ebx

; 525  : 	}
; 526  : }

	ret	8
?SetUsingStrategy@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@_N@Z ENDP ; CvEconomicAI::SetUsingStrategy
_TEXT	ENDS
PUBLIC	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ; CvEconomicAI::GetBestGreatWorkCity
EXTRN	?getDamage@CvCity@@QBEHXZ:PROC			; CvCity::getDamage
EXTRN	?HasAvailableGreatWorkSlot@CvPlayerCulture@@QAE_NW4GreatWorkSlotType@@@Z:PROC ; CvPlayerCulture::HasAvailableGreatWorkSlot
EXTRN	?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z:PROC ; CultureHelpers::GetGreatWorkSlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z
_TEXT	SEGMENT
_pBestCity$ = -4					; size = 4
_pStartPlot$ = 8					; size = 4
_iLoop$ = 12						; size = 4
_eGreatWork$ = 12					; size = 4
?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z PROC ; CvEconomicAI::GetBestGreatWorkCity, COMDAT
; _this$ = ecx

; 845  : {

	push	ecx

; 846  : 	CvCity* pBestCity = NULL;
; 847  : 	CvCity* pLoopCity;
; 848  : 	int iLoop;
; 849  : 	int iBestDistance = MAX_INT;
; 850  : 
; 851  : 	// Make sure there is an undamaged city with a Great Work slot
; 852  : 	GreatWorkSlotType eGreatWorkSlot = CultureHelpers::GetGreatWorkSlot(eGreatWork);

	mov	eax, DWORD PTR _eGreatWork$[esp]
	push	ebx
	push	ebp
	push	edi
	xor	ebp, ebp
	push	eax
	mov	ebx, ecx
	mov	DWORD PTR _pBestCity$[esp+20], ebp
	mov	edi, 2147483647				; 7fffffffH
	call	?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z ; CultureHelpers::GetGreatWorkSlot

; 853  : 	if (m_pPlayer->GetCulture()->HasAvailableGreatWorkSlot(eGreatWorkSlot))

	mov	ecx, DWORD PTR [ebx+4]
	add	esp, 4
	push	eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?HasAvailableGreatWorkSlot@CvPlayerCulture@@QAE_NW4GreatWorkSlotType@@@Z ; CvPlayerCulture::HasAvailableGreatWorkSlot
	test	al, al
	je	SHORT $LN24@GetBestGre
	push	esi

; 854  : 	{
; 855  : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	ebp
	lea	ecx, DWORD PTR _iLoop$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR [ebx+4]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN23@GetBestGre
	mov	ebp, DWORD PTR _pStartPlot$[esp+16]
	npad	5
$LL5@GetBestGre:

; 856  : 		{
; 857  : 			if (pLoopCity->getDamage() == 0)

	mov	ecx, esi
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	test	eax, eax
	jne	SHORT $LN4@GetBestGre

; 858  : 			{
; 859  : 				int iDistance = plotDistance(pStartPlot->getX(), pStartPlot->getY(), pLoopCity->getX(), pLoopCity->getY());

	mov	edx, DWORD PTR [esi+108]
	mov	eax, DWORD PTR [esi+96]
	movsx	ecx, WORD PTR [ebp+2]
	push	edx
	movsx	edx, WORD PTR [ebp]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 860  : 				if(iDistance < iBestDistance)

	cmp	eax, edi
	jge	SHORT $LN4@GetBestGre

; 861  : 				{
; 862  : 					iBestDistance = iDistance;

	mov	edi, eax

; 863  : 					pBestCity = pLoopCity;

	mov	DWORD PTR _pBestCity$[esp+20], esi
$LN4@GetBestGre:
	mov	ecx, DWORD PTR [ebx+4]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+20]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL5@GetBestGre

; 864  : 				}
; 865  : 			}
; 866  : 		}
; 867  : 	}
; 868  : 
; 869  : 	return pBestCity;

	mov	eax, DWORD PTR _pBestCity$[esp+20]
	pop	esi
	pop	edi
	pop	ebp
	pop	ebx

; 870  : }

	pop	ecx
	ret	8
$LN23@GetBestGre:
	pop	esi
	pop	edi

; 864  : 				}
; 865  : 			}
; 866  : 		}
; 867  : 	}
; 868  : 
; 869  : 	return pBestCity;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 870  : }

	pop	ecx
	ret	8
$LN24@GetBestGre:
	pop	edi

; 864  : 				}
; 865  : 			}
; 866  : 		}
; 867  : 	}
; 868  : 
; 869  : 	return pBestCity;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 870  : }

	pop	ecx
	ret	8
?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ENDP ; CvEconomicAI::GetBestGreatWorkCity
_TEXT	ENDS
PUBLIC	?ClearUnitTargetGoodyStepPlot@CvEconomicAI@@QAEXPAVCvUnit@@@Z ; CvEconomicAI::ClearUnitTargetGoodyStepPlot
; Function compile flags: /Ogtpy
;	COMDAT ?ClearUnitTargetGoodyStepPlot@CvEconomicAI@@QAEXPAVCvUnit@@@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
?ClearUnitTargetGoodyStepPlot@CvEconomicAI@@QAEXPAVCvUnit@@@Z PROC ; CvEconomicAI::ClearUnitTargetGoodyStepPlot, COMDAT
; _this$ = ecx

; 970  : 	int iUnitID = pUnit->GetID();

	mov	eax, DWORD PTR _pUnit$[esp-4]
	push	esi
	mov	esi, DWORD PTR [eax+100]

; 971  : 	for(uint ui = 0; ui < m_aiGoodyHutUnitAssignments.size(); ui++)

	xor	eax, eax
	cmp	DWORD PTR [ecx+104], eax
	jbe	SHORT $LN2@ClearUnitT
	npad	1
$LL4@ClearUnitT:
	mov	edx, DWORD PTR [ecx+100]

; 972  : 	{
; 973  : 		if(iUnitID == m_aiGoodyHutUnitAssignments[ui].m_iUnitID)

	cmp	esi, DWORD PTR [edx+eax*8]
	lea	edx, DWORD PTR [edx+eax*8]
	jne	SHORT $LN3@ClearUnitT

; 974  : 		{
; 975  : 			m_aiGoodyHutUnitAssignments[ui].m_iStepPlotID = -1;

	mov	DWORD PTR [edx+4], -1
$LN3@ClearUnitT:

; 971  : 	for(uint ui = 0; ui < m_aiGoodyHutUnitAssignments.size(); ui++)

	inc	eax
	cmp	eax, DWORD PTR [ecx+104]
	jb	SHORT $LL4@ClearUnitT
$LN2@ClearUnitT:
	pop	esi

; 976  : 		}
; 977  : 	}
; 978  : }

	ret	4
?ClearUnitTargetGoodyStepPlot@CvEconomicAI@@QAEXPAVCvUnit@@@Z ENDP ; CvEconomicAI::ClearUnitTargetGoodyStepPlot
_TEXT	ENDS
PUBLIC	?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z ; CvEconomicAI::ScoreExplorePlot
EXTRN	?getSeeThroughChange@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getSeeThroughChange
EXTRN	?isImpassable@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isImpassable
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z:PROC ; CvPlot::canSeePlot
EXTRN	?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isAdjacentRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z
_TEXT	SEGMENT
_iResultValue$ = -32					; size = 4
_iPlotY$ = -28						; size = 4
_iPlotX$ = -24						; size = 4
_iY$226506 = -20					; size = 4
tv590 = -16						; size = 4
tv566 = -12						; size = 4
tv395 = -8						; size = 4
tv391 = -4						; size = 4
_pPlot$ = 8						; size = 4
_eTeam$ = 12						; size = 4
_iX$226502 = 16						; size = 4
_iRange$ = 16						; size = 4
_eDomainType$ = 20					; size = 4
?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z PROC ; CvEconomicAI::ScoreExplorePlot, COMDAT

; 982  : {

	sub	esp, 32					; 00000020H

; 983  : 	int iResultValue = 0;
; 984  : 	int iAdjacencyBonus = 1;
; 985  : 	int iBadScore = 10;
; 986  : 	int iGoodScore = 100;
; 987  : 	int iReallyGoodScore = 200;
; 988  : 	//int iGoodyHutScore = 100000;
; 989  : 
; 990  : 	int iPlotX = pPlot->getX();

	mov	eax, DWORD PTR _pPlot$[esp+28]
	movsx	edx, WORD PTR [eax]

; 991  : 	int iPlotY = pPlot->getY();

	movsx	eax, WORD PTR [eax+2]
	push	ebx

; 992  : 
; 993  : 	FAssertMsg(pPlot->isRevealed(eTeam), "Plot isn't revealed. This isn't good.");
; 994  : 	CvPlot* pEvalPlot = NULL;
; 995  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 996  : 	int iMaxDX, iX;
; 997  : 	for (int iY = -iRange; iY <= iRange; iY++)
; 998  : 	{
; 999  : 		iMaxDX = iRange - MAX(0, iY);
; 1000 : 		for (iX = -iRange - MIN(0, iY); iX <= iMaxDX; iX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1001 : 		{
; 1002 : 			// No need for range check because loops are set up properly
; 1003 : 			pEvalPlot = plotXY(iPlotX, iPlotY, iX, iY);
; 1004 : #else
; 1005 : 	for(int iX = -iRange; iX <= iRange; iX++)

	mov	ebx, DWORD PTR _iRange$[esp+32]
	push	ebp
	mov	ebp, ebx
	neg	ebp
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	cmp	edi, ebx
	mov	DWORD PTR _iResultValue$[esp+44], ecx
	mov	DWORD PTR _iPlotX$[esp+44], edx
	mov	DWORD PTR _iPlotY$[esp+44], eax
	mov	DWORD PTR tv391[esp+44], ebp
	mov	DWORD PTR _iX$226502[esp+40], edi
	jg	$LN107@ScoreExplo
	push	esi
	mov	esi, edi
	neg	esi
	mov	DWORD PTR tv590[esp+48], esi
$LL117@ScoreExplo:

; 1006 : 	{
; 1007 : 		for(int iY = -iRange; iY <= iRange; iY++)

	cmp	ebp, ebx
	mov	DWORD PTR _iY$226506[esp+48], ebp
	jg	$LN35@ScoreExplo

; 1008 : 		{
; 1009 : 			pEvalPlot = plotXYWithRangeCheck(iPlotX, iPlotY, iX, iY, iRange);

	xor	ecx, ecx
	test	edi, edi
	setge	cl
	mov	eax, ebp
	neg	eax
	mov	DWORD PTR tv566[esp+48], eax
	mov	DWORD PTR tv395[esp+48], ecx
$LL33@ScoreExplo:
	xor	edx, edx
	test	ebp, ebp
	setge	dl
	mov	ecx, edi
	cmp	DWORD PTR tv395[esp+48], edx
	jne	SHORT $LN45@ScoreExplo
	test	edi, edi
	jge	SHORT $LN49@ScoreExplo
	mov	ecx, esi
$LN49@ScoreExplo:
	test	ebp, ebp
	jl	SHORT $LN50@ScoreExplo
	mov	eax, ebp
$LN50@ScoreExplo:
	add	eax, ecx
	jmp	SHORT $LN56@ScoreExplo
$LN45@ScoreExplo:
	test	edi, edi
	jge	SHORT $LN53@ScoreExplo
	mov	ecx, esi
$LN53@ScoreExplo:
	test	ebp, ebp
	jl	SHORT $LN54@ScoreExplo
	mov	eax, ebp
$LN54@ScoreExplo:
	cmp	ecx, eax
	jl	SHORT $LN56@ScoreExplo
	mov	eax, ecx
$LN56@ScoreExplo:
	cmp	eax, ebx
	jg	$LN32@ScoreExplo
	mov	eax, DWORD PTR _iPlotY$[esp+48]
	mov	ecx, DWORD PTR _iPlotX$[esp+48]
	push	ebp
	push	edi
	push	eax
	push	ecx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	esi, eax
	add	esp, 16					; 00000010H

; 1010 : #endif
; 1011 : 			if(!pEvalPlot)

	test	esi, esi
	je	$LN32@ScoreExplo

; 1012 : 			{
; 1013 : 				continue;
; 1014 : 			}
; 1015 : 
; 1016 : 			if(pEvalPlot == pPlot)

	cmp	esi, DWORD PTR _pPlot$[esp+44]
	je	$LN32@ScoreExplo

; 1017 : 			{
; 1018 : 				continue;
; 1019 : 			}
; 1020 : 
; 1021 : 			if(pEvalPlot->isRevealed(eTeam))

	mov	eax, DWORD PTR _eTeam$[esp+44]
	mov	edi, eax
	shr	edi, 5
	mov	edx, edi
	shl	edx, 5
	mov	ecx, eax
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [esi+edi*4+8]
	jne	$LN114@ScoreExplo

; 1022 : 			{
; 1023 : 				continue;
; 1024 : 			}
; 1025 : 
; 1026 : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 1027 : 			int iMainDistance = hexDistance(iX, iY);
; 1028 : #endif
; 1029 : 			if(pEvalPlot->isAdjacentRevealed(eTeam))

	push	eax
	mov	ecx, esi
	call	?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentRevealed
	test	al, al
	je	$LN27@ScoreExplo

; 1030 : 			{
; 1031 : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 1032 : 				if (iMainDistance > 1)
; 1033 : #else
; 1034 : 				if(plotDistance(iPlotX, iPlotY, pEvalPlot->getX(), pEvalPlot->getY()) > 1)

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	mov	edx, DWORD PTR _iPlotY$[esp+48]
	push	eax
	mov	eax, DWORD PTR _iPlotX$[esp+52]
	push	ecx
	push	edx
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jle	$LN17@ScoreExplo

; 1035 : #endif
; 1036 : 				{
; 1037 : 					CvPlot* pAdjacentPlot;
; 1038 : 					bool bViewBlocked = true;
; 1039 : 					for(int i = 0; i < NUM_DIRECTION_TYPES; ++i)

	xor	ebp, ebp
	npad	5
$LL25@ScoreExplo:

; 1040 : 					{
; 1041 : 						pAdjacentPlot = plotDirection(pEvalPlot->getX(), pEvalPlot->getY(), ((DirectionTypes)i));

	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	push	ebp
	push	ecx
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 1042 : 						if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN24@ScoreExplo

; 1043 : 						{
; 1044 : 							if(pAdjacentPlot->isRevealed(eTeam))

	mov	ecx, edi
	shl	ecx, 5
	mov	edx, ecx
	mov	ecx, DWORD PTR _eTeam$[esp+44]
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [eax+edi*4+8]
	je	SHORT $LN24@ScoreExplo

; 1045 : 							{
; 1046 : 								int iDistance = plotDistance(iPlotX, iPlotY, pAdjacentPlot->getX(), pAdjacentPlot->getY());
; 1047 : 								if(iDistance > iRange)

	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	mov	eax, DWORD PTR _iPlotY$[esp+48]
	push	ecx
	mov	ecx, DWORD PTR _iPlotX$[esp+52]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, ebx
	jg	SHORT $LN24@ScoreExplo

; 1048 : 								{
; 1049 : 									continue;
; 1050 : 								}
; 1051 : 
; 1052 : 								// this cheats, because we can't be sure that between the target and the viewer
; 1053 : 								if(pPlot->canSeePlot(pEvalPlot, eTeam, iRange, NO_DIRECTION))

	mov	edx, DWORD PTR _eTeam$[esp+44]
	mov	ecx, DWORD PTR _pPlot$[esp+44]
	push	-1
	push	ebx
	push	edx
	push	esi
	call	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z ; CvPlot::canSeePlot
	test	al, al
	jne	SHORT $LN108@ScoreExplo
$LN24@ScoreExplo:

; 1035 : #endif
; 1036 : 				{
; 1037 : 					CvPlot* pAdjacentPlot;
; 1038 : 					bool bViewBlocked = true;
; 1039 : 					for(int i = 0; i < NUM_DIRECTION_TYPES; ++i)

	inc	ebp
	cmp	ebp, 6
	jl	SHORT $LL25@ScoreExplo

; 1112 : 			}
; 1113 : 
; 1114 : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 1115 : 			iResultValue += (iRange - iMainDistance) * iAdjacencyBonus;
; 1116 : #else
; 1117 : 			int iDistance = plotDistance(iPlotX, iPlotY, pEvalPlot->getX(), pEvalPlot->getY());
; 1118 : 			iResultValue += (iRange - iDistance) * iAdjacencyBonus;

	mov	ebp, DWORD PTR _iY$226506[esp+48]
$LN114@ScoreExplo:
	mov	edi, DWORD PTR _iX$226502[esp+44]
$LN32@ScoreExplo:

; 1006 : 	{
; 1007 : 		for(int iY = -iRange; iY <= iRange; iY++)

	mov	eax, DWORD PTR tv566[esp+48]
	mov	esi, DWORD PTR tv590[esp+48]
	inc	ebp
	dec	eax
	cmp	ebp, ebx
	mov	DWORD PTR _iY$226506[esp+48], ebp
	mov	DWORD PTR tv566[esp+48], eax
	jle	$LL33@ScoreExplo
	mov	ebp, DWORD PTR tv391[esp+48]
$LN35@ScoreExplo:

; 992  : 
; 993  : 	FAssertMsg(pPlot->isRevealed(eTeam), "Plot isn't revealed. This isn't good.");
; 994  : 	CvPlot* pEvalPlot = NULL;
; 995  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 996  : 	int iMaxDX, iX;
; 997  : 	for (int iY = -iRange; iY <= iRange; iY++)
; 998  : 	{
; 999  : 		iMaxDX = iRange - MAX(0, iY);
; 1000 : 		for (iX = -iRange - MIN(0, iY); iX <= iMaxDX; iX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1001 : 		{
; 1002 : 			// No need for range check because loops are set up properly
; 1003 : 			pEvalPlot = plotXY(iPlotX, iPlotY, iX, iY);
; 1004 : #else
; 1005 : 	for(int iX = -iRange; iX <= iRange; iX++)

	inc	edi
	dec	esi
	cmp	edi, ebx
	mov	DWORD PTR _iX$226502[esp+44], edi
	mov	DWORD PTR tv590[esp+48], esi
	jle	$LL117@ScoreExplo

; 1119 : #endif
; 1120 : 		}
; 1121 : 	}
; 1122 : 
; 1123 : 	return iResultValue;

	mov	eax, DWORD PTR _iResultValue$[esp+48]
	pop	esi
	pop	edi
	pop	ebp
	pop	ebx

; 1124 : }

	add	esp, 32					; 00000020H
	ret	0
$LN108@ScoreExplo:

; 1035 : #endif
; 1036 : 				{
; 1037 : 					CvPlot* pAdjacentPlot;
; 1038 : 					bool bViewBlocked = true;
; 1039 : 					for(int i = 0; i < NUM_DIRECTION_TYPES; ++i)

	mov	ebp, DWORD PTR _iY$226506[esp+48]
$LN17@ScoreExplo:

; 1054 : 								{
; 1055 : 									bViewBlocked = false;
; 1056 : 								}
; 1057 : 
; 1058 : 								if(!bViewBlocked)
; 1059 : 								{
; 1060 : 									break;
; 1061 : 								}
; 1062 : 							}
; 1063 : 						}
; 1064 : 					}
; 1065 : 
; 1066 : 					if(bViewBlocked)
; 1067 : 					{
; 1068 : 						continue;
; 1069 : 					}
; 1070 : 				}
; 1071 : 
; 1072 : 				// "cheating" to look to see what the next tile is.
; 1073 : 				// a human should be able to do this by looking at the transition from the tile to the next
; 1074 : 				switch(eDomainType)

	mov	eax, DWORD PTR _eDomainType$[esp+44]
	sub	eax, 0
	je	SHORT $LN14@ScoreExplo
	sub	eax, 2
	jne	SHORT $LN113@ScoreExplo

; 1090 : 					}
; 1091 : 				}
; 1092 : 				break;
; 1093 : 				case DOMAIN_LAND:
; 1094 : 					if(pEvalPlot->isMountain() || pEvalPlot->isWater())

	mov	al, BYTE PTR [esi+5]
	test	al, al
	je	SHORT $LN12@ScoreExplo
	cmp	al, 3
	je	SHORT $LN12@ScoreExplo

; 1095 : 					{
; 1096 : 						iResultValue += iBadScore;
; 1097 : 					}
; 1098 : 					else if(pEvalPlot->isHills())

	cmp	al, 1
	jne	SHORT $LN27@ScoreExplo

; 1099 : 					{
; 1100 : 						iResultValue += iReallyGoodScore;

	add	DWORD PTR _iResultValue$[esp+48], 200	; 000000c8H

; 1101 : 					}
; 1102 : 					else
; 1103 : 					{
; 1104 : 						iResultValue += iGoodScore;

	jmp	SHORT $LN113@ScoreExplo
$LN14@ScoreExplo:

; 1075 : 				{
; 1076 : 				case DOMAIN_SEA:
; 1077 : 				{
; 1078 : 					FeatureTypes eFeature = pEvalPlot->getFeatureType();
; 1079 : 					if(pEvalPlot->isWater() || (eFeature != NO_FEATURE && GC.getFeatureInfo(eFeature)->isImpassable()))

	cmp	BYTE PTR [esi+5], 3
	movsx	edi, BYTE PTR [esi+432]
	je	SHORT $LN12@ScoreExplo
	cmp	edi, -1
	je	SHORT $LN109@ScoreExplo
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?isImpassable@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isImpassable
	test	al, al
	jne	SHORT $LN12@ScoreExplo
$LN109@ScoreExplo:

; 1082 : 					}
; 1083 : 					else if(pEvalPlot->isMountain() || pEvalPlot->isHills() || (eFeature != NO_FEATURE && GC.getFeatureInfo(eFeature)->getSeeThroughChange() > 0))

	mov	al, BYTE PTR [esi+5]
	test	al, al
	je	SHORT $LN27@ScoreExplo
	cmp	al, 1
	je	SHORT $LN27@ScoreExplo
	cmp	edi, -1
	je	SHORT $LN10@ScoreExplo
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getSeeThroughChange@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getSeeThroughChange
	test	eax, eax
	jg	SHORT $LN27@ScoreExplo
$LN10@ScoreExplo:

; 1088 : 					{
; 1089 : 						iResultValue += iReallyGoodScore;

	add	DWORD PTR _iResultValue$[esp+48], 200	; 000000c8H

; 1084 : 					{
; 1085 : 						iResultValue += iGoodScore;
; 1086 : 					}
; 1087 : 					else

	jmp	SHORT $LN113@ScoreExplo
$LN12@ScoreExplo:

; 1080 : 					{
; 1081 : 						iResultValue += iBadScore;

	add	DWORD PTR _iResultValue$[esp+48], 10	; 0000000aH

; 1105 : 					}
; 1106 : 					break;
; 1107 : 				}
; 1108 : 			}
; 1109 : 			else

	jmp	SHORT $LN113@ScoreExplo
$LN27@ScoreExplo:

; 1110 : 			{
; 1111 : 				iResultValue += iGoodScore;

	add	DWORD PTR _iResultValue$[esp+48], 100	; 00000064H
$LN113@ScoreExplo:

; 1112 : 			}
; 1113 : 
; 1114 : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 1115 : 			iResultValue += (iRange - iMainDistance) * iAdjacencyBonus;
; 1116 : #else
; 1117 : 			int iDistance = plotDistance(iPlotX, iPlotY, pEvalPlot->getX(), pEvalPlot->getY());
; 1118 : 			iResultValue += (iRange - iDistance) * iAdjacencyBonus;

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	mov	edx, DWORD PTR _iPlotY$[esp+48]
	push	eax
	mov	eax, DWORD PTR _iPlotX$[esp+52]
	push	ecx
	push	edx
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	mov	ecx, ebx
	sub	ecx, eax
	add	esp, 16					; 00000010H
	add	DWORD PTR _iResultValue$[esp+48], ecx
	jmp	$LN114@ScoreExplo
$LN107@ScoreExplo:
	pop	edi
	pop	ebp

; 1119 : #endif
; 1120 : 		}
; 1121 : 	}
; 1122 : 
; 1123 : 	return iResultValue;

	mov	eax, ecx
	pop	ebx

; 1124 : }

	add	esp, 32					; 00000020H
	ret	0
?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z ENDP ; CvEconomicAI::ScoreExplorePlot
_TEXT	ENDS
PUBLIC	?DoReconState@CvEconomicAI@@AAEXXZ		; CvEconomicAI::DoReconState
EXTRN	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z:PROC ; CvHomelandAI::LogHomelandMessage
EXTRN	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ:PROC ; CvPlayer::GetHomelandAI
EXTRN	?getName@CvUnit@@QBE?BVCvString@@XZ:PROC	; CvUnit::getName
EXTRN	?AI_setUnitAIType@CvUnit@@QAEXW4UnitAITypes@@@Z:PROC ; CvUnit::AI_setUnitAIType
EXTRN	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetUnitAIType
EXTRN	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ:PROC	; CvUnit::getUnitInfo
EXTRN	_sqrt:PROC
EXTRN	?isShallowWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isShallowWater
EXTRN	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ:PROC	; CvTeam::canEmbarkAllWaterPassage
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	__ftol2_sse_excpt:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?DoReconState@CvEconomicAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$3
__ehfuncinfo$?DoReconState@CvEconomicAI@@AAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?DoReconState@CvEconomicAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?DoReconState@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
_bNeedToLookAtDeepWaterAlso$ = -157			; size = 1
tv806 = -156						; size = 4
tv804 = -156						; size = 4
_iPlotLoop$ = -156					; size = 4
_iUnitLoop$ = -152					; size = 4
_iNumLandPlotsRevealed$ = -148				; size = 4
_iNumCoastalTilesWithAdjacentFog$ = -144		; size = 4
tv952 = -140						; size = 4
_iNumCoastalTilesRevealed$ = -136			; size = 4
_iNumLandPlotsWithAdjacentFog$ = -132			; size = 4
_iCityLoop$ = -128					; size = 4
_strLogString$227234 = -124				; size = 28
_strLogString$227205 = -96				; size = 28
$T235814 = -68						; size = 28
$T235815 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?DoReconState@CvEconomicAI@@AAEXXZ PROC			; CvEconomicAI::DoReconState, COMDAT
; _this$ = ecx

; 1964 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DoReconState@CvEconomicAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 148				; 00000094H
	push	edi
	mov	edi, ecx

; 1965 : #ifdef AUI_WARNING_FIXES
; 1966 : 	uint iPlotLoop;
; 1967 : 	int iDirectionLoop, iUnitLoop;
; 1968 : #else
; 1969 : 	int iPlotLoop, iDirectionLoop, iUnitLoop;
; 1970 : #endif
; 1971 : 	CvPlot* pPlot;
; 1972 : 	CvPlot* pAdjacentPlot;
; 1973 : 	CvUnit* pLoopUnit;
; 1974 : 	bool bIsLand;
; 1975 : 	bool bIsCoastalWater;
; 1976 : 
; 1977 : 	if(GetPlayer()->isMinorCiv())

	mov	ecx, DWORD PTR [edi+4]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN48@DoReconSta

; 1978 : 	{
; 1979 : 		m_eReconState = RECON_STATE_ENOUGH;

	xor	eax, eax
	mov	DWORD PTR [edi+28], eax

; 1980 : 		m_eNavalReconState = RECON_STATE_ENOUGH;

	mov	DWORD PTR [edi+32], eax
	pop	edi

; 2179 : 						}
; 2180 : 					}
; 2181 : 				}
; 2182 : 			}
; 2183 : 		}
; 2184 : 	}
; 2185 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+160]
	mov	DWORD PTR fs:0, ecx
	add	esp, 160				; 000000a0H
	ret	0
$LN48@DoReconSta:

; 1981 : 		return;
; 1982 : 	}
; 1983 : 
; 1984 : 	// Start at 1 so we don't get divide-by-0 errors
; 1985 : 	//   Land recon counters
; 1986 : 	int iNumLandPlotsRevealed = 1;
; 1987 : 	int iNumLandPlotsWithAdjacentFog = 1;
; 1988 : 
; 1989 : 	//   Naval recon counters
; 1990 : 	int iNumCoastalTilesRevealed = 1;
; 1991 : 	int iNumCoastalTilesWithAdjacentFog = 1;
; 1992 : 
; 1993 : 	bool bNeedToLookAtDeepWaterAlso = GET_TEAM(m_pPlayer->getTeam()).canEmbarkAllWaterPassage();

	mov	eax, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [eax+44]
	push	esi
	mov	esi, 1
	mov	DWORD PTR _iNumLandPlotsRevealed$[esp+168], esi
	mov	DWORD PTR _iNumLandPlotsWithAdjacentFog$[esp+168], esi
	mov	DWORD PTR _iNumCoastalTilesRevealed$[esp+168], esi
	mov	DWORD PTR _iNumCoastalTilesWithAdjacentFog$[esp+168], esi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN61@DoReconSta
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN62@DoReconSta
$LN61@DoReconSta:
	or	eax, -1
$LN62@DoReconSta:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebx
	push	ebp
	mov	ecx, eax
	call	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ ; CvTeam::canEmbarkAllWaterPassage

; 1994 : 
; 1995 : 	// Look at map size and gauge how much of it we know about
; 1996 : 	for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	BYTE PTR _bNeedToLookAtDeepWaterAlso$[esp+176], al
	mov	eax, DWORD PTR [ecx+4028]
	xor	edx, edx
	cmp	eax, edx
	mov	DWORD PTR _iPlotLoop$[esp+176], edx
	jle	$LN45@DoReconSta

; 1981 : 		return;
; 1982 : 	}
; 1983 : 
; 1984 : 	// Start at 1 so we don't get divide-by-0 errors
; 1985 : 	//   Land recon counters
; 1986 : 	int iNumLandPlotsRevealed = 1;
; 1987 : 	int iNumLandPlotsWithAdjacentFog = 1;
; 1988 : 
; 1989 : 	//   Naval recon counters
; 1990 : 	int iNumCoastalTilesRevealed = 1;
; 1991 : 	int iNumCoastalTilesWithAdjacentFog = 1;
; 1992 : 
; 1993 : 	bool bNeedToLookAtDeepWaterAlso = GET_TEAM(m_pPlayer->getTeam()).canEmbarkAllWaterPassage();

	mov	DWORD PTR tv952[esp+176], edx
$LL191@DoReconSta:

; 1997 : 	{
; 1998 : 		pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
; 1999 : 
; 2000 : 		if(pPlot->isRevealed(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR [edi+4]
	mov	ebp, DWORD PTR [ecx+4068]
	mov	eax, DWORD PTR [eax+44]
	add	ebp, DWORD PTR tv952[esp+176]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN80@DoReconSta
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN81@DoReconSta
$LN80@DoReconSta:
	or	ecx, -1
$LN81@DoReconSta:
	mov	eax, ecx
	shr	eax, 5
	mov	edx, eax
	shl	edx, 5
	sub	ecx, edx
	mov	edx, esi
	shl	edx, cl
	test	edx, DWORD PTR [ebp+eax*4+8]
	je	$LN46@DoReconSta

; 2001 : 		{
; 2002 : 			bIsLand = false;
; 2003 : 			bIsCoastalWater = false;
; 2004 : 
; 2005 : 			// Count Revealed Land Plots
; 2006 : 			if(!pPlot->isWater())

	cmp	BYTE PTR [ebp+5], 3
	je	SHORT $LN43@DoReconSta

; 2007 : 			{
; 2008 : 				bIsLand = true;
; 2009 : 				iNumLandPlotsRevealed++;

	add	DWORD PTR _iNumLandPlotsRevealed$[esp+176], esi
	jmp	SHORT $LN188@DoReconSta
$LN43@DoReconSta:

; 2010 : 			}
; 2011 : 			else if(pPlot->isShallowWater() || bNeedToLookAtDeepWaterAlso)

	mov	ecx, ebp
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	test	al, al
	jne	SHORT $LN40@DoReconSta
	cmp	BYTE PTR _bNeedToLookAtDeepWaterAlso$[esp+176], al
	je	SHORT $LN188@DoReconSta
$LN40@DoReconSta:

; 2012 : 			{
; 2013 : 				bIsCoastalWater = true;
; 2014 : 				iNumCoastalTilesRevealed++;

	add	DWORD PTR _iNumCoastalTilesRevealed$[esp+176], esi
$LN188@DoReconSta:

; 2015 : 			}
; 2016 : 
; 2017 : 			// Check adjacent Plots for THEIR visibility
; 2018 : 			for(iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)

	xor	ebx, ebx
$LL39@DoReconSta:

; 2019 : 			{
; 2020 : 				pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iDirectionLoop));

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	ebx
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 2021 : 
; 2022 : 				if(pAdjacentPlot != NULL)

	test	esi, esi
	je	$LN38@DoReconSta

; 2023 : 				{
; 2024 : 					// Check to see if adjacent Tile is land or water...
; 2025 : 					if(pAdjacentPlot->isWater())

	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN35@DoReconSta

; 2026 : 					{
; 2027 : 						// This is a slight cheat (because the AI rules out water tiles) but helps prevents the AI from building too many Land explorers
; 2028 : 						if((bNeedToLookAtDeepWaterAlso || pAdjacentPlot->isShallowWater()) && !pAdjacentPlot->isRevealed(m_pPlayer->getTeam()))

	cmp	BYTE PTR _bNeedToLookAtDeepWaterAlso$[esp+176], 0
	jne	SHORT $LN33@DoReconSta
	mov	ecx, esi
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	test	al, al
	je	SHORT $LN38@DoReconSta
$LN33@DoReconSta:
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN101@DoReconSta
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN102@DoReconSta
$LN101@DoReconSta:
	or	ecx, -1
$LN102@DoReconSta:
	mov	eax, ecx
	shr	eax, 5
	mov	edx, eax
	shl	edx, 5
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [esi+eax*4+8]
	jne	SHORT $LN38@DoReconSta

; 2029 : 						{
; 2030 : 							iNumCoastalTilesWithAdjacentFog++;

	inc	DWORD PTR _iNumCoastalTilesWithAdjacentFog$[esp+176]

; 2031 : 							break;

	jmp	SHORT $LN196@DoReconSta
$LN35@DoReconSta:

; 2032 : 						}
; 2033 : 					}
; 2034 : 					else
; 2035 : 					{
; 2036 : 						// This is a slight cheat (because the AI rules out water tiles) but helps prevents the AI from building too many Land explorers
; 2037 : 						if(!pAdjacentPlot->isRevealed(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN114@DoReconSta
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN115@DoReconSta
$LN114@DoReconSta:
	or	ecx, -1
$LN115@DoReconSta:
	mov	eax, ecx
	shr	eax, 5
	mov	edx, eax
	shl	edx, 5
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [esi+eax*4+8]
	je	SHORT $LN181@DoReconSta
$LN38@DoReconSta:

; 2015 : 			}
; 2016 : 
; 2017 : 			// Check adjacent Plots for THEIR visibility
; 2018 : 			for(iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)

	inc	ebx
	cmp	ebx, 6
	jl	$LL39@DoReconSta

; 2032 : 						}
; 2033 : 					}
; 2034 : 					else
; 2035 : 					{
; 2036 : 						// This is a slight cheat (because the AI rules out water tiles) but helps prevents the AI from building too many Land explorers
; 2037 : 						if(!pAdjacentPlot->isRevealed(m_pPlayer->getTeam()))

	jmp	SHORT $LN196@DoReconSta
$LN181@DoReconSta:

; 2038 : 						{
; 2039 : 							iNumLandPlotsWithAdjacentFog++;

	inc	DWORD PTR _iNumLandPlotsWithAdjacentFog$[esp+176]
$LN196@DoReconSta:
	mov	esi, 1
$LN46@DoReconSta:

; 1994 : 
; 1995 : 	// Look at map size and gauge how much of it we know about
; 1996 : 	for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	eax, DWORD PTR _iPlotLoop$[esp+176]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	DWORD PTR tv952[esp+176], 484		; 000001e4H
	add	eax, esi
	cmp	eax, DWORD PTR [ecx+4028]
	mov	DWORD PTR _iPlotLoop$[esp+176], eax
	jl	$LL191@DoReconSta
$LN45@DoReconSta:

; 2040 : 							break;
; 2041 : 						}
; 2042 : 					}
; 2043 : 				}
; 2044 : 			}
; 2045 : 		}
; 2046 : 	}
; 2047 : 
; 2048 : 	// RECON ON OUR HOME CONTINENT
; 2049 : 
; 2050 : 	// How many Units do we have exploring or being trained to do this job? The more Units we have the less we want this Strategy
; 2051 : 	int iNumExploringUnits = m_pPlayer->GetNumUnitsWithUnitAI(UNITAI_EXPLORE, true, false) + m_iExplorersDisbanded;

	mov	ecx, DWORD PTR [edi+4]
	push	0
	push	esi
	push	10					; 0000000aH
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI

; 2052 : 	int iStrategyWeight = /*100*/ GC.getAI_STRATEGY_EARLY_EXPLORATION_STARTING_WEIGHT();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1996

; 2053 : 	int iWeightThreshold = 110;  // So result is a number from 10 to 100
; 2054 : 	iWeightThreshold -= m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_RECON")) *
; 2055 : 	                    /*10*/ GC.getAI_STRATEGY_EARLY_EXPLORATION_WEIGHT_PER_FLAVOR();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2004
	push	0
	mov	ebp, eax
	add	ebp, DWORD PTR [edi+36]
	push	OFFSET $SG227188
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [edi+4]
	push	eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	imul	eax, esi
	mov	esi, 110				; 0000006eH
	sub	esi, eax

; 2056 : 
; 2057 : 	// Safety check even if personality flavor is higher than expected
; 2058 : 	if(iWeightThreshold > 100)

	cmp	esi, 100				; 00000064H
	jle	SHORT $LN30@DoReconSta

; 2059 : 	{
; 2060 : 		iWeightThreshold = 100;

	mov	esi, 100				; 00000064H
$LN30@DoReconSta:

; 2061 : 	}
; 2062 : 
; 2063 : 	iStrategyWeight *= iNumLandPlotsWithAdjacentFog;
; 2064 : 	int iNumExplorerDivisor = iNumExploringUnits + /*1*/ GC.getAI_STRATEGY_EARLY_EXPLORATION_EXPLORERS_WEIGHT_DIVISOR();
; 2065 : 	iStrategyWeight /= (iNumExplorerDivisor * iNumExplorerDivisor);
; 2066 : 	iStrategyWeight /= (int)sqrt((double)iNumLandPlotsRevealed);

	fild	DWORD PTR _iNumLandPlotsRevealed$[esp+176]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2000
	sub	esp, 8
	add	ebp, eax
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	call	__ftol2_sse_excpt
	mov	ecx, eax
	mov	eax, ebp
	imul	eax, ebp
	mov	DWORD PTR tv806[esp+176], eax
	mov	eax, ebx
	imul	eax, DWORD PTR _iNumLandPlotsWithAdjacentFog$[esp+176]
	mov	ebx, DWORD PTR tv806[esp+176]
	cdq
	idiv	ebx

; 2071 : 	}
; 2072 : 	else

	xor	ebp, ebp
	cdq
	idiv	ecx
	mov	ecx, eax
	cmp	ecx, esi
	jle	SHORT $LN29@DoReconSta

; 2067 : 
; 2068 : 	if(iStrategyWeight > iWeightThreshold)
; 2069 : 	{
; 2070 : 		m_eReconState = RECON_STATE_NEEDED;

	mov	DWORD PTR [edi+28], 2

; 2071 : 	}
; 2072 : 	else

	jmp	$LN190@DoReconSta
$LN29@DoReconSta:

; 2073 : 	{
; 2074 : 		if(iStrategyWeight > (iWeightThreshold / 4))

	mov	eax, esi
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	ecx, eax
	jle	SHORT $LN27@DoReconSta

; 2075 : 		{
; 2076 : 			m_eReconState = RECON_STATE_NEUTRAL;

	mov	DWORD PTR [edi+28], 1

; 2077 : 		}
; 2078 : 		else

	jmp	$LN190@DoReconSta
$LN27@DoReconSta:

; 2079 : 		{
; 2080 : 			m_eReconState = RECON_STATE_ENOUGH;

	mov	DWORD PTR [edi+28], ebp

; 2081 : 
; 2082 : 			// Return all/most warriors/spears to normal unit AI since have enough recon.  Keep at least 1 explorer through Turn 100.
; 2083 : 			bool bSkipFirst = GC.getGame().getGameTurn() < 100;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 2084 : 			for(pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))

	mov	ecx, DWORD PTR [edi+4]
	push	ebp
	lea	edx, DWORD PTR _iUnitLoop$[esp+180]
	cmp	eax, 100				; 00000064H
	push	edx
	setl	bl
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	cmp	esi, ebp
	je	$LN190@DoReconSta
	npad	6
$LL25@DoReconSta:

; 2085 : 			{
; 2086 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_EXPLORE && pLoopUnit->getUnitInfo().GetUnitAIType(UNITAI_ATTACK))

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	jne	$LN24@DoReconSta
	push	3
	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	test	al, al
	je	$LN24@DoReconSta

; 2087 : 				{
; 2088 : 					if(bSkipFirst)

	test	bl, bl
	je	SHORT $LN21@DoReconSta

; 2089 : 					{
; 2090 : 						bSkipFirst = false;

	xor	bl, bl

; 2091 : 					}
; 2092 : 					else

	jmp	$LN24@DoReconSta
$LN21@DoReconSta:

; 2093 : 					{
; 2094 : 						pLoopUnit->AI_setUnitAIType(UNITAI_ATTACK);

	push	3
	mov	ecx, esi
	call	?AI_setUnitAIType@CvUnit@@QAEXW4UnitAITypes@@@Z ; CvUnit::AI_setUnitAIType

; 2095 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN24@DoReconSta
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN24@DoReconSta

; 2096 : 						{
; 2097 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227205[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2098 : 							strLogString.Format("Assigning exploring %s back to attack AI, X: %d, Y: %d", pLoopUnit->getName().GetCString(), pLoopUnit->getX(), pLoopUnit->getY());

	lea	eax, DWORD PTR $T235814[esp+176]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+188], ebp
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	push	ecx
	push	esi
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+192], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$227205[esp+188]
	push	OFFSET $SG227207
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T235814[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2099 : 							m_pPlayer->GetHomelandAI()->LogHomelandMessage(strLogString);

	mov	ecx, DWORD PTR [edi+4]
	lea	edx, DWORD PTR _strLogString$227205[esp+176]
	push	edx
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2100 : 						}

	lea	ecx, DWORD PTR _strLogString$227205[esp+176]
	mov	DWORD PTR __$EHRec$[esp+184], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN24@DoReconSta:
	mov	ecx, DWORD PTR [edi+4]
	push	ebp
	lea	eax, DWORD PTR _iUnitLoop$[esp+180]
	push	eax
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	cmp	esi, ebp
	jne	$LL25@DoReconSta
$LN190@DoReconSta:

; 2101 : 					}
; 2102 : 				}
; 2103 : 			}
; 2104 : 		}
; 2105 : 	}
; 2106 : 
; 2107 : 	// NAVAL RECON ACROSS THE ENTIRE MAP
; 2108 : 
; 2109 : 	// No coastal cities?  Moot point...
; 2110 : 	CvCity* pLoopCity;
; 2111 : 	int iCityLoop;
; 2112 : 	bool bFoundCoastalCity = false;
; 2113 : 	for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL && !bFoundCoastalCity; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	push	ebp
	lea	ecx, DWORD PTR _iCityLoop$[esp+180]
	push	ecx
	mov	ecx, DWORD PTR [edi+4]
	xor	bl, bl
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	cmp	eax, ebp
	je	SHORT $LN187@DoReconSta
	npad	1
$LL18@DoReconSta:
	test	bl, bl
	jne	SHORT $LN14@DoReconSta

; 2114 : 	{
; 2115 : 		if(pLoopCity->isCoastal())

	push	-1
	mov	ecx, eax
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	SHORT $LN17@DoReconSta

; 2116 : 		{
; 2117 : 			bFoundCoastalCity = true;

	mov	bl, 1
$LN17@DoReconSta:

; 2101 : 					}
; 2102 : 				}
; 2103 : 			}
; 2104 : 		}
; 2105 : 	}
; 2106 : 
; 2107 : 	// NAVAL RECON ACROSS THE ENTIRE MAP
; 2108 : 
; 2109 : 	// No coastal cities?  Moot point...
; 2110 : 	CvCity* pLoopCity;
; 2111 : 	int iCityLoop;
; 2112 : 	bool bFoundCoastalCity = false;
; 2113 : 	for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL && !bFoundCoastalCity; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	mov	ecx, DWORD PTR [edi+4]
	push	ebp
	lea	edx, DWORD PTR _iCityLoop$[esp+180]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	cmp	eax, ebp
	jne	SHORT $LL18@DoReconSta

; 2118 : 		}
; 2119 : 	}
; 2120 : 
; 2121 : 	if(!bFoundCoastalCity)

	test	bl, bl
	jne	SHORT $LN14@DoReconSta
$LN187@DoReconSta:

; 2122 : 	{
; 2123 : 		m_eNavalReconState = RECON_STATE_ENOUGH;

	mov	DWORD PTR [edi+32], ebp

; 2124 : 	}
; 2125 : 
; 2126 : 	else

	jmp	$LN194@DoReconSta
$LN14@DoReconSta:

; 2127 : 	{
; 2128 : 		// How many Units do we have exploring or being trained to do this job? The more Units we have the less we want this Strategy
; 2129 : 		iNumExploringUnits = m_pPlayer->GetNumUnitsWithUnitAI(UNITAI_EXPLORE_SEA, true, true);

	mov	ecx, DWORD PTR [edi+4]
	push	1
	push	1
	push	21					; 00000015H
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI

; 2130 : 		iStrategyWeight = /*100*/ GC.getAI_STRATEGY_EARLY_EXPLORATION_STARTING_WEIGHT();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1996

; 2131 : 		iWeightThreshold = 110;  // So result is a number from 10 to 100
; 2132 : 		iWeightThreshold -= m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_NAVAL_RECON")) *
; 2133 : 		                    /*10*/ GC.getAI_STRATEGY_EARLY_EXPLORATION_WEIGHT_PER_FLAVOR();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2004
	push	0
	push	OFFSET $SG227218
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR [edi+4]
	push	eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	imul	eax, esi
	mov	esi, 110				; 0000006eH
	sub	esi, eax

; 2134 : 
; 2135 : 		// Safety check even if personality flavor is higher than expected
; 2136 : 		if(iWeightThreshold > 100)

	cmp	esi, 100				; 00000064H
	jle	SHORT $LN12@DoReconSta

; 2137 : 		{
; 2138 : 			iWeightThreshold = 100;

	mov	esi, 100				; 00000064H
$LN12@DoReconSta:

; 2139 : 		}
; 2140 : 
; 2141 : 		iStrategyWeight *= iNumCoastalTilesWithAdjacentFog;
; 2142 : 		iNumExplorerDivisor = iNumExploringUnits + /*1*/ GC.getAI_STRATEGY_EARLY_EXPLORATION_EXPLORERS_WEIGHT_DIVISOR();
; 2143 : 		iStrategyWeight /= (iNumExplorerDivisor * iNumExplorerDivisor);
; 2144 : 		iStrategyWeight /= (int)sqrt((double)iNumCoastalTilesRevealed);

	fild	DWORD PTR _iNumCoastalTilesRevealed$[esp+176]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2000
	sub	esp, 8
	add	ebp, eax
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	call	__ftol2_sse_excpt
	mov	ecx, eax
	mov	eax, ebp
	imul	eax, ebp
	mov	DWORD PTR tv804[esp+176], eax
	mov	eax, ebx
	imul	eax, DWORD PTR _iNumCoastalTilesWithAdjacentFog$[esp+176]
	mov	ebx, DWORD PTR tv804[esp+176]
	cdq
	idiv	ebx
	cdq
	idiv	ecx
	mov	ecx, eax

; 2145 : 
; 2146 : 		if(iStrategyWeight > iWeightThreshold/* || iNumExploringUnits == 0 && iNumCoastalTilesWithAdjacentFog > 50*/)

	cmp	ecx, esi
	jle	SHORT $LN11@DoReconSta

; 2147 : 		{
; 2148 : 			m_eNavalReconState = RECON_STATE_NEEDED;

	mov	DWORD PTR [edi+32], 2

; 2149 : 		}
; 2150 : 		else

	jmp	$LN194@DoReconSta
$LN11@DoReconSta:

; 2151 : 		{
; 2152 : 			if(iStrategyWeight > (iWeightThreshold / 4))

	mov	eax, esi
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	ecx, eax
	jle	SHORT $LN9@DoReconSta

; 2153 : 			{
; 2154 : 				m_eNavalReconState = RECON_STATE_NEUTRAL;

	mov	DWORD PTR [edi+32], 1

; 2155 : 			}
; 2156 : 			else

	jmp	$LN194@DoReconSta
$LN9@DoReconSta:

; 2157 : 			{
; 2158 : 				m_eNavalReconState = RECON_STATE_ENOUGH;
; 2159 : 
; 2160 : 				// Return all/most boats to normal unit AI since have enough recon
; 2161 : 				bool bSkipFirst = (m_eNavalReconState == RECON_STATE_NEUTRAL);
; 2162 : 				for(pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))

	mov	ecx, DWORD PTR [edi+4]
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[esp+180]
	push	edx
	mov	DWORD PTR [edi+32], 0
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	$LN194@DoReconSta
	npad	7
$LL7@DoReconSta:

; 2163 : 				{
; 2164 : 					if(pLoopUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA && pLoopUnit->getUnitInfo().GetUnitAIType(UNITAI_ATTACK_SEA))

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	jne	$LN6@DoReconSta
	push	18					; 00000012H
	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	test	al, al
	je	$LN6@DoReconSta

; 2165 : 					{
; 2166 : 						if(bSkipFirst)
; 2167 : 						{
; 2168 : 							bSkipFirst = false;
; 2169 : 						}
; 2170 : 						else
; 2171 : 						{
; 2172 : 							pLoopUnit->AI_setUnitAIType(UNITAI_ATTACK_SEA);

	push	18					; 00000012H
	mov	ecx, esi
	call	?AI_setUnitAIType@CvUnit@@QAEXW4UnitAITypes@@@Z ; CvUnit::AI_setUnitAIType

; 2173 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@DoReconSta
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN6@DoReconSta

; 2174 : 							{
; 2175 : 								CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227234[esp+176]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2176 : 								strLogString.Format("Assigning naval explorer back to attack sea AI to %s, X: %d, Y: %d", pLoopUnit->getName().GetCString(), pLoopUnit->getX(), pLoopUnit->getY());

	lea	eax, DWORD PTR $T235815[esp+176]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+188], 2
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	push	ecx
	push	esi
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+192], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$227234[esp+188]
	push	OFFSET $SG227236
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T235815[esp+176]
	mov	BYTE PTR __$EHRec$[esp+184], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2177 : 								m_pPlayer->GetHomelandAI()->LogHomelandMessage(strLogString);

	mov	ecx, DWORD PTR [edi+4]
	lea	edx, DWORD PTR _strLogString$227234[esp+176]
	push	edx
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2178 : 							}

	lea	ecx, DWORD PTR _strLogString$227234[esp+176]
	mov	DWORD PTR __$EHRec$[esp+184], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@DoReconSta:
	mov	ecx, DWORD PTR [edi+4]
	push	0
	lea	eax, DWORD PTR _iUnitLoop$[esp+180]
	push	eax
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	$LL7@DoReconSta
$LN194@DoReconSta:

; 2179 : 						}
; 2180 : 					}
; 2181 : 				}
; 2182 : 			}
; 2183 : 		}
; 2184 : 	}
; 2185 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+176]
	pop	ebp
	pop	ebx
	pop	esi
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 160				; 000000a0H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$227205[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR $T235814[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$227234[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR $T235815[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoReconState@CvEconomicAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoReconState@CvEconomicAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoReconState@CvEconomicAI@@AAEXXZ ENDP			; CvEconomicAI::DoReconState
PUBLIC	?DoAntiquitySites@CvEconomicAI@@AAEXXZ		; CvEconomicAI::DoAntiquitySites
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
; Function compile flags: /Ogtpy
;	COMDAT ?DoAntiquitySites@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
_iNumSites$ = -16					; size = 4
_iPlotLoop$ = -12					; size = 4
_eArtifactResourceType$ = -8				; size = 4
_eHiddenArtifactResourceType$ = -4			; size = 4
?DoAntiquitySites@CvEconomicAI@@AAEXXZ PROC		; CvEconomicAI::DoAntiquitySites, COMDAT
; _this$ = ecx

; 2189 : {

	sub	esp, 16					; 00000010H

; 2190 : 	int iNumSites = 0;
; 2191 : #ifdef AUI_WARNING_FIXES
; 2192 : 	uint iPlotLoop;
; 2193 : #else
; 2194 : 	int iPlotLoop;
; 2195 : #endif
; 2196 : 	CvPlot *pPlot;
; 2197 : 	ResourceTypes eArtifactResourceType = static_cast<ResourceTypes>(GC.getARTIFACT_RESOURCE());
; 2198 : 	ResourceTypes eHiddenArtifactResourceType = static_cast<ResourceTypes>(GC.getHIDDEN_ARTIFACT_RESOURCE());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8412
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8408
	xor	eax, eax
	mov	DWORD PTR _eArtifactResourceType$[esp+20], ecx

; 2199 : 
; 2200 : 	for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	DWORD PTR [ecx+4028], eax
	mov	DWORD PTR _iNumSites$[esp+20], eax
	mov	DWORD PTR _eHiddenArtifactResourceType$[esp+20], edx
	mov	DWORD PTR _iPlotLoop$[esp+20], eax
	jle	$LN54@DoAntiquit
	push	ebx
	push	ebp
	push	esi
	xor	ebx, ebx
	npad	5
$LL57@DoAntiquit:

; 2201 : 	{
; 2202 : 		pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
; 2203 : 		if(pPlot->isRevealed(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [ecx+4068]
	mov	edx, DWORD PTR [eax+44]
	add	esi, ebx
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN25@DoAntiquit
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN26@DoAntiquit
$LN25@DoAntiquit:
	or	ecx, -1
$LN26@DoAntiquit:
	mov	eax, ecx
	shr	eax, 5
	mov	ebp, eax
	shl	ebp, 5
	sub	ecx, ebp
	mov	ebp, 1
	shl	ebp, cl
	test	ebp, DWORD PTR [esi+eax*4+8]
	je	SHORT $LN5@DoAntiquit

; 2204 : 		{
; 2205 : 			if (pPlot->getResourceType(m_pPlayer->getTeam()) == eArtifactResourceType ||
; 2206 : 				pPlot->getResourceType(m_pPlayer->getTeam()) == eHiddenArtifactResourceType)

	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN38@DoAntiquit
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN39@DoAntiquit
$LN38@DoAntiquit:
	or	edx, -1
$LN39@DoAntiquit:
	push	edx
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, DWORD PTR _eArtifactResourceType$[esp+32]
	je	SHORT $LN1@DoAntiquit
	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN47@DoAntiquit
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN48@DoAntiquit
$LN47@DoAntiquit:
	or	eax, -1
$LN48@DoAntiquit:
	push	eax
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, DWORD PTR _eHiddenArtifactResourceType$[esp+32]
	jne	SHORT $LN5@DoAntiquit
$LN1@DoAntiquit:

; 2207 : 			{
; 2208 : 				iNumSites++;

	inc	DWORD PTR _iNumSites$[esp+32]
$LN5@DoAntiquit:

; 2199 : 
; 2200 : 	for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	eax, DWORD PTR _iPlotLoop$[esp+32]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	inc	eax
	add	ebx, 484				; 000001e4H
	cmp	eax, DWORD PTR [ecx+4028]
	mov	DWORD PTR _iPlotLoop$[esp+32], eax
	jl	$LL57@DoAntiquit

; 2209 : 			}
; 2210 : 		}
; 2211 : 	}
; 2212 : 
; 2213 : 	m_iVisibleAntiquitySites = iNumSites;

	mov	edx, DWORD PTR _iNumSites$[esp+32]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR [edi+44], edx
	pop	edi

; 2214 : }

	add	esp, 16					; 00000010H
	ret	0
$LN54@DoAntiquit:

; 2209 : 			}
; 2210 : 		}
; 2211 : 	}
; 2212 : 
; 2213 : 	m_iVisibleAntiquitySites = iNumSites;

	mov	DWORD PTR [edi+44], eax
	pop	edi

; 2214 : }

	add	esp, 16					; 00000010H
	ret	0
?DoAntiquitySites@CvEconomicAI@@AAEXXZ ENDP		; CvEconomicAI::DoAntiquitySites
_TEXT	ENDS
PUBLIC	?FindWorkerToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ ; CvEconomicAI::FindWorkerToScrap
EXTRN	?getSpecialUnitType@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ:PROC ; CvUnit::getSpecialUnitType
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
; Function compile flags: /Ogtpy
;	COMDAT ?FindWorkerToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ
_TEXT	SEGMENT
_iUnitLoop$ = -4					; size = 4
?FindWorkerToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ PROC	; CvEconomicAI::FindWorkerToScrap, COMDAT
; _this$ = ecx

; 2679 : {

	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx

; 2680 : 	CvUnit* pLoopUnit = NULL;
; 2681 : 	int iUnitLoop = 0;
; 2682 : 
; 2683 : 	// Look at map for loose workers
; 2684 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))

	mov	ecx, DWORD PTR [ebx+4]
	push	0
	lea	eax, DWORD PTR _iUnitLoop$[esp+20]
	push	eax
	mov	DWORD PTR _iUnitLoop$[esp+24], 0
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN3@FindWorker
$LN16@FindWorker:

; 2685 : 	{
; 2686 : 		if(!pLoopUnit)
; 2687 : 		{
; 2688 : 			continue;
; 2689 : 		}
; 2690 : 		UnitTypes eWorker = (UnitTypes) GC.getInfoTypeForString("UNIT_WORKER");

	push	0
	push	OFFSET $SG227716
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2691 : 		if(pLoopUnit->getDomainType() == DOMAIN_LAND && pLoopUnit->getUnitType() == eWorker && !pLoopUnit->IsCombatUnit() && pLoopUnit->getSpecialUnitType() == NO_SPECIALUNIT)

	mov	ecx, esi
	mov	edi, eax
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN4@FindWorker
	mov	ecx, esi
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	cmp	eax, edi
	jne	SHORT $LN4@FindWorker
	cmp	DWORD PTR [esi+1044], 0
	jg	SHORT $LN4@FindWorker
	mov	ecx, esi
	call	?getSpecialUnitType@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ ; CvUnit::getSpecialUnitType
	cmp	eax, -1
	je	SHORT $LN13@FindWorker
$LN4@FindWorker:

; 2680 : 	CvUnit* pLoopUnit = NULL;
; 2681 : 	int iUnitLoop = 0;
; 2682 : 
; 2683 : 	// Look at map for loose workers
; 2684 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR [ebx+4]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN16@FindWorker
$LN3@FindWorker:
	pop	edi
	pop	esi

; 2694 : 		}
; 2695 : 	}
; 2696 : 
; 2697 : 	return NULL;

	xor	eax, eax
	pop	ebx

; 2698 : }

	pop	ecx
	ret	0
$LN13@FindWorker:
	pop	edi

; 2692 : 		{
; 2693 : 			return pLoopUnit;

	mov	eax, esi
	pop	esi
	pop	ebx

; 2698 : }

	pop	ecx
	ret	0
?FindWorkerToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ ENDP	; CvEconomicAI::FindWorkerToScrap
_TEXT	ENDS
PUBLIC	?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z ; CvEconomicAI::LogScrapUnit
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z$2
__ehfuncinfo$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z
_TEXT	SEGMENT
_strLogString$ = -68					; size = 28
$T236234 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_iNumWorkers$ = 16					; size = 4
_iNumCities$ = 20					; size = 4
_iNumImprovedPlots$ = 24				; size = 4
_iNumValidPlots$ = 28					; size = 4
?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z PROC ; CvEconomicAI::LogScrapUnit, COMDAT
; _this$ = ecx

; 2790 : {

	push	-1
	push	__ehhandler$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	esi
	mov	esi, ecx

; 2791 : 	if(!GC.getLogging() || !GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+80], 0
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogScrapUn
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogScrapUn
	push	edi

; 2794 : 	}
; 2795 : 
; 2796 : 	CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$[esp+76]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2797 : 	strLogString.Format("Disbanding worker. %s, X: %d, Y: %d, iNumWorkers: %d, iNumCities: %d, improved/valid plots: %d/%d", pUnit->getName().GetCString(), pUnit->getX(), pUnit->getY(), iNumWorkers, iNumCities, iNumImprovedPlots, iNumValidPlots);

	mov	ecx, DWORD PTR _pUnit$[esp+72]
	lea	eax, DWORD PTR $T236234[esp+76]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+88], 1
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	edi, DWORD PTR _iNumValidPlots$[esp+72]
	mov	ecx, DWORD PTR _pUnit$[esp+72]
	mov	edx, DWORD PTR [ecx+88]
	mov	ecx, DWORD PTR [ecx+76]
	push	edi
	mov	edi, DWORD PTR _iNumImprovedPlots$[esp+76]
	push	edi
	mov	edi, DWORD PTR _iNumCities$[esp+80]
	push	edi
	mov	edi, DWORD PTR _iNumWorkers$[esp+84]
	push	edi
	push	edx
	push	ecx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+108], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$[esp+104]
	push	OFFSET $SG227789
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 36					; 00000024H
	lea	ecx, DWORD PTR $T236234[esp+76]
	mov	BYTE PTR __$EHRec$[esp+84], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2798 : 	m_pPlayer->GetHomelandAI()->LogHomelandMessage(strLogString);

	mov	ecx, DWORD PTR [esi+4]
	lea	edx, DWORD PTR _strLogString$[esp+76]
	push	edx
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2799 : }

	lea	ecx, DWORD PTR _strLogString$[esp+76]
	mov	BYTE PTR __$EHRec$[esp+84], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
$LN1@LogScrapUn:
	mov	ecx, DWORD PTR _pUnit$[esp+68]
	mov	DWORD PTR __$EHRec$[esp+80], -1
	test	ecx, ecx
	je	SHORT $LN11@LogScrapUn

; 2792 : 	{
; 2793 : 		return;

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN11@LogScrapUn:

; 2799 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z$1:
	lea	ecx, DWORD PTR _strLogString$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z$2:
	lea	ecx, DWORD PTR $T236234[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z ENDP ; CvEconomicAI::LogScrapUnit
PUBLIC	?IsAreaSafeForQuickColony@EconomicAIHelpers@@YA_NHPAVCvPlayer@@@Z ; EconomicAIHelpers::IsAreaSafeForQuickColony
EXTRN	?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::isVisibleEnemyUnit
EXTRN	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ:PROC ; CvArea::getAreaBoundaries
; Function compile flags: /Ogtpy
;	COMDAT ?IsAreaSafeForQuickColony@EconomicAIHelpers@@YA_NHPAVCvPlayer@@@Z
_TEXT	SEGMENT
_iBeginSearchY$ = -52					; size = 4
$T236312 = -48						; size = 16
$T236313 = -32						; size = 16
$T236315 = -16						; size = 16
$T236314 = -16						; size = 16
_iAreaID$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsAreaSafeForQuickColony@EconomicAIHelpers@@YA_NHPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsAreaSafeForQuickColony, COMDAT

; 2846 : {

	sub	esp, 52					; 00000034H
	push	esi

; 2847 : 	if(iAreaID == -1)

	mov	esi, DWORD PTR _iAreaID$[esp+52]
	cmp	esi, -1
	jne	SHORT $LN12@IsAreaSafe
$LN41@IsAreaSafe:

; 2848 : 	{
; 2849 : 		return false;

	xor	al, al
	pop	esi

; 2890 : }

	add	esp, 52					; 00000034H
	ret	0
$LN12@IsAreaSafe:

; 2850 : 	}
; 2851 : 
; 2852 : 	// Can't be capitals area
; 2853 : 	CvCity* pCapitalCity = pPlayer->getCapitalCity();

	mov	ecx, DWORD PTR _pPlayer$[esp+52]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 2854 : 	if(pCapitalCity != NULL)

	test	eax, eax
	je	SHORT $LN10@IsAreaSafe

; 2855 : 	{
; 2856 : 		if(iAreaID == pCapitalCity->getArea())

	mov	ecx, eax
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	cmp	esi, eax

; 2857 : 		{
; 2858 : 			return false;

	je	SHORT $LN41@IsAreaSafe
$LN10@IsAreaSafe:

; 2859 : 		}
; 2860 : 	}
; 2861 : 
; 2862 : 	CvArea* pArea = GC.getMap().getArea(iAreaID);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	ebp
	push	edi
	push	esi
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	esi, eax

; 2863 : 	int iBeginSearchX = pArea->getAreaBoundaries().m_iWestEdge;

	lea	eax, DWORD PTR $T236312[esp+68]
	push	eax
	mov	ecx, esi
	call	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ; CvArea::getAreaBoundaries
	mov	edi, DWORD PTR [eax+12]

; 2864 : 	int iBeginSearchY = pArea->getAreaBoundaries().m_iSouthEdge;

	lea	ecx, DWORD PTR $T236313[esp+68]
	push	ecx
	mov	ecx, esi
	call	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ; CvArea::getAreaBoundaries
	mov	edx, DWORD PTR [eax+4]

; 2865 : 	int iEndSearchX   = pArea->getAreaBoundaries().m_iEastEdge;

	lea	eax, DWORD PTR $T236314[esp+68]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _iBeginSearchY$[esp+72], edx
	call	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ; CvArea::getAreaBoundaries
	mov	ebp, DWORD PTR [eax+8]

; 2866 : 	int iEndSearchY   = pArea->getAreaBoundaries().m_iNorthEdge;

	lea	ecx, DWORD PTR $T236315[esp+68]
	push	ecx
	mov	ecx, esi
	call	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ; CvArea::getAreaBoundaries

; 2867 : 
; 2868 : 	for(int iPlotX = iBeginSearchX; iPlotX <= iEndSearchX; iPlotX++)

	cmp	edi, ebp
	mov	ebx, DWORD PTR [eax]
	jg	SHORT $LN7@IsAreaSafe
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
$LL9@IsAreaSafe:

; 2869 : 	{
; 2870 : 		for(int iPlotY = iBeginSearchY; iPlotY <= iEndSearchY; iPlotY++)

	mov	esi, DWORD PTR _iBeginSearchY$[esp+68]
	cmp	esi, ebx
	jg	SHORT $LN8@IsAreaSafe
	npad	3
$LL6@IsAreaSafe:

; 2871 : 		{
; 2872 : 			CvPlot* pPlot = GC.getMap().plotCheckInvalid(iPlotX, iPlotY);

	cmp	edi, -2147483647			; 80000001H
	je	SHORT $LN5@IsAreaSafe
	cmp	esi, -2147483647			; 80000001H
	je	SHORT $LN5@IsAreaSafe
	mov	ecx, DWORD PTR [eax+4020]
	imul	ecx, esi
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]

; 2873 : 			if(!pPlot)

	je	SHORT $LN5@IsAreaSafe

; 2874 : 			{
; 2875 : 				continue;
; 2876 : 			}
; 2877 : 
; 2878 : 			if(pPlot->getArea() != iAreaID)

	mov	edx, DWORD PTR _iAreaID$[esp+64]
	cmp	DWORD PTR [ecx+356], edx
	jne	SHORT $LN5@IsAreaSafe

; 2879 : 			{
; 2880 : 				continue;
; 2881 : 			}
; 2882 : 
; 2883 : 			if(pPlot->isVisibleEnemyUnit(pPlayer->GetID()))

	mov	eax, DWORD PTR _pPlayer$[esp+64]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleEnemyUnit
	test	al, al
	jne	SHORT $LN35@IsAreaSafe
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
$LN5@IsAreaSafe:

; 2869 : 	{
; 2870 : 		for(int iPlotY = iBeginSearchY; iPlotY <= iEndSearchY; iPlotY++)

	inc	esi
	cmp	esi, ebx
	jle	SHORT $LL6@IsAreaSafe
$LN8@IsAreaSafe:

; 2867 : 
; 2868 : 	for(int iPlotX = iBeginSearchX; iPlotX <= iEndSearchX; iPlotX++)

	inc	edi
	cmp	edi, ebp
	jle	SHORT $LL9@IsAreaSafe
$LN7@IsAreaSafe:
	pop	edi
	pop	ebp
	pop	ebx

; 2886 : 			}
; 2887 : 		}
; 2888 : 	}
; 2889 : 	return true;

	mov	al, 1
	pop	esi

; 2890 : }

	add	esp, 52					; 00000034H
	ret	0
$LN35@IsAreaSafe:
	pop	edi
	pop	ebp
	pop	ebx

; 2884 : 			{
; 2885 : 				return false;

	xor	al, al
	pop	esi

; 2890 : }

	add	esp, 52					; 00000034H
	ret	0
?IsAreaSafeForQuickColony@EconomicAIHelpers@@YA_NHPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsAreaSafeForQuickColony
_TEXT	ENDS
PUBLIC	?IsTestStrategy_ReallyNeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ReallyNeedReconSea
EXTRN	?canEmbark@CvTeam@@QBE_NXZ:PROC			; CvTeam::canEmbark
EXTRN	?GetFreePromotions@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetFreePromotions
EXTRN	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetDefaultUnitAIType
EXTRN	?GetDomainType@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetDomainType
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?getProductionUnit@CvCity@@QBE?AW4UnitTypes@@XZ:PROC ; CvCity::getProductionUnit
EXTRN	?isProductionUnit@CvCity@@QBE_NXZ:PROC		; CvCity::isProductionUnit
EXTRN	?GetTerrainPassableTech@CvPromotionEntry@@QBEHH@Z:PROC ; CvPromotionEntry::GetTerrainPassableTech
EXTRN	?GetTerrainImpassable@CvPromotionEntry@@QBE_NH@Z:PROC ; CvPromotionEntry::GetTerrainImpassable
EXTRN	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z:PROC ; CvGlobals::getPromotionInfo
EXTRN	?getNumPromotionInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPromotionInfos
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_ReallyNeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_iLoop$227889 = -4					; size = 4
_iLoop$227862 = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_ReallyNeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_ReallyNeedReconSea, COMDAT

; 2916 : {

	push	ecx
	push	ebx

; 2917 : 	if(pPlayer->GetEconomicAI()->GetNavalReconState() == RECON_STATE_NEEDED)

	mov	ebx, DWORD PTR _pPlayer$[esp+4]
	push	esi
	mov	ecx, ebx
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	cmp	DWORD PTR [eax+32], 2
	jne	$LN68@IsTestStra@26

; 2918 : 	{
; 2919 : 		if(GET_TEAM(pPlayer->getTeam()).canEmbarkAllWaterPassage())  // get a caravel out there NOW!

	mov	eax, DWORD PTR [ebx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN39@IsTestStra@26
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN40@IsTestStra@26
$LN39@IsTestStra@26:
	or	eax, -1
$LN40@IsTestStra@26:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ ; CvTeam::canEmbarkAllWaterPassage
	test	al, al
	je	$LN29@IsTestStra@26

; 2920 : 		{
; 2921 : 			CvUnit* pLoopUnit;
; 2922 : 			CvCity* pLoopCity;
; 2923 : 			int iLoop;
; 2924 : 
; 2925 : 			// Current Units
; 2926 : 			for(pLoopUnit = pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$227862[esp+16]
	push	eax
	mov	ecx, ebx
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN26@IsTestStra@26
$LL28@IsTestStra@26:

; 2927 : 			{
; 2928 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA && !pLoopUnit->isTerrainImpassable(TERRAIN_OCEAN))

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	jne	SHORT $LN27@IsTestStra@26
	mov	ecx, DWORD PTR [esi+1996]
	cmp	DWORD PTR [ecx+24], 0
	jle	SHORT $LN68@IsTestStra@26
$LN27@IsTestStra@26:

; 2920 : 		{
; 2921 : 			CvUnit* pLoopUnit;
; 2922 : 			CvCity* pLoopCity;
; 2923 : 			int iLoop;
; 2924 : 
; 2925 : 			// Current Units
; 2926 : 			for(pLoopUnit = pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$227862[esp+16]
	push	edx
	mov	ecx, ebx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL28@IsTestStra@26
$LN26@IsTestStra@26:
	push	ebp
	push	edi

; 2931 : 				}
; 2932 : 			}
; 2933 : 
; 2934 : 			// Figure out which Promotion is the one which makes a unit not cross oceans
; 2935 : 			PromotionTypes eOceanImpassablePromotion = NO_PROMOTION;
; 2936 : #ifdef AUI_WARNING_FIXES
; 2937 : 			for (uint iI = 0; iI < GC.getNumPromotionInfos(); iI++)
; 2938 : #else
; 2939 : 			for(int iI = 0; iI < GC.getNumPromotionInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	or	ebp, -1
	xor	edi, edi
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	test	eax, eax
	jle	SHORT $LN22@IsTestStra@26
$LL78@IsTestStra@26:

; 2940 : #endif
; 2941 : 			{
; 2942 : 				const PromotionTypes eLoopPromotion = static_cast<PromotionTypes>(iI);
; 2943 : 				CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(eLoopPromotion);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	mov	esi, eax

; 2944 : 				if(pkPromotionInfo)

	test	esi, esi
	je	SHORT $LN23@IsTestStra@26

; 2945 : 				{
; 2946 : 					if(pkPromotionInfo->GetTerrainImpassable(TERRAIN_OCEAN) && pkPromotionInfo->GetTerrainPassableTech(TERRAIN_OCEAN) == -1)

	push	6
	mov	ecx, esi
	call	?GetTerrainImpassable@CvPromotionEntry@@QBE_NH@Z ; CvPromotionEntry::GetTerrainImpassable
	test	al, al
	je	SHORT $LN23@IsTestStra@26
	push	6
	mov	ecx, esi
	call	?GetTerrainPassableTech@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetTerrainPassableTech
	cmp	eax, -1
	je	SHORT $LN69@IsTestStra@26
$LN23@IsTestStra@26:

; 2931 : 				}
; 2932 : 			}
; 2933 : 
; 2934 : 			// Figure out which Promotion is the one which makes a unit not cross oceans
; 2935 : 			PromotionTypes eOceanImpassablePromotion = NO_PROMOTION;
; 2936 : #ifdef AUI_WARNING_FIXES
; 2937 : 			for (uint iI = 0; iI < GC.getNumPromotionInfos(); iI++)
; 2938 : #else
; 2939 : 			for(int iI = 0; iI < GC.getNumPromotionInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	cmp	edi, eax
	jl	SHORT $LL78@IsTestStra@26

; 2996 : 					{
; 2997 : 						if(pkUnitEntry->GetDomainType() == DOMAIN_SEA && pkUnitEntry->GetDefaultUnitAIType() == UNITAI_EXPLORE_SEA)

	jmp	SHORT $LN22@IsTestStra@26
$LN68@IsTestStra@26:
	pop	esi

; 2929 : 				{
; 2930 : 					return false;

	xor	al, al
	pop	ebx

; 3005 : 		}
; 3006 : 	}
; 3007 : 
; 3008 : 	return false;
; 3009 : }

	pop	ecx
	ret	0
$LN69@IsTestStra@26:

; 2947 : 					{
; 2948 : 						eOceanImpassablePromotion = eLoopPromotion;

	mov	ebp, edi
$LN22@IsTestStra@26:

; 2949 : 						break;
; 2950 : 					}
; 2951 : 				}
; 2952 : 			}
; 2953 : 
; 2954 : 			// Units being trained now
; 2955 : 			for(pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$227862[esp+24]
	push	eax
	mov	ecx, ebx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN17@IsTestStra@26
	npad	6
$LL19@IsTestStra@26:

; 2956 : 			{
; 2957 : 				if(pLoopCity->isProductionUnit())

	mov	ecx, esi
	call	?isProductionUnit@CvCity@@QBE_NXZ	; CvCity::isProductionUnit
	test	al, al
	je	SHORT $LN18@IsTestStra@26

; 2958 : 				{
; 2959 : 					CvUnitEntry* pkUnitEntry = GC.getUnitInfo(pLoopCity->getProductionUnit());

	mov	ecx, esi
	call	?getProductionUnit@CvCity@@QBE?AW4UnitTypes@@XZ ; CvCity::getProductionUnit
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	esi, eax

; 2960 : 					if(pkUnitEntry)

	test	esi, esi
	je	SHORT $LN18@IsTestStra@26

; 2961 : 					{
; 2962 : 						if(pkUnitEntry->GetDomainType() == DOMAIN_SEA && pkUnitEntry->GetDefaultUnitAIType() == UNITAI_EXPLORE_SEA)

	mov	ecx, esi
	call	?GetDomainType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDomainType
	test	eax, eax
	jne	SHORT $LN18@IsTestStra@26
	mov	ecx, esi
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType
	cmp	eax, 21					; 00000015H
	jne	SHORT $LN18@IsTestStra@26

; 2963 : 						{
; 2964 : 							if(!pkUnitEntry->GetFreePromotions(eOceanImpassablePromotion))

	push	ebp
	mov	ecx, esi
	call	?GetFreePromotions@CvUnitEntry@@QBE_NH@Z ; CvUnitEntry::GetFreePromotions
	test	al, al
	je	SHORT $LN70@IsTestStra@26
$LN18@IsTestStra@26:

; 2949 : 						break;
; 2950 : 					}
; 2951 : 				}
; 2952 : 			}
; 2953 : 
; 2954 : 			// Units being trained now
; 2955 : 			for(pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$227862[esp+24]
	push	ecx
	mov	ecx, ebx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL19@IsTestStra@26
$LN17@IsTestStra@26:
	pop	edi
	pop	ebp
	pop	esi

; 2967 : 							}
; 2968 : 						}
; 2969 : 					}
; 2970 : 				}
; 2971 : 			}
; 2972 : 			return true;

	mov	al, 1
	pop	ebx

; 3005 : 		}
; 3006 : 	}
; 3007 : 
; 3008 : 	return false;
; 3009 : }

	pop	ecx
	ret	0
$LN70@IsTestStra@26:
	pop	edi
	pop	ebp
	pop	esi

; 2965 : 							{
; 2966 : 								return false;

	xor	al, al
	pop	ebx

; 3005 : 		}
; 3006 : 	}
; 3007 : 
; 3008 : 	return false;
; 3009 : }

	pop	ecx
	ret	0
$LN29@IsTestStra@26:

; 2973 : 		}
; 2974 : 		else if(GET_TEAM(pPlayer->getTeam()).canEmbark())  // get a trireme out there NOW!

	mov	eax, DWORD PTR [ebx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN56@IsTestStra@26
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN57@IsTestStra@26
$LN56@IsTestStra@26:
	or	eax, -1
$LN57@IsTestStra@26:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?canEmbark@CvTeam@@QBE_NXZ		; CvTeam::canEmbark
	test	al, al
	je	$LN68@IsTestStra@26

; 2975 : 		{
; 2976 : 			CvUnit* pLoopUnit;
; 2977 : 			CvCity* pLoopCity;
; 2978 : 			int iLoop;
; 2979 : 
; 2980 : 			// Current Units
; 2981 : 			for(pLoopUnit = pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$227889[esp+16]
	push	edx
	mov	ecx, ebx
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	test	eax, eax
	je	SHORT $LN79@IsTestStra@26
$LL10@IsTestStra@26:

; 2982 : 			{
; 2983 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA)

	mov	ecx, eax
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	je	$LN68@IsTestStra@26
	push	0
	lea	eax, DWORD PTR _iLoop$227889[esp+16]
	push	eax
	mov	ecx, ebx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	test	eax, eax
	jne	SHORT $LL10@IsTestStra@26
$LN79@IsTestStra@26:

; 2984 : 				{
; 2985 : 					return false;
; 2986 : 				}
; 2987 : 			}
; 2988 : 
; 2989 : 			// Units being trained now
; 2990 : 			for(pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$227889[esp+16]
	push	ecx
	mov	ecx, ebx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN4@IsTestStra@26
$LL6@IsTestStra@26:

; 2991 : 			{
; 2992 : 				if(pLoopCity->isProductionUnit())

	mov	ecx, esi
	call	?isProductionUnit@CvCity@@QBE_NXZ	; CvCity::isProductionUnit
	test	al, al
	je	SHORT $LN5@IsTestStra@26

; 2993 : 				{
; 2994 : 					CvUnitEntry* pkUnitEntry = GC.getUnitInfo(pLoopCity->getProductionUnit());

	mov	ecx, esi
	call	?getProductionUnit@CvCity@@QBE?AW4UnitTypes@@XZ ; CvCity::getProductionUnit
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	esi, eax

; 2995 : 					if(pkUnitEntry)

	test	esi, esi
	je	SHORT $LN5@IsTestStra@26

; 2996 : 					{
; 2997 : 						if(pkUnitEntry->GetDomainType() == DOMAIN_SEA && pkUnitEntry->GetDefaultUnitAIType() == UNITAI_EXPLORE_SEA)

	mov	ecx, esi
	call	?GetDomainType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDomainType
	test	eax, eax
	jne	SHORT $LN5@IsTestStra@26
	mov	ecx, esi
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType
	cmp	eax, 21					; 00000015H
	je	$LN68@IsTestStra@26
$LN5@IsTestStra@26:

; 2984 : 				{
; 2985 : 					return false;
; 2986 : 				}
; 2987 : 			}
; 2988 : 
; 2989 : 			// Units being trained now
; 2990 : 			for(pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$227889[esp+16]
	push	edx
	mov	ecx, ebx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL6@IsTestStra@26
$LN4@IsTestStra@26:
	pop	esi

; 2998 : 						{
; 2999 : 							return false;
; 3000 : 						}
; 3001 : 					}
; 3002 : 				}
; 3003 : 			}
; 3004 : 			return true;

	mov	al, 1
	pop	ebx

; 3005 : 		}
; 3006 : 	}
; 3007 : 
; 3008 : 	return false;
; 3009 : }

	pop	ecx
	ret	0
?IsTestStrategy_ReallyNeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_ReallyNeedReconSea
_TEXT	ENDS
PUBLIC	?IsTestStrategy_DevelopingReligion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_DevelopingReligion
EXTRN	?GetNumReligionsStillToFound@CvGameReligions@@QBEHXZ:PROC ; CvGameReligions::GetNumReligionsStillToFound
EXTRN	?HasCreatedPantheon@CvGameReligions@@QBE_NW4PlayerTypes@@@Z:PROC ; CvGameReligions::HasCreatedPantheon
EXTRN	?HasCreatedReligion@CvGameReligions@@QBE_NW4PlayerTypes@@@Z:PROC ; CvGameReligions::HasCreatedReligion
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_DevelopingReligion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_DevelopingReligion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_DevelopingReligion, COMDAT

; 3057 : {

	push	edi

; 3058 : 	if(pPlayer->isHuman())

	mov	edi, DWORD PTR _pPlayer$[esp]
	mov	ecx, edi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN4@IsTestStra@27

; 3059 : 	{
; 3060 : 		return false;

	xor	al, al
	pop	edi

; 3080 : }

	ret	0
$LN4@IsTestStra@27:

; 3061 : 	}
; 3062 : 
; 3063 : 	// Always true if we've already created a religion
; 3064 : 	CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	esi, eax

; 3065 : 	if(pReligions->HasCreatedReligion(pPlayer->GetID()))

	mov	eax, DWORD PTR [edi+44]
	push	eax
	mov	ecx, esi
	call	?HasCreatedReligion@CvGameReligions@@QBE_NW4PlayerTypes@@@Z ; CvGameReligions::HasCreatedReligion
	test	al, al

; 3066 : 	{
; 3067 : 		return true;

	jne	SHORT $LN18@IsTestStra@27

; 3068 : 	}
; 3069 : 
; 3070 : 	// Also true if created a pantheon and there are religions left to create
; 3071 : 	if(pReligions->HasCreatedPantheon(pPlayer->GetID()))

	mov	edi, DWORD PTR [edi+44]
	push	edi
	mov	ecx, esi
	call	?HasCreatedPantheon@CvGameReligions@@QBE_NW4PlayerTypes@@@Z ; CvGameReligions::HasCreatedPantheon
	test	al, al
	je	SHORT $LN1@IsTestStra@27

; 3072 : 	{
; 3073 : 		if(pReligions->GetNumReligionsStillToFound() > 0)

	mov	ecx, esi
	call	?GetNumReligionsStillToFound@CvGameReligions@@QBEHXZ ; CvGameReligions::GetNumReligionsStillToFound
	test	eax, eax
	jle	SHORT $LN1@IsTestStra@27
$LN18@IsTestStra@27:
	pop	esi

; 3074 : 		{
; 3075 : 			return true;

	mov	al, 1
	pop	edi

; 3080 : }

	ret	0
$LN1@IsTestStra@27:
	pop	esi

; 3076 : 		}
; 3077 : 	}
; 3078 : 
; 3079 : 	return false;

	xor	al, al
	pop	edi

; 3080 : }

	ret	0
?IsTestStrategy_DevelopingReligion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_DevelopingReligion
_TEXT	ENDS
PUBLIC	__real@3d4ccccd
PUBLIC	?IsTestStrategy_TechLeader@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_TechLeader
EXTRN	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ:PROC	; CvTeamTechs::GetNumTechsKnown
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ:PROC ; CvPlayer::GetEspionageAI
;	COMDAT __real@3d4ccccd
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?IsTestStrategy_TechLeader@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_iNumPlayersAheadInTech$ = -12				; size = 4
_fRatio$227956 = -8					; size = 4
_iNumOtherPlayers$ = -8					; size = 4
tv397 = -4						; size = 4
_fCutOff$227958 = -4					; size = 4
_iMyTechNum$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_TechLeader@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_TechLeader, COMDAT

; 3084 : {

	sub	esp, 12					; 0000000cH
	push	esi

; 3085 : 	if (pPlayer->isHuman())

	mov	esi, DWORD PTR _pPlayer$[esp+12]
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN16@IsTestStra@28
$LN66@IsTestStra@28:

; 3086 : 	{
; 3087 : 		return false;

	xor	al, al
	pop	esi

; 3149 : 	}
; 3150 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN16@IsTestStra@28:

; 3088 : 	}
; 3089 : 
; 3090 : 	// don't evaluate if espionage hasn't started yet
; 3091 : 	if (pPlayer->GetEspionageAI()->m_iTurnEspionageStarted == -1)

	mov	ecx, esi
	call	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ ; CvPlayer::GetEspionageAI
	cmp	DWORD PTR [eax+736], -1

; 3092 : 	{
; 3093 : 		return false;

	je	SHORT $LN66@IsTestStra@28

; 3094 : 	}
; 3095 : 
; 3096 : 	int iMyTechNum = GET_TEAM(pPlayer->getTeam()).GetTeamTechs()->GetNumTechsKnown();

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN23@IsTestStra@28
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN24@IsTestStra@28
$LN23@IsTestStra@28:
	or	eax, -1
$LN24@IsTestStra@28:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebx
	push	ebp
	push	edi
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ	; CvTeamTechs::GetNumTechsKnown

; 3097 : 
; 3098 : 	int iNumOtherPlayers = 0;

	xor	ebx, ebx

; 3099 : 	int iNumPlayersAheadInTech = 0;

	xor	ebp, ebp

; 3100 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	xor	edi, edi
	mov	DWORD PTR _iMyTechNum$[esp+28], eax
	xor	esi, esi
	npad	4
$LL14@IsTestStra@28:

; 3101 : 	{
; 3102 : 		PlayerTypes ePlayer = (PlayerTypes)ui;
; 3103 : 		if(!GET_PLAYER(ePlayer).isAlive())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR [esi+eax+2256], 0
	je	SHORT $LN13@IsTestStra@28

; 3104 : 		{
; 3105 : 			continue;
; 3106 : 		}
; 3107 : 
; 3108 : 		if (ePlayer == pPlayer->GetID())

	mov	ecx, DWORD PTR _pPlayer$[esp+24]
	cmp	edi, DWORD PTR [ecx+44]
	je	SHORT $LN13@IsTestStra@28

; 3109 : 		{
; 3110 : 			continue;
; 3111 : 		}
; 3112 : 
; 3113 : 		iNumOtherPlayers++;
; 3114 : 		int iNumTechs = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();

	mov	eax, DWORD PTR [esi+eax+44]
	inc	ebx
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN46@IsTestStra@28
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN47@IsTestStra@28
$LN46@IsTestStra@28:
	or	eax, -1
$LN47@IsTestStra@28:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ	; CvTeamTechs::GetNumTechsKnown

; 3115 : 		if (iNumTechs > iMyTechNum)

	cmp	eax, DWORD PTR _iMyTechNum$[esp+28]
	jle	SHORT $LN13@IsTestStra@28

; 3116 : 		{
; 3117 : 			iNumPlayersAheadInTech++;

	inc	ebp
$LN13@IsTestStra@28:

; 3100 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	add	esi, 63236				; 0000f704H
	inc	edi
	cmp	esi, 1391192				; 00153a58H
	jb	SHORT $LL14@IsTestStra@28

; 3116 : 		{
; 3117 : 			iNumPlayersAheadInTech++;

	mov	DWORD PTR _iNumPlayersAheadInTech$[esp+28], ebp
	mov	DWORD PTR _iNumOtherPlayers$[esp+28], ebx

; 3118 : 		}
; 3119 : 	}
; 3120 : 
; 3121 : 	if (iNumOtherPlayers > 0)

	test	ebx, ebx
	jle	$LN8@IsTestStra@28

; 3122 : 	{
; 3123 : 		FlavorTypes eFlavorEspionage = NO_FLAVOR;
; 3124 : 		for (int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	xor	esi, esi
	or	ebp, -1
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, esi
	jle	SHORT $LN5@IsTestStra@28
	mov	ebx, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	xor	edi, edi
	npad	8
$LL7@IsTestStra@28:

; 3125 : 		{
; 3126 : 			FlavorTypes eFlavor = (FlavorTypes)iFlavor;
; 3127 : 			if (GC.getFlavorTypes(eFlavor) == "FLAVOR_ESPIONAGE")

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [edi+edx]
	push	OFFSET $SG227955
	push	eax
	call	ebx
	add	esp, 8
	test	al, al
	je	SHORT $LN6@IsTestStra@28

; 3128 : 			{
; 3129 : 				eFlavorEspionage = eFlavor;

	mov	ebp, esi
$LN6@IsTestStra@28:

; 3122 : 	{
; 3123 : 		FlavorTypes eFlavorEspionage = NO_FLAVOR;
; 3124 : 		for (int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	inc	esi
	add	edi, 28					; 0000001cH
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL7@IsTestStra@28
$LN5@IsTestStra@28:

; 3130 : 			}
; 3131 : 		}
; 3132 : 		CvAssertMsg(eFlavorEspionage != NO_FLAVOR, "Could not find espionage flavor!");
; 3133 : 
; 3134 : 		float fRatio = iNumPlayersAheadInTech / (float)iNumOtherPlayers;

	fild	DWORD PTR _iNumPlayersAheadInTech$[esp+28]

; 3135 : 		float fCutOff = (0.05f * pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavorEspionage));

	mov	ecx, DWORD PTR _pPlayer$[esp+24]
	push	ebp
	fidiv	DWORD PTR _iNumOtherPlayers$[esp+32]
	fstp	DWORD PTR _fRatio$227956[esp+32]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	DWORD PTR tv397[esp+28], eax
	fild	DWORD PTR tv397[esp+28]
	fmul	DWORD PTR __real@3d4ccccd
	fstp	DWORD PTR _fCutOff$227958[esp+28]

; 3136 : 
; 3137 : 		if (fRatio < fCutOff)

	fld	DWORD PTR _fRatio$227956[esp+28]
	fld	DWORD PTR _fCutOff$227958[esp+28]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN8@IsTestStra@28
	pop	edi
	pop	ebp
	pop	ebx

; 3138 : 		{
; 3139 : 			return true;

	mov	al, 1
	pop	esi

; 3149 : 	}
; 3150 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN8@IsTestStra@28:
	pop	edi
	pop	ebp
	pop	ebx

; 3140 : 		}
; 3141 : 		else
; 3142 : 		{
; 3143 : 			return false;
; 3144 : 		}
; 3145 : 	}
; 3146 : 	else
; 3147 : 	{
; 3148 : 		return false;

	xor	al, al
	pop	esi

; 3149 : 	}
; 3150 : }

	add	esp, 12					; 0000000cH
	ret	0
?IsTestStrategy_TechLeader@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_TechLeader
_TEXT	ENDS
PUBLIC	?IsTestStrategy_FoundCity@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_FoundCity
EXTRN	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z:PROC ; CvPlayer::GetBestSettlePlot
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?getArea@CvUnit@@QBEHXZ:PROC			; CvUnit::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_FoundCity@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_iBestArea$ = -12					; size = 4
_iUnitLoop$ = -8					; size = 4
_iSecondBestArea$ = -4					; size = 4
___formal$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_FoundCity@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_FoundCity, COMDAT

; 3436 : {

	sub	esp, 12					; 0000000cH
	push	esi

; 3437 : 	int iUnitLoop;
; 3438 : 	CvUnit* pLoopUnit;
; 3439 : 	CvUnit* pFirstSettler = 0;
; 3440 : 	int iLooseSettler = 0;
; 3441 : 	//int iStrategyWeight = 0;
; 3442 : 	int iFirstSettlerArea = -1;
; 3443 : 	int iBestArea;
; 3444 : 	int iSecondBestArea;
; 3445 : 	int iNumAreas;
; 3446 : 	int iArea = -1;
; 3447 : 
; 3448 : #ifdef NQM_AI_GIMP_NO_BUILDING_SETTLERS
; 3449 : 	if ((pPlayer->isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE)) || (!pPlayer->isHuman() && (GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS"))))

	mov	esi, DWORD PTR _pPlayer$[esp+12]
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN20@IsTestStra@29
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	5
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	jne	SHORT $LN19@IsTestStra@29
$LN20@IsTestStra@29:
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN22@IsTestStra@29
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG228120
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	jne	SHORT $LN19@IsTestStra@29
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG228121
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	test	al, al
	je	SHORT $LN22@IsTestStra@29
$LN19@IsTestStra@29:

; 3450 : #else
; 3451 : 	if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && pPlayer->isHuman())
; 3452 : #endif
; 3453 : 	{
; 3454 : 		return false;

	xor	al, al
	pop	esi

; 3535 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN22@IsTestStra@29:
	push	edi

; 3455 : 	}
; 3456 : 
; 3457 : 	// Never run this strategy for a human player
; 3458 : 	if(!pPlayer->isHuman())

	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN1@IsTestStra@29

; 3459 : 	{
; 3460 : 		// Look at map for loose settlers
; 3461 : 		for(pLoopUnit = pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	eax, DWORD PTR _iUnitLoop$[esp+24]
	push	eax
	mov	ecx, esi
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN1@IsTestStra@29
$LN58@IsTestStra@29:

; 3462 : 		{
; 3463 : 			if(pLoopUnit != NULL)
; 3464 : 			{
; 3465 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_SETTLE)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 1
	jne	SHORT $LN16@IsTestStra@29

; 3466 : 				{
; 3467 : 					if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, edi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN51@IsTestStra@29
$LN16@IsTestStra@29:

; 3459 : 	{
; 3460 : 		// Look at map for loose settlers
; 3461 : 		for(pLoopUnit = pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[esp+24]
	push	ecx
	mov	ecx, esi
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LN58@IsTestStra@29
$LN1@IsTestStra@29:
	pop	edi

; 3530 : 			}
; 3531 : 		}
; 3532 : 	}
; 3533 : 
; 3534 : 	return false;

	xor	al, al
	pop	esi

; 3535 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN51@IsTestStra@29:

; 3468 : 					{
; 3469 : 						iLooseSettler++;
; 3470 : 						iFirstSettlerArea = pLoopUnit->getArea();

	mov	ecx, edi
	call	?getArea@CvUnit@@QBEHXZ			; CvUnit::getArea

; 3471 : 						pFirstSettler = pLoopUnit;
; 3472 : 						break;
; 3473 : 					}
; 3474 : 				}
; 3475 : 			}
; 3476 : 		}
; 3477 : 
; 3478 : 		// Don't run this strategy if have 0 cities, in that case we just want to drop down a city wherever we happen to be
; 3479 : 		if (iLooseSettler && pPlayer->getNumCities() >= 1)

	mov	ecx, esi
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	jl	SHORT $LN1@IsTestStra@29

; 3480 : 		{
; 3481 : 			iNumAreas = pPlayer->GetBestSettleAreas(pPlayer->GetEconomicAI()->GetMinimumSettleFertility(), iBestArea, iSecondBestArea);

	mov	ecx, esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	eax, DWORD PTR [eax+48]
	lea	edx, DWORD PTR _iSecondBestArea$[esp+20]
	push	edx
	lea	ecx, DWORD PTR _iBestArea$[esp+24]
	push	ecx
	push	eax
	mov	ecx, esi
	call	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z ; CvPlayer::GetBestSettleAreas

; 3482 : 			if(iNumAreas == 0)

	test	eax, eax

; 3483 : 			{
; 3484 : 				return false;

	je	SHORT $LN1@IsTestStra@29

; 3485 : 			}
; 3486 : 
; 3487 : 			bool bCanEmbark = GET_TEAM(pPlayer->getTeam()).canEmbark() || pPlayer->GetPlayerTraits()->IsEmbarkedAllWater();

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN39@IsTestStra@29
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN40@IsTestStra@29
$LN39@IsTestStra@29:
	or	eax, -1
$LN40@IsTestStra@29:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?canEmbark@CvTeam@@QBE_NXZ		; CvTeam::canEmbark
	test	al, al
	jne	SHORT $LN25@IsTestStra@29
	mov	ecx, esi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	cmp	BYTE PTR [eax+336], 0
	je	$LN9@IsTestStra@29
$LN25@IsTestStra@29:

; 3488 : 			bool bWantEscort = false;
; 3489 : 
; 3490 : 			// CASE 1: we can go offshore
; 3491 : 			if (bCanEmbark && (pPlayer->getNumCities() > 1))

	mov	ecx, esi
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	jle	SHORT $LN9@IsTestStra@29

; 3492 : 			{
; 3493 : 				int iRandArea = GC.getGame().getJonRandNum(6, "Randomly choose an area to settle");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	push	OFFSET $SG228135
	push	6
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 3494 : 
; 3495 : 				if (iRandArea <= 1) // this is "pick best tile I know ignoring what area it is part of", in the early game this is usually the start landmass

	cmp	eax, 1
	jg	SHORT $LN8@IsTestStra@29

; 3496 : 				{
; 3497 : 					iArea = -1;

	or	ebx, -1

; 3498 : 					CvPlot* pPlot = pPlayer->GetBestSettlePlot(pFirstSettler, bWantEscort, -1);

	push	ebx
	push	0
	push	edi
	mov	ecx, esi
	call	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z ; CvPlayer::GetBestSettlePlot

; 3499 : 					if (!pPlot)

	test	eax, eax
	je	SHORT $LN54@IsTestStra@29
$LN3@IsTestStra@29:

; 3518 : 				}
; 3519 : 				else
; 3520 : 				{
; 3521 : 					pPlayer->addAIOperation(AI_OPERATION_QUICK_COLONIZE, NO_PLAYER, iArea);

	push	0
	push	0
	push	ebx
	push	-1
	push	12					; 0000000cH
	mov	ecx, esi
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	pop	ebx
	pop	edi

; 3522 : 				}
; 3523 : 
; 3524 : 				return true;

	mov	al, 1
	pop	esi

; 3535 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN8@IsTestStra@29:

; 3500 : 					{
; 3501 : 						bWantEscort = true;
; 3502 : 					}
; 3503 : 				}
; 3504 : 				else if (iRandArea == 2) // least likely
; 3505 : 				{
; 3506 : 					iArea = iSecondBestArea;

	mov	ebx, DWORD PTR _iSecondBestArea$[esp+24]

; 3507 : 					bWantEscort = IsAreaSafeForQuickColony(iArea, pPlayer);

	push	esi
	cmp	eax, 2
	je	SHORT $LN59@IsTestStra@29

; 3508 : 				}
; 3509 : 				else // this is as likely as the other options combined
; 3510 : 				{
; 3511 : 					iArea = iBestArea;

	mov	ebx, DWORD PTR _iBestArea$[esp+28]
$LN59@IsTestStra@29:

; 3512 : 					bWantEscort = IsAreaSafeForQuickColony(iArea, pPlayer);

	push	ebx
	call	?IsAreaSafeForQuickColony@EconomicAIHelpers@@YA_NHPAVCvPlayer@@@Z ; EconomicAIHelpers::IsAreaSafeForQuickColony
	add	esp, 8

; 3513 : 				}
; 3514 : 
; 3515 : 				if (bWantEscort)

	test	al, al
	je	SHORT $LN3@IsTestStra@29
$LN54@IsTestStra@29:

; 3516 : 				{
; 3517 : 					pPlayer->addAIOperation(AI_OPERATION_FOUND_CITY, NO_PLAYER, iArea);

	push	0
	push	0
	push	ebx
	push	-1
	push	4

; 3518 : 				}
; 3519 : 				else
; 3520 : 				{
; 3521 : 					pPlayer->addAIOperation(AI_OPERATION_QUICK_COLONIZE, NO_PLAYER, iArea);

	mov	ecx, esi
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	pop	ebx
	pop	edi

; 3522 : 				}
; 3523 : 
; 3524 : 				return true;

	mov	al, 1
	pop	esi

; 3535 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN9@IsTestStra@29:

; 3525 : 			}
; 3526 : 			else // we can't embark yet
; 3527 : 			{
; 3528 : 				pPlayer->addAIOperation(AI_OPERATION_FOUND_CITY, NO_PLAYER, iBestArea);

	mov	edx, DWORD PTR _iBestArea$[esp+20]
	push	0
	push	0
	push	edx
	push	-1
	push	4
	mov	ecx, esi
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
	pop	edi

; 3529 : 				return true;

	mov	al, 1
	pop	esi

; 3535 : }

	add	esp, 12					; 0000000cH
	ret	0
?IsTestStrategy_FoundCity@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_FoundCity
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedImprovement@EconomicAIHelpers@@YA_NPAVCvPlayer@@W4YieldTypes@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedImprovement
EXTRN	?GetYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetYieldChange
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z:PROC ; CvPlayer::canBuild
EXTRN	?getImprovement@CvBuildInfo@@QBEHXZ:PROC	; CvBuildInfo::getImprovement
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?getTechPrereq@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getTechPrereq
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
EXTRN	?getNumBuildInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildInfos
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedImprovement@EconomicAIHelpers@@YA_NPAVCvPlayer@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_iCityLoop$ = -20					; size = 4
_iNumCitiesConcerned$ = -16				; size = 4
_iUnitLoop$ = -12					; size = 4
_fWarningRatio$ = -12					; size = 8
_eImprovement$228230 = -4				; size = 4
_iNumCities$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
_eYield$ = 12						; size = 4
?IsTestStrategy_NeedImprovement@EconomicAIHelpers@@YA_NPAVCvPlayer@@W4YieldTypes@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedImprovement, COMDAT

; 3629 : 	// find the city strategy associated with this issue
; 3630 : 	AICityStrategyTypes eCityStrategy = NO_AICITYSTRATEGY;
; 3631 : 	switch(eYield)

	mov	eax, DWORD PTR _eYield$[esp-4]
	sub	esp, 20					; 00000014H
	push	ebx
	xor	ebx, ebx
	sub	eax, ebx
	push	esi
	je	SHORT $LN28@IsTestStra@30
	sub	eax, 1
	jne	SHORT $LN63@IsTestStra@30

; 3635 : 		break;
; 3636 : 	case YIELD_PRODUCTION:
; 3637 : 		eCityStrategy = (AICityStrategyTypes)GC.getInfoTypeForString("AICITYSTRATEGY_NEED_IMPROVEMENT_PRODUCTION");

	push	ebx
	push	OFFSET $SG228197

; 3638 : 		break;

	jmp	SHORT $LN70@IsTestStra@30
$LN28@IsTestStra@30:

; 3632 : 	{
; 3633 : 	case YIELD_FOOD:
; 3634 : 		eCityStrategy = (AICityStrategyTypes)GC.getInfoTypeForString("AICITYSTRATEGY_NEED_IMPROVEMENT_FOOD");

	push	ebx
	push	OFFSET $SG228194
$LN70@IsTestStra@30:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, eax

; 3639 : 	}
; 3640 : 
; 3641 : 	FAssertMsg(eCityStrategy != NO_AICITYSTRATEGY, "No strategy found. What?");
; 3642 : 	if(eCityStrategy == NO_AICITYSTRATEGY)

	cmp	esi, -1
	jne	SHORT $LN26@IsTestStra@30
$LN63@IsTestStra@30:
	pop	esi

; 3643 : 	{
; 3644 : 		return false;

	xor	al, al
	pop	ebx

; 3754 : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@IsTestStra@30:
	push	ebp

; 3645 : 	}
; 3646 : 
; 3647 : 	// if enough cities are worried about this problem
; 3648 : 	int iNumCities = pPlayer->getNumCities();

	mov	ebp, DWORD PTR _pPlayer$[esp+28]
	mov	ecx, ebp
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	DWORD PTR _iNumCities$[esp+32], eax

; 3649 : 	if(iNumCities == 0)

	cmp	eax, ebx
	jne	SHORT $LN25@IsTestStra@30
	pop	ebp
	pop	esi

; 3650 : 	{
; 3651 : 		return false; // no cities, no problem!

	xor	al, al
	pop	ebx

; 3754 : }

	add	esp, 20					; 00000014H
	ret	0
$LN25@IsTestStra@30:
	push	edi

; 3652 : 	}
; 3653 : 
; 3654 : 	int iCityLoop = 0;
; 3655 : 	CvCity* pLoopCity = NULL;
; 3656 : 	int iNumCitiesConcerned = 0;
; 3657 : 	for(pLoopCity = pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iCityLoop))

	push	ebx
	lea	eax, DWORD PTR _iCityLoop$[esp+40]
	xor	edi, edi
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR _iCityLoop$[esp+44], ebx
	mov	DWORD PTR _iNumCitiesConcerned$[esp+44], edi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	cmp	eax, ebx
	je	SHORT $LN22@IsTestStra@30
$LL24@IsTestStra@30:

; 3658 : 	{
; 3659 : 		if(pLoopCity->GetCityStrategyAI()->IsUsingCityStrategy(eCityStrategy))

	push	esi
	mov	ecx, eax
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::IsUsingCityStrategy
	test	al, al
	je	SHORT $LN23@IsTestStra@30

; 3660 : 		{
; 3661 : 			iNumCitiesConcerned++;

	inc	edi
$LN23@IsTestStra@30:

; 3652 : 	}
; 3653 : 
; 3654 : 	int iCityLoop = 0;
; 3655 : 	CvCity* pLoopCity = NULL;
; 3656 : 	int iNumCitiesConcerned = 0;
; 3657 : 	for(pLoopCity = pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iCityLoop))

	push	ebx
	lea	ecx, DWORD PTR _iCityLoop$[esp+40]
	push	ecx
	mov	ecx, ebp
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	cmp	eax, ebx
	jne	SHORT $LL24@IsTestStra@30

; 3660 : 		{
; 3661 : 			iNumCitiesConcerned++;

	mov	DWORD PTR _iNumCitiesConcerned$[esp+36], edi
$LN22@IsTestStra@30:

; 3662 : 		}
; 3663 : 	}
; 3664 : 
; 3665 : 	double fWarningRatio = GC.getAI_STRATEGY_NEED_IMPROVEMENT_CITY_RATIO();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+2016
	fstp	QWORD PTR _fWarningRatio$[esp+36]

; 3666 : 
; 3667 : 	// if not enough cities are upset
; 3668 : 	if((iNumCitiesConcerned / (double)iNumCities) < fWarningRatio)

	fild	DWORD PTR _iNumCitiesConcerned$[esp+36]
	fidiv	DWORD PTR _iNumCities$[esp+36]
	fcomp	QWORD PTR _fWarningRatio$[esp+36]
	fnstsw	ax
	test	ah, 5

; 3669 : 	{
; 3670 : 		return false;

	jnp	SHORT $LN58@IsTestStra@30

; 3671 : 	}
; 3672 : 
; 3673 : 	// see if there's a builder
; 3674 : 	int iUnitLoop = 0;
; 3675 : 	CvUnit* pLoopUnit = NULL;
; 3676 : 	CvUnit* pBuilder = NULL;
; 3677 : 	for(pLoopUnit = pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iUnitLoop))

	push	ebx
	lea	edx, DWORD PTR _iUnitLoop$[esp+40]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR _iUnitLoop$[esp+44], ebx
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	cmp	esi, ebx
	je	SHORT $LN58@IsTestStra@30
$LL19@IsTestStra@30:

; 3678 : 	{
; 3679 : 		if(pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	je	SHORT $LN55@IsTestStra@30
	push	ebx
	lea	eax, DWORD PTR _iUnitLoop$[esp+40]
	push	eax
	mov	ecx, ebp
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	cmp	esi, ebx
	jne	SHORT $LL19@IsTestStra@30
$LN58@IsTestStra@30:
	pop	edi
	pop	ebp
	pop	esi

; 3747 : 			{
; 3748 : 				return false;

	xor	al, al
	pop	ebx

; 3754 : }

	add	esp, 20					; 00000014H
	ret	0
$LN55@IsTestStra@30:

; 3680 : 		{
; 3681 : 			pBuilder = pLoopUnit;
; 3682 : 			break;
; 3683 : 		}
; 3684 : 	}
; 3685 : 
; 3686 : 	// if no builder, ignore
; 3687 : 	// perhaps prompt a builder?
; 3688 : 	if(!pBuilder)

	cmp	esi, ebx

; 3689 : 	{
; 3690 : 		return false;

	je	SHORT $LN58@IsTestStra@30

; 3691 : 	}
; 3692 : 
; 3693 : 	// is there a build that I can create to improve the yield?
; 3694 : 
; 3695 : 	// loop through the build types to find one that we can use
; 3696 : 	BuildTypes eBuild;
; 3697 : #ifdef AUI_WARNING_FIXES
; 3698 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 3699 : #else
; 3700 : 	int iBuildIndex;
; 3701 : 	for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	$LN12@IsTestStra@30
$LL67@IsTestStra@30:

; 3702 : #endif
; 3703 : 	{
; 3704 : 		eBuild = (BuildTypes)iBuildIndex;
; 3705 : 		CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 3706 : 		if(pkBuildInfo)

	test	eax, eax
	je	$LN13@IsTestStra@30

; 3707 : 		{
; 3708 : 			if(pkBuildInfo->getTechPrereq() != NO_TECH)

	mov	ecx, eax
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq
	cmp	eax, -1
	je	SHORT $LN9@IsTestStra@30

; 3709 : 			{
; 3710 : 				if(!(GET_TEAM(pPlayer->getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechPrereq())))

	mov	ecx, ebp
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	esi, eax
	imul	esi, 2984				; 00000ba8H
	add	esi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq
	push	eax
	mov	ecx, esi
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	$LN13@IsTestStra@30
$LN9@IsTestStra@30:

; 3711 : 				{
; 3712 : 					// don't have the tech needed for this build, so look at the next one
; 3713 : 					continue;
; 3714 : 				}
; 3715 : 			}
; 3716 : 
; 3717 : 			ImprovementTypes eImprovement = (ImprovementTypes)GC.getBuildInfo(eBuild)->getImprovement();

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	DWORD PTR _eImprovement$228230[esp+36], eax

; 3718 : 			if(eImprovement == NO_IMPROVEMENT)

	cmp	eax, -1
	je	SHORT $LN13@IsTestStra@30

; 3719 : 			{
; 3720 : 				continue;
; 3721 : 			}
; 3722 : 
; 3723 : 			CvPlotsVector& aPlots = pPlayer->GetPlots();

	mov	ecx, ebp
	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots
	mov	ebx, eax

; 3724 : 			bool bCanBuild = false;
; 3725 : 			for(uint ui = 0; ui < aPlots.size(); ui++)

	xor	esi, esi
	cmp	DWORD PTR [ebx+4], esi
	jbe	SHORT $LN13@IsTestStra@30
	npad	6
$LL7@IsTestStra@30:

; 3726 : 			{
; 3727 : 				if(aPlots[ui] < 0)

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+esi*4]
	test	eax, eax
	jl	SHORT $LN13@IsTestStra@30

; 3728 : 				{
; 3729 : 					break;
; 3730 : 				}
; 3731 : 
; 3732 : 				CvPlot* pPlot = GC.getMap().plotByIndex(aPlots[ui]);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN47@IsTestStra@30
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	jmp	SHORT $LN48@IsTestStra@30
$LN47@IsTestStra@30:
	xor	eax, eax
$LN48@IsTestStra@30:

; 3733 : 				if(pPlayer->canBuild(pPlot, eBuild, false /*test era*/, false /*test visible*/, false /*test gold*/))

	push	1
	push	0
	push	0
	push	0
	push	edi
	push	eax
	mov	ecx, ebp
	call	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z ; CvPlayer::canBuild
	test	al, al
	jne	SHORT $LN57@IsTestStra@30
	inc	esi
	cmp	esi, DWORD PTR [ebx+4]
	jb	SHORT $LL7@IsTestStra@30

; 3734 : 				{
; 3735 : 					bCanBuild = true;
; 3736 : 					break;
; 3737 : 				}
; 3738 : 			}
; 3739 : 
; 3740 : 			if(!bCanBuild)
; 3741 : 			{
; 3742 : 				continue;
; 3743 : 			}
; 3744 : 
; 3745 : 			// we can use an improvement that increases the yield
; 3746 : 			if(GC.getImprovementInfo(eImprovement)->GetYieldChange(eYield) > 0)

	jmp	SHORT $LN13@IsTestStra@30
$LN57@IsTestStra@30:
	mov	edx, DWORD PTR _eYield$[esp+32]
	mov	eax, DWORD PTR _eImprovement$228230[esp+36]
	push	edx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChange
	test	eax, eax
	jg	$LN58@IsTestStra@30
$LN13@IsTestStra@30:

; 3691 : 	}
; 3692 : 
; 3693 : 	// is there a build that I can create to improve the yield?
; 3694 : 
; 3695 : 	// loop through the build types to find one that we can use
; 3696 : 	BuildTypes eBuild;
; 3697 : #ifdef AUI_WARNING_FIXES
; 3698 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 3699 : #else
; 3700 : 	int iBuildIndex;
; 3701 : 	for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	edi, eax
	jl	$LL67@IsTestStra@30
$LN12@IsTestStra@30:
	pop	edi
	pop	ebp
	pop	esi

; 3749 : 			}
; 3750 : 		}
; 3751 : 	}
; 3752 : 
; 3753 : 	return true;

	mov	al, 1
	pop	ebx

; 3754 : }

	add	esp, 20					; 00000014H
	ret	0
?IsTestStrategy_NeedImprovement@EconomicAIHelpers@@YA_NPAVCvPlayer@@W4YieldTypes@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedImprovement
_TEXT	ENDS
PUBLIC	?IsTestStrategy_IslandStart@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_IslandStart
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
EXTRN	?getCanEmbarkCount@CvTeam@@QBEHXZ:PROC		; CvTeam::getCanEmbarkCount
EXTRN	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ:PROC ; CvPlayer::getStartingPlot
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_IslandStart@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_iRevealedCoastalTiles$ = -16				; size = 4
_iCoastalTiles$ = -12					; size = 4
tv295 = -8						; size = 4
_pStrategy$ = -4					; size = 4
_iStartArea$ = 8					; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_IslandStart@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_IslandStart, COMDAT

; 3835 : {

	sub	esp, 16					; 00000010H
	push	ebp

; 3836 : 	int iStartArea;
; 3837 : 	CvPlot* pLoopPlot;
; 3838 : 	int iCoastalTiles = 0;
; 3839 : 	int iRevealedCoastalTiles = 0;
; 3840 : 
; 3841 : 	CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	ebp, DWORD PTR _pPlayer$[esp+16]
	push	esi
	push	edi
	xor	edi, edi
	mov	ecx, ebp
	mov	DWORD PTR _iCoastalTiles$[esp+28], edi
	mov	DWORD PTR _iRevealedCoastalTiles$[esp+28], edi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _eStrategy$[esp+24]
	mov	eax, DWORD PTR [ecx+edx*4]

; 3842 : 
; 3843 : 	// Only kick off this strategy in the first 25 turns of the game (though it will last 50 turns once selected)
; 3844 : 	if(GC.getGame().getGameTurn() < 25 && pPlayer->getStartingPlot())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _pStrategy$[esp+28], eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, 25					; 00000019H
	jge	$LN1@IsTestStra@31
	mov	ecx, ebp
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	test	eax, eax
	je	$LN1@IsTestStra@31

; 3845 : 	{
; 3846 : 		if(GET_TEAM(pPlayer->getTeam()).getCanEmbarkCount() < 1)

	mov	eax, DWORD PTR [ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN24@IsTestStra@31
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN25@IsTestStra@31
$LN24@IsTestStra@31:
	or	eax, -1
$LN25@IsTestStra@31:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?getCanEmbarkCount@CvTeam@@QBEHXZ	; CvTeam::getCanEmbarkCount
	cmp	eax, 1
	jge	$LN1@IsTestStra@31

; 3847 : 		{
; 3848 : 			iStartArea = pPlayer->getStartingPlot()->getArea();

	mov	ecx, ebp
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot

; 3849 : 
; 3850 : 			// Have we revealed a high enough percentage of the coast of our landmass?
; 3851 : #ifdef AUI_WARNING_FIXES
; 3852 : 			for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 3853 : #else
; 3854 : 			for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	DWORD PTR [ecx+4028], edi
	mov	eax, DWORD PTR [eax+356]
	mov	DWORD PTR _iStartArea$[esp+24], eax
	jle	SHORT $LN5@IsTestStra@31
	push	ebx
	xor	ebx, ebx
	npad	10
$LL7@IsTestStra@31:

; 3855 : #endif
; 3856 : 			{
; 3857 : 				pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	esi, DWORD PTR [ecx+4068]

; 3858 : 				if(pLoopPlot->getArea() == iStartArea)

	mov	edx, DWORD PTR _iStartArea$[esp+28]
	add	esi, ebx
	cmp	DWORD PTR [esi+356], edx
	jne	SHORT $LN6@IsTestStra@31

; 3859 : 				{
; 3860 : 					if(pLoopPlot->isCoastalLand())

	push	-1
	mov	ecx, esi
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	test	al, al
	je	SHORT $LN3@IsTestStra@31

; 3861 : 					{
; 3862 : 						iCoastalTiles++;

	inc	DWORD PTR _iCoastalTiles$[esp+32]
$LN3@IsTestStra@31:

; 3863 : 					}
; 3864 : 					if(pLoopPlot->isRevealed(pPlayer->getTeam()))

	mov	ecx, ebp
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	DWORD PTR tv295[esp+32], ecx
	mov	ecx, eax
	mov	eax, DWORD PTR tv295[esp+32]
	sub	ecx, eax
	mov	eax, 1
	shl	eax, cl

; 3865 : 					{
; 3866 : 						iRevealedCoastalTiles++;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	test	eax, DWORD PTR [esi+edx*4+8]
	je	SHORT $LN6@IsTestStra@31
	inc	DWORD PTR _iRevealedCoastalTiles$[esp+32]
$LN6@IsTestStra@31:

; 3849 : 
; 3850 : 			// Have we revealed a high enough percentage of the coast of our landmass?
; 3851 : #ifdef AUI_WARNING_FIXES
; 3852 : 			for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 3853 : #else
; 3854 : 			for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	inc	edi
	add	ebx, 484				; 000001e4H
	cmp	edi, DWORD PTR [ecx+4028]
	jl	SHORT $LL7@IsTestStra@31
	pop	ebx
$LN5@IsTestStra@31:

; 3867 : 					}
; 3868 : 				}
; 3869 : 			}
; 3870 : 
; 3871 : 			if((iRevealedCoastalTiles * 100 / (iCoastalTiles + 1)) > GC.getAI_STRATEGY_ISLAND_START_COAST_REVEAL_PERCENT() &&
; 3872 : 			        GC.getMap().getArea(iStartArea)->getNumTiles() < pStrategy->GetWeightThreshold())

	mov	eax, DWORD PTR _iRevealedCoastalTiles$[esp+28]
	mov	edx, DWORD PTR _iCoastalTiles$[esp+28]
	imul	eax, 100				; 00000064H
	lea	esi, DWORD PTR [edx+1]
	cdq
	idiv	esi
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2020
	jle	SHORT $LN1@IsTestStra@31
	mov	edx, DWORD PTR _iStartArea$[esp+24]
	mov	eax, DWORD PTR _pStrategy$[esp+28]
	mov	esi, DWORD PTR [eax+268]
	push	edx
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	cmp	eax, esi
	jge	SHORT $LN1@IsTestStra@31
	pop	edi
	pop	esi

; 3873 : 			{
; 3874 : 				return true;

	mov	al, 1
	pop	ebp

; 3880 : }

	add	esp, 16					; 00000010H
	ret	0
$LN1@IsTestStra@31:
	pop	edi
	pop	esi

; 3875 : 			}
; 3876 : 		}
; 3877 : 	}
; 3878 : 
; 3879 : 	return false;

	xor	al, al
	pop	ebp

; 3880 : }

	add	esp, 16					; 00000010H
	ret	0
?IsTestStrategy_IslandStart@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_IslandStart
_TEXT	ENDS
PUBLIC	?IsTestStrategy_GS_SpaceshipHomestretch@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch
EXTRN	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z:PROC ; CvTeam::getProjectCount
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_GS_SpaceshipHomestretch@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_GS_SpaceshipHomestretch@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch, COMDAT

; 4143 : 	// if I already built the Apollo Program I should follow through
; 4144 : 	ProjectTypes eApolloProgram = (ProjectTypes) GC.getInfoTypeForString("PROJECT_APOLLO_PROGRAM", true);

	push	1
	push	OFFSET $SG228448
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4145 : 	if(eApolloProgram != NO_PROJECT)

	cmp	eax, -1
	je	SHORT $LN1@IsTestStra@32

; 4146 : 	{
; 4147 : 		if(GET_TEAM(pPlayer->getTeam()).getProjectCount(eApolloProgram) > 0)

	mov	ecx, DWORD PTR _pPlayer$[esp-4]
	mov	ecx, DWORD PTR [ecx+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN9@IsTestStra@32
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN10@IsTestStra@32
$LN9@IsTestStra@32:
	or	ecx, -1
$LN10@IsTestStra@32:
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	test	eax, eax
	jle	SHORT $LN1@IsTestStra@32

; 4148 : 		{
; 4149 : 			return true;

	mov	al, 1

; 4154 : }

	ret	0
$LN1@IsTestStra@32:

; 4150 : 		}
; 4151 : 	}
; 4152 : 
; 4153 : 	return false;

	xor	al, al

; 4154 : }

	ret	0
?IsTestStrategy_GS_SpaceshipHomestretch@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch
_TEXT	ENDS
PUBLIC	?IsTestStrategy_NeedGuilds@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedGuilds
EXTRN	?GetFirstCityWithBuildingClass@CvPlayer@@QAEPAVCvCity@@W4BuildingClassTypes@@@Z:PROC ; CvPlayer::GetFirstCityWithBuildingClass
EXTRN	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetBuildingClassType
EXTRN	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetPrereqAndTech
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
; Function compile flags: /Ogtpy
;	COMDAT ?IsTestStrategy_NeedGuilds@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedGuilds@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedGuilds, COMDAT

; 4212 : 	CvTeam &kTeam = GET_TEAM(pPlayer->getTeam());

	mov	eax, DWORD PTR _pPlayer$[esp-4]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN16@IsTestStra@33
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN17@IsTestStra@33
$LN16@IsTestStra@33:
	or	eax, -1
$LN17@IsTestStra@33:
	push	ebx
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebp
	push	esi
	push	edi

; 4213 : 
; 4214 : 	BuildingTypes eWritersGuild = (BuildingTypes)GC.getInfoTypeForString("BUILDING_WRITERS_GUILD", true);

	push	1
	push	OFFSET $SG228483
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebx, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4215 : 	BuildingTypes eArtistsGuild = (BuildingTypes)GC.getInfoTypeForString("BUILDING_ARTISTS_GUILD", true);

	push	1
	push	OFFSET $SG228486
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	esi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4216 : 	BuildingTypes eMusiciansGuild = (BuildingTypes)GC.getInfoTypeForString("BUILDING_MUSICIANS_GUILD", true);

	push	1
	push	OFFSET $SG228489
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 4217 : 
; 4218 : 	CvBuildingEntry *pkBuilding;
; 4219 : 	pkBuilding = GC.getBuildingInfo(eWritersGuild);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	ebp, eax
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	esi, eax

; 4220 : 	if (pkBuilding)

	test	esi, esi
	je	SHORT $LN7@IsTestStra@33

; 4221 : 	{
; 4222 : 		if (kTeam.GetTeamTechs()->HasTech((TechTypes)pkBuilding->GetPrereqAndTech()))

	mov	ecx, esi
	call	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPrereqAndTech
	push	eax
	mov	ecx, ebx
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN7@IsTestStra@33

; 4223 : 		{
; 4224 : 			if (pPlayer->GetFirstCityWithBuildingClass((BuildingClassTypes)pkBuilding->GetBuildingClassType()) == NULL)

	mov	ecx, esi
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	mov	ecx, DWORD PTR _pPlayer$[esp+12]
	push	eax
	call	?GetFirstCityWithBuildingClass@CvPlayer@@QAEPAVCvCity@@W4BuildingClassTypes@@@Z ; CvPlayer::GetFirstCityWithBuildingClass
	test	eax, eax
	jne	SHORT $LN7@IsTestStra@33
$LN24@IsTestStra@33:
	pop	edi
	pop	esi
	pop	ebp

; 4225 : 			{
; 4226 : 				return true;

	mov	al, 1
	pop	ebx

; 4254 : }

	ret	0
$LN7@IsTestStra@33:

; 4227 : 			}
; 4228 : 		}
; 4229 : 	}
; 4230 : 	pkBuilding = GC.getBuildingInfo(eArtistsGuild);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	esi, eax

; 4231 : 	if (pkBuilding)

	test	esi, esi
	je	SHORT $LN23@IsTestStra@33

; 4232 : 	{
; 4233 : 		if (kTeam.GetTeamTechs()->HasTech((TechTypes)pkBuilding->GetPrereqAndTech()))

	mov	ecx, esi
	call	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPrereqAndTech
	push	eax
	mov	ecx, ebx
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN23@IsTestStra@33

; 4234 : 		{
; 4235 : 			if (pPlayer->GetFirstCityWithBuildingClass((BuildingClassTypes)pkBuilding->GetBuildingClassType()) == NULL)

	mov	ecx, esi
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	mov	ecx, DWORD PTR _pPlayer$[esp+12]
	push	eax
	call	?GetFirstCityWithBuildingClass@CvPlayer@@QAEPAVCvCity@@W4BuildingClassTypes@@@Z ; CvPlayer::GetFirstCityWithBuildingClass
	test	eax, eax

; 4236 : 			{
; 4237 : 				return true;

	je	SHORT $LN24@IsTestStra@33
$LN23@IsTestStra@33:

; 4238 : 			}
; 4239 : 		}
; 4240 : 	}
; 4241 : 	pkBuilding = GC.getBuildingInfo(eMusiciansGuild);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	esi, eax

; 4242 : 	if (pkBuilding)

	test	esi, esi
	je	SHORT $LN1@IsTestStra@33

; 4243 : 	{
; 4244 : 		if (kTeam.GetTeamTechs()->HasTech((TechTypes)pkBuilding->GetPrereqAndTech()))

	mov	ecx, esi
	call	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPrereqAndTech
	push	eax
	mov	ecx, ebx
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN1@IsTestStra@33

; 4245 : 		{
; 4246 : 			if (pPlayer->GetFirstCityWithBuildingClass((BuildingClassTypes)pkBuilding->GetBuildingClassType()) == NULL)

	mov	ecx, esi
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	mov	ecx, DWORD PTR _pPlayer$[esp+12]
	push	eax
	call	?GetFirstCityWithBuildingClass@CvPlayer@@QAEPAVCvCity@@W4BuildingClassTypes@@@Z ; CvPlayer::GetFirstCityWithBuildingClass
	test	eax, eax

; 4247 : 			{
; 4248 : 				return true;

	je	$LN24@IsTestStra@33
$LN1@IsTestStra@33:
	pop	edi
	pop	esi
	pop	ebp

; 4249 : 			}
; 4250 : 		}
; 4251 : 	}
; 4252 : 
; 4253 : 	return false;

	xor	al, al
	pop	ebx

; 4254 : }

	ret	0
?IsTestStrategy_NeedGuilds@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedGuilds
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@XZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@XZ PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@XZ ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@XZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@XZ PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@XZ ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::end
_TEXT	ENDS
PUBLIC	??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z PROC ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 296  : 	FFastVector(const THIS_TYPE& RHS)

	push	ebx

; 297  : 	{
; 298  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	ebx, DWORD PTR _RHS$[esp]
	xor	eax, eax
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], ecx

; 299  : 		m_uiCurrMaxSize = RHS.m_uiCurrMaxSize;

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [esi+8], edx

; 300  : 		if( RHS.m_uiCurrMaxSize)

	cmp	DWORD PTR [ebx+8], eax
	je	SHORT $LN1@FFastVecto
	push	edi

; 301  : 		{
; 302  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	edi, DWORD PTR [ebx+8]
	cmp	edi, eax
	jbe	SHORT $LN6@FFastVecto
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
$LN6@FFastVecto:
	mov	DWORD PTR [esi], eax
	pop	edi
$LN1@FFastVecto:

; 303  : 		}
; 304  : #ifdef BREAK_ON_REPEATED_RESIZE
; 305  : 		m_nResizeTimes = 0;
; 306  : #endif
; 307  : 		Copy(RHS);

	push	ebx
	mov	ecx, esi
	call	?Copy@?$BaseVector@I$0A@@@IAEXABV1@@Z	; BaseVector<unsigned int,0>::Copy

; 308  : 	};

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z ENDP ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z PROC ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	esi
	xor	eax, eax
	push	edi

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	mov	edi, DWORD PTR _uiStartingMaxSize$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	jbe	SHORT $LN5@FFastVecto@2
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
$LN5@FFastVecto@2:
	mov	DWORD PTR [esi], eax
	pop	edi

; 315  : 	};

	mov	eax, esi
	pop	esi
	ret	4
??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z ENDP ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ PROC ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 318  : 	};

	ret	0
??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ ENDP ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z PROC ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	esi
	xor	eax, eax
	push	edi

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	mov	edi, DWORD PTR _uiStartingMaxSize$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	jbe	SHORT $LN5@FFastVecto@3
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
$LN5@FFastVecto@3:
	mov	DWORD PTR [esi], eax
	pop	edi

; 315  : 	};

	mov	eax, esi
	pop	esi
	ret	4
??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z ENDP ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ PROC ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 318  : 	};

	ret	0
??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ENDP ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z PROC ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	esi
	xor	eax, eax
	push	edi

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	mov	edi, DWORD PTR _uiStartingMaxSize$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	jbe	SHORT $LN5@FFastVecto@4
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
$LN5@FFastVecto@4:
	mov	DWORD PTR [esi], eax
	pop	edi

; 315  : 	};

	mov	eax, esi
	pop	esi
	ret	4
??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z ENDP ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::~FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ PROC ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::~FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 318  : 	};

	ret	0
??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ ENDP ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::~FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>
_TEXT	ENDS
PUBLIC	??4?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEXABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??4?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEXABV0@@Z PROC ; FStaticVector<CvPurchaseRequest,6,1,297,0>::operator=, COMDAT
; _this$ = ecx

; 620  : 	void operator = (const THIS_TYPE& RHS){

	push	ebp

; 621  : 		if( m_uiCurrMaxSize <= RHS.m_uiCurrSize){

	mov	ebp, DWORD PTR _RHS$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [ebp+4]
	ja	SHORT $LN2@operator@7

; 622  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	ebx
	lea	ebx, DWORD PTR [esi+12]
	push	edi
	cmp	eax, ebx
	je	SHORT $LN5@operator@7
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN5@operator@7:

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	edi, DWORD PTR [ebp+8]
	cmp	edi, 6
	jbe	SHORT $LN16@operator@7
	push	798					; 0000031eH
	lea	ecx, DWORD PTR [edi+edi*2]
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	ecx, ecx
	add	ecx, ecx
	push	4
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN15@operator@7
$LN16@operator@7:
	mov	eax, ebx
	mov	DWORD PTR [esi+8], 6
$LN15@operator@7:
	pop	edi
	mov	DWORD PTR [esi], eax
	pop	ebx
$LN2@operator@7:

; 624  : 		}else{
; 625  : 			Destroy(m_pData, m_uiCurrSize);
; 626  : 		}
; 627  : 		Copy(RHS);

	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+4], edx
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebp

; 628  : 	};

	ret	4
??4?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEXABV0@@Z ENDP ; FStaticVector<CvPurchaseRequest,6,1,297,0>::operator=
_TEXT	ENDS
PUBLIC	??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z PROC ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 296  : 	FFastVector(const THIS_TYPE& RHS)

	push	ebx

; 297  : 	{
; 298  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	ebx, DWORD PTR _RHS$[esp]
	xor	eax, eax
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], ecx

; 299  : 		m_uiCurrMaxSize = RHS.m_uiCurrMaxSize;

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [esi+8], edx

; 300  : 		if( RHS.m_uiCurrMaxSize)

	cmp	DWORD PTR [ebx+8], eax
	je	SHORT $LN1@FFastVecto@5
	push	edi

; 301  : 		{
; 302  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	edi, DWORD PTR [ebx+8]
	cmp	edi, eax
	jbe	SHORT $LN6@FFastVecto@5
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
$LN6@FFastVecto@5:
	mov	DWORD PTR [esi], eax
	pop	edi
$LN1@FFastVecto@5:

; 303  : 		}
; 304  : #ifdef BREAK_ON_REPEATED_RESIZE
; 305  : 		m_nResizeTimes = 0;
; 306  : #endif
; 307  : 		Copy(RHS);

	push	ebx
	mov	ecx, esi
	call	?Copy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXABV1@@Z ; BaseVector<CvUnit *,0>::Copy

; 308  : 	};

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z ENDP ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z PROC ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	esi
	xor	eax, eax
	push	edi

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	mov	edi, DWORD PTR _uiStartingMaxSize$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	jbe	SHORT $LN5@FFastVecto@6
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
$LN5@FFastVecto@6:
	mov	DWORD PTR [esi], eax
	pop	edi

; 315  : 	};

	mov	eax, esi
	pop	esi
	ret	4
??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z ENDP ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ PROC ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 318  : 	};

	ret	0
??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ ENDP ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z
_TEXT	SEGMENT
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z PROC ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	esi
	xor	eax, eax
	push	edi

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	mov	edi, DWORD PTR _uiStartingMaxSize$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	jbe	SHORT $LN5@FFastVecto@7
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
$LN5@FFastVecto@7:
	mov	DWORD PTR [esi], eax
	pop	edi

; 315  : 	};

	mov	eax, esi
	pop	esi
	ret	4
??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z ENDP ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::~FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ PROC ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::~FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 318  : 	};

	ret	0
??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ ENDP ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::~FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	?clear@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXXZ ; CvWeightedVector<CvUnit *,50,1>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?clear@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXXZ PROC ; CvWeightedVector<CvUnit *,50,1>::clear, COMDAT
; _this$ = ecx

; 116  : 		m_pItems.clear();

	mov	DWORD PTR [ecx+4], 0

; 117  : 	};

	ret	0
?clear@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXXZ ENDP ; CvWeightedVector<CvUnit *,50,1>::clear
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvEconomicAIStrategyXMLEntry@@@std@@YAPAPAVCvEconomicAIStrategyXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvEconomicAIStrategyXMLEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXI@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXI@Z PROC ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR [esi+8]
	push	edi
	mov	ebp, eax

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	test	eax, eax
	jne	SHORT $LN34@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN34@GrowSize:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+12]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN9@GrowSize
	npad	1
$LL10@GrowSize:

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN37@GrowSize

; 433  : 				break;
; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL10@GrowSize

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN9@GrowSize
$LN37@GrowSize:

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN9@GrowSize:

; 438  : 		}
; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	jbe	SHORT $LN7@GrowSize
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi

; 441  : 		if (pTemp)

	test	ebx, ebx
	je	SHORT $LN7@GrowSize

; 442  : 		{
; 443  : 			if( bPODType ){
; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 445  : 			}else{
; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jbe	SHORT $LN2@GrowSize
	mov	ecx, ebx
$LL4@GrowSize:

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	ecx, ecx
	je	SHORT $LN3@GrowSize
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], edx
$LN3@GrowSize:
	inc	eax
	add	ecx, 4
	cmp	eax, DWORD PTR [esi+4]
	jb	SHORT $LL4@GrowSize
$LN2@GrowSize:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	pop	edi

; 450  : 			m_pData = pTemp;

	mov	DWORD PTR [esi], ebx
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
$LN7@GrowSize:
	pop	edi

; 451  : 		}
; 452  : 		else
; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	DWORD PTR [esi+8], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
?GrowSize@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXI@Z ENDP ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z PROC ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR [esi+8]
	push	edi
	mov	ebp, eax

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	test	eax, eax
	jne	SHORT $LN34@GrowSize@2
	mov	DWORD PTR [esi+8], 1
$LN34@GrowSize@2:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+12]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN9@GrowSize@2
	npad	1
$LL10@GrowSize@2:

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN37@GrowSize@2

; 433  : 				break;
; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL10@GrowSize@2

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN9@GrowSize@2
$LN37@GrowSize@2:

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN9@GrowSize@2:

; 438  : 		}
; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	jbe	SHORT $LN7@GrowSize@2
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi

; 441  : 		if (pTemp)

	test	ebx, ebx
	je	SHORT $LN7@GrowSize@2

; 442  : 		{
; 443  : 			if( bPODType ){
; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 445  : 			}else{
; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jbe	SHORT $LN2@GrowSize@2
	mov	ecx, ebx
$LL4@GrowSize@2:

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	ecx, ecx
	je	SHORT $LN3@GrowSize@2
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], edx
$LN3@GrowSize@2:
	inc	eax
	add	ecx, 4
	cmp	eax, DWORD PTR [esi+4]
	jb	SHORT $LL4@GrowSize@2
$LN2@GrowSize@2:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	pop	edi

; 450  : 			m_pData = pTemp;

	mov	DWORD PTR [esi], ebx
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
$LN7@GrowSize@2:
	pop	edi

; 451  : 		}
; 452  : 		else
; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	DWORD PTR [esi+8], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ENDP ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXI@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXI@Z PROC ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR [esi+8]
	push	edi
	mov	ebp, eax

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	test	eax, eax
	jne	SHORT $LN34@GrowSize@3
	mov	DWORD PTR [esi+8], 1
$LN34@GrowSize@3:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+12]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN9@GrowSize@3
	npad	1
$LL10@GrowSize@3:

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN37@GrowSize@3

; 433  : 				break;
; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL10@GrowSize@3

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN9@GrowSize@3
$LN37@GrowSize@3:

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN9@GrowSize@3:

; 438  : 		}
; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	jbe	SHORT $LN7@GrowSize@3
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi

; 441  : 		if (pTemp)

	test	ebx, ebx
	je	SHORT $LN7@GrowSize@3

; 442  : 		{
; 443  : 			if( bPODType ){
; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 445  : 			}else{
; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jbe	SHORT $LN2@GrowSize@3
	mov	ecx, ebx
$LL4@GrowSize@3:

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	ecx, ecx
	je	SHORT $LN3@GrowSize@3
	mov	edx, DWORD PTR [esi]
	mov	edi, DWORD PTR [edx+eax*8]
	mov	DWORD PTR [ecx], edi
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR [ecx+4], edx
$LN3@GrowSize@3:
	inc	eax
	add	ecx, 8
	cmp	eax, DWORD PTR [esi+4]
	jb	SHORT $LL4@GrowSize@3
$LN2@GrowSize@3:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	pop	edi

; 450  : 			m_pData = pTemp;

	mov	DWORD PTR [esi], ebx
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
$LN7@GrowSize@3:
	pop	edi

; 451  : 		}
; 452  : 		else
; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	DWORD PTR [esi+8], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
?GrowSize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvPurchaseRequest,6,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@4
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@4:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@4
	npad	6
$LL8@GrowSize@4:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@4

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@4

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@4
$LN31@GrowSize@4:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@4:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 6
	jbe	SHORT $LN15@GrowSize@4
	push	798					; 0000031eH
	lea	eax, DWORD PTR [ebp+ebp*2]
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@4
$LN15@GrowSize@4:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 6
$LN14@GrowSize@4:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+eax*2]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@4
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@4:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+84], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvPurchaseRequest,6,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXI@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXI@Z PROC ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR [esi+8]
	push	edi
	mov	ebp, eax

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	test	eax, eax
	jne	SHORT $LN34@GrowSize@5
	mov	DWORD PTR [esi+8], 1
$LN34@GrowSize@5:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+12]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN9@GrowSize@5
	npad	1
$LL10@GrowSize@5:

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN37@GrowSize@5

; 433  : 				break;
; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL10@GrowSize@5

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN9@GrowSize@5
$LN37@GrowSize@5:

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN9@GrowSize@5:

; 438  : 		}
; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	jbe	SHORT $LN7@GrowSize@5
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi

; 441  : 		if (pTemp)

	test	ebx, ebx
	je	SHORT $LN7@GrowSize@5

; 442  : 		{
; 443  : 			if( bPODType ){
; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 445  : 			}else{
; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jbe	SHORT $LN2@GrowSize@5
	mov	ecx, ebx
$LL4@GrowSize@5:

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	ecx, ecx
	je	SHORT $LN3@GrowSize@5
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], edx
$LN3@GrowSize@5:
	inc	eax
	add	ecx, 4
	cmp	eax, DWORD PTR [esi+4]
	jb	SHORT $LL4@GrowSize@5
$LN2@GrowSize@5:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	pop	edi

; 450  : 			m_pData = pTemp;

	mov	DWORD PTR [esi], ebx
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
$LN7@GrowSize@5:
	pop	edi

; 451  : 		}
; 452  : 		else
; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	DWORD PTR [esi+8], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
?GrowSize@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEXI@Z ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEXI@Z PROC ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR [esi+8]
	push	edi
	mov	ebp, eax

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	test	eax, eax
	jne	SHORT $LN34@GrowSize@6
	mov	DWORD PTR [esi+8], 1
$LN34@GrowSize@6:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+12]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN9@GrowSize@6
	npad	1
$LL10@GrowSize@6:

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN35@GrowSize@6

; 433  : 				break;
; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL10@GrowSize@6

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN9@GrowSize@6
$LN35@GrowSize@6:

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN9@GrowSize@6:

; 438  : 		}
; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	jbe	SHORT $LN7@GrowSize@6
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi

; 441  : 		if (pTemp)

	test	ebx, ebx
	je	SHORT $LN7@GrowSize@6

; 442  : 		{
; 443  : 			if( bPODType ){
; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	ebx
	call	_memcpy

; 445  : 			}else{
; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 16					; 00000010H
	pop	edi

; 450  : 			m_pData = pTemp;

	mov	DWORD PTR [esi], ebx
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
$LN7@GrowSize@6:
	pop	edi

; 451  : 		}
; 452  : 		else
; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	DWORD PTR [esi+8], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
?GrowSize@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEXI@Z ENDP ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::~FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::~FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@2:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::~FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAEXPAPAVCvEconomicAIStrategyXMLEntry@@0@Z ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAEXPAPAVCvEconomicAIStrategyXMLEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAEXPAPAVCvEconomicAIStrategyXMLEntry@@0@Z PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAEXPAPAVCvEconomicAIStrategyXMLEntry@@0@Z ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize@7
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize@7:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@7
	npad	6
$LL8@GrowSize@7:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize@7

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@7

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@7
$LN34@GrowSize@7:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@7:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 50					; 00000032H
	jbe	SHORT $LN16@GrowSize@7
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize@7
$LN16@GrowSize@7:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 50			; 00000032H
$LN15@GrowSize@7:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize@7
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize@7:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+412], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSizeToFit
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSizeToFit, COMDAT
; _this$ = ecx

; 776  : 	{

	push	esi
	push	edi

; 777  : 		if( uiFit <= m_uiCurrMaxSize )

	mov	edi, DWORD PTR _uiFit$[esp+4]
	mov	esi, ecx
	cmp	edi, DWORD PTR [esi+8]
	jbe	SHORT $LN7@GrowSizeTo
	push	ebx

; 778  : 			return;
; 779  : 
; 780  : 		m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edi

; 781  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	cmp	edi, 50					; 00000032H
	jbe	SHORT $LN13@GrowSizeTo
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebx, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN12@GrowSizeTo
$LN13@GrowSizeTo:
	lea	ebx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 50			; 00000032H
$LN12@GrowSizeTo:

; 782  : 		if( bPODType ){
; 783  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	ebx
	call	_memcpy

; 784  : 		}else{
; 785  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 786  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 787  : 		}
; 788  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	add	esp, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN20@GrowSizeTo
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN20@GrowSizeTo:

; 789  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], ebx

; 790  : 
; 791  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+412], 1
	pop	ebx
$LN7@GrowSizeTo:
	pop	edi
	pop	esi

; 792  : 	};

	ret	4
?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSizeToFit
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$229896 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$229896[esp+16]
	push	eax
	call	??$get_temporary_buffer@VCvPurchaseRequest@@@std@@YA?AU?$pair@PAVCvPurchaseRequest@@H@0@H@Z ; std::get_temporary_buffer<CvPurchaseRequest>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$229896[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$229896[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Median<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z PROC ; std::_Median<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	ebx, edi
	sar	ebx, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap
	npad	3
$LL2@Make_heap:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [edi+esi*8-8]
	sub	esp, 8
	mov	eax, esp
	dec	esi
	push	ebx
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+esi*8+4]
	push	esi
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap
$LN1@Make_heap:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_
	push	ebx
	push	esi
$LL7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN21@Insertion_
	npad	7
$LL22@Insertion_:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_
$LN21@Insertion_:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_
	pop	esi
	pop	ebx
$LN6@Insertion_:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAVCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@00@Z ; std::_Insertion_sort1<CvPurchaseRequest *,CvPurchaseRequest>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAVCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@00@Z
_TEXT	SEGMENT
__Val$230173 = -12					; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAVCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@00@Z PROC ; std::_Insertion_sort1<CvPurchaseRequest *,CvPurchaseRequest>, COMDAT

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 12					; 0000000cH
	push	edi
	mov	edi, DWORD PTR __First$[esp+12]
	cmp	edi, eax
	je	$LN6@Insertion_@2

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+12]
	cmp	edx, eax
	je	$LN6@Insertion_@2
	push	ebx
	push	ebp
	push	esi
$LL7@Insertion_@2:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+8]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+8]
	mov	ebp, DWORD PTR [edx+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	mov	DWORD PTR __Val$230173[esp+32], ebp
	jle	SHORT $LN5@Insertion_@2

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN19@Insertion_@2
	npad	5
$LL20@Insertion_@2:
	mov	ecx, DWORD PTR [eax-12]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+20], ecx
	cmp	eax, edi
	jne	SHORT $LL20@Insertion_@2
$LN19@Insertion_@2:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], ebp
	mov	DWORD PTR [edi+8], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@2
$LN5@Insertion_@2:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-12]
	jle	SHORT $LN1@Insertion_@2
	npad	5
$LL3@Insertion_@2:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ebp, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], ebp
	mov	ecx, eax
	sub	eax, 12					; 0000000cH
	cmp	esi, DWORD PTR [eax+8]
	jg	SHORT $LL3@Insertion_@2

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Val$230173[esp+32]
$LN1@Insertion_@2:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [ecx+8], esi
$LN4@Insertion_@2:
	add	edx, 12					; 0000000cH
	cmp	edx, DWORD PTR __Last$[esp+24]
	jne	SHORT $LL7@Insertion_@2
	pop	esi
	pop	ebp
	pop	ebx
$LN6@Insertion_@2:
	pop	edi

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	add	esp, 12					; 0000000cH
	ret	0
??$_Insertion_sort1@PAVCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@00@Z ENDP ; std::_Insertion_sort1<CvPurchaseRequest *,CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@PAVCvPurchaseRequest@@PAV1@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@0000@Z ; stdext::_Unchecked_merge_backward<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@PAVCvPurchaseRequest@@PAV1@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@0000@Z
_TEXT	SEGMENT
$T237885 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$_Unchecked_merge_backward@PAVCvPurchaseRequest@@PAV1@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@0000@Z PROC ; stdext::_Unchecked_merge_backward<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>, COMDAT

; 5202 : 	{

	push	ecx

; 5203 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	edx, DWORD PTR __Last2$[esp]
	mov	BYTE PTR $T237885[esp+4], 0
	mov	eax, DWORD PTR $T237885[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Merge_backward@PAVCvPurchaseRequest@@PAV1@PAV1@@std@@YAPAVCvPurchaseRequest@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>

; 5204 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_merge_backward@PAVCvPurchaseRequest@@PAV1@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@0000@Z ENDP ; stdext::_Unchecked_merge_backward<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	??$lower_bound@PAVCvPurchaseRequest@@V1@@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@@Z ; std::lower_bound<CvPurchaseRequest *,CvPurchaseRequest>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@PAVCvPurchaseRequest@@V1@@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$lower_bound@PAVCvPurchaseRequest@@V1@@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@@Z PROC ; std::lower_bound<CvPurchaseRequest *,CvPurchaseRequest>, COMDAT

; 2276 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Lower_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvPurchaseRequest *,CvPurchaseRequest,int>
	add	esp, 16					; 00000010H

; 2277 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2278 : 	return _First;
; 2279 : 	}

	ret	0
??$lower_bound@PAVCvPurchaseRequest@@V1@@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@@Z ENDP ; std::lower_bound<CvPurchaseRequest *,CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??$upper_bound@PAVCvPurchaseRequest@@V1@@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@@Z ; std::upper_bound<CvPurchaseRequest *,CvPurchaseRequest>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@PAVCvPurchaseRequest@@V1@@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$upper_bound@PAVCvPurchaseRequest@@V1@@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@@Z PROC ; std::upper_bound<CvPurchaseRequest *,CvPurchaseRequest>, COMDAT

; 2347 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Upper_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvPurchaseRequest *,CvPurchaseRequest,int>
	add	esp, 16					; 00000010H

; 2348 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2349 : 	return _First;
; 2350 : 	}

	ret	0
??$upper_bound@PAVCvPurchaseRequest@@V1@@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@@Z ENDP ; std::upper_bound<CvPurchaseRequest *,CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T237903 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+12]
	xor	ebx, ebx
	mov	DWORD PTR $T237903[esp+16], ebx
	cmp	ecx, edi
	je	SHORT $LN1@Copy_opt@3
	lea	esi, DWORD PTR [ebx+12]
	npad	7
$LL3@Copy_opt@3:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __Dest$[esp+28]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN14@Copy_opt@3
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR __Dest$[esp+28]
	add	DWORD PTR [eax+4], esi
	jmp	SHORT $LN2@Copy_opt@3
$LN14@Copy_opt@3:
	cmp	eax, ebx
	je	SHORT $LN19@Copy_opt@3
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR __Dest$[esp+28]
$LN19@Copy_opt@3:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN2@Copy_opt@3:
	add	ecx, esi
	cmp	ecx, edi
	jne	SHORT $LL3@Copy_opt@3
$LN1@Copy_opt@3:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	cmp	eax, ebx
	je	SHORT $LN41@Copy_opt@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Copy_opt@3:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvPurchaseRequest@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAVCvPurchaseRequest@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge@PAVCvPurchaseRequest@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>, COMDAT

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+8]
	cmp	eax, esi
	je	SHORT $LN16@Merge
	npad	5
$LL5@Merge:
	cmp	ecx, edi
	je	SHORT $LN3@Merge

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	ebx, DWORD PTR [ecx+8]
	cmp	ebx, DWORD PTR [eax+8]
	jle	SHORT $LN2@Merge

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	add	ecx, 12					; 0000000cH

; 2516 : 		else

	jmp	SHORT $LN40@Merge
$LN2@Merge:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	ebx, DWORD PTR [eax+8]
	add	eax, 12					; 0000000cH
$LN40@Merge:
	mov	DWORD PTR [edx+8], ebx
	add	edx, 12					; 0000000cH
	cmp	eax, esi
	jne	SHORT $LL5@Merge
$LN3@Merge:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	eax, esi
	je	SHORT $LN16@Merge
	npad	4
$LL18@Merge:
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	ebx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ebx
	add	eax, 12					; 0000000cH
	add	edx, 12					; 0000000cH
	cmp	eax, esi
	jne	SHORT $LL18@Merge
$LN16@Merge:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	eax, edx
	cmp	ecx, edi
	je	SHORT $LN27@Merge
$LL29@Merge:
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edi
	jne	SHORT $LL29@Merge
$LN27@Merge:
	pop	edi
	pop	esi
	pop	ebx

; 2521 : 	}

	ret	0
??$_Merge@PAVCvPurchaseRequest@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$rotate@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@00@Z ; std::rotate<CvPurchaseRequest *>
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@00@Z PROC ; std::rotate<CvPurchaseRequest *>, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN6@rotate
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN6@rotate

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00PAH0@Z ; std::_Rotate<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 20					; 00000014H
$LN6@rotate:

; 1721 : 	}

	ret	0
??$rotate@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@00@Z ENDP ; std::rotate<CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax-8]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 8
	mov	edx, esp
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??0CvEconomicAI@@QAE@XZ				; CvEconomicAI::CvEconomicAI
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$??0CvEconomicAI@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0CvEconomicAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvEconomicAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvEconomicAI@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvEconomicAI@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvEconomicAI@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvEconomicAI@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvEconomicAI@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvEconomicAI@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvEconomicAI@@QAE@XZ$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ??0CvEconomicAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvEconomicAI@@QAE@XZ PROC				; CvEconomicAI::CvEconomicAI, COMDAT
; _this$ = ecx

; 249  : {

	push	-1
	push	__ehhandler$??0CvEconomicAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], 1
	mov	DWORD PTR [eax+56], ecx
	mov	DWORD PTR [eax+60], ecx
	mov	DWORD PTR [eax+52], ecx
	mov	DWORD PTR [eax+68], ecx
	mov	DWORD PTR [eax+72], ecx
	mov	DWORD PTR [eax+64], ecx
	mov	DWORD PTR [eax+80], ecx
	mov	DWORD PTR [eax+84], ecx
	mov	DWORD PTR [eax+76], ecx
	mov	DWORD PTR [eax+92], ecx
	mov	DWORD PTR [eax+96], ecx
	mov	DWORD PTR [eax+88], ecx
	mov	DWORD PTR [eax+104], ecx
	mov	DWORD PTR [eax+108], ecx
	mov	DWORD PTR [eax+100], ecx
	lea	edx, DWORD PTR [eax+124]
	mov	DWORD PTR [eax+116], ecx
	mov	DWORD PTR [eax+120], 6
	mov	DWORD PTR [eax+112], edx
	lea	edx, DWORD PTR [eax+212]
	mov	DWORD PTR [eax+204], ecx
	mov	DWORD PTR [eax+208], 6
	mov	DWORD PTR [eax+200], edx
	mov	DWORD PTR [eax+292], ecx
	mov	DWORD PTR [eax+296], ecx
	mov	DWORD PTR [eax+288], ecx

; 250  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvEconomicAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	jmp	??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??0CvEconomicAI@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??0CvEconomicAI@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??0CvEconomicAI@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??0CvEconomicAI@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	jmp	??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::~FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??0CvEconomicAI@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>
__unwindfunclet$??0CvEconomicAI@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	jmp	??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>
__ehhandler$??0CvEconomicAI@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvEconomicAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvEconomicAI@@QAE@XZ ENDP				; CvEconomicAI::CvEconomicAI
PUBLIC	??1CvEconomicAI@@QAE@XZ				; CvEconomicAI::~CvEconomicAI
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$??1CvEconomicAI@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??1CvEconomicAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvEconomicAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ??1CvEconomicAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvEconomicAI@@QAE@XZ PROC				; CvEconomicAI::~CvEconomicAI, COMDAT
; _this$ = ecx

; 254  : {

	push	-1
	push	__ehhandler$??1CvEconomicAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi

; 255  : 	Uninit();

	mov	eax, DWORD PTR [esi+12]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], 6
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+12], ebx
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+16], ebx
	mov	eax, DWORD PTR [esi+20]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+20], ebx

; 256  : }

	mov	eax, DWORD PTR [esi+288]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	eax, DWORD PTR [esi+200]
	lea	ecx, DWORD PTR [esi+212]
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[esp+32], 5
	cmp	eax, ecx
	je	SHORT $LN36@CvEconomic
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@CvEconomic:
	mov	eax, DWORD PTR [esi+112]
	lea	edx, DWORD PTR [esi+124]
	mov	BYTE PTR __$EHRec$[esp+32], 4
	cmp	eax, edx
	je	SHORT $LN50@CvEconomic
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN50@CvEconomic:
	mov	eax, DWORD PTR [esi+100]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+36], 3
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	eax, DWORD PTR [esi+88]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+40], 2
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	eax, DWORD PTR [esi+76]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+44], 1
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	eax, DWORD PTR [esi+64]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+48], bl
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	esi, DWORD PTR [esi+52]
	push	esi
	mov	DWORD PTR __$EHRec$[esp+52], -1
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	add	esp, 20					; 00000014H
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	jmp	??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	jmp	??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::~FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	jmp	??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>
__ehhandler$??1CvEconomicAI@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvEconomicAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvEconomicAI@@QAE@XZ ENDP				; CvEconomicAI::~CvEconomicAI
PUBLIC	__real@4008000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@3fd0000000000000
PUBLIC	?DisbandExtraWorkers@CvEconomicAI@@AAEXXZ	; CvEconomicAI::DisbandExtraWorkers
EXTRN	?scrap@CvUnit@@QAEXXZ:PROC			; CvUnit::scrap
EXTRN	?IsRouteToCapitalConnected@CvCity@@QAE_NXZ:PROC	; CvCity::IsRouteToCapitalConnected
EXTRN	?area@CvCity@@QBEPAVCvArea@@XZ:PROC		; CvCity::area
EXTRN	?getNumUnits@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumUnits
;	COMDAT __real@4008000000000000
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?DisbandExtraWorkers@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
_iMinWorkers$ = -32					; size = 4
_fRatio$ = -32						; size = 8
_iNumValidPlots$ = -24					; size = 4
_iNumImprovedPlots$ = -20				; size = 4
_fCurrentRatio$ = -20					; size = 8
_iNumWorkers$ = -12					; size = 4
$T238759 = -12						; size = 4
$T238760 = -8						; size = 4
_iNumCities$ = -8					; size = 4
$T238758 = -8						; size = 4
_iLoop$ = -4						; size = 4
?DisbandExtraWorkers@CvEconomicAI@@AAEXXZ PROC		; CvEconomicAI::DisbandExtraWorkers, COMDAT
; _this$ = ecx

; 2217 : {

	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2218 : 	// Are we running at a deficit?
; 2219 : 	EconomicAIStrategyTypes eStrategyLosingMoney = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_LOSING_MONEY");

	push	0
	mov	edi, ecx
	push	OFFSET $SG227258
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2220 : 	bool bInDeficit = m_pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyLosingMoney);

	mov	ecx, DWORD PTR [edi+4]
	mov	esi, eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	eax, DWORD PTR [eax+12]

; 2221 : 
; 2222 : 	int iGoldSpentOnUnits = m_pPlayer->GetTreasury()->GetExpensePerTurnUnitMaintenance();

	mov	ecx, DWORD PTR [edi+4]
	mov	bl, BYTE PTR [esi+eax]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury

; 2223 : 	int iAverageGoldPerUnit = iGoldSpentOnUnits / (max(1,m_pPlayer->getNumUnits()));

	mov	ecx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [eax+16]
	call	?getNumUnits@CvPlayer@@QBEHXZ		; CvPlayer::getNumUnits
	cmp	eax, 1
	mov	DWORD PTR $T238758[esp+48], eax
	mov	DWORD PTR $T238759[esp+48], 1
	lea	ecx, DWORD PTR $T238758[esp+48]
	jg	SHORT $LN33@DisbandExt
	lea	ecx, DWORD PTR $T238759[esp+48]
$LN33@DisbandExt:
	mov	eax, esi
	cdq
	idiv	DWORD PTR [ecx]

; 2224 : 
; 2225 : 	if(!bInDeficit && iAverageGoldPerUnit <= 4)

	test	bl, bl
	jne	SHORT $LN22@DisbandExt
	cmp	eax, 4
	jle	$LN20@DisbandExt
$LN22@DisbandExt:

; 2226 : 	{
; 2227 : 		return;
; 2228 : 	}
; 2229 : 
; 2230 : 	//antonjs: consider: make calls to GetWorkersToCitiesRatio and GetImprovedToImprovablePlotsRatio instead, is the code similar enough?
; 2231 : 
; 2232 : 	double fWorstCaseRatio = 0.25; // one worker for four cities
; 2233 : 	int iNumWorkers = m_pPlayer->GetNumUnitsWithUnitAI(UNITAI_WORKER, true, false);

	mov	ecx, DWORD PTR [edi+4]
	push	0
	push	1
	push	2
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI

; 2234 : 	int iNumCities = m_pPlayer->getNumCities();

	mov	ecx, DWORD PTR [edi+4]
	mov	esi, eax
	mov	DWORD PTR _iNumWorkers$[esp+48], esi
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities

; 2235 : 
; 2236 : 	double fCurrentRatio = iNumWorkers / (double)iNumCities;

	fild	DWORD PTR _iNumWorkers$[esp+48]
	mov	DWORD PTR _iNumCities$[esp+48], eax
	fidiv	DWORD PTR _iNumCities$[esp+48]
	fstp	QWORD PTR _fCurrentRatio$[esp+48]

; 2237 : 	if(fCurrentRatio <= fWorstCaseRatio || iNumWorkers == 1)

	fld	QWORD PTR __real@3fd0000000000000
	fcomp	QWORD PTR _fCurrentRatio$[esp+48]
	fnstsw	ax
	test	ah, 1
	je	$LN20@DisbandExt
	cmp	esi, 1
	je	$LN20@DisbandExt

; 2238 : 	{
; 2239 : 		return;
; 2240 : 	}
; 2241 : 
; 2242 : 	const CvPlotsVector& aiPlots = m_pPlayer->GetPlots();

	mov	ecx, DWORD PTR [edi+4]
	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots

; 2243 : 	int iNumValidPlots = 0;

	xor	ebx, ebx
	mov	ebp, eax
	mov	DWORD PTR _iNumValidPlots$[esp+48], ebx

; 2244 : 	int iNumImprovedPlots = 0;

	mov	DWORD PTR _iNumImprovedPlots$[esp+48], ebx

; 2245 : 	for(uint ui = 0; ui < aiPlots.size(); ui++)

	cmp	DWORD PTR [ebp+4], ebx
	jbe	$LN20@DisbandExt
$LN19@DisbandExt:

; 2246 : 	{
; 2247 : 		if(aiPlots[ui] == -1)

	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ecx+ebx*4]
	cmp	eax, -1
	je	SHORT $LN18@DisbandExt

; 2248 : 		{
; 2249 : 			continue;
; 2250 : 		}
; 2251 : 
; 2252 : 		const CvPlot* pPlot = GC.getMap().plotByIndex(aiPlots[ui]);

	test	eax, eax
	jl	SHORT $LN18@DisbandExt
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN18@DisbandExt
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	mov	esi, eax

; 2253 : 		if(!pPlot)

	je	SHORT $LN18@DisbandExt

; 2254 : 		{
; 2255 : 			continue;
; 2256 : 		}
; 2257 : 
; 2258 : 		if(pPlot->isWater() || pPlot->isImpassable() || pPlot->isMountain() || pPlot->isCity())

	mov	al, BYTE PTR [esi+5]
	cmp	al, 3
	je	SHORT $LN18@DisbandExt
	test	BYTE PTR [esi+462], 128			; 00000080H
	jne	SHORT $LN18@DisbandExt
	test	al, al
	je	SHORT $LN18@DisbandExt
	mov	ecx, esi
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	test	al, al
	jne	SHORT $LN18@DisbandExt

; 2259 : 		{
; 2260 : 			continue;
; 2261 : 		}
; 2262 : 
; 2263 : 		iNumValidPlots++;

	inc	DWORD PTR _iNumValidPlots$[esp+48]

; 2264 : 
; 2265 : 		if(pPlot->getImprovementType() != NO_IMPROVEMENT && !pPlot->IsImprovementPillaged())

	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN18@DisbandExt
	mov	ecx, esi
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	test	al, al
	jne	SHORT $LN18@DisbandExt

; 2266 : 		{
; 2267 : 			iNumImprovedPlots++;

	inc	DWORD PTR _iNumImprovedPlots$[esp+48]
$LN18@DisbandExt:

; 2245 : 	for(uint ui = 0; ui < aiPlots.size(); ui++)

	inc	ebx
	cmp	ebx, DWORD PTR [ebp+4]
	jb	SHORT $LN19@DisbandExt

; 2268 : 		}
; 2269 : 	}
; 2270 : 
; 2271 : 	// potential div by zero
; 2272 : 	if(iNumValidPlots <= 0)

	mov	ecx, DWORD PTR _iNumValidPlots$[esp+48]
	test	ecx, ecx
	jle	$LN20@DisbandExt

; 2273 : 	{
; 2274 : 		return;
; 2275 : 	}
; 2276 : 
; 2277 : 	int iNumUnimprovedPlots = iNumValidPlots - iNumImprovedPlots;
; 2278 : 
; 2279 : 	// less than two thirds of the plots are improved, don't discard anybody
; 2280 : 	double fRatio = iNumImprovedPlots / (double)iNumValidPlots;

	fild	DWORD PTR _iNumImprovedPlots$[esp+48]
	sub	ecx, DWORD PTR _iNumImprovedPlots$[esp+48]
	fidiv	DWORD PTR _iNumValidPlots$[esp+48]
	fstp	QWORD PTR _fRatio$[esp+48]

; 2281 : 	if(fRatio < 2/(double)3)

	fld	QWORD PTR __real@4000000000000000
	fdiv	QWORD PTR __real@4008000000000000
	fcomp	QWORD PTR _fRatio$[esp+48]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN20@DisbandExt

; 2282 : 	{
; 2283 : 		return;
; 2284 : 	}
; 2285 : 
; 2286 : 	int iWorkersPerUnimprovedPlot = 5;
; 2287 : 	int iMinWorkers = iNumUnimprovedPlots / iWorkersPerUnimprovedPlot;

	mov	eax, ecx
	cdq
	mov	ecx, 5
	idiv	ecx
	mov	DWORD PTR _iMinWorkers$[esp+48], eax

; 2288 : 	if((iNumUnimprovedPlots % iWorkersPerUnimprovedPlot) > 0)

	test	edx, edx
	jle	SHORT $LN9@DisbandExt

; 2289 : 	{
; 2290 : 		iMinWorkers += 1;

	inc	DWORD PTR _iMinWorkers$[esp+48]
$LN9@DisbandExt:

; 2291 : 	}
; 2292 : 
; 2293 : 	CvCity* pCapital = m_pPlayer->getCapitalCity();

	mov	ecx, DWORD PTR [edi+4]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ebx, eax

; 2294 : 	if(!pCapital)

	test	ebx, ebx
	je	$LN20@DisbandExt

; 2295 : 	{
; 2296 : 		return;
; 2297 : 	}
; 2298 : 
; 2299 : 	int iLoop;
; 2300 : 	CvCity* pCity;
; 2301 : 	for(pCity = m_pPlayer->firstCity(&iLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [edi+4]
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+52]
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN5@DisbandExt
$LL7@DisbandExt:

; 2302 : 	{
; 2303 : 		if(pCity == pCapital)

	cmp	esi, ebx
	je	SHORT $LN6@DisbandExt

; 2304 : 		{
; 2305 : 			continue;
; 2306 : 		}
; 2307 : 
; 2308 : 		if(pCapital->area() == pCity->area() && !pCity->IsRouteToCapitalConnected())

	mov	ecx, esi
	call	?area@CvCity@@QBEPAVCvArea@@XZ		; CvCity::area
	mov	ecx, ebx
	mov	ebp, eax
	call	?area@CvCity@@QBEPAVCvArea@@XZ		; CvCity::area
	cmp	eax, ebp
	jne	SHORT $LN6@DisbandExt
	mov	ecx, esi
	call	?IsRouteToCapitalConnected@CvCity@@QAE_NXZ ; CvCity::IsRouteToCapitalConnected
	test	al, al
	jne	SHORT $LN6@DisbandExt

; 2309 : 		{
; 2310 : 			iMinWorkers += 1;

	inc	DWORD PTR _iMinWorkers$[esp+48]
$LN6@DisbandExt:

; 2295 : 	{
; 2296 : 		return;
; 2297 : 	}
; 2298 : 
; 2299 : 	int iLoop;
; 2300 : 	CvCity* pCity;
; 2301 : 	for(pCity = m_pPlayer->firstCity(&iLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [edi+4]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+52]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL7@DisbandExt
$LN5@DisbandExt:

; 2311 : 		}
; 2312 : 	}
; 2313 : 
; 2314 : 
; 2315 : 	if(iNumWorkers <= iMinWorkers)

	mov	ebx, DWORD PTR _iNumWorkers$[esp+48]
	cmp	ebx, DWORD PTR _iMinWorkers$[esp+48]
	jle	SHORT $LN20@DisbandExt

; 2316 : 	{
; 2317 : 		return;
; 2318 : 	}
; 2319 : 
; 2320 : 	m_iLastTurnWorkerDisbanded = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 2321 : 
; 2322 : 	CvUnit* pUnit = FindWorkerToScrap();

	mov	ecx, edi
	mov	DWORD PTR [edi+40], eax
	call	?FindWorkerToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ ; CvEconomicAI::FindWorkerToScrap
	mov	esi, eax

; 2323 : 	if(!pUnit)

	test	esi, esi
	je	SHORT $LN20@DisbandExt

; 2324 : 	{
; 2325 : 		return;
; 2326 : 	}
; 2327 : 
; 2328 : 	pUnit->scrap();

	mov	ecx, esi
	call	?scrap@CvUnit@@QAEXXZ			; CvUnit::scrap

; 2329 : 	LogScrapUnit(pUnit, iNumWorkers, iNumCities, iNumImprovedPlots, iNumValidPlots);

	mov	ecx, DWORD PTR _iNumValidPlots$[esp+48]
	mov	edx, DWORD PTR _iNumImprovedPlots$[esp+48]
	mov	eax, DWORD PTR _iNumCities$[esp+48]
	push	ecx
	push	edx
	push	eax
	push	ebx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T238760[esp+72], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z ; CvEconomicAI::LogScrapUnit
$LN20@DisbandExt:

; 2330 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
?DisbandExtraWorkers@CvEconomicAI@@AAEXXZ ENDP		; CvEconomicAI::DisbandExtraWorkers
_TEXT	ENDS
PUBLIC	?DisbandExtraArchaeologists@CvEconomicAI@@AAEXXZ ; CvEconomicAI::DisbandExtraArchaeologists
; Function compile flags: /Ogtpy
;	COMDAT ?DisbandExtraArchaeologists@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
_iNumSites$ = -8					; size = 4
$T238847 = -4						; size = 4
_iNumArchaeologists$ = -4				; size = 4
?DisbandExtraArchaeologists@CvEconomicAI@@AAEXXZ PROC	; CvEconomicAI::DisbandExtraArchaeologists, COMDAT
; _this$ = ecx

; 2331 : void CvEconomicAI::DisbandExtraArchaeologists(){

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 2332 : 	int iNumSites = GC.getGame().GetNumArchaeologySites();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetNumArchaeologySites@CvGame@@QBEHXZ	; CvGame::GetNumArchaeologySites

; 2333 : 	double dMaxRatio = .5; //Ratio of archaeologists to sites
; 2334 : 	int iNumArchaeologists = m_pPlayer->GetNumUnitsWithUnitAI(UNITAI_ARCHAEOLOGIST, true);

	mov	ecx, DWORD PTR [edi+4]
	push	1
	push	1
	mov	ebx, eax
	push	39					; 00000027H
	mov	DWORD PTR _iNumSites$[esp+36], ebx
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI

; 2335 : 	PolicyTypes eExpFinisher = (PolicyTypes) GC.getInfoTypeForString("POLICY_EXPLORATION_FINISHER", true /*bHideAssert*/);

	push	1
	mov	ebp, eax
	push	OFFSET $SG227315
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iNumArchaeologists$[esp+32], ebp
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2336 : 	if (eExpFinisher != NO_POLICY)	

	cmp	eax, -1
	je	SHORT $LN4@DisbandExt@2

; 2337 : 	{
; 2338 : 		if (m_pPlayer->GetPlayerPolicies()->HasPolicy(eExpFinisher))

	mov	ecx, DWORD PTR [edi+4]
	push	eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	test	al, al
	je	SHORT $LN4@DisbandExt@2

; 2339 : 		{
; 2340 : 			iNumSites += GC.getGame().GetNumHiddenArchaeologySites();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetNumHiddenArchaeologySites@CvGame@@QBEHXZ ; CvGame::GetNumHiddenArchaeologySites
	add	ebx, eax
	mov	DWORD PTR _iNumSites$[esp+24], ebx
$LN4@DisbandExt@2:

; 2341 : 		}
; 2342 : 	}
; 2343 : 	
; 2344 : 	CvUnit* pUnit;
; 2345 : 	UnitTypes eArch = (UnitTypes) GC.getInfoTypeForString("UNIT_ARCHAEOLOGIST", true /*bHideAssert*/);

	push	1
	push	OFFSET $SG227321
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 2346 : 	if(eArch == NO_UNIT){

	cmp	eax, -1
	je	SHORT $LN2@DisbandExt@2

; 2347 : 		return;
; 2348 : 	}
; 2349 : 	if ((double)iNumSites * dMaxRatio + 1 < iNumArchaeologists ){

	fild	DWORD PTR _iNumSites$[esp+24]
	fmul	QWORD PTR __real@3fe0000000000000
	fadd	QWORD PTR __real@3ff0000000000000
	fild	DWORD PTR _iNumArchaeologists$[esp+24]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@DisbandExt@2

; 2350 : 		pUnit = FindArchaeologistToScrap();

	mov	ecx, edi
	call	?FindArchaeologistToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ ; CvEconomicAI::FindArchaeologistToScrap
	mov	esi, eax

; 2351 : 	
; 2352 : 		if(!pUnit)

	test	esi, esi
	je	SHORT $LN2@DisbandExt@2

; 2353 : 		{
; 2354 : 			return;
; 2355 : 		}
; 2356 : 	
; 2357 : 		pUnit->scrap();

	mov	ecx, esi
	call	?scrap@CvUnit@@QAEXXZ			; CvUnit::scrap

; 2358 : 		LogScrapUnit(pUnit, iNumArchaeologists, iNumSites, 0, 0);

	push	0
	push	0
	push	ebx
	push	ebp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T238847[esp+48], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, edi
	call	?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z ; CvEconomicAI::LogScrapUnit
$LN2@DisbandExt@2:

; 2359 : 	}
; 2360 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
?DisbandExtraArchaeologists@CvEconomicAI@@AAEXXZ ENDP	; CvEconomicAI::DisbandExtraArchaeologists
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	?push_back@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEIABI@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEIABI@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEIABI@Z PROC ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	esi
	mov	esi, ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 378  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXI@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN1@push_back:

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back:

; 380  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 381  : 	};

	ret	4
?push_back@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEIABI@Z ENDP ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back
_TEXT	ENDS
PUBLIC	?push_back_copy@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEXABII@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back_copy
; Function compile flags: /Ogtpy
;	COMDAT ?push_back_copy@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEXABII@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_uiNum$ = 12						; size = 4
?push_back_copy@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEXABII@Z PROC ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back_copy, COMDAT
; _this$ = ecx

; 408  : 	{

	push	esi
	push	edi

; 409  : 		uiNum += m_uiCurrSize;

	mov	edi, DWORD PTR _uiNum$[esp+4]
	mov	esi, ecx
	add	edi, DWORD PTR [esi+4]

; 410  : 		if( uiNum > m_uiCurrMaxSize )

	cmp	edi, DWORD PTR [esi+8]
	jbe	SHORT $LN4@push_back_

; 411  : 			GrowSize(uiNum);

	push	edi
	call	?GrowSize@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXI@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN4@push_back_:

; 412  : 		for(unsigned int i = m_uiCurrSize; i < uiNum; ++i){

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	jae	SHORT $LN13@push_back_
	mov	edx, DWORD PTR _element$[esp+4]
	push	ebx
$LL3@push_back_:
	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+eax*4]

; 413  : 			new( (void*)&m_pData[i] )T(element);

	test	ecx, ecx
	je	SHORT $LN2@push_back_
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
$LN2@push_back_:
	inc	eax
	cmp	eax, edi
	jb	SHORT $LL3@push_back_
	pop	ebx
$LN13@push_back_:

; 414  : 		}
; 415  : 		m_uiCurrSize = uiNum;

	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi

; 416  : 	};

	ret	8
?push_back_copy@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEXABII@Z ENDP ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back_copy
_TEXT	ENDS
PUBLIC	?resize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?resize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXI@Z PROC ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::resize, COMDAT
; _this$ = ecx

; 353  : 	{

	push	esi
	push	edi

; 354  : 		if( m_uiCurrMaxSize < uiNewSize ){

	mov	edi, DWORD PTR _uiNewSize$[esp+4]
	mov	esi, ecx
	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN6@resize

; 355  : 			GrowSize(uiNewSize);

	push	edi
	call	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize

; 356  : 		}
; 357  : 		m_uiCurrSize = MIN(uiNewSize, m_uiCurrMaxSize);

	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN6@resize
	mov	eax, DWORD PTR [esi+8]
	pop	edi
	mov	DWORD PTR [esi+4], eax
	pop	esi

; 358  : 	};

	ret	4

; 356  : 		}
; 357  : 		m_uiCurrSize = MIN(uiNewSize, m_uiCurrMaxSize);

$LN6@resize:
	lea	eax, DWORD PTR _uiNewSize$[esp+4]
	mov	ecx, DWORD PTR [eax]
	pop	edi
	mov	DWORD PTR [esi+4], ecx
	pop	esi

; 358  : 	};

	ret	4
?resize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXI@Z ENDP ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::resize
_TEXT	ENDS
PUBLIC	?push_back@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEIABH@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEIABH@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEIABH@Z PROC ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	esi
	mov	esi, ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@2

; 378  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN1@push_back@2:

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back@2
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back@2:

; 380  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 381  : 	};

	ret	4
?push_back@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEIABH@Z ENDP ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back
_TEXT	ENDS
PUBLIC	?push_back_copy@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXABHI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back_copy
; Function compile flags: /Ogtpy
;	COMDAT ?push_back_copy@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXABHI@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_uiNum$ = 12						; size = 4
?push_back_copy@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXABHI@Z PROC ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back_copy, COMDAT
; _this$ = ecx

; 408  : 	{

	push	esi
	push	edi

; 409  : 		uiNum += m_uiCurrSize;

	mov	edi, DWORD PTR _uiNum$[esp+4]
	mov	esi, ecx
	add	edi, DWORD PTR [esi+4]

; 410  : 		if( uiNum > m_uiCurrMaxSize )

	cmp	edi, DWORD PTR [esi+8]
	jbe	SHORT $LN4@push_back_@2

; 411  : 			GrowSize(uiNum);

	push	edi
	call	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN4@push_back_@2:

; 412  : 		for(unsigned int i = m_uiCurrSize; i < uiNum; ++i){

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	jae	SHORT $LN13@push_back_@2
	mov	edx, DWORD PTR _element$[esp+4]
	push	ebx
$LL3@push_back_@2:
	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+eax*4]

; 413  : 			new( (void*)&m_pData[i] )T(element);

	test	ecx, ecx
	je	SHORT $LN2@push_back_@2
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
$LN2@push_back_@2:
	inc	eax
	cmp	eax, edi
	jb	SHORT $LL3@push_back_@2
	pop	ebx
$LN13@push_back_@2:

; 414  : 		}
; 415  : 		m_uiCurrSize = uiNum;

	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi

; 416  : 	};

	ret	8
?push_back_copy@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXABHI@Z ENDP ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back_copy
_TEXT	ENDS
PUBLIC	?resize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAEXI@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?resize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAEXI@Z PROC ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::resize, COMDAT
; _this$ = ecx

; 353  : 	{

	push	esi
	push	edi

; 354  : 		if( m_uiCurrMaxSize < uiNewSize ){

	mov	edi, DWORD PTR _uiNewSize$[esp+4]
	mov	esi, ecx
	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN6@resize@2

; 355  : 			GrowSize(uiNewSize);

	push	edi
	call	?GrowSize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXI@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::GrowSize

; 356  : 		}
; 357  : 		m_uiCurrSize = MIN(uiNewSize, m_uiCurrMaxSize);

	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN6@resize@2
	mov	eax, DWORD PTR [esi+8]
	pop	edi
	mov	DWORD PTR [esi+4], eax
	pop	esi

; 358  : 	};

	ret	4

; 356  : 		}
; 357  : 		m_uiCurrSize = MIN(uiNewSize, m_uiCurrMaxSize);

$LN6@resize@2:
	lea	eax, DWORD PTR _uiNewSize$[esp+4]
	mov	ecx, DWORD PTR [eax]
	pop	edi
	mov	DWORD PTR [esi+4], ecx
	pop	esi

; 358  : 	};

	ret	4
?resize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAEXI@Z ENDP ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::resize
_TEXT	ENDS
PUBLIC	?push_back@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAEIABUGoodyHutUnitAssignment@CvEconomicAI@@@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAEIABUGoodyHutUnitAssignment@CvEconomicAI@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAEIABUGoodyHutUnitAssignment@CvEconomicAI@@@Z PROC ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	esi
	mov	esi, ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@3

; 378  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXI@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::GrowSize
$LN1@push_back@3:

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@3
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@3:

; 380  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 381  : 	};

	ret	4
?push_back@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAEIABUGoodyHutUnitAssignment@CvEconomicAI@@@Z ENDP ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEIABVCvPurchaseRequest@@@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEIABVCvPurchaseRequest@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEIABVCvPurchaseRequest@@@Z PROC ; FStaticVector<CvPurchaseRequest,6,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+84], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@4

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::GrowSize
$LN1@push_back@4:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back@4
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN4@push_back@4:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEIABVCvPurchaseRequest@@@Z ENDP ; FStaticVector<CvPurchaseRequest,6,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAEIABQAVCvUnit@@@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAEIABQAVCvUnit@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAEIABQAVCvUnit@@@Z PROC ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	esi
	mov	esi, ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@5

; 378  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXI@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::GrowSize
$LN1@push_back@5:

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back@5
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back@5:

; 380  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 381  : 	};

	ret	4
?push_back@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAEIABQAVCvUnit@@@Z ENDP ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::push_back
_TEXT	ENDS
PUBLIC	?push_back_copy@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAEXABHI@Z ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::push_back_copy
; Function compile flags: /Ogtpy
;	COMDAT ?push_back_copy@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAEXABHI@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_uiNum$ = 12						; size = 4
?push_back_copy@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAEXABHI@Z PROC ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::push_back_copy, COMDAT
; _this$ = ecx

; 408  : 	{

	push	esi
	push	edi

; 409  : 		uiNum += m_uiCurrSize;

	mov	edi, DWORD PTR _uiNum$[esp+4]
	mov	esi, ecx
	add	edi, DWORD PTR [esi+4]

; 410  : 		if( uiNum > m_uiCurrMaxSize )

	cmp	edi, DWORD PTR [esi+8]
	jbe	SHORT $LN4@push_back_@3

; 411  : 			GrowSize(uiNum);

	push	edi
	call	?GrowSize@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEXI@Z ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::GrowSize
$LN4@push_back_@3:

; 412  : 		for(unsigned int i = m_uiCurrSize; i < uiNum; ++i){

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	jae	SHORT $LN13@push_back_@3
	mov	edx, DWORD PTR _element$[esp+4]
	push	ebx
$LL3@push_back_@3:
	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+eax*4]

; 413  : 			new( (void*)&m_pData[i] )T(element);

	test	ecx, ecx
	je	SHORT $LN2@push_back_@3
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
$LN2@push_back_@3:
	inc	eax
	cmp	eax, edi
	jb	SHORT $LL3@push_back_@3
	pop	ebx
$LN13@push_back_@3:

; 414  : 		}
; 415  : 		m_uiCurrSize = uiNum;

	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi

; 416  : 	};

	ret	8
?push_back_copy@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAEXABHI@Z ENDP ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::push_back_copy
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ ; CvWeightedVector<CvUnit *,50,1>::CvWeightedVector<CvUnit *,50,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ PROC	; CvWeightedVector<CvUnit *,50,1>::CvWeightedVector<CvUnit *,50,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 50			; 00000032H
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ ENDP	; CvWeightedVector<CvUnit *,50,1>::CvWeightedVector<CvUnit *,50,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ ; CvWeightedVector<CvUnit *,50,1>::~CvWeightedVector<CvUnit *,50,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ PROC	; CvWeightedVector<CvUnit *,50,1>::~CvWeightedVector<CvUnit *,50,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted:
	ret	0
??1?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ ENDP	; CvWeightedVector<CvUnit *,50,1>::~CvWeightedVector<CvUnit *,50,1>
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@0@Z ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@0@Z PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@0@Z ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAEXI@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::reserve
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAEXI@Z
_TEXT	SEGMENT
_uiResSize$ = 8						; size = 4
?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::reserve, COMDAT
; _this$ = ecx

; 658  : 		GrowSizeToFit(uiResSize);

	jmp	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSizeToFit
?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::reserve
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@Z PROC ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+412], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@6

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSize
$LN1@push_back@6:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@6
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@6:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z
_TEXT	SEGMENT
__Tmp$239363 = -24					; size = 8
__Tmp$239291 = -16					; size = 8
__Tmp$239318 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 3
	cdq
	push	esi
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ebx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-8]
	push	eax
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Median<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+8]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_
$LL27@Unguarded_:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN99@Unguarded_
	jg	SHORT $LN99@Unguarded_

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_
$LN99@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL25@Unguarded_:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_
	jg	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+36]
	jae	SHORT $LN103@Unguarded_
	npad	6
$LL21@Unguarded_:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	jl	SHORT $LN20@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 8
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_
	mov	ebp, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$239291[esp+44], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	edx, DWORD PTR __Tmp$239291[esp+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
$LN20@Unguarded_:
	add	eax, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jb	SHORT $LL21@Unguarded_
$LN103@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+36]
	jbe	SHORT $LN115@Unguarded_
	lea	edx, DWORD PTR [ebx-8]
$LL14@Unguarded_:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jl	SHORT $LN13@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$239318[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$239318[esp+44]
	mov	DWORD PTR [edx+4], edi
$LN13@Unguarded_:
	sub	ebx, 8
	sub	edx, 8
	cmp	DWORD PTR __First$[esp+36], ebx
	jb	SHORT $LL14@Unguarded_
$LN111@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+36]
$LN115@Unguarded_:
	jne	SHORT $LN6@Unguarded_
	cmp	eax, DWORD PTR __Last$[esp+36]
	je	$LN105@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi
$LN64@Unguarded_:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	edi, ecx
	add	esi, 8
	add	ecx, 8
	add	eax, 8
	cmp	edi, edx
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$239363[esp+40], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$239363[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$239363[esp+40]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$239363[esp+44]
	mov	DWORD PTR [edx+4], edi
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN3@Unguarded_
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN78@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
$LN78@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebx
	je	SHORT $LN92@Unguarded_
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [ebx+4], edi
$LN92@Unguarded_:
	add	eax, 8

; 3076 : 		}

	jmp	$LL23@Unguarded_
$LN105@Unguarded_:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::make_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z PROC ; std::make_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@0@Z ; std::_Insertion_sort<CvPurchaseRequest *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@0@Z PROC ; std::_Insertion_sort<CvPurchaseRequest *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@00@Z ; std::_Insertion_sort1<CvPurchaseRequest *,CvPurchaseRequest>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@0@Z ENDP ; std::_Insertion_sort<CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z
_TEXT	SEGMENT
$T239473 = -4						; size = 1
$T239480 = -4						; size = 4
$T239476 = -4						; size = 4
__Cat$239484 = 8					; size = 1
$T239475 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z PROC ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T239480[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$239484[esp+4]
	mov	edx, DWORD PTR $T239475[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T239473[esp+12], bl
	mov	eax, DWORD PTR $T239473[esp+12]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR $T239476[esp+44], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+40]
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_@5:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ENDP ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@0000@Z ; stdext::unchecked_merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@0000@Z
_TEXT	SEGMENT
$T239524 = -4						; size = 1
$T239525 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@0000@Z PROC ; stdext::unchecked_merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Dest$[esp]
	mov	BYTE PTR $T239524[esp+4], 0
	mov	eax, DWORD PTR $T239524[esp+4]
	mov	ecx, DWORD PTR $T239525[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Merge@PAVCvPurchaseRequest@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>

; 5117 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@0000@Z ENDP ; stdext::unchecked_merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAVCvPurchaseRequest@@HV1@@std@@YAPAVCvPurchaseRequest@@PAV1@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_rotate<CvPurchaseRequest *,int,CvPurchaseRequest>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@PAVCvPurchaseRequest@@HV1@@std@@YAPAVCvPurchaseRequest@@PAV1@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z
_TEXT	SEGMENT
$T239536 = -20						; size = 20
$T239534 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T239535 = 20						; size = 4
$T239533 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAVCvPurchaseRequest@@HV1@@std@@YAPAVCvPurchaseRequest@@PAV1@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z PROC ; std::_Buffered_rotate<CvPurchaseRequest *,int,CvPurchaseRequest>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebx, DWORD PTR __Count2$[esp+20]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Tempbuf$[esp+28]
	push	edi
	mov	edi, DWORD PTR __Count1$[esp+32]
	cmp	edi, ebx
	jg	SHORT $LN4@Buffered_r
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen
	cmp	edi, eax
	jg	SHORT $LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR __Mid$[esp+32]
	mov	ebp, DWORD PTR __First$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T239533[esp+52], esp
	push	ebx
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T239534[esp+60]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	mov	eax, DWORD PTR $T239534[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN25@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edi, DWORD PTR __Last$[esp+32]
	push	ebp
	push	edi
	push	ebx
	call	??$unchecked_copy@PAVCvPurchaseRequest@@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@00@Z ; stdext::unchecked_copy<CvPurchaseRequest *,CvPurchaseRequest *>

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi]
	push	edi
	push	eax
	push	esi
	call	??$unchecked_copy_backward@PAVCvPurchaseRequest@@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvPurchaseRequest *,CvPurchaseRequest *>
	add	esp, 24					; 00000018H

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen
	cmp	ebx, eax
	jg	SHORT $LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR __Last$[esp+32]
	mov	ebp, DWORD PTR __Mid$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T239535[esp+52], esp
	push	ebx
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T239536[esp+60]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	mov	eax, DWORD PTR $T239536[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN45@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN45@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	edi, DWORD PTR __First$[esp+32]
	push	ebx
	push	ebp
	push	edi
	call	??$unchecked_copy_backward@PAVCvPurchaseRequest@@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvPurchaseRequest *,CvPurchaseRequest *>

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi]
	push	edi
	push	eax
	push	esi
	call	??$unchecked_copy@PAVCvPurchaseRequest@@PAV1@@stdext@@YAPAVCvPurchaseRequest@@PAV1@00@Z ; stdext::unchecked_copy<CvPurchaseRequest *,CvPurchaseRequest *>
	add	esp, 24					; 00000018H

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	esi, DWORD PTR __First$[esp+32]
	mov	eax, DWORD PTR __Mid$[esp+32]
	cmp	esi, eax
	je	SHORT $LN56@Buffered_r
	mov	ecx, DWORD PTR __Last$[esp+32]
	cmp	eax, ecx
	je	SHORT $LN56@Buffered_r
	xor	edi, edi
	push	edi
	push	edi
	push	ecx
	push	eax
	push	esi
	call	??$_Rotate@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00PAH0@Z ; std::_Rotate<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 20					; 00000014H
$LN56@Buffered_r:

; 2700 : 		std::advance(_First, _Count2);

	lea	ecx, DWORD PTR [ebx+ebx*2]

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	lea	eax, DWORD PTR [esi+ecx*4]
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@PAVCvPurchaseRequest@@HV1@@std@@YAPAVCvPurchaseRequest@@PAV1@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ENDP ; std::_Buffered_rotate<CvPurchaseRequest *,int,CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::pop_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	edx, eax
	push	esi
	sub	edx, ecx
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	push	edi
	jle	SHORT $LN12@pop_heap

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	ebx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	DWORD PTR [eax-4], ebx
	mov	eax, esp
	add	edx, -8					; fffffff8H
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN12@pop_heap:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvPurchaseRequest@@PAV1@H@std@@YAXPAVCvPurchaseRequest@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvPurchaseRequest *,CvPurchaseRequest *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvPurchaseRequest@@PAV1@H@std@@YAXPAVCvPurchaseRequest@@00HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T239760 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
$T239836 = 24						; size = 1
$T239837 = 24						; size = 1
$T239761 = 24						; size = 1
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvPurchaseRequest@@PAV1@H@std@@YAXPAVCvPurchaseRequest@@00HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvPurchaseRequest *,CvPurchaseRequest *,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ecx

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	edx, DWORD PTR __Count$[esp]
	mov	eax, DWORD PTR __Dest$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Chunk$[esp+4]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp+ebp]
	cmp	edi, edx
	jg	SHORT $LN3@Chunked_me
	lea	ebp, DWORD PTR [ebp+ebp*2]
	add	ebp, ebp
	add	ebp, ebp
	push	ebx
$LL50@Chunked_me:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	BYTE PTR $T239760[esp+20], 0
	mov	ebx, DWORD PTR $T239760[esp+20]
	push	ebx
	mov	ebx, DWORD PTR $T239761[esp+20]
	push	ebx
	lea	edx, DWORD PTR [ecx+ebp]
	push	eax
	lea	esi, DWORD PTR [edx+ebp]
	push	esi
	push	edx
	push	edx
	push	ecx
	call	??$_Merge@PAVCvPurchaseRequest@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>
	mov	edx, DWORD PTR __Count$[esp+44]
	sub	edx, edi
	add	esp, 28					; 0000001cH
	cmp	edx, edi

; 3297 : 		_First = _Mid2;

	mov	ecx, esi
	mov	DWORD PTR __Count$[esp+16], edx
	jge	SHORT $LL50@Chunked_me
	mov	ebp, DWORD PTR __Chunk$[esp+16]
	pop	ebx
$LN3@Chunked_me:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	cmp	edx, ebp
	jg	SHORT $LN2@Chunked_me

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	edx, DWORD PTR __Last$[esp+12]
	cmp	ecx, edx
	je	SHORT $LN41@Chunked_me
	sub	eax, ecx
	npad	6
$LL32@Chunked_me:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax+ecx], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+ecx+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+ecx+8], esi
	add	ecx, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL32@Chunked_me
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	pop	ecx
	ret	0
$LN2@Chunked_me:

; 3302 : 	else
; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);
; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	BYTE PTR $T239836[esp+12], 0
	mov	esi, DWORD PTR $T239836[esp+12]
	push	esi
	mov	esi, DWORD PTR $T239837[esp+16]
	push	esi
	push	eax
	mov	eax, DWORD PTR __Last$[esp+24]
	push	eax
	lea	edx, DWORD PTR [ebp+ebp*2]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	push	edx
	push	ecx
	call	??$_Merge@PAVCvPurchaseRequest@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
$LN41@Chunked_me:
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	pop	ecx
	ret	0
??$_Chunked_merge@PAVCvPurchaseRequest@@PAV1@H@std@@YAXPAVCvPurchaseRequest@@00HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvPurchaseRequest *,CvPurchaseRequest *,int>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T239863 = -24						; size = 4
$T239856 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
$T239857 = 12						; size = 4
$T239855 = 12						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ebp, DWORD PTR __Last1$[esp+28]
	push	esi
	mov	esi, DWORD PTR __First1$[esp+32]
	xor	ebx, ebx
	push	edi
	mov	edi, DWORD PTR __First2$[esp+36]
	mov	DWORD PTR $T239863[esp+40], ebx
	cmp	esi, ebp
	je	SHORT $LN3@Merge@2
	npad	3
$LL4@Merge@2:
	cmp	edi, DWORD PTR __Last2$[esp+36]
	je	SHORT $LN3@Merge@2

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR [edi+8]
	cmp	eax, DWORD PTR [esi+8]

; 2515 : 			*_Dest = *_First2, ++_First2;

	lea	ecx, DWORD PTR __Dest$[esp+36]
	jle	SHORT $LN2@Merge@2
	push	edi
	call	??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABVCvPurchaseRequest@@@Z ; std::_Temp_iterator<CvPurchaseRequest>::operator=
	add	edi, 12					; 0000000cH

; 2516 : 		else

	jmp	SHORT $LN1@Merge@2
$LN2@Merge@2:

; 2517 : 			*_Dest = *_First1, ++_First1;

	push	esi
	call	??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABVCvPurchaseRequest@@@Z ; std::_Temp_iterator<CvPurchaseRequest>::operator=
	add	esi, 12					; 0000000cH
$LN1@Merge@2:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	esi, ebp
	jne	SHORT $LL4@Merge@2
$LN3@Merge@2:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T239855[esp+56], esp
	push	ebp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+76]
	lea	edx, DWORD PTR $T239856[esp+64]
	push	esi
	push	edx
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[esp+84], eax
	mov	eax, DWORD PTR $T239856[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN36@Merge@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN36@Merge@2:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Last2$[esp+36]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+36]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T239857[esp+56], esp
	push	edx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+76]
	push	edi
	push	esi
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	mov	eax, DWORD PTR __Dest$[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN57@Merge@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Merge@2:

; 2521 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	?Reset@CvEconomicAI@@QAEXXZ			; CvEconomicAI::Reset
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
;	COMDAT ?Reset@CvEconomicAI@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvEconomicAI@@QAEXXZ PROC			; CvEconomicAI::Reset, COMDAT
; _this$ = ecx

; 297  : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 298  : 	int iI;
; 299  : 
; 300  : 	for(iI = 0; iI < m_pAIStrategies->GetNumEconomicAIStrategies(); iI++)

	mov	ecx, DWORD PTR [esi+8]
	push	edi
	mov	edi, DWORD PTR [ecx+8]
	sub	edi, DWORD PTR [ecx+4]
	xor	edx, edx
	xor	eax, eax
	test	edi, -4					; fffffffcH
	jle	SHORT $LN13@Reset
	npad	5
$LL15@Reset:

; 301  : 	{
; 302  : 		m_pabUsingStrategy[iI] = false;

	mov	ecx, DWORD PTR [esi+12]
	mov	BYTE PTR [eax+ecx], dl

; 303  : 		m_paiTurnStrategyAdopted[iI] = -1;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+eax*4], -1
	mov	ecx, DWORD PTR [esi+8]
	mov	edi, DWORD PTR [ecx+8]
	sub	edi, DWORD PTR [ecx+4]
	inc	eax
	sar	edi, 2
	cmp	eax, edi
	jl	SHORT $LL15@Reset
$LN13@Reset:

; 304  : 	}
; 305  : 
; 306  : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)
; 307  : 	{
; 308  : 		m_auiYields[ui] = 0;

	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [ecx+20], edx

; 309  : 	}
; 310  : 
; 311  : 	for(uint ui = 0; ui < m_aiExplorationPlots.size(); ui++)

	xor	eax, eax
	cmp	DWORD PTR [esi+68], edx
	jbe	SHORT $LN7@Reset
	npad	5
$LL9@Reset:

; 312  : 	{
; 313  : 		m_aiExplorationPlots[ui] = -1;

	mov	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR [ecx+eax*4], -1

; 314  : 		m_aiExplorationPlotRatings[ui] = -1;

	mov	ecx, DWORD PTR [esi+76]
	mov	DWORD PTR [ecx+eax*4], -1
	inc	eax
	cmp	eax, DWORD PTR [esi+68]
	jb	SHORT $LL9@Reset
$LN7@Reset:

; 315  : 	}
; 316  : 
; 317  : 	for(uint ui = 0; ui < m_aiGoodyHutPlots.size(); ui++)

	xor	eax, eax
	cmp	DWORD PTR [esi+92], edx
	jbe	SHORT $LN4@Reset
$LL6@Reset:

; 318  : 	{
; 319  : 		m_aiGoodyHutPlots[ui] = -1;

	mov	ecx, DWORD PTR [esi+88]
	mov	DWORD PTR [ecx+eax*4], -1
	mov	ecx, DWORD PTR [esi+100]
	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	eax

; 320  : 		m_aiGoodyHutUnitAssignments[ui].Clear();

	mov	DWORD PTR [ecx], -1
	mov	DWORD PTR [ecx+4], -1
	cmp	eax, DWORD PTR [esi+92]
	jb	SHORT $LL6@Reset
$LN4@Reset:

; 321  : 	}
; 322  : 
; 323  : 	m_bExplorationPlotsDirty = true;
; 324  : 
; 325  : 	for(uint ui = 0; ui < NUM_PURCHASE_TYPES; ui++)

	xor	ebp, ebp
	mov	BYTE PTR [esi], 1

; 326  : 	{
; 327  : 		CvPurchaseRequest request;
; 328  : 		request.m_eType = (PurchaseType)ui;
; 329  : 		request.m_iAmount = 0;

	xor	ebx, ebx
	lea	edi, DWORD PTR [esi+112]
	npad	2
$LL3@Reset:

; 330  : 		request.m_iPriority = 0;
; 331  : 		m_RequestedSavings.push_back(request);

	mov	eax, DWORD PTR [edi+8]
	mov	BYTE PTR [edi+84], dl
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN40@Reset
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::GrowSize
	xor	edx, edx
$LN40@Reset:
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, edx
	je	SHORT $LN43@Reset
	mov	DWORD PTR [eax], ebp
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ecx
$LN43@Reset:
	inc	DWORD PTR [edi+4]
	inc	ebp
	cmp	ebp, 6
	jb	SHORT $LL3@Reset

; 332  : 	}
; 333  : 
; 334  : 	m_iExplorersDisbanded = 0;
; 335  : 	m_eReconState = NO_RECON_STATE;

	or	eax, -1
	mov	DWORD PTR [esi+36], edx
	mov	DWORD PTR [esi+28], eax

; 336  : 	m_eNavalReconState = NO_RECON_STATE;

	mov	DWORD PTR [esi+32], eax

; 337  : 	m_iLastTurnWorkerDisbanded = -1;

	mov	DWORD PTR [esi+40], eax

; 338  : 	m_iVisibleAntiquitySites = 0;

	mov	DWORD PTR [esi+44], edx

; 339  : 
; 340  : 	// Cached AI defines
; 341  : 	m_iMinimumSettleFertility = GC.getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2028
	mov	DWORD PTR [esi+48], edx

; 342  : 
; 343  : 	// Basic number of cities desired for early growth is in XML (10)
; 344  : 	// Later will scale that up or down based on ratio of FLAVOR_EXPANSION to FLAVOR_GROWTH
; 345  : 	m_iEarlyCityNumberTarget = GC.getAI_STRATEGY_EARLY_EXPANSION_NUM_CITIES_LIMIT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2012
	pop	edi
	mov	DWORD PTR [esi+24], eax
	pop	esi
	pop	ebp
	pop	ebx

; 346  : }

	ret	0
?Reset@CvEconomicAI@@QAEXXZ ENDP			; CvEconomicAI::Reset
_TEXT	ENDS
PUBLIC	?Read@CvEconomicAI@@QAEXAAVFDataStream@@@Z	; CvEconomicAI::Read
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvEconomicAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_iTemp$ = -16						; size = 4
_iTemp$240268 = -12					; size = 4
$T240208 = -12						; size = 4
$T240187 = -12						; size = 4
$T240134 = -12						; size = 4
$T240113 = -12						; size = 4
_iDummy$226076 = -12					; size = 4
$T240030 = -12						; size = 4
_iDummy$226066 = -12					; size = 4
$T240029 = -12						; size = 4
_wrapGetNumEconomicAIStrategies$ = -12			; size = 8
_uiVersion$ = -4					; size = 4
_iEntriesToRead$ = 8					; size = 4
_kStream$ = 8						; size = 4
?Read@CvEconomicAI@@QAEXAAVFDataStream@@@Z PROC		; CvEconomicAI::Read, COMDAT
; _this$ = ecx

; 350  : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi

; 351  : 	// Version number to maintain backwards compatibility
; 352  : 	uint uiVersion;
; 353  : 	kStream >> uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+28]
	push	edi
	mov	ebp, ecx
	lea	eax, DWORD PTR _uiVersion$[esp+36]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _this$[esp+40], ebp
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 354  : 
; 355  : 	int iEntriesToRead;
; 356  : 
; 357  : 	FAssertMsg(m_pAIStrategies != NULL && m_pAIStrategies->GetNumEconomicAIStrategies() > 0, "Number of AIStrategies to serialize is expected to greater than 0");
; 358  : 
; 359  : 	kStream >> iEntriesToRead;

	lea	ecx, DWORD PTR _iEntriesToRead$[esp+32]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 360  : 
; 361  : #ifdef _MSC_VER
; 362  : #pragma warning ( push )
; 363  : #pragma warning ( disable : 6011 ) // no clear solution or recovery if m_pAIStrategies is ever NULL
; 364  : #endif//_MSC_VER
; 365  : 	ArrayWrapper<bool> wrapGetNumEconomicAIStrategies(iEntriesToRead, m_pabUsingStrategy);

	mov	edx, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR _iEntriesToRead$[esp+32]

; 366  : #ifdef _MSC_VER
; 367  : #pragma warning ( pop )
; 368  : #endif//_MSC_VER
; 369  : 
; 370  : 	kStream >> wrapGetNumEconomicAIStrategies;

	lea	ecx, DWORD PTR _wrapGetNumEconomicAIStrategies$[esp+36]
	push	ecx
	push	esi
	mov	DWORD PTR _wrapGetNumEconomicAIStrategies$[esp+44], edx
	mov	DWORD PTR _wrapGetNumEconomicAIStrategies$[esp+48], eax
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>

; 371  : 
; 372  : 	ArrayWrapper<int> wrapGetNumEconomicAIStrategies2(iEntriesToRead, m_paiTurnStrategyAdopted);
; 373  : 	kStream >> wrapGetNumEconomicAIStrategies2;

	mov	ebx, DWORD PTR _iEntriesToRead$[esp+40]
	mov	edi, DWORD PTR [ebp+16]
	add	esp, 8
	test	ebx, ebx
	jle	SHORT $LN29@Read
$LL31@Read:
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL31@Read
$LN29@Read:

; 374  : 
; 375  : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	xor	edi, edi
$LL18@Read:

; 376  : 	{
; 377  : 		kStream >> m_auiYields[ui];

	mov	edx, DWORD PTR [ebp+52]
	add	edx, edi
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read
	add	edi, 4
	cmp	edi, 24					; 00000018H
	jb	SHORT $LL18@Read

; 378  : 	}
; 379  : 
; 380  : 	kStream >> m_bExplorationPlotsDirty;

	push	ebp
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 381  : 
; 382  : 	kStream >> iEntriesToRead;

	lea	eax, DWORD PTR _iEntriesToRead$[esp+32]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 383  : 
; 384  : #define MAX_PLOT_ARRAY_SIZE	((152+1)*(96+1))
; 385  : 	int iMaxEntriesToRead = MIN(MAX_PLOT_ARRAY_SIZE, iEntriesToRead);

	mov	eax, 14841				; 000039f9H
	cmp	DWORD PTR _iEntriesToRead$[esp+32], eax
	mov	DWORD PTR $T240029[esp+36], eax
	lea	eax, DWORD PTR _iEntriesToRead$[esp+32]
	jl	SHORT $LN51@Read
	lea	eax, DWORD PTR $T240029[esp+36]
$LN51@Read:
	mov	edi, DWORD PTR [eax]

; 386  : 
; 387  : 	m_aiExplorationPlots.resize(iMaxEntriesToRead);

	lea	ebx, DWORD PTR [ebp+64]
	mov	DWORD PTR $T240113[esp+36], edi
	cmp	DWORD PTR [ebx+8], edi
	jae	SHORT $LN52@Read
	push	edi
	mov	ecx, ebx
	call	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN52@Read:
	cmp	DWORD PTR [ebx+8], edi
	lea	eax, DWORD PTR [ebx+8]
	jb	SHORT $LN58@Read
	lea	eax, DWORD PTR $T240113[esp+36]
$LN58@Read:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ebx+4], ecx

; 388  : 	m_aiExplorationPlotRatings.resize(iMaxEntriesToRead);

	lea	ebx, DWORD PTR [ebp+76]
	mov	DWORD PTR $T240134[esp+36], edi
	cmp	DWORD PTR [ebx+8], edi
	jae	SHORT $LN59@Read
	push	edi
	mov	ecx, ebx
	call	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN59@Read:
	cmp	DWORD PTR [ebx+8], edi
	lea	eax, DWORD PTR [ebx+8]
	jb	SHORT $LN65@Read
	lea	eax, DWORD PTR $T240134[esp+36]
$LN65@Read:
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ebx+4], edx

; 389  : 
; 390  : 	for(int i = 0; i < iMaxEntriesToRead; i++)

	xor	ebx, ebx
	test	edi, edi
	jle	SHORT $LN13@Read
$LL150@Read:
	mov	eax, DWORD PTR _this$[esp+36]
	add	eax, 64					; 00000040H
	mov	eax, DWORD PTR [eax]
	lea	ebp, DWORD PTR [ebx*4]
	add	eax, ebp

; 391  : 	{
; 392  : 		kStream >> m_aiExplorationPlots[i];

	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	eax, DWORD PTR _this$[esp+36]
	mov	ecx, DWORD PTR [eax+76]
	add	eax, 76					; 0000004cH
	add	ecx, ebp

; 393  : 		kStream >> m_aiExplorationPlotRatings[i];

	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	ebx
	cmp	ebx, edi
	jl	SHORT $LL150@Read

; 389  : 
; 390  : 	for(int i = 0; i < iMaxEntriesToRead; i++)

	mov	ebp, DWORD PTR _this$[esp+36]
$LN13@Read:

; 394  : 	}
; 395  : 
; 396  : 	// Skip any ones that go over the limit
; 397  : 	for(int i = iMaxEntriesToRead; i < iEntriesToRead; i++)

	cmp	edi, DWORD PTR _iEntriesToRead$[esp+32]
	jge	SHORT $LN10@Read
$LL12@Read:

; 398  : 	{
; 399  : 		int iDummy;
; 400  : 		kStream >> iDummy;

	lea	edx, DWORD PTR _iDummy$226066[esp+36]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 401  : 		kStream >> iDummy;

	lea	eax, DWORD PTR _iDummy$226066[esp+36]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	edi
	cmp	edi, DWORD PTR _iEntriesToRead$[esp+32]
	jl	SHORT $LL12@Read
$LN10@Read:

; 402  : 	}
; 403  : 
; 404  : 	// goody hut plots
; 405  : 	kStream >> iEntriesToRead;

	lea	ecx, DWORD PTR _iEntriesToRead$[esp+32]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 406  : 	iMaxEntriesToRead = MIN(MAX_PLOT_ARRAY_SIZE, iEntriesToRead);

	mov	eax, 14841				; 000039f9H
	cmp	DWORD PTR _iEntriesToRead$[esp+32], eax
	mov	DWORD PTR $T240030[esp+36], eax
	lea	eax, DWORD PTR _iEntriesToRead$[esp+32]
	jl	SHORT $LN83@Read
	lea	eax, DWORD PTR $T240030[esp+36]
$LN83@Read:
	mov	ebx, DWORD PTR [eax]

; 407  : 	m_aiGoodyHutPlots.resize(iMaxEntriesToRead);

	lea	edi, DWORD PTR [ebp+88]
	mov	DWORD PTR $T240187[esp+36], ebx
	cmp	DWORD PTR [edi+8], ebx
	jae	SHORT $LN84@Read
	push	ebx
	mov	ecx, edi
	call	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN84@Read:
	cmp	DWORD PTR [edi+8], ebx
	lea	eax, DWORD PTR [edi+8]
	jb	SHORT $LN90@Read
	lea	eax, DWORD PTR $T240187[esp+36]
$LN90@Read:
	mov	edx, DWORD PTR [eax]

; 408  : 	m_aiGoodyHutUnitAssignments.resize(iMaxEntriesToRead);

	add	ebp, 100				; 00000064H
	mov	DWORD PTR [edi+4], edx
	lea	edi, DWORD PTR [ebp+8]
	mov	DWORD PTR $T240208[esp+36], ebx
	cmp	DWORD PTR [edi], ebx
	jae	SHORT $LN96@Read
	push	ebx
	mov	ecx, ebp
	call	?GrowSize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXI@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::GrowSize
	cmp	DWORD PTR [edi], ebx
	jb	SHORT $LN97@Read
$LN96@Read:
	lea	edi, DWORD PTR $T240208[esp+36]
$LN97@Read:
	mov	eax, DWORD PTR [edi]

; 409  : 
; 410  : 	for(int i = 0; i < iMaxEntriesToRead; i++)

	xor	edi, edi
	mov	DWORD PTR [ebp+4], eax
	test	ebx, ebx
	jle	SHORT $LN7@Read
$LL9@Read:
	mov	eax, DWORD PTR _this$[esp+36]
	mov	ecx, DWORD PTR [eax+88]
	add	eax, 88					; 00000058H
	lea	edx, DWORD PTR [ecx+edi*4]

; 411  : 	{
; 412  : 		kStream >> m_aiGoodyHutPlots[i];

	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	eax, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [edi*8]
	add	eax, ecx

; 413  : 		m_aiGoodyHutUnitAssignments[i].Clear();

	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1
	mov	eax, DWORD PTR [ebp]
	add	eax, ecx

; 414  : 		kStream >> m_aiGoodyHutUnitAssignments[i].m_iUnitID;

	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL9@Read
$LN7@Read:

; 415  : 	}
; 416  : 
; 417  : 	// Skip any ones that go over the limit
; 418  : 	for(int i = iMaxEntriesToRead; i < iEntriesToRead; i++)

	cmp	ebx, DWORD PTR _iEntriesToRead$[esp+32]
	mov	edi, ebx
	jge	SHORT $LN4@Read
	npad	4
$LL6@Read:

; 419  : 	{
; 420  : 		int iDummy;
; 421  : 		kStream >> iDummy;

	lea	ecx, DWORD PTR _iDummy$226076[esp+36]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 422  : 		kStream >> iDummy;

	lea	edx, DWORD PTR _iDummy$226076[esp+36]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	edi
	cmp	edi, DWORD PTR _iEntriesToRead$[esp+32]
	jl	SHORT $LL6@Read
$LN4@Read:

; 423  : 	}
; 424  : 
; 425  : 	int iTemp;
; 426  : 	kStream >> iTemp;

	lea	eax, DWORD PTR _iTemp$[esp+36]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 427  : 	m_eReconState = (ReconState)iTemp;

	mov	ecx, DWORD PTR _iTemp$[esp+36]
	mov	edi, DWORD PTR _this$[esp+36]

; 428  : 	kStream >> iTemp;

	lea	edx, DWORD PTR _iTemp$[esp+36]
	mov	DWORD PTR [edi+28], ecx
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 429  : 	m_eNavalReconState = (ReconState)iTemp;

	mov	eax, DWORD PTR _iTemp$[esp+36]

; 430  : 
; 431  : 	kStream >> m_iExplorersDisbanded;

	lea	ecx, DWORD PTR [edi+36]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR [edi+32], eax
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 432  : 	kStream >> m_iLastTurnWorkerDisbanded;

	lea	edx, DWORD PTR [edi+40]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 433  : 	kStream >> m_iVisibleAntiquitySites;

	lea	eax, DWORD PTR [edi+44]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 434  : 
; 435  : 	kStream >> iEntriesToRead;

	lea	ecx, DWORD PTR _iEntriesToRead$[esp+32]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 436  : 	for(int i = 0; i < iEntriesToRead; i++)

	xor	ebx, ebx
	cmp	DWORD PTR _iEntriesToRead$[esp+32], ebx
	jle	SHORT $LN1@Read

; 423  : 	}
; 424  : 
; 425  : 	int iTemp;
; 426  : 	kStream >> iTemp;

	xor	ebp, ebp
	jmp	SHORT $LN3@Read
$LL151@Read:
	mov	edi, DWORD PTR _this$[esp+36]
$LN3@Read:

; 437  : 	{
; 438  : 		kStream >> m_RequestedSavings[i];

	mov	edi, DWORD PTR [edi+112]
	lea	edx, DWORD PTR _iTemp$240268[esp+36]
	push	edx
	mov	ecx, esi
	add	edi, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	eax, DWORD PTR _iTemp$240268[esp+36]
	lea	ecx, DWORD PTR [edi+4]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR [edi], eax
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 8
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	ebx
	add	ebp, 12					; 0000000cH
	cmp	ebx, DWORD PTR _iEntriesToRead$[esp+32]
	jl	SHORT $LL151@Read
$LN1@Read:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 439  : 	}
; 440  : }

	add	esp, 20					; 00000014H
	ret	4
?Read@CvEconomicAI@@QAEXAAVFDataStream@@@Z ENDP		; CvEconomicAI::Read
_TEXT	ENDS
PUBLIC	?LogMonitor@CvEconomicAI@@QAEXXZ		; CvEconomicAI::LogMonitor
EXTRN	?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ:PROC ; CvTreasury::GetImprovementGoldMaintenance
EXTRN	?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ:PROC ; CvTreasury::GetBuildingGoldMaintenance
EXTRN	?GetCityConnectionGoldTimes100@CvTreasury@@QBEHXZ:PROC ; CvTreasury::GetCityConnectionGoldTimes100
EXTRN	?GetGoldPerTurnFromTraits@CvTreasury@@QBEHXZ:PROC ; CvTreasury::GetGoldPerTurnFromTraits
EXTRN	?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ:PROC ; CvTreasury::GetGoldPerTurnFromReligion
EXTRN	?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ:PROC ; CvTreasury::GetGoldPerTurnFromDiplomacy
EXTRN	?GetCityConnectionGold@CvTreasury@@QBEHXZ:PROC	; CvTreasury::GetCityConnectionGold
EXTRN	?GetGold@CvTreasury@@QBEHXZ:PROC		; CvTreasury::GetGold
EXTRN	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z:PROC ; CvTreasury::GetGoldFromCitiesTimes100
EXTRN	?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ:PROC ; CvPlayerTrade::GetNumTradeRoutesPossible
EXTRN	?GetNumTradeRoutesUsed@CvPlayerTrade@@QAEH_N@Z:PROC ; CvPlayerTrade::GetNumTradeRoutesUsed
EXTRN	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ:PROC ; CvPlayer::GetTrade
EXTRN	?isBeingWorked@CvPlot@@QBE_NXZ:PROC		; CvPlot::isBeingWorked
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
EXTRN	?GetHappiness@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetHappiness
EXTRN	?GetFaith@CvPlayer@@QBEHXZ:PROC			; CvPlayer::GetFaith
EXTRN	?GetJONSCultureEverGenerated@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetJONSCultureEverGenerated
EXTRN	?GetNumPoliciesOwned@CvPlayerPolicies@@QBEHXZ:PROC ; CvPlayerPolicies::GetNumPoliciesOwned
EXTRN	?GetTotalFaithPerTurn@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetTotalFaithPerTurn
EXTRN	?GetTotalJONSCulturePerTurn@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetTotalJONSCulturePerTurn
EXTRN	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::calculateTotalYield
;	COMDAT ?bFirstRun@?7??LogMonitor@CvEconomicAI@@QAEXXZ@4_NA
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_DATA	SEGMENT
?bFirstRun@?7??LogMonitor@CvEconomicAI@@QAEXXZ@4_NA DB 01H ; `CvEconomicAI::LogMonitor'::`8'::bFirstRun
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogMonitor@CvEconomicAI@@QAEXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?LogMonitor@CvEconomicAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogMonitor@CvEconomicAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$7
	DD	06H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$26
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?LogMonitor@CvEconomicAI@@QAEXXZ
_TEXT	SEGMENT
tv2253 = -248						; size = 4
$T240336 = -248						; size = 4
$T240335 = -248						; size = 4
$T240334 = -248						; size = 4
$T240333 = -248						; size = 4
$T240332 = -248						; size = 4
$T240331 = -248						; size = 4
_iGPTFromReligion$ = -248				; size = 4
$T240330 = -248						; size = 4
$T240329 = -248						; size = 4
$T240328 = -248						; size = 4
$T240327 = -248						; size = 4
$T240326 = -248						; size = 4
$T240325 = -248						; size = 4
$T240324 = -248						; size = 4
$T240323 = -248						; size = 4
$T240322 = -248						; size = 4
$T240321 = -248						; size = 4
$T240320 = -248						; size = 4
$T240319 = -248						; size = 4
_uiPlotIndex$226810 = -248				; size = 4
$T240317 = -248						; size = 4
$T240316 = -248						; size = 4
$T240315 = -248						; size = 4
$T240314 = -248						; size = 4
$T240313 = -248						; size = 4
$T240312 = -248						; size = 4
$T240311 = -248						; size = 4
$T240310 = -248						; size = 4
$T240309 = -248						; size = 4
$T240308 = -248						; size = 4
$T240307 = -248						; size = 4
$T240306 = -248						; size = 4
$T240305 = -248						; size = 4
$T240304 = -248						; size = 4
$T240303 = -248						; size = 4
$T240302 = -248						; size = 4
$T240301 = -248						; size = 4
$T240299 = -248						; size = 4
_bBuildHeader$ = -241					; size = 1
_iGPTFromDiplomacy$ = -240				; size = 4
_aiPlots$ = -240					; size = 4
$T240300 = -240						; size = 4
_strHeader$ = -236					; size = 28
_strLog$ = -208						; size = 28
_iWorkedTiles$ = -180					; size = 4
_pLog$ = -176						; size = 4
_iLoopCity$ = -172					; size = 4
_m_aiNumImprovements$ = -168				; size = 12
_iLoopUnit$ = -156					; size = 4
_strPlayerName$ = -152					; size = 28
_strLogName$ = -124					; size = 28
$T240297 = -96						; size = 28
$T240298 = -68						; size = 28
_str$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
?LogMonitor@CvEconomicAI@@QAEXXZ PROC			; CvEconomicAI::LogMonitor, COMDAT
; _this$ = ecx

; 1317 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?LogMonitor@CvEconomicAI@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 1318 : 	if(!(GC.getLogging() && GC.getAILogging()))

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN32@LogMonitor
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN32@LogMonitor

; 1319 : 	{
; 1320 : 		return;
; 1321 : 	}
; 1322 : 
; 1323 : 	// don't log minor civs for now
; 1324 : 	if(m_pPlayer->isMinorCiv())

	mov	ecx, DWORD PTR [esi+4]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN32@LogMonitor

; 1325 : 	{
; 1326 : 		return;
; 1327 : 	}
; 1328 : 
; 1329 : 	static bool bFirstRun = true;
; 1330 : 	bool bBuildHeader = false;
; 1331 : 	CvString strHeader;

	lea	ecx, DWORD PTR _strHeader$[esp+264]
	mov	BYTE PTR _bBuildHeader$[esp+264], al
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+272], ebx

; 1332 : 	if(bFirstRun)

	cmp	BYTE PTR ?bFirstRun@?7??LogMonitor@CvEconomicAI@@QAEXXZ@4_NA, bl
	je	SHORT $LN30@LogMonitor

; 1333 : 	{
; 1334 : 		bFirstRun = false;

	mov	BYTE PTR ?bFirstRun@?7??LogMonitor@CvEconomicAI@@QAEXXZ@4_NA, bl

; 1335 : 		bBuildHeader = true;

	mov	BYTE PTR _bBuildHeader$[esp+264], 1
$LN30@LogMonitor:

; 1336 : 	}
; 1337 : 
; 1338 : 	CvString strLog;

	lea	ecx, DWORD PTR _strLog$[esp+264]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1339 : 
; 1340 : 	// Find the name of this civ and city
; 1341 : 	CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$[esp+264]
	mov	BYTE PTR __$EHRec$[esp+272], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1342 : 	strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+272], 2
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$[esp+264]
	cmp	eax, ebx
	je	SHORT $LN91@LogMonitor
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN90@LogMonitor
$LN91@LogMonitor:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN90@LogMonitor:

; 1343 : 	CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$[esp+264]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1344 : 
; 1345 : 	// Open the log file
; 1346 : 	if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR __$EHRec$[esp+272], 3
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	test	al, al
	je	$LN29@LogMonitor

; 1347 : 	{
; 1348 : 		strLogName = "EconomicMonitorLog_" + strPlayerName + ".csv";

	lea	eax, DWORD PTR _strPlayerName$[esp+264]
	push	eax
	lea	ecx, DWORD PTR $T240297[esp+268]
	push	OFFSET $SG226655
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG226654
	push	eax
	lea	edx, DWORD PTR $T240298[esp+284]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+296], 4
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+272], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$[esp+268]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T240298[esp+264]
	mov	BYTE PTR __$EHRec$[esp+272], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T240297[esp+264]
	mov	BYTE PTR __$EHRec$[esp+272], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1349 : 	}
; 1350 : 	else

	jmp	SHORT $LN28@LogMonitor
$LN29@LogMonitor:

; 1351 : 	{
; 1352 : 		strLogName = "EconomicMonitorLog.csv";

	push	OFFSET $SG226657
	lea	ecx, DWORD PTR _strLogName$[esp+268]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
$LN28@LogMonitor:

; 1353 : 	}
; 1354 : 
; 1355 : 	FILogFile* pLog;
; 1356 : 	pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strLogName$[esp+264]
	mov	edi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [edi]
	push	ebx
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, edi
	call	eax

; 1357 : 
; 1358 : 	CvString str;

	lea	ecx, DWORD PTR _str$[esp+264]
	mov	DWORD PTR _pLog$[esp+264], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1359 : 
; 1360 : 	// civ name
; 1361 : 	AppendToLog(strHeader, strLog, "Civ Name", strPlayerName);

	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strPlayerName$[esp+292]
	mov	DWORD PTR $T240299[esp+292], esp
	mov	ecx, esp
	push	edx
	mov	BYTE PTR __$EHRec$[esp+304], 6
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240300[esp+320], esp
	mov	ecx, esp
	push	OFFSET $SG226662
	mov	BYTE PTR __$EHRec$[esp+332], 7
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+320]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+324]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+336], 6
	call	?AppendToLog@@YAXAAVCvString@@0V1@1@Z	; AppendToLog

; 1362 : 
; 1363 : 	// turn
; 1364 : 	AppendToLog(strHeader, strLog, "Turn", GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	esp, 64					; 00000040H
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240301[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226664
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+296]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+300]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1365 : 
; 1366 : 	// # cities
; 1367 : 	AppendToLog(strHeader, strLog, "# Cities", GetPlayer()->getNumCities());

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 40					; 00000028H
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240302[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226666
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+296]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+300]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1368 : 
; 1369 : 	// total pop
; 1370 : 	int iPop = 0;
; 1371 : 	int iLoopCity = 0;
; 1372 : 	CvCity* pLoopCity = NULL;
; 1373 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iLoopCity))

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 40					; 00000028H
	push	ebx
	lea	eax, DWORD PTR _iLoopCity$[esp+268]
	push	eax
	xor	edi, edi
	mov	DWORD PTR _iLoopCity$[esp+272], ebx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	cmp	eax, ebx
	je	SHORT $LN25@LogMonitor
	npad	5
$LL27@LogMonitor:

; 1374 : 	{
; 1375 : 		iPop += pLoopCity->getPopulation();

	mov	ecx, eax
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	lea	edx, DWORD PTR _iLoopCity$[esp+268]
	push	edx
	add	edi, eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	cmp	eax, ebx
	jne	SHORT $LL27@LogMonitor
$LN25@LogMonitor:

; 1376 : 	}
; 1377 : 	AppendToLog(strHeader, strLog, "Pop", iPop);

	push	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240303[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226674
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+296]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+300]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1378 : 
; 1379 : 	// total yields this turn
; 1380 : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	xor	edi, edi
$LL24@LogMonitor:

; 1381 : 	{
; 1382 : 		switch(ui)

	cmp	edi, 5
	ja	$LN23@LogMonitor
	jmp	DWORD PTR $LN408@LogMonitor[edi*4]
$LN19@LogMonitor:

; 1383 : 		{
; 1384 : 		case YIELD_FOOD:
; 1385 : 			AppendToLog(strHeader, strLog, "Food", m_pPlayer->calculateTotalYield((YieldTypes)ui));

	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	call	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::calculateTotalYield
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240304[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226686
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+296]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+300]
	push	eax

; 1386 : 			break;

	jmp	$LN406@LogMonitor
$LN18@LogMonitor:

; 1387 : 		case YIELD_PRODUCTION:
; 1388 : 			AppendToLog(strHeader, strLog, "Production", m_pPlayer->calculateTotalYield((YieldTypes)ui));

	mov	ecx, DWORD PTR [esi+4]
	push	1
	call	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::calculateTotalYield
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240305[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226690
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+296]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+300]
	push	edx

; 1389 : 			break;

	jmp	$LN406@LogMonitor
$LN17@LogMonitor:

; 1390 : 		case YIELD_GOLD:
; 1391 : 			AppendToLog(strHeader, strLog, "City Gold", m_pPlayer->calculateTotalYield((YieldTypes)ui));

	mov	ecx, DWORD PTR [esi+4]
	push	2
	call	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::calculateTotalYield
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240306[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226694

; 1392 : 			break;

	jmp	SHORT $LN407@LogMonitor
$LN16@LogMonitor:

; 1393 : 		case YIELD_SCIENCE:
; 1394 : 			AppendToLog(strHeader, strLog, "Science", m_pPlayer->calculateTotalYield((YieldTypes)ui));

	mov	ecx, DWORD PTR [esi+4]
	push	3
	call	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::calculateTotalYield
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240307[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226698
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+296]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+300]
	push	eax

; 1395 : 			break;

	jmp	SHORT $LN406@LogMonitor
$LN15@LogMonitor:

; 1396 : 		case YIELD_CULTURE:
; 1397 : 			AppendToLog(strHeader, strLog, "Culture", m_pPlayer->GetTotalJONSCulturePerTurn());

	mov	ecx, DWORD PTR [esi+4]
	call	?GetTotalJONSCulturePerTurn@CvPlayer@@QBEHXZ ; CvPlayer::GetTotalJONSCulturePerTurn
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240308[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226701
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+296]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+300]
	push	edx

; 1398 : 			break;

	jmp	SHORT $LN406@LogMonitor
$LN14@LogMonitor:

; 1399 : 		case YIELD_FAITH:
; 1400 : 			AppendToLog(strHeader, strLog, "Faith", m_pPlayer->GetTotalFaithPerTurn());

	mov	ecx, DWORD PTR [esi+4]
	call	?GetTotalFaithPerTurn@CvPlayer@@QBEHXZ	; CvPlayer::GetTotalFaithPerTurn
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240309[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226704
$LN407@LogMonitor:
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+296]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+300]
	push	ecx
$LN406@LogMonitor:
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H
$LN23@LogMonitor:
	inc	edi
	cmp	edi, 6
	jb	$LL24@LogMonitor

; 1401 : 			break;
; 1402 : 		}
; 1403 : 	}
; 1404 : 
; 1405 : 	// Num Techs
; 1406 : 	AppendToLog(strHeader, strLog, "Num Techs", GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->GetNumTechsKnown());

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN169@LogMonitor
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN170@LogMonitor
$LN169@LogMonitor:
	or	eax, -1
$LN170@LogMonitor:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ	; CvTeamTechs::GetNumTechsKnown
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240310[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226706
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+296]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+300]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1407 : 
; 1408 : 	// Culture
; 1409 : 	AppendToLog(strHeader, strLog, "Policies", GetPlayer()->GetPlayerPolicies()->GetNumPoliciesOwned());

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 40					; 00000028H
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumPoliciesOwned@CvPlayerPolicies@@QBEHXZ ; CvPlayerPolicies::GetNumPoliciesOwned
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240311[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226708
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+296]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+300]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1410 : 	AppendToLog(strHeader, strLog, "Culture (lifetime)", GetPlayer()->GetJONSCultureEverGenerated());

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 40					; 00000028H
	call	?GetJONSCultureEverGenerated@CvPlayer@@QBEHXZ ; CvPlayer::GetJONSCultureEverGenerated
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240312[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226710
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+296]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+300]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1411 : 
; 1412 : 	// Faith
; 1413 : 	AppendToLog(strHeader, strLog, "Faith", GetPlayer()->GetFaith());

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 40					; 00000028H
	call	?GetFaith@CvPlayer@@QBEHXZ		; CvPlayer::GetFaith
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240313[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226712
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+296]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+300]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1414 : 
; 1415 : 	// workers
; 1416 : 	int iWorkerCount = 0;
; 1417 : 	CvUnit* pLoopUnit;
; 1418 : 	int iLoopUnit;
; 1419 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	push	ebx
	lea	ecx, DWORD PTR _iLoopUnit$[esp+268]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	xor	edi, edi
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	cmp	eax, ebx
	je	SHORT $LN11@LogMonitor
	npad	4
$LL13@LogMonitor:

; 1420 : 	{
; 1421 : 		if(pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER)

	mov	ecx, eax
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	jne	SHORT $LN12@LogMonitor

; 1422 : 		{
; 1423 : 			iWorkerCount++;

	inc	edi
$LN12@LogMonitor:

; 1414 : 
; 1415 : 	// workers
; 1416 : 	int iWorkerCount = 0;
; 1417 : 	CvUnit* pLoopUnit;
; 1418 : 	int iLoopUnit;
; 1419 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	lea	edx, DWORD PTR _iLoopUnit$[esp+268]
	push	edx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	cmp	eax, ebx
	jne	SHORT $LL13@LogMonitor
$LN11@LogMonitor:

; 1424 : 		}
; 1425 : 	}
; 1426 : 	AppendToLog(strHeader, strLog, "# Workers", iWorkerCount);

	push	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240314[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226721
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+296]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+300]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1427 : 	AppendToLog(strHeader, strLog, "Positive Happiness",  m_pPlayer->GetHappiness());

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 40					; 00000028H
	call	?GetHappiness@CvPlayer@@QBEHXZ		; CvPlayer::GetHappiness
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240315[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226723
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+296]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+300]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1428 : 	AppendToLog(strHeader, strLog, "Negative Happiness", m_pPlayer->GetUnhappiness());

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 40					; 00000028H
	push	ebx
	push	ebx
	call	?GetUnhappiness@CvPlayer@@QBEHPAVCvCity@@0@Z ; CvPlayer::GetUnhappiness
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240316[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226725
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+296]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+300]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1429 : 	AppendToLog(strHeader, strLog, "Net Happiness", m_pPlayer->GetExcessHappiness());

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 40					; 00000028H
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240317[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226727
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+296]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+300]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1430 : 
; 1431 : 	// # of each improvement constructed
; 1432 : 	FFastVector<int, true> m_aiNumImprovements;

	xor	ebp, ebp
	add	esp, 40					; 00000028H
	mov	DWORD PTR _m_aiNumImprovements$[esp+268], ebp
	mov	DWORD PTR _m_aiNumImprovements$[esp+272], ebx
	mov	DWORD PTR _m_aiNumImprovements$[esp+264], ebx

; 1433 : 	m_aiNumImprovements.push_back_copy(-1, GC.getNumImprovementInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR __$EHRec$[esp+272], 8
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	mov	edi, eax
	cmp	edi, ebx
	jbe	SHORT $LN234@LogMonitor
	push	edi
	lea	ecx, DWORD PTR _m_aiNumImprovements$[esp+268]
	call	?GrowSize@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEXI@Z ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::GrowSize
	mov	ebp, DWORD PTR _m_aiNumImprovements$[esp+268]
$LN234@LogMonitor:
	cmp	ebp, edi
	jae	SHORT $LN231@LogMonitor
	mov	edx, DWORD PTR _m_aiNumImprovements$[esp+264]
	mov	ecx, edi
	lea	eax, DWORD PTR [edx+ebp*4]
	sub	ecx, ebp
$LL233@LogMonitor:
	cmp	eax, ebx
	je	SHORT $LN232@LogMonitor
	mov	DWORD PTR [eax], -1
$LN232@LogMonitor:
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LL233@LogMonitor
$LN231@LogMonitor:

; 1434 : 
; 1435 : 	// go through all the plots the player has under their control
; 1436 : 	CvPlotsVector& aiPlots = m_pPlayer->GetPlots();

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _m_aiNumImprovements$[esp+268], edi
	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots
	mov	ecx, eax

; 1437 : 
; 1438 : 	// worked tiles
; 1439 : 	int iTiles = 0;
; 1440 : 	int iWorkedTiles = 0;
; 1441 : 	int iImprovedTiles = 0;
; 1442 : 	for(uint uiPlotIndex = 0; uiPlotIndex < aiPlots.size(); uiPlotIndex++)

	xor	eax, eax
	xor	ebp, ebp
	mov	DWORD PTR _aiPlots$[esp+264], ecx
	mov	DWORD PTR _iWorkedTiles$[esp+264], ebx
	mov	DWORD PTR _uiPlotIndex$226810[esp+264], eax
	cmp	DWORD PTR [ecx+4], eax
	jbe	$LN393@LogMonitor
$LN9@LogMonitor:

; 1443 : 	{
; 1444 : 		// when we encounter the first plot that is invalid, the rest of the list will be invalid
; 1445 : 		if(aiPlots[uiPlotIndex] == -1)

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax*4]
	cmp	eax, -1
	je	SHORT $LN393@LogMonitor

; 1446 : 		{
; 1447 : 			break;
; 1448 : 		}
; 1449 : 
; 1450 : 		CvPlot* pPlot = GC.getMap().plotByIndex(aiPlots[uiPlotIndex]);

	test	eax, eax
	jl	SHORT $LN8@LogMonitor
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [edx+4028]
	jge	SHORT $LN8@LogMonitor
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [edx+4068]
	mov	edi, eax

; 1451 : 		if(!pPlot)

	je	SHORT $LN8@LogMonitor

; 1452 : 		{
; 1453 : 			continue;
; 1454 : 		}
; 1455 : 
; 1456 : 		iTiles++;
; 1457 : 
; 1458 : 		// plot has city in it, don't count
; 1459 : 		if(pPlot->getPlotCity())

	mov	eax, DWORD PTR [edi+104]
	inc	ebx
	test	eax, eax
	jl	SHORT $LN399@LogMonitor
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN399@LogMonitor
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	jne	SHORT $LN400@LogMonitor
$LN399@LogMonitor:

; 1460 : 		{
; 1461 : 			continue;
; 1462 : 		}
; 1463 : 
; 1464 : 		if(pPlot->isBeingWorked())

	mov	ecx, edi
	call	?isBeingWorked@CvPlot@@QBE_NXZ		; CvPlot::isBeingWorked
	test	al, al
	je	SHORT $LN3@LogMonitor

; 1465 : 		{
; 1466 : 			iWorkedTiles++;

	inc	DWORD PTR _iWorkedTiles$[esp+264]
$LN3@LogMonitor:

; 1467 : 		}
; 1468 : 
; 1469 : 		if(pPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, edi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN400@LogMonitor

; 1470 : 		{
; 1471 : 			iImprovedTiles++;

	inc	ebp
$LN400@LogMonitor:
	mov	ecx, DWORD PTR _aiPlots$[esp+264]
$LN8@LogMonitor:

; 1437 : 
; 1438 : 	// worked tiles
; 1439 : 	int iTiles = 0;
; 1440 : 	int iWorkedTiles = 0;
; 1441 : 	int iImprovedTiles = 0;
; 1442 : 	for(uint uiPlotIndex = 0; uiPlotIndex < aiPlots.size(); uiPlotIndex++)

	mov	eax, DWORD PTR _uiPlotIndex$226810[esp+264]
	inc	eax
	mov	DWORD PTR _uiPlotIndex$226810[esp+264], eax
	cmp	eax, DWORD PTR [ecx+4]
	jb	$LN9@LogMonitor
$LN393@LogMonitor:

; 1472 : 		}
; 1473 : 	}
; 1474 : 
; 1475 : 	AppendToLog(strHeader, strLog, "Tiles", iTiles);

	push	ebx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240319[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226821
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+296]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+300]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1476 : 	AppendToLog(strHeader, strLog, "Worked (non-city) tiles", iWorkedTiles);

	mov	ecx, DWORD PTR _iWorkedTiles$[esp+304]
	add	esp, 40					; 00000028H
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240320[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226823
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+296]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+300]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1477 : 	AppendToLog(strHeader, strLog, "Improved tiles", iImprovedTiles);

	push	ebp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240321[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226825
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+296]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+300]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1478 : 
; 1479 : 	AppendToLog(strHeader, strLog, "Trade Routes established", m_pPlayer->GetTrade()->GetNumTradeRoutesUsed(false));

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 40					; 00000028H
	push	0
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?GetNumTradeRoutesUsed@CvPlayerTrade@@QAEH_N@Z ; CvPlayerTrade::GetNumTradeRoutesUsed
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240322[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226827
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+296]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+300]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1480 : 	AppendToLog(strHeader, strLog, "Trade Routes available", (int)m_pPlayer->GetTrade()->GetNumTradeRoutesPossible());

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 40					; 00000028H
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ ; CvPlayerTrade::GetNumTradeRoutesPossible
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240323[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226830
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+296]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+300]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1481 : 
; 1482 : 	CvTreasury *pTreasury = m_pPlayer->GetTreasury();

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 40					; 00000028H
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	esi, eax

; 1483 : 
; 1484 : 	int iInternationalTradeGPT = pTreasury->GetGoldFromCitiesTimes100(false) - pTreasury->GetGoldFromCitiesTimes100(true);

	push	1
	mov	ecx, esi
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100
	push	0
	mov	ecx, esi
	mov	ebx, eax
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100
	mov	edi, eax

; 1485 : 	AppendToLog(strHeader, strLog, "Gold From Cities", pTreasury->GetGoldFromCitiesTimes100(true) / 100);

	push	1
	mov	ecx, esi
	sub	edi, ebx
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100
	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240324[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226834
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+296]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+300]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1486 : 	AppendToLog(strHeader, strLog, "Gold From Trade Routes", (int)(iInternationalTradeGPT / 100));

	mov	eax, 1374389535				; 51eb851fH
	imul	edi
	sar	edx, 5
	mov	edi, edx
	add	esp, 40					; 00000028H
	shr	edi, 31					; 0000001fH
	add	edi, edx
	push	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240325[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226837
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+296]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+300]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1487 : 	AppendToLog(strHeader, strLog, "Treasury", pTreasury->GetGold());

	mov	ecx, esi
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240326[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226839
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+296]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+300]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1488 : 	AppendToLog(strHeader, strLog, "GPT - Connects", pTreasury->GetCityConnectionGold());

	mov	ecx, esi
	call	?GetCityConnectionGold@CvTreasury@@QBEHXZ ; CvTreasury::GetCityConnectionGold
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240327[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226841
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+296]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+300]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1489 : 	AppendToLog(strHeader, strLog, "GPT - Diplo", pTreasury->GetGoldPerTurnFromDiplomacy());

	mov	ecx, esi
	call	?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromDiplomacy
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240328[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226843
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+296]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+300]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1490 : 	AppendToLog(strHeader, strLog, "GPT - Religion", pTreasury->GetGoldPerTurnFromReligion());

	mov	ecx, esi
	call	?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromReligion
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240329[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226845
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+296]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+300]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1491 : 	AppendToLog(strHeader, strLog, "GPT - Traits", pTreasury->GetGoldPerTurnFromTraits());

	mov	ecx, esi
	call	?GetGoldPerTurnFromTraits@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromTraits
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240330[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226847
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+296]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+300]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1492 : 
; 1493 : 	int iGoldFromCitiesMinusTR = pTreasury->GetGoldFromCitiesTimes100(true) / 100;

	push	1
	mov	ecx, esi
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100
	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH

; 1494 : 	int iGPTFromDiplomacy = pTreasury->GetGoldPerTurnFromDiplomacy();

	mov	ecx, esi
	add	ebp, edx
	call	?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromDiplomacy

; 1495 : 	int iGoldFromCityConnect = pTreasury->GetCityConnectionGoldTimes100() / 100;

	mov	ecx, esi
	mov	DWORD PTR _iGPTFromDiplomacy$[esp+264], eax
	call	?GetCityConnectionGoldTimes100@CvTreasury@@QBEHXZ ; CvTreasury::GetCityConnectionGoldTimes100
	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH

; 1496 : 	int iGPTFromReligion = pTreasury->GetGoldPerTurnFromReligion();

	mov	ecx, esi
	add	ebx, edx
	call	?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromReligion

; 1497 : 	int iGPTFromTraits = pTreasury->GetGoldPerTurnFromTraits();

	mov	ecx, esi
	mov	DWORD PTR _iGPTFromReligion$[esp+264], eax
	call	?GetGoldPerTurnFromTraits@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromTraits

; 1498 : 	int iTradeRouteGold = (int)(iInternationalTradeGPT / 100);
; 1499 : 	int iTotalIncome = iGoldFromCitiesMinusTR + iGPTFromDiplomacy + iGoldFromCityConnect + iGPTFromReligion + iGPTFromTraits + iTradeRouteGold;

	add	edi, eax
	add	edi, DWORD PTR _iGPTFromReligion$[esp+264]
	add	edi, ebx
	add	edi, DWORD PTR _iGPTFromDiplomacy$[esp+264]
	add	edi, ebp

; 1500 : 	AppendToLog(strHeader, strLog, "Total Income", iTotalIncome);

	push	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240331[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226857
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+296]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+300]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1501 : 
; 1502 : 	// Gold breakdown
; 1503 : 	int iExpenses = pTreasury->GetExpensePerTurnUnitMaintenance() + pTreasury->GetBuildingGoldMaintenance() + pTreasury->GetImprovementGoldMaintenance();

	mov	ebp, DWORD PTR [esi+16]
	add	esp, 40					; 00000028H
	mov	ecx, esi
	call	?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetBuildingGoldMaintenance
	mov	ecx, esi
	mov	DWORD PTR tv2253[esp+264], eax
	call	?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetImprovementGoldMaintenance
	mov	ebx, eax
	mov	eax, DWORD PTR tv2253[esp+264]
	add	eax, ebp
	add	ebx, eax

; 1504 : 	AppendToLog(strHeader, strLog, "Unit Maint", pTreasury->GetExpensePerTurnUnitMaintenance());

	mov	eax, DWORD PTR [esi+16]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240332[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226860
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+296]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+300]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1505 : 	AppendToLog(strHeader, strLog, "Build Maint", pTreasury->GetBuildingGoldMaintenance());

	mov	ecx, esi
	call	?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetBuildingGoldMaintenance
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240333[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226862
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+296]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+300]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1506 : 	AppendToLog(strHeader, strLog, "Improve Maint", pTreasury->GetImprovementGoldMaintenance());

	mov	ecx, esi
	call	?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetImprovementGoldMaintenance
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240334[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226864
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+296]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+300]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1507 : 	AppendToLog(strHeader, strLog, "Total Expenses", iExpenses);

	push	ebx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240335[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226866
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+296]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+300]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1508 : 	AppendToLog(strHeader, strLog, "Net GPT", iTotalIncome - iExpenses);

	sub	edi, ebx
	push	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T240336[esp+296], esp
	mov	ecx, esp
	push	OFFSET $SG226868
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+296]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+300]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1509 : 
; 1510 : 	if(bBuildHeader)

	cmp	BYTE PTR _bBuildHeader$[esp+264], 0
	je	SHORT $LN401@LogMonitor

; 1511 : 	{
; 1512 : 		pLog->Msg(strHeader);

	lea	ecx, DWORD PTR _strHeader$[esp+264]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	esi, DWORD PTR _pLog$[esp+264]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8
	jmp	SHORT $LN1@LogMonitor
$LN401@LogMonitor:
	mov	esi, DWORD PTR _pLog$[esp+264]
$LN1@LogMonitor:

; 1513 : 	}
; 1514 : 	pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$[esp+264]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx

; 1515 : }

	mov	eax, DWORD PTR _m_aiNumImprovements$[esp+272]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+284], 6
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _str$[esp+264]
	mov	BYTE PTR __$EHRec$[esp+272], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogName$[esp+264]
	mov	BYTE PTR __$EHRec$[esp+272], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayerName$[esp+264]
	mov	BYTE PTR __$EHRec$[esp+272], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLog$[esp+264]
	mov	BYTE PTR __$EHRec$[esp+272], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strHeader$[esp+264]
	mov	DWORD PTR __$EHRec$[esp+272], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN32@LogMonitor:
	mov	ecx, DWORD PTR __$EHRec$[esp+264]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 248				; 000000f8H
	ret	0
	npad	1
$LN408@LogMonitor:
	DD	$LN19@LogMonitor
	DD	$LN18@LogMonitor
	DD	$LN17@LogMonitor
	DD	$LN16@LogMonitor
	DD	$LN15@LogMonitor
	DD	$LN14@LogMonitor
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strHeader$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T240297[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$5:
	lea	ecx, DWORD PTR $T240298[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$6:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$7:
	mov	ecx, DWORD PTR $T240299[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$26:
	lea	ecx, DWORD PTR _m_aiNumImprovements$[ebp]
	jmp	??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::~FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>
__ehhandler$?LogMonitor@CvEconomicAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?LogMonitor@CvEconomicAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogMonitor@CvEconomicAI@@QAEXXZ ENDP			; CvEconomicAI::LogMonitor
PUBLIC	?LogCityMonitor@CvEconomicAI@@QAEXXZ		; CvEconomicAI::LogCityMonitor
EXTRN	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ:PROC	; CvPlot::getWorkingCity
EXTRN	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z:PROC ; CvCityCitizens::IsCanWork
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?getExtraSpecialistYield@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getExtraSpecialistYield
EXTRN	?getYieldRate@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRate
;	COMDAT ?bFirstRun@?7??LogCityMonitor@CvEconomicAI@@QAEXXZ@4_NA
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_DATA	SEGMENT
?bFirstRun@?7??LogCityMonitor@CvEconomicAI@@QAEXXZ@4_NA DB 01H ; `CvEconomicAI::LogCityMonitor'::`8'::bFirstRun
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogCityMonitor@CvEconomicAI@@QAEXXZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?LogCityMonitor@CvEconomicAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogCityMonitor@CvEconomicAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$9
	DD	08H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$12
	DD	08H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$13
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?LogCityMonitor@CvEconomicAI@@QAEXXZ
_TEXT	SEGMENT
tv2523 = -276						; size = 4
tv2176 = -276						; size = 4
$T241034 = -276						; size = 4
_iWorkedTiles$227054 = -276				; size = 4
$T241030 = -276						; size = 4
$T241029 = -276						; size = 4
$T241028 = -276						; size = 4
$T241027 = -276						; size = 4
$T241026 = -276						; size = 4
$T241025 = -276						; size = 4
$T241024 = -276						; size = 4
$T241023 = -276						; size = 4
$T241022 = -276						; size = 4
$T241021 = -276						; size = 4
$T241020 = -276						; size = 4
$T241019 = -276						; size = 4
$T241018 = -276						; size = 4
$T241017 = -276						; size = 4
$T241016 = -276						; size = 4
$T241015 = -276						; size = 4
$T241014 = -276						; size = 4
$T241013 = -276						; size = 4
$T241012 = -276						; size = 4
$T241011 = -276						; size = 4
$T241010 = -276						; size = 4
$T241009 = -276						; size = 4
$T241008 = -276						; size = 4
$T241007 = -276						; size = 4
$T241006 = -276						; size = 4
$T241004 = -276						; size = 4
$T241002 = -276						; size = 4
$T241000 = -276						; size = 4
$T240999 = -276						; size = 4
$T240998 = -276						; size = 4
_bBuildHeader$ = -269					; size = 1
$T241033 = -268						; size = 4
$T241032 = -268						; size = 4
$T241031 = -268						; size = 4
_pLoopCity$ = -268					; size = 4
tv1848 = -264						; size = 8
_iImprovedTiles$227055 = -264				; size = 4
_fRatio$ = -264						; size = 4
$T241005 = -264						; size = 4
$T241001 = -264						; size = 4
_strHeader$ = -252					; size = 28
_strLog$ = -224						; size = 28
_aiPlots$ = -196					; size = 4
_pLog$ = -192						; size = 4
_iLoopCity$ = -188					; size = 4
_aiSpecialistsYields$ = -184				; size = 12
_aiCityYields$ = -172					; size = 12
_this$ = -160						; size = 4
_strPlayerName$ = -156					; size = 28
_strLogName$ = -128					; size = 28
$T241003 = -100						; size = 28
$T240996 = -100						; size = 28
_str$ = -72						; size = 28
$T240997 = -44						; size = 28
__$EHRec$ = -12						; size = 12
?LogCityMonitor@CvEconomicAI@@QAEXXZ PROC		; CvEconomicAI::LogCityMonitor, COMDAT
; _this$ = ecx

; 1518 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?LogCityMonitor@CvEconomicAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 1519 : 	if(!(GC.getLogging() && GC.getAILogging()))

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+296], edi
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN71@LogCityMon
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN71@LogCityMon

; 1520 : 	{
; 1521 : 		return;
; 1522 : 	}
; 1523 : 
; 1524 : 	// don't log minor civs for now
; 1525 : 	if(m_pPlayer->isMinorCiv())

	mov	ecx, DWORD PTR [edi+4]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN71@LogCityMon

; 1526 : 	{
; 1527 : 		return;
; 1528 : 	}
; 1529 : 
; 1530 : 	static bool bFirstRun = true;
; 1531 : 	bool bBuildHeader = false;
; 1532 : 	CvString strHeader;

	lea	ecx, DWORD PTR _strHeader$[esp+296]
	mov	BYTE PTR _bBuildHeader$[esp+296], al
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ebp, ebp

; 1533 : 	if(bFirstRun)

	cmp	BYTE PTR ?bFirstRun@?7??LogCityMonitor@CvEconomicAI@@QAEXXZ@4_NA, 0
	mov	DWORD PTR __$EHRec$[esp+304], ebp
	je	SHORT $LN69@LogCityMon

; 1534 : 	{
; 1535 : 		bFirstRun = false;

	mov	BYTE PTR ?bFirstRun@?7??LogCityMonitor@CvEconomicAI@@QAEXXZ@4_NA, 0

; 1536 : 		bBuildHeader = true;

	mov	BYTE PTR _bBuildHeader$[esp+296], 1
$LN69@LogCityMon:

; 1537 : 	}
; 1538 : 
; 1539 : 	// go through all the plots the player has under their control
; 1540 : 	CvPlotsVector& aiPlots = m_pPlayer->GetPlots();

	mov	ecx, DWORD PTR [edi+4]
	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots

; 1541 : 
; 1542 : 	CvString strLog;

	lea	ecx, DWORD PTR _strLog$[esp+296]
	mov	DWORD PTR _aiPlots$[esp+296], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1543 : 
; 1544 : 	// Find the name of this civ and city
; 1545 : 	CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1546 : 	strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi+4]
	mov	BYTE PTR __$EHRec$[esp+304], 2
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$[esp+296]
	cmp	eax, ebp
	je	SHORT $LN129@LogCityMon
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN128@LogCityMon
$LN129@LogCityMon:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN128@LogCityMon:

; 1547 : 	CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$[esp+296]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1548 : 
; 1549 : 	// Open the log file
; 1550 : 	if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR __$EHRec$[esp+304], 3
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	test	al, al
	je	$LN68@LogCityMon

; 1551 : 	{
; 1552 : 		strLogName = "EconomicCityMonitorLog_" + strPlayerName + ".csv";

	lea	eax, DWORD PTR _strPlayerName$[esp+296]
	push	eax
	lea	ecx, DWORD PTR $T240996[esp+300]
	push	OFFSET $SG226889
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG226888
	push	eax
	lea	edx, DWORD PTR $T240997[esp+316]
	mov	bl, 4
	push	edx
	mov	BYTE PTR __$EHRec$[esp+328], bl
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+304], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$[esp+300]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T240997[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T240996[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1553 : 	}
; 1554 : 	else

	jmp	SHORT $LN67@LogCityMon
$LN68@LogCityMon:

; 1555 : 	{
; 1556 : 		strLogName = "EconomicCityMonitorLog.csv";

	push	OFFSET $SG226891
	lea	ecx, DWORD PTR _strLogName$[esp+300]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
$LN67@LogCityMon:

; 1557 : 	}
; 1558 : 
; 1559 : 	FILogFile* pLog;
; 1560 : 	pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strLogName$[esp+296]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	ebp
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 1561 : 
; 1562 : 	CvString str;

	lea	ecx, DWORD PTR _str$[esp+296]
	mov	DWORD PTR _pLog$[esp+296], eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1563 : 
; 1564 : 	float fRatio;
; 1565 : 
; 1566 : 	// per city
; 1567 : 	int iLoopCity = 0;

	mov	DWORD PTR _iLoopCity$[esp+296], ebp

; 1568 : 	CvCity* pLoopCity = NULL;
; 1569 : 
; 1570 : 	FFastVector<int> aiCityYields;

	mov	DWORD PTR _aiCityYields$[esp+300], ebp
	mov	DWORD PTR _aiCityYields$[esp+304], ebp
	mov	DWORD PTR _aiCityYields$[esp+296], ebp

; 1571 : 	aiCityYields.push_back_copy(-1, NUM_YIELD_TYPES);

	push	6
	lea	ecx, DWORD PTR $T240998[esp+300]
	push	ecx
	or	esi, -1
	lea	ecx, DWORD PTR _aiCityYields$[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], 7
	mov	DWORD PTR $T240998[esp+304], esi
	call	?push_back_copy@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXABHI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back_copy

; 1572 : 
; 1573 : 	FFastVector<int> aiSpecialistsYields;

	mov	DWORD PTR _aiSpecialistsYields$[esp+300], ebp
	mov	DWORD PTR _aiSpecialistsYields$[esp+304], ebp
	mov	DWORD PTR _aiSpecialistsYields$[esp+296], ebp

; 1574 : 	aiSpecialistsYields.push_back_copy(-1, NUM_YIELD_TYPES);

	push	6
	lea	edx, DWORD PTR $T240999[esp+300]
	push	edx
	lea	ecx, DWORD PTR _aiSpecialistsYields$[esp+304]
	mov	BYTE PTR __$EHRec$[esp+312], 8
	mov	DWORD PTR $T240999[esp+304], esi
	call	?push_back_copy@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXABHI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back_copy

; 1575 : 
; 1576 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iLoopCity))

	mov	ecx, DWORD PTR [edi+4]
	push	ebp
	lea	eax, DWORD PTR _iLoopCity$[esp+300]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebx, eax
	mov	DWORD PTR _pLoopCity$[esp+296], ebx
	cmp	ebx, ebp
	je	$LN64@LogCityMon
	jmp	SHORT $LN66@LogCityMon
	npad	1
$LL478@LogCityMon:
	mov	ebx, DWORD PTR _pLoopCity$[esp+296]
	xor	ebp, ebp
$LN66@LogCityMon:

; 1577 : 	{
; 1578 : 		for(uint ui = 0; ui < aiCityYields.size(); ui++)

	mov	ecx, DWORD PTR _aiCityYields$[esp+300]
	cmp	ecx, ebp
	mov	ebp, DWORD PTR _aiCityYields$[esp+296]
	jbe	SHORT $LN63@LogCityMon
	xor	eax, eax
	mov	edi, ebp
	rep stosd
$LN63@LogCityMon:

; 1579 : 		{
; 1580 : 			aiCityYields[ui] = 0;
; 1581 : 		}
; 1582 : 
; 1583 : 		for(uint ui = 0; ui < aiSpecialistsYields.size(); ui++)

	mov	ecx, DWORD PTR _aiSpecialistsYields$[esp+300]
	test	ecx, ecx
	jbe	SHORT $LN60@LogCityMon
	mov	edi, DWORD PTR _aiSpecialistsYields$[esp+296]
	xor	eax, eax
	rep stosd
$LN60@LogCityMon:

; 1584 : 		{
; 1585 : 			aiSpecialistsYields[ui] = 0;
; 1586 : 		}
; 1587 : 
; 1588 : 		strHeader = "";

	push	OFFSET $SG226930
	lea	ecx, DWORD PTR _strHeader$[esp+300]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 1589 : 		strLog = "";

	push	OFFSET $SG226931
	lea	ecx, DWORD PTR _strLog$[esp+300]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 1590 : 
; 1591 : 		// civ name
; 1592 : 		AppendToLog(strHeader, strLog, "Civ Name", strPlayerName);

	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strPlayerName$[esp+324]
	mov	DWORD PTR $T241000[esp+324], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241001[esp+352], esp
	mov	ecx, esp
	push	OFFSET $SG226934
	mov	BYTE PTR __$EHRec$[esp+364], 9
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+352]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+356]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+368], 8
	call	?AppendToLog@@YAXAAVCvString@@0V1@1@Z	; AppendToLog

; 1593 : 
; 1594 : 		// turn
; 1595 : 		AppendToLog(strHeader, strLog, "Turn", GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	esp, 64					; 00000040H
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241002[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG226936
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+328]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+332]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1596 : 
; 1597 : 		// city name
; 1598 : 		str = pLoopCity->getName();

	lea	ecx, DWORD PTR $T241003[esp+296]
	push	ecx
	mov	ecx, ebx
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	ecx, DWORD PTR _str$[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 10		; 0000000aH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T241003[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1599 : 		AppendToLog(strHeader, strLog, "City Name", str);

	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _str$[esp+324]
	mov	DWORD PTR $T241004[esp+324], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241005[esp+352], esp
	mov	ecx, esp
	push	OFFSET $SG226940
	mov	BYTE PTR __$EHRec$[esp+364], 11		; 0000000bH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+352]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+356]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+368], 8
	call	?AppendToLog@@YAXAAVCvString@@0V1@1@Z	; AppendToLog
	add	esp, 64					; 00000040H

; 1600 : 
; 1601 : 		//	pop
; 1602 : 		AppendToLog(strHeader, strLog, "Population", pLoopCity->getPopulation());

	mov	ecx, ebx
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241006[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG226942
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+328]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+332]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1603 : 
; 1604 : 		//	total yields
; 1605 : 		for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	xor	esi, esi
$LL57@LogCityMon:

; 1606 : 		{
; 1607 : 			aiCityYields[ui] = pLoopCity->getYieldRate((YieldTypes)ui, false);

	push	0
	push	esi
	mov	ecx, ebx
	call	?getYieldRate@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRate
	mov	DWORD PTR [ebp+esi*4], eax

; 1608 : 			switch(ui)

	cmp	esi, 5
	ja	$LN56@LogCityMon
	jmp	DWORD PTR $LN493@LogCityMon[esi*4]
$LN52@LogCityMon:

; 1609 : 			{
; 1610 : 			case YIELD_FOOD:
; 1611 : 				AppendToLog(strHeader, strLog, "food", aiCityYields[ui]);

	mov	ecx, eax
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241007[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG226954

; 1612 : 				break;

	jmp	SHORT $LN487@LogCityMon
$LN51@LogCityMon:

; 1613 : 			case YIELD_PRODUCTION:
; 1614 : 				AppendToLog(strHeader, strLog, "production", aiCityYields[ui]);

	mov	ecx, eax
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241008[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG226957

; 1615 : 				break;

	jmp	SHORT $LN487@LogCityMon
$LN50@LogCityMon:

; 1616 : 			case YIELD_SCIENCE:
; 1617 : 				AppendToLog(strHeader, strLog, "science", aiCityYields[ui]);

	mov	ecx, eax
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241009[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG226960

; 1618 : 				break;

	jmp	SHORT $LN487@LogCityMon
$LN49@LogCityMon:

; 1619 : 			case YIELD_GOLD:
; 1620 : 				AppendToLog(strHeader, strLog, "city gold", aiCityYields[ui]);

	mov	ecx, eax
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241010[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG226963

; 1621 : 				break;

	jmp	SHORT $LN487@LogCityMon
$LN48@LogCityMon:

; 1622 : 			case YIELD_CULTURE:
; 1623 : 				AppendToLog(strHeader, strLog, "culture", aiCityYields[ui]);

	mov	ecx, eax
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241011[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG226966

; 1624 : 				break;

	jmp	SHORT $LN487@LogCityMon
$LN47@LogCityMon:

; 1625 : 			case YIELD_FAITH:
; 1626 : 				AppendToLog(strHeader, strLog, "faith", aiCityYields[ui]);

	mov	ecx, eax
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241012[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG226969
$LN487@LogCityMon:
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+328]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+332]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H
$LN56@LogCityMon:
	inc	esi
	cmp	esi, 6
	jb	$LL57@LogCityMon

; 1627 : 				break;
; 1628 : 			}
; 1629 : 		}
; 1630 : 
; 1631 : 		//	yields / pop
; 1632 : 		for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	xor	edi, edi
$LL46@LogCityMon:

; 1633 : 		{
; 1634 : 			fRatio = 0.0f;
; 1635 : 			if(pLoopCity->getPopulation() > 0)

	mov	ecx, ebx
	xor	esi, esi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	test	eax, eax
	jle	SHORT $LN43@LogCityMon

; 1636 : 			{
; 1637 : 				fRatio = aiCityYields[ui] / (float)pLoopCity->getPopulation();

	fild	DWORD PTR [ebp+edi*4]
	mov	ecx, ebx
	fstp	QWORD PTR tv1848[esp+296]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	DWORD PTR tv2523[esp+296], eax
	fild	DWORD PTR tv2523[esp+296]
	fdivr	QWORD PTR tv1848[esp+296]
	fstp	DWORD PTR _fRatio$[esp+296]
	mov	esi, DWORD PTR _fRatio$[esp+296]
$LN43@LogCityMon:

; 1638 : 			}
; 1639 : 
; 1640 : 			switch(ui)

	cmp	edi, 5
	ja	$LN45@LogCityMon
	jmp	DWORD PTR $LN494@LogCityMon[edi*4]
$LN40@LogCityMon:

; 1641 : 			{
; 1642 : 			case YIELD_FOOD:
; 1643 : 				AppendToLog(strHeader, strLog, "food / pop", fRatio);

	sub	esp, 32					; 00000020H
	mov	DWORD PTR [esp+28], esi
	mov	DWORD PTR $T241013[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG226982
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+328]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+332]
	push	edx

; 1644 : 				break;

	jmp	$LN488@LogCityMon
$LN39@LogCityMon:

; 1645 : 			case YIELD_PRODUCTION:
; 1646 : 				AppendToLog(strHeader, strLog, "production / pop", fRatio);

	sub	esp, 32					; 00000020H
	mov	DWORD PTR [esp+28], esi
	mov	DWORD PTR $T241014[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG226985
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+328]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+332]
	push	ecx

; 1647 : 				break;

	jmp	$LN488@LogCityMon
$LN38@LogCityMon:

; 1648 : 			case YIELD_SCIENCE:
; 1649 : 				AppendToLog(strHeader, strLog, "science / pop", fRatio);

	sub	esp, 32					; 00000020H
	mov	DWORD PTR [esp+28], esi
	mov	DWORD PTR $T241015[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG226988

; 1650 : 				break;

	jmp	SHORT $LN489@LogCityMon
$LN37@LogCityMon:

; 1651 : 			case YIELD_GOLD:
; 1652 : 				AppendToLog(strHeader, strLog, "gold / pop", fRatio);

	sub	esp, 32					; 00000020H
	mov	DWORD PTR [esp+28], esi
	mov	DWORD PTR $T241016[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG226991
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+328]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+332]
	push	edx

; 1653 : 				break;

	jmp	SHORT $LN488@LogCityMon
$LN36@LogCityMon:

; 1654 : 			case YIELD_CULTURE:
; 1655 : 				AppendToLog(strHeader, strLog, "culture / pop", fRatio);

	sub	esp, 32					; 00000020H
	mov	DWORD PTR [esp+28], esi
	mov	DWORD PTR $T241017[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG226994
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+328]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+332]
	push	ecx

; 1656 : 				break;

	jmp	SHORT $LN488@LogCityMon
$LN35@LogCityMon:

; 1657 : 			case YIELD_FAITH:
; 1658 : 				AppendToLog(strHeader, strLog, "faith / pop", fRatio);

	sub	esp, 32					; 00000020H
	mov	DWORD PTR [esp+28], esi
	mov	DWORD PTR $T241018[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG226997
$LN489@LogCityMon:
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+328]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+332]
	push	eax
$LN488@LogCityMon:
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H
$LN45@LogCityMon:
	inc	edi
	cmp	edi, 6
	jb	$LL46@LogCityMon

; 1659 : 				break;
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 		//	yields from specialists
; 1664 : 		for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	xor	esi, esi
$LL34@LogCityMon:

; 1665 : 		{
; 1666 : 			aiSpecialistsYields[ui] = pLoopCity->getExtraSpecialistYield((YieldTypes)ui);

	push	esi
	mov	ecx, ebx
	call	?getExtraSpecialistYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getExtraSpecialistYield
	mov	edi, DWORD PTR _aiSpecialistsYields$[esp+296]
	mov	DWORD PTR [edi+esi*4], eax

; 1667 : 			switch(ui)

	cmp	esi, 5
	ja	$LN33@LogCityMon
	jmp	DWORD PTR $LN495@LogCityMon[esi*4]
$LN29@LogCityMon:

; 1668 : 			{
; 1669 : 			case YIELD_FOOD:
; 1670 : 				AppendToLog(strHeader, strLog, "food specialist", aiSpecialistsYields[ui]);

	mov	ecx, eax
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241019[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227009

; 1671 : 				break;

	jmp	SHORT $LN490@LogCityMon
$LN28@LogCityMon:

; 1672 : 			case YIELD_PRODUCTION:
; 1673 : 				AppendToLog(strHeader, strLog, "production specialist", aiSpecialistsYields[ui]);

	mov	ecx, eax
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241020[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227012

; 1674 : 				break;

	jmp	SHORT $LN490@LogCityMon
$LN27@LogCityMon:

; 1675 : 			case YIELD_SCIENCE:
; 1676 : 				AppendToLog(strHeader, strLog, "science specialist", aiSpecialistsYields[ui]);

	mov	ecx, eax
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241021[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227015

; 1677 : 				break;

	jmp	SHORT $LN490@LogCityMon
$LN26@LogCityMon:

; 1678 : 			case YIELD_GOLD:
; 1679 : 				AppendToLog(strHeader, strLog, "gold specialist", aiSpecialistsYields[ui]);

	mov	ecx, eax
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241022[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227018

; 1680 : 				break;

	jmp	SHORT $LN490@LogCityMon
$LN25@LogCityMon:

; 1681 : 			case YIELD_CULTURE:
; 1682 : 				AppendToLog(strHeader, strLog, "culture specialist", aiSpecialistsYields[ui]);

	mov	ecx, eax
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241023[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227021

; 1683 : 				break;

	jmp	SHORT $LN490@LogCityMon
$LN24@LogCityMon:

; 1684 : 			case YIELD_FAITH:
; 1685 : 				AppendToLog(strHeader, strLog, "faith specialist", aiSpecialistsYields[ui]);

	mov	ecx, eax
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241024[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227024
$LN490@LogCityMon:
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+328]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+332]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H
$LN33@LogCityMon:
	inc	esi
	cmp	esi, 6
	jb	$LL34@LogCityMon

; 1686 : 				break;
; 1687 : 			}
; 1688 : 		}
; 1689 : 
; 1690 : 		// ratio from specialists
; 1691 : 		for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	xor	esi, esi
	npad	6
$LL23@LogCityMon:

; 1692 : 		{
; 1693 : 			fRatio = 0.0f;
; 1694 : 			if(aiCityYields[ui] > 0)

	mov	ecx, DWORD PTR [ebp+esi*4]
	xor	eax, eax
	mov	DWORD PTR tv2176[esp+296], ecx
	test	ecx, ecx
	jle	SHORT $LN20@LogCityMon

; 1695 : 			{
; 1696 : 				fRatio = aiSpecialistsYields[ui] / (float)aiCityYields[ui];

	fild	DWORD PTR [edi+esi*4]
	fidiv	DWORD PTR tv2176[esp+296]
	fstp	DWORD PTR _fRatio$[esp+296]
	mov	eax, DWORD PTR _fRatio$[esp+296]
$LN20@LogCityMon:

; 1697 : 			}
; 1698 : 			switch(ui)

	cmp	esi, 5
	ja	$LN22@LogCityMon
	jmp	DWORD PTR $LN496@LogCityMon[esi*4]
$LN17@LogCityMon:

; 1699 : 			{
; 1700 : 			case YIELD_FOOD:
; 1701 : 				AppendToLog(strHeader, strLog, "food specialist / food", fRatio);

	sub	esp, 32					; 00000020H
	mov	DWORD PTR [esp+28], eax
	mov	DWORD PTR $T241025[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227037
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+328]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+332]
	push	edx

; 1702 : 				break;

	jmp	$LN491@LogCityMon
$LN16@LogCityMon:

; 1703 : 			case YIELD_PRODUCTION:
; 1704 : 				AppendToLog(strHeader, strLog, "production specialist / production", fRatio);

	sub	esp, 32					; 00000020H
	mov	DWORD PTR [esp+28], eax
	mov	DWORD PTR $T241026[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227040
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+328]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+332]
	push	ecx

; 1705 : 				break;

	jmp	$LN491@LogCityMon
$LN15@LogCityMon:

; 1706 : 			case YIELD_SCIENCE:
; 1707 : 				AppendToLog(strHeader, strLog, "science specialist / science", fRatio);

	sub	esp, 32					; 00000020H
	mov	DWORD PTR [esp+28], eax
	mov	DWORD PTR $T241027[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227043

; 1708 : 				break;

	jmp	SHORT $LN492@LogCityMon
$LN14@LogCityMon:

; 1709 : 			case YIELD_GOLD:
; 1710 : 				AppendToLog(strHeader, strLog, "gold specialist / gold", fRatio);

	sub	esp, 32					; 00000020H
	mov	DWORD PTR [esp+28], eax
	mov	DWORD PTR $T241028[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227046
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+328]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+332]
	push	edx

; 1711 : 				break;

	jmp	SHORT $LN491@LogCityMon
$LN13@LogCityMon:

; 1712 : 			case YIELD_CULTURE:
; 1713 : 				AppendToLog(strHeader, strLog, "culture specialist / culture", fRatio);

	sub	esp, 32					; 00000020H
	mov	DWORD PTR [esp+28], eax
	mov	DWORD PTR $T241029[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227049
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+328]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+332]
	push	ecx

; 1714 : 				break;

	jmp	SHORT $LN491@LogCityMon
$LN12@LogCityMon:

; 1715 : 			case YIELD_FAITH:
; 1716 : 				AppendToLog(strHeader, strLog, "faith specialist / faith", fRatio);

	sub	esp, 32					; 00000020H
	mov	DWORD PTR [esp+28], eax
	mov	DWORD PTR $T241030[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227052
$LN492@LogCityMon:
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+328]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+332]
	push	eax
$LN491@LogCityMon:
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H
$LN22@LogCityMon:
	inc	esi
	cmp	esi, 6
	jb	$LL23@LogCityMon

; 1717 : 				break;
; 1718 : 			}
; 1719 : 		}
; 1720 : 
; 1721 : 		//	% of worked tiles that are improved
; 1722 : 		// worked tiles
; 1723 : 		int iTiles = 0;
; 1724 : 		int iWorkedTiles = 0;
; 1725 : 		int iImprovedTiles = 0;
; 1726 : 		for(uint uiPlotIndex = 0; uiPlotIndex < aiPlots.size(); uiPlotIndex++)

	mov	eax, DWORD PTR _aiPlots$[esp+296]
	xor	edi, edi
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _iWorkedTiles$227054[esp+296], ebx
	mov	DWORD PTR _iImprovedTiles$227055[esp+296], edi
	cmp	DWORD PTR [eax+4], edi
	jbe	$LN465@LogCityMon
$LN11@LogCityMon:

; 1727 : 		{
; 1728 : 			// when we encounter the first plot that is invalid, the rest of the list will be invalid
; 1729 : 			if(aiPlots[uiPlotIndex] == -1)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+edi*4]
	cmp	eax, -1
	je	$LN485@LogCityMon

; 1730 : 			{
; 1731 : 				break;
; 1732 : 			}
; 1733 : 
; 1734 : 			CvPlot* pPlot = GC.getMap().plotByIndex(aiPlots[uiPlotIndex]);

	test	eax, eax
	jl	SHORT $LN10@LogCityMon
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN10@LogCityMon
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	mov	esi, eax

; 1735 : 			if(!pPlot)

	je	SHORT $LN10@LogCityMon

; 1736 : 			{
; 1737 : 				continue;
; 1738 : 			}
; 1739 : 
; 1740 : 			// plot has city in it, don't count
; 1741 : 			if(pPlot->getPlotCity())

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN476@LogCityMon
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN476@LogCityMon
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	jne	SHORT $LN10@LogCityMon
$LN476@LogCityMon:

; 1742 : 			{
; 1743 : 				continue;
; 1744 : 			}
; 1745 : 
; 1746 : 			if(!pLoopCity->GetCityCitizens()->IsCanWork(pPlot))

	mov	ecx, DWORD PTR _pLoopCity$[esp+296]
	push	esi
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ; CvCityCitizens::IsCanWork
	test	al, al
	je	SHORT $LN10@LogCityMon

; 1747 : 			{
; 1748 : 				continue;
; 1749 : 			}
; 1750 : 
; 1751 : 			iTiles++;
; 1752 : 
; 1753 : 			if(pPlot->getWorkingCity() == pLoopCity)

	mov	ecx, esi
	inc	ebp
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	cmp	eax, DWORD PTR _pLoopCity$[esp+296]
	jne	SHORT $LN4@LogCityMon

; 1754 : 			{
; 1755 : 				iWorkedTiles++;

	inc	ebx
$LN4@LogCityMon:

; 1756 : 			}
; 1757 : 
; 1758 : 			if(pPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN10@LogCityMon

; 1759 : 			{
; 1760 : 				iImprovedTiles++;

	inc	DWORD PTR _iImprovedTiles$227055[esp+296]
$LN10@LogCityMon:

; 1717 : 				break;
; 1718 : 			}
; 1719 : 		}
; 1720 : 
; 1721 : 		//	% of worked tiles that are improved
; 1722 : 		// worked tiles
; 1723 : 		int iTiles = 0;
; 1724 : 		int iWorkedTiles = 0;
; 1725 : 		int iImprovedTiles = 0;
; 1726 : 		for(uint uiPlotIndex = 0; uiPlotIndex < aiPlots.size(); uiPlotIndex++)

	mov	eax, DWORD PTR _aiPlots$[esp+296]
	inc	edi
	cmp	edi, DWORD PTR [eax+4]
	jb	$LN11@LogCityMon
$LN485@LogCityMon:

; 1754 : 			{
; 1755 : 				iWorkedTiles++;

	mov	DWORD PTR _iWorkedTiles$227054[esp+296], ebx
$LN465@LogCityMon:

; 1761 : 			}
; 1762 : 		}
; 1763 : 
; 1764 : 		AppendToLog(strHeader, strLog, "Tiles", iTiles);

	push	ebp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241031[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227068
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+328]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+332]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1765 : 		AppendToLog(strHeader, strLog, "Worked (non-city) tiles", iWorkedTiles);

	push	ebx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241032[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227070
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+328]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+332]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog

; 1766 : 		AppendToLog(strHeader, strLog, "Improved tiles", iImprovedTiles);

	mov	ecx, DWORD PTR _iImprovedTiles$227055[esp+336]
	add	esp, 40					; 00000028H
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T241033[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227072
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+328]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+332]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1767 : 
; 1768 : 		// % of worked tiles that are improved
; 1769 : 		// improved / worked tiles
; 1770 : 		fRatio = 0.0f;

	xor	eax, eax

; 1771 : 		if(iWorkedTiles > 0)

	test	ebx, ebx
	jle	SHORT $LN2@LogCityMon

; 1772 : 		{
; 1773 : 			fRatio = iImprovedTiles / (float)iWorkedTiles;

	fild	DWORD PTR _iImprovedTiles$227055[esp+296]
	fidiv	DWORD PTR _iWorkedTiles$227054[esp+296]
	fstp	DWORD PTR _fRatio$[esp+296]
	mov	eax, DWORD PTR _fRatio$[esp+296]
$LN2@LogCityMon:

; 1774 : 		}
; 1775 : 		AppendToLog(strHeader, strLog, "improved / worked", fRatio);

	sub	esp, 32					; 00000020H
	mov	DWORD PTR [esp+28], eax
	mov	DWORD PTR $T241034[esp+328], esp
	mov	ecx, esp
	push	OFFSET $SG227076
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+328]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+332]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1776 : 
; 1777 : 		if(bBuildHeader)

	cmp	BYTE PTR _bBuildHeader$[esp+296], 0
	je	SHORT $LN483@LogCityMon

; 1778 : 		{
; 1779 : 			bBuildHeader = false;
; 1780 : 			pLog->Msg(strHeader);

	lea	ecx, DWORD PTR _strHeader$[esp+296]
	mov	BYTE PTR _bBuildHeader$[esp+296], 0
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	esi, DWORD PTR _pLog$[esp+296]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8
	jmp	SHORT $LN1@LogCityMon
$LN483@LogCityMon:
	mov	esi, DWORD PTR _pLog$[esp+296]
$LN1@LogCityMon:

; 1781 : 		}
; 1782 : 		pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$[esp+296]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	mov	eax, DWORD PTR _this$[esp+304]
	mov	ecx, DWORD PTR [eax+4]
	add	esp, 8
	push	0
	lea	edx, DWORD PTR _iLoopCity$[esp+300]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[esp+296], eax
	test	eax, eax
	jne	$LL478@LogCityMon

; 1575 : 
; 1576 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iLoopCity))

	or	esi, -1
$LN64@LogCityMon:

; 1783 : 	}
; 1784 : }

	mov	eax, DWORD PTR _aiSpecialistsYields$[esp+296]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+308], 7
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	ecx, DWORD PTR _aiCityYields$[esp+300]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+312], 6
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 8
	lea	ecx, DWORD PTR _str$[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogName$[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayerName$[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLog$[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strHeader$[esp+296]
	mov	DWORD PTR __$EHRec$[esp+304], esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN71@LogCityMon:
	mov	ecx, DWORD PTR __$EHRec$[esp+296]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN493@LogCityMon:
	DD	$LN52@LogCityMon
	DD	$LN51@LogCityMon
	DD	$LN49@LogCityMon
	DD	$LN50@LogCityMon
	DD	$LN48@LogCityMon
	DD	$LN47@LogCityMon
$LN494@LogCityMon:
	DD	$LN40@LogCityMon
	DD	$LN39@LogCityMon
	DD	$LN37@LogCityMon
	DD	$LN38@LogCityMon
	DD	$LN36@LogCityMon
	DD	$LN35@LogCityMon
$LN495@LogCityMon:
	DD	$LN29@LogCityMon
	DD	$LN28@LogCityMon
	DD	$LN26@LogCityMon
	DD	$LN27@LogCityMon
	DD	$LN25@LogCityMon
	DD	$LN24@LogCityMon
$LN496@LogCityMon:
	DD	$LN17@LogCityMon
	DD	$LN16@LogCityMon
	DD	$LN14@LogCityMon
	DD	$LN15@LogCityMon
	DD	$LN13@LogCityMon
	DD	$LN12@LogCityMon
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strHeader$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T240996[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$5:
	lea	ecx, DWORD PTR $T240997[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$6:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$7:
	lea	ecx, DWORD PTR _aiCityYields$[ebp]
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$8:
	lea	ecx, DWORD PTR _aiSpecialistsYields$[ebp]
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$9:
	mov	ecx, DWORD PTR $T241000[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$12:
	lea	ecx, DWORD PTR $T241003[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$13:
	mov	ecx, DWORD PTR $T241004[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogCityMonitor@CvEconomicAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?LogCityMonitor@CvEconomicAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogCityMonitor@CvEconomicAI@@QAEXXZ ENDP		; CvEconomicAI::LogCityMonitor
PUBLIC	?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ	; CvEconomicAI::AssignHutsToExplorers
EXTRN	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z:PROC ; CvTwoLayerPathFinder::GenerateUnitPath
EXTRN	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::getPathFinder
EXTRN	?maxMoves@CvUnit@@QBEHXZ:PROC			; CvUnit::maxMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ$1
__ehfuncinfo$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
_uiGoody$227676 = -56					; size = 4
_uiHutIndex$227674 = -52				; size = 4
_this$ = -48						; size = 4
_iClosestEstimateTurns$227675 = -44			; size = 4
_uiExplorer$227669 = -40				; size = 4
_aiHutIndices$ = -36					; size = 12
_tempHutIndices$227699 = -24				; size = 12
__$EHRec$ = -12						; size = 12
?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ PROC	; CvEconomicAI::AssignHutsToExplorers, COMDAT
; _this$ = ecx

; 2618 : {

	push	-1
	push	__ehhandler$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 2619 : 	FFastVector<unsigned int> aiHutIndices;

	xor	ebp, ebp
	xor	ecx, ecx
	xor	ebx, ebx
	mov	DWORD PTR _this$[esp+72], edi
	mov	DWORD PTR _aiHutIndices$[esp+76], ecx
	mov	DWORD PTR _aiHutIndices$[esp+80], ebx
	mov	DWORD PTR _aiHutIndices$[esp+72], ebp

; 2620 : 
; 2621 : 	// Create temporary list of huts
; 2622 : 	for(uint uiGoodyPlots = 0; uiGoodyPlots < m_aiGoodyHutPlots.size(); uiGoodyPlots++)

	mov	eax, DWORD PTR [edi+92]
	xor	esi, esi
	mov	DWORD PTR __$EHRec$[esp+80], ebp
	cmp	eax, ebp
	jbe	SHORT $LN16@AssignHuts
$LL18@AssignHuts:

; 2623 : 	{
; 2624 : 		aiHutIndices.push_back(uiGoodyPlots);

	cmp	ecx, ebx
	jne	SHORT $LN34@AssignHuts
	push	ebx
	lea	ecx, DWORD PTR _aiHutIndices$[esp+76]
	call	?GrowSize@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXI@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::GrowSize
	mov	ebx, DWORD PTR _aiHutIndices$[esp+80]
$LN34@AssignHuts:
	mov	ecx, DWORD PTR _aiHutIndices$[esp+76]
	mov	eax, DWORD PTR _aiHutIndices$[esp+72]
	lea	eax, DWORD PTR [eax+ecx*4]
	cmp	eax, ebp
	je	SHORT $LN37@AssignHuts
	mov	DWORD PTR [eax], esi
$LN37@AssignHuts:
	inc	ecx
	inc	esi
	mov	DWORD PTR _aiHutIndices$[esp+76], ecx
	cmp	esi, DWORD PTR [edi+92]
	jb	SHORT $LL18@AssignHuts
$LN16@AssignHuts:

; 2625 : 	}
; 2626 : 
; 2627 : 	for(uint uiExplorer = 0; uiExplorer < m_apExplorers.size(); uiExplorer++)

	mov	eax, DWORD PTR [edi+292]
	xor	edx, edx
	mov	DWORD PTR _uiExplorer$227669[esp+72], edx
	cmp	eax, ebp
	jbe	$LN13@AssignHuts
	jmp	SHORT $LN15@AssignHuts
	npad	11
$LL192@AssignHuts:
	mov	ecx, DWORD PTR _aiHutIndices$[esp+76]
$LN15@AssignHuts:

; 2628 : 	{
; 2629 : 		CvUnit* pUnit = m_apExplorers[uiExplorer];

	mov	eax, DWORD PTR [edi+288]
	mov	esi, DWORD PTR [eax+edx*4]

; 2630 : 		uint uiHutIndex = MAX_INT;

	mov	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _uiHutIndex$227674[esp+72], eax

; 2631 : 		int iClosestEstimateTurns = MAX_INT;

	mov	DWORD PTR _iClosestEstimateTurns$227675[esp+72], eax

; 2632 : 
; 2633 : 		for(uint uiGoody = 0; uiGoody < aiHutIndices.size(); uiGoody++)

	xor	eax, eax
	mov	DWORD PTR _uiGoody$227676[esp+72], eax
	test	ecx, ecx
	jbe	$LN14@AssignHuts
	jmp	SHORT $LN12@AssignHuts
	npad	6
$LL193@AssignHuts:
	mov	edi, DWORD PTR _this$[esp+72]
$LN12@AssignHuts:

; 2634 : 		{
; 2635 : 			if(m_aiGoodyHutPlots[aiHutIndices[uiGoody]] == -1)

	mov	ecx, DWORD PTR _aiHutIndices$[esp+72]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edi+88]
	mov	edi, DWORD PTR [eax+edx*4]
	cmp	edi, -1
	je	$LN11@AssignHuts

; 2636 : 			{
; 2637 : 				continue;
; 2638 : 			}
; 2639 : 
; 2640 : 			CvPlot* pGoodyPlot = GC.getMap().plotByIndex(m_aiGoodyHutPlots[aiHutIndices[uiGoody]]);

	test	edi, edi
	jl	SHORT $LN59@AssignHuts
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	edi, DWORD PTR [eax+4028]
	jge	SHORT $LN59@AssignHuts
	imul	edi, 484				; 000001e4H
	add	edi, DWORD PTR [eax+4068]
	jmp	SHORT $LN60@AssignHuts
$LN59@AssignHuts:
	xor	edi, edi
$LN60@AssignHuts:

; 2641 : 			int iDistance = plotDistance(pUnit->getX(), pUnit->getY(), pGoodyPlot->getX(), pGoodyPlot->getY());

	movsx	edx, WORD PTR [edi+2]
	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	edx
	movsx	edx, WORD PTR [edi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 2642 : 
; 2643 : 			int iEstimateTurns = MAX_INT;
; 2644 : 			if(pUnit->maxMoves() >= 1)

	mov	ecx, esi
	mov	ebx, eax
	mov	ebp, 2147483647				; 7fffffffH
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	cmp	eax, 1
	jl	SHORT $LN8@AssignHuts

; 2645 : 			{
; 2646 : 				iEstimateTurns = iDistance / (pUnit->maxMoves() / GC.getMOVE_DENOMINATOR());

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	ecx, esi
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	cdq
	idiv	ebp
	mov	ecx, eax
	mov	eax, ebx
	cdq
	idiv	ecx
	mov	ebp, eax
$LN8@AssignHuts:

; 2647 : 			}
; 2648 : 
; 2649 : 			if(iEstimateTurns < iClosestEstimateTurns)

	cmp	ebp, DWORD PTR _iClosestEstimateTurns$227675[esp+72]
	jge	SHORT $LN189@AssignHuts

; 2650 : 			{
; 2651 : 				// Now check path
; 2652 : 				bool bCanFindPath = GC.getPathFinder().GenerateUnitPath(pUnit, pUnit->getX(), pUnit->getY(), pGoodyPlot->getX(), pGoodyPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	mov	edx, DWORD PTR [esi+88]
	mov	edi, DWORD PTR [esi+76]
	push	1
	push	138					; 0000008aH
	push	eax
	push	ecx
	push	edx
	push	edi
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	ecx, eax
	call	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath

; 2653 : 				if(bCanFindPath)
; 2654 : 				{
; 2655 : 					iClosestEstimateTurns = iEstimateTurns;
; 2656 : 					uiHutIndex = aiHutIndices[uiGoody];

	mov	ebx, DWORD PTR _aiHutIndices$[esp+80]
	test	al, al
	je	SHORT $LN11@AssignHuts
	mov	edx, DWORD PTR _aiHutIndices$[esp+72]
	mov	eax, DWORD PTR _uiGoody$227676[esp+72]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _iClosestEstimateTurns$227675[esp+72], ebp
	mov	DWORD PTR _uiHutIndex$227674[esp+72], ecx
	jmp	SHORT $LN11@AssignHuts
$LN189@AssignHuts:
	mov	ebx, DWORD PTR _aiHutIndices$[esp+80]
$LN11@AssignHuts:

; 2632 : 
; 2633 : 		for(uint uiGoody = 0; uiGoody < aiHutIndices.size(); uiGoody++)

	mov	eax, DWORD PTR _uiGoody$227676[esp+72]
	mov	ebp, DWORD PTR _aiHutIndices$[esp+76]
	inc	eax
	mov	DWORD PTR _uiGoody$227676[esp+72], eax
	cmp	eax, ebp
	jb	$LL193@AssignHuts

; 2657 : 				}
; 2658 : 			}
; 2659 : 		}
; 2660 : 
; 2661 : 		if(uiHutIndex != MAX_INT)

	mov	edx, DWORD PTR _uiHutIndex$227674[esp+72]
	cmp	edx, 2147483647				; 7fffffffH
	je	$LN14@AssignHuts

; 2662 : 		{
; 2663 : 			m_aiGoodyHutUnitAssignments[uiHutIndex] = GoodyHutUnitAssignment( pUnit->GetID(), -1);

	mov	eax, DWORD PTR _this$[esp+72]
	mov	esi, DWORD PTR [esi+100]
	mov	eax, DWORD PTR [eax+100]
	or	ecx, -1

; 2664 : 
; 2665 : 			FFastVector<unsigned int> tempHutIndices = aiHutIndices;

	xor	edi, edi
	mov	DWORD PTR [eax+edx*8], esi
	mov	DWORD PTR [eax+edx*8+4], ecx
	mov	DWORD PTR _tempHutIndices$227699[esp+72], edi
	mov	DWORD PTR _tempHutIndices$227699[esp+80], ebx
	test	ebx, ebx
	je	SHORT $LN190@AssignHuts
	jbe	SHORT $LN104@AssignHuts
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	ecx, DWORD PTR [ebx*4]
	push	4
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tempHutIndices$227699[esp+80], ebx
	jmp	SHORT $LN105@AssignHuts
$LN104@AssignHuts:
	xor	eax, eax
$LN105@AssignHuts:
	mov	edi, eax
	mov	DWORD PTR _tempHutIndices$227699[esp+72], edi
$LN190@AssignHuts:
	mov	ecx, DWORD PTR _aiHutIndices$[esp+72]
	mov	DWORD PTR _tempHutIndices$227699[esp+76], ebp
	mov	eax, edi
	sub	ecx, edi
	mov	edx, ebp
	npad	1
$LL111@AssignHuts:
	test	eax, eax
	je	SHORT $LN110@AssignHuts
	mov	esi, DWORD PTR [ecx+eax]
	mov	DWORD PTR [eax], esi
$LN110@AssignHuts:
	add	eax, 4
	sub	edx, 1
	jne	SHORT $LL111@AssignHuts

; 2666 : 			aiHutIndices.clear();

	xor	ecx, ecx

; 2667 : 			for(uint uiHut = 0; uiHut < tempHutIndices.size(); uiHut++)

	xor	esi, esi
	mov	BYTE PTR __$EHRec$[esp+80], 1
	mov	DWORD PTR _aiHutIndices$[esp+76], ecx
	test	ebp, ebp
	jbe	SHORT $LN2@AssignHuts
$LL4@AssignHuts:

; 2668 : 			{
; 2669 : 				if(tempHutIndices[uiHut] != uiHutIndex)

	mov	edx, DWORD PTR _uiHutIndex$227674[esp+72]
	cmp	DWORD PTR [edi+esi*4], edx
	je	SHORT $LN3@AssignHuts

; 2670 : 				{
; 2671 : 					aiHutIndices.push_back(tempHutIndices[uiHut]);

	cmp	ecx, ebx
	jne	SHORT $LN134@AssignHuts
	push	ebx
	lea	ecx, DWORD PTR _aiHutIndices$[esp+76]
	call	?GrowSize@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXI@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::GrowSize
	mov	ebx, DWORD PTR _aiHutIndices$[esp+80]
	mov	ecx, DWORD PTR _aiHutIndices$[esp+76]
$LN134@AssignHuts:
	mov	eax, DWORD PTR _aiHutIndices$[esp+72]
	lea	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN137@AssignHuts
	mov	edx, DWORD PTR [edi+esi*4]
	mov	DWORD PTR [eax], edx
$LN137@AssignHuts:
	inc	ecx
	mov	DWORD PTR _aiHutIndices$[esp+76], ecx
$LN3@AssignHuts:
	inc	esi
	cmp	esi, ebp
	jb	SHORT $LL4@AssignHuts
$LN2@AssignHuts:

; 2672 : 				}
; 2673 : 			}
; 2674 : 		}

	push	edi
	mov	BYTE PTR __$EHRec$[esp+84], 0
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN14@AssignHuts:
	mov	edx, DWORD PTR _uiExplorer$227669[esp+72]
	mov	edi, DWORD PTR _this$[esp+72]
	inc	edx
	mov	DWORD PTR _uiExplorer$227669[esp+72], edx
	cmp	edx, DWORD PTR [edi+292]
	jb	$LL192@AssignHuts
$LN13@AssignHuts:

; 2675 : 	}
; 2676 : }

	mov	eax, DWORD PTR _aiHutIndices$[esp+72]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+84], -1
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 56					; 00000038H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _aiHutIndices$[ebp]
	jmp	??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _tempHutIndices$227699[ebp]
	jmp	??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
__ehhandler$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ ENDP	; CvEconomicAI::AssignHutsToExplorers
PUBLIC	??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::~vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::~vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::~vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEXXZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::clear
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEIABQAVCvUnit@@H@Z ; CvWeightedVector<CvUnit *,50,1>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEIABQAVCvUnit@@H@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEIABQAVCvUnit@@H@Z PROC ; CvWeightedVector<CvUnit *,50,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+412], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@7
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSize
$LN5@push_back@7:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@7
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@7:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEIABQAVCvUnit@@H@Z ENDP ; CvWeightedVector<CvUnit *,50,1>::push_back
_TEXT	ENDS
PUBLIC	?reserve@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXI@Z ; CvWeightedVector<CvUnit *,50,1>::reserve
; Function compile flags: /Ogtpy
;	COMDAT ?reserve@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?reserve@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXI@Z PROC ; CvWeightedVector<CvUnit *,50,1>::reserve, COMDAT
; _this$ = ecx

; 128  : 		m_pItems.reserve(uiNewSize);

	jmp	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSizeToFit
?reserve@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXI@Z ENDP ; CvWeightedVector<CvUnit *,50,1>::reserve
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_merge<CvPurchaseRequest *,int,CvPurchaseRequest>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z
_TEXT	SEGMENT
__Firstn$230036 = -32					; size = 4
__Lastn$230037 = -28					; size = 4
__Midn$230056 = -24					; size = 4
$T242366 = -20						; size = 20
$T242364 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
tv368 = 20						; size = 4
$T242485 = 20						; size = 1
$T242433 = 20						; size = 1
$T242434 = 20						; size = 1
$T242365 = 20						; size = 4
$T242363 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z PROC ; std::_Buffered_merge<CvPurchaseRequest *,int,CvPurchaseRequest>, COMDAT

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[esp-4]
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, DWORD PTR __First$[esp+32]
	push	ebp
	mov	ebp, DWORD PTR __Mid$[esp+36]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+44]
	add	eax, edi
	cmp	eax, 2
	je	$LN106@Buffered_m
	jmp	SHORT $LN101@Buffered_m
$LL113@Buffered_m:
	mov	edi, DWORD PTR __Count2$[esp+44]
$LN101@Buffered_m:

; 2764 : 		}
; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	DWORD PTR __Count1$[esp+44], edi
	mov	esi, DWORD PTR __Tempbuf$[esp+44]
	jg	SHORT $LN6@Buffered_m
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen
	cmp	DWORD PTR __Count1$[esp+44], eax
	jle	$LN107@Buffered_m
$LN6@Buffered_m:

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen
	cmp	edi, eax
	jle	$LN108@Buffered_m

; 2775 : 		}
; 2776 : 	else
; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	mov	eax, DWORD PTR __Count1$[esp+44]
	cmp	edi, eax

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2784 : 			_Firstn = _First;
; 2785 : 			std::advance(_Firstn, _Count1n);
; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	push	0
	jge	SHORT $LN2@Buffered_m
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __Last$[esp+48]
	mov	edi, eax
	sar	edi, 1
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	eax, DWORD PTR [ebx+ecx*4]
	push	eax
	push	edx
	push	ebp
	mov	DWORD PTR __Firstn$230036[esp+64], eax
	call	??$_Lower_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvPurchaseRequest *,CvPurchaseRequest,int>
	mov	ecx, eax

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	edx, ecx
	sub	edx, ebp
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Lastn$230037[esp+48], ecx
	add	esi, edx

; 2788 : 			}
; 2789 : 		else

	jmp	SHORT $LN99@Buffered_m
$LN2@Buffered_m:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	eax, edi
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1

; 2792 : 			_Lastn = _Mid;
; 2793 : 			std::advance(_Lastn, _Count2n);

	lea	eax, DWORD PTR [esi+esi*2]
	lea	eax, DWORD PTR [ebp+eax*4]

; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	push	eax
	push	ebp
	push	ebx
	mov	DWORD PTR __Lastn$230037[esp+64], eax
	call	??$_Upper_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvPurchaseRequest *,CvPurchaseRequest,int>

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	ecx, DWORD PTR __Lastn$230037[esp+64]
	mov	edx, eax
	mov	DWORD PTR __Firstn$230036[esp+64], eax
	sub	edx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	esp, 16					; 00000010H
	add	edi, edx
$LN99@Buffered_m:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	edx, DWORD PTR __Tempbuf$[esp+44]
	mov	eax, DWORD PTR __Count1$[esp+44]
	push	edx
	sub	eax, edi
	push	esi
	push	eax
	push	ecx
	mov	DWORD PTR tv368[esp+60], eax
	mov	eax, DWORD PTR __Firstn$230036[esp+64]
	push	ebp
	push	eax
	call	??$_Buffered_rotate@PAVCvPurchaseRequest@@HV1@@std@@YAPAVCvPurchaseRequest@@PAV1@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_rotate<CvPurchaseRequest *,int,CvPurchaseRequest>

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	ecx, DWORD PTR __Tempbuf$[esp+68]
	mov	edx, DWORD PTR __Firstn$230036[esp+72]
	push	ecx
	push	esi
	push	edi
	push	eax
	push	edx
	push	ebx
	mov	DWORD PTR __Midn$230056[esp+96], eax
	call	??$_Buffered_merge@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_merge<CvPurchaseRequest *,int,CvPurchaseRequest>

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	eax, DWORD PTR __Count2$[esp+92]
	mov	ecx, DWORD PTR tv368[esp+92]
	mov	ebp, DWORD PTR __Lastn$230037[esp+96]
	mov	ebx, DWORD PTR __Midn$230056[esp+96]
	sub	eax, esi
	mov	DWORD PTR __Count1$[esp+92], ecx
	add	ecx, eax
	add	esp, 48					; 00000030H
	mov	DWORD PTR __Count2$[esp+44], eax
	cmp	ecx, 2
	jne	$LL113@Buffered_m
$LN106@Buffered_m:

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR [ebp+8]
	cmp	eax, DWORD PTR [ebx+8]
	jle	$LN3@Buffered_m

; 2763 : 			std::iter_swap(_First, _Mid);

	cmp	ebx, ebp
	je	$LN3@Buffered_m
	mov	esi, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx], esi
	mov	esi, DWORD PTR [ebp+4]
	mov	DWORD PTR [ebx+4], esi
	mov	esi, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebx+8], esi
	mov	DWORD PTR [ebp], eax
	mov	DWORD PTR [ebp+4], ecx
	mov	DWORD PTR [ebp+8], edx

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
$LN107@Buffered_m:

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T242363[esp+64], esp
	push	ebp
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T242364[esp+72]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	mov	eax, DWORD PTR $T242364[esp+80]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN37@Buffered_m
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN37@Buffered_m:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	eax, DWORD PTR __Last$[esp+44]
	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T242433[esp+44], 0
	mov	ecx, DWORD PTR $T242433[esp+44]
	mov	edx, DWORD PTR $T242434[esp+44]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	mov	edx, DWORD PTR [esi]
	push	ebx
	push	eax
	push	ebp
	push	ecx
	push	edx
	call	??$_Merge@PAVCvPurchaseRequest@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
$LN108@Buffered_m:

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR __Last$[esp+44]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T242365[esp+64], esp
	push	edi
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T242366[esp+72]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	mov	eax, DWORD PTR $T242366[esp+80]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN61@Buffered_m
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN61@Buffered_m:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR $T242485[esp+44], 0
	mov	ecx, DWORD PTR $T242485[esp+44]
	push	ecx
	push	edi
	push	edx
	push	eax
	push	ebp
	push	ebx
	call	??$_Merge_backward@PAVCvPurchaseRequest@@PAV1@PAV1@@std@@YAPAVCvPurchaseRequest@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>
	add	esp, 24					; 00000018H
$LN3@Buffered_m:

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
??$_Buffered_merge@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ENDP ; std::_Buffered_merge<CvPurchaseRequest *,int,CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap
	mov	ebx, 8
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	lea	esi, DWORD PTR [ecx-8]
	jle	SHORT $LN2@Sort_heap
$LN24@Sort_heap:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	sub	esp, 8
	mov	DWORD PTR [esi+4], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [ebx+esi-8]
	sar	ecx, 3
	push	ecx
	push	0
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN2@Sort_heap:
	sub	esi, 8
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 3
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap
$LN1@Sort_heap:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@PAV1@H@stdext@@YAXPAVCvPurchaseRequest@@00HH@Z ; stdext::_Unchecked_chunked_merge<CvPurchaseRequest *,CvPurchaseRequest *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@PAV1@H@stdext@@YAXPAVCvPurchaseRequest@@00HH@Z
_TEXT	SEGMENT
$T242653 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@PAV1@H@stdext@@YAXPAVCvPurchaseRequest@@00HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvPurchaseRequest *,CvPurchaseRequest *,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	mov	BYTE PTR $T242653[esp+4], 0
	mov	eax, DWORD PTR $T242653[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvPurchaseRequest@@PAV1@H@std@@YAXPAVCvPurchaseRequest@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvPurchaseRequest *,CvPurchaseRequest *,int>

; 5254 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@PAV1@H@stdext@@YAXPAVCvPurchaseRequest@@00HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvPurchaseRequest *,CvPurchaseRequest *,int>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z ; stdext::unchecked_merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z
_TEXT	SEGMENT
$T242657 = -4						; size = 1
$T242663 = -4						; size = 4
$T242659 = -4						; size = 4
$T242658 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z PROC ; stdext::unchecked_merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T242663[esp+8], ebx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T242658[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T242657[esp+12], bl
	mov	eax, DWORD PTR $T242657[esp+12]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+36]
	mov	edx, DWORD PTR __Last1$[esp+36]
	mov	DWORD PTR $T242659[esp+40], esp
	push	eax
	mov	eax, DWORD PTR __First1$[esp+40]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+56]
	add	esp, 48					; 00000030H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@6:
	mov	eax, esi

; 5117 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z ENDP ; stdext::unchecked_merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
_TEXT	ENDS
PUBLIC	??0CvEconomicAIStrategyXMLEntries@@QAE@XZ	; CvEconomicAIStrategyXMLEntries::CvEconomicAIStrategyXMLEntries
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
;	COMDAT ??0CvEconomicAIStrategyXMLEntries@@QAE@XZ
_TEXT	SEGMENT
??0CvEconomicAIStrategyXMLEntries@@QAE@XZ PROC		; CvEconomicAIStrategyXMLEntries::CvEconomicAIStrategyXMLEntries, COMDAT
; _this$ = ecx

; 200  : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 201  : 
; 202  : }

	ret	0
??0CvEconomicAIStrategyXMLEntries@@QAE@XZ ENDP		; CvEconomicAIStrategyXMLEntries::CvEconomicAIStrategyXMLEntries
_TEXT	ENDS
PUBLIC	?DeleteArray@CvEconomicAIStrategyXMLEntries@@QAEXXZ ; CvEconomicAIStrategyXMLEntries::DeleteArray
; Function compile flags: /Ogtpy
;	COMDAT ?DeleteArray@CvEconomicAIStrategyXMLEntries@@QAEXXZ
_TEXT	SEGMENT
?DeleteArray@CvEconomicAIStrategyXMLEntries@@QAEXXZ PROC ; CvEconomicAIStrategyXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 224  : {

	push	esi
	push	edi
	mov	edi, ecx

; 225  : 	for(std::vector<CvEconomicAIStrategyXMLEntry*>::iterator it = m_paAIStrategyEntries.begin(); it != m_paAIStrategyEntries.end(); ++it)

	mov	esi, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [edi+8]
	je	SHORT $LN1@DeleteArra
	npad	4
$LL14@DeleteArra:

; 226  : 	{
; 227  : 		SAFE_DELETE(*it);

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN32@DeleteArra
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	1
	call	edx
$LN32@DeleteArra:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [edi+8]
	jne	SHORT $LL14@DeleteArra
$LN1@DeleteArra:

; 228  : 	}
; 229  : 
; 230  : 	m_paAIStrategyEntries.clear();

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN48@DeleteArra
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN73@DeleteArra
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN73@DeleteArra:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN48@DeleteArra:
	pop	edi
	pop	esi

; 231  : }

	ret	0
?DeleteArray@CvEconomicAIStrategyXMLEntries@@QAEXXZ ENDP ; CvEconomicAIStrategyXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	?Init@CvEconomicAI@@QAEXPAVCvEconomicAIStrategyXMLEntries@@PAVCvPlayer@@@Z ; CvEconomicAI::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvEconomicAI@@QAEXPAVCvEconomicAIStrategyXMLEntries@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
$T243135 = 8						; size = 4
_pAIStrategies$ = 8					; size = 4
_pPlayer$ = 12						; size = 4
?Init@CvEconomicAI@@QAEXPAVCvEconomicAIStrategyXMLEntries@@PAVCvPlayer@@@Z PROC ; CvEconomicAI::Init, COMDAT
; _this$ = ecx

; 261  : 	// Store off the pointer to the AIStrategies active for this game
; 262  : 	m_pAIStrategies = pAIStrategies;
; 263  : 
; 264  : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _pPlayer$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _pAIStrategies$[esp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ecx

; 265  : 
; 266  : 	// Initialize arrays
; 267  : 	FAssertMsg(m_pabUsingStrategy==NULL, "about to leak memory, CvStrategyAI::m_pabUsingStrategy");
; 268  : 	m_pabUsingStrategy = FNEW(bool[m_pAIStrategies->GetNumEconomicAIStrategies()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 269  : 
; 270  : 	FAssertMsg(m_paiTurnStrategyAdopted==NULL, "about to leak memory, CvStrategyAI::m_paiTurnStrategyAdopted");
; 271  : 	m_paiTurnStrategyAdopted = FNEW(int[m_pAIStrategies->GetNumEconomicAIStrategies()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	sar	eax, 2
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+16], eax

; 272  : 
; 273  : 	FAssertMsg(m_aiTempFlavors==NULL, "about to leak memory, CvStrategyAI::m_aiTempFlavors");
; 274  : 	m_aiTempFlavors = FNEW(int[GC.getNumFlavorTypes()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+20], eax

; 275  : 
; 276  : 	m_auiYields.clear();
; 277  : #ifdef AUI_WARNING_FIXES
; 278  : 	m_auiYields.push_back_copy(0, uint(NUM_YIELD_TYPES));
; 279  : #else
; 280  : 	m_auiYields.push_back_copy(-1, NUM_YIELD_TYPES);

	push	6
	lea	eax, DWORD PTR $T243135[esp+4]
	lea	ecx, DWORD PTR [esi+52]
	push	eax
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR $T243135[esp+8], -1
	call	?push_back_copy@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEXABII@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back_copy

; 281  : #endif
; 282  : 	m_RequestedSavings.clear();
; 283  : 
; 284  : 	Reset();

	mov	ecx, esi
	mov	DWORD PTR [esi+116], 0
	call	?Reset@CvEconomicAI@@QAEXXZ		; CvEconomicAI::Reset
	pop	esi

; 285  : }

	ret	8
?Init@CvEconomicAI@@QAEXPAVCvEconomicAIStrategyXMLEntries@@PAVCvPlayer@@@Z ENDP ; CvEconomicAI::Init
_TEXT	ENDS
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::sort_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T243207 = -24						; size = 4
$T243212 = -20						; size = 20
$T243210 = -20						; size = 20
$T243208 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T243209 = 40						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>, COMDAT

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Count$[esp+32]
	lea	ecx, DWORD PTR [eax+eax]
	xor	ebx, ebx
	cmp	ecx, esi
	push	edi
	jg	SHORT $LN3@Chunked_me@2
	lea	edi, DWORD PTR [eax+eax*2]
	add	edi, edi
	add	edi, edi
$LL5@Chunked_me@2:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR $T243207[esp+60], esp
	lea	esi, DWORD PTR [edi+ecx]
	push	esi
	push	ecx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ebp, DWORD PTR __Dest$[esp+80]
	push	ecx
	mov	DWORD PTR [eax+16], ebp
	push	edx
	lea	eax, DWORD PTR $T243208[esp+76]
	push	eax
	call	??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z ; stdext::unchecked_merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T243208[esp+80]
	add	esp, 40					; 00000028H
	mov	DWORD PTR __Dest$[esp+52], ecx
	cmp	eax, ebx
	je	SHORT $LN41@Chunked_me@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Chunked_me@2:
	mov	eax, DWORD PTR __Chunk$[esp+36]

; 3297 : 		_First = _Mid2;

	mov	edx, esi
	mov	esi, DWORD PTR __Count$[esp+36]
	lea	ecx, DWORD PTR [eax+eax]
	sub	esi, ecx
	cmp	esi, ecx
	mov	DWORD PTR __Count$[esp+36], esi
	jge	SHORT $LL5@Chunked_me@2
$LN3@Chunked_me@2:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)
; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	cmp	esi, eax
	mov	DWORD PTR $T243209[esp+56], esp
	jg	SHORT $LN2@Chunked_me@2
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T243210[esp+68]
	push	ecx
	call	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	add	esp, 32					; 00000020H

; 3302 : 	else

	jmp	SHORT $LN99@Chunked_me@2
$LN2@Chunked_me@2:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);

	lea	eax, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [edx+eax*4]

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	esi, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], esi
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	push	ecx
	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T243212[esp+76]
	push	ecx
	call	??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z ; stdext::unchecked_merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	add	esp, 40					; 00000028H
$LN99@Chunked_me@2:
	mov	eax, DWORD PTR $T243212[esp+40]
	cmp	eax, ebx
	je	SHORT $LN75@Chunked_me@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN75@Chunked_me@2:

; 3308 : 		}
; 3309 : 	}

	mov	eax, DWORD PTR __Dest$[esp+36]
	cmp	eax, ebx
	je	SHORT $LN85@Chunked_me@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN85@Chunked_me@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>
_TEXT	ENDS
PUBLIC	??1CvEconomicAIStrategyXMLEntries@@QAE@XZ	; CvEconomicAIStrategyXMLEntries::~CvEconomicAIStrategyXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ$0
__ehfuncinfo$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ??1CvEconomicAIStrategyXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvEconomicAIStrategyXMLEntries@@QAE@XZ PROC		; CvEconomicAIStrategyXMLEntries::~CvEconomicAIStrategyXMLEntries, COMDAT
; _this$ = ecx

; 206  : {

	push	-1
	push	__ehhandler$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi

; 207  : 	DeleteArray();

	call	?DeleteArray@CvEconomicAIStrategyXMLEntries@@QAEXXZ ; CvEconomicAIStrategyXMLEntries::DeleteArray

; 208  : }

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN9@CvEconomic@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@CvEconomic@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::~vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
__ehhandler$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvEconomicAIStrategyXMLEntries@@QAE@XZ ENDP		; CvEconomicAIStrategyXMLEntries::~CvEconomicAIStrategyXMLEntries
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z
_TEXT	SEGMENT
__Mid$229610 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort:
	test	esi, esi
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$229610[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$229610[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$229610[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$229610[esp+36]
$LN26@Sort:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort
$LN25@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN10@Sort
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z
_TEXT	SEGMENT
$T243455 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T243456 = 40						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T243455[esp+8], bl
	mov	eax, DWORD PTR $T243455[esp+8]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR $T243456[esp+36], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+36]
	push	edx
	push	eax
	call	??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>

; 5254 : 	}

	mov	eax, DWORD PTR __Dest$[esp+44]
	add	esp, 40					; 00000028H
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>
_TEXT	ENDS
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z PROC ; std::sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ENDP ; std::sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_merge_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z
_TEXT	SEGMENT
$T243606 = -8						; size = 1
$T243577 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T243576 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z PROC ; std::_Buffered_merge_sort<CvPurchaseRequest *,int,CvPurchaseRequest>, COMDAT

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@2
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@2:

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;
; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	lea	esi, DWORD PTR [eax+384]

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	push	ebx
	push	esi
	push	eax
	call	??$_Insertion_sort1@PAVCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@00@Z ; std::_Insertion_sort1<CvPurchaseRequest *,CvPurchaseRequest>
	add	esp, 12					; 0000000cH
	sub	ebp, 1

; 3363 : 		_Mid = _Midend;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@2
$LN4@Buffered_m@2:

; 3364 : 		}
; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@PAVCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@00@Z ; std::_Insertion_sort1<CvPurchaseRequest *,CvPurchaseRequest>

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 12					; 0000000cH
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@2
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
$LL3@Buffered_m@2:

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+20]
	mov	BYTE PTR $T243576[esp+20], bl
	mov	eax, DWORD PTR $T243576[esp+20]
	push	eax
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	DWORD PTR $T243577[esp+56], esp
	push	ecx
	push	edx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	call	??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+60]
	mov	BYTE PTR $T243606[esp+64], bl
	mov	ecx, DWORD PTR $T243606[esp+64]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvPurchaseRequest@@PAV1@H@std@@YAXPAVCvPurchaseRequest@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvPurchaseRequest *,CvPurchaseRequest *,int>
	add	esi, esi
	add	esp, 64					; 00000040H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@2
$LN1@Buffered_m@2:

; 3373 : 		}
; 3374 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ENDP ; std::_Buffered_merge_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	?SortItems@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXXZ ; CvWeightedVector<CvUnit *,50,1>::SortItems
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?SortItems@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXXZ PROC ; CvWeightedVector<CvUnit *,50,1>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXXZ ENDP ; CvWeightedVector<CvUnit *,50,1>::SortItems
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z PROC ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	edi

; 3382 : 	if (_Count <= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp]
	cmp	edi, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@00@Z ; std::_Insertion_sort1<CvPurchaseRequest *,CvPurchaseRequest>
	add	esp, 12					; 0000000cH
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
$LN4@Stable_sor:
	push	ebx

; 3384 : 	else
; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [edi+1]
	cdq
	push	ebp

; 3387 : 		_BidIt _Mid = _First;
; 3388 : 		std::advance(_Mid, _Count2);
; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+8]
	sub	eax, edx
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR __First$[esp+12]
	sar	esi, 1
	lea	edx, DWORD PTR [esi+esi*2]
	mov	ecx, ebp
	lea	ebx, DWORD PTR [eax+edx*4]
	call	?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen
	cmp	esi, eax

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	push	ebp
	push	esi
	push	ebx
	jg	SHORT $LN2@Stable_sor
	mov	ecx, DWORD PTR __First$[esp+24]
	push	ecx
	call	??$_Buffered_merge_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_merge_sort<CvPurchaseRequest *,int,CvPurchaseRequest>

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	edx
	push	ebx
	call	??$_Buffered_merge_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_merge_sort<CvPurchaseRequest *,int,CvPurchaseRequest>

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN17@Stable_sor
$LN2@Stable_sor:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	eax, DWORD PTR __First$[esp+24]
	push	eax
	call	??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	ecx
	push	ebx
	call	??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
$LN17@Stable_sor:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	edx, DWORD PTR __Last$[esp+44]
	mov	eax, DWORD PTR __First$[esp+44]
	add	esp, 32					; 00000020H
	push	ebp
	push	edi
	push	esi
	push	edx
	push	ebx
	push	eax
	call	??$_Buffered_merge@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_merge<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 24					; 00000018H
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ENDP ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ	; CvEconomicAI::AssignExplorersToHuts
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ:PROC ; CvTwoLayerPathFinder::GetPathEndTurnPlot
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ$1
__ehfuncinfo$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
_uiExplorer$227616 = -460				; size = 4
_iUnitID$227614 = -460					; size = 4
_this$ = -456						; size = 4
_uiGoodyPlots$227608 = -452				; size = 4
_kPathFinder$ = -448					; size = 4
_iStepPlotID$227615 = -444				; size = 4
_tempExplorers$227646 = -440				; size = 12
_aBestUnitList$ = -428					; size = 416
__$EHRec$ = -12						; size = 12
?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ PROC	; CvEconomicAI::AssignExplorersToHuts, COMDAT
; _this$ = ecx

; 2519 : {

	push	-1
	push	__ehhandler$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 448				; 000001c0H
	push	ebx
	push	edi
	mov	ebx, ecx

; 2520 : #if defined(PATH_PLAN_LAST)
; 2521 : 	WeightedUnitVector aBestUnitList;

	xor	edi, edi
	lea	eax, DWORD PTR _aBestUnitList$[esp+480]
	mov	DWORD PTR _this$[esp+468], ebx
	mov	DWORD PTR _aBestUnitList$[esp+472], edi
	mov	DWORD PTR _aBestUnitList$[esp+476], 50	; 00000032H
	mov	DWORD PTR _aBestUnitList$[esp+468], eax

; 2522 : 	aBestUnitList.reserve(m_apExplorers.size());

	mov	eax, DWORD PTR [ebx+292]
	push	eax
	lea	ecx, DWORD PTR _aBestUnitList$[esp+472]
	mov	DWORD PTR __$EHRec$[esp+480], edi
	call	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSizeToFit

; 2523 : #endif
; 2524 : 
; 2525 : 	CvTwoLayerPathFinder& kPathFinder = GC.getPathFinder();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	DWORD PTR _kPathFinder$[esp+468], eax

; 2526 : 	for(uint uiGoodyPlots = 0; uiGoodyPlots < m_aiGoodyHutPlots.size(); uiGoodyPlots++)

	mov	eax, DWORD PTR [ebx+92]
	xor	ecx, ecx
	mov	DWORD PTR _uiGoodyPlots$227608[esp+468], ecx
	cmp	eax, edi
	jbe	$LN227@AssignExpl
	push	ebp
	push	esi
	jmp	SHORT $LN18@AssignExpl
$LL235@AssignExpl:
	xor	edi, edi
$LN18@AssignExpl:

; 2527 : 	{
; 2528 : 		if(m_aiGoodyHutPlots[uiGoodyPlots] == -1)

	mov	edx, DWORD PTR [ebx+88]
	mov	ebp, DWORD PTR [edx+ecx*4]
	cmp	ebp, -1
	je	$LN17@AssignExpl

; 2529 : 		{
; 2530 : 			continue;
; 2531 : 		}
; 2532 : 
; 2533 : 		CvPlot* pGoodyPlot = GC.getMap().plotByIndex(m_aiGoodyHutPlots[uiGoodyPlots]);

	cmp	ebp, edi
	jl	SHORT $LN50@AssignExpl
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	ebp, DWORD PTR [eax+4028]
	jge	SHORT $LN50@AssignExpl
	imul	ebp, 484				; 000001e4H
	add	ebp, DWORD PTR [eax+4068]
	jmp	SHORT $LN51@AssignExpl
$LN50@AssignExpl:
	xor	ebp, ebp
$LN51@AssignExpl:

; 2534 : #if !defined(PATH_PLAN_LAST)
; 2535 : 		int iClosestEstimateTurns = MAX_INT;
; 2536 : #endif
; 2537 : 		int iUnitID = NO_UNIT;
; 2538 : 		int iStepPlotID = -1;

	mov	DWORD PTR _iStepPlotID$227615[esp+476], -1

; 2539 : 
; 2540 : 		aBestUnitList.clear();

	mov	DWORD PTR _aBestUnitList$[esp+480], edi

; 2541 : 
; 2542 : 		for(uint uiExplorer = 0; uiExplorer < m_apExplorers.size(); uiExplorer++)

	mov	DWORD PTR _uiExplorer$227616[esp+476], edi
	cmp	DWORD PTR [ebx+292], edi
	jbe	$LN230@AssignExpl
$LL234@AssignExpl:

; 2543 : 		{
; 2544 : 			CvUnit* pUnit = m_apExplorers[uiExplorer];
; 2545 : 
; 2546 : 			int iDistance = plotDistance(pUnit->getX(), pUnit->getY(), pGoodyPlot->getX(), pGoodyPlot->getY());

	movsx	edx, WORD PTR [ebp+2]
	mov	eax, DWORD PTR [ebx+288]
	mov	ecx, DWORD PTR _uiExplorer$227616[esp+476]
	mov	esi, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	edx
	movsx	edx, WORD PTR [ebp]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 2547 : 
; 2548 : #if defined(PATH_PLAN_LAST)
; 2549 : 			if(pUnit->maxMoves() >= 1)

	mov	ecx, esi
	mov	edi, eax
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	cmp	eax, 1
	jl	SHORT $LN13@AssignExpl

; 2550 : 			{
; 2551 : 				int iEstimateTurns = iDistance / (pUnit->maxMoves() / GC.getMOVE_DENOMINATOR());

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	ecx, esi
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	cdq
	idiv	ebx

; 2552 : 				aBestUnitList.push_back(pUnit, iEstimateTurns);

	mov	BYTE PTR _aBestUnitList$[esp+888], 0
	mov	ecx, eax
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, eax
	mov	eax, DWORD PTR _aBestUnitList$[esp+484]
	cmp	DWORD PTR _aBestUnitList$[esp+480], eax
	jne	SHORT $LN86@AssignExpl
	push	eax
	lea	ecx, DWORD PTR _aBestUnitList$[esp+480]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSize
$LN86@AssignExpl:
	mov	edx, DWORD PTR _aBestUnitList$[esp+480]
	mov	eax, DWORD PTR _aBestUnitList$[esp+476]
	lea	eax, DWORD PTR [eax+edx*8]
	test	eax, eax
	je	SHORT $LN89@AssignExpl
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
$LN89@AssignExpl:
	inc	DWORD PTR _aBestUnitList$[esp+480]
	mov	ebx, DWORD PTR _this$[esp+476]
$LN13@AssignExpl:
	mov	eax, DWORD PTR _uiExplorer$227616[esp+476]
	inc	eax
	mov	DWORD PTR _uiExplorer$227616[esp+476], eax
	cmp	eax, DWORD PTR [ebx+292]
	jb	$LL234@AssignExpl

; 2541 : 
; 2542 : 		for(uint uiExplorer = 0; uiExplorer < m_apExplorers.size(); uiExplorer++)

	mov	edi, DWORD PTR _aBestUnitList$[esp+480]
$LN230@AssignExpl:

; 2553 : 			}
; 2554 : #else
; 2555 : 			int iEstimateTurns = MAX_INT;
; 2556 : 			if(pUnit->maxMoves() >= 1)
; 2557 : 			{
; 2558 : 				iEstimateTurns = iDistance / (pUnit->maxMoves() / GC.getMOVE_DENOMINATOR());
; 2559 : 			}
; 2560 : 
; 2561 : 			if(iEstimateTurns < iClosestEstimateTurns)
; 2562 : 			{
; 2563 : 				// Now check path
; 2564 : 				bool bCanFindPath = kPathFinder.GenerateUnitPath(pUnit, pUnit->getX(), pUnit->getY(), pGoodyPlot->getX(), pGoodyPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);
; 2565 : 				if(bCanFindPath)
; 2566 : 				{
; 2567 : 					iClosestEstimateTurns = iEstimateTurns;
; 2568 : 					iUnitID = pUnit->GetID();
; 2569 : 					CvPlot* pPlot = kPathFinder.GetPathEndTurnPlot();
; 2570 : 					if(pPlot)
; 2571 : 						iStepPlotID = pPlot->GetPlotIndex();
; 2572 : 				}
; 2573 : 			}
; 2574 : #endif
; 2575 : 		}
; 2576 : 
; 2577 : #if defined(PATH_PLAN_LAST)
; 2578 : 		uint uiListSize;
; 2579 : 		if ((uiListSize = aBestUnitList.size()) > 0)

	test	edi, edi
	jbe	$LN17@AssignExpl

; 2580 : 		{
; 2581 : 			aBestUnitList.SortItems();			// highest score will be first.

	mov	ecx, DWORD PTR _aBestUnitList$[esp+476]
	lea	eax, DWORD PTR [ecx+edi*8]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH
$LL9@AssignExpl:

; 2583 : 			{
; 2584 : 				CvUnit* pUnit = aBestUnitList.GetElement(i);

	mov	eax, DWORD PTR _aBestUnitList$[esp+476]
	mov	esi, DWORD PTR [eax+edi*8-8]

; 2585 : 				bool bCanFindPath = kPathFinder.GenerateUnitPath(pUnit, pUnit->getX(), pUnit->getY(), pGoodyPlot->getX(), pGoodyPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	mov	edx, DWORD PTR [esi+88]
	mov	ebx, DWORD PTR [esi+76]
	push	1
	dec	edi
	push	138					; 0000008aH
	push	eax
	push	ecx
	push	edx
	push	ebx
	mov	ebx, DWORD PTR _kPathFinder$[esp+500]
	push	esi
	mov	ecx, ebx
	call	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath

; 2586 : 				if(bCanFindPath)

	test	al, al
	jne	SHORT $LN217@AssignExpl

; 2582 : 			for (uint i = uiListSize; i--; )	// Go backward, we want the lowest score (distance)

	test	edi, edi
	jne	SHORT $LL9@AssignExpl

; 2586 : 				if(bCanFindPath)

	jmp	$LN226@AssignExpl
$LN217@AssignExpl:

; 2587 : 				{
; 2588 : 					iUnitID = pUnit->GetID();

	mov	esi, DWORD PTR [esi+100]

; 2589 : 					// Since we've gone through the trouble of calculating a path, save where our turn will end so the Homeland AI doesn't need to re-do the path.
; 2590 : 					CvPlot* pPlot = kPathFinder.GetPathEndTurnPlot();

	mov	ecx, ebx
	mov	DWORD PTR _iUnitID$227614[esp+476], esi
	call	?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ ; CvTwoLayerPathFinder::GetPathEndTurnPlot

; 2591 : 					if(pPlot)

	test	eax, eax
	je	SHORT $LN228@AssignExpl

; 2592 : 						iStepPlotID = pPlot->GetPlotIndex();

	mov	ecx, eax
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	jmp	SHORT $LN6@AssignExpl
$LN228@AssignExpl:
	mov	eax, DWORD PTR _iStepPlotID$227615[esp+476]
$LN6@AssignExpl:

; 2593 : 					break;
; 2594 : 				}
; 2595 : 			}
; 2596 : 		}
; 2597 : #endif
; 2598 : 
; 2599 : 		if(iUnitID != NO_UNIT)

	cmp	esi, -1
	je	$LN226@AssignExpl

; 2600 : 		{
; 2601 : 			m_aiGoodyHutUnitAssignments[uiGoodyPlots] = GoodyHutUnitAssignment(iUnitID, iStepPlotID);

	mov	edi, DWORD PTR _this$[esp+476]
	mov	ecx, DWORD PTR [edi+100]
	mov	edx, DWORD PTR _uiGoodyPlots$227608[esp+476]
	mov	DWORD PTR [ecx+edx*8], esi

; 2602 : 
; 2603 : 			FFastVector<CvUnit*> tempExplorers = m_apExplorers;

	add	edi, 288				; 00000120H
	mov	DWORD PTR [ecx+edx*8+4], eax
	mov	eax, DWORD PTR [edi+8]
	xor	esi, esi
	mov	DWORD PTR _tempExplorers$227646[esp+476], esi
	mov	DWORD PTR _tempExplorers$227646[esp+484], eax
	test	eax, eax
	je	SHORT $LN229@AssignExpl
	mov	ebx, eax
	test	ebx, ebx
	jbe	SHORT $LN137@AssignExpl
	push	85					; 00000055H
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	ecx, DWORD PTR [ebx*4]
	push	4
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tempExplorers$227646[esp+484], ebx
	jmp	SHORT $LN138@AssignExpl
$LN137@AssignExpl:
	xor	eax, eax
$LN138@AssignExpl:
	mov	esi, eax
	mov	DWORD PTR _tempExplorers$227646[esp+476], esi
$LN229@AssignExpl:
	mov	ebp, DWORD PTR [edi+4]
	xor	ebx, ebx
	xor	eax, eax
	mov	DWORD PTR _tempExplorers$227646[esp+480], ebp
	cmp	ebp, ebx
	jbe	SHORT $LN142@AssignExpl
	mov	ecx, esi
	npad	5
$LL144@AssignExpl:
	cmp	ecx, ebx
	je	SHORT $LN143@AssignExpl
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], edx
$LN143@AssignExpl:
	inc	eax
	add	ecx, 4
	cmp	eax, ebp
	jb	SHORT $LL144@AssignExpl
$LN142@AssignExpl:
	mov	BYTE PTR __$EHRec$[esp+484], 1

; 2604 : 			m_apExplorers.clear();

	mov	DWORD PTR [edi+4], ebx

; 2605 : 			for(uint uiExplorer = 0; uiExplorer < tempExplorers.size(); uiExplorer++)

	cmp	ebp, ebx
	jbe	SHORT $LN2@AssignExpl
$LL4@AssignExpl:

; 2606 : 			{
; 2607 : 				if(tempExplorers[uiExplorer]->GetID() != iUnitID)

	mov	eax, DWORD PTR [esi+ebx*4]
	mov	ecx, DWORD PTR _iUnitID$227614[esp+476]
	cmp	DWORD PTR [eax+100], ecx
	je	SHORT $LN3@AssignExpl

; 2608 : 				{
; 2609 : 					m_apExplorers.push_back(tempExplorers[uiExplorer]);

	mov	eax, DWORD PTR [edi+8]
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN171@AssignExpl
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXI@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::GrowSize
$LN171@AssignExpl:
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	je	SHORT $LN174@AssignExpl
	mov	ecx, DWORD PTR [esi+ebx*4]
	mov	DWORD PTR [eax], ecx
$LN174@AssignExpl:
	inc	DWORD PTR [edi+4]
$LN3@AssignExpl:

; 2605 : 			for(uint uiExplorer = 0; uiExplorer < tempExplorers.size(); uiExplorer++)

	inc	ebx
	cmp	ebx, ebp
	jb	SHORT $LL4@AssignExpl
$LN2@AssignExpl:

; 2610 : 				}
; 2611 : 			}
; 2612 : 		}

	push	esi
	mov	BYTE PTR __$EHRec$[esp+488], 0
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN226@AssignExpl:
	mov	ebx, DWORD PTR _this$[esp+476]
$LN17@AssignExpl:

; 2526 : 	for(uint uiGoodyPlots = 0; uiGoodyPlots < m_aiGoodyHutPlots.size(); uiGoodyPlots++)

	mov	ecx, DWORD PTR _uiGoodyPlots$227608[esp+476]
	inc	ecx
	mov	DWORD PTR _uiGoodyPlots$227608[esp+476], ecx
	cmp	ecx, DWORD PTR [ebx+92]
	jb	$LL235@AssignExpl
	pop	esi
	pop	ebp
$LN227@AssignExpl:

; 2613 : 	}
; 2614 : }

	mov	eax, DWORD PTR _aBestUnitList$[esp+468]
	lea	edx, DWORD PTR _aBestUnitList$[esp+480]
	pop	edi
	mov	DWORD PTR __$EHRec$[esp+472], -1
	pop	ebx
	cmp	eax, edx
	je	SHORT $LN198@AssignExpl
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN198@AssignExpl:
	mov	ecx, DWORD PTR __$EHRec$[esp+460]
	mov	DWORD PTR fs:0, ecx
	add	esp, 460				; 000001ccH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _aBestUnitList$[ebp]
	jmp	??1?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ ; CvWeightedVector<CvUnit *,50,1>::~CvWeightedVector<CvUnit *,50,1>
__unwindfunclet$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _tempExplorers$227646[ebp]
	jmp	??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
__ehhandler$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ ENDP	; CvEconomicAI::AssignExplorersToHuts
PUBLIC	??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z PROC ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3411 : 	_Diff _Count = 0;
; 3412 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	mov	edx, eax
	push	edx
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	call	??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>

; 3415 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+60]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN20@Stable_sor@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@Stable_sor@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ ; std::_Temp_iterator<CvPurchaseRequest>::~_Temp_iterator<CvPurchaseRequest>
__ehhandler$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z ENDP ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
PUBLIC	?UpdatePlots@CvEconomicAI@@QAEXXZ		; CvEconomicAI::UpdatePlots
EXTRN	?GetMissionAIType@CvUnit@@QAE?AW4MissionAITypes@@XZ:PROC ; CvUnit::GetMissionAIType
EXTRN	?IsAutomated@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsAutomated
EXTRN	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlot::getNumDefenders
EXTRN	?HasBarbarianCamp@CvPlot@@QAE_NXZ:PROC		; CvPlot::HasBarbarianCamp
EXTRN	?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isRevealedGoody
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
;	COMDAT ?UpdatePlots@CvEconomicAI@@QAEXXZ
_TEXT	SEGMENT
_i$227353 = -32						; size = 4
_uiGoodyHutPlotIndex$ = -28				; size = 4
$T244292 = -24						; size = 4
_uiExplorationPlotIndex$ = -20				; size = 4
tv1286 = -16						; size = 4
_iLoopCity$ = -12					; size = 4
_pPlot$ = -8						; size = 4
_iLoopUnit$ = -4					; size = 4
?UpdatePlots@CvEconomicAI@@QAEXXZ PROC			; CvEconomicAI::UpdatePlots, COMDAT
; _this$ = ecx

; 2364 : {

	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2365 : 	// reset all plots
; 2366 : 	for(uint ui = 0; ui < m_aiExplorationPlots.size(); ui++)

	xor	ebx, ebx
	xor	eax, eax
	push	edi
	cmp	DWORD PTR [esi+68], ebx
	jbe	SHORT $LN30@UpdatePlot
$LL32@UpdatePlot:

; 2367 : 	{
; 2368 : 		m_aiExplorationPlots[ui] = -1;

	mov	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR [ecx+eax*4], -1

; 2369 : 		m_aiExplorationPlotRatings[ui] = -1;

	mov	edx, DWORD PTR [esi+76]
	mov	DWORD PTR [edx+eax*4], -1
	inc	eax
	cmp	eax, DWORD PTR [esi+68]
	jb	SHORT $LL32@UpdatePlot
$LN30@UpdatePlot:

; 2370 : 	}
; 2371 : 
; 2372 : 	for(uint ui = 0; ui < m_aiGoodyHutPlots.size(); ui++)

	xor	eax, eax
	cmp	DWORD PTR [esi+92], ebx
	jbe	SHORT $LN27@UpdatePlot
$LL29@UpdatePlot:

; 2373 : 	{
; 2374 : 		m_aiGoodyHutPlots[ui] = -1;

	mov	ecx, DWORD PTR [esi+88]
	mov	DWORD PTR [ecx+eax*4], -1
	mov	edx, DWORD PTR [esi+100]
	lea	ecx, DWORD PTR [edx+eax*8]
	inc	eax

; 2375 : 		m_aiGoodyHutUnitAssignments[ui].Clear();

	mov	DWORD PTR [ecx], -1
	mov	DWORD PTR [ecx+4], -1
	cmp	eax, DWORD PTR [esi+92]
	jb	SHORT $LL29@UpdatePlot
$LN27@UpdatePlot:

; 2376 : 	}
; 2377 : 
; 2378 : 	// find the center of all the cities
; 2379 : 	int iTotalX = 0;
; 2380 : 	int iTotalY = 0;
; 2381 : 	int iCityCount = 0;
; 2382 : 	int iLoopCity = 0;
; 2383 : 	CvCity* pLoopCity = NULL;
; 2384 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	lea	eax, DWORD PTR _iLoopCity$[esp+52]
	push	eax
	mov	DWORD PTR _iLoopCity$[esp+56], ebx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN24@UpdatePlot
	npad	4
$LL26@UpdatePlot:
	push	ebx
	lea	ecx, DWORD PTR _iLoopCity$[esp+52]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL26@UpdatePlot
$LN24@UpdatePlot:

; 2385 : 	{
; 2386 : 		iTotalX += pLoopCity->getX();
; 2387 : 		iTotalY += pLoopCity->getY();
; 2388 : 		iCityCount++;
; 2389 : 	}
; 2390 : 
; 2391 : 	int iCivCenterX = -1;
; 2392 : 	int iCivCenterY = -1;
; 2393 : 	if(iCityCount > 0)
; 2394 : 	{
; 2395 : 		iCivCenterX = iTotalX / iCityCount;
; 2396 : 		iCivCenterY = iTotalY / iCityCount;
; 2397 : 	}
; 2398 : 
; 2399 : 	uint uiExplorationPlotIndex = 0;
; 2400 : 	uint uiGoodyHutPlotIndex = 0;
; 2401 : 	TeamTypes ePlayerTeam = m_pPlayer->getTeam();

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _uiExplorationPlotIndex$[esp+48], ebx
	mov	DWORD PTR _uiGoodyHutPlotIndex$[esp+48], ebx
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN61@UpdatePlot
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T244292[esp+48], eax
	jmp	SHORT $LN62@UpdatePlot
$LN61@UpdatePlot:
	mov	DWORD PTR $T244292[esp+48], -1
$LN62@UpdatePlot:

; 2402 : 
; 2403 : 	CvPlot* pPlot;
; 2404 : #ifdef AUI_WARNING_FIXES
; 2405 : 	for (uint i = 0; i < GC.getMap().numPlots(); i++)
; 2406 : #else
; 2407 : 	for(int i = 0; i < GC.getMap().numPlots(); i++)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	DWORD PTR [ecx+4028], ebx
	mov	DWORD PTR _i$227353[esp+48], ebx
	jle	$LN20@UpdatePlot
	mov	DWORD PTR tv1286[esp+48], ebx
	npad	7
$LL22@UpdatePlot:

; 2408 : #endif
; 2409 : 	{
; 2410 : 		pPlot = GC.getMap().plotByIndexUnchecked(i);

	mov	edi, DWORD PTR [ecx+4068]
	add	edi, DWORD PTR tv1286[esp+48]
	mov	DWORD PTR _pPlot$[esp+48], edi

; 2411 : 		if(pPlot == NULL)

	je	$LN21@UpdatePlot

; 2412 : 		{
; 2413 : 			continue;
; 2414 : 		}
; 2415 : 
; 2416 : 		if(!pPlot->isRevealed(ePlayerTeam))

	mov	ebp, DWORD PTR $T244292[esp+48]
	mov	eax, ebp
	shr	eax, 5
	mov	ecx, eax
	shl	ecx, 5
	mov	edx, ecx
	mov	ecx, ebp
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	test	edx, DWORD PTR [edi+eax*4+8]
	je	$LN21@UpdatePlot

; 2417 : 		{
; 2418 : 			continue;
; 2419 : 		}
; 2420 : 
; 2421 : 		if(pPlot->isRevealedGoody(ePlayerTeam) && !pPlot->isVisibleEnemyUnit(m_pPlayer->GetID()))

	push	ebp
	mov	ecx, edi
	call	?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isRevealedGoody
	test	al, al
	je	$LN17@UpdatePlot
	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, edi
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleEnemyUnit
	test	al, al
	jne	$LN17@UpdatePlot

; 2422 : 		{
; 2423 : 			if(m_aiGoodyHutPlots.size() <= uiGoodyHutPlotIndex)

	cmp	DWORD PTR [esi+92], ebx
	ja	SHORT $LN94@UpdatePlot

; 2424 : 			{
; 2425 : 				m_aiGoodyHutPlots.push_back(-1);

	mov	eax, DWORD PTR [esi+96]
	cmp	DWORD PTR [esi+92], eax
	lea	edi, DWORD PTR [esi+88]
	jne	SHORT $LN84@UpdatePlot
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN84@UpdatePlot:
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [edx+ecx*4]
	test	eax, eax
	je	SHORT $LN188@UpdatePlot
	mov	DWORD PTR [eax], -1
$LN188@UpdatePlot:
	inc	DWORD PTR [edi+4]

; 2426 : 				m_aiGoodyHutUnitAssignments.push_back(GoodyHutUnitAssignment(-1, -1));

	mov	eax, DWORD PTR [esi+108]
	lea	edi, DWORD PTR [esi+100]
	or	ebx, -1
	or	ebp, ebx
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN93@UpdatePlot
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXI@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::GrowSize
$LN93@UpdatePlot:
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN96@UpdatePlot
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebp
$LN96@UpdatePlot:
	inc	DWORD PTR [edi+4]
	mov	ebx, DWORD PTR _uiGoodyHutPlotIndex$[esp+48]
	mov	edi, DWORD PTR _pPlot$[esp+48]
$LN94@UpdatePlot:

; 2427 : 			}
; 2428 : 			m_aiGoodyHutPlots[uiGoodyHutPlotIndex] = i;

	mov	edx, DWORD PTR [esi+88]
	mov	eax, DWORD PTR _i$227353[esp+48]

; 2429 : 			m_aiGoodyHutUnitAssignments[uiGoodyHutPlotIndex].Clear();
; 2430 : 			++uiGoodyHutPlotIndex;

	mov	ebp, DWORD PTR $T244292[esp+48]
	mov	DWORD PTR [edx+ebx*4], eax
	mov	ecx, DWORD PTR [esi+100]
	lea	eax, DWORD PTR [ecx+ebx*8]
	inc	ebx
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1
	mov	DWORD PTR _uiGoodyHutPlotIndex$[esp+48], ebx
$LN17@UpdatePlot:

; 2431 : 		}
; 2432 : 		if(pPlot->HasBarbarianCamp())

	mov	ecx, edi
	call	?HasBarbarianCamp@CvPlot@@QAE_NXZ	; CvPlot::HasBarbarianCamp
	test	al, al
	je	$LN190@UpdatePlot

; 2433 : 		{
; 2434 : 			if(pPlot->getNumDefenders(BARBARIAN_PLAYER) == 0)

	push	63					; 0000003fH
	mov	ecx, edi
	call	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumDefenders
	test	eax, eax
	jne	$LN190@UpdatePlot

; 2435 : 			{
; 2436 : 				if(m_aiGoodyHutPlots.size() <= uiGoodyHutPlotIndex)

	cmp	DWORD PTR [esi+92], ebx
	ja	SHORT $LN118@UpdatePlot

; 2437 : 				{
; 2438 : 					m_aiGoodyHutPlots.push_back(-1);

	mov	eax, DWORD PTR [esi+96]
	cmp	DWORD PTR [esi+92], eax
	lea	edi, DWORD PTR [esi+88]
	jne	SHORT $LN108@UpdatePlot
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN108@UpdatePlot:
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	je	SHORT $LN189@UpdatePlot
	mov	DWORD PTR [eax], -1
$LN189@UpdatePlot:
	inc	DWORD PTR [edi+4]

; 2439 : 					m_aiGoodyHutUnitAssignments.push_back(GoodyHutUnitAssignment(-1, -1));

	mov	eax, DWORD PTR [esi+108]
	lea	edi, DWORD PTR [esi+100]
	or	ebp, -1
	or	ebx, ebp
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN117@UpdatePlot
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXI@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::GrowSize
$LN117@UpdatePlot:
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN120@UpdatePlot
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebx
$LN120@UpdatePlot:
	inc	DWORD PTR [edi+4]
	mov	ebx, DWORD PTR _uiGoodyHutPlotIndex$[esp+48]
	mov	edi, DWORD PTR _pPlot$[esp+48]
$LN118@UpdatePlot:

; 2440 : 				}
; 2441 : 				m_aiGoodyHutPlots[uiGoodyHutPlotIndex] = i;

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR _i$227353[esp+48]

; 2442 : 				m_aiGoodyHutUnitAssignments[uiGoodyHutPlotIndex].Clear();
; 2443 : 				++uiGoodyHutPlotIndex;

	mov	ebp, DWORD PTR $T244292[esp+48]
	mov	DWORD PTR [eax+ebx*4], ecx
	mov	edx, DWORD PTR [esi+100]
	lea	eax, DWORD PTR [edx+ebx*8]
	inc	ebx
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], -1
	mov	DWORD PTR _uiGoodyHutPlotIndex$[esp+48], ebx
$LN190@UpdatePlot:

; 2444 : 			}
; 2445 : 		}
; 2446 : 
; 2447 : 		DomainTypes eDomain = DOMAIN_LAND;
; 2448 : 		if(pPlot->isWater())

	cmp	BYTE PTR [edi+5], 3
	mov	eax, 2
	jne	SHORT $LN185@UpdatePlot

; 2449 : 		{
; 2450 : 			eDomain = DOMAIN_SEA;

	xor	eax, eax
$LN185@UpdatePlot:

; 2451 : 		}
; 2452 : 
; 2453 : 		int iScore = ScoreExplorePlot(pPlot, ePlayerTeam, 1, eDomain);

	push	eax
	push	1
	push	ebp
	push	edi
	call	?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z ; CvEconomicAI::ScoreExplorePlot
	mov	ebp, eax
	add	esp, 16					; 00000010H

; 2454 : 		if(iScore <= 0)

	test	ebp, ebp
	jle	SHORT $LN21@UpdatePlot

; 2455 : 		{
; 2456 : 			continue;
; 2457 : 		}
; 2458 : 
; 2459 : 		// add an entry for this plot
; 2460 : 		if(m_aiExplorationPlots.size() <= uiExplorationPlotIndex)

	mov	eax, DWORD PTR _uiExplorationPlotIndex$[esp+48]
	cmp	DWORD PTR [esi+68], eax
	ja	SHORT $LN187@UpdatePlot

; 2461 : 		{
; 2462 : 			m_aiExplorationPlots.push_back(-1);

	mov	eax, DWORD PTR [esi+72]
	cmp	DWORD PTR [esi+68], eax
	lea	edi, DWORD PTR [esi+64]
	jne	SHORT $LN134@UpdatePlot
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN134@UpdatePlot:
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN186@UpdatePlot
	mov	DWORD PTR [eax], -1
$LN186@UpdatePlot:
	inc	DWORD PTR [edi+4]

; 2463 : 			m_aiExplorationPlotRatings.push_back(-1);

	mov	eax, DWORD PTR [esi+84]
	cmp	DWORD PTR [esi+80], eax
	lea	edi, DWORD PTR [esi+76]
	jne	SHORT $LN141@UpdatePlot
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN141@UpdatePlot:
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+edx*4]
	test	eax, eax
	je	SHORT $LN144@UpdatePlot
	mov	DWORD PTR [eax], -1
$LN144@UpdatePlot:
	inc	DWORD PTR [edi+4]
	mov	eax, DWORD PTR _uiExplorationPlotIndex$[esp+48]
$LN187@UpdatePlot:

; 2464 : 		}
; 2465 : 
; 2466 : 		m_aiExplorationPlots[uiExplorationPlotIndex] = i;

	mov	ecx, DWORD PTR [esi+64]
	mov	edx, DWORD PTR _i$227353[esp+48]
	mov	DWORD PTR [ecx+eax*4], edx

; 2467 : 		m_aiExplorationPlotRatings[uiExplorationPlotIndex] = iScore;

	mov	ecx, DWORD PTR [esi+76]
	mov	DWORD PTR [ecx+eax*4], ebp

; 2468 : 		uiExplorationPlotIndex++;

	inc	eax
	mov	DWORD PTR _uiExplorationPlotIndex$[esp+48], eax
$LN21@UpdatePlot:
	mov	eax, DWORD PTR _i$227353[esp+48]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	DWORD PTR tv1286[esp+48], 484		; 000001e4H
	inc	eax
	cmp	eax, DWORD PTR [ecx+4028]
	mov	DWORD PTR _i$227353[esp+48], eax
	jl	$LL22@UpdatePlot

; 2402 : 
; 2403 : 	CvPlot* pPlot;
; 2404 : #ifdef AUI_WARNING_FIXES
; 2405 : 	for (uint i = 0; i < GC.getMap().numPlots(); i++)
; 2406 : #else
; 2407 : 	for(int i = 0; i < GC.getMap().numPlots(); i++)

	xor	ebx, ebx
$LN20@UpdatePlot:

; 2469 : 	}
; 2470 : 
; 2471 : 	// assign explorers to goody huts
; 2472 : 
; 2473 : 	// build explorer list
; 2474 : 	CvUnit* pLoopUnit;
; 2475 : 	int iLoopUnit;
; 2476 : 	m_apExplorers.clear();

	lea	ebp, DWORD PTR [esi+288]

; 2477 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	push	ebx
	lea	edx, DWORD PTR _iLoopUnit$[esp+52]
	mov	DWORD PTR [ebp+4], ebx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	edi, eax
	test	edi, edi
	je	$LN7@UpdatePlot
$LL9@UpdatePlot:

; 2478 : 	{
; 2479 : 		// non-automated human-controlled units should not be considered
; 2480 : 		if(m_pPlayer->isHuman() && !pLoopUnit->IsAutomated())

	mov	ecx, DWORD PTR [esi+4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN6@UpdatePlot
	mov	ecx, edi
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	test	al, al
	je	SHORT $LN8@UpdatePlot
$LN6@UpdatePlot:

; 2481 : 		{
; 2482 : 			continue;
; 2483 : 		}
; 2484 : 
; 2485 : 		if(pLoopUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	je	SHORT $LN8@UpdatePlot

; 2486 : 		{
; 2487 : 			continue;
; 2488 : 		}
; 2489 : 
; 2490 : 		if(pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE && pLoopUnit->GetMissionAIType() != MISSIONAI_EXPLORE)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN4@UpdatePlot
	mov	ecx, edi
	call	?GetMissionAIType@CvUnit@@QAE?AW4MissionAITypes@@XZ ; CvUnit::GetMissionAIType
	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN8@UpdatePlot
$LN4@UpdatePlot:

; 2491 : 		{
; 2492 : 			continue;
; 2493 : 		}
; 2494 : 
; 2495 : 		if(pLoopUnit->getArmyID() != FFreeList::INVALID_INDEX)

	mov	ecx, edi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	SHORT $LN8@UpdatePlot

; 2496 : 		{
; 2497 : 			continue;
; 2498 : 		}
; 2499 : 
; 2500 : 		m_apExplorers.push_back(pLoopUnit);

	mov	eax, DWORD PTR [ebp+8]
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN160@UpdatePlot
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXI@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::GrowSize
$LN160@UpdatePlot:
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN163@UpdatePlot
	mov	DWORD PTR [eax], edi
$LN163@UpdatePlot:
	inc	DWORD PTR [ebp+4]
$LN8@UpdatePlot:

; 2477 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	mov	ecx, DWORD PTR [esi+4]
	push	0
	lea	edx, DWORD PTR _iLoopUnit$[esp+52]
	push	edx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL9@UpdatePlot
$LN7@UpdatePlot:

; 2501 : 	}
; 2502 : 
; 2503 : 	if(m_apExplorers.size() >= m_aiGoodyHutPlots.size())

	mov	eax, DWORD PTR [esi+292]

; 2504 : 	{
; 2505 : 		AssignExplorersToHuts();

	mov	ecx, esi
	cmp	eax, DWORD PTR [esi+92]
	jb	SHORT $LN2@UpdatePlot
	call	?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ ; CvEconomicAI::AssignExplorersToHuts
	pop	edi

; 2510 : 	}
; 2511 : 
; 2512 : 	m_bExplorationPlotsDirty = false;

	mov	BYTE PTR [esi], 0
	pop	esi
	pop	ebp
	pop	ebx

; 2513 : }

	add	esp, 32					; 00000020H
	ret	0
$LN2@UpdatePlot:

; 2506 : 	}
; 2507 : 	else
; 2508 : 	{
; 2509 : 		AssignHutsToExplorers();

	call	?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ ; CvEconomicAI::AssignHutsToExplorers
	pop	edi

; 2510 : 	}
; 2511 : 
; 2512 : 	m_bExplorationPlotsDirty = false;

	mov	BYTE PTR [esi], 0
	pop	esi
	pop	ebp
	pop	ebx

; 2513 : }

	add	esp, 32					; 00000020H
	ret	0
?UpdatePlots@CvEconomicAI@@QAEXXZ ENDP			; CvEconomicAI::UpdatePlots
_TEXT	ENDS
PUBLIC	??$stable_sort@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@0@Z ; std::stable_sort<CvPurchaseRequest *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$stable_sort@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$stable_sort@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@0@Z PROC ; std::stable_sort<CvPurchaseRequest *>, COMDAT

; 3420 : 	_DEBUG_RANGE(_First, _Last);
; 3421 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor

; 3422 : 		{
; 3423 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 16					; 00000010H
$LN1@stable_sor:

; 3424 : 		}
; 3425 : 	}

	ret	0
??$stable_sort@PAVCvPurchaseRequest@@@std@@YAXPAVCvPurchaseRequest@@0@Z ENDP ; std::stable_sort<CvPurchaseRequest *>
_TEXT	ENDS
PUBLIC	?GetExplorationPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ; CvEconomicAI::GetExplorationPlots
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
;	COMDAT ?GetExplorationPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ
_TEXT	SEGMENT
?GetExplorationPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ PROC ; CvEconomicAI::GetExplorationPlots, COMDAT
; _this$ = ecx

; 911  : {

	push	esi
	mov	esi, ecx

; 912  : 	if(m_bExplorationPlotsDirty)

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN4@GetExplora

; 913  : 	{
; 914  : 		UpdatePlots();

	call	?UpdatePlots@CvEconomicAI@@QAEXXZ	; CvEconomicAI::UpdatePlots
$LN4@GetExplora:

; 915  : 	}
; 916  : 
; 917  : 	return m_aiExplorationPlots;

	lea	eax, DWORD PTR [esi+64]
	pop	esi

; 918  : }

	ret	0
?GetExplorationPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ENDP ; CvEconomicAI::GetExplorationPlots
_TEXT	ENDS
PUBLIC	?GetExplorationPlotRatings@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ; CvEconomicAI::GetExplorationPlotRatings
; Function compile flags: /Ogtpy
;	COMDAT ?GetExplorationPlotRatings@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ
_TEXT	SEGMENT
?GetExplorationPlotRatings@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ PROC ; CvEconomicAI::GetExplorationPlotRatings, COMDAT
; _this$ = ecx

; 921  : {

	push	esi
	mov	esi, ecx

; 922  : 	if(m_bExplorationPlotsDirty)

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN4@GetExplora@2

; 923  : 	{
; 924  : 		UpdatePlots();

	call	?UpdatePlots@CvEconomicAI@@QAEXXZ	; CvEconomicAI::UpdatePlots
$LN4@GetExplora@2:

; 925  : 	}
; 926  : 
; 927  : 	return m_aiExplorationPlotRatings;

	lea	eax, DWORD PTR [esi+76]
	pop	esi

; 928  : }

	ret	0
?GetExplorationPlotRatings@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ENDP ; CvEconomicAI::GetExplorationPlotRatings
_TEXT	ENDS
PUBLIC	?GetGoodyHutPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ; CvEconomicAI::GetGoodyHutPlots
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoodyHutPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ
_TEXT	SEGMENT
?GetGoodyHutPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ PROC ; CvEconomicAI::GetGoodyHutPlots, COMDAT
; _this$ = ecx

; 931  : {

	push	esi
	mov	esi, ecx

; 932  : 	if(m_bExplorationPlotsDirty)

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN4@GetGoodyHu

; 933  : 	{
; 934  : 		UpdatePlots();

	call	?UpdatePlots@CvEconomicAI@@QAEXXZ	; CvEconomicAI::UpdatePlots
$LN4@GetGoodyHu:

; 935  : 	}
; 936  : 
; 937  : 	return m_aiGoodyHutPlots;

	lea	eax, DWORD PTR [esi+88]
	pop	esi

; 938  : }

	ret	0
?GetGoodyHutPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ENDP ; CvEconomicAI::GetGoodyHutPlots
_TEXT	ENDS
PUBLIC	?GetUnitTargetGoodyPlot@CvEconomicAI@@QAEPAVCvPlot@@PAVCvUnit@@PAPAV2@@Z ; CvEconomicAI::GetUnitTargetGoodyPlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitTargetGoodyPlot@CvEconomicAI@@QAEPAVCvPlot@@PAVCvUnit@@PAPAV2@@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_ppkStepPlot$ = 12					; size = 4
?GetUnitTargetGoodyPlot@CvEconomicAI@@QAEPAVCvPlot@@PAVCvUnit@@PAPAV2@@Z PROC ; CvEconomicAI::GetUnitTargetGoodyPlot, COMDAT
; _this$ = ecx

; 942  : {

	push	ebx
	mov	ebx, ecx

; 943  : 	if(m_bExplorationPlotsDirty)

	cmp	BYTE PTR [ebx], 0
	push	esi
	push	edi
	je	SHORT $LN6@GetUnitTar

; 944  : 	{
; 945  : 		UpdatePlots();

	call	?UpdatePlots@CvEconomicAI@@QAEXXZ	; CvEconomicAI::UpdatePlots
$LN6@GetUnitTar:
	mov	edx, DWORD PTR [ebx+104]

; 946  : 	}
; 947  : 
; 948  : 	int iUnitID = pUnit->GetID();

	mov	eax, DWORD PTR _pUnit$[esp+8]
	mov	esi, DWORD PTR [eax+100]

; 949  : 	for(uint ui = 0; ui < m_aiGoodyHutUnitAssignments.size(); ui++)

	xor	ecx, ecx
	test	edx, edx
	jbe	SHORT $LN3@GetUnitTar
	mov	edi, DWORD PTR [ebx+100]
	mov	eax, edi
$LL5@GetUnitTar:

; 950  : 	{
; 951  : 		if(iUnitID == m_aiGoodyHutUnitAssignments[ui].m_iUnitID)

	cmp	esi, DWORD PTR [eax]
	je	SHORT $LN40@GetUnitTar
	inc	ecx
	add	eax, 8
	cmp	ecx, edx
	jb	SHORT $LL5@GetUnitTar
$LN3@GetUnitTar:
	pop	edi
	pop	esi

; 959  : 		}
; 960  : 	}
; 961  : 
; 962  : 	return NULL;

	xor	eax, eax
	pop	ebx

; 963  : }

	ret	8
$LN40@GetUnitTar:

; 952  : 		{
; 953  : 			if (ppkStepPlot)

	mov	esi, DWORD PTR _ppkStepPlot$[esp+8]
	test	esi, esi
	je	SHORT $LN1@GetUnitTar

; 954  : 			{
; 955  : 				int iStepPlotID = m_aiGoodyHutUnitAssignments[ui].m_iStepPlotID;

	mov	eax, DWORD PTR [edi+ecx*8+4]

; 956  : 				*ppkStepPlot = (iStepPlotID != -1)?GC.getMap().plotByIndex(iStepPlotID):NULL;

	cmp	eax, -1
	je	SHORT $LN9@GetUnitTar
	test	eax, eax
	jl	SHORT $LN9@GetUnitTar
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [edx+4028]
	jge	SHORT $LN9@GetUnitTar
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [edx+4068]
	jmp	SHORT $LN10@GetUnitTar
$LN9@GetUnitTar:
	xor	eax, eax
$LN10@GetUnitTar:
	mov	DWORD PTR [esi], eax
$LN1@GetUnitTar:

; 957  : 			}
; 958  : 			return GC.getMap().plotByIndex(m_aiGoodyHutPlots[ui]);

	mov	edx, DWORD PTR [ebx+88]
	mov	eax, DWORD PTR [edx+ecx*4]
	test	eax, eax
	jl	SHORT $LN3@GetUnitTar
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN3@GetUnitTar
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	pop	edi
	pop	esi
	pop	ebx

; 963  : }

	ret	8
?GetUnitTargetGoodyPlot@CvEconomicAI@@QAEPAVCvPlot@@PAVCvUnit@@PAPAV2@@Z ENDP ; CvEconomicAI::GetUnitTargetGoodyPlot
_TEXT	ENDS
PUBLIC	?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z ; CvEconomicAI::CanWithdrawMoneyForPurchase
; Function compile flags: /Ogtpy
;	COMDAT ?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z
_TEXT	SEGMENT
_request$226590 = -12					; size = 12
_ePurchase$ = 8						; size = 4
_iAmount$ = 12						; size = 4
_iPriority$ = 16					; size = 4
?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z PROC ; CvEconomicAI::CanWithdrawMoneyForPurchase, COMDAT
; _this$ = ecx

; 1161 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 1162 : 	int iBalance = m_pPlayer->GetTreasury()->GetGold();

	mov	ecx, DWORD PTR [edi+4]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold

; 1163 : 
; 1164 : 	// Update this item's priority
; 1165 : 	if(iPriority != -1)

	mov	ecx, DWORD PTR _ePurchase$[esp+24]
	mov	ebx, eax
	mov	eax, DWORD PTR _iPriority$[esp+24]
	cmp	eax, -1
	je	SHORT $LN8@CanWithdra

; 1166 : 	{
; 1167 : 		int iIndex = (int)ePurchase;
; 1168 : 		m_RequestedSavings[iIndex].m_iPriority = iPriority;

	mov	edx, DWORD PTR [edi+112]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	mov	DWORD PTR [edx+ecx*4+8], eax
$LN8@CanWithdra:

; 1169 : 	}
; 1170 : 
; 1171 : 	// Copy into temp array and sort by priority
; 1172 : 	m_TempRequestedSavings = m_RequestedSavings;

	lea	eax, DWORD PTR [edi+112]
	lea	esi, DWORD PTR [edi+200]
	push	eax
	mov	ecx, esi
	call	??4?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::operator=

; 1173 : 	std::stable_sort(m_TempRequestedSavings.begin(), m_TempRequestedSavings.end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, ecx
	lea	eax, DWORD PTR [eax+edx*4]
	cmp	ecx, eax
	je	SHORT $LN17@CanWithdra
	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 16					; 00000010H
$LN17@CanWithdra:
	mov	edi, DWORD PTR [edi+204]

; 1174 : 
; 1175 : 	for(int iI = 0; iI < (int)m_TempRequestedSavings.size(); iI++)

	xor	edx, edx
	test	edi, edi
	jle	SHORT $LN5@CanWithdra
	mov	eax, DWORD PTR [esi]
	npad	1
$LL7@CanWithdra:

; 1176 : 	{
; 1177 : 		CvPurchaseRequest request = m_TempRequestedSavings[iI];

	mov	ecx, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR _request$226590[esp+36], ebp

; 1178 : 
; 1179 : 		// Is this higher priority than the request we care about?
; 1180 : 		if(request.m_eType != ePurchase)

	cmp	ecx, DWORD PTR _ePurchase$[esp+24]
	je	SHORT $LN30@CanWithdra

; 1181 : 		{
; 1182 : 			iBalance -= request.m_iAmount;

	sub	ebx, esi

; 1183 : 
; 1184 : 			// No money left?
; 1185 : 			if(iBalance <= 0)

	test	ebx, ebx
	jle	SHORT $LN5@CanWithdra
	inc	edx
	add	eax, 12					; 0000000cH
	cmp	edx, edi
	jl	SHORT $LL7@CanWithdra
$LN5@CanWithdra:
	pop	edi
	pop	esi
	pop	ebp

; 1195 : 		}
; 1196 : 	}
; 1197 : 
; 1198 : 	CvAssert(false);
; 1199 : 	return false;  // Should never reach here

	xor	al, al
	pop	ebx

; 1200 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
$LN30@CanWithdra:
	pop	edi

; 1186 : 			{
; 1187 : 				return false;
; 1188 : 			}
; 1189 : 		}
; 1190 : 
; 1191 : 		// Is this the one, if so, check balance remaining
; 1192 : 		else if(request.m_eType == ePurchase)
; 1193 : 		{
; 1194 : 			return (iBalance >=iAmount);

	xor	eax, eax
	cmp	ebx, DWORD PTR _iAmount$[esp+20]
	pop	esi
	pop	ebp
	setge	al
	pop	ebx

; 1200 : }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z ENDP ; CvEconomicAI::CanWithdrawMoneyForPurchase
_TEXT	ENDS
PUBLIC	?AmountAvailableForPurchase@CvEconomicAI@@QAEHW4PurchaseType@@@Z ; CvEconomicAI::AmountAvailableForPurchase
; Function compile flags: /Ogtpy
;	COMDAT ?AmountAvailableForPurchase@CvEconomicAI@@QAEHW4PurchaseType@@@Z
_TEXT	SEGMENT
_request$226605 = -12					; size = 12
_ePurchase$ = 8						; size = 4
?AmountAvailableForPurchase@CvEconomicAI@@QAEHW4PurchaseType@@@Z PROC ; CvEconomicAI::AmountAvailableForPurchase, COMDAT
; _this$ = ecx

; 1208 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 1209 : 	int iBalance = m_pPlayer->GetTreasury()->GetGold();

	mov	ecx, DWORD PTR [edi+4]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	mov	ebx, eax

; 1210 : 
; 1211 : 	// Copy into temp array and sort by priority
; 1212 : #ifdef AUI_WARNING_FIXES
; 1213 : 	FStaticVector<CvPurchaseRequest, NUM_PURCHASE_TYPES, true, c_eCiv5GameplayDLL, 0> vTempRequestedSavings = m_RequestedSavings;
; 1214 : 	std::stable_sort(vTempRequestedSavings.begin(), vTempRequestedSavings.end());
; 1215 : 
; 1216 : 	for (FStaticVector<CvPurchaseRequest, NUM_PURCHASE_TYPES, true, c_eCiv5GameplayDLL, 0>::iterator it = vTempRequestedSavings.begin(); it != vTempRequestedSavings.end(); ++it)
; 1217 : 	{
; 1218 : 		CvPurchaseRequest request = *it;
; 1219 : #else
; 1220 : 	m_TempRequestedSavings = m_RequestedSavings;

	lea	eax, DWORD PTR [edi+112]
	lea	esi, DWORD PTR [edi+200]
	push	eax
	mov	ecx, esi
	call	??4?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::operator=

; 1221 : 	std::stable_sort(m_TempRequestedSavings.begin(), m_TempRequestedSavings.end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, ecx
	lea	eax, DWORD PTR [eax+edx*4]
	cmp	ecx, eax
	je	SHORT $LN14@AmountAvai
	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 16					; 00000010H
$LN14@AmountAvai:
	mov	edi, DWORD PTR [edi+204]

; 1222 : 
; 1223 : 	for(int iI = 0; iI < (int)m_TempRequestedSavings.size(); iI++)

	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN5@AmountAvai
	mov	esi, DWORD PTR [esi]
$LL7@AmountAvai:

; 1224 : 	{
; 1225 : 		CvPurchaseRequest request = m_TempRequestedSavings[iI];

	mov	eax, DWORD PTR [esi]
	mov	ebp, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _request$226605[esp+36], ebp

; 1226 : #endif
; 1227 : 
; 1228 : 		// Is this higher priority than the request we care about?
; 1229 : 		if(request.m_eType != ePurchase)

	cmp	eax, DWORD PTR _ePurchase$[esp+24]
	je	SHORT $LN27@AmountAvai

; 1230 : 		{
; 1231 : 			iBalance -= request.m_iAmount;

	sub	ebx, edx

; 1232 : 
; 1233 : 			// No money left?
; 1234 : 			if(iBalance <= 0)

	test	ebx, ebx
	jle	SHORT $LN5@AmountAvai
	inc	ecx
	add	esi, 12					; 0000000cH
	cmp	ecx, edi
	jl	SHORT $LL7@AmountAvai
$LN5@AmountAvai:
	pop	edi
	pop	esi
	pop	ebp

; 1244 : 		}
; 1245 : 	}
; 1246 : 
; 1247 : 	CvAssert(false);
; 1248 : #ifdef AUI_WARNING_FIXES
; 1249 : 	return iBalance;
; 1250 : #else
; 1251 : 	return false;  // Should never reach here

	xor	eax, eax
	pop	ebx

; 1252 : #endif
; 1253 : }

	add	esp, 12					; 0000000cH
	ret	4
$LN27@AmountAvai:
	pop	edi
	pop	esi
	pop	ebp

; 1235 : 			{
; 1236 : 				return 0;
; 1237 : 			}
; 1238 : 		}
; 1239 : 
; 1240 : 		// Is this the one, if so, check balance remaining
; 1241 : 		else if(request.m_eType == ePurchase)
; 1242 : 		{
; 1243 : 			return (iBalance);

	mov	eax, ebx
	pop	ebx

; 1252 : #endif
; 1253 : }

	add	esp, 12					; 0000000cH
	ret	4
?AmountAvailableForPurchase@CvEconomicAI@@QAEHW4PurchaseType@@@Z ENDP ; CvEconomicAI::AmountAvailableForPurchase
_TEXT	ENDS
PUBLIC	?DoPlotPurchases@CvEconomicAI@@AAEXXZ		; CvEconomicAI::DoPlotPurchases
EXTRN	?BuyPlot@CvCity@@QAEXHH@Z:PROC			; CvCity::BuyPlot
EXTRN	?GetBuyPlotCost@CvCity@@QBEHHH@Z:PROC		; CvCity::GetBuyPlotCost
EXTRN	?GetBuyPlotScore@CvCity@@QAEHAAH0@Z:PROC	; CvCity::GetBuyPlotScore
EXTRN	?CanBuyAnyPlot@CvCity@@QAE_NXZ:PROC		; CvCity::CanBuyAnyPlot
EXTRN	?GetBuyPlotCost@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetBuyPlotCost
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?DoPlotPurchases@CvEconomicAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoPlotPurchases@CvEconomicAI@@AAEXXZ$0
__ehfuncinfo$?DoPlotPurchases@CvEconomicAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoPlotPurchases@CvEconomicAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?DoPlotPurchases@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
_iBestX$ = -64						; size = 4
_pBestCity$ = -60					; size = 4
_iTempX$ = -56						; size = 4
_iTempY$ = -52						; size = 4
_iLoop$ = -48						; size = 4
_iBestY$ = -44						; size = 4
_strLogString$227147 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?DoPlotPurchases@CvEconomicAI@@AAEXXZ PROC		; CvEconomicAI::DoPlotPurchases, COMDAT
; _this$ = ecx

; 1882 : {

	push	-1
	push	__ehhandler$?DoPlotPurchases@CvEconomicAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi

; 1883 : 	CvCity* pLoopCity = 0;
; 1884 : 	CvCity* pBestCity = NULL;

	xor	esi, esi
	push	edi
	mov	ebx, ecx

; 1885 : 	int iBestX = -1;
; 1886 : 	int iBestY = -1;
; 1887 : 	int iTempX = 0, iTempY = 0;
; 1888 : 
; 1889 : 	int iScore = 0;
; 1890 : 	int iLoop = 0;
; 1891 : 
; 1892 : 	// No plot buying for minors
; 1893 : 	if(m_pPlayer->isMinorCiv())

	mov	ecx, DWORD PTR [ebx+4]
	or	edi, -1
	mov	DWORD PTR _pBestCity$[esp+76], esi
	mov	DWORD PTR _iBestX$[esp+76], edi
	mov	DWORD PTR _iBestY$[esp+76], edi
	mov	DWORD PTR _iTempX$[esp+76], esi
	mov	DWORD PTR _iTempY$[esp+76], esi
	mov	DWORD PTR _iLoop$[esp+76], esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN2@DoPlotPurc

; 1894 : 	{
; 1895 : 		return;
; 1896 : 	}
; 1897 : 
; 1898 : 	// No plot buying when at war
; 1899 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	esi
	push	OFFSET $SG227128
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 1900 : 	if(eStrategyAtWar != NO_MILITARYAISTRATEGY)

	cmp	eax, edi
	je	SHORT $LN11@DoPlotPurc

; 1901 : 	{
; 1902 : 		if(m_pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyAtWar))

	mov	ecx, DWORD PTR [ebx+4]
	push	eax
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	test	al, al
	jne	$LN2@DoPlotPurc
$LN11@DoPlotPurc:

; 1903 : 		{
; 1904 : 			return;
; 1905 : 		}
; 1906 : 	}
; 1907 : 
; 1908 : 	// Set up the parameters
; 1909 : 	int iBestScore = /*150*/ GC.getAI_GOLD_PRIORITY_MINIMUM_PLOT_BUY_VALUE();
; 1910 : 	int iCurrentCost = m_pPlayer->GetBuyPlotCost();

	mov	ecx, DWORD PTR [ebx+4]
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2068
	push	ebp
	call	?GetBuyPlotCost@CvPlayer@@QBEHXZ	; CvPlayer::GetBuyPlotCost

; 1911 : 	int iGoldForHalfCost = /*1000*/ GC.getAI_GOLD_BALANCE_TO_HALVE_PLOT_BUY_MINIMUM();
; 1912 : 	int iBalance = m_pPlayer->GetTreasury()->GetGold();

	mov	ecx, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2072
	mov	ebp, eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold

; 1913 : 
; 1914 : 	// Let's always invest any money we have in plot purchases
; 1915 : 	//  (LATER -- save up money to spend at newly settled cities)
; 1916 : 	if(iCurrentCost < iBalance && iGoldForHalfCost > iCurrentCost)

	cmp	ebp, eax
	jge	$LN31@DoPlotPurc
	cmp	esi, ebp
	jle	$LN31@DoPlotPurc

; 1917 : 	{
; 1918 : 		// Lower our requirements if we're building up a sizable treasury
; 1919 : 		int iDiscountPercent = 50 * (iBalance - iCurrentCost) / (iGoldForHalfCost - iCurrentCost);

	sub	eax, ebp
	imul	eax, 50					; 00000032H
	cdq
	sub	esi, ebp
	idiv	esi

; 1920 : 		iBestScore = iBestScore - (iBestScore * iDiscountPercent / 100);
; 1921 : 
; 1922 : 		// Find the best city to buy a plot
; 1923 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	imul	eax, edi
	mov	ecx, eax
	mov	eax, -1374389535			; ae147ae1H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR _iLoop$[esp+84]
	add	eax, edx
	push	ecx
	mov	ecx, DWORD PTR [ebx+4]
	add	edi, eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	$LN31@DoPlotPurc
$LL9@DoPlotPurc:

; 1924 : 		{
; 1925 : 			if(pLoopCity->CanBuyAnyPlot())

	mov	ecx, esi
	call	?CanBuyAnyPlot@CvCity@@QAE_NXZ		; CvCity::CanBuyAnyPlot
	test	al, al
	je	SHORT $LN8@DoPlotPurc

; 1926 : 			{
; 1927 : 				iScore = pLoopCity->GetBuyPlotScore(iTempX, iTempY);

	lea	edx, DWORD PTR _iTempY$[esp+80]
	push	edx
	lea	eax, DWORD PTR _iTempX$[esp+84]
	push	eax
	mov	ecx, esi
	call	?GetBuyPlotScore@CvCity@@QAEHAAH0@Z	; CvCity::GetBuyPlotScore

; 1928 : 
; 1929 : 				if(iScore > iBestScore)

	cmp	eax, edi
	jle	SHORT $LN8@DoPlotPurc

; 1930 : 				{
; 1931 : 					pBestCity = pLoopCity;
; 1932 : 					iBestScore = iScore;
; 1933 : 					iBestX = iTempX;

	mov	ecx, DWORD PTR _iTempX$[esp+80]

; 1934 : 					iBestY = iTempY;

	mov	edx, DWORD PTR _iTempY$[esp+80]
	mov	DWORD PTR _pBestCity$[esp+80], esi
	mov	edi, eax
	mov	DWORD PTR _iBestX$[esp+80], ecx
	mov	DWORD PTR _iBestY$[esp+80], edx
$LN8@DoPlotPurc:
	mov	ecx, DWORD PTR [ebx+4]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+84]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL9@DoPlotPurc

; 1935 : 				}
; 1936 : 			}
; 1937 : 		}
; 1938 : 
; 1939 : 		if(pBestCity != NULL)

	mov	ecx, DWORD PTR _pBestCity$[esp+80]
	test	ecx, ecx
	je	$LN31@DoPlotPurc

; 1940 : 		{
; 1941 : 			if(iBestX != -1 && iBestY != -1)

	mov	eax, DWORD PTR _iBestX$[esp+80]
	cmp	eax, -1
	je	$LN31@DoPlotPurc
	mov	ebp, DWORD PTR _iBestY$[esp+80]
	cmp	ebp, -1
	je	$LN31@DoPlotPurc

; 1942 : 			{
; 1943 : 				int iCost = pBestCity->GetBuyPlotCost(iBestX, iBestY);

	push	ebp
	push	eax
	call	?GetBuyPlotCost@CvCity@@QBEHHH@Z	; CvCity::GetBuyPlotCost

; 1944 : 
; 1945 : 				if(CanWithdrawMoneyForPurchase(PURCHASE_TYPE_TILE, iCost, iBestScore))

	push	edi
	mov	esi, eax
	push	esi
	push	0
	mov	ecx, ebx
	call	?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z ; CvEconomicAI::CanWithdrawMoneyForPurchase
	test	al, al
	je	$LN31@DoPlotPurc

; 1946 : 				{
; 1947 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN29@DoPlotPurc
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN29@DoPlotPurc

; 1948 : 					{
; 1949 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227147[esp+80]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1950 : 						strLogString.Format("Buying plot, X: %d, Y: %d, Cost: %d, Balance (before buy): %d, Priority: %d", iBestX, iBestY,
; 1951 : 						                    iCost, m_pPlayer->GetTreasury()->GetGold(), iBestScore);

	mov	ecx, DWORD PTR [ebx+4]
	push	edi
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	mov	ecx, DWORD PTR _iBestX$[esp+84]
	push	eax
	push	esi
	push	ebp
	push	ecx
	lea	edx, DWORD PTR _strLogString$227147[esp+100]
	push	OFFSET $SG227148
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1952 : 						m_pPlayer->GetHomelandAI()->LogHomelandMessage(strLogString);

	mov	ecx, DWORD PTR [ebx+4]
	add	esp, 28					; 0000001cH
	lea	eax, DWORD PTR _strLogString$227147[esp+80]
	push	eax
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1953 : 					}

	lea	ecx, DWORD PTR _strLogString$227147[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN29@DoPlotPurc:

; 1954 : 					pBestCity->BuyPlot(iBestX, iBestY);

	mov	ecx, DWORD PTR _iBestX$[esp+80]
	push	ebp
	push	ecx
	mov	ecx, DWORD PTR _pBestCity$[esp+88]
	call	?BuyPlot@CvCity@@QAEXHH@Z		; CvCity::BuyPlot
$LN31@DoPlotPurc:
	pop	ebp
$LN2@DoPlotPurc:

; 1955 : 				}
; 1956 : 			}
; 1957 : 		}
; 1958 : 	}
; 1959 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 64					; 00000040H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoPlotPurchases@CvEconomicAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$227147[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoPlotPurchases@CvEconomicAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoPlotPurchases@CvEconomicAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoPlotPurchases@CvEconomicAI@@AAEXXZ ENDP		; CvEconomicAI::DoPlotPurchases
PUBLIC	?DoTurn@CvEconomicAI@@QAEXXZ			; CvEconomicAI::DoTurn
EXTRN	?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ:PROC	; CvPlayerCulture::DoSwapGreatWorks
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z:PROC ; CvFlavorManager::ChangeFlavors
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DoTurn@CvEconomicAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTurn@CvEconomicAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoTurn@CvEconomicAI@@QAEXXZ$1
__ehfuncinfo$?DoTurn@CvEconomicAI@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DoTurn@CvEconomicAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?DoTurn@CvEconomicAI@@QAEXXZ
_TEXT	SEGMENT
_bTestStrategyStart$226202 = -51			; size = 1
_bTestStrategyEnd$226210 = -50				; size = 1
_bResult$226348 = -49					; size = 1
_pStrategy$226200 = -48					; size = 4
_args$226347 = -44					; size = 4
_strStrategyName$226222 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?DoTurn@CvEconomicAI@@QAEXXZ PROC			; CvEconomicAI::DoTurn, COMDAT
; _this$ = ecx

; 551  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DoTurn@CvEconomicAI@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebp
	push	esi
	mov	esi, ecx

; 552  : 	AI_PERF_FORMAT("AI-perf.csv", ("CvEconomicAI::DoTurn, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), GetPlayer()->getCivilizationShortDescription()) );
; 553  : 
; 554  : 	UpdatePlots();

	call	?UpdatePlots@CvEconomicAI@@QAEXXZ	; CvEconomicAI::UpdatePlots

; 555  : 	LogMonitor();

	mov	ecx, esi
	call	?LogMonitor@CvEconomicAI@@QAEXXZ	; CvEconomicAI::LogMonitor

; 556  : 	LogCityMonitor();

	mov	ecx, esi
	call	?LogCityMonitor@CvEconomicAI@@QAEXXZ	; CvEconomicAI::LogCityMonitor

; 557  : 
; 558  : 	// Functions that need to run before we look at strategies
; 559  : 	DoReconState();

	mov	ecx, esi
	call	?DoReconState@CvEconomicAI@@AAEXXZ	; CvEconomicAI::DoReconState

; 560  : 	DoAntiquitySites();

	mov	ecx, esi
	call	?DoAntiquitySites@CvEconomicAI@@AAEXXZ	; CvEconomicAI::DoAntiquitySites

; 561  : 
; 562  : 	int iStrategiesLoop = 0;
; 563  : 
; 564  : 	// Loop through all strategies
; 565  : 	for(iStrategiesLoop = 0; iStrategiesLoop < GetEconomicAIStrategies()->GetNumEconomicAIStrategies(); iStrategiesLoop++)

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	xor	ebp, ebp
	test	ecx, -4					; fffffffcH
	jle	$LN125@DoTurn
	push	ebx
	push	edi
$LL336@DoTurn:

; 566  : 	{
; 567  : 		EconomicAIStrategyTypes eStrategy = (EconomicAIStrategyTypes) iStrategiesLoop;
; 568  : 		CvEconomicAIStrategyXMLEntry* pStrategy = GetEconomicAIStrategies()->GetEntry(iStrategiesLoop);

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [edx+ebp*4]

; 569  : 
; 570  : 		// Minor Civs can't run some Strategies
; 571  : 		if(m_pPlayer->isMinorCiv() && pStrategy->IsNoMinorCivs())

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _pStrategy$226200[esp+68], edi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN124@DoTurn
	cmp	BYTE PTR [edi+276], 0
	jne	$LN126@DoTurn
$LN124@DoTurn:

; 572  : 		{
; 573  : 			continue;
; 574  : 		}
; 575  : 
; 576  : 		bool bTestStrategyStart = true;
; 577  : 
; 578  : 		// Do we already have this Strategy adopted?
; 579  : 		if(IsUsingStrategy(eStrategy))

	mov	eax, DWORD PTR [esi+12]
	cmp	BYTE PTR [eax+ebp], 0
	mov	BYTE PTR _bTestStrategyStart$226202[esp+68], 1

; 580  : 		{
; 581  : 			bTestStrategyStart = false;
; 582  : 		}
; 583  : 		else

	jne	$LN343@DoTurn

; 584  : 		{
; 585  : 			// Has the prereq Tech necessary?
; 586  : 			if(pStrategy->GetTechPrereq() != NO_TECH && !GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pStrategy->GetTechPrereq()))

	mov	ecx, DWORD PTR [edi+280]
	cmp	ecx, -1
	je	SHORT $LN340@DoTurn
	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN158@DoTurn
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN159@DoTurn
$LN158@DoTurn:
	or	eax, -1
$LN159@DoTurn:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al

; 587  : 			{
; 588  : 				bTestStrategyStart = false;
; 589  : 			}
; 590  : 
; 591  : 			// Has the Tech which obsoletes this Strategy?
; 592  : 			if(bTestStrategyStart && pStrategy->GetTechObsolete() != NO_TECH && GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pStrategy->GetTechObsolete()))

	je	SHORT $LN344@DoTurn
$LN340@DoTurn:
	mov	ecx, DWORD PTR [edi+284]
	cmp	ecx, -1
	je	SHORT $LN120@DoTurn
	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN175@DoTurn
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN176@DoTurn
$LN175@DoTurn:
	or	eax, -1
$LN176@DoTurn:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	SHORT $LN120@DoTurn
$LN344@DoTurn:

; 593  : 			{
; 594  : 				bTestStrategyStart = false;

	mov	BYTE PTR _bTestStrategyStart$226202[esp+68], 0
$LN120@DoTurn:

; 595  : 			}
; 596  : 
; 597  : 			// Not time to check this yet?
; 598  : 			if(GC.getGame().getGameTurn() < pStrategy->GetFirstTurnExecuted())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR [edi+296]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, edi
	jge	SHORT $LN119@DoTurn
$LN343@DoTurn:

; 599  : 			{
; 600  : 				bTestStrategyStart = false;

	mov	BYTE PTR _bTestStrategyStart$226202[esp+68], 0
$LN119@DoTurn:

; 601  : 			}
; 602  : 		}
; 603  : 
; 604  : 		bool bTestStrategyEnd = false;
; 605  : 
; 606  : 		// Strategy is active, check to see if we should even try to disable it
; 607  : 		if(IsUsingStrategy(eStrategy))

	mov	eax, DWORD PTR [esi+12]
	cmp	BYTE PTR [eax+ebp], 0
	mov	BYTE PTR _bTestStrategyEnd$226210[esp+68], 0
	je	SHORT $LN334@DoTurn

; 608  : 		{
; 609  : 			if(pStrategy->GetCheckTriggerTurnCount() > 0)

	mov	ecx, DWORD PTR _pStrategy$226200[esp+68]
	mov	edi, DWORD PTR [ecx+292]
	test	edi, edi
	jle	SHORT $LN334@DoTurn

; 610  : 			{
; 611  : 				// Is it a turn where we want to check to see if this Strategy is maintained?
; 612  : 				if((GC.getGame().getGameTurn() - GetTurnStrategyAdopted(eStrategy)) % pStrategy->GetCheckTriggerTurnCount() == 0)

	mov	edx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, DWORD PTR [edx+ebp*4]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, ebx
	cdq
	idiv	edi
	test	edx, edx
	jne	SHORT $LN334@DoTurn

; 613  : 				{
; 614  : 					bTestStrategyEnd = true;
; 615  : 				}
; 616  : 			}
; 617  : 
; 618  : 			if(bTestStrategyEnd && pStrategy->GetMinimumNumTurnsExecuted() > 0)

	mov	eax, DWORD PTR _pStrategy$226200[esp+68]
	mov	edi, DWORD PTR [eax+288]
	mov	BYTE PTR _bTestStrategyEnd$226210[esp+68], 1
	test	edi, edi
	jle	SHORT $LN334@DoTurn

; 619  : 			{
; 620  : 				// Has the minimum # of turns passed for this Strategy?
; 621  : 				if(GC.getGame().getGameTurn() < GetTurnStrategyAdopted(eStrategy) + pStrategy->GetMinimumNumTurnsExecuted())

	mov	ecx, DWORD PTR [esi+16]
	mov	ebx, DWORD PTR [ecx+ebp*4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	ebx, edi
	cmp	eax, ebx
	jge	SHORT $LN334@DoTurn

; 622  : 				{
; 623  : 					bTestStrategyEnd = false;

	mov	BYTE PTR _bTestStrategyEnd$226210[esp+68], 0
$LN334@DoTurn:

; 624  : 				}
; 625  : 			}
; 626  : 		}
; 627  : 
; 628  : 		// Check Strategy Triggers
; 629  : 		// Functionality and existence of specific Strategies is hardcoded here, but data is stored in XML so it's easier to modify
; 630  : 
; 631  : 		if(bTestStrategyStart || bTestStrategyEnd)

	cmp	BYTE PTR _bTestStrategyStart$226202[esp+68], 0
	jne	SHORT $LN112@DoTurn
	cmp	BYTE PTR _bTestStrategyEnd$226210[esp+68], 0
	je	$LN126@DoTurn
$LN112@DoTurn:

; 632  : 		{
; 633  : 			bool bStrategyShouldBeActive = false;
; 634  : 
; 635  : 			// Has the Tech which obsoletes this Strategy? If so, Strategy should be deactivated regardless of other factors
; 636  : 			if(pStrategy->GetTechObsolete() != NO_TECH && GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pStrategy->GetTechObsolete()))

	mov	edi, DWORD PTR _pStrategy$226200[esp+68]
	mov	ecx, DWORD PTR [edi+284]
	cmp	ecx, -1
	je	SHORT $LN111@DoTurn
	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN214@DoTurn
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN215@DoTurn
$LN214@DoTurn:
	or	eax, -1
$LN215@DoTurn:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al

; 637  : 			{
; 638  : 				bStrategyShouldBeActive = false;
; 639  : 			}
; 640  : 			// Strategy isn't obsolete, so test triggers as normal
; 641  : 			else

	jne	$LN332@DoTurn
$LN111@DoTurn:

; 642  : 			{
; 643  : 				CvString strStrategyName = (CvString) pStrategy->GetType();

	lea	ecx, DWORD PTR [edi+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	jne	SHORT $LN226@DoTurn
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN226@DoTurn:
	push	eax
	lea	ecx, DWORD PTR _strStrategyName$226222[esp+72]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 644  : 
; 645  : 				// Check all of the Strategy Triggers
; 646  : 				if(strStrategyName == "ECONOMICAISTRATEGY_NEED_RECON")

	mov	edi, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	lea	eax, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226226
	push	eax
	mov	DWORD PTR __$EHRec$[esp+84], 0
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN109@DoTurn

; 647  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedRecon(m_pPlayer);

	mov	edi, DWORD PTR [esi+4]
	push	0
	push	OFFSET $SG227849
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	eax, -1
	je	SHORT $LN228@DoTurn
	push	eax
	mov	ecx, edi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	test	al, al
	je	SHORT $LN228@DoTurn
	xor	bl, bl
	jmp	$LN30@DoTurn
$LN228@DoTurn:
	mov	ecx, edi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	cmp	DWORD PTR [eax+28], 2
	sete	bl
	jmp	$LN30@DoTurn
$LN109@DoTurn:

; 648  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_ENOUGH_RECON")

	lea	ecx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226229
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN107@DoTurn

; 649  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_EnoughRecon(m_pPlayer);

	mov	ecx, DWORD PTR [esi+4]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	cmp	DWORD PTR [eax+28], 0
	sete	bl
	jmp	$LN30@DoTurn
$LN107@DoTurn:

; 650  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_REALLY_NEED_RECON_SEA")

	lea	edx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226232
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN105@DoTurn

; 651  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_ReallyNeedReconSea(m_pPlayer);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	?IsTestStrategy_ReallyNeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ReallyNeedReconSea
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN105@DoTurn:

; 652  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_RECON_SEA")

	lea	ecx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226235
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN103@DoTurn

; 653  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedReconSea(m_pPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	?IsTestStrategy_NeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedReconSea
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN103@DoTurn:

; 654  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_ENOUGH_RECON_SEA")

	lea	eax, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226238
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN101@DoTurn

; 655  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_EnoughReconSea(m_pPlayer);

	mov	ecx, DWORD PTR [esi+4]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	cmp	DWORD PTR [eax+32], 0
	sete	bl
	jmp	$LN30@DoTurn
$LN101@DoTurn:

; 656  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_EARLY_EXPANSION")

	lea	ecx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226241
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN99@DoTurn

; 657  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_EarlyExpansion(m_pPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	?IsTestStrategy_EarlyExpansion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EarlyExpansion
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN99@DoTurn:

; 658  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_ENOUGH_EXPANSION")

	lea	eax, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226244
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN97@DoTurn

; 659  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_EnoughExpansion(eStrategy, m_pPlayer);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	push	ebp
	call	?IsTestStrategy_EnoughExpansion@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EnoughExpansion
	add	esp, 8
	mov	bl, al
	jmp	$LN30@DoTurn
$LN97@DoTurn:

; 660  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_HAPPINESS")

	lea	edx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226247
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN95@DoTurn

; 661  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedHappiness(eStrategy, m_pPlayer);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	push	ebp
	call	?IsTestStrategy_NeedHappiness@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedHappiness
	add	esp, 8
	mov	bl, al
	jmp	$LN30@DoTurn
$LN95@DoTurn:

; 662  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_HAPPINESS_CRITICAL")

	lea	ecx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226250
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN93@DoTurn

; 663  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedHappinessCritical(eStrategy, m_pPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	push	ebp
	call	?IsTestStrategy_NeedHappinessCritical@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedHappinessCritical
	add	esp, 8
	mov	bl, al
	jmp	$LN30@DoTurn
$LN93@DoTurn:

; 664  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_CITIES_NEED_NAVAL_GROWTH")

	lea	eax, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226253
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN91@DoTurn

; 665  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalGrowth(eStrategy, m_pPlayer);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	push	ebp
	call	?IsTestStrategy_CitiesNeedNavalGrowth@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalGrowth
	add	esp, 8
	mov	bl, al
	jmp	$LN30@DoTurn
$LN91@DoTurn:

; 666  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_CITIES_NEED_NAVAL_TILE_IMPROVEMENT")

	lea	edx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226256
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN89@DoTurn

; 667  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalTileImprovement(eStrategy, m_pPlayer);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	push	ebp
	call	?IsTestStrategy_CitiesNeedNavalTileImprovement@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalTileImprovement
	add	esp, 8
	mov	bl, al
	jmp	$LN30@DoTurn
$LN89@DoTurn:

; 668  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_FOUND_CITY")

	lea	ecx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226259
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN87@DoTurn

; 669  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_FoundCity(eStrategy, m_pPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	push	ebp
	call	?IsTestStrategy_FoundCity@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_FoundCity
	add	esp, 8
	mov	bl, al
	jmp	$LN30@DoTurn
$LN87@DoTurn:

; 670  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_TRADE_WITH_CITY_STATE")

	lea	eax, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226262
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN85@DoTurn

; 671  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_TradeWithCityState(eStrategy, m_pPlayer);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	push	ebp
	call	?IsTestStrategy_TradeWithCityState@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_TradeWithCityState
	add	esp, 8
	mov	bl, al
	jmp	$LN30@DoTurn
$LN85@DoTurn:

; 672  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_IMPROVEMENT_FOOD")

	lea	edx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226265
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN83@DoTurn

; 673  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedImprovement(m_pPlayer, YIELD_FOOD);

	mov	eax, DWORD PTR [esi+4]
	push	0
	push	eax
	call	?IsTestStrategy_NeedImprovement@EconomicAIHelpers@@YA_NPAVCvPlayer@@W4YieldTypes@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedImprovement
	add	esp, 8
	mov	bl, al
	jmp	$LN30@DoTurn
$LN83@DoTurn:

; 674  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_IMPROVEMENT_PRODUCTION")

	lea	ecx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226268
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN81@DoTurn

; 675  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedImprovement(m_pPlayer, YIELD_PRODUCTION);

	mov	edx, DWORD PTR [esi+4]
	push	1
	push	edx
	call	?IsTestStrategy_NeedImprovement@EconomicAIHelpers@@YA_NPAVCvPlayer@@W4YieldTypes@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedImprovement
	add	esp, 8
	mov	bl, al
	jmp	$LN30@DoTurn
$LN81@DoTurn:

; 676  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_ONE_OR_FEWER_COASTAL_CITIES")

	lea	eax, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226271
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN79@DoTurn

; 677  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_OneOrFewerCoastalCities(m_pPlayer);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	?IsTestStrategy_OneOrFewerCoastalCities@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_OneOrFewerCoastalCities
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN79@DoTurn:

; 678  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_LOSING_MONEY")

	lea	edx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226274
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN77@DoTurn

; 679  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_LosingMoney(eStrategy, m_pPlayer);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	push	ebp
	call	?IsTestStrategy_LosingMoney@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_LosingMoney
	add	esp, 8
	mov	bl, al
	jmp	$LN30@DoTurn
$LN77@DoTurn:

; 680  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_HALT_GROWTH_BUILDINGS")

	lea	ecx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226277
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN75@DoTurn

; 681  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_HaltGrowthBuildings(m_pPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	?IsTestStrategy_HaltGrowthBuildings@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_HaltGrowthBuildings
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN75@DoTurn:

; 682  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_TOO_MANY_UNITS")

	lea	eax, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226280
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN73@DoTurn

; 683  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_TooManyUnits(m_pPlayer);

	mov	ecx, DWORD PTR [esi+4]
	call	?GetUnitProductionMaintenanceMod@CvPlayer@@QBEHXZ ; CvPlayer::GetUnitProductionMaintenanceMod
	test	eax, eax
	setne	bl
	jmp	$LN30@DoTurn
$LN73@DoTurn:

; 684  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_ISLAND_START")

	lea	ecx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226283
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN71@DoTurn

; 685  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_IslandStart(eStrategy, m_pPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	push	ebp
	call	?IsTestStrategy_IslandStart@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_IslandStart
	add	esp, 8
	mov	bl, al
	jmp	$LN30@DoTurn
$LN71@DoTurn:

; 686  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS")

	lea	eax, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226286
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN69@DoTurn

; 687  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_ExpandToOtherContinents(m_pPlayer);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	?IsTestStrategy_ExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ExpandToOtherContinents
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN69@DoTurn:

; 688  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_REALLY_EXPAND_TO_OTHER_CONTINENTS")

	lea	edx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226289
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN67@DoTurn

; 689  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_ReallyExpandToOtherContinents(m_pPlayer);				

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	?IsTestStrategy_ReallyExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ReallyExpandToOtherContinents
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN67@DoTurn:

; 690  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_MOSTLY_ON_THE_COAST")

	lea	ecx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226292
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN65@DoTurn

; 691  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_MostlyOnTheCoast(m_pPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	?IsTestStrategy_MostlyOnTheCoast@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_MostlyOnTheCoast
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN65@DoTurn:

; 692  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_EXPAND_LIKE_CRAZY")

	lea	eax, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226295
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN63@DoTurn

; 693  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_ExpandLikeCrazy(eStrategy, m_pPlayer);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	push	ebp
	call	?IsTestStrategy_ExpandLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ExpandLikeCrazy
	add	esp, 8
	mov	bl, al
	jmp	$LN30@DoTurn
$LN63@DoTurn:

; 694  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_GROW_LIKE_CRAZY")

	lea	edx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226298
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN61@DoTurn

; 695  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_GrowLikeCrazy(eStrategy, m_pPlayer);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	push	ebp
	call	?IsTestStrategy_GrowLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GrowLikeCrazy
	add	esp, 8
	mov	bl, al
	jmp	$LN30@DoTurn
$LN61@DoTurn:

; 696  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_GS_CULTURE")

	lea	ecx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226301
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN59@DoTurn

; 697  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_GS_Culture(m_pPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	?IsTestStrategy_GS_Culture@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Culture
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN59@DoTurn:

; 698  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_GS_CONQUEST")

	lea	eax, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226304
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN57@DoTurn

; 699  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_GS_Conquest(m_pPlayer);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	?IsTestStrategy_GS_Conquest@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Conquest
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN57@DoTurn:

; 700  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_GS_DIPLOMACY")

	lea	edx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226307
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN55@DoTurn

; 701  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_GS_Diplomacy(m_pPlayer);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	?IsTestStrategy_GS_Diplomacy@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Diplomacy
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN55@DoTurn:

; 702  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_GS_SPACESHIP")

	lea	ecx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226310
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN53@DoTurn

; 703  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_GS_Spaceship(m_pPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	?IsTestStrategy_GS_Spaceship@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Spaceship
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN53@DoTurn:

; 704  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_GS_SPACESHIP_HOMESTRETCH")

	lea	eax, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226313
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN51@DoTurn

; 705  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch(m_pPlayer);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	?IsTestStrategy_GS_SpaceshipHomestretch@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN51@DoTurn:

; 706  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NAVAL_MAP")

	lea	edx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226316
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN49@DoTurn

; 707  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NavalMap(m_pPlayer);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	?IsTestStrategy_NavalMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NavalMap
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN49@DoTurn:

; 708  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_OFFSHORE_EXPANSION_MAP")

	lea	ecx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226319
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN47@DoTurn

; 709  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_OffshoreExpansionMap(m_pPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	?IsTestStrategy_OffshoreExpansionMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_OffshoreExpansionMap
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN47@DoTurn:

; 710  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_DEVELOPING_RELIGION")

	lea	eax, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226322
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN45@DoTurn

; 711  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_DevelopingReligion(m_pPlayer);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	?IsTestStrategy_DevelopingReligion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_DevelopingReligion
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN45@DoTurn:

; 712  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_TECH_LEADER")

	lea	edx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226325
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN43@DoTurn

; 713  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_TechLeader(m_pPlayer);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	?IsTestStrategy_TechLeader@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_TechLeader
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN43@DoTurn:

; 714  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_ARCHAEOLOGISTS")

	lea	ecx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226328
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN41@DoTurn

; 715  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedArchaeologists(m_pPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	?IsTestStrategy_NeedArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedArchaeologists
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN41@DoTurn:

; 716  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_ENOUGH_ARCHAEOLOGISTS")

	lea	eax, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226331
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN39@DoTurn

; 717  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_EnoughArchaeologists(m_pPlayer);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	?IsTestStrategy_EnoughArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EnoughArchaeologists
	add	esp, 4
	mov	bl, al
	jmp	$LN30@DoTurn
$LN39@DoTurn:

; 718  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_MUSEUMS")

	lea	edx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226334
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN37@DoTurn

; 719  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedMuseums(m_pPlayer);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	?IsTestStrategy_NeedMuseums@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedMuseums
	add	esp, 4
	mov	bl, al
	jmp	SHORT $LN30@DoTurn
$LN37@DoTurn:

; 720  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_GUILDS")

	lea	ecx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226337
	push	ecx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN35@DoTurn

; 721  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedGuilds(m_pPlayer);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	?IsTestStrategy_NeedGuilds@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedGuilds
	add	esp, 4
	mov	bl, al
	jmp	SHORT $LN30@DoTurn
$LN35@DoTurn:

; 722  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_CONCERT_TOUR")

	lea	eax, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226340
	push	eax
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN33@DoTurn

; 723  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_ConcertTour(eStrategy, m_pPlayer);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	push	ebp
	call	?IsTestStrategy_ConcertTour@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ConcertTour
	add	esp, 8
	mov	bl, al
	jmp	SHORT $LN30@DoTurn
$LN33@DoTurn:

; 724  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_STARTED_PIETY")

	lea	edx, DWORD PTR _strStrategyName$226222[esp+68]
	push	OFFSET $SG226343
	push	edx
	call	edi
	add	esp, 8
	test	al, al
	je	SHORT $LN31@DoTurn

; 725  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_StartedPiety(m_pPlayer);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	?IsTestStrategy_StartedPiety@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_StartedPiety
	add	esp, 4
	mov	bl, al

; 726  : 
; 727  : 				// Never found it?  Assume it is scenario-specific and should be on unless disabled by Lua hook
; 728  : 				else

	jmp	SHORT $LN30@DoTurn
$LN31@DoTurn:

; 729  : 				{
; 730  : 					bStrategyShouldBeActive = true;

	mov	bl, 1
$LN30@DoTurn:

; 731  : 				}
; 732  : 
; 733  : 				// Check Lua hook
; 734  : 				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	edi, eax

; 735  : 				if(pkScriptSystem && bStrategyShouldBeActive)

	test	edi, edi
	je	SHORT $LN29@DoTurn
	test	bl, bl
	je	SHORT $LN29@DoTurn

; 736  : 				{
; 737  : 					CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226347[esp+68]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 738  : 					args->Push(iStrategiesLoop);

	mov	ecx, DWORD PTR _args$226347[esp+68]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebp
	mov	BYTE PTR __$EHRec$[esp+80], 1
	call	eax

; 739  : 					args->Push(m_pPlayer->GetID());

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _args$226347[esp+68]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 740  : 
; 741  : 					// Attempt to execute the game events.
; 742  : 					// Will return false if there are no registered listeners.
; 743  : 					bool bResult = false;
; 744  : 					if(LuaSupport::CallTestAll(pkScriptSystem, "EconomicStrategyCanActivate", args.get(), bResult))

	mov	edx, DWORD PTR _args$226347[esp+68]
	lea	ecx, DWORD PTR _bResult$226348[esp+68]
	push	ecx
	push	edx
	push	OFFSET $SG226350
	push	edi
	mov	BYTE PTR _bResult$226348[esp+84], 0
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN27@DoTurn

; 745  : 					{
; 746  : 						// Check the result.
; 747  : 						if(bResult == false)

	cmp	BYTE PTR _bResult$226348[esp+68], 0
	jne	SHORT $LN27@DoTurn

; 748  : 						{
; 749  : 							bStrategyShouldBeActive = false;

	xor	bl, bl
$LN27@DoTurn:

; 750  : 						}
; 751  : 					}
; 752  : 				}

	lea	ecx, DWORD PTR _args$226347[esp+68]
	mov	BYTE PTR __$EHRec$[esp+76], 0
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN29@DoTurn:

; 753  : 			}

	lea	ecx, DWORD PTR _strStrategyName$226222[esp+68]
	mov	DWORD PTR __$EHRec$[esp+76], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 754  : 
; 755  : 			// This variable keeps track of whether or not we should be doing something (i.e. Strategy is active now but should be turned off, OR Strategy is inactive and should be enabled)
; 756  : 			bool bAdoptOrEndStrategy = false;
; 757  : 
; 758  : 			// Strategy should be on, and if it's not, turn it on
; 759  : 			if(bStrategyShouldBeActive)

	test	bl, bl
	je	SHORT $LN331@DoTurn

; 760  : 			{
; 761  : 				if(bTestStrategyStart)

	cmp	BYTE PTR _bTestStrategyStart$226202[esp+68], 0

; 762  : 				{
; 763  : 					bAdoptOrEndStrategy = true;

	je	$LN126@DoTurn

; 778  : 				{
; 779  : 					bAdoptOrEndStrategy = true;
; 780  : 				}
; 781  : 			}
; 782  : 
; 783  : 			// Flavor propagation
; 784  : 			if(bAdoptOrEndStrategy)
; 785  : 			{
; 786  : 				int iFlavorLoop;
; 787  : 
; 788  : 				// We should adopt this Strategy
; 789  : 				if(bTestStrategyStart)
; 790  : 				{
; 791  : 					SetUsingStrategy(eStrategy, true);

	mov	eax, DWORD PTR [esi+12]
	add	eax, ebp
	cmp	BYTE PTR [eax], 1
	je	SHORT $LN337@DoTurn
	mov	BYTE PTR [eax], 1
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR [esi+16]
	cmp	DWORD PTR [ecx+ebp*4], eax
	lea	ecx, DWORD PTR [ecx+ebp*4]
	je	SHORT $LN266@DoTurn
	mov	DWORD PTR [ecx], eax
$LN266@DoTurn:
	push	1
	push	ebp
	mov	ecx, esi
	call	?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z ; CvEconomicAI::LogStrategy
$LN337@DoTurn:

; 792  : 
; 793  : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	edi, DWORD PTR _pStrategy$226200[esp+68]
	xor	eax, eax
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, eax
	jle	$LN14@DoTurn
$LL16@DoTurn:

; 794  : 					{
; 795  : 						m_aiTempFlavors[iFlavorLoop] = pStrategy->GetPlayerFlavorValue(iFlavorLoop);

	mov	ecx, DWORD PTR [edi+260]
	test	ecx, ecx
	je	SHORT $LN276@DoTurn
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN277@DoTurn
$LN331@DoTurn:

; 764  : 				}
; 765  : 				else if(bTestStrategyEnd)
; 766  : 				{
; 767  : 					bAdoptOrEndStrategy = false;
; 768  : 				}
; 769  : 			}
; 770  : 			// Strategy should be off, and if it's not, turn it off
; 771  : 			else

	mov	edi, DWORD PTR _pStrategy$226200[esp+68]
$LN332@DoTurn:

; 772  : 			{
; 773  : 				if(bTestStrategyStart)

	cmp	BYTE PTR _bTestStrategyStart$226202[esp+68], 0

; 774  : 				{
; 775  : 					bAdoptOrEndStrategy = false;

	jne	$LN126@DoTurn

; 776  : 				}
; 777  : 				else if(bTestStrategyEnd)

	cmp	BYTE PTR _bTestStrategyEnd$226210[esp+68], 0
	je	$LN126@DoTurn

; 806  : 				}
; 807  : 				// End the Strategy
; 808  : 				else if(bTestStrategyEnd)
; 809  : 				{
; 810  : 					SetUsingStrategy(eStrategy, false);

	mov	ecx, DWORD PTR [esi+12]
	cmp	BYTE PTR [ecx+ebp], 0
	lea	eax, DWORD PTR [ecx+ebp]
	je	SHORT $LN339@DoTurn
	mov	BYTE PTR [eax], 0
	mov	edx, DWORD PTR [esi+16]
	cmp	DWORD PTR [edx+ebp*4], -1
	lea	eax, DWORD PTR [edx+ebp*4]
	je	SHORT $LN298@DoTurn
	mov	DWORD PTR [eax], -1
$LN298@DoTurn:
	push	0
	push	ebp
	mov	ecx, esi
	call	?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z ; CvEconomicAI::LogStrategy
$LN339@DoTurn:

; 811  : 
; 812  : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	ecx, ecx
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, ecx
	jle	$LN341@DoTurn
$LL8@DoTurn:

; 813  : 					{
; 814  : 						m_aiTempFlavors[iFlavorLoop] = -pStrategy->GetPlayerFlavorValue(iFlavorLoop);

	mov	eax, DWORD PTR [edi+260]
	test	eax, eax
	je	SHORT $LN305@DoTurn
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN306@DoTurn

; 794  : 					{
; 795  : 						m_aiTempFlavors[iFlavorLoop] = pStrategy->GetPlayerFlavorValue(iFlavorLoop);

$LN276@DoTurn:
	or	ecx, -1
$LN277@DoTurn:
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [edx+eax*4], ecx
	inc	eax
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	$LL16@DoTurn
$LN14@DoTurn:

; 796  : 					}
; 797  : 
; 798  : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, true);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+4]
	push	1
	push	eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z ; CvFlavorManager::ChangeFlavors

; 799  : 
; 800  : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	eax, eax
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, eax
	jle	$LN3@DoTurn
	npad	6
$LL13@DoTurn:

; 801  : 					{
; 802  : 						m_aiTempFlavors[iFlavorLoop] = pStrategy->GetCityFlavorValue(iFlavorLoop);

	mov	ecx, DWORD PTR [edi+264]
	test	ecx, ecx
	je	SHORT $LN284@DoTurn
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN285@DoTurn
$LN284@DoTurn:
	or	ecx, -1
$LN285@DoTurn:
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [edx+eax*4], ecx
	inc	eax
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL13@DoTurn

; 803  : 					}
; 804  : 
; 805  : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, false);

	jmp	SHORT $LN3@DoTurn

; 813  : 					{
; 814  : 						m_aiTempFlavors[iFlavorLoop] = -pStrategy->GetPlayerFlavorValue(iFlavorLoop);

$LN305@DoTurn:
	or	eax, -1
$LN306@DoTurn:
	mov	edx, DWORD PTR [esi+20]
	neg	eax
	mov	DWORD PTR [edx+ecx*4], eax
	inc	ecx
	cmp	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	$LL8@DoTurn
$LN341@DoTurn:

; 815  : 					}
; 816  : 
; 817  : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, true);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+4]
	push	1
	push	eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z ; CvFlavorManager::ChangeFlavors

; 818  : 
; 819  : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	ecx, ecx
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, ecx
	jle	SHORT $LN3@DoTurn
	npad	6
$LL5@DoTurn:

; 820  : 					{
; 821  : 						m_aiTempFlavors[iFlavorLoop] = -pStrategy->GetCityFlavorValue(iFlavorLoop);

	mov	eax, DWORD PTR [edi+264]
	test	eax, eax
	je	SHORT $LN313@DoTurn
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN314@DoTurn
$LN313@DoTurn:
	or	eax, -1
$LN314@DoTurn:
	mov	edx, DWORD PTR [esi+20]
	neg	eax
	mov	DWORD PTR [edx+ecx*4], eax
	inc	ecx
	cmp	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL5@DoTurn
$LN3@DoTurn:

; 822  : 					}
; 823  : 
; 824  : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, false);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+4]
	push	0
	push	eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z ; CvFlavorManager::ChangeFlavors
$LN126@DoTurn:
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	inc	ebp
	sar	ecx, 2
	cmp	ebp, ecx
	jl	$LL336@DoTurn
	pop	edi
	pop	ebx
$LN125@DoTurn:

; 825  : 				}
; 826  : 			}
; 827  : 		}
; 828  : 	}
; 829  : 
; 830  : 	if(!m_pPlayer->isHuman())

	mov	ecx, DWORD PTR [esi+4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN1@DoTurn

; 831  : 	{
; 832  : 		DoHurry();

	mov	ecx, esi
	call	?DoHurry@CvEconomicAI@@AAEXXZ		; CvEconomicAI::DoHurry

; 833  : 		DoPlotPurchases();

	mov	ecx, esi
	call	?DoPlotPurchases@CvEconomicAI@@AAEXXZ	; CvEconomicAI::DoPlotPurchases

; 834  : 		DisbandExtraWorkers();

	mov	ecx, esi
	call	?DisbandExtraWorkers@CvEconomicAI@@AAEXXZ ; CvEconomicAI::DisbandExtraWorkers

; 835  : 		if (!m_pPlayer->isMinorCiv() && !m_pPlayer->isBarbarian())

	mov	ecx, DWORD PTR [esi+4]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN1@DoTurn
	mov	ecx, DWORD PTR [esi+4]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN1@DoTurn

; 836  : 		{
; 837  : 			DisbandExtraArchaeologists();

	mov	ecx, esi
	call	?DisbandExtraArchaeologists@CvEconomicAI@@AAEXXZ ; CvEconomicAI::DisbandExtraArchaeologists

; 838  : 			m_pPlayer->GetCulture()->DoSwapGreatWorks();

	mov	ecx, DWORD PTR [esi+4]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ ; CvPlayerCulture::DoSwapGreatWorks
$LN1@DoTurn:

; 839  : 		}
; 840  : 	}
; 841  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTurn@CvEconomicAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strStrategyName$226222[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvEconomicAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _args$226347[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?DoTurn@CvEconomicAI@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DoTurn@CvEconomicAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTurn@CvEconomicAI@@QAEXXZ ENDP			; CvEconomicAI::DoTurn
END
