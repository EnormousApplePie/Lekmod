; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvUnitMission.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG217999 DB	'*** PROTOCOL ERROR *** : PushMission invoked for a human'
	DB	' controlled player outside of a network message!', 00H
	ORG $+3
$SG218016 DB	'FEATURE_FOREST', 00H
	ORG $+1
$SG218020 DB	'FEATURE_JUNGLE', 00H
	ORG $+1
$SG218024 DB	'FEATURE_MARSH', 00H
	ORG $+2
$SG218028 DB	'FEATURE_FALLOUT', 00H
	ORG $+4
$SG218153 DB	'*** PROTOCOL ERROR *** : PushMission invoked for a human'
	DB	' controlled player outside of a network message!', 00H
	ORG $+3
$SG218204 DB	'TXT_KEY_ADVISOR_CITY_ATTACK_BODY', 00H
	ORG $+3
$SG218215 DB	'TXT_KEY_ADVISOR_BAD_ATTACK_BODY', 00H
$SG218413 DB	'CanStartMission', 00H
CONST	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ; FObjectHandle<CvUnit>::pointer
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC ; FObjectHandle<CvUnit>::pointer, COMDAT
; _this$ = ecx

; 78   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 79   : 	}

	ret	0
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP ; FObjectHandle<CvUnit>::pointer
_TEXT	ENDS
PUBLIC	??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator->, COMDAT
; _this$ = ecx

; 88   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 89   : 	}

	ret	0
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator->
_TEXT	ENDS
PUBLIC	??D?$FObjectHandle@VCvUnit@@@@QAEAAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$FObjectHandle@VCvUnit@@@@QAEAAVCvUnit@@XZ
_TEXT	SEGMENT
??D?$FObjectHandle@VCvUnit@@@@QAEAAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator*, COMDAT
; _this$ = ecx

; 98   : 		return *m_target;

	mov	eax, DWORD PTR [ecx]

; 99   : 	}

	ret	0
??D?$FObjectHandle@VCvUnit@@@@QAEAAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator*
_TEXT	ENDS
PUBLIC	??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ		; FObjectHandle<CvUnit>::operator bool
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ
_TEXT	SEGMENT
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ PROC		; FObjectHandle<CvUnit>::operator bool, COMDAT
; _this$ = ecx

; 108  : 		return m_target != 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 109  : 	}

	ret	0
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ ENDP		; FObjectHandle<CvUnit>::operator bool
_TEXT	ENDS
PUBLIC	??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ		; FObjectHandle<CvUnit>::operator!
; Function compile flags: /Ogtpy
;	COMDAT ??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ
_TEXT	SEGMENT
??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ PROC		; FObjectHandle<CvUnit>::operator!, COMDAT
; _this$ = ecx

; 113  : 		return m_target == 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	sete	al

; 114  : 	}

	ret	0
??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ ENDP		; FObjectHandle<CvUnit>::operator!
_TEXT	ENDS
PUBLIC	??8?$FObjectHandle@VCvUnit@@@@QBE_NPBVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$FObjectHandle@VCvUnit@@@@QBE_NPBVCvUnit@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??8?$FObjectHandle@VCvUnit@@@@QBE_NPBVCvUnit@@@Z PROC	; FObjectHandle<CvUnit>::operator==, COMDAT
; _this$ = ecx

; 123  : 		return m_target == rhs;

	mov	ecx, DWORD PTR [ecx]
	xor	eax, eax
	cmp	ecx, DWORD PTR _rhs$[esp-4]
	sete	al

; 124  : 	}

	ret	4
??8?$FObjectHandle@VCvUnit@@@@QBE_NPBVCvUnit@@@Z ENDP	; FObjectHandle<CvUnit>::operator==
_TEXT	ENDS
PUBLIC	?ignoreDestruction@?$FObjectHandle@VCvUnit@@@@QAEX_N@Z ; FObjectHandle<CvUnit>::ignoreDestruction
; Function compile flags: /Ogtpy
;	COMDAT ?ignoreDestruction@?$FObjectHandle@VCvUnit@@@@QAEX_N@Z
_TEXT	SEGMENT
_ignore$ = 8						; size = 1
?ignoreDestruction@?$FObjectHandle@VCvUnit@@@@QAEX_N@Z PROC ; FObjectHandle<CvUnit>::ignoreDestruction, COMDAT
; _this$ = ecx

; 128  : 		m_ignoreDestruction = ignore;

	mov	al, BYTE PTR _ignore$[esp-4]
	mov	BYTE PTR [ecx+4], al

; 129  : 	}

	ret	4
?ignoreDestruction@?$FObjectHandle@VCvUnit@@@@QAEX_N@Z ENDP ; FObjectHandle<CvUnit>::ignoreDestruction
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 215  : 	{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+4], 0

; 216  : 		OBJECT_HANDLE_STACK;
; 217  : 	}

	ret	0
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@PAVCvPlot@@$00@@QBEIXZ	; BaseVector<CvPlot *,1>::size
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?size@?$BaseVector@PAVCvPlot@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@PAVCvPlot@@$00@@QBEIXZ PROC		; BaseVector<CvPlot *,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@PAVCvPlot@@$00@@QBEIXZ ENDP		; BaseVector<CvPlot *,1>::size
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z PROC	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from object pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 662  : 		}

	ret	4
??0?$auto_ptr@VICvUnit1@@@std@@QAE@PAVICvUnit1@@@Z ENDP	; std::auto_ptr<ICvUnit1>::auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ ; std::auto_ptr<ICvUnit1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ PROC ; std::auto_ptr<ICvUnit1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvUnit1@@@std@@QBEPAVICvUnit1@@XZ ENDP ; std::auto_ptr<ICvUnit1>::get
_TEXT	ENDS
PUBLIC	??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z PROC ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 669  : 	auto_ptr(auto_ptr_ref<_Ty> _Right) _THROW0()

	mov	eax, ecx

; 670  : 		{	// construct by assuming pointer from _Right auto_ptr_ref
; 671  : 		_Ty *_Ptr = _Right._Ref;
; 672  : 		_Right._Ref = 0;	// release old
; 673  : 		_Myptr = _Ptr;	// reset this

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 674  : 		}

	ret	4
??0?$auto_ptr@VICvPlot1@@@std@@QAE@U?$auto_ptr_ref@VICvPlot1@@@1@@Z ENDP ; std::auto_ptr<ICvPlot1>::auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ ; std::auto_ptr<ICvPlot1>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ PROC ; std::auto_ptr<ICvPlot1>::get, COMDAT
; _this$ = ecx

; 750  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 751  : 		}

	ret	0
?get@?$auto_ptr@VICvPlot1@@@std@@QBEPAVICvPlot1@@XZ ENDP ; std::auto_ptr<ICvPlot1>::get
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UMissionData@@$00@@QAEAAUMissionData@@I@Z ; BaseVector<MissionData,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UMissionData@@$00@@QAEAAUMissionData@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UMissionData@@$00@@QAEAAUMissionData@@I@Z PROC ; BaseVector<MissionData,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 131  : 	};

	ret	4
??A?$BaseVector@UMissionData@@$00@@QAEAAUMissionData@@I@Z ENDP ; BaseVector<MissionData,1>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UMissionData@@$00@@QBEABUMissionData@@I@Z ; BaseVector<MissionData,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UMissionData@@$00@@QBEABUMissionData@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UMissionData@@$00@@QBEABUMissionData@@I@Z PROC ; BaseVector<MissionData,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 137  : 	};

	ret	4
??A?$BaseVector@UMissionData@@$00@@QBEABUMissionData@@I@Z ENDP ; BaseVector<MissionData,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UMissionData@@$00@@QBEIXZ	; BaseVector<MissionData,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UMissionData@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UMissionData@@$00@@QBEIXZ PROC	; BaseVector<MissionData,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UMissionData@@$00@@QBEIXZ ENDP	; BaseVector<MissionData,1>::size
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEPAUMissionData@@I@Z ; FStaticVector<MissionData,12,1,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEPAUMissionData@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEPAUMissionData@@I@Z PROC ; FStaticVector<MissionData,12,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 12					; 0000000cH
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	lea	eax, DWORD PTR [edi+edi*4]
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 12			; 0000000cH
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEPAUMissionData@@I@Z ENDP ; FStaticVector<MissionData,12,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UMissionData@@$00@@IAEXPAUMissionData@@I@Z ; BaseVector<MissionData,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UMissionData@@$00@@IAEXPAUMissionData@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UMissionData@@$00@@IAEXPAUMissionData@@I@Z PROC ; BaseVector<MissionData,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UMissionData@@$00@@IAEXPAUMissionData@@I@Z ENDP ; BaseVector<MissionData,1>::Destroy
_TEXT	ENDS
PUBLIC	??$strcpy_s@$0CAA@@@YAHAAY0CAA@DPBD@Z		; strcpy_s<512>
EXTRN	__imp__strcpy_s:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\string.h
;	COMDAT ??$strcpy_s@$0CAA@@@YAHAAY0CAA@DPBD@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Source$ = 12						; size = 4
??$strcpy_s@$0CAA@@@YAHAAY0CAA@DPBD@Z PROC		; strcpy_s<512>, COMDAT

; 73   : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, _Deref_post_z_ char, _Dest, _In_z_ const char *, _Source)

	mov	eax, DWORD PTR __Source$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	push	eax
	push	512					; 00000200H
	push	ecx
	call	DWORD PTR __imp__strcpy_s
	add	esp, 12					; 0000000cH
	ret	0
??$strcpy_s@$0CAA@@@YAHAAY0CAA@DPBD@Z ENDP		; strcpy_s<512>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ; std::auto_ptr_ref<ICvPlot1>::auto_ptr_ref<ICvPlot1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z PROC ; std::auto_ptr_ref<ICvPlot1>::auto_ptr_ref<ICvPlot1>, COMDAT
; _this$ = ecx

; 647  : 		{	// construct from generic pointer to auto_ptr ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [eax], ecx

; 648  : 		}

	ret	4
??0?$auto_ptr_ref@VICvPlot1@@@std@@QAE@PAVICvPlot1@@@Z ENDP ; std::auto_ptr_ref<ICvPlot1>::auto_ptr_ref<ICvPlot1>
_TEXT	ENDS
PUBLIC	??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z ; CvPopupInfo::CvPopupInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
;	COMDAT ??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z
_TEXT	SEGMENT
_buttonPopupType$ = 8					; size = 4
_data1$ = 12						; size = 4
_data2$ = 16						; size = 4
_data3$ = 20						; size = 4
_flags$ = 24						; size = 4
_option1$ = 28						; size = 1
_option2$ = 32						; size = 1
??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z PROC	; CvPopupInfo::CvPopupInfo, COMDAT
; _this$ = ecx

; 119  : 	{

	mov	edx, DWORD PTR _data2$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _data1$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _data3$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _flags$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	cl, BYTE PTR _option1$[esp-4]
	mov	DWORD PTR [eax+12], edx
	mov	dl, BYTE PTR _option2$[esp-4]
	mov	BYTE PTR [eax+16], cl
	mov	ecx, DWORD PTR _buttonPopupType$[esp-4]
	mov	BYTE PTR [eax+17], dl
	mov	DWORD PTR [eax+20], ecx

; 120  : 		//Nothing
; 121  : 		szText[0] = 0;

	mov	BYTE PTR [eax+24], 0

; 122  : 	}

	ret	28					; 0000001cH
??0CvPopupInfo@@QAE@W4ButtonPopupTypes@@HHHH_N1@Z ENDP	; CvPopupInfo::CvPopupInfo
_TEXT	ENDS
PUBLIC	??0MissionData@@QAE@XZ				; MissionData::MissionData
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvstructs.h
;	COMDAT ??0MissionData@@QAE@XZ
_TEXT	SEGMENT
??0MissionData@@QAE@XZ PROC				; MissionData::MissionData, COMDAT
; _this$ = ecx

; 48   : 	{

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 49   : 	}

	ret	0
??0MissionData@@QAE@XZ ENDP				; MissionData::MissionData
_TEXT	ENDS
PUBLIC	??3ICvUnknown@@SGXPAX@Z				; ICvUnknown::operator delete
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
;	COMDAT ??3ICvUnknown@@SGXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3ICvUnknown@@SGXPAX@Z PROC				; ICvUnknown::operator delete, COMDAT

; 310  : 		if (p)

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN1@operator

; 311  : 		{
; 312  : 			ICvUnknown* inst = (ICvUnknown*)(p);
; 313  : 			inst->Destroy();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[esp-4], eax
	jmp	edx
$LN1@operator:

; 314  : 		}
; 315  : 	}

	ret	4
??3ICvUnknown@@SGXPAX@Z ENDP				; ICvUnknown::operator delete
_TEXT	ENDS
PUBLIC	??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::operator->
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
;	COMDAT ??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::operator->, COMDAT
; _this$ = ecx

; 40   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 41   : }

	ret	0
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::operator->
_TEXT	ENDS
PUBLIC	?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::get, COMDAT
; _this$ = ecx

; 45   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 46   : }

	ret	0
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::get
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7713 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8568]

; 7714 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::getVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::getVisibilityCount, COMDAT
; _this$ = ecx

; 588  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 589  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 590  : 
; 591  : 		return m_aiVisibilityCount[eTeam];

	mov	eax, DWORD PTR [ecx+156]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 592  : 	}

	ret	4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::getVisibilityCount
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z		; CvMap::plotByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z PROC		; CvMap::plotByIndex, COMDAT
; _this$ = ecx

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	mov	eax, DWORD PTR _iIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@plotByInde
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN3@plotByInde
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 264  : 	}

	ret	4
$LN3@plotByInde:

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	xor	eax, eax

; 264  : 	}

	ret	4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z ENDP		; CvMap::plotByIndex
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Isnil
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 17					; 00000011H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Left
; Function compile flags: /Ogtpy
;	COMDAT ?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Right
; Function compile flags: /Ogtpy
;	COMDAT ?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z ; std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\set
;	COMDAT ?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z PROC ; std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0>::_Kfn, COMDAT

; 45   : 		return (_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 46   : 		}

	ret	0
?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z ENDP ; std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0>::_Kfn
_TEXT	ENDS
PUBLIC	??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z ; std::less<FAutoVariableBase *>::operator()
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
;	COMDAT ??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z PROC ; std::less<FAutoVariableBase *>::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [edx]
	sbb	eax, eax
	neg	eax

; 144  : 		}

	ret	8
??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z ENDP ; std::less<FAutoVariableBase *>::operator()
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Color
; Function compile flags: /Ogtpy
;	COMDAT ?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 16					; 00000010H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rmost
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ ; std::allocator<FAutoVariableBase *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ PROC ; std::allocator<FAutoVariableBase *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ ENDP ; std::allocator<FAutoVariableBase *>::max_size
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z PROC ; std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+12], ecx
	mov	BYTE PTR [eax+16], dl
	mov	BYTE PTR [eax+17], 0

; 39   : 			}

	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z ENDP ; std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Max
; Function compile flags: /Ogtpy
;	COMDAT ?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+17], 0
	jne	SHORT $LN1@Max
	npad	3
$LL2@Max:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+17], 0
	je	SHORT $LL2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Max
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ		; FAutoVariable<char,CvPlot>::operator char const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ
_TEXT	SEGMENT
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ PROC		; FAutoVariable<char,CvPlot>::operator char const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@DVCvPlot@@@@QBEABDXZ ENDP		; FAutoVariable<char,CvPlot>::operator char const &
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T219776 = -12						; size = 12
$T219781 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*4]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T219781[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T219776[esp+16]
	mov	DWORD PTR $T219781[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T219776[esp+16]
	push	ecx
	mov	DWORD PTR $T219776[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z PROC	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 156  : 	{

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx
	mov	BYTE PTR [esi+4], 0

; 157  : 		OBJECT_HANDLE_STACK;
; 158  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@2

; 159  : 		{
; 160  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@2:

; 161  : 		}
; 162  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ENDP	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z PROC ; FObjectHandle<CvUnit>::operator=, COMDAT
; _this$ = ecx

; 165  : 	{

	push	esi
	mov	esi, ecx

; 166  : 		OBJECT_HANDLE_STACK;
; 167  : 		if(m_target)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@operator@2

; 168  : 		{
; 169  : 			m_target->getDestructionNotification().removeTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@operator@2:

; 170  : 		}
; 171  : 		m_target = target;

	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx

; 172  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN9@operator@2

; 173  : 		{
; 174  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@operator@2:

; 175  : 		}
; 176  : 		return *this;

	mov	eax, esi
	pop	esi

; 177  : 	}

	ret	4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ENDP ; FObjectHandle<CvUnit>::operator=
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 222  : 	{

	mov	eax, DWORD PTR _source$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	mov	dl, BYTE PTR [eax+4]
	mov	BYTE PTR [esi+4], dl

; 223  : 		OBJECT_HANDLE_STACK;
; 224  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@3

; 225  : 		{
; 226  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@3:

; 227  : 		}
; 228  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?getAt@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@H@Z ; FFastSmallFixedList<MissionData,12,1,297,0>::getAt
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?getAt@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?getAt@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@H@Z PROC ; FFastSmallFixedList<MissionData,12,1,297,0>::getAt, COMDAT
; _this$ = ecx

; 881  :         if ( (UINT)iIndex < mVec.size() )

	mov	eax, DWORD PTR _iIndex$[esp-4]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN2@getAt

; 882  : #endif
; 883  : 	    {
; 884  : 		    return &mVec[ iIndex ];

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 889  : 	    }
; 890  :     };

	ret	4
$LN2@getAt:

; 885  : 	    }
; 886  : 	    else
; 887  : 	    {
; 888  : 		    return NULL;

	xor	eax, eax

; 889  : 	    }
; 890  :     };

	ret	4
?getAt@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@H@Z ENDP ; FFastSmallFixedList<MissionData,12,1,297,0>::getAt
_TEXT	ENDS
PUBLIC	?getLength@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEHXZ ; FFastSmallFixedList<MissionData,12,1,297,0>::getLength
; Function compile flags: /Ogtpy
;	COMDAT ?getLength@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEHXZ
_TEXT	SEGMENT
?getLength@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEHXZ PROC ; FFastSmallFixedList<MissionData,12,1,297,0>::getLength, COMDAT
; _this$ = ecx

; 962  :         return mVec.size();

	mov	eax, DWORD PTR [ecx+4]

; 963  :     }

	ret	0
?getLength@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEHXZ ENDP ; FFastSmallFixedList<MissionData,12,1,297,0>::getLength
_TEXT	ENDS
PUBLIC	?head@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@XZ ; FFastSmallFixedList<MissionData,12,1,297,0>::head
; Function compile flags: /Ogtpy
;	COMDAT ?head@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@XZ
_TEXT	SEGMENT
?head@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@XZ PROC ; FFastSmallFixedList<MissionData,12,1,297,0>::head, COMDAT
; _this$ = ecx

; 968  :         UINT uSize = mVec.size();
; 969  : 
; 970  :         if( uSize > 0 )

	cmp	DWORD PTR [ecx+4], 0
	jbe	SHORT $LN2@head

; 971  :         {
; 972  :             return &mVec[ 0 ];

	mov	eax, DWORD PTR [ecx]

; 977  :         }
; 978  :     };

	ret	0
$LN2@head:

; 973  :         }
; 974  :         else
; 975  :         {
; 976  :             return NULL;

	xor	eax, eax

; 977  :         }
; 978  :     };

	ret	0
?head@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@XZ ENDP ; FFastSmallFixedList<MissionData,12,1,297,0>::head
_TEXT	ENDS
PUBLIC	?tail@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@XZ ; FFastSmallFixedList<MissionData,12,1,297,0>::tail
; Function compile flags: /Ogtpy
;	COMDAT ?tail@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@XZ
_TEXT	SEGMENT
?tail@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@XZ PROC ; FFastSmallFixedList<MissionData,12,1,297,0>::tail, COMDAT
; _this$ = ecx

; 983  :         UINT uSize = mVec.size();

	mov	eax, DWORD PTR [ecx+4]

; 984  : 
; 985  :         if( uSize > 0 )

	test	eax, eax
	jbe	SHORT $LN2@tail

; 986  :         {
; 987  :             return &mVec[ uSize - 1 ];

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4-20]

; 992  :         }
; 993  :     };

	ret	0
$LN2@tail:

; 988  :         }
; 989  :         else
; 990  :         {
; 991  :             return NULL;

	xor	eax, eax

; 992  :         }
; 993  :     };

	ret	0
?tail@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@XZ ENDP ; FFastSmallFixedList<MissionData,12,1,297,0>::tail
_TEXT	ENDS
PUBLIC	?head@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@XZ ; FFastSmallFixedList<MissionData,12,1,297,0>::head
; Function compile flags: /Ogtpy
;	COMDAT ?head@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@XZ
_TEXT	SEGMENT
?head@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@XZ PROC ; FFastSmallFixedList<MissionData,12,1,297,0>::head, COMDAT
; _this$ = ecx

; 997  :         UINT uSize = mVec.size();
; 998  : 
; 999  :         if( uSize > 0 )

	cmp	DWORD PTR [ecx+4], 0
	jbe	SHORT $LN2@head@2

; 1000 :         {
; 1001 :             return &mVec[ 0];

	mov	eax, DWORD PTR [ecx]

; 1006 :         }
; 1007 :     };

	ret	0
$LN2@head@2:

; 1002 :         }
; 1003 :         else
; 1004 :         {
; 1005 :             return NULL;

	xor	eax, eax

; 1006 :         }
; 1007 :     };

	ret	0
?head@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@XZ ENDP ; FFastSmallFixedList<MissionData,12,1,297,0>::head
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@auto_ptr@2
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@auto_ptr@2:

; 722  : 		}

	ret	0
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	?getAt@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@H@Z ; FFastSmallFixedList<MissionData,12,1,297,0>::getAt
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?getAt@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?getAt@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@H@Z PROC ; FFastSmallFixedList<MissionData,12,1,297,0>::getAt, COMDAT
; _this$ = ecx

; 900  :         if ( (UINT)iIndex < mVec.size() )

	mov	eax, DWORD PTR _iIndex$[esp-4]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN2@getAt@2

; 901  : #endif
; 902  : 	    {
; 903  : 		    return &mVec[ iIndex ];

	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 908  : 	    }
; 909  :     };

	ret	4
$LN2@getAt@2:

; 904  : 	    }
; 905  : 	    else
; 906  : 	    {
; 907  : 		    return NULL;

	xor	eax, eax

; 908  : 	    }
; 909  :     };

	ret	4
?getAt@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@H@Z ENDP ; FFastSmallFixedList<MissionData,12,1,297,0>::getAt
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEXPAUMissionData@@I@Z ; FStaticVector<MissionData,12,1,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEXPAUMissionData@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEXPAUMissionData@@I@Z PROC ; FStaticVector<MissionData,12,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEXPAUMissionData@@I@Z ENDP ; FStaticVector<MissionData,12,1,297,0>::Free
_TEXT	ENDS
PUBLIC	??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ ; std::auto_ptr<ICvPlot1>::operator<ICvPlot1> std::auto_ptr_ref<ICvPlot1>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ PROC ; std::auto_ptr<ICvPlot1>::operator<ICvPlot1> std::auto_ptr_ref<ICvPlot1>, COMDAT
; _this$ = ecx

; 684  : 		{	// convert to compatible auto_ptr_ref
; 685  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 686  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 687  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 688  : 		return (_Ans);
; 689  : 		}

	ret	4
??$?BVICvPlot1@@@?$auto_ptr@VICvPlot1@@@std@@QAE?AU?$auto_ptr_ref@VICvPlot1@@@1@XZ ENDP ; std::auto_ptr<ICvPlot1>::operator<ICvPlot1> std::auto_ptr_ref<ICvPlot1>
_TEXT	ENDS
PUBLIC	?GetID@CvUnit@@QBEHXZ				; CvUnit::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?GetID@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvUnit@@QBEHXZ PROC				; CvUnit::GetID, COMDAT
; _this$ = ecx

; 662  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+100]

; 663  : 	}

	ret	0
?GetID@CvUnit@@QBEHXZ ENDP				; CvUnit::GetID
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
PUBLIC	?IsCombatUnit@CvUnit@@QBE_NXZ			; CvUnit::IsCombatUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsCombatUnit@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?IsCombatUnit@CvUnit@@QBE_NXZ PROC			; CvUnit::IsCombatUnit, COMDAT
; _this$ = ecx

; 1243 : 		return (m_iBaseCombat > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+1044], eax
	setg	al

; 1244 : 	}

	ret	0
?IsCombatUnit@CvUnit@@QBE_NXZ ENDP			; CvUnit::IsCombatUnit
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlayer::getTeam
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayerID$ = 8						; size = 4
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlayer::getTeam, COMDAT

; 1173 : 		return CvPreGame::teamType(ePlayerID);

	mov	eax, DWORD PTR _ePlayerID$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1174 : 	}

	ret	0

; 1173 : 		return CvPreGame::teamType(ePlayerID);

$LN3@getTeam:
	or	eax, -1

; 1174 : 	}

	ret	0
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z		; CvPlot::isVisible
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isVisible, COMDAT
; _this$ = ecx

; 210  : 		if(eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@isVisible

; 211  : 			return false;

	xor	al, al

; 214  : 	}

	ret	4
$LN1@isVisible:

; 212  : 
; 213  : 		return ((getVisibilityCount(eTeam) > 0));

	mov	ecx, DWORD PTR [ecx+156]
	xor	edx, edx
	cmp	WORD PTR [ecx+eax*2], dx
	setg	dl
	mov	al, dl

; 214  : 	}

	ret	4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isVisible
_TEXT	ENDS
PUBLIC	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ		; CvPlot::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ PROC		; CvPlot::getTeam, COMDAT
; _this$ = ecx

; 232  : 		PlayerTypes playerID = getOwner();

	movsx	eax, BYTE PTR [ecx+4]

; 233  : 		if(playerID != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN2@getTeam@2

; 234  : 		{
; 235  : 			return CvPlayer::getTeam(playerID);

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@getTeam@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 240  : 		}
; 241  : 	}

	ret	0
$LN2@getTeam@2:

; 236  : 		}
; 237  : 		else
; 238  : 		{
; 239  : 			return NO_TEAM;

	or	eax, -1

; 240  : 		}
; 241  : 	}

	ret	0
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlot::getTeam
_TEXT	ENDS
PUBLIC	?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ	; CvPlot::getFeatureType
; Function compile flags: /Ogtpy
;	COMDAT ?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ
_TEXT	SEGMENT
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ PROC	; CvPlot::getFeatureType, COMDAT
; _this$ = ecx

; 435  : #ifdef AUI_WARNING_FIXES
; 436  : 		int f = m_eFeatureType;
; 437  : #else
; 438  : 		char f = m_eFeatureType;
; 439  : #endif
; 440  : 		return (FeatureTypes)f;

	movsx	eax, BYTE PTR [ecx+432]

; 441  : 	}

	ret	0
?getFeatureType@CvPlot@@QBE?AW4FeatureTypes@@XZ ENDP	; CvPlot::getFeatureType
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Key
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Root
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+17], 0
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+17], 0
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN43@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN24@Dec
	npad	1
$LL25@Dec:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL25@Dec
$LN24@Dec:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN3@Dec
$LL4@Dec:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN1@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z ; CvUnitMission::CanStartMission
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?canChangeAdmiralPort@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC ; CvUnit::canChangeAdmiralPort
EXTRN	?getMISSION_CHANGE_ADMIRAL_PORT@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_CHANGE_ADMIRAL_PORT
EXTRN	?canBlastTourism@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canBlastTourism
EXTRN	?getMISSION_ONE_SHOT_TOURISM@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_ONE_SHOT_TOURISM
EXTRN	?canGivePolicies@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canGivePolicies
EXTRN	?getMISSION_GIVE_POLICIES@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_GIVE_POLICIES
EXTRN	?canSellExoticGoods@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canSellExoticGoods
EXTRN	?getMISSION_SELL_EXOTIC_GOODS@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SELL_EXOTIC_GOODS
EXTRN	?canChangeTradeUnitHomeCity@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC ; CvUnit::canChangeTradeUnitHomeCity
EXTRN	?getMISSION_CHANGE_TRADE_UNIT_HOME_CITY@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_CHANGE_TRADE_UNIT_HOME_CITY
EXTRN	?canCreateGreatWork@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canCreateGreatWork
EXTRN	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_GREAT_WORK
EXTRN	?canPlunderTradeRoute@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canPlunderTradeRoute
EXTRN	?getMISSION_PLUNDER_TRADE_ROUTE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_PLUNDER_TRADE_ROUTE
EXTRN	?canMakeTradeRoute@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC ; CvUnit::canMakeTradeRoute
EXTRN	?getMISSION_ESTABLISH_TRADE_ROUTE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_ESTABLISH_TRADE_ROUTE
EXTRN	?canLead@CvUnit@@QBEHPBVCvPlot@@H@Z:PROC	; CvUnit::canLead
EXTRN	?getMISSION_LEAD@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_LEAD
EXTRN	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z:PROC ; CvUnit::canBuild
EXTRN	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_BUILD
EXTRN	?canGoldenAge@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canGoldenAge
EXTRN	?getMISSION_GOLDEN_AGE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_GOLDEN_AGE
EXTRN	?CanRemoveHeresy@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC ; CvUnit::CanRemoveHeresy
EXTRN	?getMISSION_REMOVE_HERESY@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_REMOVE_HERESY
EXTRN	?CanEnhanceReligion@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC ; CvUnit::CanEnhanceReligion
EXTRN	?getMISSION_ENHANCE_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_ENHANCE_RELIGION
EXTRN	?CanSpreadReligion@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC ; CvUnit::CanSpreadReligion
EXTRN	?getMISSION_SPREAD_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SPREAD_RELIGION
EXTRN	?CanFoundReligion@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC ; CvUnit::CanFoundReligion
EXTRN	?getMISSION_FOUND_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_FOUND_RELIGION
EXTRN	?CanCultureBomb@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::CanCultureBomb
EXTRN	?getMISSION_CULTURE_BOMB@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_CULTURE_BOMB
EXTRN	?CanBuildSpaceship@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::CanBuildSpaceship
EXTRN	?getMISSION_SPACESHIP@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SPACESHIP
EXTRN	?canBuyCityState@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canBuyCityState
EXTRN	?getMISSION_BUY_CITY_STATE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_BUY_CITY_STATE
EXTRN	?canRepairFleet@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canRepairFleet
EXTRN	?getMISSION_REPAIR_FLEET@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_REPAIR_FLEET
EXTRN	?canTrade@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canTrade
EXTRN	?getMISSION_TRADE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_TRADE
EXTRN	?canHurry@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canHurry
EXTRN	?getMISSION_HURRY@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_HURRY
EXTRN	?canDiscover@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canDiscover
EXTRN	?getMISSION_DISCOVER@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_DISCOVER
EXTRN	?canConstruct@CvUnit@@QBE_NPBVCvPlot@@W4BuildingTypes@@@Z:PROC ; CvUnit::canConstruct
EXTRN	?getMISSION_CONSTRUCT@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_CONSTRUCT
EXTRN	?canJoin@CvUnit@@QBE_NPBVCvPlot@@W4SpecialistTypes@@@Z:PROC ; CvUnit::canJoin
EXTRN	?getMISSION_JOIN@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_JOIN
EXTRN	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canFound
EXTRN	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_FOUND
EXTRN	?canPillage@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canPillage
EXTRN	?getMISSION_PILLAGE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_PILLAGE
EXTRN	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z:PROC	; CvUnit::canRangeStrikeAt
EXTRN	?getMISSION_RANGE_ATTACK@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_RANGE_ATTACK
EXTRN	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z:PROC	; CvUnit::canRebaseAt
EXTRN	?getMISSION_REBASE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_REBASE
EXTRN	?canAirSweepAt@CvUnit@@QBE_NHH@Z:PROC		; CvUnit::canAirSweepAt
EXTRN	?getMISSION_AIR_SWEEP@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_AIR_SWEEP
EXTRN	?canParadropAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z:PROC ; CvUnit::canParadropAt
EXTRN	?getMISSION_PARADROP@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_PARADROP
EXTRN	?canNukeAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z:PROC	; CvUnit::canNukeAt
EXTRN	?getMISSION_NUKE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_NUKE
EXTRN	?canAirliftAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z:PROC	; CvUnit::canAirliftAt
EXTRN	?getMISSION_AIRLIFT@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_AIRLIFT
EXTRN	?canSentry@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canSentry
EXTRN	?getMISSION_ALERT@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_ALERT
EXTRN	?canHeal@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canHeal
EXTRN	?getMISSION_HEAL@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_HEAL
EXTRN	?canAirPatrol@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canAirPatrol
EXTRN	?getMISSION_AIRPATROL@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_AIRPATROL
EXTRN	?canDisembark@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canDisembark
EXTRN	?getMISSION_DISEMBARK@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_DISEMBARK
EXTRN	?canEmbark@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canEmbark
EXTRN	?getMISSION_EMBARK@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_EMBARK
EXTRN	?canSetUpForRangedAttack@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC ; CvUnit::canSetUpForRangedAttack
EXTRN	?getMISSION_SET_UP_FOR_RANGED_ATTACK@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SET_UP_FOR_RANGED_ATTACK
EXTRN	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canFortify
EXTRN	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_FORTIFY
EXTRN	?canSleep@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canSleep
EXTRN	?getMISSION_SLEEP@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SLEEP
EXTRN	?canHold@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canHold
EXTRN	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SKIP
EXTRN	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z:PROC		; CvUnit::atPlot
EXTRN	?IsImmobile@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsImmobile
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
EXTRN	?getMISSION_MOVE_TO_UNIT@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_MOVE_TO_UNIT
EXTRN	?GetBestBuildRoute@CvUnit@@QBE?AW4RouteTypes@@PAVCvPlot@@PAW4BuildTypes@@@Z:PROC ; CvUnit::GetBestBuildRoute
EXTRN	?at@CvPlot@@QBE_NHH@Z:PROC			; CvPlot::at
EXTRN	?getMISSION_ROUTE_TO@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_ROUTE_TO
EXTRN	?getMISSION_SWAP_UNITS@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SWAP_UNITS
EXTRN	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_MOVE_TO
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	?IsBusy@CvUnit@@QBE_NXZ:PROC			; CvUnit::IsBusy
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z$2
__ehfuncinfo$?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z
_TEXT	SEGMENT
_bResult$218411 = -25					; size = 1
_args$218410 = -24					; size = 4
_pTargetUnit$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
_iMission$ = 16						; size = 4
_iData1$ = 20						; size = 4
_iData2$ = 24						; size = 4
_pPlot$ = 28						; size = 4
_bTestVisible$ = 32					; size = 1
?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z PROC ; CvUnitMission::CanStartMission, COMDAT

; 861  : {

	push	-1
	push	__ehhandler$?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+40], ebx

; 862  : 	UnitHandle pTargetUnit;

	mov	DWORD PTR _pTargetUnit$[esp+32], ebx
	mov	BYTE PTR _pTargetUnit$[esp+36], bl

; 863  : 
; 864  : 	if(hUnit->IsBusy())

	mov	ecx, DWORD PTR _hUnit$[esp+28]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	call	?IsBusy@CvUnit@@QBE_NXZ			; CvUnit::IsBusy
	test	al, al
	je	SHORT $LN145@CanStartMi

; 865  : 	{
; 866  : 		return false;

	mov	ecx, DWORD PTR _hUnit$[esp+28]
	mov	DWORD PTR __$EHRec$[esp+40], -1
	cmp	ecx, ebx
	je	SHORT $LN163@CanStartMi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN163@CanStartMi:
	xor	al, al
	pop	ebx

; 1253 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	0
$LN145@CanStartMi:

; 867  : 	}
; 868  : 
; 869  : #ifdef AUI_UNIT_MISSION_FIX_NO_MISSION_ON_DEATH
; 870  : 	if (hUnit->isDelayedDeath())
; 871  : 	{
; 872  : 		return false;
; 873  : 	}
; 874  : #endif
; 875  : 
; 876  : 	// Prevented by scripting?
; 877  : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	push	esi
	push	edi
	call	edx

; 878  : 	if(pkScriptSystem)

	mov	esi, DWORD PTR _iMission$[esp+36]
	mov	edi, eax
	cmp	edi, ebx
	je	$LN144@CanStartMi

; 879  : 	{
; 880  : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$218410[esp+40]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 881  : 		args->Push(hUnit->getOwner());

	mov	eax, DWORD PTR _hUnit$[esp+36]
	mov	eax, DWORD PTR [eax+40]
	mov	ecx, DWORD PTR _args$218410[esp+40]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR __$EHRec$[esp+52], 2
	call	eax

; 882  : 		args->Push(hUnit->GetID());

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	mov	eax, DWORD PTR [ecx+100]
	mov	ecx, DWORD PTR _args$218410[esp+40]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 883  : 		args->Push(iMission);

	mov	ecx, DWORD PTR _args$218410[esp+40]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	esi
	call	eax

; 884  : 
; 885  : 		// Attempt to execute the game events.
; 886  : 		// Will return false if there are no registered listeners.
; 887  : 		bool bResult = false;
; 888  : 		if(LuaSupport::CallTestAll(pkScriptSystem, "CanStartMission", args.get(), bResult))

	mov	edx, DWORD PTR _args$218410[esp+40]
	lea	ecx, DWORD PTR _bResult$218411[esp+40]
	push	ecx
	push	edx
	push	OFFSET $SG218413
	push	edi
	mov	BYTE PTR _bResult$218411[esp+56], 0
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN142@CanStartMi

; 889  : 		{
; 890  : 			// Check the result.
; 891  : 			if(bResult == false)

	cmp	BYTE PTR _bResult$218411[esp+40], 0
	jne	SHORT $LN142@CanStartMi

; 892  : 			{
; 893  : 				return false;

	lea	ecx, DWORD PTR _args$218410[esp+40]
	mov	BYTE PTR __$EHRec$[esp+48], 1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	cmp	ecx, ebx
	je	SHORT $LN195@CanStartMi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN195@CanStartMi:
	pop	edi
	pop	esi
	xor	al, al
	pop	ebx

; 1253 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	0
$LN142@CanStartMi:

; 894  : 			}
; 895  : 		}
; 896  : 	}

	lea	ecx, DWORD PTR _args$218410[esp+40]
	mov	BYTE PTR __$EHRec$[esp+48], 1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN144@CanStartMi:

; 897  : 
; 898  : 	if(pPlot == NULL)

	mov	edi, DWORD PTR _pPlot$[esp+36]
	cmp	edi, ebx
	jne	SHORT $LN141@CanStartMi

; 899  : 	{
; 900  : 		pPlot = hUnit->plot();

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	edi, eax
$LN141@CanStartMi:
	push	ebp

; 901  : 	}
; 902  : 
; 903  : 	if(iMission == CvTypes::getMISSION_MOVE_TO() ||
; 904  : 	        iMission == CvTypes::getMISSION_SWAP_UNITS())

	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	or	ebp, -1
	cmp	esi, eax
	je	$LN139@CanStartMi
	call	?getMISSION_SWAP_UNITS@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SWAP_UNITS
	cmp	esi, eax
	je	$LN139@CanStartMi

; 914  : 		}
; 915  : 	}
; 916  : 	else if(iMission == CvTypes::getMISSION_ROUTE_TO())

	call	?getMISSION_ROUTE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ROUTE_TO
	cmp	esi, eax
	jne	SHORT $LN135@CanStartMi

; 917  : 	{
; 918  : 		if(!(pPlot->at(iData1, iData2)) || (hUnit->GetBestBuildRoute(pPlot) != NO_ROUTE))

	mov	eax, DWORD PTR _iData2$[esp+40]
	mov	ecx, DWORD PTR _iData1$[esp+40]
	push	eax
	push	ecx
	mov	ecx, edi
	call	?at@CvPlot@@QBE_NHH@Z			; CvPlot::at
	test	al, al
	je	SHORT $LN805@CanStartMi
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	0
	push	edi
	call	?GetBestBuildRoute@CvUnit@@QBE?AW4RouteTypes@@PAVCvPlot@@PAW4BuildTypes@@@Z ; CvUnit::GetBestBuildRoute
	cmp	eax, ebp
	je	$LN806@CanStartMi
$LN805@CanStartMi:

; 919  : 		{
; 920  : 			return true;

	mov	DWORD PTR __$EHRec$[esp+52], ebp
	jmp	$LN818@CanStartMi
$LN135@CanStartMi:

; 921  : 		}
; 922  : 	}
; 923  : 	else if(iMission == CvTypes::getMISSION_MOVE_TO_UNIT())

	call	?getMISSION_MOVE_TO_UNIT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO_UNIT
	cmp	esi, eax
	jne	SHORT $LN131@CanStartMi

; 924  : 	{
; 925  : 		CvAssertMsg(iData1 != NO_PLAYER, "iData1 should be a valid Player");
; 926  : 		CvAssertMsg(iData2 != NO_UNIT, "iData2 should be a valid Unit ID");
; 927  : 		if (iData1 != NO_PLAYER && iData2 != NO_UNIT)

	mov	eax, DWORD PTR _iData1$[esp+40]
	cmp	eax, ebp
	je	$LN798@CanStartMi
	mov	ecx, DWORD PTR _iData2$[esp+40]
	cmp	ecx, ebp
	je	$LN798@CanStartMi

; 928  : 		{
; 929  : 			pTargetUnit = GET_PLAYER((PlayerTypes)iData1).getUnit(iData2);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	push	eax
	lea	ecx, DWORD PTR _pTargetUnit$[esp+48]
	call	??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator=

; 930  : 
; 931  : 			if (pTargetUnit->IsImmobile())

	mov	ebx, DWORD PTR _pTargetUnit$[esp+44]
	mov	ecx, ebx
	call	?IsImmobile@CvUnit@@QBE_NXZ		; CvUnit::IsImmobile
	test	al, al

; 932  : 			{
; 933  : 				return false;

	jne	$LN806@CanStartMi

; 934  : 			}
; 935  : 
; 936  : 			if((pTargetUnit) && !(pTargetUnit->atPlot(*pPlot)))

	test	ebx, ebx
	je	$LN815@CanStartMi
	push	edi
	mov	ecx, ebx
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	test	al, al
	jne	$LN806@CanStartMi

; 937  : 			{
; 938  : 				return true;

	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+52], al
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	DWORD PTR __$EHRec$[esp+52], ebp
	jmp	$LN818@CanStartMi
$LN131@CanStartMi:

; 939  : 			}
; 940  : 		}
; 941  : 		else
; 942  : 			return false;
; 943  : 	}
; 944  : 	else if(iMission == CvTypes::getMISSION_SKIP())

	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	cmp	esi, eax
	jne	SHORT $LN125@CanStartMi

; 945  : 	{
; 946  : 		if(hUnit->canHold(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?canHold@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canHold

; 947  : 		{
; 948  : 			return true;

	jmp	$LN820@CanStartMi
$LN125@CanStartMi:

; 949  : 		}
; 950  : 	}
; 951  : 	else if(iMission == CvTypes::getMISSION_SLEEP())

	call	?getMISSION_SLEEP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SLEEP
	cmp	esi, eax
	jne	SHORT $LN122@CanStartMi

; 952  : 	{
; 953  : 		if(hUnit->canSleep(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?canSleep@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canSleep

; 954  : 		{
; 955  : 			return true;

	jmp	$LN820@CanStartMi
$LN122@CanStartMi:

; 956  : 		}
; 957  : 	}
; 958  : 	else if(iMission == CvTypes::getMISSION_FORTIFY())

	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	cmp	esi, eax
	jne	SHORT $LN119@CanStartMi

; 959  : 	{
; 960  : 		if(hUnit->canFortify(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canFortify

; 961  : 		{
; 962  : 			return true;

	jmp	$LN820@CanStartMi
$LN119@CanStartMi:

; 963  : 		}
; 964  : 	}
; 965  : 	else if(iMission == CvTypes::getMISSION_SET_UP_FOR_RANGED_ATTACK())

	call	?getMISSION_SET_UP_FOR_RANGED_ATTACK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SET_UP_FOR_RANGED_ATTACK
	cmp	esi, eax
	jne	SHORT $LN116@CanStartMi

; 966  : 	{
; 967  : 		if(hUnit->canSetUpForRangedAttack(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?canSetUpForRangedAttack@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canSetUpForRangedAttack

; 968  : 		{
; 969  : 			return true;

	jmp	$LN820@CanStartMi
$LN116@CanStartMi:

; 970  : 		}
; 971  : 	}
; 972  : 	else if(iMission == CvTypes::getMISSION_EMBARK())

	call	?getMISSION_EMBARK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_EMBARK
	cmp	esi, eax
	jne	SHORT $LN113@CanStartMi

; 973  : 	{
; 974  : 		if(hUnit->canEmbark(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?canEmbark@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canEmbark

; 975  : 		{
; 976  : 			return true;

	jmp	$LN820@CanStartMi
$LN113@CanStartMi:

; 977  : 		}
; 978  : 	}
; 979  : 	else if(iMission == CvTypes::getMISSION_DISEMBARK())

	call	?getMISSION_DISEMBARK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_DISEMBARK
	cmp	esi, eax
	jne	SHORT $LN110@CanStartMi

; 980  : 	{
; 981  : 		if(hUnit->canDisembark(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?canDisembark@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canDisembark

; 982  : 		{
; 983  : 			return true;

	jmp	$LN820@CanStartMi
$LN110@CanStartMi:

; 984  : 		}
; 985  : 	}
; 986  : 	else if(iMission == CvTypes::getMISSION_AIRPATROL())

	call	?getMISSION_AIRPATROL@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_AIRPATROL
	cmp	esi, eax
	jne	SHORT $LN107@CanStartMi

; 987  : 	{
; 988  : 		if(hUnit->canAirPatrol(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?canAirPatrol@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canAirPatrol

; 989  : 		{
; 990  : 			return true;

	jmp	$LN820@CanStartMi
$LN107@CanStartMi:

; 991  : 		}
; 992  : 	}
; 993  : 	else if(iMission == CvTypes::getMISSION_HEAL())

	call	?getMISSION_HEAL@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_HEAL
	cmp	esi, eax
	jne	SHORT $LN104@CanStartMi

; 994  : 	{
; 995  : 		if(hUnit->canHeal(pPlot, bTestVisible))

	mov	edx, DWORD PTR _bTestVisible$[esp+40]
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edx
	push	edi
	call	?canHeal@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canHeal

; 996  : 		{
; 997  : 			return true;

	jmp	$LN820@CanStartMi
$LN104@CanStartMi:

; 998  : 		}
; 999  : 	}
; 1000 : 	else if(iMission == CvTypes::getMISSION_ALERT())

	call	?getMISSION_ALERT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ALERT
	cmp	esi, eax
	jne	SHORT $LN101@CanStartMi

; 1001 : 	{
; 1002 : 		if(hUnit->canSentry(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?canSentry@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canSentry

; 1003 : 		{
; 1004 : 			return true;

	jmp	$LN820@CanStartMi
$LN101@CanStartMi:

; 1005 : 		}
; 1006 : 	}
; 1007 : 	else if(iMission == CvTypes::getMISSION_AIRLIFT())

	call	?getMISSION_AIRLIFT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_AIRLIFT
	cmp	esi, eax
	jne	SHORT $LN98@CanStartMi

; 1008 : 	{
; 1009 : 		if(hUnit->canAirliftAt(pPlot, iData1, iData2))

	mov	eax, DWORD PTR _iData2$[esp+40]
	mov	ecx, DWORD PTR _iData1$[esp+40]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+48]
	push	edi
	call	?canAirliftAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z ; CvUnit::canAirliftAt

; 1010 : 		{
; 1011 : 			return true;

	jmp	$LN820@CanStartMi
$LN98@CanStartMi:

; 1012 : 		}
; 1013 : 	}
; 1014 : 	else if(iMission == CvTypes::getMISSION_NUKE())

	call	?getMISSION_NUKE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_NUKE
	cmp	esi, eax
	jne	SHORT $LN95@CanStartMi

; 1015 : 	{
; 1016 : 		if(hUnit->canNukeAt(pPlot, iData1, iData2))

	mov	edx, DWORD PTR _iData2$[esp+40]
	mov	eax, DWORD PTR _iData1$[esp+40]
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edx
	push	eax
	push	edi
	call	?canNukeAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z	; CvUnit::canNukeAt

; 1017 : 		{
; 1018 : 			return true;

	jmp	$LN820@CanStartMi
$LN95@CanStartMi:

; 1019 : 		}
; 1020 : 	}
; 1021 : 	else if(iMission == CvTypes::getMISSION_PARADROP())

	call	?getMISSION_PARADROP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_PARADROP
	cmp	esi, eax
	jne	SHORT $LN92@CanStartMi

; 1022 : 	{
; 1023 : 		if(hUnit->canParadropAt(pPlot, iData1, iData2))

	mov	ecx, DWORD PTR _iData2$[esp+40]
	mov	edx, DWORD PTR _iData1$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+44]
	push	edx
	push	edi
	call	?canParadropAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z ; CvUnit::canParadropAt

; 1024 : 		{
; 1025 : 			return true;

	jmp	$LN820@CanStartMi
$LN92@CanStartMi:

; 1026 : 		}
; 1027 : 	}
; 1028 : 	else if(iMission == CvTypes::getMISSION_AIR_SWEEP())

	call	?getMISSION_AIR_SWEEP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_AIR_SWEEP
	cmp	esi, eax
	jne	SHORT $LN89@CanStartMi

; 1029 : 	{
; 1030 : 		if(hUnit->canAirSweepAt(iData1, iData2))

	mov	eax, DWORD PTR _iData2$[esp+40]
	mov	ecx, DWORD PTR _iData1$[esp+40]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+48]
	call	?canAirSweepAt@CvUnit@@QBE_NHH@Z	; CvUnit::canAirSweepAt

; 1031 : 		{
; 1032 : 			return true;

	jmp	$LN820@CanStartMi
$LN89@CanStartMi:

; 1033 : 		}
; 1034 : 	}
; 1035 : 	else if(iMission == CvTypes::getMISSION_REBASE())

	call	?getMISSION_REBASE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_REBASE
	cmp	esi, eax
	jne	SHORT $LN86@CanStartMi

; 1036 : 	{
; 1037 : 		if(hUnit->canRebaseAt(pPlot, iData1, iData2))

	mov	edx, DWORD PTR _iData2$[esp+40]
	mov	eax, DWORD PTR _iData1$[esp+40]
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edx
	push	eax
	push	edi
	call	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z ; CvUnit::canRebaseAt

; 1038 : 		{
; 1039 : 			return true;

	jmp	$LN820@CanStartMi
$LN86@CanStartMi:

; 1040 : 		}
; 1041 : 	}
; 1042 : 	else if(iMission == CvTypes::getMISSION_RANGE_ATTACK())

	call	?getMISSION_RANGE_ATTACK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_RANGE_ATTACK
	cmp	esi, eax
	jne	SHORT $LN83@CanStartMi

; 1043 : 	{
; 1044 : 		if(hUnit->canRangeStrikeAt(iData1, iData2))

	mov	ecx, DWORD PTR _iData2$[esp+40]
	mov	edx, DWORD PTR _iData1$[esp+40]
	push	1
	push	1
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+52]
	push	edx
	call	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z	; CvUnit::canRangeStrikeAt

; 1045 : 		{
; 1046 : 			return true;

	jmp	$LN820@CanStartMi
$LN83@CanStartMi:

; 1047 : 		}
; 1048 : 	}
; 1049 : 	else if(iMission == CvTypes::getMISSION_PILLAGE())

	call	?getMISSION_PILLAGE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_PILLAGE
	cmp	esi, eax
	jne	SHORT $LN80@CanStartMi

; 1050 : 	{
; 1051 : 		if(hUnit->canPillage(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?canPillage@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canPillage

; 1052 : 		{
; 1053 : 			return true;

	jmp	$LN820@CanStartMi
$LN80@CanStartMi:

; 1054 : 		}
; 1055 : 	}
; 1056 : 	else if(iMission == CvTypes::getMISSION_FOUND())

	call	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FOUND
	cmp	esi, eax
	jne	SHORT $LN77@CanStartMi

; 1057 : 	{
; 1058 : 		if(hUnit->canFound(pPlot, bTestVisible))

	mov	eax, DWORD PTR _bTestVisible$[esp+40]
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	eax
	push	edi
	call	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canFound

; 1059 : 		{
; 1060 : 			return true;

	jmp	$LN820@CanStartMi
$LN77@CanStartMi:

; 1061 : 		}
; 1062 : 	}
; 1063 : 	else if(iMission == CvTypes::getMISSION_JOIN())

	call	?getMISSION_JOIN@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_JOIN
	cmp	esi, eax
	jne	SHORT $LN74@CanStartMi

; 1064 : 	{
; 1065 : 		if(hUnit->canJoin(pPlot, ((SpecialistTypes)iData1)))

	mov	ecx, DWORD PTR _iData1$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+44]
	push	edi
	call	?canJoin@CvUnit@@QBE_NPBVCvPlot@@W4SpecialistTypes@@@Z ; CvUnit::canJoin

; 1066 : 		{
; 1067 : 			return true;

	jmp	$LN820@CanStartMi
$LN74@CanStartMi:

; 1068 : 		}
; 1069 : 	}
; 1070 : 	else if(iMission == CvTypes::getMISSION_CONSTRUCT())

	call	?getMISSION_CONSTRUCT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CONSTRUCT
	cmp	esi, eax
	jne	SHORT $LN71@CanStartMi

; 1071 : 	{
; 1072 : 		if(hUnit->canConstruct(pPlot, ((BuildingTypes)iData1)))

	mov	edx, DWORD PTR _iData1$[esp+40]
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edx
	push	edi
	call	?canConstruct@CvUnit@@QBE_NPBVCvPlot@@W4BuildingTypes@@@Z ; CvUnit::canConstruct

; 1073 : 		{
; 1074 : 			return true;

	jmp	$LN820@CanStartMi
$LN71@CanStartMi:

; 1075 : 		}
; 1076 : 	}
; 1077 : 	else if(iMission == CvTypes::getMISSION_DISCOVER())

	call	?getMISSION_DISCOVER@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_DISCOVER
	cmp	esi, eax
	jne	SHORT $LN68@CanStartMi

; 1078 : 	{
; 1079 : 		if(hUnit->canDiscover(pPlot, bTestVisible))

	mov	eax, DWORD PTR _bTestVisible$[esp+40]
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	eax
	push	edi
	call	?canDiscover@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canDiscover

; 1080 : 		{
; 1081 : 			return true;

	jmp	$LN820@CanStartMi
$LN68@CanStartMi:

; 1082 : 		}
; 1083 : 	}
; 1084 : 	else if(iMission == CvTypes::getMISSION_HURRY())

	call	?getMISSION_HURRY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_HURRY
	cmp	esi, eax
	jne	SHORT $LN65@CanStartMi

; 1085 : 	{
; 1086 : 		//if (hUnit->IsCanRushBuilding(pPlot->getPlotCity(), bTestVisible))
; 1087 : 		if(hUnit->canHurry(pPlot, bTestVisible))

	mov	ecx, DWORD PTR _bTestVisible$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+44]
	push	edi
	call	?canHurry@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canHurry

; 1088 : 		{
; 1089 : 			return true;

	jmp	$LN820@CanStartMi
$LN65@CanStartMi:

; 1090 : 		}
; 1091 : 	}
; 1092 : 	else if(iMission == CvTypes::getMISSION_TRADE())

	call	?getMISSION_TRADE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_TRADE
	cmp	esi, eax
	jne	SHORT $LN62@CanStartMi

; 1093 : 	{
; 1094 : 		if(hUnit->canTrade(pPlot, bTestVisible))

	mov	edx, DWORD PTR _bTestVisible$[esp+40]
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edx
	push	edi
	call	?canTrade@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canTrade

; 1095 : 		{
; 1096 : 			return true;

	jmp	$LN820@CanStartMi
$LN62@CanStartMi:

; 1097 : 		}
; 1098 : 	}
; 1099 : 	else if(iMission == CvTypes::getMISSION_REPAIR_FLEET())

	call	?getMISSION_REPAIR_FLEET@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_REPAIR_FLEET
	cmp	esi, eax
	jne	SHORT $LN59@CanStartMi

; 1100 : 	{
; 1101 : 		if(hUnit->canRepairFleet(pPlot, bTestVisible))

	mov	eax, DWORD PTR _bTestVisible$[esp+40]
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	eax
	push	edi
	call	?canRepairFleet@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canRepairFleet

; 1102 : 		{
; 1103 : 			return true;

	jmp	$LN820@CanStartMi
$LN59@CanStartMi:

; 1104 : 		}
; 1105 : 	}
; 1106 : 	else if (iMission == CvTypes::getMISSION_BUY_CITY_STATE())

	call	?getMISSION_BUY_CITY_STATE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUY_CITY_STATE
	cmp	esi, eax
	jne	SHORT $LN56@CanStartMi

; 1107 : 	{
; 1108 : 		if (hUnit->canBuyCityState(pPlot, bTestVisible))

	mov	ecx, DWORD PTR _bTestVisible$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+44]
	push	edi
	call	?canBuyCityState@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canBuyCityState

; 1109 : 		{
; 1110 : 			return true;

	jmp	$LN820@CanStartMi
$LN56@CanStartMi:

; 1111 : 		}
; 1112 : 	}
; 1113 : 	else if(iMission == CvTypes::getMISSION_SPACESHIP())

	call	?getMISSION_SPACESHIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPACESHIP
	cmp	esi, eax
	jne	SHORT $LN53@CanStartMi

; 1114 : 	{
; 1115 : 		if(hUnit->CanBuildSpaceship(pPlot, bTestVisible))

	mov	edx, DWORD PTR _bTestVisible$[esp+40]
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edx
	push	edi
	call	?CanBuildSpaceship@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::CanBuildSpaceship

; 1116 : 		{
; 1117 : 			return true;

	jmp	$LN820@CanStartMi
$LN53@CanStartMi:

; 1118 : 		}
; 1119 : 	}
; 1120 : 	else if(iMission == CvTypes::getMISSION_CULTURE_BOMB())

	call	?getMISSION_CULTURE_BOMB@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CULTURE_BOMB
	cmp	esi, eax
	jne	SHORT $LN50@CanStartMi

; 1121 : 	{
; 1122 : 		if(hUnit->CanCultureBomb(pPlot, bTestVisible))

	mov	eax, DWORD PTR _bTestVisible$[esp+40]
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	eax
	push	edi
	call	?CanCultureBomb@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::CanCultureBomb

; 1123 : 		{
; 1124 : 			return true;

	jmp	$LN820@CanStartMi
$LN50@CanStartMi:

; 1125 : 		}
; 1126 : 	}
; 1127 : 	else if(iMission == CvTypes::getMISSION_FOUND_RELIGION())

	call	?getMISSION_FOUND_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FOUND_RELIGION
	cmp	esi, eax
	jne	SHORT $LN47@CanStartMi

; 1128 : 	{
; 1129 : 		if(hUnit->CanFoundReligion(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?CanFoundReligion@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::CanFoundReligion

; 1130 : 		{
; 1131 : 			return true;

	jmp	$LN820@CanStartMi
$LN47@CanStartMi:

; 1132 : 		}
; 1133 : 	}
; 1134 : 	else if(iMission == CvTypes::getMISSION_SPREAD_RELIGION())

	call	?getMISSION_SPREAD_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPREAD_RELIGION
	cmp	esi, eax
	jne	SHORT $LN44@CanStartMi

; 1135 : 	{
; 1136 : 		if(hUnit->CanSpreadReligion(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?CanSpreadReligion@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::CanSpreadReligion

; 1137 : 		{
; 1138 : 			return true;

	jmp	$LN820@CanStartMi
$LN44@CanStartMi:

; 1139 : 		}
; 1140 : 	}
; 1141 : 	else if(iMission == CvTypes::getMISSION_ENHANCE_RELIGION())

	call	?getMISSION_ENHANCE_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ENHANCE_RELIGION
	cmp	esi, eax
	jne	SHORT $LN41@CanStartMi

; 1142 : 	{
; 1143 : 		if(hUnit->CanEnhanceReligion(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?CanEnhanceReligion@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::CanEnhanceReligion

; 1144 : 		{
; 1145 : 			return true;

	jmp	$LN820@CanStartMi
$LN41@CanStartMi:

; 1146 : 		}
; 1147 : 	}
; 1148 : 	else if(iMission == CvTypes::getMISSION_REMOVE_HERESY())

	call	?getMISSION_REMOVE_HERESY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_REMOVE_HERESY
	cmp	esi, eax
	jne	SHORT $LN38@CanStartMi

; 1149 : 	{
; 1150 : 		if(hUnit->CanRemoveHeresy(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?CanRemoveHeresy@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::CanRemoveHeresy

; 1151 : 		{
; 1152 : 			return true;

	jmp	$LN820@CanStartMi
$LN38@CanStartMi:

; 1153 : 		}
; 1154 : 	}
; 1155 : 	else if(iMission == CvTypes::getMISSION_GOLDEN_AGE())

	call	?getMISSION_GOLDEN_AGE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GOLDEN_AGE
	cmp	esi, eax
	jne	SHORT $LN35@CanStartMi

; 1156 : 	{
; 1157 : 		//this means to play the animation only
; 1158 : 		if(iData1 != -1)

	cmp	DWORD PTR _iData1$[esp+40], ebp
	je	SHORT $LN34@CanStartMi

; 1159 : 		{
; 1160 : 			return true;

	mov	DWORD PTR __$EHRec$[esp+52], ebp
	jmp	$LN818@CanStartMi
$LN34@CanStartMi:

; 1161 : 		}
; 1162 : 
; 1163 : 		if(hUnit->canGoldenAge(pPlot, bTestVisible))

	mov	ecx, DWORD PTR _bTestVisible$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+44]
	push	edi
	call	?canGoldenAge@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canGoldenAge
	test	al, al
	je	$LN806@CanStartMi

; 1164 : 		{
; 1165 : 			return true;

	mov	DWORD PTR __$EHRec$[esp+52], ebp
	jmp	$LN818@CanStartMi
$LN35@CanStartMi:

; 1166 : 		}
; 1167 : 	}
; 1168 : 	else if(iMission == CvTypes::getMISSION_BUILD())

	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	cmp	esi, eax
	jne	SHORT $LN31@CanStartMi

; 1169 : 	{
; 1170 : 		CvAssertMsg(((BuildTypes)iData1) < GC.getNumBuildInfos(), "Invalid Build");
; 1171 : 		if(hUnit->canBuild(pPlot, ((BuildTypes)iData1), bTestVisible))

	mov	edx, DWORD PTR _bTestVisible$[esp+40]
	mov	eax, DWORD PTR _iData1$[esp+40]
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	1
	push	edx
	push	eax
	push	edi
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild

; 1172 : 		{
; 1173 : 			return true;

	jmp	$LN820@CanStartMi
$LN31@CanStartMi:

; 1174 : 		}
; 1175 : 	}
; 1176 : 	else if(iMission == CvTypes::getMISSION_LEAD())

	call	?getMISSION_LEAD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_LEAD
	cmp	esi, eax
	jne	SHORT $LN28@CanStartMi

; 1177 : 	{
; 1178 : 		if(hUnit->canLead(pPlot, iData1))

	mov	ecx, DWORD PTR _iData1$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+44]
	push	edi
	call	?canLead@CvUnit@@QBEHPBVCvPlot@@H@Z	; CvUnit::canLead
	test	eax, eax

; 1179 : 		{
; 1180 : 			return true;

	jmp	$LN821@CanStartMi
$LN28@CanStartMi:

; 1181 : 		}
; 1182 : 	}
; 1183 : 	else if (iMission == CvTypes::getMISSION_ESTABLISH_TRADE_ROUTE())

	call	?getMISSION_ESTABLISH_TRADE_ROUTE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ESTABLISH_TRADE_ROUTE
	cmp	esi, eax
	jne	SHORT $LN25@CanStartMi

; 1184 : 	{
; 1185 : 		if (hUnit->canMakeTradeRoute(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?canMakeTradeRoute@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canMakeTradeRoute

; 1186 : 		{
; 1187 : 			return true;

	jmp	$LN820@CanStartMi
$LN25@CanStartMi:

; 1188 : 		}
; 1189 : 	}
; 1190 : 	else if (iMission == CvTypes::getMISSION_PLUNDER_TRADE_ROUTE())

	call	?getMISSION_PLUNDER_TRADE_ROUTE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_PLUNDER_TRADE_ROUTE
	cmp	esi, eax
	jne	SHORT $LN22@CanStartMi

; 1191 : 	{
; 1192 : 		if (hUnit->canPlunderTradeRoute(pPlot, bTestVisible))

	mov	edx, DWORD PTR _bTestVisible$[esp+40]
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edx
	push	edi
	call	?canPlunderTradeRoute@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canPlunderTradeRoute

; 1193 : 		{
; 1194 : 			return true;

	jmp	$LN820@CanStartMi
$LN22@CanStartMi:

; 1195 : 		}
; 1196 : 	}
; 1197 : 	else if (iMission == CvTypes::getMISSION_GREAT_WORK())

	call	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GREAT_WORK
	cmp	esi, eax
	jne	SHORT $LN19@CanStartMi

; 1198 : 	{
; 1199 : 		if (hUnit->canCreateGreatWork(pPlot, bTestVisible))

	mov	eax, DWORD PTR _bTestVisible$[esp+40]
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	eax
	push	edi
	call	?canCreateGreatWork@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canCreateGreatWork

; 1200 : 		{
; 1201 : 			return true;

	jmp	$LN820@CanStartMi
$LN19@CanStartMi:

; 1202 : 		}
; 1203 : 	}
; 1204 : 	else if (iMission == CvTypes::getMISSION_CHANGE_TRADE_UNIT_HOME_CITY())

	call	?getMISSION_CHANGE_TRADE_UNIT_HOME_CITY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CHANGE_TRADE_UNIT_HOME_CITY
	cmp	esi, eax
	jne	SHORT $LN16@CanStartMi

; 1205 : 	{
; 1206 : 		if (hUnit->canChangeTradeUnitHomeCity(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?canChangeTradeUnitHomeCity@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canChangeTradeUnitHomeCity

; 1207 : 		{
; 1208 : 			return true;

	jmp	$LN820@CanStartMi
$LN16@CanStartMi:

; 1209 : 		}
; 1210 : 	}
; 1211 : 	else if (iMission == CvTypes::getMISSION_SELL_EXOTIC_GOODS())

	call	?getMISSION_SELL_EXOTIC_GOODS@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SELL_EXOTIC_GOODS
	cmp	esi, eax
	jne	SHORT $LN13@CanStartMi

; 1212 : 	{
; 1213 : 		if (hUnit->canSellExoticGoods(pPlot, bTestVisible))

	mov	ecx, DWORD PTR _bTestVisible$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+44]
	push	edi
	call	?canSellExoticGoods@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canSellExoticGoods

; 1214 : 		{
; 1215 : 			return true;

	jmp	SHORT $LN820@CanStartMi
$LN13@CanStartMi:

; 1216 : 		}
; 1217 : 	}
; 1218 : 	else if(iMission == CvTypes::getMISSION_GIVE_POLICIES())

	call	?getMISSION_GIVE_POLICIES@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GIVE_POLICIES
	cmp	esi, eax
	jne	SHORT $LN10@CanStartMi

; 1219 : 	{
; 1220 : 		//this means to play the animation only
; 1221 : 		if(iData1 != -1)
; 1222 : 		{
; 1223 : 			return true;

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	cmp	DWORD PTR _iData1$[esp+40], ebp
	je	SHORT $LN9@CanStartMi
	mov	DWORD PTR __$EHRec$[esp+52], ebp
	jmp	SHORT $LN819@CanStartMi
$LN9@CanStartMi:

; 1224 : 		}
; 1225 : 
; 1226 : 		if(hUnit->canGivePolicies(pPlot, bTestVisible))

	mov	edx, DWORD PTR _bTestVisible$[esp+40]
	push	edx
	push	edi
	call	?canGivePolicies@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canGivePolicies
	test	al, al
	je	$LN806@CanStartMi

; 1227 : 		{
; 1228 : 			return true;

	mov	DWORD PTR __$EHRec$[esp+52], ebp
	jmp	SHORT $LN818@CanStartMi
$LN10@CanStartMi:

; 1229 : 		}
; 1230 : 	}
; 1231 : 	else if(iMission == CvTypes::getMISSION_ONE_SHOT_TOURISM())

	call	?getMISSION_ONE_SHOT_TOURISM@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ONE_SHOT_TOURISM
	cmp	esi, eax
	jne	SHORT $LN6@CanStartMi

; 1232 : 	{
; 1233 : 		//this means to play the animation only
; 1234 : 		if(iData1 != -1)
; 1235 : 		{
; 1236 : 			return true;

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	cmp	DWORD PTR _iData1$[esp+40], ebp
	je	SHORT $LN5@CanStartMi
	mov	DWORD PTR __$EHRec$[esp+52], ebp
	jmp	SHORT $LN819@CanStartMi
$LN5@CanStartMi:

; 1237 : 		}
; 1238 : 
; 1239 : 		if(hUnit->canBlastTourism(pPlot, bTestVisible))

	mov	eax, DWORD PTR _bTestVisible$[esp+40]
	push	eax
	push	edi
	call	?canBlastTourism@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canBlastTourism
	test	al, al
	je	$LN806@CanStartMi

; 1240 : 		{
; 1241 : 			return true;

	mov	DWORD PTR __$EHRec$[esp+52], ebp
	jmp	SHORT $LN818@CanStartMi
$LN6@CanStartMi:

; 1242 : 		}
; 1243 : 	}
; 1244 : 	else if (iMission == CvTypes::getMISSION_CHANGE_ADMIRAL_PORT())

	call	?getMISSION_CHANGE_ADMIRAL_PORT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CHANGE_ADMIRAL_PORT
	cmp	esi, eax
	jne	SHORT $LN806@CanStartMi

; 1245 : 	{
; 1246 : 		if (hUnit->canChangeAdmiralPort(pPlot))

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edi
	call	?canChangeAdmiralPort@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::canChangeAdmiralPort
$LN820@CanStartMi:
	test	al, al
$LN821@CanStartMi:
	je	SHORT $LN806@CanStartMi
$LN817@CanStartMi:

; 1247 : 		{
; 1248 : 			return true;

	mov	DWORD PTR __$EHRec$[esp+52], -1
$LN818@CanStartMi:
	mov	ecx, DWORD PTR _hUnit$[esp+40]
$LN819@CanStartMi:
	test	ecx, ecx
	je	SHORT $LN221@CanStartMi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 912  : 		{
; 913  : 			return true;

$LN221@CanStartMi:
	pop	ebp
	pop	edi
	pop	esi

; 1247 : 		{
; 1248 : 			return true;

	mov	al, 1
	pop	ebx

; 1253 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	0
$LN139@CanStartMi:

; 905  : 	{
; 906  : 		if (hUnit->IsImmobile() && hUnit->getDomainType() != DOMAIN_AIR)	// If immobile, we can't move... unless we are an air unit.

	mov	ecx, DWORD PTR _hUnit$[esp+40]
	call	?IsImmobile@CvUnit@@QBE_NXZ		; CvUnit::IsImmobile
	test	al, al
	je	SHORT $LN138@CanStartMi
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN138@CanStartMi

; 907  : 		{
; 908  : 			return false;

	mov	DWORD PTR __$EHRec$[esp+52], -1
	jmp	SHORT $LN816@CanStartMi
$LN138@CanStartMi:

; 909  : 		}
; 910  : 
; 911  : 		if(!(pPlot->at(iData1, iData2)))

	mov	ecx, DWORD PTR _iData2$[esp+40]
	mov	edx, DWORD PTR _iData1$[esp+40]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?at@CvPlot@@QBE_NHH@Z			; CvPlot::at
	test	al, al

; 912  : 		{
; 913  : 			return true;

	je	SHORT $LN817@CanStartMi
$LN806@CanStartMi:

; 1249 : 		}
; 1250 : 	}
; 1251 : 
; 1252 : 	return false;

	test	ebx, ebx
$LN815@CanStartMi:
	mov	BYTE PTR __$EHRec$[esp+52], 0
	je	SHORT $LN798@CanStartMi
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN798@CanStartMi:
	mov	DWORD PTR __$EHRec$[esp+52], ebp
$LN816@CanStartMi:
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	test	ecx, ecx
	je	SHORT $LN803@CanStartMi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN803@CanStartMi:

; 1253 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	ebp
	pop	edi
	pop	esi
	xor	al, al
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z$1:
	lea	ecx, DWORD PTR _pTargetUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z$2:
	lea	ecx, DWORD PTR _args$218410[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CanStartMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@HHHPAVCvPlot@@_N@Z ENDP ; CvUnitMission::CanStartMission
PUBLIC	?DeactivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::DeactivateHeadMission
EXTRN	?isOption@CvPlayer@@QBE_NW4PlayerOptionTypes@@@Z:PROC ; CvPlayer::isOption
EXTRN	?IsSelected@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsSelected
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?SetMissionTimer@CvUnit@@QAEXH@Z:PROC		; CvUnit::SetMissionTimer
EXTRN	?SetActivityType@CvUnit@@QAEXW4ActivityTypes@@@Z:PROC ; CvUnit::SetActivityType
EXTRN	?GetActivityType@CvUnit@@QBE?AW4ActivityTypes@@XZ:PROC ; CvUnit::GetActivityType
EXTRN	?GetLengthMissionQueue@CvUnit@@QBEHXZ:PROC	; CvUnit::GetLengthMissionQueue
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?DeactivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DeactivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@H@Z$0
__ehfuncinfo$?DeactivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DeactivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?DeactivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@H@Z
_TEXT	SEGMENT
$T221600 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
_iUnitCycleTimer$ = 16					; size = 4
?DeactivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@H@Z PROC ; CvUnitMission::DeactivateHeadMission, COMDAT

; 1978 : {

	push	-1
	push	__ehhandler$?DeactivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 1979 : 	VALIDATE_OBJECT
; 1980 : 	CvAssert(hUnit->getOwner() != NO_PLAYER);
; 1981 : 
; 1982 : 	if(hUnit->GetLengthMissionQueue() != 0)

	mov	ecx, DWORD PTR _hUnit$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0
	call	?GetLengthMissionQueue@CvUnit@@QBEHXZ	; CvUnit::GetLengthMissionQueue
	test	eax, eax
	je	$LN2@Deactivate

; 1983 : 	{
; 1984 : 		if(hUnit->GetActivityType() == ACTIVITY_MISSION)

	mov	ecx, DWORD PTR _hUnit$[esp+12]
	call	?GetActivityType@CvUnit@@QBE?AW4ActivityTypes@@XZ ; CvUnit::GetActivityType
	cmp	eax, 6
	jne	SHORT $LN4@Deactivate

; 1985 : 		{
; 1986 : 			hUnit->SetActivityType(ACTIVITY_AWAKE);

	mov	ecx, DWORD PTR _hUnit$[esp+12]
	push	0
	call	?SetActivityType@CvUnit@@QAEXW4ActivityTypes@@@Z ; CvUnit::SetActivityType
$LN4@Deactivate:

; 1987 : 		}
; 1988 : 
; 1989 : 		hUnit->SetMissionTimer(0);

	mov	ecx, DWORD PTR _hUnit$[esp+12]
	push	esi
	push	0
	call	?SetMissionTimer@CvUnit@@QAEXH@Z	; CvUnit::SetMissionTimer

; 1990 : 
; 1991 : 		if(hUnit->getOwner() == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR _hUnit$[esp+16]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [eax+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	pop	esi
	jne	SHORT $LN2@Deactivate

; 1992 : 		{
; 1993 : 			if(hUnit->IsSelected())

	mov	ecx, DWORD PTR _hUnit$[esp+12]
	call	?IsSelected@CvUnit@@QBE_NXZ		; CvUnit::IsSelected
	test	al, al
	je	SHORT $LN2@Deactivate

; 1994 : 			{
; 1995 : 				if(GET_PLAYER(hUnit->getOwner()).isOption(PLAYEROPTION_QUICK_MOVES))

	mov	ecx, DWORD PTR _hUnit$[esp+12]
	mov	eax, DWORD PTR [ecx+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	3
	mov	ecx, eax
	call	?isOption@CvPlayer@@QBE_NW4PlayerOptionTypes@@@Z ; CvPlayer::isOption
	test	al, al
	je	SHORT $LN46@Deactivate

; 1996 : 					iUnitCycleTimer = min(1, iUnitCycleTimer);

	mov	eax, 1
	cmp	DWORD PTR _iUnitCycleTimer$[esp+12], eax
	mov	DWORD PTR $T221600[esp+16], eax
	lea	eax, DWORD PTR _iUnitCycleTimer$[esp+12]
	jl	SHORT $LN38@Deactivate
	lea	eax, DWORD PTR $T221600[esp+16]
$LN38@Deactivate:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN1@Deactivate
$LN46@Deactivate:
	mov	eax, DWORD PTR _iUnitCycleTimer$[esp+12]
$LN1@Deactivate:

; 1997 : 
; 1998 : 				GC.GetEngineUserInterface()->changeCycleSelectionCounter(iUnitCycleTimer);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+224]
	call	eax
$LN2@Deactivate:

; 1999 : 			}
; 2000 : 		}
; 2001 : 	}
; 2002 : }

	mov	ecx, DWORD PTR _hUnit$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], -1
	test	ecx, ecx
	je	SHORT $LN44@Deactivate
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN44@Deactivate:
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DeactivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@H@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?DeactivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?DeactivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DeactivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@H@Z ENDP ; CvUnitMission::DeactivateHeadMission
PUBLIC	?HeadMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z ; CvUnitMission::HeadMissionQueueNode
; Function compile flags: /Ogtpy
;	COMDAT ?HeadMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
_kQueue$ = 8						; size = 4
?HeadMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z PROC ; CvUnitMission::HeadMissionQueueNode, COMDAT

; 2022 : 	return kQueue.head();

	mov	eax, DWORD PTR _kQueue$[esp-4]
	cmp	DWORD PTR [eax+4], 0
	jbe	SHORT $LN4@HeadMissio
	mov	eax, DWORD PTR [eax]

; 2023 : }

	ret	0

; 2022 : 	return kQueue.head();

$LN4@HeadMissio:
	xor	eax, eax

; 2023 : }

	ret	0
?HeadMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z ENDP ; CvUnitMission::HeadMissionQueueNode
_TEXT	ENDS
PUBLIC	?HeadMissionQueueNode@CvUnitMission@@CAPAUMissionData@@AAV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z ; CvUnitMission::HeadMissionQueueNode
; Function compile flags: /Ogtpy
;	COMDAT ?HeadMissionQueueNode@CvUnitMission@@CAPAUMissionData@@AAV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
_kQueue$ = 8						; size = 4
?HeadMissionQueueNode@CvUnitMission@@CAPAUMissionData@@AAV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z PROC ; CvUnitMission::HeadMissionQueueNode, COMDAT

; 2029 : 	return kQueue.head();

	mov	eax, DWORD PTR _kQueue$[esp-4]
	cmp	DWORD PTR [eax+4], 0
	jbe	SHORT $LN4@HeadMissio@2
	mov	eax, DWORD PTR [eax]

; 2030 : }

	ret	0

; 2029 : 	return kQueue.head();

$LN4@HeadMissio@2:
	xor	eax, eax

; 2030 : }

	ret	0
?HeadMissionQueueNode@CvUnitMission@@CAPAUMissionData@@AAV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z ENDP ; CvUnitMission::HeadMissionQueueNode
_TEXT	ENDS
PUBLIC	?TailMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z ; CvUnitMission::TailMissionQueueNode
; Function compile flags: /Ogtpy
;	COMDAT ?TailMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
_kQueue$ = 8						; size = 4
?TailMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z PROC ; CvUnitMission::TailMissionQueueNode, COMDAT

; 2036 : 	return ((MissionQueue&)kQueue).tail();

	mov	ecx, DWORD PTR _kQueue$[esp-4]
	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jbe	SHORT $LN4@TailMissio
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4-20]

; 2037 : }

	ret	0

; 2036 : 	return ((MissionQueue&)kQueue).tail();

$LN4@TailMissio:
	xor	eax, eax

; 2037 : }

	ret	0
?TailMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z ENDP ; CvUnitMission::TailMissionQueueNode
_TEXT	ENDS
PUBLIC	?TailMissionQueueNode@CvUnitMission@@CAPAUMissionData@@AAV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z ; CvUnitMission::TailMissionQueueNode
; Function compile flags: /Ogtpy
;	COMDAT ?TailMissionQueueNode@CvUnitMission@@CAPAUMissionData@@AAV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
_kQueue$ = 8						; size = 4
?TailMissionQueueNode@CvUnitMission@@CAPAUMissionData@@AAV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z PROC ; CvUnitMission::TailMissionQueueNode, COMDAT

; 2043 : 	return kQueue.tail();

	mov	ecx, DWORD PTR _kQueue$[esp-4]
	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jbe	SHORT $LN4@TailMissio@2
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4-20]

; 2044 : }

	ret	0

; 2043 : 	return kQueue.tail();

$LN4@TailMissio@2:
	xor	eax, eax

; 2044 : }

	ret	0
?TailMissionQueueNode@CvUnitMission@@CAPAUMissionData@@AAV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z ENDP ; CvUnitMission::TailMissionQueueNode
_TEXT	ENDS
PUBLIC	?GetMissionFromQueue@CvUnitMission@@CAPAUMissionData@@AAV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@H@Z ; CvUnitMission::GetMissionFromQueue
; Function compile flags: /Ogtpy
;	COMDAT ?GetMissionFromQueue@CvUnitMission@@CAPAUMissionData@@AAV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@H@Z
_TEXT	SEGMENT
_kQueue$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?GetMissionFromQueue@CvUnitMission@@CAPAUMissionData@@AAV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@H@Z PROC ; CvUnitMission::GetMissionFromQueue, COMDAT

; 2050 : 	return kQueue.getAt(iIndex);

	mov	eax, DWORD PTR _iIndex$[esp-4]
	mov	ecx, DWORD PTR _kQueue$[esp-4]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN4@GetMission
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 2051 : }

	ret	0

; 2050 : 	return kQueue.getAt(iIndex);

$LN4@GetMission:
	xor	eax, eax

; 2051 : }

	ret	0
?GetMissionFromQueue@CvUnitMission@@CAPAUMissionData@@AAV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@H@Z ENDP ; CvUnitMission::GetMissionFromQueue
_TEXT	ENDS
PUBLIC	?GetLengthMissionQueue@CvUnitMission@@CAHABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z ; CvUnitMission::GetLengthMissionQueue
; Function compile flags: /Ogtpy
;	COMDAT ?GetLengthMissionQueue@CvUnitMission@@CAHABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
_kQueue$ = 8						; size = 4
?GetLengthMissionQueue@CvUnitMission@@CAHABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z PROC ; CvUnitMission::GetLengthMissionQueue, COMDAT

; 2057 : 	return kQueue.getLength();

	mov	eax, DWORD PTR _kQueue$[esp-4]
	mov	eax, DWORD PTR [eax+4]

; 2058 : }

	ret	0
?GetLengthMissionQueue@CvUnitMission@@CAHABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z ENDP ; CvUnitMission::GetLengthMissionQueue
_TEXT	ENDS
PUBLIC	?GetHeadMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvUnitMission::GetHeadMissionData
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetHeadMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetHeadMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@@Z$0
__ehfuncinfo$?GetHeadMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetHeadMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?GetHeadMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
?GetHeadMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvUnitMission::GetHeadMissionData, COMDAT

; 2062 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GetHeadMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi

; 2063 : 	CvAssert(hUnit.pointer() != NULL);
; 2064 : 	if(hUnit->m_missionQueue.getLength())

	mov	ecx, DWORD PTR _hUnit$[esp+12]
	mov	eax, DWORD PTR [ecx+2604]
	test	eax, eax
	je	SHORT $LN1@GetHeadMis

; 2065 : 		return (hUnit->m_missionQueue.head());

	jbe	SHORT $LN14@GetHeadMis
	mov	esi, DWORD PTR [ecx+2600]
	mov	DWORD PTR __$EHRec$[esp+24], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	eax, esi

; 2067 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0

; 2065 : 		return (hUnit->m_missionQueue.head());

$LN14@GetHeadMis:
	xor	esi, esi
	mov	DWORD PTR __$EHRec$[esp+24], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	eax, esi

; 2067 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
$LN1@GetHeadMis:

; 2066 : 	return NULL;

	mov	DWORD PTR __$EHRec$[esp+24], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 2067 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetHeadMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetHeadMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetHeadMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetHeadMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvUnitMission::GetHeadMissionData
PUBLIC	?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::IsHeadMission
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z$0
__ehfuncinfo$?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
_iMission$ = 16						; size = 4
?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z PROC ; CvUnitMission::IsHeadMission, COMDAT

; 2071 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi

; 2072 : 	CvAssert(hUnit.pointer() != NULL);
; 2073 : 	if(hUnit->m_missionQueue.getLength())

	mov	ecx, DWORD PTR _hUnit$[esp+12]
	mov	eax, DWORD PTR [ecx+2604]
	test	eax, eax
	je	SHORT $LN1@IsHeadMiss

; 2074 : 	{
; 2075 : 		const MissionData& kMissionData = *hUnit->m_missionQueue.head();

	jbe	SHORT $LN15@IsHeadMiss
	mov	esi, DWORD PTR [ecx+2600]
	jmp	SHORT $LN14@IsHeadMiss
$LN15@IsHeadMiss:
	xor	esi, esi
$LN14@IsHeadMiss:

; 2076 : 		if(kMissionData.eMissionType == (MissionTypes)iMission)

	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR _iMission$[esp+12]
	jne	SHORT $LN1@IsHeadMiss

; 2077 : 			return &kMissionData;

	mov	DWORD PTR __$EHRec$[esp+24], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	eax, esi

; 2080 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
$LN1@IsHeadMiss:

; 2078 : 	}
; 2079 : 	return NULL;

	mov	DWORD PTR __$EHRec$[esp+24], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 2080 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsHeadMission@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z ENDP ; CvUnitMission::IsHeadMission
PUBLIC	?HasCompletedMoveMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@@Z ; CvUnitMission::HasCompletedMoveMission
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?HasCompletedMoveMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?HasCompletedMoveMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?HasCompletedMoveMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@@Z$1
__ehfuncinfo$?HasCompletedMoveMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?HasCompletedMoveMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?HasCompletedMoveMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_pTargetUnit$218981 = -20				; size = 8
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
?HasCompletedMoveMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvUnitMission::HasCompletedMoveMission, COMDAT

; 2085 : {

	push	-1
	push	__ehhandler$?HasCompletedMoveMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2086 : 	MissionQueueNode* pkMissionNode;
; 2087 : 	if((pkMissionNode = HeadMissionQueueNode(hUnit->m_missionQueue)) != NULL)

	mov	ecx, DWORD PTR _hUnit$[esp+32]
	cmp	DWORD PTR [ecx+2604], 0
	mov	DWORD PTR __$EHRec$[esp+44], 0
	jbe	$LN1@HasComplet
	mov	esi, DWORD PTR [ecx+2600]
	test	esi, esi
	je	$LN1@HasComplet

; 2088 : 	{
; 2089 : 		MissionData& kMissionData = *pkMissionNode;
; 2090 : 		if((kMissionData.eMissionType == CvTypes::getMISSION_MOVE_TO()) ||
; 2091 : 		        (kMissionData.eMissionType == CvTypes::getMISSION_ROUTE_TO()) ||
; 2092 : 		        (kMissionData.eMissionType == CvTypes::getMISSION_MOVE_TO_UNIT()))

	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	cmp	DWORD PTR [esi], eax
	je	SHORT $LN6@HasComplet
	call	?getMISSION_ROUTE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ROUTE_TO
	cmp	DWORD PTR [esi], eax
	je	SHORT $LN6@HasComplet
	call	?getMISSION_MOVE_TO_UNIT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO_UNIT
	cmp	DWORD PTR [esi], eax
	jne	$LN106@HasComplet
$LN6@HasComplet:

; 2093 : 		{
; 2094 : 			CvPlot* pTargetPlot = NULL;
; 2095 : 
; 2096 : 			if(kMissionData.eMissionType == CvTypes::getMISSION_MOVE_TO_UNIT())

	call	?getMISSION_MOVE_TO_UNIT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO_UNIT
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN5@HasComplet

; 2097 : 			{
; 2098 : 				UnitHandle pTargetUnit = GET_PLAYER((PlayerTypes)kMissionData.iData1).getUnit(kMissionData.iData2);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pTargetUnit$218981[esp+36], esi
	mov	BYTE PTR _pTargetUnit$218981[esp+40], 0
	test	esi, esi
	je	SHORT $LN30@HasComplet
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN30@HasComplet:
	mov	BYTE PTR __$EHRec$[esp+44], 1

; 2099 : 				if(pTargetUnit)

	test	esi, esi
	je	SHORT $LN4@HasComplet

; 2100 : 				{
; 2101 : 					pTargetPlot = pTargetUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 2106 : 				}
; 2107 : 			}

	mov	ecx, esi
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[esp+44], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 2108 : 			else

	jmp	$LN55@HasComplet
$LN4@HasComplet:

; 2102 : 				}
; 2103 : 				else
; 2104 : 				{
; 2105 : 					return true;	// Our unit is gone, assume we are done.

	mov	ecx, DWORD PTR _hUnit$[esp+32]
	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	ecx, ecx
	je	SHORT $LN44@HasComplet
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN44@HasComplet:
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx

; 2121 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
$LN5@HasComplet:

; 2109 : 			{
; 2110 : 				pTargetPlot = GC.getMap().plot(kMissionData.iData1, kMissionData.iData2);

	mov	eax, DWORD PTR [esi+4]
	mov	ebp, DWORD PTR [esi+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN106@HasComplet
	cmp	ebp, -2147483647			; 80000001H
	je	$LN106@HasComplet
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN63@HasComplet
	test	eax, eax
	jge	SHORT $LN65@HasComplet
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN67@HasComplet
$LN65@HasComplet:
	cmp	eax, ecx
	jl	SHORT $LN63@HasComplet
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN67@HasComplet
$LN63@HasComplet:
	mov	esi, eax
$LN67@HasComplet:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN105@HasComplet
	test	ebp, ebp
	jge	SHORT $LN75@HasComplet
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN77@HasComplet
$LN75@HasComplet:
	cmp	ebp, edi
	jl	SHORT $LN105@HasComplet
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN77@HasComplet
$LN105@HasComplet:
	mov	edx, ebp
$LN77@HasComplet:
	test	esi, esi
	jl	SHORT $LN106@HasComplet
	cmp	esi, ecx
	jge	SHORT $LN106@HasComplet
	test	edx, edx
	jl	SHORT $LN106@HasComplet
	cmp	edx, edi
	jge	SHORT $LN106@HasComplet
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	edi, ecx
$LN55@HasComplet:

; 2111 : 			}
; 2112 : 
; 2113 : 			if(pTargetPlot && hUnit->atPlot(*pTargetPlot))

	test	edi, edi
	je	SHORT $LN106@HasComplet
	mov	ecx, DWORD PTR _hUnit$[esp+32]
	push	edi
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	test	al, al

; 2114 : 			{
; 2115 : 				return true;

	jne	$LN4@HasComplet
$LN106@HasComplet:
	mov	ecx, DWORD PTR _hUnit$[esp+32]
$LN1@HasComplet:

; 2116 : 			}
; 2117 : 		}
; 2118 : 	}
; 2119 : 
; 2120 : 	return false;

	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	ecx, ecx
	je	SHORT $LN101@HasComplet
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN101@HasComplet:

; 2121 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?HasCompletedMoveMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?HasCompletedMoveMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@@Z$1:
	lea	ecx, DWORD PTR _pTargetUnit$218981[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?HasCompletedMoveMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?HasCompletedMoveMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?HasCompletedMoveMission@CvUnitMission@@SA_NV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvUnitMission::HasCompletedMoveMission
PUBLIC	?next@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@PBU2@@Z ; FFastSmallFixedList<MissionData,12,1,297,0>::next
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?next@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@PBU2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?next@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@PBU2@@Z PROC ; FFastSmallFixedList<MissionData,12,1,297,0>::next, COMDAT
; _this$ = ecx

; 936  : #ifdef AUI_FIX_FFASTVECTOR_USE_UNSIGNED
; 937  : 		unsigned int iIndex = (pNode + 1) - &mVec[0];
; 938  : #else
; 939  :         INT iIndex = ( pNode + 1 ) - &mVec[ 0 ];

	mov	edx, DWORD PTR _pNode$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx]
	sub	edx, esi
	add	edx, 20					; 00000014H
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 940  : #endif
; 941  :         return getAt( iIndex );

	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN6@next
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [esi+eax*4]
	pop	esi

; 942  :     }

	ret	4

; 940  : #endif
; 941  :         return getAt( iIndex );

$LN6@next:
	xor	eax, eax
	pop	esi

; 942  :     }

	ret	4
?next@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@PBU2@@Z ENDP ; FFastSmallFixedList<MissionData,12,1,297,0>::next
_TEXT	ENDS
PUBLIC	?prev@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@PBU2@@Z ; FFastSmallFixedList<MissionData,12,1,297,0>::prev
; Function compile flags: /Ogtpy
;	COMDAT ?prev@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@PBU2@@Z
_TEXT	SEGMENT
_pNode$ = 8						; size = 4
?prev@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@PBU2@@Z PROC ; FFastSmallFixedList<MissionData,12,1,297,0>::prev, COMDAT
; _this$ = ecx

; 947  : #ifdef AUI_FIX_FFASTVECTOR_USE_UNSIGNED
; 948  : 		unsigned int iIndex = (pNode - 1) - &mVec[0];
; 949  : #else
; 950  :         INT iIndex = ( pNode - 1 ) - &mVec[ 0 ];

	mov	edx, DWORD PTR _pNode$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx]
	sub	edx, esi
	sub	edx, 20					; 00000014H
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 951  : #endif
; 952  :         return getAt( iIndex );

	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN6@prev
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [esi+eax*4]
	pop	esi

; 953  :     }

	ret	4

; 951  : #endif
; 952  :         return getAt( iIndex );

$LN6@prev:
	xor	eax, eax
	pop	esi

; 953  :     }

	ret	4
?prev@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QBEPBUMissionData@@PBU2@@Z ENDP ; FFastSmallFixedList<MissionData,12,1,297,0>::prev
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<MissionData,12,1,297,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<MissionData,12,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 12					; 0000000cH
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	lea	eax, DWORD PTR [ebp+ebp*4]
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 12			; 0000000cH
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+eax*4]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+252], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<MissionData,12,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::begin
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+12], ecx
	mov	BYTE PTR [eax+16], dl
	mov	BYTE PTR [eax+17], 0
$LN4@Buynode:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	20					; 00000014H
?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::CalculateMissionTimer
EXTRN	?IsAutomated@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsAutomated
EXTRN	?ShowMoves@CvUnit@@QBE_NXZ:PROC			; CvUnit::ShowMoves
EXTRN	?isHuman@CvUnit@@QBE_NXZ:PROC			; CvUnit::isHuman
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z$1
__ehfuncinfo$?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z
_TEXT	SEGMENT
_iTime$ = -28						; size = 4
$T222318 = -24						; size = 4
_pTargetUnit$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
_iSteps$ = 16						; size = 4
?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z PROC ; CvUnitMission::CalculateMissionTimer, COMDAT

; 1785 : {

	push	-1
	push	__ehhandler$?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	edi
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+44], ebx

; 1786 : 	UnitHandle pTargetUnit;

	mov	DWORD PTR _pTargetUnit$[esp+36], ebx
	mov	BYTE PTR _pTargetUnit$[esp+40], bl

; 1787 : 	CvPlot* pTargetPlot;
; 1788 : 	int iTime = 0;
; 1789 : 
; 1790 : 	MissionQueueNode* pkMissionNode;
; 1791 : 	if(!hUnit->isHuman() && !hUnit->ShowMoves())

	mov	ecx, DWORD PTR _hUnit$[esp+32]
	mov	BYTE PTR __$EHRec$[esp+44], 1
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	jne	SHORT $LN13@CalculateM
	mov	ecx, DWORD PTR _hUnit$[esp+32]
	call	?ShowMoves@CvUnit@@QBE_NXZ		; CvUnit::ShowMoves
	test	al, al
	jne	SHORT $LN13@CalculateM

; 1792 : 	{
; 1793 : 		iTime = 0;

	xor	edi, edi
	jmp	$LN116@CalculateM
$LN13@CalculateM:

; 1794 : 	}
; 1795 : 	else if((pkMissionNode = HeadMissionQueueNode(hUnit->m_missionQueue)) != NULL)

	mov	eax, DWORD PTR _hUnit$[esp+32]
	push	esi
	cmp	DWORD PTR [eax+2604], ebx
	jbe	$LN11@CalculateM
	mov	esi, DWORD PTR [eax+2600]
	cmp	esi, ebx
	je	$LN11@CalculateM

; 1796 : 	{
; 1797 : 		MissionData& kMissionData = *pkMissionNode;
; 1798 : 
; 1799 : 		iTime = 1;

	mov	edi, 1
	mov	DWORD PTR _iTime$[esp+40], edi

; 1800 : 
; 1801 : 		if((kMissionData.eMissionType == CvTypes::getMISSION_MOVE_TO()) ||
; 1802 : 		        (kMissionData.eMissionType == CvTypes::getMISSION_ROUTE_TO()) ||
; 1803 : 		        (kMissionData.eMissionType == CvTypes::getMISSION_MOVE_TO_UNIT()))

	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	cmp	DWORD PTR [esi], eax
	je	SHORT $LN9@CalculateM
	call	?getMISSION_ROUTE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ROUTE_TO
	cmp	DWORD PTR [esi], eax
	je	SHORT $LN9@CalculateM
	call	?getMISSION_MOVE_TO_UNIT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO_UNIT
	cmp	DWORD PTR [esi], eax
	jne	$LN3@CalculateM
$LN9@CalculateM:
	push	ebp

; 1804 : 		{
; 1805 : 			if(kMissionData.eMissionType == CvTypes::getMISSION_MOVE_TO_UNIT())

	call	?getMISSION_MOVE_TO_UNIT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO_UNIT
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN8@CalculateM

; 1806 : 			{
; 1807 : 				pTargetUnit = GET_PLAYER((PlayerTypes)kMissionData.iData1).getUnit(kMissionData.iData2);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pTargetUnit$[esp+44], esi
	cmp	esi, ebx
	je	$LN118@CalculateM
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 1808 : 				if(pTargetUnit)
; 1809 : 				{
; 1810 : 					pTargetPlot = pTargetUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 1811 : 				}
; 1812 : 				else

	jmp	$LN54@CalculateM
$LN8@CalculateM:

; 1813 : 				{
; 1814 : 					pTargetPlot = NULL;
; 1815 : 				}
; 1816 : 			}
; 1817 : 			else
; 1818 : 			{
; 1819 : 				pTargetPlot = GC.getMap().plot(kMissionData.iData1, kMissionData.iData2);

	mov	eax, DWORD PTR [esi+4]
	mov	ebp, DWORD PTR [esi+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN118@CalculateM
	cmp	ebp, -2147483647			; 80000001H
	je	$LN118@CalculateM
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN62@CalculateM
	test	eax, eax
	jge	SHORT $LN64@CalculateM
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN66@CalculateM
$LN64@CalculateM:
	cmp	eax, ecx
	jl	SHORT $LN62@CalculateM
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN66@CalculateM
$LN62@CalculateM:
	mov	esi, eax
$LN66@CalculateM:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN117@CalculateM
	test	ebp, ebp
	jge	SHORT $LN74@CalculateM
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN76@CalculateM
$LN74@CalculateM:
	cmp	ebp, edi
	jl	SHORT $LN117@CalculateM
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN76@CalculateM
$LN117@CalculateM:
	mov	edx, ebp
$LN76@CalculateM:
	test	esi, esi
	jl	SHORT $LN118@CalculateM
	cmp	esi, ecx
	jge	SHORT $LN118@CalculateM
	test	edx, edx
	jl	SHORT $LN118@CalculateM
	cmp	edx, edi
	jge	SHORT $LN118@CalculateM
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	eax, ecx
$LN54@CalculateM:

; 1820 : 			}
; 1821 : 
; 1822 : 			if(pTargetPlot && hUnit->atPlot(*pTargetPlot))

	test	eax, eax
	je	SHORT $LN118@CalculateM
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	eax
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	test	al, al
	je	SHORT $LN118@CalculateM

; 1823 : 			{
; 1824 : 				iTime += iSteps;

	mov	edi, DWORD PTR _iSteps$[esp+40]
	inc	edi

; 1825 : 			}
; 1826 : 			else

	jmp	SHORT $LN123@CalculateM
$LN118@CalculateM:

; 1827 : 			{
; 1828 : 				iTime = std::min(iTime, 2);

	mov	edi, 1
$LN123@CalculateM:
	mov	DWORD PTR _iTime$[esp+44], edi
	pop	ebp
$LN3@CalculateM:

; 1829 : 			}
; 1830 : 		}
; 1831 : 
; 1832 : 		if(hUnit->isHuman() && (hUnit->IsAutomated() /*|| (GET_PLAYER((GC.getGame().isNetworkMultiPlayer()) ? hUnit->getOwner() : GC.getGame().getActivePlayer()).isOption(PLAYEROPTION_QUICK_MOVES))*/))

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	je	SHORT $LN121@CalculateM
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	test	al, al
	je	SHORT $LN121@CalculateM

; 1833 : 		{
; 1834 : 			iTime = std::min(iTime, 1);

	cmp	edi, 1
	mov	DWORD PTR $T222318[esp+40], 1
	lea	eax, DWORD PTR $T222318[esp+40]
	jg	SHORT $LN103@CalculateM
	lea	eax, DWORD PTR _iTime$[esp+40]
$LN103@CalculateM:
	mov	edi, DWORD PTR [eax]

; 1835 : 		}
; 1836 : 	}
; 1837 : 	else

	jmp	SHORT $LN121@CalculateM
$LN11@CalculateM:

; 1838 : 	{
; 1839 : 		iTime = 0;

	xor	edi, edi
$LN121@CalculateM:
	pop	esi
$LN116@CalculateM:

; 1840 : 	}
; 1841 : 
; 1842 : 	return iTime;

	mov	ecx, DWORD PTR _pTargetUnit$[esp+36]
	mov	BYTE PTR __$EHRec$[esp+44], 0
	test	ecx, ecx
	je	SHORT $LN107@CalculateM
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN107@CalculateM:
	mov	ecx, DWORD PTR _hUnit$[esp+32]
	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	ecx, ecx
	je	SHORT $LN115@CalculateM
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN115@CalculateM:

; 1843 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	eax, edi
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z$1:
	lea	ecx, DWORD PTR _pTargetUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z ENDP ; CvUnitMission::CalculateMissionTimer
PUBLIC	?UpdateMissionTimer@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::UpdateMissionTimer
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?UpdateMissionTimer@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateMissionTimer@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z$0
__ehfuncinfo$?UpdateMissionTimer@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UpdateMissionTimer@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?UpdateMissionTimer@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
$T222566 = 16						; size = 4
_iSteps$ = 16						; size = 4
?UpdateMissionTimer@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z PROC ; CvUnitMission::UpdateMissionTimer, COMDAT

; 1847 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?UpdateMissionTimer@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 1848 : 	hUnit->SetMissionTimer(CalculateMissionTimer(hUnit, iSteps));

	mov	eax, DWORD PTR _iSteps$[esp+8]
	mov	ecx, DWORD PTR _hUnit$[esp+8]
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _hUnit$[esp+24]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR $T222566[esp+20], esp
	test	eax, eax
	je	SHORT $LN8@UpdateMiss
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN8@UpdateMiss:
	call	?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::CalculateMissionTimer
	mov	ecx, DWORD PTR _hUnit$[esp+20]
	add	esp, 12					; 0000000cH
	push	eax
	call	?SetMissionTimer@CvUnit@@QAEXH@Z	; CvUnit::SetMissionTimer

; 1849 : }

	mov	ecx, DWORD PTR _hUnit$[esp+8]
	mov	DWORD PTR __$EHRec$[esp+20], -1
	test	ecx, ecx
	je	SHORT $LN15@UpdateMiss
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN15@UpdateMiss:
	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateMissionTimer@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?UpdateMissionTimer@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?UpdateMissionTimer@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateMissionTimer@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z ENDP ; CvUnitMission::UpdateMissionTimer
PUBLIC	?NextMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@PBU2@@Z ; CvUnitMission::NextMissionQueueNode
; Function compile flags: /Ogtpy
;	COMDAT ?NextMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@PBU2@@Z
_TEXT	SEGMENT
_kQueue$ = 8						; size = 4
_pNode$ = 12						; size = 4
?NextMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@PBU2@@Z PROC ; CvUnitMission::NextMissionQueueNode, COMDAT

; 2008 : 	return kQueue.next(pNode);

	mov	ecx, DWORD PTR _pNode$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kQueue$[esp+4]
	mov	esi, DWORD PTR [edi]
	sub	ecx, esi
	add	ecx, 20					; 00000014H
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, DWORD PTR [edi+4]
	jae	SHORT $LN8@NextMissio
	lea	eax, DWORD PTR [eax+eax*4]
	pop	edi
	lea	eax, DWORD PTR [esi+eax*4]
	pop	esi

; 2009 : }

	ret	0

; 2008 : 	return kQueue.next(pNode);

$LN8@NextMissio:
	pop	edi
	xor	eax, eax
	pop	esi

; 2009 : }

	ret	0
?NextMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@PBU2@@Z ENDP ; CvUnitMission::NextMissionQueueNode
_TEXT	ENDS
PUBLIC	?PrevMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@PBU2@@Z ; CvUnitMission::PrevMissionQueueNode
; Function compile flags: /Ogtpy
;	COMDAT ?PrevMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@PBU2@@Z
_TEXT	SEGMENT
_kQueue$ = 8						; size = 4
_pNode$ = 12						; size = 4
?PrevMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@PBU2@@Z PROC ; CvUnitMission::PrevMissionQueueNode, COMDAT

; 2015 : 	return kQueue.prev(pNode);

	mov	ecx, DWORD PTR _pNode$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _kQueue$[esp+4]
	mov	esi, DWORD PTR [edi]
	sub	ecx, esi
	sub	ecx, 20					; 00000014H
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, DWORD PTR [edi+4]
	jae	SHORT $LN8@PrevMissio
	lea	eax, DWORD PTR [eax+eax*4]
	pop	edi
	lea	eax, DWORD PTR [esi+eax*4]
	pop	esi

; 2016 : }

	ret	0

; 2015 : 	return kQueue.prev(pNode);

$LN8@PrevMissio:
	pop	edi
	xor	eax, eax
	pop	esi

; 2016 : }

	ret	0
?PrevMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@PBU2@@Z ENDP ; CvUnitMission::PrevMissionQueueNode
_TEXT	ENDS
PUBLIC	?resize@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEXI@Z ; FStaticVector<MissionData,12,1,297,0>::resize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?resize@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?resize@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEXI@Z PROC ; FStaticVector<MissionData,12,1,297,0>::resize, COMDAT
; _this$ = ecx

; 666  : 	{

	push	esi
	push	edi

; 667  : 		if( m_uiCurrMaxSize < uiNewSize ){

	mov	edi, DWORD PTR _uiNewSize$[esp+4]
	mov	esi, ecx
	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN4@resize

; 668  : 			GrowSize(uiNewSize);

	push	edi
	call	?GrowSize@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<MissionData,12,1,297,0>::GrowSize
$LN4@resize:

; 669  : 		}
; 670  : 		m_uiCurrSize = uiNewSize;

	mov	DWORD PTR [esi+4], edi
	pop	edi
	pop	esi

; 671  : 	};

	ret	4
?resize@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEXI@Z ENDP ; FStaticVector<MissionData,12,1,297,0>::resize
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEIABUMissionData@@@Z ; FStaticVector<MissionData,12,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEIABUMissionData@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEIABUMissionData@@@Z PROC ; FStaticVector<MissionData,12,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+252], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<MissionData,12,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEIABUMissionData@@@Z ENDP ; FStaticVector<MissionData,12,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
$T222688 = -80						; size = 28
$T222687 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 1073741822		; 3ffffffeH
	jb	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T222688[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T222687[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T222688[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T222687[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T222687[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T222687[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T222687[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert:
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+16], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert
	npad	5
$LL10@Insert:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+16], 0
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+16], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+16], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+16], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
$LN5@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+16], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+16], 0
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+16], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+16], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+16], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+16], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN170@Insert
	mov	DWORD PTR [edx+4], eax
$LN170@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert
$LN169@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert
$LN167@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+16], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert
$LN9@Insert:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+16], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$0:
	lea	ecx, DWORD PTR $T222688[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$2:
	lea	ecx, DWORD PTR $T222687[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	?LastMissionPlot@CvUnitMission@@SAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvUnitMission::LastMissionPlot
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?LastMissionPlot@CvUnitMission@@SAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LastMissionPlot@CvUnitMission@@SAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LastMissionPlot@CvUnitMission@@SAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z$1
__ehfuncinfo$?LastMissionPlot@CvUnitMission@@SAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LastMissionPlot@CvUnitMission@@SAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?LastMissionPlot@CvUnitMission@@SAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_pTargetUnit$218825 = -20				; size = 8
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
?LastMissionPlot@CvUnitMission@@SAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvUnitMission::LastMissionPlot, COMDAT

; 1748 : {

	push	-1
	push	__ehhandler$?LastMissionPlot@CvUnitMission@@SAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 1749 : 	const MissionQueueNode* pMissionNode = TailMissionQueueNode(hUnit->m_missionQueue);

	mov	ecx, DWORD PTR _hUnit$[esp+28]
	mov	eax, DWORD PTR [ecx+2604]
	mov	DWORD PTR __$EHRec$[esp+40], 0
	test	eax, eax
	jbe	SHORT $LN17@LastMissio
	mov	edx, DWORD PTR [ecx+2600]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	esi, DWORD PTR [edx+eax*4-20]
	jmp	SHORT $LN16@LastMissio
$LN17@LastMissio:
	xor	esi, esi
$LN16@LastMissio:

; 1750 : 
; 1751 : 	while(pMissionNode != NULL)

	test	esi, esi
	je	$LN6@LastMissio
	mov	bl, 1
	npad	4
$LL7@LastMissio:

; 1752 : 	{
; 1753 : 		if(pMissionNode->eMissionType == CvTypes::getMISSION_MOVE_TO() ||
; 1754 : 		        pMissionNode->eMissionType == CvTypes::getMISSION_ROUTE_TO() ||
; 1755 : 		        pMissionNode->eMissionType == CvTypes::getMISSION_SWAP_UNITS())

	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	cmp	DWORD PTR [esi], eax
	je	$LN4@LastMissio
	call	?getMISSION_ROUTE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ROUTE_TO
	cmp	DWORD PTR [esi], eax
	je	$LN4@LastMissio
	call	?getMISSION_SWAP_UNITS@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SWAP_UNITS
	cmp	DWORD PTR [esi], eax
	je	$LN4@LastMissio

; 1758 : 		}
; 1759 : 
; 1760 : 		else if(pMissionNode->eMissionType == CvTypes::getMISSION_MOVE_TO_UNIT())

	call	?getMISSION_MOVE_TO_UNIT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO_UNIT
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN93@LastMissio

; 1761 : 		{
; 1762 : 			UnitHandle pTargetUnit = GET_PLAYER((PlayerTypes)pMissionNode->iData1).getUnit(pMissionNode->iData2);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pTargetUnit$218825[esp+32], edi
	mov	BYTE PTR _pTargetUnit$218825[esp+36], 0
	test	edi, edi
	je	SHORT $LN74@LastMissio
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN74@LastMissio:
	mov	BYTE PTR __$EHRec$[esp+40], bl

; 1763 : 			if(pTargetUnit)

	test	edi, edi
	jne	SHORT $LN120@LastMissio

; 1766 : 			}
; 1767 : 		}

	mov	BYTE PTR __$EHRec$[esp+40], 0
$LN93@LastMissio:

; 1768 : 
; 1769 : 		pMissionNode = PrevMissionQueueNode(hUnit->m_missionQueue, pMissionNode);

	mov	ecx, DWORD PTR _hUnit$[esp+28]
	mov	edi, DWORD PTR [ecx+2600]
	sub	esi, edi
	sub	esi, 20					; 00000014H
	mov	eax, 1717986919				; 66666667H
	imul	esi
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, DWORD PTR [ecx+2604]
	jae	SHORT $LN104@LastMissio
	lea	edx, DWORD PTR [eax+eax*4]
	lea	esi, DWORD PTR [edi+edx*4]
	jmp	SHORT $LN103@LastMissio
$LN104@LastMissio:
	xor	esi, esi
$LN103@LastMissio:

; 1750 : 
; 1751 : 	while(pMissionNode != NULL)

	test	esi, esi
	jne	$LL7@LastMissio
$LN6@LastMissio:

; 1770 : 	}
; 1771 : 
; 1772 : 	return hUnit->plot();

	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, eax
$LN128@LastMissio:
	mov	ecx, DWORD PTR _hUnit$[esp+28]
	mov	DWORD PTR __$EHRec$[esp+40], -1
	test	ecx, ecx
	je	SHORT $LN116@LastMissio
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN116@LastMissio:

; 1773 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
$LN120@LastMissio:

; 1764 : 			{
; 1765 : 				return pTargetUnit->plot();

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, edi
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+40], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	jmp	SHORT $LN128@LastMissio
$LN4@LastMissio:

; 1756 : 		{
; 1757 : 			return GC.getMap().plot(pMissionNode->iData1, pMissionNode->iData2);

	mov	eax, DWORD PTR [esi+4]
	push	ebp
	mov	ebp, DWORD PTR [esi+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN26@LastMissio
	cmp	ebp, -2147483647			; 80000001H
	je	$LN26@LastMissio
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN36@LastMissio
	test	eax, eax
	jge	SHORT $LN38@LastMissio
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN40@LastMissio
$LN38@LastMissio:
	cmp	eax, ecx
	jl	SHORT $LN36@LastMissio
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN40@LastMissio
$LN36@LastMissio:
	mov	esi, eax
$LN40@LastMissio:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN124@LastMissio
	test	ebp, ebp
	jge	SHORT $LN48@LastMissio
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN50@LastMissio
$LN48@LastMissio:
	cmp	ebp, edi
	jl	SHORT $LN124@LastMissio
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN50@LastMissio
$LN124@LastMissio:
	mov	edx, ebp
$LN50@LastMissio:
	test	esi, esi
	jl	SHORT $LN26@LastMissio
	cmp	esi, ecx
	jge	SHORT $LN26@LastMissio
	test	edx, edx
	jl	SHORT $LN26@LastMissio
	cmp	edx, edi
	jge	SHORT $LN26@LastMissio
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	pop	ebp
	mov	esi, ecx
	jmp	$LN128@LastMissio
$LN26@LastMissio:
	xor	esi, esi
	pop	ebp
	jmp	$LN128@LastMissio
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LastMissionPlot@CvUnitMission@@SAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LastMissionPlot@CvUnitMission@@SAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z$1:
	lea	ecx, DWORD PTR _pTargetUnit$218825[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?LastMissionPlot@CvUnitMission@@SAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LastMissionPlot@CvUnitMission@@SAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LastMissionPlot@CvUnitMission@@SAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvUnitMission::LastMissionPlot
PUBLIC	?GetMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::GetMissionData
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z$0
__ehfuncinfo$?GetMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?GetMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
_iNode$ = 16						; size = 4
?GetMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z PROC ; CvUnitMission::GetMissionData, COMDAT

; 1854 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GetMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1855 : 	int iCount = 0;
; 1856 : 
; 1857 : 	const MissionQueue& kQueue = hUnit->m_missionQueue;

	mov	ecx, DWORD PTR _hUnit$[esp+24]

; 1858 : 	const MissionQueueNode* pMissionNode = HeadMissionQueueNode(kQueue);

	mov	ebp, DWORD PTR [ecx+2604]
	xor	ebx, ebx
	test	ebp, ebp
	jbe	SHORT $LN12@GetMission@2
	mov	esi, DWORD PTR [ecx+2600]
	jmp	SHORT $LN11@GetMission@2
$LN12@GetMission@2:
	xor	esi, esi
$LN11@GetMission@2:

; 1859 : 
; 1860 : 	while(pMissionNode != NULL)

	test	esi, esi
	je	SHORT $LN2@GetMission@2
$LL3@GetMission@2:

; 1861 : 	{
; 1862 : 		if(iNode == iCount)

	cmp	DWORD PTR _iNode$[esp+24], ebx
	je	SHORT $LN44@GetMission@2

; 1865 : 		}
; 1866 : 
; 1867 : 		iCount++;
; 1868 : 
; 1869 : 		pMissionNode = NextMissionQueueNode(kQueue, pMissionNode);

	mov	edi, DWORD PTR [ecx+2600]
	sub	esi, edi
	add	esi, 20					; 00000014H
	mov	eax, 1717986919				; 66666667H
	imul	esi
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	inc	ebx
	cmp	eax, ebp
	jae	SHORT $LN31@GetMission@2
	lea	eax, DWORD PTR [eax+eax*4]
	lea	esi, DWORD PTR [edi+eax*4]
	jmp	SHORT $LN30@GetMission@2
$LN31@GetMission@2:
	xor	esi, esi
$LN30@GetMission@2:

; 1859 : 
; 1860 : 	while(pMissionNode != NULL)

	test	esi, esi
	jne	SHORT $LL3@GetMission@2
$LN2@GetMission@2:

; 1870 : 	}
; 1871 : 
; 1872 : 	return NULL;

	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	ecx, ecx
	je	SHORT $LN41@GetMission@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@GetMission@2:
	xor	eax, eax

; 1873 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
$LN44@GetMission@2:

; 1863 : 		{
; 1864 : 			return pMissionNode;

	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	ecx, ecx
	je	SHORT $LN22@GetMission@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN22@GetMission@2:

; 1873 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@H@Z ENDP ; CvUnitMission::GetMissionData
PUBLIC	?insertAtEnd@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEXPAUMissionData@@@Z ; FFastSmallFixedList<MissionData,12,1,297,0>::insertAtEnd
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?insertAtEnd@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEXPAUMissionData@@@Z
_TEXT	SEGMENT
_ptData$ = 8						; size = 4
?insertAtEnd@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEXPAUMissionData@@@Z PROC ; FFastSmallFixedList<MissionData,12,1,297,0>::insertAtEnd, COMDAT
; _this$ = ecx

; 1027 :         mVec.push_back( *ptData );       

	jmp	?push_back@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEIABUMissionData@@@Z ; FStaticVector<MissionData,12,1,297,0>::push_back
?insertAtEnd@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEXPAUMissionData@@@Z ENDP ; FFastSmallFixedList<MissionData,12,1,297,0>::insertAtEnd
_TEXT	ENDS
PUBLIC	?insertAtBeginning@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEXPAUMissionData@@@Z ; FFastSmallFixedList<MissionData,12,1,297,0>::insertAtBeginning
; Function compile flags: /Ogtpy
;	COMDAT ?insertAtBeginning@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEXPAUMissionData@@@Z
_TEXT	SEGMENT
_ptData$ = 8						; size = 4
?insertAtBeginning@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEXPAUMissionData@@@Z PROC ; FFastSmallFixedList<MissionData,12,1,297,0>::insertAtBeginning, COMDAT
; _this$ = ecx

; 1075 : 	{        

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 1076 : 		UINT uSize = mVec.size();

	mov	edi, DWORD PTR [esi+4]

; 1077 : 
; 1078 : 		mVec.resize( uSize + 1 );

	lea	ebx, DWORD PTR [edi+1]
	cmp	DWORD PTR [esi+8], ebx
	jae	SHORT $LN8@insertAtBe
	push	ebx
	call	?GrowSize@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<MissionData,12,1,297,0>::GrowSize
$LN8@insertAtBe:

; 1079 : 
; 1080 : #ifdef AUI_FIX_FFASTVECTOR_USE_UNSIGNED
; 1081 : 		for (unsigned int iIdx = uSize; iIdx >= 1; --iIdx)
; 1082 : #else
; 1083 :         for( INT iIdx = (INT)uSize; iIdx >= 1; --iIdx )

	cmp	edi, 1
	mov	DWORD PTR [esi+4], ebx
	jl	SHORT $LN1@insertAtBe
	lea	ecx, DWORD PTR [edi+edi*4]
	add	ecx, ecx
	add	ecx, ecx
$LL3@insertAtBe:

; 1084 : #endif
; 1085 :         {
; 1086 :             mVec[ iIdx ] = mVec[ iIdx - 1 ];

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+ecx-20]
	add	eax, ecx
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [eax-16]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [eax-12]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [eax-8]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [eax-4]
	sub	ecx, 20					; 00000014H
	sub	edi, 1
	mov	DWORD PTR [eax+16], edx
	jne	SHORT $LL3@insertAtBe
$LN1@insertAtBe:

; 1087 :         }
; 1088 : 
; 1089 :         mVec[ 0 ] = *ptData;

	mov	eax, DWORD PTR _ptData$[esp+8]
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR [esi]
	mov	DWORD PTR [esi], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+12], edx
	mov	eax, DWORD PTR [eax+16]
	pop	edi
	mov	DWORD PTR [esi+16], eax
	pop	esi
	pop	ebx

; 1090 :     };

	ret	4
?insertAtBeginning@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEXPAUMissionData@@@Z ENDP ; FFastSmallFixedList<MissionData,12,1,297,0>::insertAtBeginning
_TEXT	ENDS
PUBLIC	?deleteNode@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@PAU2@@Z ; FFastSmallFixedList<MissionData,12,1,297,0>::deleteNode
; Function compile flags: /Ogtpy
;	COMDAT ?deleteNode@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@PAU2@@Z
_TEXT	SEGMENT
_tData$ = 8						; size = 4
?deleteNode@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@PAU2@@Z PROC ; FFastSmallFixedList<MissionData,12,1,297,0>::deleteNode, COMDAT
; _this$ = ecx

; 1094 :     {

	push	ebx
	push	esi
	mov	esi, ecx

; 1095 :         UINT uDeletePos = tData - &mVec[ 0 ];

	mov	ecx, DWORD PTR _tData$[esp+4]
	sub	ecx, DWORD PTR [esi]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	push	edi
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx

; 1096 : 
; 1097 :         for( UINT uIdx = uDeletePos; uIdx + 1 < mVec.size(); ++uIdx )

	lea	edx, DWORD PTR [edi+1]
	cmp	edx, DWORD PTR [esi+4]
	jae	SHORT $LN3@deleteNode
	lea	ecx, DWORD PTR [edi+edi*4]
	add	ecx, ecx
	add	ecx, ecx
	npad	5
$LL5@deleteNode:

; 1098 :         {
; 1099 :             mVec[ uIdx ] = mVec[ uIdx + 1 ];

	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR [eax+ecx+20]
	add	eax, ecx
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [eax+28]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [eax+32]
	mov	DWORD PTR [eax+12], ebx
	mov	ebx, DWORD PTR [eax+36]
	inc	edx
	mov	DWORD PTR [eax+16], ebx
	add	ecx, 20					; 00000014H
	cmp	edx, DWORD PTR [esi+4]
	jb	SHORT $LL5@deleteNode
$LN3@deleteNode:

; 1100 :         }
; 1101 : 
; 1102 :         //  List shrinks by 1
; 1103 :         mVec.resize( mVec.size() - 1 );

	mov	ebx, DWORD PTR [esi+4]
	dec	ebx
	cmp	DWORD PTR [esi+8], ebx
	jae	SHORT $LN18@deleteNode
	push	ebx
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<MissionData,12,1,297,0>::GrowSize
$LN18@deleteNode:
	mov	DWORD PTR [esi+4], ebx

; 1104 : 
; 1105 :         if( uDeletePos < mVec.size() )

	cmp	edi, ebx
	jae	SHORT $LN2@deleteNode

; 1106 :         {
; 1107 : 	        return &mVec[ uDeletePos ];

	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [edi+edi*4]
	pop	edi
	pop	esi
	lea	eax, DWORD PTR [edx+ecx*4]
	pop	ebx

; 1112 :         }
; 1113 :     };

	ret	4
$LN2@deleteNode:
	pop	edi
	pop	esi

; 1108 :         }
; 1109 :         else
; 1110 :         {
; 1111 :             return NULL;

	xor	eax, eax
	pop	ebx

; 1112 :         }
; 1113 :     };

	ret	4
?deleteNode@?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEPAUMissionData@@PAU2@@Z ENDP ; FFastSmallFixedList<MissionData,12,1,297,0>::deleteNode
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T223580 = 12						; size = 4
$T223578 = 12						; size = 4
__Where$198776 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+17], 0
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+16], cl
	jne	SHORT $LN9@insert
	mov	edx, DWORD PTR [ebp]
	npad	1
$LL10@insert:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+12]
	mov	esi, eax
	setb	cl
	mov	BYTE PTR __Addleft$[esp+16], cl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	cl, cl
	je	SHORT $LN13@insert
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert
$LN13@insert:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert:

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL10@insert
$LN9@insert:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, esi
	mov	DWORD PTR __Where$198776[esp+12], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN57@insert

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	lea	ecx, DWORD PTR $T223578[esp+12]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN4@insert
	push	ebp
	push	esi
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN4@insert:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$198776[esp+12]
$LN57@insert:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR [ebp]
	jae	SHORT $LN2@insert

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Addleft$[esp+16]
	push	ebp
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T223580[esp+24]
	push	edx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN2@insert:

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
_TEXT	ENDS
PUBLIC	?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z ; CvUnitMission::WaitFor
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?getMISSION_WAIT_FOR@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_WAIT_FOR
EXTRN	?dispatchingNetMessage@CvUnit@@SA_NXZ:PROC	; CvUnit::dispatchingNetMessage
EXTRN	?isHuman@CvPreGame@@YA_NW4PlayerTypes@@@Z:PROC	; CvPreGame::isHuman
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z$2
__ehfuncinfo$?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z
_TEXT	SEGMENT
_mission$ = -60						; size = 20
$T223709 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
_hWaitForUnit$ = 16					; size = 8
?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z PROC ; CvUnitMission::WaitFor, COMDAT

; 328  : {

	push	-1
	push	__ehhandler$?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H

; 329  : 	if(CvPreGame::isHuman(hUnit->getOwner()))

	mov	eax, DWORD PTR _hUnit$[esp+56]
	mov	eax, DWORD PTR [eax+40]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+72], 1
	call	?isHuman@CvPreGame@@YA_NW4PlayerTypes@@@Z ; CvPreGame::isHuman
	add	esp, 4
	test	al, al
	je	SHORT $LN2@WaitFor

; 330  : 	{
; 331  : 		CvAssertMsg(CvUnit::dispatchingNetMessage(), "Multiplayer Error! CvUnit::PushMission invoked for a human player outside of a network message!");
; 332  : 		if(!CvUnit::dispatchingNetMessage())

	call	?dispatchingNetMessage@CvUnit@@SA_NXZ	; CvUnit::dispatchingNetMessage
	test	al, al
	jne	SHORT $LN2@WaitFor

; 333  : 			gDLL->netMessageDebugLog("*** PROTOCOL ERROR *** : PushMission invoked for a human controlled player outside of a network message!");

	push	OFFSET $SG218153
	lea	ecx, DWORD PTR $T223709[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+76]
	lea	eax, DWORD PTR $T223709[esp+60]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+72], 2
	call	edx
	lea	ecx, DWORD PTR $T223709[esp+60]
	mov	BYTE PTR __$EHRec$[esp+68], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@WaitFor:
	push	ebx
	push	ebp
	push	esi
	push	edi

; 334  : 	}
; 335  : 
; 336  : 	CvAssert(hUnit->getOwner() != NO_PLAYER);
; 337  : 
; 338  : 	MissionData mission;
; 339  : 	mission.eMissionType = CvTypes::getMISSION_WAIT_FOR();

	call	?getMISSION_WAIT_FOR@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_WAIT_FOR
	mov	ebx, eax

; 340  : 	mission.iData1 = hWaitForUnit->getOwner();

	mov	eax, DWORD PTR _hWaitForUnit$[esp+72]
	mov	ecx, DWORD PTR [eax+40]

; 341  : 	mission.iData2 = hWaitForUnit->GetID();

	mov	edx, DWORD PTR [eax+100]
	mov	DWORD PTR _mission$[esp+80], ecx

; 342  : 	mission.iFlags = 0;
; 343  : 	mission.iPushTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _mission$[esp+84], edx
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 344  : 
; 345  : 	MissionQueue& kQueue = hUnit->m_missionQueue;

	mov	esi, DWORD PTR _hUnit$[esp+72]

; 346  : 
; 347  : 	//  Insert head of mission list
; 348  : 	kQueue.insertAtBeginning(&mission);

	mov	edi, DWORD PTR [esi+2604]
	add	esi, 2600				; 00000a28H
	lea	ebp, DWORD PTR [edi+1]
	mov	DWORD PTR _mission$[esp+92], eax
	cmp	DWORD PTR [esi+8], ebp
	jae	SHORT $LN42@WaitFor
	push	ebp
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<MissionData,12,1,297,0>::GrowSize
$LN42@WaitFor:
	cmp	edi, 1
	mov	DWORD PTR [esi+4], ebp
	jl	SHORT $LN35@WaitFor
	lea	ecx, DWORD PTR [edi+edi*4]
	add	ecx, ecx
	add	ecx, ecx
	npad	3
$LL37@WaitFor:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+ecx-20]
	add	eax, ecx
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [eax-16]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [eax-12]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [eax-8]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [eax-4]
	sub	ecx, 20					; 00000014H
	sub	edi, 1
	mov	DWORD PTR [eax+16], edx
	jne	SHORT $LL37@WaitFor
$LN35@WaitFor:
	mov	esi, DWORD PTR [esi]
	mov	eax, DWORD PTR _mission$[esp+80]
	mov	ecx, DWORD PTR _mission$[esp+84]
	mov	edx, DWORD PTR _mission$[esp+92]
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ecx
	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], edx

; 349  : 
; 350  : 	CvAssert(kQueue.getLength() < 10);
; 351  : 
; 352  : 	if((hUnit->getOwner() == GC.getGame().getActivePlayer()) && hUnit->IsSelected())

	mov	eax, DWORD PTR _hUnit$[esp+72]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [eax+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	pop	edi
	cmp	esi, eax
	pop	esi
	pop	ebp
	pop	ebx
	jne	SHORT $LN1@WaitFor
	mov	ecx, DWORD PTR _hUnit$[esp+56]
	call	?IsSelected@CvUnit@@QBE_NXZ		; CvUnit::IsSelected
	test	al, al
	je	SHORT $LN1@WaitFor

; 353  : 	{
; 354  : 		GC.GetEngineUserInterface()->setDirty(Waypoints_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	2
	call	eax

; 355  : 		GC.GetEngineUserInterface()->setDirty(SelectionButtons_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	6
	call	eax

; 356  : 		GC.GetEngineUserInterface()->setDirty(UnitInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	19					; 00000013H
	call	eax
$LN1@WaitFor:

; 357  : 	}
; 358  : }

	mov	ecx, DWORD PTR _hUnit$[esp+56]
	mov	BYTE PTR __$EHRec$[esp+68], 0
	test	ecx, ecx
	je	SHORT $LN70@WaitFor
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN70@WaitFor:
	mov	ecx, DWORD PTR _hWaitForUnit$[esp+56]
	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	ecx, ecx
	je	SHORT $LN75@WaitFor
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN75@WaitFor:
	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	mov	DWORD PTR fs:0, ecx
	add	esp, 60					; 0000003cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z$0:
	lea	ecx, DWORD PTR _hWaitForUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z$1:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z$2:
	lea	ecx, DWORD PTR $T223709[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z:
	mov	eax, OFFSET __ehfuncinfo$?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?WaitFor@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@0@Z ENDP ; CvUnitMission::WaitFor
PUBLIC	?ActivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@@Z ; CvUnitMission::ActivateHeadMission
PUBLIC	?DeleteMissionQueueNode@CvUnitMission@@CAPAUMissionData@@V?$FObjectHandle@VCvUnit@@@@PAU2@@Z ; CvUnitMission::DeleteMissionQueueNode
EXTRN	?ClearPathCache@CvUnit@@IAEXXZ:PROC		; CvUnit::ClearPathCache
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?DeleteMissionQueueNode@CvUnitMission@@CAPAUMissionData@@V?$FObjectHandle@VCvUnit@@@@PAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DeleteMissionQueueNode@CvUnitMission@@CAPAUMissionData@@V?$FObjectHandle@VCvUnit@@@@PAU2@@Z$0
__ehfuncinfo$?DeleteMissionQueueNode@CvUnitMission@@CAPAUMissionData@@V?$FObjectHandle@VCvUnit@@@@PAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DeleteMissionQueueNode@CvUnitMission@@CAPAUMissionData@@V?$FObjectHandle@VCvUnit@@@@PAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?DeleteMissionQueueNode@CvUnitMission@@CAPAUMissionData@@V?$FObjectHandle@VCvUnit@@@@PAU2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
$T223863 = 16						; size = 4
$T223862 = 16						; size = 4
_pNode$ = 16						; size = 4
?DeleteMissionQueueNode@CvUnitMission@@CAPAUMissionData@@V?$FObjectHandle@VCvUnit@@@@PAU2@@Z PROC ; CvUnitMission::DeleteMissionQueueNode, COMDAT

; 1903 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DeleteMissionQueueNode@CvUnitMission@@CAPAUMissionData@@V?$FObjectHandle@VCvUnit@@@@PAU2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	push	edi

; 1904 : 	MissionQueueNode* pNextMissionNode;
; 1905 : 
; 1906 : 	CvAssertMsg(pNode != NULL, "Node is not assigned a valid value");
; 1907 : 	CvAssert(hUnit->getOwner() != NO_PLAYER);
; 1908 : 
; 1909 : 	MissionQueue& kQueue = hUnit->m_missionQueue;

	mov	ecx, DWORD PTR _hUnit$[esp+20]

; 1910 : 
; 1911 : 	if(pNode == HeadMissionQueueNode(kQueue))

	cmp	DWORD PTR [ecx+2604], 0
	lea	esi, DWORD PTR [ecx+2600]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	jbe	SHORT $LN15@DeleteMiss
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN14@DeleteMiss
$LN15@DeleteMiss:
	xor	eax, eax
$LN14@DeleteMiss:
	mov	edi, DWORD PTR _pNode$[esp+20]
	cmp	edi, eax
	jne	SHORT $LN4@DeleteMiss

; 1912 : 	{
; 1913 : 		DeactivateHeadMission(hUnit, /*iUnitCycleTimer*/ 1);

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	cl, BYTE PTR _hUnit$[esp+36]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T223862[esp+32], esp
	test	eax, eax
	je	SHORT $LN25@DeleteMiss
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN25@DeleteMiss:
	call	?DeactivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::DeactivateHeadMission
	add	esp, 12					; 0000000cH
$LN4@DeleteMiss:

; 1914 : 	}
; 1915 : 
; 1916 : 	pNextMissionNode = kQueue.deleteNode(pNode);

	sub	edi, DWORD PTR [esi]
	mov	eax, 1717986919				; 66666667H
	imul	edi
	mov	eax, DWORD PTR [esi+4]
	sar	edx, 3
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	lea	edx, DWORD PTR [edi+1]
	cmp	edx, eax
	jae	SHORT $LN29@DeleteMiss
	lea	ecx, DWORD PTR [edi+edi*4]
	add	ecx, ecx
	add	ecx, ecx
	npad	2
$LL31@DeleteMiss:
	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR [eax+ecx+20]
	add	eax, ecx
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [eax+28]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [eax+32]
	mov	DWORD PTR [eax+12], ebx
	mov	ebx, DWORD PTR [eax+36]
	inc	edx
	mov	DWORD PTR [eax+16], ebx
	add	ecx, 20					; 00000014H
	cmp	edx, DWORD PTR [esi+4]
	jb	SHORT $LL31@DeleteMiss
$LN29@DeleteMiss:
	mov	eax, DWORD PTR [esi+4]
	lea	ebx, DWORD PTR [eax-1]
	cmp	DWORD PTR [esi+8], ebx
	jae	SHORT $LN44@DeleteMiss
	push	ebx
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<MissionData,12,1,297,0>::GrowSize
$LN44@DeleteMiss:
	mov	DWORD PTR [esi+4], ebx
	cmp	edi, ebx
	jae	SHORT $LN28@DeleteMiss
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [edi+edi*4]
	lea	edi, DWORD PTR [edx+ecx*4]

; 1917 : 	if(pNextMissionNode == NULL)

	test	edi, edi
	jne	SHORT $LN3@DeleteMiss
$LN111@DeleteMiss:

; 1918 : 		hUnit->ClearPathCache();

	mov	ecx, DWORD PTR _hUnit$[esp+20]
	call	?ClearPathCache@CvUnit@@IAEXXZ		; CvUnit::ClearPathCache
$LN3@DeleteMiss:

; 1919 : 
; 1920 : 	if(pNextMissionNode == HeadMissionQueueNode(kQueue))

	cmp	DWORD PTR [esi+4], 0
	jbe	SHORT $LN56@DeleteMiss
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN55@DeleteMiss

; 1914 : 	}
; 1915 : 
; 1916 : 	pNextMissionNode = kQueue.deleteNode(pNode);

$LN28@DeleteMiss:
	xor	edi, edi

; 1917 : 	if(pNextMissionNode == NULL)

	jmp	SHORT $LN111@DeleteMiss

; 1919 : 
; 1920 : 	if(pNextMissionNode == HeadMissionQueueNode(kQueue))

$LN56@DeleteMiss:
	xor	esi, esi
$LN55@DeleteMiss:
	cmp	edi, esi
	jne	SHORT $LN2@DeleteMiss

; 1921 : 	{
; 1922 : 		ActivateHeadMission(hUnit);

	mov	ecx, DWORD PTR _hUnit$[esp+20]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _hUnit$[esp+32]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T223863[esp+28], esp
	test	eax, eax
	je	SHORT $LN66@DeleteMiss
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN66@DeleteMiss:
	call	?ActivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@@Z ; CvUnitMission::ActivateHeadMission
	add	esp, 8
$LN2@DeleteMiss:

; 1923 : 	}
; 1924 : 
; 1925 : 	if((hUnit->getOwner() == GC.getGame().getActivePlayer()) && hUnit->IsSelected())

	mov	eax, DWORD PTR _hUnit$[esp+20]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [eax+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	SHORT $LN1@DeleteMiss
	mov	ecx, DWORD PTR _hUnit$[esp+20]
	call	?IsSelected@CvUnit@@QBE_NXZ		; CvUnit::IsSelected
	test	al, al
	je	SHORT $LN1@DeleteMiss

; 1926 : 	{
; 1927 : 		GC.GetEngineUserInterface()->setDirty(Waypoints_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	2
	call	eax

; 1928 : 		GC.GetEngineUserInterface()->setDirty(SelectionButtons_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	6
	call	eax

; 1929 : 		GC.GetEngineUserInterface()->setDirty(UnitInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	19					; 00000013H
	call	eax
$LN1@DeleteMiss:

; 1930 : 	}
; 1931 : 
; 1932 : 	return pNextMissionNode;

	mov	ecx, DWORD PTR _hUnit$[esp+20]
	mov	DWORD PTR __$EHRec$[esp+32], -1
	test	ecx, ecx
	je	SHORT $LN112@DeleteMiss
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN112@DeleteMiss:

; 1933 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DeleteMissionQueueNode@CvUnitMission@@CAPAUMissionData@@V?$FObjectHandle@VCvUnit@@@@PAU2@@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?DeleteMissionQueueNode@CvUnitMission@@CAPAUMissionData@@V?$FObjectHandle@VCvUnit@@@@PAU2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DeleteMissionQueueNode@CvUnitMission@@CAPAUMissionData@@V?$FObjectHandle@VCvUnit@@@@PAU2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DeleteMissionQueueNode@CvUnitMission@@CAPAUMissionData@@V?$FObjectHandle@VCvUnit@@@@PAU2@@Z ENDP ; CvUnitMission::DeleteMissionQueueNode
PUBLIC	?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z ; FAutoArchive::touch
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautoarchive.h
;	COMDAT ?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
$T224095 = -8						; size = 8
$T224094 = 8						; size = 4
_dirtyVariable$ = 8					; size = 4
?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z PROC	; FAutoArchive::touch, COMDAT
; _this$ = ecx

; 55   : 	{

	sub	esp, 8

; 56   : #ifdef FAUTOARCHIVE_DEBUG
; 57   : 		debugHelp(dirtyVariable);
; 58   : #endif//FAUTOARCHIVE_DEBUG
; 59   : 		m_deltas.insert(&dirtyVariable);

	mov	eax, DWORD PTR _dirtyVariable$[esp+4]
	lea	edx, DWORD PTR $T224094[esp+4]
	mov	DWORD PTR $T224094[esp+4], eax
	push	edx
	lea	eax, DWORD PTR $T224095[esp+12]
	push	eax
	add	ecx, 20					; 00000014H
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert

; 60   : 	}

	add	esp, 8
	ret	4
?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z ENDP	; FAutoArchive::touch
_TEXT	ENDS
PUBLIC	?set@?$FAutoVariable@HVCvUnit@@@@QAEXABH@Z	; FAutoVariable<int,CvUnit>::set
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?set@?$FAutoVariable@HVCvUnit@@@@QAEXABH@Z
_TEXT	SEGMENT
$T224105 = -8						; size = 8
$T224104 = 8						; size = 4
_source$ = 8						; size = 4
?set@?$FAutoVariable@HVCvUnit@@@@QAEXABH@Z PROC		; FAutoVariable<int,CvUnit>::set, COMDAT
; _this$ = ecx

; 225  : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 226  : 	if(m_value != source)

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _source$[esp+12]
	cmp	eax, DWORD PTR [edi]
	je	SHORT $LN1@set

; 227  : 	{
; 228  : 		m_owner.touch(*this);

	lea	ecx, DWORD PTR $T224104[esp+12]
	push	ecx
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR $T224105[esp+20]
	push	edx
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T224104[esp+20], esi
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert

; 229  : 		m_value = source;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
$LN1@set:
	pop	edi
	pop	esi

; 230  : 	}
; 231  : }

	add	esp, 8
	ret	4
?set@?$FAutoVariable@HVCvUnit@@@@QAEXABH@Z ENDP		; FAutoVariable<int,CvUnit>::set
_TEXT	ENDS
PUBLIC	?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z ; CvUnitMission::PopMission
EXTRN	??3CvDllUnit@@SAXPAX@Z:PROC			; CvDllUnit::operator delete
EXTRN	??0CvDllUnit@@QAE@PAVCvUnit@@@Z:PROC		; CvDllUnit::CvDllUnit
EXTRN	??2CvDllUnit@@SAPAXI@Z:PROC			; CvDllUnit::operator new
EXTRN	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z:PROC ; CvPlayer::changeNumResourceUsed
EXTRN	?getResourceQuantityRequirement@CvRouteInfo@@QBEHH@Z:PROC ; CvRouteInfo::getResourceQuantityRequirement
EXTRN	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z:PROC ; CvGlobals::getRouteInfo
EXTRN	?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetResourceQuantityRequirement
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?getRoute@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getRoute
EXTRN	?getImprovement@CvBuildInfo@@QBEHXZ:PROC	; CvBuildInfo::getImprovement
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
EXTRN	?getBuildType@CvUnit@@QBE?AW4BuildTypes@@XZ:PROC ; CvUnit::getBuildType
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$2
__ehfuncinfo$?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
$T224114 = -16						; size = 4
$T224111 = -16						; size = 4
_pDllUnit$218133 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvUnitMission::PopMission, COMDAT

; 257  : {

	push	-1
	push	__ehhandler$?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebp
	push	esi
	push	edi

; 258  : 	CvAssert(hUnit->getOwner() != NO_PLAYER);
; 259  : 
; 260  : 	// Update Resource info
; 261  : 	if(hUnit->getBuildType() != NO_BUILD)

	mov	ecx, DWORD PTR _hUnit$[esp+24]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	?getBuildType@CvUnit@@QBE?AW4BuildTypes@@XZ ; CvUnit::getBuildType
	cmp	eax, -1
	je	$LN46@PopMission

; 262  : 	{
; 263  : 		ImprovementTypes eImprovement = NO_IMPROVEMENT;
; 264  : 		RouteTypes eRoute = NO_ROUTE;
; 265  : 
; 266  : 		CvBuildInfo* pkBuildInfo = GC.getBuildInfo(hUnit->getBuildType());

	mov	ecx, DWORD PTR _hUnit$[esp+24]
	or	ebp, -1
	or	edi, ebp
	call	?getBuildType@CvUnit@@QBE?AW4BuildTypes@@XZ ; CvUnit::getBuildType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	esi, eax

; 267  : 		if(pkBuildInfo)

	test	esi, esi
	je	SHORT $LN11@PopMission

; 268  : 		{
; 269  : 			if(pkBuildInfo->getImprovement() != NO_IMPROVEMENT)

	mov	ecx, esi
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement

; 270  : 			{
; 271  : 				eImprovement = (ImprovementTypes) pkBuildInfo->getImprovement();

	mov	ecx, esi
	cmp	eax, ebp
	je	SHORT $LN13@PopMission
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	ebp, eax
	jmp	SHORT $LN11@PopMission
$LN13@PopMission:

; 272  : 			}
; 273  : 			else if(pkBuildInfo->getRoute() != NO_ROUTE)

	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	cmp	eax, -1
	je	SHORT $LN11@PopMission

; 274  : 			{
; 275  : 				eRoute = (RouteTypes) pkBuildInfo->getRoute();

	mov	ecx, esi
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	mov	edi, eax
$LN11@PopMission:

; 276  : 			}
; 277  : 		}
; 278  : 
; 279  : 		int iNumResource;
; 280  : 
; 281  : 		// Update the amount of a Resource used up by popped Build
; 282  : #ifdef AUI_WARNING_FIXES
; 283  : 		for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 284  : #else
; 285  : 		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	SHORT $LN8@PopMission
	npad	5
$LL10@PopMission:

; 286  : #endif
; 287  : 		{
; 288  : 			iNumResource = 0;
; 289  : 
; 290  : 			if(eImprovement != NO_IMPROVEMENT)

	cmp	ebp, -1
	je	SHORT $LN7@PopMission

; 291  : 			{
; 292  : 				CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 293  : 				if(pkImprovementInfo)

	test	eax, eax
	je	SHORT $LN9@PopMission

; 294  : 				{
; 295  : 					iNumResource += pkImprovementInfo->GetResourceQuantityRequirement(iResourceLoop);

	push	esi
	mov	ecx, eax
	call	?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetResourceQuantityRequirement

; 296  : 				}
; 297  : 			}

	jmp	SHORT $LN3@PopMission
$LN7@PopMission:

; 298  : 			else if(eRoute != NO_ROUTE)

	cmp	edi, -1
	je	SHORT $LN9@PopMission

; 299  : 			{
; 300  : 				CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo

; 301  : 				if(pkRouteInfo)

	test	eax, eax
	je	SHORT $LN9@PopMission

; 302  : 				{
; 303  : 					iNumResource += pkRouteInfo->getResourceQuantityRequirement(iResourceLoop);

	push	esi
	mov	ecx, eax
	call	?getResourceQuantityRequirement@CvRouteInfo@@QBEHH@Z ; CvRouteInfo::getResourceQuantityRequirement
$LN3@PopMission:

; 304  : 				}
; 305  : 			}
; 306  : 
; 307  : 			if(iNumResource > 0)

	test	eax, eax
	jle	SHORT $LN9@PopMission

; 308  : 			{
; 309  : 				GET_PLAYER(hUnit->getOwner()).changeNumResourceUsed((ResourceTypes) iResourceLoop, -iNumResource);

	mov	ecx, DWORD PTR _hUnit$[esp+24]
	mov	ecx, DWORD PTR [ecx+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	neg	eax
	push	eax
	push	esi
	call	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeNumResourceUsed
$LN9@PopMission:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jl	SHORT $LL10@PopMission
$LN8@PopMission:

; 310  : 			}
; 311  : 		}
; 312  : 
; 313  : 		auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(hUnit.pointer()));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T224111[esp+28], eax
	mov	BYTE PTR __$EHRec$[esp+36], 1
	test	eax, eax
	je	SHORT $LN18@PopMission
	mov	edx, DWORD PTR _hUnit$[esp+24]
	push	edx
	mov	ecx, eax
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	esi, eax
	jmp	SHORT $LN19@PopMission
$LN18@PopMission:
	xor	esi, esi
$LN19@PopMission:
	mov	DWORD PTR _pDllUnit$218133[esp+28], esi

; 314  : 		gDLL->GameplayUnitWork(pDllUnit.get(), -1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+612]
	push	-1
	push	esi
	mov	BYTE PTR __$EHRec$[esp+44], 2
	call	edx

; 315  : 	}

	mov	BYTE PTR __$EHRec$[esp+36], 0
	test	esi, esi
	je	SHORT $LN46@PopMission
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	esi
	call	ecx
$LN46@PopMission:

; 316  : 
; 317  : 	MissionQueueNode* pTailNode = TailMissionQueueNode(hUnit->m_missionQueue);

	mov	ecx, DWORD PTR _hUnit$[esp+24]
	mov	eax, DWORD PTR [ecx+2604]
	test	eax, eax
	jbe	SHORT $LN1@PopMission
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx+2600]
	lea	eax, DWORD PTR [eax+edx*4-20]

; 318  : 
; 319  : 	if(pTailNode != NULL)

	test	eax, eax
	je	SHORT $LN1@PopMission

; 320  : 	{
; 321  : 		DeleteMissionQueueNode(hUnit, pTailNode);

	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	cl, BYTE PTR _hUnit$[esp+40]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T224114[esp+40], esp
	test	eax, eax
	je	SHORT $LN64@PopMission
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN64@PopMission:
	call	?DeleteMissionQueueNode@CvUnitMission@@CAPAUMissionData@@V?$FObjectHandle@VCvUnit@@@@PAU2@@Z ; CvUnitMission::DeleteMissionQueueNode
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	add	esp, 12					; 0000000cH
$LN1@PopMission:

; 322  : 	}
; 323  : }

	mov	DWORD PTR __$EHRec$[esp+36], -1
	test	ecx, ecx
	je	SHORT $LN69@PopMission
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN69@PopMission:
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebp
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$1:
	mov	eax, DWORD PTR $T224111[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$2:
	lea	ecx, DWORD PTR _pDllUnit$218133[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__ehhandler$?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvUnitMission::PopMission
PUBLIC	?ClearMissionQueue@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::ClearMissionQueue
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ClearMissionQueue@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ClearMissionQueue@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z$0
__ehfuncinfo$?ClearMissionQueue@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ClearMissionQueue@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?ClearMissionQueue@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
$T224235 = 16						; size = 4
$T224234 = 16						; size = 4
_iUnitCycleTimerOverride$ = 16				; size = 4
?ClearMissionQueue@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z PROC ; CvUnitMission::ClearMissionQueue, COMDAT

; 1938 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ClearMissionQueue@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi

; 1939 : 	//VALIDATE_OBJECT
; 1940 : 	CvAssert(hUnit->getOwner() != NO_PLAYER);
; 1941 : 
; 1942 : 	DeactivateHeadMission(hUnit, iUnitCycleTimerOverride);

	mov	eax, DWORD PTR _iUnitCycleTimerOverride$[esp+12]
	mov	ecx, DWORD PTR _hUnit$[esp+12]
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _hUnit$[esp+28]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR $T224234[esp+24], esp
	test	eax, eax
	je	SHORT $LN12@ClearMissi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN12@ClearMissi:
	call	?DeactivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::DeactivateHeadMission

; 1943 : 
; 1944 : 	while(hUnit->m_missionQueue.getLength() > 0)

	mov	ecx, DWORD PTR _hUnit$[esp+24]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [ecx+2604], 0
	jle	SHORT $LN2@ClearMissi
	npad	7
$LL3@ClearMissi:

; 1945 : 	{
; 1946 : 		PopMission(hUnit);

	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	cl, BYTE PTR _hUnit$[esp+24]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T224235[esp+20], esp
	test	eax, eax
	je	SHORT $LN23@ClearMissi
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN23@ClearMissi:
	call	?PopMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z ; CvUnitMission::PopMission
	mov	ecx, DWORD PTR _hUnit$[esp+20]
	add	esp, 8
	cmp	DWORD PTR [ecx+2604], 0
	jg	SHORT $LL3@ClearMissi
$LN2@ClearMissi:

; 1947 : 	}
; 1948 : 
; 1949 : 	hUnit->ClearPathCache();

	call	?ClearPathCache@CvUnit@@IAEXXZ		; CvUnit::ClearPathCache

; 1950 : //	hUnit->m_missionQueue.clear();
; 1951 : 
; 1952 : 	if((hUnit->getOwner() == GC.getGame().getActivePlayer()) && hUnit->IsSelected())

	mov	edx, DWORD PTR _hUnit$[esp+12]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [edx+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	SHORT $LN1@ClearMissi
	mov	ecx, DWORD PTR _hUnit$[esp+12]
	call	?IsSelected@CvUnit@@QBE_NXZ		; CvUnit::IsSelected
	test	al, al
	je	SHORT $LN1@ClearMissi

; 1953 : 	{
; 1954 : 		GC.GetEngineUserInterface()->setDirty(Waypoints_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	2
	call	edx

; 1955 : 		GC.GetEngineUserInterface()->setDirty(SelectionButtons_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	6
	call	edx

; 1956 : 		GC.GetEngineUserInterface()->setDirty(UnitInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	19					; 00000013H
	call	edx
$LN1@ClearMissi:

; 1957 : 	}
; 1958 : }

	mov	ecx, DWORD PTR _hUnit$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], -1
	test	ecx, ecx
	je	SHORT $LN46@ClearMissi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN46@ClearMissi:
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ClearMissionQueue@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ClearMissionQueue@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?ClearMissionQueue@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ClearMissionQueue@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z ENDP ; CvUnitMission::ClearMissionQueue
PUBLIC	??4?$FAutoVariable@HVCvUnit@@@@QAEAAHABH@Z	; FAutoVariable<int,CvUnit>::operator=
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??4?$FAutoVariable@HVCvUnit@@@@QAEAAHABH@Z
_TEXT	SEGMENT
$T224339 = -8						; size = 8
$T224338 = 8						; size = 4
_rhs$ = 8						; size = 4
??4?$FAutoVariable@HVCvUnit@@@@QAEAAHABH@Z PROC		; FAutoVariable<int,CvUnit>::operator=, COMDAT
; _this$ = ecx

; 201  : {

	sub	esp, 8
	push	esi
	push	edi

; 202  : 	if(rhs != m_value)

	mov	edi, DWORD PTR _rhs$[esp+12]
	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [ecx+4]
	lea	esi, DWORD PTR [ecx+4]
	je	SHORT $LN9@operator@3

; 203  : 	{
; 204  : 		set(rhs);

	mov	DWORD PTR $T224338[esp+12], ecx
	mov	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR $T224338[esp+12]
	push	edx
	lea	eax, DWORD PTR $T224339[esp+20]
	push	eax
	add	ecx, 20					; 00000014H
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx
$LN9@operator@3:
	pop	edi

; 205  : 	}
; 206  : 	return m_value;

	mov	eax, esi
	pop	esi

; 207  : }

	add	esp, 8
	ret	4
??4?$FAutoVariable@HVCvUnit@@@@QAEAAHABH@Z ENDP		; FAutoVariable<int,CvUnit>::operator=
_TEXT	ENDS
PUBLIC	?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z ; CvUnitMission::ContinueMission
EXTRN	?SetCombatWarned@CvGame@@QAEX_N@Z:PROC		; CvGame::SetCombatWarned
EXTRN	?PublishQueuedVisualizationMoves@CvUnit@@IAEXXZ:PROC ; CvUnit::PublishQueuedVisualizationMoves
EXTRN	?isInCombat@CvUnit@@QBE_NXZ:PROC		; CvUnit::isInCombat
EXTRN	?GetMissionTimer@CvUnit@@QBEHXZ:PROC		; CvUnit::GetMissionTimer
EXTRN	?IsWork@CvUnit@@QBE_NXZ:PROC			; CvUnit::IsWork
EXTRN	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z:PROC ; CvGlobals::WrapPlotPointer
EXTRN	?isActiveVisible@CvPlot@@QBE_N_N@Z:PROC		; CvPlot::isActiveVisible
EXTRN	?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ:PROC	; CvPlot::isVisibleToWatchingHuman
EXTRN	?ChangeMissionTimer@CvUnit@@QAEXH@Z:PROC	; CvUnit::ChangeMissionTimer
EXTRN	?getMISSION_DIE_ANIMATION@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_DIE_ANIMATION
EXTRN	?at@CvUnit@@QBE_NHH@Z:PROC			; CvUnit::at
EXTRN	?HeadMissionQueueNode@CvUnit@@IAEPAUMissionData@@XZ:PROC ; CvUnit::HeadMissionQueueNode
EXTRN	?UnitBuild@CvUnit@@QAE_NW4BuildTypes@@@Z:PROC	; CvUnit::UnitBuild
EXTRN	?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z:PROC ; CvUnitCombat::AttackNuclear
EXTRN	?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z:PROC ; CvUnitCombat::AttackRanged
EXTRN	?isPotentialEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isPotentialEnemy
EXTRN	?GetMissionAIPlot@CvUnit@@QAEPAVCvPlot@@XZ:PROC	; CvUnit::GetMissionAIPlot
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
EXTRN	?GetMissionAIType@CvUnit@@QAE?AW4MissionAITypes@@XZ:PROC ; CvUnit::GetMissionAIType
EXTRN	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z:PROC ; CvPlot::getBestDefender
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?UnitPathTo@CvUnit@@QAEHHHHH_N@Z:PROC		; CvUnit::UnitPathTo
EXTRN	?ReadyToMove@CvUnit@@QBE_NXZ:PROC		; CvUnit::ReadyToMove
EXTRN	?AreUnitsOfSameType@CvUnit@@QBE_NABV1@_N@Z:PROC	; CvUnit::AreUnitsOfSameType
EXTRN	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z:PROC	; CvPlot::getUnitByIndex
EXTRN	?getNumUnits@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumUnits
EXTRN	?UnitRoadTo@CvUnit@@QAE_NHHH@Z:PROC		; CvUnit::UnitRoadTo
EXTRN	?UnitAttack@CvUnit@@QAE_NHHHH@Z:PROC		; CvUnit::UnitAttack
EXTRN	?GetCombatPrediction@CvGame@@QAE?AW4CombatPredictionTypes@@PBVCvUnit@@0@Z:PROC ; CvGame::GetCombatPrediction
EXTRN	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z:PROC ; CvPlot::getVisibleEnemyDefender
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
EXTRN	?IsCombatWarned@CvGame@@QBE_NXZ:PROC		; CvGame::IsCombatWarned
EXTRN	?isNetworkMultiplayerGame@CvPreGame@@YA_NXZ:PROC ; CvPreGame::isNetworkMultiplayerGame
EXTRN	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z:PROC	; CvUnit::canMoveInto
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
EXTRN	?canMove@CvUnit@@QBE_NXZ:PROC			; CvUnit::canMove
EXTRN	?IsDoingPartialMove@CvUnit@@QBE_NXZ:PROC	; CvUnit::IsDoingPartialMove
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z$13
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z
_TEXT	SEGMENT
_bDone$218175 = -594					; size = 1
_bAction$218176 = -593					; size = 1
tv1646 = -592						; size = 4
$T224401 = -592						; size = 4
$T224465 = -592						; size = 4
_pDllPlot$218352 = -592					; size = 4
$T224350 = -592						; size = 4
_bBadAttackInterrupt$218191 = -585			; size = 1
$T225499 = -584						; size = 4
$T224357 = -584						; size = 4
$T224354 = -584						; size = 4
_pDllUnit$218379 = -584					; size = 4
$T224351 = -584						; size = 4
_pTargetUnit$218286 = -580				; size = 8
$T224349 = -572						; size = 8
$T225500 = -564						; size = 8
$T224402 = -564						; size = 8
_pTargetUnit$218253 = -556				; size = 8
_kPopup$218214 = -548					; size = 536
_kPopup$218198 = -548					; size = 536
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
_iSteps$ = 16						; size = 4
_iETA$ = 20						; size = 4
?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z PROC ; CvUnitMission::ContinueMission, COMDAT

; 393  : {

	push	-1
	push	__ehhandler$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 584				; 00000248H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 394  : 	hUnit->ClearPathCache();		// At the start of the continue, clear any cached path.  The cache will be rebuilt and reused while the mission loops in this method

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	mov	DWORD PTR __$EHRec$[esp+620], 0
	call	?ClearPathCache@CvUnit@@IAEXXZ		; CvUnit::ClearPathCache
	npad	10
$LL109@ContinueMi:

; 395  : 
; 396  : 	bool bContinueMissionRestart = true;	// to make this function no longer recursive
; 397  : 	while(bContinueMissionRestart)
; 398  : 	{
; 399  : 		bContinueMissionRestart = false;
; 400  : 
; 401  : 		bool bDone = false;   // are we done with mission?
; 402  : 		bool bAction = false; // are we taking an action this turn?
; 403  : 
; 404  : 		// slewis - important modification!
; 405  : 		// This function may call the pathfinder multiple times.
; 406  : 		// That can cause partial moves to be impossible in certain circumstances.
; 407  : 		// We need a way to determine if the pathfinder can be used without breaking the currently built path.
; 408  : 		// I added unit flags to accomplish this. (While this flag does not necessarily need to be serialized,
; 409  : 		// the variable is serialized for future proofing.)
; 410  : 		hUnit->m_iFlags = hUnit->m_iFlags | CvUnit::UNITFLAG_EVALUATING_MISSION;

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	mov	esi, DWORD PTR [ecx+1364]
	or	esi, 1
	lea	edi, DWORD PTR [ecx+1360]
	mov	BYTE PTR _bDone$218175[esp+612], 0
	mov	BYTE PTR _bAction$218176[esp+612], 0
	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN135@ContinueMi
	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR $T224401[esp+612]
	push	ecx
	lea	edx, DWORD PTR $T224402[esp+616]
	push	edx
	lea	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T224401[esp+620], edi
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	DWORD PTR [edi+4], esi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
$LN135@ContinueMi:

; 411  : 
; 412  : 		// slewis - more important info!
; 413  : 		// I replaced all the "return"s in this function with "goto"s.
; 414  : 		// This ensures that every way this function is exited, it always clears out the unit flag evaluation mission.
; 415  : 		// I know gotos are frowned upon, but if anyone else wants to re-write and test this function, be my guest.
; 416  : 
; 417  : 		CvAssert(!hUnit->isInCombat());
; 418  : 		CvAssert(hUnit->HeadMissionQueueNode() != NULL);
; 419  : 		CvAssert(hUnit->getOwner() != NO_PLAYER);
; 420  : 		CvAssert(hUnit->GetActivityType() == ACTIVITY_MISSION);
; 421  : 
; 422  : 		if(HeadMissionQueueNode(hUnit->m_missionQueue) == NULL)

	cmp	DWORD PTR [ecx+2604], 0
	jbe	$LN630@ContinueMi
	cmp	DWORD PTR [ecx+2600], 0
	je	$LN630@ContinueMi

; 427  : 		}
; 428  : 
; 429  : 		CvAssert(iSteps < 100);
; 430  : 		if(iSteps >= 100)

	cmp	DWORD PTR _iSteps$[esp+608], 100	; 00000064H
	jge	$ContinueMissionExit$218179

; 431  : 			goto ContinueMissionExit;
; 432  : 
; 433  : 		const MissionData* pkMissionData = (HeadMissionQueueNode(hUnit->m_missionQueue));

	mov	eax, DWORD PTR _hUnit$[esp+608]
	cmp	DWORD PTR [eax+2604], 0
	jbe	SHORT $LN159@ContinueMi
	mov	edi, DWORD PTR [eax+2600]
	jmp	SHORT $LN667@ContinueMi
$LN159@ContinueMi:
	xor	edi, edi
$LN667@ContinueMi:

; 434  : 
; 435  : 		if(pkMissionData->iPushTurn == GC.getGame().getGameTurn() || (pkMissionData->iFlags & MOVE_UNITS_THROUGH_ENEMY))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224465[esp+612], edi
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	DWORD PTR [edi+16], eax
	je	SHORT $LN102@ContinueMi
	test	BYTE PTR [edi+12], 16			; 00000010H
	je	$LN84@ContinueMi
$LN102@ContinueMi:

; 436  : 		{
; 437  : #ifdef AUI_UNIT_MISSION_FIX_CONTINUE_MISSION_CIVILIANS_DONT_ATTEMPT_ATTACK
; 438  : 			if (pkMissionData->eMissionType == CvTypes::getMISSION_MOVE_TO() && !hUnit->IsDoingPartialMove() && hUnit->canMove() && hUnit->IsCanAttack() && hUnit->m_unitMoveLocs.size() == 0)
; 439  : #else
; 440  : 			if(pkMissionData->eMissionType == CvTypes::getMISSION_MOVE_TO() && !hUnit->IsDoingPartialMove() && hUnit->canMove() && hUnit->m_unitMoveLocs.size() == 0)

	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	cmp	DWORD PTR [edi], eax
	jne	$LN84@ContinueMi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?IsDoingPartialMove@CvUnit@@QBE_NXZ	; CvUnit::IsDoingPartialMove
	test	al, al
	jne	$LN84@ContinueMi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN84@ContinueMi
	mov	eax, DWORD PTR _hUnit$[esp+608]
	cmp	DWORD PTR [eax+2400], 0
	jne	$LN84@ContinueMi

; 441  : #endif
; 442  : 			{
; 443  : 				CvPlot* pPlot = GC.getMap().plot(pkMissionData->iData1, pkMissionData->iData2);

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edi+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN178@ContinueMi
	cmp	ebx, -2147483647			; 80000001H
	je	$LN178@ContinueMi
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	dl, dl
	je	SHORT $LN188@ContinueMi
	test	eax, eax
	jge	SHORT $LN190@ContinueMi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN192@ContinueMi
$LN190@ContinueMi:
	cmp	eax, ecx
	jl	SHORT $LN188@ContinueMi
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN192@ContinueMi
$LN188@ContinueMi:
	mov	esi, eax
$LN192@ContinueMi:
	mov	al, BYTE PTR [ebp+4057]
	mov	edi, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN198@ContinueMi
	test	ebx, ebx
	jge	SHORT $LN200@ContinueMi
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN202@ContinueMi
$LN200@ContinueMi:
	cmp	ebx, edi
	jl	SHORT $LN198@ContinueMi
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN202@ContinueMi
$LN198@ContinueMi:
	mov	edx, ebx
$LN202@ContinueMi:
	test	esi, esi
	jl	SHORT $LN182@ContinueMi
	cmp	esi, ecx
	jge	SHORT $LN182@ContinueMi
	test	edx, edx
	jl	SHORT $LN182@ContinueMi
	cmp	edx, edi
	jge	SHORT $LN182@ContinueMi
	mov	edi, DWORD PTR $T224465[esp+612]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	esi, ecx
	jmp	SHORT $LN180@ContinueMi
$LN182@ContinueMi:
	mov	edi, DWORD PTR $T224465[esp+612]
$LN178@ContinueMi:
	xor	esi, esi
$LN180@ContinueMi:

; 444  : 				if(hUnit->IsAutomated() && pPlot->isVisible(hUnit->getTeam()) && hUnit->canMoveInto(*pPlot, CvUnit::MOVEFLAG_ATTACK))

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	test	al, al
	je	SHORT $LN100@ContinueMi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, esi
	call	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isVisible
	test	al, al
	je	SHORT $LN100@ContinueMi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	push	1
	push	esi
	call	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveInto
	test	al, al

; 445  : 				{
; 446  : 					// if we're automated and try to attack, consider this move OVAH
; 447  : 					bDone = true;
; 448  : 				}
; 449  : 				else

	jne	$LN668@ContinueMi
$LN100@ContinueMi:

; 450  : 				{
; 451  : 					bool bCityAttackInterrupt = gDLL->GetAdvisorCityAttackInterrupt();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+864]
	call	eax

; 452  : 					bool bBadAttackInterrupt = gDLL->GetAdvisorBadAttackInterrupt();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	bl, al
	mov	eax, DWORD PTR [edx+856]
	call	eax

; 453  : 					if(hUnit->isHuman() && !CvPreGame::isNetworkMultiplayerGame() && !GC.getGame().IsCombatWarned() && (bCityAttackInterrupt || bBadAttackInterrupt))

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	mov	BYTE PTR _bBadAttackInterrupt$218191[esp+612], al
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	je	$LN86@ContinueMi
	call	?isNetworkMultiplayerGame@CvPreGame@@YA_NXZ ; CvPreGame::isNetworkMultiplayerGame
	test	al, al
	jne	$LN86@ContinueMi
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?IsCombatWarned@CvGame@@QBE_NXZ		; CvGame::IsCombatWarned
	test	al, al
	jne	$LN86@ContinueMi
	test	bl, bl
	jne	SHORT $LN97@ContinueMi
	cmp	BYTE PTR _bBadAttackInterrupt$218191[esp+612], bl
	je	$LN86@ContinueMi
$LN97@ContinueMi:

; 454  : 					{
; 455  : 						if(hUnit->canMoveInto(*pPlot, CvUnit::MOVEFLAG_ATTACK) && pPlot->isVisible(hUnit->getTeam()))

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	push	1
	push	esi
	call	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveInto
	test	al, al
	je	$LN86@ContinueMi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, esi
	call	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isVisible
	test	al, al
	je	$LN86@ContinueMi

; 456  : 						{
; 457  : 							if(pPlot->isCity())

	mov	ecx, esi
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	test	al, al
	je	$LN95@ContinueMi

; 458  : 							{
; 459  : 								if(bCityAttackInterrupt)

	test	bl, bl
	je	$LN86@ContinueMi

; 460  : 								{
; 461  : 									GC.GetEngineUserInterface()->SetDontShowPopups(false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+556]
	push	0
	call	eax

; 462  : 
; 463  : 									if(!GC.getGame().isOption(GAMEOPTION_NO_TUTORIAL))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	20					; 00000014H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	jne	$LN86@ContinueMi

; 464  : 									{
; 465  : 										// do city alert
; 466  : 										CvPopupInfo kPopup(BUTTONPOPUP_ADVISOR_MODAL);

	or	eax, -1

; 467  : 										kPopup.iData1 = ADVISOR_MILITARY;
; 468  : 										kPopup.iData2 = pPlot->GetPlotIndex();

	mov	ecx, esi
	mov	DWORD PTR _kPopup$218198[esp+616], eax
	mov	DWORD PTR _kPopup$218198[esp+620], eax
	mov	DWORD PTR _kPopup$218198[esp+624], 0
	mov	BYTE PTR _kPopup$218198[esp+628], 0
	mov	BYTE PTR _kPopup$218198[esp+629], 0
	mov	DWORD PTR _kPopup$218198[esp+632], 72	; 00000048H
	mov	BYTE PTR _kPopup$218198[esp+636], 0
	mov	DWORD PTR _kPopup$218198[esp+612], 0
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex

; 469  : 										kPopup.iData3 = hUnit->plot()->GetPlotIndex();

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	mov	DWORD PTR _kPopup$218198[esp+616], eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex

; 470  : 										strcpy_s(kPopup.szText, "TXT_KEY_ADVISOR_CITY_ATTACK_BODY");

	lea	ecx, DWORD PTR _kPopup$218198[esp+636]
	push	OFFSET $SG218204
	push	ecx
	mov	DWORD PTR _kPopup$218198[esp+628], eax
	call	??$strcpy_s@$0CAA@@@YAHAAY0CAA@DPBD@Z	; strcpy_s<512>

; 471  : 										kPopup.bOption1 = true;
; 472  : 										GC.GetEngineUserInterface()->AddPopup(kPopup);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	BYTE PTR _kPopup$218198[esp+636], 1
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+180]
	add	esp, 8
	lea	eax, DWORD PTR _kPopup$218198[esp+612]
	push	eax
	call	edx

; 473  : 										goto ContinueMissionExit;

	jmp	$ContinueMissionExit$218179
$LN95@ContinueMi:

; 474  : 									}
; 475  : 								}
; 476  : 							}
; 477  : 							else if(bBadAttackInterrupt)

	cmp	BYTE PTR _bBadAttackInterrupt$218191[esp+612], 0
	je	SHORT $LN86@ContinueMi

; 478  : 							{
; 479  : 								CvUnit* pDefender = pPlot->getVisibleEnemyDefender(hUnit->getOwner());

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	mov	eax, DWORD PTR [ecx+40]
	push	eax
	mov	ecx, esi
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender

; 480  : 								if(pDefender)

	test	eax, eax
	je	SHORT $LN86@ContinueMi

; 481  : 								{
; 482  : 									CombatPredictionTypes ePrediction = GC.getGame().GetCombatPrediction(hUnit.pointer(), pDefender);

	mov	edx, DWORD PTR _hUnit$[esp+608]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	eax
	push	edx
	call	?GetCombatPrediction@CvGame@@QAE?AW4CombatPredictionTypes@@PBVCvUnit@@0@Z ; CvGame::GetCombatPrediction

; 483  : 									if(ePrediction == COMBAT_PREDICTION_TOTAL_DEFEAT || ePrediction == COMBAT_PREDICTION_MAJOR_DEFEAT)

	cmp	eax, 2
	je	SHORT $LN87@ContinueMi
	cmp	eax, 6
	jne	SHORT $LN86@ContinueMi
$LN87@ContinueMi:

; 484  : 									{
; 485  : 										if(!GC.getGame().isOption(GAMEOPTION_NO_TUTORIAL))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	20					; 00000014H
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	je	$LN633@ContinueMi
$LN86@ContinueMi:

; 496  : 										}
; 497  : 
; 498  : 									}
; 499  : 								}
; 500  : 							}
; 501  : 						}
; 502  : 					}
; 503  : 
; 504  : 					if(hUnit->UnitAttack(pkMissionData->iData1, pkMissionData->iData2, pkMissionData->iFlags, iSteps))

	mov	eax, DWORD PTR _iSteps$[esp+608]
	mov	ecx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+8]
	push	eax
	mov	eax, DWORD PTR [edi+4]
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+616]
	push	edx
	push	eax
	call	?UnitAttack@CvUnit@@QAE_NHHHH@Z		; CvUnit::UnitAttack
	test	al, al
	je	SHORT $LN84@ContinueMi
$LN668@ContinueMi:

; 505  : 					{
; 506  : 						bDone = true;

	mov	BYTE PTR _bDone$218175[esp+612], 1
$LN84@ContinueMi:

; 507  : 					}
; 508  : 				}
; 509  : 			}
; 510  : 		}
; 511  : 
; 512  : 		// extra crash protection, should never happen (but a previous bug in groupAttack was causing a NULL here)
; 513  : 		// while that bug is fixed, no reason to not be a little more careful
; 514  : 		if(HeadMissionQueueNode(hUnit->m_missionQueue) == NULL)

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	cmp	DWORD PTR [ecx+2604], 0
	lea	ebp, DWORD PTR [ecx+2600]
	mov	DWORD PTR tv1646[esp+612], ebp
	jbe	$LN630@ContinueMi
	cmp	DWORD PTR [ebp], 0
	je	$LN630@ContinueMi

; 515  : 		{
; 516  : 			hUnit->SetActivityType(ACTIVITY_AWAKE);
; 517  : 			goto ContinueMissionExit;
; 518  : 		}
; 519  : 
; 520  : 		const MissionQueue& kMissionQueue = hUnit->m_missionQueue;
; 521  : 		// If there are units in the selection group, they can all move, and we're not done
; 522  : 		//   then try to follow the misision
; 523  : 		if(!bDone && hUnit->canMove() && !hUnit->IsDoingPartialMove())

	cmp	BYTE PTR _bDone$218175[esp+612], 0
	jne	$LN36@ContinueMi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN640@ContinueMi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?IsDoingPartialMove@CvUnit@@QBE_NXZ	; CvUnit::IsDoingPartialMove
	test	al, al
	jne	$LN640@ContinueMi

; 524  : 		{
; 525  : 			const MissionData& kMissionData = *HeadMissionQueueNode(kMissionQueue);

	cmp	DWORD PTR [ebp+4], 0
	jbe	SHORT $LN289@ContinueMi
	mov	esi, DWORD PTR [ebp]
	jmp	SHORT $LN288@ContinueMi
$LN289@ContinueMi:
	xor	esi, esi
$LN288@ContinueMi:

; 526  : 
; 527  : 			if(kMissionData.eMissionType == CvTypes::getMISSION_MOVE_TO() ||
; 528  : 			        kMissionData.eMissionType == CvTypes::getMISSION_EMBARK() ||
; 529  : 			        kMissionData.eMissionType == CvTypes::getMISSION_DISEMBARK())

	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	cmp	DWORD PTR [esi], eax
	je	$LN79@ContinueMi
	call	?getMISSION_EMBARK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_EMBARK
	cmp	DWORD PTR [esi], eax
	je	$LN79@ContinueMi
	call	?getMISSION_DISEMBARK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_DISEMBARK
	cmp	DWORD PTR [esi], eax
	je	$LN79@ContinueMi

; 553  : 					}
; 554  : 				}
; 555  : 			}
; 556  : 
; 557  : 			else if(kMissionData.eMissionType == CvTypes::getMISSION_ROUTE_TO())

	call	?getMISSION_ROUTE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ROUTE_TO
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN72@ContinueMi

; 558  : 			{
; 559  : 				if(hUnit->UnitRoadTo(kMissionData.iData1, kMissionData.iData2, kMissionData.iFlags))

	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+612]
	push	edx
	push	eax
	call	?UnitRoadTo@CvUnit@@QAE_NHHH@Z		; CvUnit::UnitRoadTo
	test	al, al
	je	$LN669@ContinueMi

; 560  : 				{
; 561  : 					bAction = true;

	mov	BYTE PTR _bAction$218176[esp+612], 1

; 562  : 				}
; 563  : 				else

	jmp	$LN640@ContinueMi
$LN72@ContinueMi:

; 564  : 				{
; 565  : 					bDone = true;
; 566  : 				}
; 567  : 			}
; 568  : 
; 569  : 			else if(kMissionData.eMissionType == CvTypes::getMISSION_SWAP_UNITS())

	call	?getMISSION_SWAP_UNITS@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SWAP_UNITS
	cmp	DWORD PTR [esi], eax
	jne	$LN68@ContinueMi

; 570  : 			{
; 571  : 				CvPlot* pOriginationPlot;
; 572  : 				CvPlot* pTargetPlot;
; 573  : 
; 574  : 				// Get target plot
; 575  : 				pTargetPlot = GC.getMap().plot(kMissionData.iData1, kMissionData.iData2);

	mov	eax, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [esi+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN640@ContinueMi
	cmp	ebx, -2147483647			; 80000001H
	je	$LN640@ContinueMi
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	dl, dl
	je	SHORT $LN316@ContinueMi
	test	eax, eax
	jge	SHORT $LN318@ContinueMi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN320@ContinueMi
$LN318@ContinueMi:
	cmp	eax, ecx
	jl	SHORT $LN316@ContinueMi
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN320@ContinueMi
$LN316@ContinueMi:
	mov	esi, eax
$LN320@ContinueMi:
	mov	al, BYTE PTR [ebp+4057]
	mov	edi, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN326@ContinueMi
	test	ebx, ebx
	jge	SHORT $LN328@ContinueMi
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN330@ContinueMi
$LN328@ContinueMi:
	cmp	ebx, edi
	jl	SHORT $LN326@ContinueMi
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN330@ContinueMi
$LN326@ContinueMi:
	mov	edx, ebx
$LN330@ContinueMi:
	test	esi, esi
	jl	$LN640@ContinueMi
	cmp	esi, ecx
	jge	$LN640@ContinueMi
	test	edx, edx
	jl	$LN640@ContinueMi
	cmp	edx, edi
	jge	$LN640@ContinueMi
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	ebp, ecx

; 576  : 
; 577  : 				if(pTargetPlot != NULL)

	je	$LN640@ContinueMi

; 578  : 				{
; 579  : 					pOriginationPlot = hUnit->plot();

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 580  : 
; 581  : 					if(pTargetPlot->getNumUnits() < 1)

	mov	ecx, ebp
	mov	edi, eax
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	eax, 1
	jl	$ContinueMissionExit$218179

; 582  : 					{
; 583  : 						bAction = false;
; 584  : 						bDone = true;
; 585  : 						break;
; 586  : 					}
; 587  : 
; 588  : 					// Find unit to move out
; 589  : #ifdef AUI_WARNING_FIXES
; 590  : 					for (uint iI = 0; iI < pTargetPlot->getNumUnits(); iI++)
; 591  : #else
; 592  : 					for(int iI = 0; iI < pTargetPlot->getNumUnits(); iI++)

	mov	ecx, ebp
	xor	ebx, ebx
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	$LN640@ContinueMi
$LL65@ContinueMi:

; 593  : #endif
; 594  : 					{
; 595  : 						CvUnit* pUnit2 = pTargetPlot->getUnitByIndex(iI);

	push	ebx
	mov	ecx, ebp
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex

; 596  : 
; 597  : 						if(pUnit2->AreUnitsOfSameType(*(hUnit)) && pUnit2->ReadyToMove())

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	push	0
	mov	esi, eax
	push	ecx
	mov	ecx, esi
	call	?AreUnitsOfSameType@CvUnit@@QBE_NABV1@_N@Z ; CvUnit::AreUnitsOfSameType
	test	al, al
	je	SHORT $LN64@ContinueMi
	mov	ecx, esi
	call	?ReadyToMove@CvUnit@@QBE_NXZ		; CvUnit::ReadyToMove
	test	al, al
	je	SHORT $LN64@ContinueMi

; 598  : 						{
; 599  : 							// Start the swap
; 600  : 							hUnit->UnitPathTo(HeadMissionQueueNode(kMissionQueue)->iData1, HeadMissionQueueNode(kMissionQueue)->iData2, MOVE_IGNORE_STACKING);

	mov	ecx, DWORD PTR tv1646[esp+612]
	push	0
	push	-1
	push	4
	push	ecx
	call	?HeadMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z ; CvUnitMission::HeadMissionQueueNode
	mov	edx, DWORD PTR [eax+8]
	add	esp, 4
	push	edx
	push	ecx
	call	?HeadMissionQueueNode@CvUnitMission@@CAPBUMissionData@@ABV?$FFastSmallFixedList@UMissionData@@$0M@$00$0BCJ@$0A@@@@Z ; CvUnitMission::HeadMissionQueueNode
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _hUnit$[esp+628]
	add	esp, 4
	push	eax
	call	?UnitPathTo@CvUnit@@QAEHHHHH_N@Z	; CvUnit::UnitPathTo

; 601  : 
; 602  : 							// Move the other unit back out
; 603  : 							pUnit2->UnitPathTo(pOriginationPlot->getX(), pOriginationPlot->getY(), 0);

	movsx	ecx, WORD PTR [edi+2]
	movsx	edx, WORD PTR [edi]
	push	0
	push	-1
	push	0
	push	ecx
	push	edx
	mov	ecx, esi
	call	?UnitPathTo@CvUnit@@QAEHHHHH_N@Z	; CvUnit::UnitPathTo

; 604  : 							bDone = true;

	mov	BYTE PTR _bDone$218175[esp+612], 1
$LN64@ContinueMi:
	mov	ecx, ebp
	inc	ebx
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	ebx, eax
	jl	$LL65@ContinueMi

; 605  : 						}
; 606  : 					}
; 607  : 				}
; 608  : 			}

	mov	ebp, DWORD PTR tv1646[esp+612]
	jmp	$LN74@ContinueMi
$LN68@ContinueMi:

; 609  : 
; 610  : 			else if(kMissionData.eMissionType == CvTypes::getMISSION_MOVE_TO_UNIT())

	call	?getMISSION_MOVE_TO_UNIT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO_UNIT
	cmp	DWORD PTR [esi], eax
	jne	$LN60@ContinueMi

; 611  : 			{
; 612  : 				if((hUnit->AI_getUnitAIType() == UNITAI_DEFENSE) && hUnit->plot()->isCity() && (hUnit->plot()->getTeam() == hUnit->getTeam()))

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 6
	jne	$LN58@ContinueMi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	test	al, al
	je	SHORT $LN58@ContinueMi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	mov	edi, ecx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	mov	ecx, edi
	mov	ebx, eax
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	ebx, eax
	jne	SHORT $LN58@ContinueMi

; 613  : 				{
; 614  : 					if(hUnit->plot()->getBestDefender(hUnit->getOwner()) == hUnit.pointer())

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	mov	eax, DWORD PTR [ecx+40]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	eax
	lea	eax, DWORD PTR $T224349[esp+640]
	push	eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _hUnit$[esp+608]
	mov	ecx, DWORD PTR $T224349[esp+612]
	sete	bl
	test	ecx, ecx
	je	SHORT $LN377@ContinueMi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN377@ContinueMi:
	test	bl, bl
	jne	$ContinueMissionExit$218179
$LN58@ContinueMi:

; 615  : 					{
; 616  : 						bAction = false;
; 617  : 						bDone = true;
; 618  : 						break;
; 619  : 					}
; 620  : 				}
; 621  : 				UnitHandle pTargetUnit = GET_PLAYER((PlayerTypes)kMissionData.iData1).getUnit(kMissionData.iData2);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	push	eax
	lea	ecx, DWORD PTR _pTargetUnit$218253[esp+616]
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>

; 622  : 				if(pTargetUnit)

	mov	edi, DWORD PTR _pTargetUnit$218253[esp+612]
	mov	BYTE PTR __$EHRec$[esp+620], 1
	test	edi, edi
	je	$LN57@ContinueMi

; 623  : 				{
; 624  : 					if(hUnit->GetMissionAIType() != MISSIONAI_SHADOW && hUnit->GetMissionAIType() != MISSIONAI_GROUP)

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?GetMissionAIType@CvUnit@@QAE?AW4MissionAITypes@@XZ ; CvUnit::GetMissionAIType
	test	eax, eax
	je	$LN52@ContinueMi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?GetMissionAIType@CvUnit@@QAE?AW4MissionAITypes@@XZ ; CvUnit::GetMissionAIType
	cmp	eax, 1
	je	SHORT $LN52@ContinueMi

; 625  : 					{
; 626  : 						if(!hUnit->plot()->isOwned() || hUnit->plot()->getOwner() == hUnit->getOwner())

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	test	al, al
	je	SHORT $LN54@ContinueMi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	movsx	edx, BYTE PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+40]
	cmp	edx, ecx
	jne	SHORT $LN52@ContinueMi
$LN54@ContinueMi:

; 627  : 						{
; 628  : 							CvPlot* pMissionPlot = pTargetUnit->GetMissionAIPlot();

	mov	ecx, edi
	call	?GetMissionAIPlot@CvUnit@@QAEPAVCvPlot@@XZ ; CvUnit::GetMissionAIPlot
	mov	ebx, eax

; 629  : 							if(pMissionPlot != NULL && NO_TEAM != pMissionPlot->getTeam())

	test	ebx, ebx
	je	SHORT $LN52@ContinueMi
	mov	ecx, ebx
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	cmp	eax, -1
	je	SHORT $LN52@ContinueMi

; 630  : 							{
; 631  : 								if(pMissionPlot->isOwned() && pTargetUnit->isPotentialEnemy(pMissionPlot->getTeam(), pMissionPlot))

	mov	ecx, ebx
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	test	al, al
	je	SHORT $LN52@ContinueMi
	push	ebx
	mov	ecx, ebx
	call	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ	; CvPlot::getTeam
	push	eax
	mov	ecx, edi
	call	?isPotentialEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isPotentialEnemy
	test	al, al
	jne	$LN637@ContinueMi
$LN52@ContinueMi:

; 636  : 								}
; 637  : 							}
; 638  : 						}
; 639  : 					}
; 640  : 
; 641  : 					if(hUnit->UnitPathTo(pTargetUnit->getX(), pTargetUnit->getY(), kMissionData.iFlags) > 0)

	mov	edx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	push	0
	push	-1
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+628]
	call	?UnitPathTo@CvUnit@@QAEHHHHH_N@Z	; CvUnit::UnitPathTo
	test	eax, eax
	jle	SHORT $LN57@ContinueMi

; 642  : 					{
; 643  : 						bAction = true;

	mov	BYTE PTR _bAction$218176[esp+612], 1

; 644  : 					}
; 645  : 					else

	jmp	SHORT $LN49@ContinueMi
$LN57@ContinueMi:

; 646  : 					{
; 647  : 						bDone = true;
; 648  : 					}
; 649  : 				}
; 650  : 				else
; 651  : 				{
; 652  : 					bDone = true;

	mov	BYTE PTR _bDone$218175[esp+612], 1
$LN49@ContinueMi:

; 653  : 				}
; 654  : 			}

	mov	BYTE PTR __$EHRec$[esp+620], 0
	test	edi, edi
	je	$LN74@ContinueMi
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	jmp	$LN74@ContinueMi
$LN60@ContinueMi:

; 655  : 
; 656  : 			else if(kMissionData.eMissionType == CvTypes::getMISSION_RANGE_ATTACK())

	call	?getMISSION_RANGE_ATTACK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_RANGE_ATTACK
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN47@ContinueMi

; 657  : 			{
; 658  : 				if(CvUnitCombat::AttackRanged(*hUnit, kMissionData.iData1, kMissionData.iData2, (kMissionData.iFlags &  MISSION_MODIFIER_NO_DEFENSIVE_SUPPORT)?CvUnitCombat::ATTACK_OPTION_NO_DEFENSIVE_SUPPORT:CvUnitCombat::ATTACK_OPTION_NONE) != CvUnitCombat::ATTACK_ABORTED)

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+4]
	shr	eax, 8
	and	eax, 1
	push	eax
	mov	eax, DWORD PTR _hUnit$[esp+612]
	push	ecx
	push	edx
	push	eax
	call	?AttackRanged@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z ; CvUnitCombat::AttackRanged
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN640@ContinueMi

; 659  : 				{
; 660  : 					bDone = true;
; 661  : 				}
; 662  : 			}

	jmp	$LN669@ContinueMi
$LN47@ContinueMi:

; 663  : 
; 664  : 			else if(kMissionData.eMissionType == CvTypes::getMISSION_NUKE())

	call	?getMISSION_NUKE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_NUKE
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN44@ContinueMi

; 665  : 			{
; 666  : 				if(CvUnitCombat::AttackNuclear(*hUnit, kMissionData.iData1, kMissionData.iData2, (kMissionData.iFlags &  MISSION_MODIFIER_NO_DEFENSIVE_SUPPORT)?CvUnitCombat::ATTACK_OPTION_NO_DEFENSIVE_SUPPORT:CvUnitCombat::ATTACK_OPTION_NONE) != CvUnitCombat::ATTACK_ABORTED)

	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	shr	ecx, 8
	and	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+612]
	push	edx
	push	eax
	push	ecx
	call	?AttackNuclear@CvUnitCombat@@SA?AW4ATTACK_RESULT@1@AAVCvUnit@@HHW4ATTACK_OPTION@1@@Z ; CvUnitCombat::AttackNuclear
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN640@ContinueMi

; 667  : 				{
; 668  : 					bDone = true;
; 669  : 				}
; 670  : 			}

	jmp	$LN669@ContinueMi
$LN44@ContinueMi:

; 671  : 
; 672  : 			else if(kMissionData.eMissionType == CvTypes::getMISSION_BUILD())

	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	cmp	DWORD PTR [esi], eax
	jne	$LN640@ContinueMi

; 673  : 			{
; 674  : 				if(!hUnit->UnitBuild((BuildTypes)(kMissionData.iData1)))

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	push	edx
	call	?UnitBuild@CvUnit@@QAE_NW4BuildTypes@@@Z ; CvUnit::UnitBuild
	test	al, al
	jne	$LN640@ContinueMi

; 675  : 				{
; 676  : 					bDone = true;

	jmp	$LN669@ContinueMi
$LN79@ContinueMi:

; 530  : 			{
; 531  : 				if(hUnit->getDomainType() == DOMAIN_AIR)

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 532  : 				{
; 533  : 					hUnit->UnitPathTo(kMissionData.iData1, kMissionData.iData2, kMissionData.iFlags);

	push	0
	cmp	eax, 1
	jne	SHORT $LN78@ContinueMi
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+4]
	push	-1
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+624]
	push	edx
	call	?UnitPathTo@CvUnit@@QAEHHHHH_N@Z	; CvUnit::UnitPathTo

; 534  : 					bDone = true;
; 535  : 				}
; 536  : 				else

	jmp	$LN669@ContinueMi
$LN78@ContinueMi:

; 537  : 				{
; 538  : 					int iThisETA = hUnit->UnitPathTo(kMissionData.iData1, kMissionData.iData2, kMissionData.iFlags, iETA);

	mov	eax, DWORD PTR _iETA$[esp+612]
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+8]
	push	eax
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+620]
	push	edx
	push	eax
	call	?UnitPathTo@CvUnit@@QAEHHHHH_N@Z	; CvUnit::UnitPathTo

; 539  : 					if(iThisETA > 0)

	test	eax, eax
	jle	SHORT $LN76@ContinueMi

; 540  : 					{
; 541  : 						bAction = true;

	mov	BYTE PTR _bAction$218176[esp+612], 1

; 542  : 					}
; 543  : 					else

	jmp	SHORT $LN75@ContinueMi
$LN76@ContinueMi:

; 544  : 					{
; 545  : 						bDone = true;

	mov	BYTE PTR _bDone$218175[esp+612], 1
$LN75@ContinueMi:

; 546  : 					}
; 547  : 
; 548  : 					// Save off the initial ETA, we will feed it back into the UnitPathTo so it can check to see if our ETA grows while we are in the loop.
; 549  : 					// This can happen as terrain gets revealed.
; 550  : 					if(iSteps == 0)

	cmp	DWORD PTR _iSteps$[esp+608], 0
	jne	SHORT $LN74@ContinueMi

; 551  : 					{
; 552  : 						iETA = iThisETA;

	mov	DWORD PTR _iETA$[esp+608], eax
$LN74@ContinueMi:

; 677  : 				}
; 678  : 			}
; 679  : 		}
; 680  : 
; 681  : 		// check to see if mission is done
; 682  : 		if(!bDone && (hUnit->HeadMissionQueueNode() != NULL))

	cmp	BYTE PTR _bDone$218175[esp+612], 0
	jne	$LN36@ContinueMi
$LN640@ContinueMi:
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?HeadMissionQueueNode@CvUnit@@IAEPAUMissionData@@XZ ; CvUnit::HeadMissionQueueNode

; 683  : 		{
; 684  : 			const MissionData& kMissionData = *HeadMissionQueueNode(kMissionQueue);

	mov	ebp, DWORD PTR tv1646[esp+612]
	test	eax, eax
	je	$LN36@ContinueMi
	cmp	DWORD PTR [ebp+4], 0
	jbe	SHORT $LN438@ContinueMi
	mov	esi, DWORD PTR [ebp]
	jmp	SHORT $LN437@ContinueMi
$LN438@ContinueMi:
	xor	esi, esi
$LN437@ContinueMi:

; 685  : 
; 686  : 			if(kMissionData.eMissionType == CvTypes::getMISSION_MOVE_TO() ||
; 687  : 			        kMissionData.eMissionType == CvTypes::getMISSION_SWAP_UNITS() ||
; 688  : 			        kMissionData.eMissionType == CvTypes::getMISSION_EMBARK() ||
; 689  : 			        kMissionData.eMissionType == CvTypes::getMISSION_DISEMBARK())

	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	cmp	DWORD PTR [esi], eax
	je	$LN37@ContinueMi
	call	?getMISSION_SWAP_UNITS@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SWAP_UNITS
	cmp	DWORD PTR [esi], eax
	je	$LN37@ContinueMi
	call	?getMISSION_EMBARK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_EMBARK
	cmp	DWORD PTR [esi], eax
	je	$LN37@ContinueMi
	call	?getMISSION_DISEMBARK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_DISEMBARK
	cmp	DWORD PTR [esi], eax
	je	$LN37@ContinueMi

; 694  : #ifdef LOG_UNIT_MOVES
; 695  : 					std::ostringstream updateMsg;
; 696  : 					updateMsg << "ContinueMission() : player ";
; 697  : 					updateMsg << GET_PLAYER(hUnit->getOwner()).getName();
; 698  : 					updateMsg << hUnit->getName() << " id=" << hUnit->GetID() << " reached " << kMissionData.iData1 << ", " << kMissionData.iData2;
; 699  : 					gDLL->netMessageDebugLog(updateMsg.str());
; 700  : #endif
; 701  : 				}
; 702  : 			}
; 703  : 
; 704  : 			else if(kMissionData.eMissionType == CvTypes::getMISSION_ROUTE_TO())

	call	?getMISSION_ROUTE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ROUTE_TO
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN34@ContinueMi

; 705  : 			{
; 706  : 				if(hUnit->at(kMissionData.iData1, kMissionData.iData2))

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+612]
	push	edx
	call	?at@CvUnit@@QBE_NHH@Z			; CvUnit::at
	test	al, al
	je	$LN36@ContinueMi

; 707  : 				{
; 708  : 					if(hUnit->GetBestBuildRoute(hUnit->plot()) == NO_ROUTE)

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	push	0
	mov	esi, ecx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?GetBestBuildRoute@CvUnit@@QBE?AW4RouteTypes@@PAVCvPlot@@PAW4BuildTypes@@@Z ; CvUnit::GetBestBuildRoute
	cmp	eax, -1
	jne	$LN36@ContinueMi

; 709  : 					{
; 710  : 						bDone = true;
; 711  : 					}
; 712  : 				}
; 713  : 			}

	jmp	$LN669@ContinueMi
$LN34@ContinueMi:

; 714  : 
; 715  : 			else if(kMissionData.eMissionType == CvTypes::getMISSION_MOVE_TO_UNIT())

	call	?getMISSION_MOVE_TO_UNIT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO_UNIT
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN30@ContinueMi

; 716  : 			{
; 717  : 				UnitHandle pTargetUnit = GET_PLAYER((PlayerTypes)kMissionData.iData1).getUnit(kMissionData.iData2);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	push	eax
	lea	ecx, DWORD PTR _pTargetUnit$218286[esp+616]
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>

; 718  : 				if((!pTargetUnit) ||hUnit-> plot() == pTargetUnit->plot())

	mov	esi, DWORD PTR _pTargetUnit$218286[esp+612]
	mov	BYTE PTR __$EHRec$[esp+620], 2
	test	esi, esi
	je	SHORT $LN28@ContinueMi
	mov	edi, DWORD PTR _hUnit$[esp+608]
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, edi
	mov	ebx, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebx
	jne	SHORT $LN29@ContinueMi
$LN28@ContinueMi:

; 719  : 				{
; 720  : 					bDone = true;

	mov	BYTE PTR _bDone$218175[esp+612], 1
$LN29@ContinueMi:

; 721  : 				}
; 722  : 			}

	mov	BYTE PTR __$EHRec$[esp+620], 0
	test	esi, esi
	je	$LN36@ContinueMi
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 723  : 
; 724  : 			else if(kMissionData.eMissionType == CvTypes::getMISSION_SET_UP_FOR_RANGED_ATTACK() ||

	jmp	$LN36@ContinueMi
$LN30@ContinueMi:

; 725  : 					kMissionData.eMissionType == CvTypes::getMISSION_AIRLIFT() ||
; 726  : 					kMissionData.eMissionType == CvTypes::getMISSION_NUKE() ||
; 727  : 					kMissionData.eMissionType == CvTypes::getMISSION_PARADROP() ||
; 728  : 					kMissionData.eMissionType == CvTypes::getMISSION_AIR_SWEEP() ||
; 729  : 					kMissionData.eMissionType == CvTypes::getMISSION_REBASE() ||
; 730  : 			        kMissionData.eMissionType == CvTypes::getMISSION_RANGE_ATTACK() ||
; 731  : 			        kMissionData.eMissionType == CvTypes::getMISSION_PILLAGE() ||
; 732  : 			        kMissionData.eMissionType == CvTypes::getMISSION_FOUND() ||
; 733  : 			        kMissionData.eMissionType == CvTypes::getMISSION_JOIN() ||
; 734  : 			        kMissionData.eMissionType == CvTypes::getMISSION_CONSTRUCT() ||
; 735  : 			        kMissionData.eMissionType == CvTypes::getMISSION_DISCOVER() ||
; 736  : 			        kMissionData.eMissionType == CvTypes::getMISSION_HURRY() ||
; 737  : 					kMissionData.eMissionType == CvTypes::getMISSION_TRADE() ||
; 738  : 					kMissionData.eMissionType == CvTypes::getMISSION_BUY_CITY_STATE() ||
; 739  : 					kMissionData.eMissionType == CvTypes::getMISSION_REPAIR_FLEET() ||
; 740  : 			        kMissionData.eMissionType == CvTypes::getMISSION_SPACESHIP() ||
; 741  : 			        kMissionData.eMissionType == CvTypes::getMISSION_CULTURE_BOMB() ||
; 742  : 			        kMissionData.eMissionType == CvTypes::getMISSION_FOUND_RELIGION() ||
; 743  : 			        kMissionData.eMissionType == CvTypes::getMISSION_GOLDEN_AGE() ||
; 744  : 			        kMissionData.eMissionType == CvTypes::getMISSION_LEAD() ||
; 745  : 			        kMissionData.eMissionType == CvTypes::getMISSION_DIE_ANIMATION() ||
; 746  : 			        kMissionData.eMissionType == CvTypes::getMISSION_SPREAD_RELIGION() ||
; 747  : 			        kMissionData.eMissionType == CvTypes::getMISSION_ENHANCE_RELIGION() ||
; 748  : 			        kMissionData.eMissionType == CvTypes::getMISSION_REMOVE_HERESY() ||
; 749  : 					kMissionData.eMissionType == CvTypes::getMISSION_ESTABLISH_TRADE_ROUTE() ||
; 750  : 					kMissionData.eMissionType == CvTypes::getMISSION_PLUNDER_TRADE_ROUTE() ||
; 751  : 					kMissionData.eMissionType == CvTypes::getMISSION_GREAT_WORK() ||
; 752  : 					kMissionData.eMissionType == CvTypes::getMISSION_CHANGE_TRADE_UNIT_HOME_CITY() ||
; 753  : 					kMissionData.eMissionType == CvTypes::getMISSION_SELL_EXOTIC_GOODS() ||
; 754  : 					kMissionData.eMissionType == CvTypes::getMISSION_GIVE_POLICIES() ||
; 755  : 					kMissionData.eMissionType == CvTypes::getMISSION_ONE_SHOT_TOURISM() ||
; 756  : 					kMissionData.eMissionType == CvTypes::getMISSION_CHANGE_ADMIRAL_PORT())

	call	?getMISSION_SET_UP_FOR_RANGED_ATTACK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SET_UP_FOR_RANGED_ATTACK
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_AIRLIFT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_AIRLIFT
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_NUKE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_NUKE
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_PARADROP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_PARADROP
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_AIR_SWEEP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_AIR_SWEEP
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_REBASE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_REBASE
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_RANGE_ATTACK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_RANGE_ATTACK
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_PILLAGE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_PILLAGE
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FOUND
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_JOIN@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_JOIN
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_CONSTRUCT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CONSTRUCT
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_DISCOVER@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_DISCOVER
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_HURRY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_HURRY
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_TRADE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_TRADE
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_BUY_CITY_STATE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUY_CITY_STATE
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_REPAIR_FLEET@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_REPAIR_FLEET
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_SPACESHIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPACESHIP
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_CULTURE_BOMB@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CULTURE_BOMB
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_FOUND_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FOUND_RELIGION
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_GOLDEN_AGE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GOLDEN_AGE
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_LEAD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_LEAD
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_DIE_ANIMATION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_DIE_ANIMATION
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_SPREAD_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPREAD_RELIGION
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_ENHANCE_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ENHANCE_RELIGION
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_REMOVE_HERESY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_REMOVE_HERESY
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_ESTABLISH_TRADE_ROUTE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ESTABLISH_TRADE_ROUTE
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_PLUNDER_TRADE_ROUTE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_PLUNDER_TRADE_ROUTE
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GREAT_WORK
	cmp	DWORD PTR [esi], eax
	je	$LN669@ContinueMi
	call	?getMISSION_CHANGE_TRADE_UNIT_HOME_CITY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CHANGE_TRADE_UNIT_HOME_CITY
	cmp	DWORD PTR [esi], eax
	je	SHORT $LN669@ContinueMi
	call	?getMISSION_SELL_EXOTIC_GOODS@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SELL_EXOTIC_GOODS
	cmp	DWORD PTR [esi], eax
	je	SHORT $LN669@ContinueMi
	call	?getMISSION_GIVE_POLICIES@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GIVE_POLICIES
	cmp	DWORD PTR [esi], eax
	je	SHORT $LN669@ContinueMi
	call	?getMISSION_ONE_SHOT_TOURISM@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ONE_SHOT_TOURISM
	cmp	DWORD PTR [esi], eax
	je	SHORT $LN669@ContinueMi
	call	?getMISSION_CHANGE_ADMIRAL_PORT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CHANGE_ADMIRAL_PORT
	cmp	DWORD PTR [esi], eax
	je	SHORT $LN669@ContinueMi

; 757  : 			{
; 758  : 				bDone = true;
; 759  : 			}
; 760  : 
; 761  : 			else if(kMissionData.eMissionType == CvTypes::getMISSION_WAIT_FOR())

	call	?getMISSION_WAIT_FOR@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_WAIT_FOR
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN36@ContinueMi

; 762  : 			{
; 763  : 				CvUnit* pkWaitingFor = GET_PLAYER((PlayerTypes)kMissionData.iData1).getUnit(kMissionData.iData2);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 764  : 				if(!pkWaitingFor || !pkWaitingFor->IsBusy())

	test	eax, eax
	je	SHORT $LN669@ContinueMi
	mov	ecx, eax
	call	?IsBusy@CvUnit@@QBE_NXZ			; CvUnit::IsBusy
	test	al, al
	je	SHORT $LN669@ContinueMi

; 765  : 				{
; 766  : 					bDone = true;
; 767  : 				}
; 768  : 				else
; 769  : 				{
; 770  : 					// Set the mission timer to 1 so we will get another UpdateMission call
; 771  : 					hUnit->ChangeMissionTimer(1);

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	push	1
	call	?ChangeMissionTimer@CvUnit@@QAEXH@Z	; CvUnit::ChangeMissionTimer
	jmp	SHORT $LN36@ContinueMi
$LN37@ContinueMi:

; 690  : 			{
; 691  : 				if(hUnit->at(kMissionData.iData1, kMissionData.iData2))

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+616]
	call	?at@CvUnit@@QBE_NHH@Z			; CvUnit::at
	test	al, al
	je	SHORT $LN36@ContinueMi
$LN669@ContinueMi:

; 692  : 				{
; 693  : 					bDone = true;

	mov	BYTE PTR _bDone$218175[esp+612], 1
$LN36@ContinueMi:

; 772  : 				}
; 773  : 			}
; 774  : 		}
; 775  : 
; 776  : 		if(HeadMissionQueueNode(kMissionQueue) != NULL)

	cmp	DWORD PTR [ebp+4], 0
	jbe	$ContinueMissionExit$218179
	cmp	DWORD PTR [ebp], 0
	je	$ContinueMissionExit$218179

; 777  : 		{
; 778  : 			// if there is an action, if it's done or there are not moves left, and a player is watching, watch the movement
; 779  : 			if(bAction && (bDone || !hUnit->canMove()) && hUnit->plot()->isVisibleToWatchingHuman())

	cmp	BYTE PTR _bAction$218176[esp+612], 0
	je	$LN517@ContinueMi
	cmp	BYTE PTR _bDone$218175[esp+612], 0
	jne	SHORT $LN17@ContinueMi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	jne	$LN15@ContinueMi
$LN17@ContinueMi:
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ ; CvPlot::isVisibleToWatchingHuman
	test	al, al
	je	$LN517@ContinueMi

; 780  : 			{
; 781  : 				UpdateMissionTimer(hUnit, iSteps);

	mov	edx, DWORD PTR _iSteps$[esp+608]
	push	edx
	sub	esp, 8
	lea	eax, DWORD PTR _hUnit$[esp+620]
	mov	ecx, esp
	mov	DWORD PTR $T224350[esp+624], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?UpdateMissionTimer@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::UpdateMissionTimer

; 782  : 
; 783  : 				if(hUnit->ShowMoves() && GC.getGame().getActivePlayer() != NO_PLAYER && hUnit->getOwner() != GC.getGame().getActivePlayer() && hUnit->plot()->isActiveVisible(false))

	mov	ecx, DWORD PTR _hUnit$[esp+620]
	add	esp, 12					; 0000000cH
	call	?ShowMoves@CvUnit@@QBE_NXZ		; CvUnit::ShowMoves
	test	al, al
	je	$LN517@ContinueMi
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, -1
	je	$LN517@ContinueMi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	mov	esi, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	je	$LN517@ContinueMi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	push	0
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?isActiveVisible@CvPlot@@QBE_N_N@Z	; CvPlot::isActiveVisible
	test	al, al
	je	SHORT $LN517@ContinueMi

; 784  : 				{
; 785  : 					auto_ptr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(hUnit->plot());

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	lea	edx, DWORD PTR $T224351[esp+616]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR _pDllPlot$218352[esp+612], esi
	mov	eax, DWORD PTR $T224351[esp+612]
	mov	BYTE PTR __$EHRec$[esp+620], 3
	test	eax, eax
	je	SHORT $LN508@ContinueMi
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN508@ContinueMi:

; 786  : 					GC.GetEngineUserInterface()->lookAt(pDllPlot.get(), CAMERALOOKAT_NORMAL);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+272]
	push	0
	push	esi
	call	edx

; 787  : 				}

	mov	BYTE PTR __$EHRec$[esp+620], 0
	test	esi, esi
	je	SHORT $LN517@ContinueMi
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	esi
	call	ecx
$LN517@ContinueMi:

; 788  : 			}
; 789  : 
; 790  : 			if(bDone)

	cmp	BYTE PTR _bDone$218175[esp+612], 0
	jne	SHORT $LN643@ContinueMi
$LN15@ContinueMi:

; 839  : 			{
; 840  : 				// if we can still act, process the mission again
; 841  : 				if(hUnit->canMove() && !hUnit->IsDoingPartialMove())

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN3@ContinueMi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?IsDoingPartialMove@CvUnit@@QBE_NXZ	; CvUnit::IsDoingPartialMove
	test	al, al
	jne	$LN3@ContinueMi

; 842  : 				{
; 843  : 					iSteps++;

	inc	DWORD PTR _iSteps$[esp+608]

; 844  : 					bContinueMissionRestart = true;	// keep looping

	jmp	$LL109@ContinueMi
$LN643@ContinueMi:

; 791  : 			{
; 792  : 				if(hUnit->IsWork())

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?IsWork@CvUnit@@QBE_NXZ			; CvUnit::IsWork
	test	al, al
	je	SHORT $LN532@ContinueMi

; 793  : 				{
; 794  : 					auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(hUnit.pointer()));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T224354[esp+612], eax
	mov	BYTE PTR __$EHRec$[esp+620], 4
	test	eax, eax
	je	SHORT $LN112@ContinueMi
	mov	edx, DWORD PTR _hUnit$[esp+608]
	push	edx
	mov	ecx, eax
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	esi, eax
	jmp	SHORT $LN113@ContinueMi
$LN112@ContinueMi:
	xor	esi, esi
$LN113@ContinueMi:
	mov	DWORD PTR _pDllUnit$218379[esp+612], esi

; 795  : 					gDLL->GameplayUnitWork(pDllUnit.get(), -1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+612]
	push	-1
	push	esi
	mov	BYTE PTR __$EHRec$[esp+628], 5
	call	edx

; 796  : 				}

	mov	BYTE PTR __$EHRec$[esp+620], 0
	test	esi, esi
	je	SHORT $LN532@ContinueMi
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	esi
	call	ecx
$LN532@ContinueMi:

; 797  : 
; 798  : 				if(hUnit->GetMissionTimer() == 0 && !hUnit->isInCombat())	// Was hUnit->IsBusy(), but its ok to clear the mission if the unit is just completing a move visualization

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?GetMissionTimer@CvUnit@@QBEHXZ		; CvUnit::GetMissionTimer
	test	eax, eax
	jne	$ContinueMissionExit$218179
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?isInCombat@CvUnit@@QBE_NXZ		; CvUnit::isInCombat
	test	al, al
	jne	$ContinueMissionExit$218179

; 799  : 				{
; 800  : 					if(hUnit->getOwner() == GC.getGame().getActivePlayer() && hUnit->IsSelected())

	mov	edx, DWORD PTR _hUnit$[esp+608]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [edx+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	$LN11@ContinueMi
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?IsSelected@CvUnit@@QBE_NXZ		; CvUnit::IsSelected
	test	al, al
	je	$LN11@ContinueMi

; 801  : 					{
; 802  : 						const MissionData& kMissionData = *HeadMissionQueueNode(kMissionQueue);

	cmp	DWORD PTR [ebp+4], 0
	jbe	SHORT $LN552@ContinueMi
	mov	esi, DWORD PTR [ebp]
	jmp	SHORT $LN551@ContinueMi
$LN552@ContinueMi:
	xor	esi, esi
$LN551@ContinueMi:

; 803  : 
; 804  : 						if((kMissionData.eMissionType == CvTypes::getMISSION_MOVE_TO()) ||
; 805  : 						        (kMissionData.eMissionType == CvTypes::getMISSION_ROUTE_TO()) ||
; 806  : 						        (kMissionData.eMissionType == CvTypes::getMISSION_MOVE_TO_UNIT()))

	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	cmp	DWORD PTR [esi], eax
	je	SHORT $LN10@ContinueMi
	call	?getMISSION_ROUTE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ROUTE_TO
	cmp	DWORD PTR [esi], eax
	je	SHORT $LN10@ContinueMi
	call	?getMISSION_MOVE_TO_UNIT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO_UNIT
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN11@ContinueMi
$LN10@ContinueMi:

; 807  : 						{
; 808  : 							// How long does the camera wait before jumping to the next item?
; 809  : 							int iCameraTime;
; 810  : 
; 811  : 							if(GET_PLAYER(hUnit->getOwner()).isOption(PLAYEROPTION_QUICK_MOVES))

	mov	eax, DWORD PTR _hUnit$[esp+608]
	mov	eax, DWORD PTR [eax+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	3
	mov	ecx, eax
	call	?isOption@CvPlayer@@QBE_NW4PlayerOptionTypes@@@Z ; CvPlayer::isOption
	test	al, al
	je	SHORT $LN9@ContinueMi

; 812  : 							{
; 813  : 								iCameraTime = 1;

	mov	eax, 1
	jmp	SHORT $LN7@ContinueMi
$LN9@ContinueMi:

; 814  : 							}
; 815  : 							// If our move revealed a Plot, camera jumps slower
; 816  : 							else if(GC.GetEngineUserInterface()->IsSelectedUnitRevealingNewPlots())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+228]
	call	eax
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	and	eax, 5
	add	eax, 5
$LN7@ContinueMi:

; 817  : 							{
; 818  : 								iCameraTime = 10;
; 819  : 							}
; 820  : 							// No plots revealed by this move, go quicker
; 821  : 							else
; 822  : 							{
; 823  : 								iCameraTime = 5;
; 824  : 							}
; 825  : 
; 826  : 							GC.GetEngineUserInterface()->changeCycleSelectionCounter(iCameraTime);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+224]
	call	eax
$LN11@ContinueMi:

; 827  : 						}
; 828  : 					}
; 829  : 
; 830  : 					if(hUnit->m_unitMoveLocs.size() > 0)

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	cmp	DWORD PTR [ecx+2400], 0
	jbe	SHORT $LN5@ContinueMi

; 831  : 					{
; 832  : 						hUnit->PublishQueuedVisualizationMoves();

	call	?PublishQueuedVisualizationMoves@CvUnit@@IAEXXZ ; CvUnit::PublishQueuedVisualizationMoves
	mov	ecx, DWORD PTR _hUnit$[esp+608]
$LN5@ContinueMi:

; 833  : 					}
; 834  : 
; 835  : 					DeleteMissionQueueNode(hUnit, HeadMissionQueueNode(hUnit->m_missionQueue));

	cmp	DWORD PTR [ecx+2604], 0
	jbe	SHORT $LN582@ContinueMi
	mov	ecx, DWORD PTR [ecx+2600]
	jmp	SHORT $LN581@ContinueMi
$LN582@ContinueMi:
	xor	ecx, ecx
$LN581@ContinueMi:
	push	ecx
	sub	esp, 8
	lea	edx, DWORD PTR _hUnit$[esp+620]
	mov	ecx, esp
	mov	DWORD PTR $T224357[esp+624], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?DeleteMissionQueueNode@CvUnitMission@@CAPAUMissionData@@V?$FObjectHandle@VCvUnit@@@@PAU2@@Z ; CvUnitMission::DeleteMissionQueueNode
	add	esp, 12					; 0000000cH

; 836  : 				}
; 837  : 			}
; 838  : 			else

	jmp	$ContinueMissionExit$218179
$LN3@ContinueMi:

; 845  : 				}
; 846  : 				else if(!hUnit->IsBusy() && hUnit->getOwner() == GC.getGame().getActivePlayer() && hUnit->IsSelected())

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?IsBusy@CvUnit@@QBE_NXZ			; CvUnit::IsBusy
	test	al, al
	jne	$ContinueMissionExit$218179
	mov	eax, DWORD PTR _hUnit$[esp+608]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [eax+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	$ContinueMissionExit$218179
	mov	ecx, DWORD PTR _hUnit$[esp+608]
	call	?IsSelected@CvUnit@@QBE_NXZ		; CvUnit::IsSelected
	test	al, al
	je	$ContinueMissionExit$218179

; 847  : 				{
; 848  : 					GC.GetEngineUserInterface()->changeCycleSelectionCounter(1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+224]
	push	1
	call	eax
	jmp	$ContinueMissionExit$218179
$LN630@ContinueMi:

; 423  : 		{
; 424  : 			// just in case...
; 425  : 			hUnit->SetActivityType(ACTIVITY_AWAKE);

	push	0
	call	?SetActivityType@CvUnit@@QAEXW4ActivityTypes@@@Z ; CvUnit::SetActivityType

; 426  : 			goto ContinueMissionExit;

	jmp	$ContinueMissionExit$218179
$LN633@ContinueMi:

; 486  : 										{
; 487  : 											GC.GetEngineUserInterface()->SetDontShowPopups(false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+556]
	xor	edi, edi
	push	edi
	call	edx

; 488  : 											CvPopupInfo kPopup(BUTTONPOPUP_ADVISOR_MODAL);

	or	eax, -1

; 489  : 											kPopup.iData1 = ADVISOR_MILITARY;
; 490  : 											kPopup.iData2 = pPlot->GetPlotIndex();

	mov	ecx, esi
	mov	DWORD PTR _kPopup$218214[esp+616], eax
	mov	DWORD PTR _kPopup$218214[esp+620], eax
	mov	DWORD PTR _kPopup$218214[esp+624], edi
	mov	BYTE PTR _kPopup$218214[esp+628], 0
	mov	BYTE PTR _kPopup$218214[esp+629], 0
	mov	DWORD PTR _kPopup$218214[esp+632], 72	; 00000048H
	mov	BYTE PTR _kPopup$218214[esp+636], 0
	mov	DWORD PTR _kPopup$218214[esp+612], edi
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex

; 491  : 											kPopup.iData3 = hUnit->plot()->GetPlotIndex();

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	mov	DWORD PTR _kPopup$218214[esp+616], eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	DWORD PTR _kPopup$218214[esp+620], eax

; 492  : 											strcpy_s(kPopup.szText, "TXT_KEY_ADVISOR_BAD_ATTACK_BODY");

	lea	eax, DWORD PTR _kPopup$218214[esp+636]
	push	OFFSET $SG218215
	push	eax
	call	??$strcpy_s@$0CAA@@@YAHAAY0CAA@DPBD@Z	; strcpy_s<512>

; 493  : 											kPopup.bOption1 = false;
; 494  : 											GC.GetEngineUserInterface()->AddPopup(kPopup);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	BYTE PTR _kPopup$218214[esp+636], 0
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+180]
	add	esp, 8
	lea	eax, DWORD PTR _kPopup$218214[esp+612]
	push	eax
	call	edx

; 495  : 											goto ContinueMissionExit;

	jmp	SHORT $ContinueMissionExit$218179
$LN637@ContinueMi:

; 632  : 								{
; 633  : 									bAction = false;
; 634  : 									bDone = true;
; 635  : 									break;

	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+620], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$ContinueMissionExit$218179:

; 849  : 				}
; 850  : 			}
; 851  : 		}
; 852  : 	}
; 853  : ContinueMissionExit: // goto destination to clean up the flag value
; 854  : 	hUnit->m_iFlags =hUnit-> m_iFlags & ~CvUnit::UNITFLAG_EVALUATING_MISSION;

	mov	edi, DWORD PTR _hUnit$[esp+608]
	mov	esi, DWORD PTR [edi+1364]
	and	esi, -2					; fffffffeH
	add	edi, 1360				; 00000550H
	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN616@ContinueMi
	mov	eax, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR $T225499[esp+612]
	push	ecx
	lea	edx, DWORD PTR $T225500[esp+616]
	push	edx
	lea	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T225499[esp+620], edi
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	DWORD PTR [edi+4], esi
$LN616@ContinueMi:

; 855  : 	GC.getGame().SetCombatWarned(false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	0
	call	?SetCombatWarned@CvGame@@QAEX_N@Z	; CvGame::SetCombatWarned

; 856  : }

	mov	ecx, DWORD PTR _hUnit$[esp+608]
	mov	DWORD PTR __$EHRec$[esp+620], -1
	test	ecx, ecx
	je	SHORT $LN626@ContinueMi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN626@ContinueMi:
	mov	ecx, DWORD PTR __$EHRec$[esp+612]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 596				; 00000254H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z$5:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z$7:
	lea	ecx, DWORD PTR _pTargetUnit$218253[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z$8:
	lea	ecx, DWORD PTR _pTargetUnit$218286[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z$11:
	lea	ecx, DWORD PTR _pDllPlot$218352[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z$12:
	mov	eax, DWORD PTR $T224354[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z$13:
	lea	ecx, DWORD PTR _pDllUnit$218379[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__ehhandler$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z:
	mov	eax, OFFSET __ehfuncinfo$?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z ENDP ; CvUnitMission::ContinueMission
PUBLIC	?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z ; CvUnitMission::StartMission
EXTRN	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z:PROC	; CvUnit::SetFortifiedThisTurn
EXTRN	?changeAdmiralPort@CvUnit@@QAE_NHH@Z:PROC	; CvUnit::changeAdmiralPort
EXTRN	?blastTourism@CvUnit@@QAE_NXZ:PROC		; CvUnit::blastTourism
EXTRN	?givePolicies@CvUnit@@QAE_NXZ:PROC		; CvUnit::givePolicies
EXTRN	?lead@CvUnit@@QAE_NH@Z:PROC			; CvUnit::lead
EXTRN	?ChangeGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::ChangeGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?getBuildCost@CvPlayer@@QBEHPBVCvPlot@@W4BuildTypes@@@Z:PROC ; CvPlayer::getBuildCost
EXTRN	?sellExoticGoods@CvUnit@@QAE_NXZ:PROC		; CvUnit::sellExoticGoods
EXTRN	?changeTradeUnitHomeCity@CvUnit@@QAE_NHH@Z:PROC	; CvUnit::changeTradeUnitHomeCity
EXTRN	?createGreatWork@CvUnit@@QAE_NXZ:PROC		; CvUnit::createGreatWork
EXTRN	?plunderTradeRoute@CvUnit@@QAE_NXZ:PROC		; CvUnit::plunderTradeRoute
EXTRN	?makeTradeRoute@CvUnit@@QAE_NHHW4TradeConnectionType@@@Z:PROC ; CvUnit::makeTradeRoute
EXTRN	?goldenAge@CvUnit@@QAE_NXZ:PROC			; CvUnit::goldenAge
EXTRN	?DoRemoveHeresy@CvUnit@@QAE_NXZ:PROC		; CvUnit::DoRemoveHeresy
EXTRN	?DoEnhanceReligion@CvUnit@@QAE_NXZ:PROC		; CvUnit::DoEnhanceReligion
EXTRN	?DoSpreadReligion@CvUnit@@QAE_NXZ:PROC		; CvUnit::DoSpreadReligion
EXTRN	?DoFoundReligion@CvUnit@@QAE_NXZ:PROC		; CvUnit::DoFoundReligion
EXTRN	?DoCultureBomb@CvUnit@@QAE_NXZ:PROC		; CvUnit::DoCultureBomb
EXTRN	?DoBuildSpaceship@CvUnit@@QAE_NXZ:PROC		; CvUnit::DoBuildSpaceship
EXTRN	?repairFleet@CvUnit@@QAE_NXZ:PROC		; CvUnit::repairFleet
EXTRN	?buyCityState@CvUnit@@QAE_NXZ:PROC		; CvUnit::buyCityState
EXTRN	?trade@CvUnit@@QAE_NXZ:PROC			; CvUnit::trade
EXTRN	?hurry@CvUnit@@QAE_NXZ:PROC			; CvUnit::hurry
EXTRN	?discover@CvUnit@@QAE_NXZ:PROC			; CvUnit::discover
EXTRN	?construct@CvUnit@@QAE_NW4BuildingTypes@@@Z:PROC ; CvUnit::construct
EXTRN	?join@CvUnit@@QAE_NW4SpecialistTypes@@@Z:PROC	; CvUnit::join
EXTRN	?found@CvUnit@@QAE_NXZ:PROC			; CvUnit::found
EXTRN	?pillage@CvUnit@@QAE_NXZ:PROC			; CvUnit::pillage
EXTRN	?rebase@CvUnit@@QAE_NHH@Z:PROC			; CvUnit::rebase
EXTRN	?airSweep@CvUnit@@QAE_NHH@Z:PROC		; CvUnit::airSweep
EXTRN	?isActiveVisible@CvPlot@@QBE_NXZ:PROC		; CvPlot::isActiveVisible
EXTRN	?paradrop@CvUnit@@QAE_NHH@Z:PROC		; CvUnit::paradrop
EXTRN	?airlift@CvUnit@@QAE_NHH@Z:PROC			; CvUnit::airlift
EXTRN	?setSetUpForRangedAttack@CvUnit@@QAEX_N@Z:PROC	; CvUnit::setSetUpForRangedAttack
EXTRN	?CanStartMission@CvUnit@@QAE_NHHHPAVCvPlot@@_N@Z:PROC ; CvUnit::CanStartMission
EXTRN	?isTurnActive@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isTurnActive
EXTRN	?isSimultaneousTurns@CvPlayer@@QBE_NXZ:PROC	; CvPlayer::isSimultaneousTurns
;	COMDAT ?stackDepth@?1??StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z@4HA
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
_BSS	SEGMENT
?stackDepth@?1??StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z@4HA DD 01H DUP (?) ; `CvUnitMission::StartMission'::`2'::stackDepth
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$12
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_bAction$ = -22						; size = 1
_bDelete$ = -21						; size = 1
tv1387 = -20						; size = 4
tv1304 = -20						; size = 4
$T225590 = -20						; size = 4
$T225587 = -20						; size = 4
_pDllUnit$218781 = -20					; size = 4
$T225583 = -20						; size = 4
_pDllUnit$218773 = -20					; size = 4
$T225579 = -20						; size = 4
_pDllUnit$218689 = -20					; size = 4
$T225577 = -20						; size = 4
$T225574 = -20						; size = 4
_pDllUnit$218674 = -20					; size = 4
$T225572 = -20						; size = 4
$T225571 = -20						; size = 4
$T225570 = -20						; size = 4
$T225592 = -16						; size = 4
$T225591 = -16						; size = 4
_kUnitOwner$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvUnitMission::StartMission, COMDAT

; 1258 : {

	push	-1
	push	__ehhandler$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1259 : 	bool bDelete;
; 1260 : 	bool bAction;
; 1261 : 	bool bNotify;
; 1262 : 
; 1263 : 	static int stackDepth = 0;
; 1264 : 	++stackDepth; // JAR debugging
; 1265 : 
; 1266 : 	CvAssert(stackDepth < 100);
; 1267 : 
; 1268 : 	CvAssert(!hUnit->IsBusy());
; 1269 : 	CvAssert(hUnit->getOwner() != NO_PLAYER);
; 1270 : 	CvAssert(hUnit->HeadMissionQueueNode() != NULL);
; 1271 : 
; 1272 : 	CvPlayerAI& kUnitOwner = GET_PLAYER(hUnit->getOwner());

	mov	eax, DWORD PTR _hUnit$[esp+36]
	mov	eax, DWORD PTR [eax+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ebp, 1
	add	DWORD PTR ?stackDepth@?1??StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z@4HA, ebp
	mov	ebx, eax

; 1273 : 
; 1274 : 
; 1275 : 	if(!kUnitOwner.isSimultaneousTurns())

	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+48], 0
	mov	DWORD PTR _kUnitOwner$[esp+40], ebx
	call	?isSimultaneousTurns@CvPlayer@@QBE_NXZ	; CvPlayer::isSimultaneousTurns
	test	al, al
	jne	SHORT $LN152@StartMissi

; 1276 : 	{
; 1277 : 		if(!kUnitOwner.isTurnActive())

	mov	ecx, ebx
	call	?isTurnActive@CvPlayer@@QBE_NXZ		; CvPlayer::isTurnActive
	test	al, al
	jne	SHORT $LN152@StartMissi

; 1278 : 		{
; 1279 : 			if(hUnit->getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	mov	esi, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	SHORT $LN150@StartMissi

; 1280 : 			{
; 1281 : 				if(hUnit->IsSelected())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?IsSelected@CvUnit@@QBE_NXZ		; CvUnit::IsSelected
	test	al, al
	je	SHORT $LN150@StartMissi

; 1282 : 				{
; 1283 : 					GC.GetEngineUserInterface()->changeCycleSelectionCounter(1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+224]
	push	ebp
	call	eax
$LN150@StartMissi:

; 1284 : 				}
; 1285 : 			}
; 1286 : 
; 1287 : 			--stackDepth; // JAR debugging

	sub	DWORD PTR ?stackDepth@?1??StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z@4HA, ebp

; 1288 : 			return;

	jmp	$LN538@StartMissi
$LN152@StartMissi:

; 1289 : 		}
; 1290 : 	}
; 1291 : 
; 1292 : 	if(hUnit->canMove())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove

; 1293 : 	{
; 1294 : 		hUnit->SetActivityType(ACTIVITY_MISSION);

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	test	al, al
	je	SHORT $LN149@StartMissi
	push	6

; 1295 : 	}
; 1296 : 	else

	jmp	SHORT $LN539@StartMissi
$LN149@StartMissi:

; 1297 : 	{
; 1298 : 		hUnit->SetActivityType(ACTIVITY_HOLD);

	push	ebp
$LN539@StartMissi:
	call	?SetActivityType@CvUnit@@QAEXW4ActivityTypes@@@Z ; CvUnit::SetActivityType

; 1299 : 	}
; 1300 : 
; 1301 : 	bDelete = false;
; 1302 : 	bAction = false;
; 1303 : 	bNotify = false;
; 1304 : 
; 1305 : 	hUnit->ClearPathCache();

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	mov	BYTE PTR _bDelete$[esp+40], 0
	mov	BYTE PTR _bAction$[esp+40], 0
	call	?ClearPathCache@CvUnit@@IAEXXZ		; CvUnit::ClearPathCache

; 1306 : 
; 1307 : 	const MissionData* pkQueueData = GetHeadMissionData(hUnit);

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _hUnit$[esp+48]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T225570[esp+48], esp
	test	eax, eax
	je	SHORT $LN216@StartMissi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN216@StartMissi:
	call	?GetHeadMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvUnitMission::GetHeadMissionData

; 1308 : 	if(!hUnit->CanStartMission(pkQueueData->eMissionType, pkQueueData->iData1, pkQueueData->iData2, hUnit->plot()))

	mov	ecx, DWORD PTR _hUnit$[esp+44]
	add	esp, 8
	push	0
	mov	esi, eax
	mov	edi, ecx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR [esi+8]
	push	eax
	push	ecx
	push	edx
	mov	ecx, edi
	call	?CanStartMission@CvUnit@@QAE_NHHHPAVCvPlot@@_N@Z ; CvUnit::CanStartMission
	or	edi, -1
	test	al, al
	jne	SHORT $LN147@StartMissi

; 1309 : 	{
; 1310 : 		bDelete = true;

	mov	BYTE PTR _bDelete$[esp+40], 1

; 1311 : 	}
; 1312 : 	else

	jmp	$LN11@StartMissi
$LN147@StartMissi:

; 1313 : 	{
; 1314 : 		CvAssertMsg(kUnitOwner.isTurnActive() || kUnitOwner.isHuman(), "It's expected that either the turn is active for this player or the player is human");
; 1315 : 
; 1316 : 		if(pkQueueData->eMissionType == CvTypes::getMISSION_SKIP())

	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN145@StartMissi

; 1317 : 		{
; 1318 : 			hUnit->SetActivityType(ACTIVITY_HOLD);

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	push	ebp
	call	?SetActivityType@CvUnit@@QAEXW4ActivityTypes@@@Z ; CvUnit::SetActivityType

; 1319 : 			bDelete = true;

	mov	BYTE PTR _bDelete$[esp+40], 1
	jmp	$LN134@StartMissi
$LN145@StartMissi:

; 1320 : 		}
; 1321 : 
; 1322 : 		else if(pkQueueData->eMissionType == CvTypes::getMISSION_SLEEP())

	call	?getMISSION_SLEEP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SLEEP
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN143@StartMissi

; 1323 : 		{
; 1324 : 			hUnit->SetActivityType(ACTIVITY_SLEEP);

	push	2

; 1325 : 			bNotify = true;
; 1326 : 			bDelete = true;

	jmp	SHORT $LN540@StartMissi
$LN143@StartMissi:

; 1327 : 		}
; 1328 : 
; 1329 : 		else if(pkQueueData->eMissionType == CvTypes::getMISSION_FORTIFY())

	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN141@StartMissi

; 1330 : 		{
; 1331 : 			hUnit->SetActivityType(ACTIVITY_SLEEP);

	push	2

; 1332 : 			bNotify = true;
; 1333 : 			bDelete = true;

	jmp	SHORT $LN540@StartMissi
$LN141@StartMissi:

; 1334 : 		}
; 1335 : 
; 1336 : 		else if(pkQueueData->eMissionType == CvTypes::getMISSION_AIRPATROL())

	call	?getMISSION_AIRPATROL@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_AIRPATROL
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN139@StartMissi

; 1337 : 		{
; 1338 : 			hUnit->SetActivityType(ACTIVITY_INTERCEPT);

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	push	5
	call	?SetActivityType@CvUnit@@QAEXW4ActivityTypes@@@Z ; CvUnit::SetActivityType

; 1339 : 			bDelete = true;

	mov	BYTE PTR _bDelete$[esp+40], 1
	jmp	SHORT $LN134@StartMissi
$LN139@StartMissi:

; 1340 : 		}
; 1341 : 
; 1342 : 		else if(pkQueueData->eMissionType == CvTypes::getMISSION_HEAL())

	call	?getMISSION_HEAL@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_HEAL
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN137@StartMissi

; 1343 : 		{
; 1344 : 			hUnit->SetActivityType(ACTIVITY_HEAL);

	push	3

; 1345 : 			bNotify = true;
; 1346 : 			bDelete = true;

	jmp	SHORT $LN540@StartMissi
$LN137@StartMissi:

; 1347 : 		}
; 1348 : 
; 1349 : 		else if(pkQueueData->eMissionType == CvTypes::getMISSION_ALERT())

	call	?getMISSION_ALERT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ALERT
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN134@StartMissi

; 1350 : 		{
; 1351 : 			hUnit->SetActivityType(ACTIVITY_SENTRY);

	push	4
$LN540@StartMissi:
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	call	?SetActivityType@CvUnit@@QAEXW4ActivityTypes@@@Z ; CvUnit::SetActivityType

; 1352 : 			bNotify = true;
; 1353 : 			bDelete = true;
; 1354 : 		}
; 1355 : 
; 1356 : 
; 1357 : 		if(bNotify)
; 1358 : 		{
; 1359 : 			// The entity should not futz with the missions, but...
; 1360 : 			CvAssert(GetHeadMissionData(hUnit) == pkQueueData);
; 1361 : 			pkQueueData = GetHeadMissionData(hUnit);

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _hUnit$[esp+48]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	BYTE PTR _bDelete$[esp+48], 1
	mov	DWORD PTR $T225571[esp+48], esp
	test	eax, eax
	je	SHORT $LN237@StartMissi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN237@StartMissi:
	call	?GetHeadMissionData@CvUnitMission@@SAPBUMissionData@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvUnitMission::GetHeadMissionData
	add	esp, 8
	mov	esi, eax
$LN134@StartMissi:

; 1362 : 		}
; 1363 : 
; 1364 : 		if(hUnit->canMove())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN11@StartMissi

; 1365 : 		{
; 1366 : 			if(pkQueueData->eMissionType == CvTypes::getMISSION_FORTIFY())

	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	cmp	DWORD PTR [esi], eax

; 1367 : 			{
; 1368 : 				hUnit->SetFortifiedThisTurn(true);
; 1369 : 			}
; 1370 : 
; 1371 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_HEAL() ||

	je	$LN129@StartMissi

; 1372 : 			        pkQueueData->eMissionType == CvTypes::getMISSION_ALERT())

	call	?getMISSION_HEAL@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_HEAL
	cmp	DWORD PTR [esi], eax
	je	$LN129@StartMissi
	call	?getMISSION_ALERT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ALERT
	cmp	DWORD PTR [esi], eax
	je	$LN129@StartMissi

; 1375 : 			}
; 1376 : 
; 1377 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_SET_UP_FOR_RANGED_ATTACK())

	call	?getMISSION_SET_UP_FOR_RANGED_ATTACK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SET_UP_FOR_RANGED_ATTACK
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN127@StartMissi

; 1378 : 			{
; 1379 : 				hUnit->setSetUpForRangedAttack(true);

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	push	ebp
	call	?setSetUpForRangedAttack@CvUnit@@QAEX_N@Z ; CvUnit::setSetUpForRangedAttack

; 1380 : 				bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1
	jmp	$LN11@StartMissi
$LN127@StartMissi:

; 1381 : 			}
; 1382 : 
; 1383 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_EMBARK())

	call	?getMISSION_EMBARK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_EMBARK
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN125@StartMissi

; 1384 : 			{
; 1385 : 				bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1
	jmp	$LN11@StartMissi
$LN125@StartMissi:

; 1386 : 			}
; 1387 : 
; 1388 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_DISEMBARK())

	call	?getMISSION_DISEMBARK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_DISEMBARK
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN123@StartMissi

; 1389 : 			{
; 1390 : 				bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1
	jmp	$LN11@StartMissi
$LN123@StartMissi:

; 1391 : 			}
; 1392 : 
; 1393 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_AIRLIFT())

	call	?getMISSION_AIRLIFT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_AIRLIFT
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN121@StartMissi

; 1394 : 			{
; 1395 : 				if(hUnit->airlift(pkQueueData->iData1, pkQueueData->iData2))

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+44]
	call	?airlift@CvUnit@@QAE_NHH@Z		; CvUnit::airlift
	test	al, al
	je	$LN11@StartMissi

; 1396 : 				{
; 1397 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1398 : 				}
; 1399 : 			}

	jmp	$LN11@StartMissi
$LN121@StartMissi:

; 1400 : 
; 1401 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_NUKE())

	call	?getMISSION_NUKE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_NUKE
	cmp	DWORD PTR [esi], eax
	jne	$LN118@StartMissi

; 1402 : 			{
; 1403 : 				MissionData& kMissionData = *hUnit->HeadMissionQueueNode();

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?HeadMissionQueueNode@CvUnit@@IAEPAUMissionData@@XZ ; CvUnit::HeadMissionQueueNode

; 1404 : 				if(GC.getMap().plot(kMissionData.iData1, kMissionData.iData2) == NULL || !hUnit->canNukeAt(hUnit->plot(), kMissionData.iData1, kMissionData.iData2))

	mov	ebx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR tv1304[esp+40], edx
	cmp	ebx, -2147483647			; 80000001H
	je	$LN99@StartMissi
	cmp	edx, -2147483647			; 80000001H
	je	$LN99@StartMissi
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	al, al
	je	SHORT $LN263@StartMissi
	test	ebx, ebx
	jge	SHORT $LN265@StartMissi
	mov	eax, ebx
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN267@StartMissi
$LN265@StartMissi:
	cmp	ebx, ecx
	jl	SHORT $LN263@StartMissi
	mov	eax, ebx
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN267@StartMissi
$LN263@StartMissi:
	mov	esi, ebx
$LN267@StartMissi:
	mov	al, BYTE PTR [ebp+4057]
	mov	edi, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN273@StartMissi
	mov	eax, DWORD PTR tv1304[esp+40]
	test	eax, eax
	jge	SHORT $LN275@StartMissi
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN277@StartMissi
$LN275@StartMissi:
	cmp	eax, edi
	jl	SHORT $LN273@StartMissi
	mov	eax, DWORD PTR tv1304[esp+40]
	cdq
	idiv	edi
	jmp	SHORT $LN277@StartMissi
$LN273@StartMissi:
	mov	edx, DWORD PTR tv1304[esp+40]
$LN277@StartMissi:
	test	esi, esi
	jl	$LN99@StartMissi
	cmp	esi, ecx
	jge	$LN99@StartMissi
	test	edx, edx
	jl	$LN99@StartMissi
	cmp	edx, edi
	jge	$LN99@StartMissi
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	test	ecx, ecx
	je	$LN99@StartMissi
	mov	eax, DWORD PTR tv1304[esp+40]
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	push	eax
	push	ebx
	mov	esi, ecx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?canNukeAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z	; CvUnit::canNukeAt
	test	al, al
	jne	$LN11@StartMissi

; 1405 : 				{
; 1406 : 					// Invalid, delete the mission
; 1407 : 					bDelete = true;

	mov	BYTE PTR _bDelete$[esp+40], 1

; 1408 : 				}
; 1409 : 			}

	jmp	$LN11@StartMissi
$LN118@StartMissi:

; 1410 : 
; 1411 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_PARADROP())

	call	?getMISSION_PARADROP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_PARADROP
	cmp	DWORD PTR [esi], eax
	jne	$LN114@StartMissi

; 1412 : 			{
; 1413 : 				if(hUnit->paradrop(pkQueueData->iData1, pkQueueData->iData2))

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edx
	call	?paradrop@CvUnit@@QAE_NHH@Z		; CvUnit::paradrop
	test	al, al
	je	$LN11@StartMissi

; 1414 : 				{
; 1415 : 					bAction = true;
; 1416 : 					// The Paradrop needs to have GameplayUnitMissionEnd, so if no mission timer will be started, do it now.
; 1417 : 					if (hUnit->plot()->isActiveVisible() && (!hUnit->isHuman() || !hUnit->plot()->isVisibleToWatchingHuman() || CalculateMissionTimer(hUnit) == 0))

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	mov	BYTE PTR _bAction$[esp+40], 1
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?isActiveVisible@CvPlot@@QBE_NXZ	; CvPlot::isActiveVisible
	test	al, al
	je	$LN11@StartMissi
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	je	SHORT $LN111@StartMissi
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ ; CvPlot::isVisibleToWatchingHuman
	test	al, al
	je	SHORT $LN111@StartMissi
	push	0
	sub	esp, 8
	lea	eax, DWORD PTR _hUnit$[esp+48]
	mov	ecx, esp
	mov	DWORD PTR $T225572[esp+52], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::CalculateMissionTimer
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN11@StartMissi
$LN111@StartMissi:

; 1418 : 					{
; 1419 : 						auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(hUnit.pointer()));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T225574[esp+40], eax
	mov	BYTE PTR __$EHRec$[esp+48], 1
	test	eax, eax
	je	SHORT $LN156@StartMissi
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	push	ecx
	mov	ecx, eax
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	esi, eax
	jmp	SHORT $LN157@StartMissi
$LN156@StartMissi:
	xor	esi, esi
$LN157@StartMissi:
	mov	DWORD PTR _pDllUnit$218674[esp+40], esi
	mov	BYTE PTR __$EHRec$[esp+48], 2

; 1420 : 						gDLL->GameplayUnitMissionEnd(pDllUnit.get());
; 1421 : 					}
; 1422 : 				}
; 1423 : 			}

	jmp	$LN544@StartMissi
$LN114@StartMissi:

; 1424 : 
; 1425 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_AIR_SWEEP())

	call	?getMISSION_AIR_SWEEP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_AIR_SWEEP
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN109@StartMissi

; 1426 : 			{
; 1427 : 				if(hUnit->airSweep(pkQueueData->iData1, pkQueueData->iData2))

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+44]
	call	?airSweep@CvUnit@@QAE_NHH@Z		; CvUnit::airSweep
	test	al, al
	je	$LN11@StartMissi

; 1428 : 				{
; 1429 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1430 : 				}
; 1431 : 			}

	jmp	$LN11@StartMissi
$LN109@StartMissi:

; 1432 : 
; 1433 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_REBASE())

	call	?getMISSION_REBASE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_REBASE
	cmp	DWORD PTR [esi], eax
	jne	$LN106@StartMissi

; 1434 : 			{
; 1435 : 				if(hUnit->rebase(pkQueueData->iData1, pkQueueData->iData2))

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	push	edx
	push	eax
	call	?rebase@CvUnit@@QAE_NHH@Z		; CvUnit::rebase
	test	al, al
	je	$LN11@StartMissi

; 1436 : 				{
; 1437 : 					bAction = true;
; 1438 : 					// The Rebase needs to have GameplayUnitMissionEnd, so if no mission timer will be started, do it now.
; 1439 : 					if (hUnit->plot()->isActiveVisible() && (!hUnit->isHuman() || !hUnit->plot()->isVisibleToWatchingHuman() || CalculateMissionTimer(hUnit) == 0))

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	mov	BYTE PTR _bAction$[esp+40], 1
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?isActiveVisible@CvPlot@@QBE_NXZ	; CvPlot::isActiveVisible
	test	al, al
	je	$LN11@StartMissi
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	je	SHORT $LN103@StartMissi
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ ; CvPlot::isVisibleToWatchingHuman
	test	al, al
	je	SHORT $LN103@StartMissi
	push	0
	sub	esp, 8
	lea	edx, DWORD PTR _hUnit$[esp+48]
	mov	ecx, esp
	mov	DWORD PTR $T225577[esp+52], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?CalculateMissionTimer@CvUnitMission@@SAHV?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::CalculateMissionTimer
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN11@StartMissi
$LN103@StartMissi:

; 1440 : 					{
; 1441 : 						auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(hUnit.pointer()));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T225579[esp+40], eax
	mov	BYTE PTR __$EHRec$[esp+48], 3
	test	eax, eax
	je	SHORT $LN158@StartMissi
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	push	ecx
	mov	ecx, eax
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	esi, eax
	jmp	SHORT $LN159@StartMissi
$LN158@StartMissi:
	xor	esi, esi
$LN159@StartMissi:
	mov	DWORD PTR _pDllUnit$218689[esp+40], esi
	mov	BYTE PTR __$EHRec$[esp+48], 4
$LN544@StartMissi:

; 1442 : 						gDLL->GameplayUnitMissionEnd(pDllUnit.get());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+672]
	push	esi
	call	eax

; 1443 : 					}
; 1444 : 				}
; 1445 : 			}

	jmp	$LN542@StartMissi
$LN106@StartMissi:

; 1446 : 
; 1447 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_RANGE_ATTACK())

	call	?getMISSION_RANGE_ATTACK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_RANGE_ATTACK
	cmp	DWORD PTR [esi], eax
	jne	$LN101@StartMissi

; 1448 : 			{
; 1449 : 				MissionData& kMissionData = *hUnit->HeadMissionQueueNode();

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?HeadMissionQueueNode@CvUnit@@IAEPAUMissionData@@XZ ; CvUnit::HeadMissionQueueNode

; 1450 : 				if(GC.getMap().plot(kMissionData.iData1, kMissionData.iData2) == NULL || !hUnit->canRangeStrikeAt(kMissionData.iData1, kMissionData.iData2))

	mov	ebx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv1387[esp+40], ecx
	cmp	ebx, -2147483647			; 80000001H
	je	$LN99@StartMissi
	cmp	ecx, -2147483647			; 80000001H
	je	$LN99@StartMissi
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	al, al
	je	SHORT $LN353@StartMissi
	test	ebx, ebx
	jge	SHORT $LN355@StartMissi
	mov	eax, ebx
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN357@StartMissi
$LN355@StartMissi:
	cmp	ebx, ecx
	jl	SHORT $LN353@StartMissi
	mov	eax, ebx
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN357@StartMissi
$LN353@StartMissi:
	mov	esi, ebx
$LN357@StartMissi:
	mov	al, BYTE PTR [ebp+4057]
	mov	edi, DWORD PTR [ebp+4024]
	test	al, al
	mov	eax, DWORD PTR tv1387[esp+40]
	je	SHORT $LN363@StartMissi
	test	eax, eax
	jge	SHORT $LN365@StartMissi
	cdq
	idiv	edi
	mov	eax, DWORD PTR tv1387[esp+40]
	add	edx, edi
	jmp	SHORT $LN367@StartMissi
$LN365@StartMissi:
	cmp	eax, edi
	jl	SHORT $LN363@StartMissi
	cdq
	idiv	edi
	mov	eax, DWORD PTR tv1387[esp+40]
	jmp	SHORT $LN367@StartMissi
$LN363@StartMissi:
	mov	edx, eax
$LN367@StartMissi:
	test	esi, esi
	jl	SHORT $LN99@StartMissi
	cmp	esi, ecx
	jge	SHORT $LN99@StartMissi
	test	edx, edx
	jl	SHORT $LN99@StartMissi
	cmp	edx, edi
	jge	SHORT $LN99@StartMissi
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	test	ecx, ecx
	je	SHORT $LN99@StartMissi
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	push	1
	push	1
	push	eax
	push	ebx
	call	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z	; CvUnit::canRangeStrikeAt
	test	al, al
	jne	$LN11@StartMissi
$LN99@StartMissi:

; 1451 : 				{
; 1452 : 					// Invalid, delete the mission
; 1453 : 					bDelete = true;

	mov	BYTE PTR _bDelete$[esp+40], 1

; 1454 : 				}
; 1455 : 			}

	jmp	$LN11@StartMissi
$LN101@StartMissi:

; 1456 : 
; 1457 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_PILLAGE())

	call	?getMISSION_PILLAGE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_PILLAGE
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN97@StartMissi

; 1458 : 			{
; 1459 : 				if(hUnit->pillage())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?pillage@CvUnit@@QAE_NXZ		; CvUnit::pillage
	test	al, al
	je	$LN11@StartMissi

; 1460 : 				{
; 1461 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1462 : 				}
; 1463 : 			}

	jmp	$LN11@StartMissi
$LN97@StartMissi:

; 1464 : 
; 1465 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_FOUND())

	call	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FOUND
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN94@StartMissi

; 1466 : 			{
; 1467 : 				if(hUnit->found())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?found@CvUnit@@QAE_NXZ			; CvUnit::found
	test	al, al
	je	$LN11@StartMissi

; 1468 : 				{
; 1469 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1470 : 				}
; 1471 : 			}

	jmp	$LN11@StartMissi
$LN94@StartMissi:

; 1472 : 
; 1473 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_JOIN())

	call	?getMISSION_JOIN@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_JOIN
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN91@StartMissi

; 1474 : 			{
; 1475 : 				if(hUnit->join((SpecialistTypes)(hUnit->HeadMissionQueueNode()->iData1)))

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	mov	esi, ecx
	call	?HeadMissionQueueNode@CvUnit@@IAEPAUMissionData@@XZ ; CvUnit::HeadMissionQueueNode
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, esi
	call	?join@CvUnit@@QAE_NW4SpecialistTypes@@@Z ; CvUnit::join
	test	al, al
	je	$LN11@StartMissi

; 1476 : 				{
; 1477 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1478 : 				}
; 1479 : 			}

	jmp	$LN11@StartMissi
$LN91@StartMissi:

; 1480 : 
; 1481 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_CONSTRUCT())

	call	?getMISSION_CONSTRUCT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CONSTRUCT
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN88@StartMissi

; 1482 : 			{
; 1483 : 				if(hUnit->construct((BuildingTypes)(hUnit->HeadMissionQueueNode()->iData1)))

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	mov	esi, ecx
	call	?HeadMissionQueueNode@CvUnit@@IAEPAUMissionData@@XZ ; CvUnit::HeadMissionQueueNode
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?construct@CvUnit@@QAE_NW4BuildingTypes@@@Z ; CvUnit::construct
	test	al, al
	je	$LN11@StartMissi

; 1484 : 				{
; 1485 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1486 : 				}
; 1487 : 			}

	jmp	$LN11@StartMissi
$LN88@StartMissi:

; 1488 : 
; 1489 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_DISCOVER())

	call	?getMISSION_DISCOVER@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_DISCOVER
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN85@StartMissi

; 1490 : 			{
; 1491 : 				if(hUnit->discover())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?discover@CvUnit@@QAE_NXZ		; CvUnit::discover
	test	al, al
	je	$LN11@StartMissi

; 1492 : 				{
; 1493 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1494 : 				}
; 1495 : 			}

	jmp	$LN11@StartMissi
$LN85@StartMissi:

; 1496 : 
; 1497 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_HURRY())

	call	?getMISSION_HURRY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_HURRY
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN82@StartMissi

; 1498 : 			{
; 1499 : 				//if (hUnit->DoRushBuilding())
; 1500 : 				if(hUnit->hurry())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?hurry@CvUnit@@QAE_NXZ			; CvUnit::hurry
	test	al, al
	je	$LN11@StartMissi

; 1501 : 				{
; 1502 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1503 : 				}
; 1504 : 			}

	jmp	$LN11@StartMissi
$LN82@StartMissi:

; 1505 : 
; 1506 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_TRADE())

	call	?getMISSION_TRADE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_TRADE
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN79@StartMissi

; 1507 : 			{
; 1508 : 				if(hUnit->trade())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?trade@CvUnit@@QAE_NXZ			; CvUnit::trade
	test	al, al
	je	$LN11@StartMissi

; 1509 : 				{
; 1510 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1511 : 				}
; 1512 : 			}

	jmp	$LN11@StartMissi
$LN79@StartMissi:

; 1513 : 
; 1514 : 			else if (pkQueueData->eMissionType == CvTypes::getMISSION_BUY_CITY_STATE())

	call	?getMISSION_BUY_CITY_STATE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUY_CITY_STATE
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN76@StartMissi

; 1515 : 			{
; 1516 : 				if (hUnit->buyCityState())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?buyCityState@CvUnit@@QAE_NXZ		; CvUnit::buyCityState
	test	al, al
	je	$LN11@StartMissi

; 1517 : 				{
; 1518 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1519 : 				}
; 1520 : 			}

	jmp	$LN11@StartMissi
$LN76@StartMissi:

; 1521 : 
; 1522 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_REPAIR_FLEET())

	call	?getMISSION_REPAIR_FLEET@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_REPAIR_FLEET
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN73@StartMissi

; 1523 : 			{
; 1524 : 				if(hUnit->repairFleet())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?repairFleet@CvUnit@@QAE_NXZ		; CvUnit::repairFleet
	test	al, al
	je	$LN11@StartMissi

; 1525 : 				{
; 1526 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1527 : 				}
; 1528 : 			}

	jmp	$LN11@StartMissi
$LN73@StartMissi:

; 1529 : 			
; 1530 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_SPACESHIP())

	call	?getMISSION_SPACESHIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPACESHIP
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN70@StartMissi

; 1531 : 			{
; 1532 : 				if(hUnit->DoBuildSpaceship())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?DoBuildSpaceship@CvUnit@@QAE_NXZ	; CvUnit::DoBuildSpaceship
	test	al, al
	je	$LN11@StartMissi

; 1533 : 				{
; 1534 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1535 : 				}
; 1536 : 			}

	jmp	$LN11@StartMissi
$LN70@StartMissi:

; 1537 : 
; 1538 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_CULTURE_BOMB())

	call	?getMISSION_CULTURE_BOMB@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CULTURE_BOMB
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN67@StartMissi

; 1539 : 			{
; 1540 : 				if(hUnit->DoCultureBomb())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?DoCultureBomb@CvUnit@@QAE_NXZ		; CvUnit::DoCultureBomb
	test	al, al
	je	$LN11@StartMissi

; 1541 : 				{
; 1542 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1543 : 				}
; 1544 : 			}

	jmp	$LN11@StartMissi
$LN67@StartMissi:

; 1545 : 
; 1546 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_FOUND_RELIGION())

	call	?getMISSION_FOUND_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FOUND_RELIGION
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN64@StartMissi

; 1547 : 			{
; 1548 : 				if(hUnit->DoFoundReligion())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?DoFoundReligion@CvUnit@@QAE_NXZ	; CvUnit::DoFoundReligion
	test	al, al
	je	$LN11@StartMissi

; 1549 : 				{
; 1550 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1551 : 				}
; 1552 : 			}

	jmp	$LN11@StartMissi
$LN64@StartMissi:

; 1553 : 
; 1554 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_SPREAD_RELIGION())

	call	?getMISSION_SPREAD_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPREAD_RELIGION
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN61@StartMissi

; 1555 : 			{
; 1556 : 				if(hUnit->DoSpreadReligion())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?DoSpreadReligion@CvUnit@@QAE_NXZ	; CvUnit::DoSpreadReligion
	test	al, al
	je	$LN11@StartMissi

; 1557 : 				{
; 1558 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1559 : 				}
; 1560 : 			}

	jmp	$LN11@StartMissi
$LN61@StartMissi:

; 1561 : 
; 1562 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_ENHANCE_RELIGION())

	call	?getMISSION_ENHANCE_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ENHANCE_RELIGION
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN58@StartMissi

; 1563 : 			{
; 1564 : 				if(hUnit->DoEnhanceReligion())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?DoEnhanceReligion@CvUnit@@QAE_NXZ	; CvUnit::DoEnhanceReligion
	test	al, al
	je	$LN11@StartMissi

; 1565 : 				{
; 1566 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1567 : 				}
; 1568 : 			}

	jmp	$LN11@StartMissi
$LN58@StartMissi:

; 1569 : 
; 1570 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_REMOVE_HERESY())

	call	?getMISSION_REMOVE_HERESY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_REMOVE_HERESY
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN55@StartMissi

; 1571 : 			{
; 1572 : 				if(hUnit->DoRemoveHeresy())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?DoRemoveHeresy@CvUnit@@QAE_NXZ		; CvUnit::DoRemoveHeresy
	test	al, al
	je	$LN11@StartMissi

; 1573 : 				{
; 1574 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1575 : 				}
; 1576 : 			}

	jmp	$LN11@StartMissi
$LN55@StartMissi:

; 1577 : 
; 1578 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_GOLDEN_AGE())

	call	?getMISSION_GOLDEN_AGE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GOLDEN_AGE
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN52@StartMissi

; 1579 : 			{
; 1580 : 				//just play animation, not golden age - JW
; 1581 : 				if(hUnit->HeadMissionQueueNode()->iData1 != -1)

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?HeadMissionQueueNode@CvUnit@@IAEPAUMissionData@@XZ ; CvUnit::HeadMissionQueueNode
	cmp	DWORD PTR [eax+4], edi
	je	SHORT $LN51@StartMissi

; 1582 : 				{
; 1583 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1584 : 				}
; 1585 : 				else

	jmp	$LN11@StartMissi
$LN51@StartMissi:

; 1586 : 				{
; 1587 : 					if(hUnit->goldenAge())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?goldenAge@CvUnit@@QAE_NXZ		; CvUnit::goldenAge
	test	al, al
	je	$LN11@StartMissi

; 1588 : 					{
; 1589 : 						bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1590 : 					}
; 1591 : 				}

	jmp	$LN11@StartMissi
$LN52@StartMissi:

; 1592 : 			}
; 1593 : 
; 1594 : 			else if (pkQueueData->eMissionType == CvTypes::getMISSION_ESTABLISH_TRADE_ROUTE())

	call	?getMISSION_ESTABLISH_TRADE_ROUTE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ESTABLISH_TRADE_ROUTE
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN47@StartMissi

; 1595 : 			{
; 1596 : 				CvPlot* pPlot = GC.getMap().plotByIndex(pkQueueData->iData1);

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jl	$LN11@StartMissi
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [ecx+4028]
	jge	$LN11@StartMissi
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 1597 : 				CvAssertMsg(pPlot, "pPlot is null! OH NOES, JOEY!");
; 1598 : 				if (pPlot)

	test	eax, eax
	je	$LN11@StartMissi

; 1599 : 				{
; 1600 : 					if(hUnit->makeTradeRoute(pPlot->getX(), pPlot->getY(), (TradeConnectionType)pkQueueData->iData2))

	movsx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR [esi+8]
	movsx	eax, WORD PTR [eax]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+44]
	push	eax
	call	?makeTradeRoute@CvUnit@@QAE_NHHW4TradeConnectionType@@@Z ; CvUnit::makeTradeRoute
	test	al, al
	je	$LN11@StartMissi

; 1601 : 					{
; 1602 : 						bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1603 : 					}
; 1604 : 				}
; 1605 : 			}

	jmp	$LN11@StartMissi
$LN47@StartMissi:

; 1606 : 	
; 1607 : 			else if (pkQueueData->eMissionType == CvTypes::getMISSION_PLUNDER_TRADE_ROUTE())

	call	?getMISSION_PLUNDER_TRADE_ROUTE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_PLUNDER_TRADE_ROUTE
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN43@StartMissi

; 1608 : 			{
; 1609 : 				if (hUnit->plunderTradeRoute())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?plunderTradeRoute@CvUnit@@QAE_NXZ	; CvUnit::plunderTradeRoute
	test	al, al
	je	$LN11@StartMissi

; 1610 : 				{
; 1611 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1612 : 				}
; 1613 : 			}

	jmp	$LN11@StartMissi
$LN43@StartMissi:

; 1614 : 
; 1615 : 			else if (pkQueueData->eMissionType == CvTypes::getMISSION_GREAT_WORK())

	call	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GREAT_WORK
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN40@StartMissi

; 1616 : 			{
; 1617 : 				if (hUnit->createGreatWork())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?createGreatWork@CvUnit@@QAE_NXZ	; CvUnit::createGreatWork
	test	al, al
	je	$LN11@StartMissi

; 1618 : 				{
; 1619 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1620 : 				}
; 1621 : 			}

	jmp	$LN11@StartMissi
$LN40@StartMissi:

; 1622 : 
; 1623 : 			else if (pkQueueData->eMissionType == CvTypes::getMISSION_CHANGE_TRADE_UNIT_HOME_CITY())

	call	?getMISSION_CHANGE_TRADE_UNIT_HOME_CITY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CHANGE_TRADE_UNIT_HOME_CITY
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN37@StartMissi

; 1624 : 			{
; 1625 : 				if(hUnit->changeTradeUnitHomeCity(pkQueueData->iData1, pkQueueData->iData2))

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+44]
	call	?changeTradeUnitHomeCity@CvUnit@@QAE_NHH@Z ; CvUnit::changeTradeUnitHomeCity
	test	al, al
	je	$LN11@StartMissi

; 1626 : 				{
; 1627 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1628 : 				}
; 1629 : 			}

	jmp	$LN11@StartMissi
$LN37@StartMissi:

; 1630 : 
; 1631 : 			else if (pkQueueData->eMissionType == CvTypes::getMISSION_SELL_EXOTIC_GOODS())

	call	?getMISSION_SELL_EXOTIC_GOODS@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SELL_EXOTIC_GOODS
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN34@StartMissi

; 1632 : 			{
; 1633 : 				if (hUnit->sellExoticGoods())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?sellExoticGoods@CvUnit@@QAE_NXZ	; CvUnit::sellExoticGoods
	test	al, al
	je	$LN11@StartMissi

; 1634 : 				{
; 1635 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1636 : 				}
; 1637 : 			}

	jmp	$LN11@StartMissi
$LN34@StartMissi:

; 1638 : 
; 1639 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_BUILD())

	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	cmp	DWORD PTR [esi], eax
	jne	$LN31@StartMissi

; 1640 : 			{
; 1641 : 				// Gold cost for Improvement construction
; 1642 : 				kUnitOwner.GetTreasury()->ChangeGold(-(kUnitOwner.getBuildCost(hUnit->plot(), (BuildTypes)(hUnit->HeadMissionQueueNode()->iData1))));

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	mov	esi, ecx
	call	?HeadMissionQueueNode@CvUnit@@IAEPAUMissionData@@XZ ; CvUnit::HeadMissionQueueNode
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, ebx
	call	?getBuildCost@CvPlayer@@QBEHPBVCvPlot@@W4BuildTypes@@@Z ; CvPlayer::getBuildCost
	neg	eax
	push	eax
	mov	ecx, ebx
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 1643 : 
; 1644 : 				auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(hUnit.pointer()));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T225583[esp+40], eax
	mov	BYTE PTR __$EHRec$[esp+48], 5
	test	eax, eax
	je	SHORT $LN160@StartMissi
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	push	ecx
	mov	ecx, eax
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	esi, eax
	jmp	SHORT $LN161@StartMissi
$LN160@StartMissi:
	xor	esi, esi
$LN161@StartMissi:
	mov	DWORD PTR _pDllUnit$218773[esp+40], esi

; 1645 : 				gDLL->GameplayUnitWork(pDllUnit.get(), (hUnit->HeadMissionQueueNode()->iData1));

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	mov	ebx, DWORD PTR [edi]
	mov	BYTE PTR __$EHRec$[esp+48], 6
	call	?HeadMissionQueueNode@CvUnit@@IAEPAUMissionData@@XZ ; CvUnit::HeadMissionQueueNode
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ebx+612]
	push	edx
	mov	ecx, edi

; 1646 : 			}

	jmp	SHORT $LN543@StartMissi
$LN31@StartMissi:

; 1647 : 
; 1648 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_ROUTE_TO())

	call	?getMISSION_ROUTE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ROUTE_TO
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN29@StartMissi

; 1649 : 			{
; 1650 : 				auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(hUnit.pointer()));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T225587[esp+40], eax
	mov	BYTE PTR __$EHRec$[esp+48], 7
	test	eax, eax
	je	SHORT $LN162@StartMissi
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	push	ecx
	mov	ecx, eax
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	esi, eax
	jmp	SHORT $LN163@StartMissi
$LN162@StartMissi:
	xor	esi, esi
$LN163@StartMissi:
	mov	DWORD PTR _pDllUnit$218781[esp+40], esi

; 1651 : 				gDLL->GameplayUnitWork(pDllUnit.get(), 0);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+612]
	mov	BYTE PTR __$EHRec$[esp+48], 8
	push	0
$LN543@StartMissi:
	push	esi
	call	eax
$LN542@StartMissi:

; 1652 : 			}

	mov	BYTE PTR __$EHRec$[esp+48], 0
	test	esi, esi
	je	$LN11@StartMissi
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	call	edx
	jmp	$LN11@StartMissi
$LN29@StartMissi:

; 1653 : 
; 1654 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_LEAD())

	call	?getMISSION_LEAD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_LEAD
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN27@StartMissi

; 1655 : 			{
; 1656 : 				if(hUnit->lead(hUnit->HeadMissionQueueNode()->iData1))

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	mov	esi, ecx
	call	?HeadMissionQueueNode@CvUnit@@IAEPAUMissionData@@XZ ; CvUnit::HeadMissionQueueNode
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, esi
	call	?lead@CvUnit@@QAE_NH@Z			; CvUnit::lead
	test	al, al
	je	$LN11@StartMissi

; 1657 : 				{
; 1658 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1659 : 				}
; 1660 : 			}

	jmp	$LN11@StartMissi
$LN27@StartMissi:

; 1661 : 
; 1662 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_DIE_ANIMATION())

	call	?getMISSION_DIE_ANIMATION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_DIE_ANIMATION
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN24@StartMissi

; 1663 : 			{
; 1664 : 				bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1
	jmp	$LN11@StartMissi
$LN24@StartMissi:

; 1665 : 			}
; 1666 : 
; 1667 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_GIVE_POLICIES())

	call	?getMISSION_GIVE_POLICIES@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GIVE_POLICIES
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN22@StartMissi

; 1668 : 			{
; 1669 : 				//just play animation, not golden age - JW
; 1670 : 				if(hUnit->HeadMissionQueueNode()->iData1 != -1)

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?HeadMissionQueueNode@CvUnit@@IAEPAUMissionData@@XZ ; CvUnit::HeadMissionQueueNode
	cmp	DWORD PTR [eax+4], edi
	je	SHORT $LN21@StartMissi

; 1671 : 				{
; 1672 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1673 : 				}
; 1674 : 				else

	jmp	SHORT $LN11@StartMissi
$LN21@StartMissi:

; 1675 : 				{
; 1676 : 					if(hUnit->givePolicies())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?givePolicies@CvUnit@@QAE_NXZ		; CvUnit::givePolicies
	test	al, al
	je	SHORT $LN11@StartMissi

; 1677 : 					{
; 1678 : 						bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1679 : 					}
; 1680 : 				}

	jmp	SHORT $LN11@StartMissi
$LN22@StartMissi:

; 1681 : 			}
; 1682 : 
; 1683 : 			else if(pkQueueData->eMissionType == CvTypes::getMISSION_ONE_SHOT_TOURISM())

	call	?getMISSION_ONE_SHOT_TOURISM@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ONE_SHOT_TOURISM
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN17@StartMissi

; 1684 : 			{
; 1685 : 				//just play animation, not golden age - JW
; 1686 : 				if(hUnit->HeadMissionQueueNode()->iData1 != -1)

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?HeadMissionQueueNode@CvUnit@@IAEPAUMissionData@@XZ ; CvUnit::HeadMissionQueueNode
	cmp	DWORD PTR [eax+4], edi
	je	SHORT $LN16@StartMissi

; 1687 : 				{
; 1688 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1689 : 				}
; 1690 : 				else

	jmp	SHORT $LN11@StartMissi
$LN16@StartMissi:

; 1691 : 				{
; 1692 : 					if(hUnit->blastTourism())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?blastTourism@CvUnit@@QAE_NXZ		; CvUnit::blastTourism
	test	al, al
	je	SHORT $LN11@StartMissi

; 1693 : 					{
; 1694 : 						bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1

; 1695 : 					}
; 1696 : 				}

	jmp	SHORT $LN11@StartMissi
$LN17@StartMissi:

; 1697 : 			}
; 1698 : 
; 1699 : 			else if (pkQueueData->eMissionType == CvTypes::getMISSION_CHANGE_ADMIRAL_PORT())

	call	?getMISSION_CHANGE_ADMIRAL_PORT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CHANGE_ADMIRAL_PORT
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN11@StartMissi

; 1700 : 			{
; 1701 : 				if(hUnit->changeAdmiralPort(pkQueueData->iData1, pkQueueData->iData2))

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+40]
	push	edx
	call	?changeAdmiralPort@CvUnit@@QAE_NHH@Z	; CvUnit::changeAdmiralPort
	test	al, al
	je	SHORT $LN11@StartMissi

; 1702 : 				{
; 1703 : 					bAction = true;

	mov	BYTE PTR _bAction$[esp+40], 1
	jmp	SHORT $LN11@StartMissi
$LN129@StartMissi:

; 1373 : 			{
; 1374 : 				hUnit->SetFortifiedThisTurn(true);

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	push	ebp
	call	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z	; CvUnit::SetFortifiedThisTurn
$LN11@StartMissi:

; 1704 : 				}
; 1705 : 			}
; 1706 : 		}
; 1707 : 	}
; 1708 : 
; 1709 : 	if(hUnit->HeadMissionQueueNode() != NULL)

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?HeadMissionQueueNode@CvUnit@@IAEPAUMissionData@@XZ ; CvUnit::HeadMissionQueueNode
	test	eax, eax
	je	$LN1@StartMissi

; 1710 : 	{
; 1711 : 		if(bAction)

	cmp	BYTE PTR _bAction$[esp+40], 0
	je	SHORT $LN7@StartMissi

; 1712 : 		{
; 1713 : 			if(hUnit->isHuman())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	je	SHORT $LN7@StartMissi

; 1714 : 			{
; 1715 : 				if(hUnit->plot()->isVisibleToWatchingHuman())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ ; CvPlot::isVisibleToWatchingHuman
	test	al, al
	je	SHORT $LN7@StartMissi

; 1716 : 				{
; 1717 : 					UpdateMissionTimer(hUnit);

	push	0
	sub	esp, 8
	lea	eax, DWORD PTR _hUnit$[esp+48]
	mov	ecx, esp
	mov	DWORD PTR $T225590[esp+52], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?UpdateMissionTimer@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@H@Z ; CvUnitMission::UpdateMissionTimer
	add	esp, 12					; 0000000cH
$LN7@StartMissi:

; 1718 : 				}
; 1719 : 			}
; 1720 : 		}
; 1721 : 
; 1722 : 		if(!hUnit->IsBusy())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?IsBusy@CvUnit@@QBE_NXZ			; CvUnit::IsBusy
	test	al, al
	jne	$LN1@StartMissi

; 1723 : 		{
; 1724 : 			if(bDelete)
; 1725 : 			{
; 1726 : 				if(hUnit->getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	cmp	BYTE PTR _bDelete$[esp+40], al
	je	SHORT $LN5@StartMissi
	mov	esi, DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	SHORT $LN3@StartMissi

; 1727 : 				{
; 1728 : 					if(hUnit->IsSelected())

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?IsSelected@CvUnit@@QBE_NXZ		; CvUnit::IsSelected
	test	al, al
	je	SHORT $LN3@StartMissi

; 1729 : 					{
; 1730 : 						GC.GetEngineUserInterface()->changeCycleSelectionCounter(kUnitOwner.isOption(PLAYEROPTION_QUICK_MOVES)? 1 : 2);

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	ecx, DWORD PTR _kUnitOwner$[esp+40]
	mov	edi, DWORD PTR [esi]
	push	3
	call	?isOption@CvPlayer@@QBE_NW4PlayerOptionTypes@@@Z ; CvPlayer::isOption
	movzx	edx, al
	mov	eax, DWORD PTR [edi+224]
	neg	edx
	sbb	edx, edx
	add	edx, 2
	push	edx
	mov	ecx, esi
	call	eax
$LN3@StartMissi:

; 1731 : 					}
; 1732 : 				}
; 1733 : 
; 1734 : 				DeleteMissionQueueNode(hUnit, hUnit->HeadMissionQueueNode());

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	call	?HeadMissionQueueNode@CvUnit@@IAEPAUMissionData@@XZ ; CvUnit::HeadMissionQueueNode
	mov	ecx, DWORD PTR _hUnit$[esp+36]
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _hUnit$[esp+52]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T225591[esp+52], esp
	test	eax, eax
	je	SHORT $LN514@StartMissi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN514@StartMissi:
	call	?DeleteMissionQueueNode@CvUnitMission@@CAPAUMissionData@@V?$FObjectHandle@VCvUnit@@@@PAU2@@Z ; CvUnitMission::DeleteMissionQueueNode
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN1@StartMissi
$LN5@StartMissi:

; 1735 : 			}
; 1736 : 			else if(hUnit->GetActivityType() == ACTIVITY_MISSION)

	call	?GetActivityType@CvUnit@@QBE?AW4ActivityTypes@@XZ ; CvUnit::GetActivityType
	cmp	eax, 6
	jne	SHORT $LN1@StartMissi

; 1737 : 			{
; 1738 : 				ContinueMission(hUnit);

	push	-1
	push	0
	sub	esp, 8
	lea	eax, DWORD PTR _hUnit$[esp+52]
	mov	ecx, esp
	mov	DWORD PTR $T225592[esp+56], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z ; CvUnitMission::ContinueMission
	add	esp, 16					; 00000010H
$LN1@StartMissi:

; 1739 : 			}
; 1740 : 		}
; 1741 : 	}
; 1742 : 	--stackDepth;

	dec	DWORD PTR ?stackDepth@?1??StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z@4HA
$LN538@StartMissi:

; 1743 : }

	mov	ecx, DWORD PTR _hUnit$[esp+36]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	test	ecx, ecx
	je	SHORT $LN521@StartMissi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN521@StartMissi:
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$4:
	mov	eax, DWORD PTR $T225574[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$5:
	lea	ecx, DWORD PTR _pDllUnit$218674[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$7:
	mov	eax, DWORD PTR $T225579[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$8:
	lea	ecx, DWORD PTR _pDllUnit$218689[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$9:
	mov	eax, DWORD PTR $T225583[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$10:
	lea	ecx, DWORD PTR _pDllUnit$218773[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$11:
	mov	eax, DWORD PTR $T225587[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$12:
	lea	ecx, DWORD PTR _pDllUnit$218781[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__ehhandler$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvUnitMission::StartMission
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ActivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ActivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@@Z$0
__ehfuncinfo$?ActivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ActivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?ActivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
$T226380 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
?ActivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvUnitMission::ActivateHeadMission, COMDAT

; 1963 : {

	push	-1
	push	__ehhandler$?ActivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 1964 : 	VALIDATE_OBJECT
; 1965 : 	CvAssert(hUnit->getOwner() != NO_PLAYER);
; 1966 : 	if(hUnit->GetLengthMissionQueue() != 0)

	mov	ecx, DWORD PTR _hUnit$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0
	call	?GetLengthMissionQueue@CvUnit@@QBEHXZ	; CvUnit::GetLengthMissionQueue
	test	eax, eax
	je	SHORT $LN1@ActivateHe

; 1967 : 	{
; 1968 : 		if(!hUnit->IsBusy())

	mov	ecx, DWORD PTR _hUnit$[esp+12]
	call	?IsBusy@CvUnit@@QBE_NXZ			; CvUnit::IsBusy
	test	al, al
	jne	SHORT $LN1@ActivateHe

; 1969 : 		{
; 1970 : 			StartMission(hUnit);

	mov	ecx, DWORD PTR _hUnit$[esp+12]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _hUnit$[esp+24]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T226380[esp+24], esp
	test	eax, eax
	je	SHORT $LN14@ActivateHe
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN14@ActivateHe:
	call	?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z ; CvUnitMission::StartMission
	add	esp, 8
$LN1@ActivateHe:

; 1971 : 		}
; 1972 : 	}
; 1973 : }

	mov	ecx, DWORD PTR _hUnit$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], -1
	test	ecx, ecx
	je	SHORT $LN19@ActivateHe
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN19@ActivateHe:
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ActivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ActivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ActivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ActivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvUnitMission::ActivateHeadMission
PUBLIC	?AutoMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z ; CvUnitMission::AutoMission
EXTRN	?doDelayedDeath@CvUnit@@QAE_NXZ:PROC		; CvUnit::doDelayedDeath
EXTRN	?SetIgnoreDangerWakeup@CvUnit@@QAEX_N@Z:PROC	; CvUnit::SetIgnoreDangerWakeup
EXTRN	?ClearMissionQueue@CvUnit@@QAEXH@Z:PROC		; CvUnit::ClearMissionQueue
EXTRN	?IsPlotUnderImmediateThreat@CvPlayer@@QBE_NAAVCvPlot@@@Z:PROC ; CvPlayer::IsPlotUnderImmediateThreat
EXTRN	?IsIgnoringDangerWakeup@CvUnit@@QBE_NXZ:PROC	; CvUnit::IsIgnoringDangerWakeup
EXTRN	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlot::getNumDefenders
EXTRN	?isDelayedDeath@CvUnit@@QBE_NXZ:PROC		; CvUnit::isDelayedDeath
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?AutoMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AutoMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$0
__ehfuncinfo$?AutoMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AutoMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?AutoMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
$T226420 = -16						; size = 4
$T226419 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
?AutoMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvUnitMission::AutoMission, COMDAT

; 38   : {

	push	-1
	push	__ehhandler$?AutoMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi

; 39   : 	CvAssert(hUnit->getOwner() != NO_PLAYER);
; 40   : 
; 41   : 	const MissionQueueNode* pkMissionNode = HeadMissionQueueNode(hUnit->m_missionQueue);

	mov	ecx, DWORD PTR _hUnit$[esp+16]
	mov	eax, DWORD PTR [ecx+2604]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	test	eax, eax
	jbe	$LN1@AutoMissio
	mov	esi, DWORD PTR [ecx+2600]

; 42   : 	if(pkMissionNode != NULL)

	test	esi, esi
	je	$LN1@AutoMissio

; 43   : 	{
; 44   : 		if(!hUnit->IsBusy() && !hUnit->isDelayedDeath())

	call	?IsBusy@CvUnit@@QBE_NXZ			; CvUnit::IsBusy
	test	al, al
	jne	$LN1@AutoMissio
	mov	ecx, DWORD PTR _hUnit$[esp+16]
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	test	al, al
	jne	$LN1@AutoMissio

; 45   : 		{
; 46   : 			// Builders which are being escorted shouldn't wake up every turn... this is annoying!
; 47   : 			bool bEscortedBuilder = false;
; 48   : 			if(pkMissionNode->eMissionType == CvTypes::getMISSION_BUILD())

	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN71@AutoMissio

; 49   : 			{
; 50   : 				if(hUnit->plot()->getNumDefenders(hUnit->getOwner()) > 0)

	mov	ecx, DWORD PTR _hUnit$[esp+16]
	mov	eax, DWORD PTR [ecx+40]
	push	eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumDefenders
	test	eax, eax
	jg	SHORT $LN72@AutoMissio
$LN71@AutoMissio:

; 51   : 				{
; 52   : 					bEscortedBuilder = true;
; 53   : 				}
; 54   : 			}
; 55   : 
; 56   : 			if(!bEscortedBuilder && !hUnit->IsIgnoringDangerWakeup() && !hUnit->IsCombatUnit() && GET_PLAYER(hUnit->getOwner()).IsPlotUnderImmediateThreat(*(hUnit->plot())))

	mov	ecx, DWORD PTR _hUnit$[esp+16]
	call	?IsIgnoringDangerWakeup@CvUnit@@QBE_NXZ	; CvUnit::IsIgnoringDangerWakeup
	test	al, al
	jne	SHORT $LN72@AutoMissio
	mov	ecx, DWORD PTR _hUnit$[esp+16]
	cmp	DWORD PTR [ecx+1044], 0
	jg	SHORT $LN4@AutoMissio
	mov	eax, DWORD PTR [ecx+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?IsPlotUnderImmediateThreat@CvPlayer@@QBE_NAAVCvPlot@@@Z ; CvPlayer::IsPlotUnderImmediateThreat
	test	al, al
	je	SHORT $LN72@AutoMissio

; 57   : 			{
; 58   : 				hUnit->ClearMissionQueue();

	mov	ecx, DWORD PTR _hUnit$[esp+16]
	push	1
	call	?ClearMissionQueue@CvUnit@@QAEXH@Z	; CvUnit::ClearMissionQueue

; 59   : 				hUnit->SetIgnoreDangerWakeup(true);

	mov	ecx, DWORD PTR _hUnit$[esp+16]
	push	1
	call	?SetIgnoreDangerWakeup@CvUnit@@QAEX_N@Z	; CvUnit::SetIgnoreDangerWakeup

; 60   : 			}
; 61   : 			else

	jmp	SHORT $LN1@AutoMissio
$LN72@AutoMissio:
	mov	ecx, DWORD PTR _hUnit$[esp+16]
$LN4@AutoMissio:

; 62   : 			{
; 63   : 				if(hUnit->GetActivityType() == ACTIVITY_MISSION)

	call	?GetActivityType@CvUnit@@QBE?AW4ActivityTypes@@XZ ; CvUnit::GetActivityType
	cmp	eax, 6
	jne	SHORT $LN2@AutoMissio

; 64   : 				{
; 65   : 					ContinueMission(hUnit);

	push	-1
	push	0
	sub	esp, 8
	lea	eax, DWORD PTR _hUnit$[esp+32]
	mov	ecx, esp
	mov	DWORD PTR $T226419[esp+36], esp
	push	eax
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z ; CvUnitMission::ContinueMission
	add	esp, 16					; 00000010H

; 66   : 				}
; 67   : 				else

	jmp	SHORT $LN1@AutoMissio
$LN2@AutoMissio:

; 68   : 				{
; 69   : 					StartMission(hUnit);

	sub	esp, 8
	lea	edx, DWORD PTR _hUnit$[esp+24]
	mov	ecx, esp
	mov	DWORD PTR $T226420[esp+28], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?StartMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z ; CvUnitMission::StartMission
	add	esp, 8
$LN1@AutoMissio:

; 70   : 				}
; 71   : 			}
; 72   : 		}
; 73   : 	}
; 74   : 
; 75   : 	hUnit.ignoreDestruction(true);
; 76   : 	hUnit->doDelayedDeath();

	mov	ecx, DWORD PTR _hUnit$[esp+16]
	mov	BYTE PTR _hUnit$[esp+20], 1
	call	?doDelayedDeath@CvUnit@@QAE_NXZ		; CvUnit::doDelayedDeath

; 77   : }

	mov	ecx, DWORD PTR _hUnit$[esp+16]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	test	ecx, ecx
	je	SHORT $LN69@AutoMissio
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN69@AutoMissio:
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AutoMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?AutoMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?AutoMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AutoMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvUnitMission::AutoMission
PUBLIC	?UpdateMission@CvUnitMission@@SAXAAV?$FObjectHandle@VCvUnit@@@@@Z ; CvUnitMission::UpdateMission
; Function compile flags: /Ogtpy
;	COMDAT ?UpdateMission@CvUnitMission@@SAXAAV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
$T226555 = 8						; size = 4
_hUnit$ = 8						; size = 4
?UpdateMission@CvUnitMission@@SAXAAV?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvUnitMission::UpdateMission, COMDAT

; 363  : {

	push	esi

; 364  : 	CvAssert(hUnit->getOwner() != NO_PLAYER);
; 365  : 
; 366  : 	if(hUnit->GetMissionTimer() > 0)

	mov	esi, DWORD PTR _hUnit$[esp]
	mov	ecx, DWORD PTR [esi]
	call	?GetMissionTimer@CvUnit@@QBEHXZ		; CvUnit::GetMissionTimer
	test	eax, eax
	jle	SHORT $LN1@UpdateMiss@2

; 367  : 	{
; 368  : 		hUnit->ChangeMissionTimer(-1);

	mov	ecx, DWORD PTR [esi]
	push	-1
	call	?ChangeMissionTimer@CvUnit@@QAEXH@Z	; CvUnit::ChangeMissionTimer

; 369  : 
; 370  : 		if(hUnit->GetMissionTimer() == 0)

	mov	ecx, DWORD PTR [esi]
	call	?GetMissionTimer@CvUnit@@QBEHXZ		; CvUnit::GetMissionTimer
	test	eax, eax
	jne	SHORT $LN1@UpdateMiss@2

; 371  : 		{
; 372  : 			if(hUnit->GetActivityType() == ACTIVITY_MISSION)

	mov	ecx, DWORD PTR [esi]
	call	?GetActivityType@CvUnit@@QBE?AW4ActivityTypes@@XZ ; CvUnit::GetActivityType
	cmp	eax, 6
	jne	SHORT $LN3@UpdateMiss@2

; 373  : 			{
; 374  : 				ContinueMission(hUnit);

	mov	ecx, DWORD PTR [esi]
	push	-1
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR [esi+4]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T226555[esp+16], esp
	test	eax, eax
	je	SHORT $LN20@UpdateMiss@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN20@UpdateMiss@2:
	call	?ContinueMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@HH@Z ; CvUnitMission::ContinueMission
	add	esp, 16					; 00000010H

; 383  : 					}
; 384  : 				}
; 385  : 			}
; 386  : 		}
; 387  : 	}
; 388  : }

	pop	esi
	ret	0
$LN3@UpdateMiss@2:

; 375  : 			}
; 376  : 			else
; 377  : 			{
; 378  : 				if(hUnit->getOwner() == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [eax+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	SHORT $LN1@UpdateMiss@2

; 379  : 				{
; 380  : 					//if (GC.GetEngineUserInterface()->GetHeadSelectedUnit() == NULL)
; 381  : 					{
; 382  : 						GC.GetEngineUserInterface()->changeCycleSelectionCounter(1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+224]
	push	1
	call	eax
$LN1@UpdateMiss@2:

; 383  : 					}
; 384  : 				}
; 385  : 			}
; 386  : 		}
; 387  : 	}
; 388  : }

	pop	esi
	ret	0
?UpdateMission@CvUnitMission@@SAXAAV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvUnitMission::UpdateMission
_TEXT	ENDS
PUBLIC	?InsertAtEndMissionQueue@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@UMissionData@@_N@Z ; CvUnitMission::InsertAtEndMissionQueue
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?InsertAtEndMissionQueue@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@UMissionData@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InsertAtEndMissionQueue@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@UMissionData@@_N@Z$0
__ehfuncinfo$?InsertAtEndMissionQueue@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@UMissionData@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?InsertAtEndMissionQueue@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@UMissionData@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?InsertAtEndMissionQueue@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@UMissionData@@_N@Z
_TEXT	SEGMENT
$T226607 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
_mission$ = 16						; size = 20
_bStart$ = 36						; size = 1
?InsertAtEndMissionQueue@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@UMissionData@@_N@Z PROC ; CvUnitMission::InsertAtEndMissionQueue, COMDAT

; 1878 : {

	push	-1
	push	__ehhandler$?InsertAtEndMissionQueue@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@UMissionData@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi

; 1879 : 	CvAssert(hUnit->getOwner() != NO_PLAYER);
; 1880 : 
; 1881 : 	MissionQueue& kQueue = hUnit->m_missionQueue;

	mov	esi, DWORD PTR _hUnit$[esp+16]

; 1882 : 	kQueue.insertAtEnd(&mission);

	lea	eax, DWORD PTR _mission$[esp+16]
	add	esi, 2600				; 00000a28H
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	?push_back@?$FStaticVector@UMissionData@@$0M@$00$0BCJ@$0A@@@QAEIABUMissionData@@@Z ; FStaticVector<MissionData,12,1,297,0>::push_back

; 1883 : 
; 1884 : 	CvAssert(kQueue.getLength() < 10);
; 1885 : 
; 1886 : 	if((GetLengthMissionQueue(kQueue) == 1) && bStart)

	mov	esi, DWORD PTR [esi+4]
	cmp	esi, 1
	jne	SHORT $LN2@InsertAtEn
	cmp	BYTE PTR _bStart$[esp+16], 0
	je	SHORT $LN2@InsertAtEn

; 1887 : 	{
; 1888 : 		ActivateHeadMission(hUnit);

	mov	ecx, DWORD PTR _hUnit$[esp+16]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _hUnit$[esp+28]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T226607[esp+28], esp
	test	eax, eax
	je	SHORT $LN20@InsertAtEn
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN20@InsertAtEn:
	call	?ActivateHeadMission@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@@Z ; CvUnitMission::ActivateHeadMission
	add	esp, 8
$LN2@InsertAtEn:

; 1889 : 	}
; 1890 : 
; 1891 : 	if((hUnit->getOwner() == GC.getGame().getActivePlayer()) && hUnit->IsSelected())

	mov	eax, DWORD PTR _hUnit$[esp+16]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [eax+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	SHORT $LN1@InsertAtEn
	mov	ecx, DWORD PTR _hUnit$[esp+16]
	call	?IsSelected@CvUnit@@QBE_NXZ		; CvUnit::IsSelected
	test	al, al
	je	SHORT $LN1@InsertAtEn

; 1892 : 	{
; 1893 : 		
; 1894 : 		GC.GetEngineUserInterface()->setDirty(Waypoints_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	2
	call	eax

; 1895 : 		GC.GetEngineUserInterface()->setDirty(SelectionButtons_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	6
	call	eax

; 1896 : 		GC.GetEngineUserInterface()->setDirty(UnitInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	19					; 00000013H
	call	eax
$LN1@InsertAtEn:

; 1897 : 	}
; 1898 : }

	mov	ecx, DWORD PTR _hUnit$[esp+16]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	test	ecx, ecx
	je	SHORT $LN41@InsertAtEn
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@InsertAtEn:
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InsertAtEndMissionQueue@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@UMissionData@@_N@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?InsertAtEndMissionQueue@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@UMissionData@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?InsertAtEndMissionQueue@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@UMissionData@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?InsertAtEndMissionQueue@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@UMissionData@@_N@Z ENDP ; CvUnitMission::InsertAtEndMissionQueue
PUBLIC	?PushMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@W4MissionTypes@@HHH_N2W4MissionAITypes@@PAVCvPlot@@PAVCvUnit@@@Z ; CvUnitMission::PushMission
EXTRN	?PlayActionSound@CvUnit@@QAEXXZ:PROC		; CvUnit::PlayActionSound
EXTRN	?isSound@CvMissionInfo@@QBE_NXZ:PROC		; CvMissionInfo::isSound
EXTRN	?getMissionInfo@CvGlobals@@QAEPAVCvMissionInfo@@W4MissionTypes@@@Z:PROC ; CvGlobals::getMissionInfo
EXTRN	?SetMissionAI@CvUnit@@QAEXW4MissionAITypes@@PAVCvPlot@@PAV1@@Z:PROC ; CvUnit::SetMissionAI
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?getFeatureTime@CvBuildInfo@@QBEHH@Z:PROC	; CvBuildInfo::getFeatureTime
EXTRN	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z:PROC	; CvBuildInfo::isFeatureRemove
EXTRN	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z:PROC ; CvUnit::SetAutomateType
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?PushMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@W4MissionTypes@@HHH_N2W4MissionAITypes@@PAVCvPlot@@PAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PushMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@W4MissionTypes@@HHH_N2W4MissionAITypes@@PAVCvPlot@@PAVCvUnit@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PushMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@W4MissionTypes@@HHH_N2W4MissionAITypes@@PAVCvPlot@@PAVCvUnit@@@Z$1
__ehfuncinfo$?PushMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@W4MissionTypes@@HHH_N2W4MissionAITypes@@PAVCvPlot@@PAVCvUnit@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?PushMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@W4MissionTypes@@HHH_N2W4MissionAITypes@@PAVCvPlot@@PAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunitmission.cpp
xdata$x	ENDS
;	COMDAT ?PushMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@W4MissionTypes@@HHH_N2W4MissionAITypes@@PAVCvPlot@@PAVCvUnit@@@Z
_TEXT	SEGMENT
$T226697 = -64						; size = 4
$T226696 = -64						; size = 4
$T226694 = -64						; size = 4
_removeMission$218014 = -60				; size = 20
$T226693 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_hUnit$ = 8						; size = 8
_eMission$ = 16						; size = 4
_iData1$ = 20						; size = 4
_iData2$ = 24						; size = 4
_iFlags$ = 28						; size = 4
$T226698 = 32						; size = 4
_pkBuildInfo$218007 = 32				; size = 4
_bAppend$ = 32						; size = 1
_bManual$ = 36						; size = 1
_eMissionAI$ = 40					; size = 4
_pMissionAIPlot$ = 44					; size = 4
_pMissionAIUnit$ = 48					; size = 4
?PushMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@W4MissionTypes@@HHH_N2W4MissionAITypes@@PAVCvPlot@@PAVCvUnit@@@Z PROC ; CvUnitMission::PushMission, COMDAT

; 82   : {

	push	-1
	push	__ehhandler$?PushMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@W4MissionTypes@@HHH_N2W4MissionAITypes@@PAVCvPlot@@PAVCvUnit@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 83   : 	if(CvPreGame::isHuman(hUnit->getOwner()))

	mov	eax, DWORD PTR _hUnit$[esp+76]
	mov	eax, DWORD PTR [eax+40]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	?isHuman@CvPreGame@@YA_NW4PlayerTypes@@@Z ; CvPreGame::isHuman
	add	esp, 4
	test	al, al
	je	SHORT $LN30@PushMissio

; 84   : 	{
; 85   : 		CvAssertMsg(CvUnit::dispatchingNetMessage(), "Multiplayer Error! CvUnit::PushMission invoked for a human player outside of a network message!");
; 86   : 		if(!CvUnit::dispatchingNetMessage())

	call	?dispatchingNetMessage@CvUnit@@SA_NXZ	; CvUnit::dispatchingNetMessage
	test	al, al
	jne	SHORT $LN30@PushMissio

; 87   : 			gDLL->netMessageDebugLog("*** PROTOCOL ERROR *** : PushMission invoked for a human controlled player outside of a network message!");

	push	OFFSET $SG217999
	lea	ecx, DWORD PTR $T226693[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+76]
	lea	eax, DWORD PTR $T226693[esp+80]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+92], 1
	call	edx
	lea	ecx, DWORD PTR $T226693[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN30@PushMissio:

; 88   : 	}
; 89   : 
; 90   : 	MissionData mission;
; 91   : 
; 92   : 	CvAssert(hUnit->getOwner() != NO_PLAYER);
; 93   : 
; 94   : 	if(!bAppend)

	mov	bl, BYTE PTR _bAppend$[esp+76]
	test	bl, bl
	jne	SHORT $LN29@PushMissio

; 95   : 	{
; 96   : 		hUnit->ClearMissionQueue();

	mov	ecx, DWORD PTR _hUnit$[esp+76]
	push	1
	call	?ClearMissionQueue@CvUnit@@QAEXH@Z	; CvUnit::ClearMissionQueue
$LN29@PushMissio:

; 97   : 	}
; 98   : 
; 99   : 	if(bManual)

	cmp	BYTE PTR _bManual$[esp+76], 0
	je	SHORT $LN28@PushMissio

; 100  : 	{
; 101  : 		hUnit->SetAutomateType(NO_AUTOMATE);

	mov	ecx, DWORD PTR _hUnit$[esp+76]
	push	-1
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType
$LN28@PushMissio:

; 102  : 	}
; 103  : 
; 104  : 	// Update Builder Resource info
; 105  : 	if(eMission == CvTypes::getMISSION_BUILD())

	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD

; 106  : 	{
; 107  : 		const BuildTypes eBuild = (BuildTypes) iData1;
; 108  : 		if(eBuild != NO_BUILD)

	mov	ebp, DWORD PTR _iData1$[esp+76]
	cmp	DWORD PTR _eMission$[esp+76], eax
	jne	$LN10@PushMissio
	cmp	ebp, -1
	je	$LN10@PushMissio

; 109  : 		{
; 110  : 			CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	edi, eax
	mov	DWORD PTR _pkBuildInfo$218007[esp+76], edi

; 111  : 			if(pkBuildInfo)

	test	edi, edi
	je	$LN10@PushMissio

; 112  : 			{
; 113  : 				if (GET_PLAYER(hUnit->getOwner()).IsPlotUnderImmediateThreat(*(hUnit->plot())))

	mov	ecx, DWORD PTR _hUnit$[esp+76]
	mov	eax, DWORD PTR [ecx+40]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?IsPlotUnderImmediateThreat@CvPlayer@@QBE_NAAVCvPlot@@@Z ; CvPlayer::IsPlotUnderImmediateThreat
	test	al, al
	je	SHORT $LN23@PushMissio

; 114  : 				{
; 115  : 					if(hUnit->plot()->getNumDefenders(hUnit->getOwner()) <= 0)

	mov	ecx, DWORD PTR _hUnit$[esp+76]
	mov	eax, DWORD PTR [ecx+40]
	push	eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumDefenders
	test	eax, eax
	jg	SHORT $LN23@PushMissio

; 116  : 					{
; 117  : 						hUnit->SetIgnoreDangerWakeup(true);

	mov	ecx, DWORD PTR _hUnit$[esp+76]
	push	1
	call	?SetIgnoreDangerWakeup@CvUnit@@QAEX_N@Z	; CvUnit::SetIgnoreDangerWakeup
$LN23@PushMissio:

; 118  : 					}
; 119  : 				}
; 120  : 
; 121  : 				//if (hUnit->isHuman())
; 122  : 				{
; 123  : 					FeatureTypes eFeature = hUnit->plot()->getFeatureType();

	mov	ecx, DWORD PTR _hUnit$[esp+76]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	esi, BYTE PTR [eax+432]

; 124  : 					if(eFeature != NO_FEATURE && pkBuildInfo->isFeatureRemove(eFeature) && pkBuildInfo->getFeatureTime(eFeature) > 0)

	cmp	esi, -1
	je	$LN15@PushMissio
	push	esi
	mov	ecx, edi
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	test	al, al
	je	$LN15@PushMissio
	push	esi
	mov	ecx, edi
	call	?getFeatureTime@CvBuildInfo@@QBEHH@Z	; CvBuildInfo::getFeatureTime
	test	eax, eax
	jle	$LN15@PushMissio

; 125  : 					{
; 126  : 						CvFeatureInfo* feature = GC.getFeatureInfo(eFeature);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	edi, eax

; 127  : 						MissionData removeMission;

	xor	eax, eax
	mov	DWORD PTR _removeMission$218014[esp+84], eax
	mov	DWORD PTR _removeMission$218014[esp+88], eax
	mov	DWORD PTR _removeMission$218014[esp+92], eax
	mov	DWORD PTR _removeMission$218014[esp+96], eax

; 128  : 						removeMission.eMissionType = eMission;
; 129  : 						if(iData1 != 15 && strcmp(feature->GetType(), "FEATURE_FOREST") == 0)

	cmp	ebp, 15					; 0000000fH
	je	$LN21@PushMissio
	lea	ecx, DWORD PTR [edi+176]
	mov	esi, OFFSET $SG218016
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	npad	5
$LL149@PushMissio:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN150@PushMissio
	test	cl, cl
	je	SHORT $LN151@PushMissio
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN150@PushMissio
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL149@PushMissio
$LN151@PushMissio:
	xor	eax, eax
	jmp	SHORT $LN152@PushMissio
$LN150@PushMissio:
	sbb	eax, eax
	sbb	eax, -1
$LN152@PushMissio:
	test	eax, eax
	jne	SHORT $LN21@PushMissio

; 130  : 						{
; 131  : 							removeMission.iData1 = 15; // todo: future proof this
; 132  : 							removeMission.iData2 = iData2;
; 133  : 							removeMission.iFlags = iFlags;
; 134  : 							removeMission.iPushTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	lea	esi, DWORD PTR [eax+15]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 135  : 							hUnit->SetMissionAI(eMissionAI, pMissionAIPlot, pMissionAIUnit);

	mov	ecx, DWORD PTR _pMissionAIPlot$[esp+76]
	mov	edx, DWORD PTR _eMissionAI$[esp+76]
	mov	edi, eax
	mov	eax, DWORD PTR _pMissionAIUnit$[esp+76]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+84]
	push	edx
	call	?SetMissionAI@CvUnit@@QAEXW4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::SetMissionAI

; 136  : 							InsertAtEndMissionQueue(hUnit, removeMission, !bAppend);

	mov	edx, DWORD PTR _eMission$[esp+76]
	test	bl, bl
	sete	al
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _iData2$[esp+80]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR _iFlags$[esp+100]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	sub	esp, 8
	mov	DWORD PTR [eax+16], edi
	lea	eax, DWORD PTR _hUnit$[esp+108]
	mov	ecx, esp
	mov	DWORD PTR $T226694[esp+112], esp
	push	eax

; 137  : 							bAppend = true;

	jmp	$LN174@PushMissio
$LN21@PushMissio:

; 138  : 						}
; 139  : 						else if(iData1 != 14 && strcmp(feature->GetType(), "FEATURE_JUNGLE") == 0)

	cmp	ebp, 14					; 0000000eH
	je	SHORT $LN19@PushMissio
	lea	ecx, DWORD PTR [edi+176]
	mov	esi, OFFSET $SG218020
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LL153@PushMissio:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN154@PushMissio
	test	cl, cl
	je	SHORT $LN155@PushMissio
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN154@PushMissio
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL153@PushMissio
$LN155@PushMissio:
	xor	eax, eax
	jmp	SHORT $LN156@PushMissio
$LN154@PushMissio:
	sbb	eax, eax
	sbb	eax, -1
$LN156@PushMissio:
	test	eax, eax
	jne	SHORT $LN19@PushMissio

; 140  : 						{
; 141  : 							removeMission.iData1 = 14; // todo: future proof this

	lea	esi, DWORD PTR [eax+14]

; 142  : 							removeMission.iData2 = iData2;
; 143  : 							removeMission.iFlags = iFlags;
; 144  : 							removeMission.iPushTurn = GC.getGame().getGameTurn();
; 145  : 							hUnit->SetMissionAI(eMissionAI, pMissionAIPlot, pMissionAIUnit);
; 146  : 							InsertAtEndMissionQueue(hUnit, removeMission, !bAppend);
; 147  : 							bAppend = true;

	jmp	$LN176@PushMissio
$LN19@PushMissio:

; 148  : 						}
; 149  : 						else if(iData1 != 16 && strcmp(feature->GetType(), "FEATURE_MARSH") == 0)

	cmp	ebp, 16					; 00000010H
	je	$LN17@PushMissio
	lea	ecx, DWORD PTR [edi+176]
	mov	esi, OFFSET $SG218024
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
$LL157@PushMissio:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN158@PushMissio
	test	cl, cl
	je	SHORT $LN159@PushMissio
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN158@PushMissio
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL157@PushMissio
$LN159@PushMissio:
	xor	eax, eax
	jmp	SHORT $LN160@PushMissio
$LN158@PushMissio:
	sbb	eax, eax
	sbb	eax, -1
$LN160@PushMissio:
	test	eax, eax
	jne	SHORT $LN17@PushMissio

; 150  : 						{
; 151  : 							removeMission.iData1 = 16; // todo: future proof this
; 152  : 							removeMission.iData2 = iData2;
; 153  : 							removeMission.iFlags = iFlags;
; 154  : 							removeMission.iPushTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	lea	esi, DWORD PTR [eax+16]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 155  : 							hUnit->SetMissionAI(eMissionAI, pMissionAIPlot, pMissionAIUnit);

	mov	ecx, DWORD PTR _pMissionAIPlot$[esp+76]
	mov	edx, DWORD PTR _eMissionAI$[esp+76]
	mov	edi, eax
	mov	eax, DWORD PTR _pMissionAIUnit$[esp+76]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+84]
	push	edx
	call	?SetMissionAI@CvUnit@@QAEXW4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::SetMissionAI

; 156  : 							InsertAtEndMissionQueue(hUnit, removeMission, !bAppend);

	mov	edx, DWORD PTR _eMission$[esp+76]
	test	bl, bl
	sete	al
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _iData2$[esp+80]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR _iFlags$[esp+100]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	sub	esp, 8
	mov	DWORD PTR [eax+16], edi
	lea	eax, DWORD PTR _hUnit$[esp+108]
	mov	ecx, esp
	mov	DWORD PTR $T226696[esp+112], esp
	push	eax

; 157  : 							bAppend = true;

	jmp	$LN174@PushMissio
$LN17@PushMissio:

; 158  : 						}
; 159  : 						else if(iData1 != 17 && strcmp(feature->GetType(), "FEATURE_FALLOUT") == 0)

	cmp	ebp, 17					; 00000011H
	je	$LN15@PushMissio
	lea	ecx, DWORD PTR [edi+176]
	mov	esi, OFFSET $SG218028
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	npad	7
$LL161@PushMissio:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN162@PushMissio
	test	cl, cl
	je	SHORT $LN163@PushMissio
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN162@PushMissio
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL161@PushMissio
$LN163@PushMissio:
	xor	eax, eax
	jmp	SHORT $LN164@PushMissio
$LN162@PushMissio:
	sbb	eax, eax
	sbb	eax, -1
$LN164@PushMissio:
	test	eax, eax
	jne	SHORT $LN15@PushMissio

; 160  : 						{
; 161  : 							removeMission.iData1 = 17; // todo: future proof this

	lea	esi, DWORD PTR [eax+17]
$LN176@PushMissio:

; 162  : 							removeMission.iData2 = iData2;
; 163  : 							removeMission.iFlags = iFlags;
; 164  : 							removeMission.iPushTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 165  : 							hUnit->SetMissionAI(eMissionAI, pMissionAIPlot, pMissionAIUnit);

	mov	ecx, DWORD PTR _pMissionAIUnit$[esp+76]
	mov	edx, DWORD PTR _pMissionAIPlot$[esp+76]
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+80]
	mov	edi, eax
	mov	eax, DWORD PTR _eMissionAI$[esp+80]
	push	edx
	push	eax
	call	?SetMissionAI@CvUnit@@QAEXW4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::SetMissionAI

; 166  : 							InsertAtEndMissionQueue(hUnit, removeMission, !bAppend);

	test	bl, bl
	sete	cl
	movzx	edx, cl
	mov	ecx, DWORD PTR _eMission$[esp+76]
	push	edx
	mov	edx, DWORD PTR _iData2$[esp+80]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _iFlags$[esp+100]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], edx
	sub	esp, 8
	mov	DWORD PTR [eax+12], ecx
	lea	edx, DWORD PTR _hUnit$[esp+108]
	mov	ecx, esp
	mov	DWORD PTR $T226697[esp+112], esp
	push	edx
	mov	DWORD PTR [eax+16], edi
$LN174@PushMissio:
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?InsertAtEndMissionQueue@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@UMissionData@@_N@Z ; CvUnitMission::InsertAtEndMissionQueue

; 167  : 							bAppend = true;

	mov	bl, 1
	add	esp, 32					; 00000020H
$LN15@PushMissio:

; 168  : 						}
; 169  : 					}
; 170  : 				}
; 171  : 
; 172  : 
; 173  : 				ImprovementTypes eImprovement = NO_IMPROVEMENT;
; 174  : 				RouteTypes eRoute = NO_ROUTE;
; 175  : 
; 176  : 				if(pkBuildInfo->getImprovement() != NO_IMPROVEMENT)

	mov	esi, DWORD PTR _pkBuildInfo$218007[esp+76]
	or	ebp, -1
	mov	ecx, esi
	or	edi, ebp
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement

; 177  : 				{
; 178  : 					eImprovement = (ImprovementTypes) pkBuildInfo->getImprovement();

	mov	ecx, esi
	cmp	eax, ebp
	je	SHORT $LN14@PushMissio
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	ebp, eax

; 179  : 				}
; 180  : 				else

	jmp	SHORT $LN13@PushMissio
$LN14@PushMissio:

; 181  : 				{
; 182  : 					eRoute = (RouteTypes) pkBuildInfo->getRoute();

	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	mov	edi, eax
$LN13@PushMissio:

; 183  : 				}
; 184  : 
; 185  : 				int iNumResource = 0;
; 186  : 
; 187  : 				// Update the amount of a Resource used up by popped Build
; 188  : #ifdef AUI_WARNING_FIXES
; 189  : 				for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 190  : #else
; 191  : 				for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	SHORT $LN167@PushMissio
	npad	1
$LL12@PushMissio:

; 192  : #endif
; 193  : 				{
; 194  : 					iNumResource = 0;
; 195  : 
; 196  : 					if(eImprovement != NO_IMPROVEMENT)

	cmp	ebp, -1
	je	SHORT $LN9@PushMissio

; 197  : 					{
; 198  : 						CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 199  : 						CvAssert(pkImprovementInfo);
; 200  : 						if(pkImprovementInfo)

	test	eax, eax
	je	SHORT $LN11@PushMissio

; 201  : 						{
; 202  : 							iNumResource += pkImprovementInfo->GetResourceQuantityRequirement(iResourceLoop);

	push	esi
	mov	ecx, eax
	call	?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetResourceQuantityRequirement

; 203  : 						}
; 204  : 					}

	jmp	SHORT $LN5@PushMissio
$LN9@PushMissio:

; 205  : 					else if(eRoute != NO_ROUTE)

	cmp	edi, -1
	je	SHORT $LN11@PushMissio

; 206  : 					{
; 207  : 						CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo

; 208  : 						CvAssert(pkRouteInfo);
; 209  : 						if(pkRouteInfo)

	test	eax, eax
	je	SHORT $LN11@PushMissio

; 210  : 						{
; 211  : 							iNumResource += pkRouteInfo->getResourceQuantityRequirement(iResourceLoop);

	push	esi
	mov	ecx, eax
	call	?getResourceQuantityRequirement@CvRouteInfo@@QBEHH@Z ; CvRouteInfo::getResourceQuantityRequirement
$LN5@PushMissio:

; 212  : 						}
; 213  : 					}
; 214  : 
; 215  : 					if(iNumResource > 0)

	test	eax, eax
	jle	SHORT $LN11@PushMissio

; 216  : 					{
; 217  : 						GET_PLAYER(hUnit->getOwner()).changeNumResourceUsed((ResourceTypes) iResourceLoop, iNumResource);

	mov	ecx, DWORD PTR _hUnit$[esp+76]
	mov	ecx, DWORD PTR [ecx+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	push	esi
	call	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeNumResourceUsed
$LN11@PushMissio:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jl	SHORT $LL12@PushMissio
$LN167@PushMissio:

; 183  : 				}
; 184  : 
; 185  : 				int iNumResource = 0;
; 186  : 
; 187  : 				// Update the amount of a Resource used up by popped Build
; 188  : #ifdef AUI_WARNING_FIXES
; 189  : 				for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 190  : #else
; 191  : 				for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	ebp, DWORD PTR _iData1$[esp+76]
$LN10@PushMissio:

; 218  : 					}
; 219  : 				}
; 220  : 			}
; 221  : 		}
; 222  : 	}
; 223  : 
; 224  : 	mission.eMissionType = eMission;
; 225  : 	mission.iData1 = iData1;
; 226  : 	mission.iData2 = iData2;
; 227  : 	mission.iFlags = iFlags;
; 228  : 	mission.iPushTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 229  : 
; 230  : 	hUnit->SetMissionAI(eMissionAI, pMissionAIPlot, pMissionAIUnit);

	mov	edx, DWORD PTR _pMissionAIUnit$[esp+76]
	mov	ecx, DWORD PTR _eMissionAI$[esp+76]
	mov	esi, eax
	mov	eax, DWORD PTR _pMissionAIPlot$[esp+76]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _hUnit$[esp+88]
	call	?SetMissionAI@CvUnit@@QAEXW4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::SetMissionAI

; 231  : 
; 232  : 	InsertAtEndMissionQueue(hUnit, mission, !bAppend);

	mov	edi, DWORD PTR _eMission$[esp+76]
	mov	ecx, DWORD PTR _iData2$[esp+76]
	test	bl, bl
	sete	dl
	movzx	eax, dl
	mov	edx, DWORD PTR _iFlags$[esp+76]
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _hUnit$[esp+100]
	mov	DWORD PTR [eax+12], edx
	sub	esp, 8
	mov	DWORD PTR [eax+16], esi
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _hUnit$[esp+112]
	mov	BYTE PTR [eax+4], dl
	mov	eax, ecx
	mov	DWORD PTR $T226698[esp+108], esp
	test	eax, eax
	je	SHORT $LN122@PushMissio
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN122@PushMissio:
	call	?InsertAtEndMissionQueue@CvUnitMission@@CAXV?$FObjectHandle@VCvUnit@@@@UMissionData@@_N@Z ; CvUnitMission::InsertAtEndMissionQueue
	add	esp, 32					; 00000020H

; 233  : 
; 234  : 	if(bManual)

	cmp	BYTE PTR _bManual$[esp+76], 0
	je	SHORT $LN3@PushMissio

; 235  : 	{
; 236  : 		if(hUnit->getOwner() == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR _hUnit$[esp+76]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [eax+40]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	jne	SHORT $LN2@PushMissio

; 237  : 		{
; 238  : 			CvMissionInfo* pMissionInfo = GC.getMissionInfo(eMission);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMissionInfo@CvGlobals@@QAEPAVCvMissionInfo@@W4MissionTypes@@@Z ; CvGlobals::getMissionInfo

; 239  : 
; 240  : 			if(hUnit->IsBusy() && pMissionInfo != NULL && pMissionInfo->isSound())

	mov	ecx, DWORD PTR _hUnit$[esp+76]
	mov	esi, eax
	call	?IsBusy@CvUnit@@QBE_NXZ			; CvUnit::IsBusy
	test	al, al
	je	SHORT $LN1@PushMissio
	test	esi, esi
	je	SHORT $LN1@PushMissio
	mov	ecx, esi
	call	?isSound@CvMissionInfo@@QBE_NXZ		; CvMissionInfo::isSound
	test	al, al
	je	SHORT $LN1@PushMissio

; 241  : 			{
; 242  : 				hUnit->PlayActionSound();

	mov	ecx, DWORD PTR _hUnit$[esp+76]
	call	?PlayActionSound@CvUnit@@QAEXXZ		; CvUnit::PlayActionSound
$LN1@PushMissio:

; 243  : 			}
; 244  : 
; 245  : 			GC.GetEngineUserInterface()->setHasMovedUnit(true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+380]
	push	1
	call	eax
$LN2@PushMissio:

; 246  : 		}
; 247  : 
; 248  : 		////gDLL->getEventReporterIFace()->selectionGroupPushMission(this, eMission);
; 249  : 		hUnit.ignoreDestruction(true);
; 250  : 		hUnit->doDelayedDeath();

	mov	ecx, DWORD PTR _hUnit$[esp+76]
	mov	BYTE PTR _hUnit$[esp+80], 1
	call	?doDelayedDeath@CvUnit@@QAE_NXZ		; CvUnit::doDelayedDeath
$LN3@PushMissio:

; 251  : 	}
; 252  : }

	mov	ecx, DWORD PTR _hUnit$[esp+76]
	mov	DWORD PTR __$EHRec$[esp+88], -1
	test	ecx, ecx
	je	SHORT $LN145@PushMissio
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN145@PushMissio:
	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 64					; 00000040H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PushMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@W4MissionTypes@@HHH_N2W4MissionAITypes@@PAVCvPlot@@PAVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _hUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PushMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@W4MissionTypes@@HHH_N2W4MissionAITypes@@PAVCvPlot@@PAVCvUnit@@@Z$1:
	lea	ecx, DWORD PTR $T226693[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?PushMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@W4MissionTypes@@HHH_N2W4MissionAITypes@@PAVCvPlot@@PAVCvUnit@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?PushMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@W4MissionTypes@@HHH_N2W4MissionAITypes@@PAVCvPlot@@PAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PushMission@CvUnitMission@@SAXV?$FObjectHandle@VCvUnit@@@@W4MissionTypes@@HHH_N2W4MissionAITypes@@PAVCvPlot@@PAVCvUnit@@@Z ENDP ; CvUnitMission::PushMission
END
