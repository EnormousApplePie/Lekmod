; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	s:\Github\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\Lua\CvLuaGameInfo.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG217181 DB	'GameInfoActions', 00H
$SG217355 DB	'MissionData', 00H
$SG217357 DB	'CommandData', 00H
$SG217359 DB	'AutomateType', 00H
	ORG $+3
$SG217361 DB	'InterfaceModeType', 00H
	ORG $+2
$SG217363 DB	'MissionType', 00H
$SG217365 DB	'CommandType', 00H
$SG217367 DB	'ControlType', 00H
$SG217369 DB	'OriginalIndex', 00H
	ORG $+2
$SG217374 DB	'ConfirmCommand', 00H
	ORG $+1
$SG217376 DB	'Visible', 00H
$SG217379 DB	'SubType', 00H
$SG217384 DB	'Type', 00H
	ORG $+3
$SG217386 DB	'TextKey', 00H
$SG217388 DB	'ActionInfoIndex', 00H
$SG217390 DB	'HotKeyVal', 00H
	ORG $+2
$SG217392 DB	'HotKeyPriority', 00H
	ORG $+1
$SG217394 DB	'HotKeyValAlt', 00H
	ORG $+3
$SG217396 DB	'HotKeyPriorityAlt', 00H
	ORG $+2
$SG217398 DB	'OrderPriority', 00H
	ORG $+2
$SG217400 DB	'AltDown', 00H
$SG217402 DB	'ShiftDown', 00H
	ORG $+2
$SG217404 DB	'CtrlDown', 00H
	ORG $+3
$SG217406 DB	'AltDownAlt', 00H
	ORG $+1
$SG217408 DB	'ShiftDownAlt', 00H
	ORG $+3
$SG217410 DB	'CtrlDownAlt', 00H
$SG217412 DB	'HotKey', 00H
	ORG $+1
$SG217414 DB	'Help', 00H
	ORG $+3
$SG217416 DB	'DisabledHelp', 00H
	ORG $+3
$SG217422 DB	'GameInfoTypes', 00H
CONST	ENDS
PUBLIC	??1Field@Table@FLua@@QAE@XZ			; FLua::Table::Field::~Field
EXTRN	??1Value@FLua@@QAE@XZ:PROC			; FLua::Value::~Value
; Function compile flags: /Ogtpy
;	COMDAT ??1Field@Table@FLua@@QAE@XZ
_TEXT	SEGMENT
??1Field@Table@FLua@@QAE@XZ PROC			; FLua::Table::Field::~Field, COMDAT
; _this$ = ecx
	add	ecx, 4
	jmp	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value
??1Field@Table@FLua@@QAE@XZ ENDP			; FLua::Table::Field::~Field
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEABQAVCvActionInfo@@XZ ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEABQAVCvActionInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEABQAVCvActionInfo@@XZ PROC ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBEABQAVCvActionInfo@@XZ ENDP ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator++
_TEXT	ENDS
PUBLIC	?_Nextnode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Nextnode
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ?_Nextnode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Nextnode, COMDAT

; 115  : 		return ((_Nodepref)(*_Pnode)._Next);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 116  : 		}

	ret	0
?_Nextnode@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAPAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@PAU342@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Myval@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Myval, COMDAT

; 125  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 126  : 		}

	ret	0
?_Myval@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@KAAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Myval
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator==
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator==
_TEXT	ENDS
PUBLIC	??8?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator==
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ??8?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator==, COMDAT
; _this$ = ecx

; 291  : 
; 292  :  #if _HAS_ITERATOR_DEBUGGING
; 293  : 			_Compat(_Right);
; 294  :  #else
; 295  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 296  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 297  : 
; 298  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 299  : 			}

	ret	4
??8?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z PROC ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z ENDP ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >
_TEXT	ENDS
PUBLIC	??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::_Const_iterator<0>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::_Const_iterator<0>, COMDAT
; _this$ = ecx

; 184  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 185  : 			}

	ret	4
??0?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@2@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::_Const_iterator<0>
_TEXT	ENDS
PUBLIC	??$Convert@PBD@?$ToLuaAnalog@PBD@Details@FLua@@SAAAPBDAAPBD@Z ; FLua::Details::ToLuaAnalog<char const *>::Convert<char const *>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\flua\include\fluacommon.h
;	COMDAT ??$Convert@PBD@?$ToLuaAnalog@PBD@Details@FLua@@SAAAPBDAAPBD@Z
_TEXT	SEGMENT
_arg$ = 8						; size = 4
??$Convert@PBD@?$ToLuaAnalog@PBD@Details@FLua@@SAAAPBDAAPBD@Z PROC ; FLua::Details::ToLuaAnalog<char const *>::Convert<char const *>, COMDAT

; 633  : 			template<class T> static inline T &Convert(T&arg) { return arg; }

	mov	eax, DWORD PTR _arg$[esp-4]
	ret	0
??$Convert@PBD@?$ToLuaAnalog@PBD@Details@FLua@@SAAAPBDAAPBD@Z ENDP ; FLua::Details::ToLuaAnalog<char const *>::Convert<char const *>
_TEXT	ENDS
PUBLIC	??$Convert@H@?$ToLuaAnalog@H@Details@FLua@@SAAAHAAH@Z ; FLua::Details::ToLuaAnalog<int>::Convert<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$Convert@H@?$ToLuaAnalog@H@Details@FLua@@SAAAHAAH@Z
_TEXT	SEGMENT
_arg$ = 8						; size = 4
??$Convert@H@?$ToLuaAnalog@H@Details@FLua@@SAAAHAAH@Z PROC ; FLua::Details::ToLuaAnalog<int>::Convert<int>, COMDAT

; 615  : 			template<class T> static inline T &Convert(T&arg) { return arg; }

	mov	eax, DWORD PTR _arg$[esp-4]
	ret	0
??$Convert@H@?$ToLuaAnalog@H@Details@FLua@@SAAAHAAH@Z ENDP ; FLua::Details::ToLuaAnalog<int>::Convert<int>
_TEXT	ENDS
PUBLIC	??$Convert@_N@?$ToLuaAnalog@_N@Details@FLua@@SAAA_NAA_N@Z ; FLua::Details::ToLuaAnalog<bool>::Convert<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$Convert@_N@?$ToLuaAnalog@_N@Details@FLua@@SAAA_NAA_N@Z
_TEXT	SEGMENT
_arg$ = 8						; size = 4
??$Convert@_N@?$ToLuaAnalog@_N@Details@FLua@@SAAA_NAA_N@Z PROC ; FLua::Details::ToLuaAnalog<bool>::Convert<bool>, COMDAT

; 615  : 			template<class T> static inline T &Convert(T&arg) { return arg; }

	mov	eax, DWORD PTR _arg$[esp-4]
	ret	0
??$Convert@_N@?$ToLuaAnalog@_N@Details@FLua@@SAAA_NAA_N@Z ENDP ; FLua::Details::ToLuaAnalog<bool>::Convert<bool>
_TEXT	ENDS
EXTRN	_lua_pushboolean:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Push@Details@FLua@@YAXPAUlua_State@@_N@Z
_TEXT	SEGMENT
?Push@Details@FLua@@YAXPAUlua_State@@_N@Z PROC		; FLua::Details::Push, COMDAT
; _L$ = ecx
; _bVal$ = eax

; 507  : 		static inline void Push(lua_State *L, const bool bVal) { lua_pushboolean(L, bVal); }

	movzx	eax, al
	push	eax
	push	ecx
	call	_lua_pushboolean
	add	esp, 8
	ret	0
?Push@Details@FLua@@YAXPAUlua_State@@_N@Z ENDP		; FLua::Details::Push
_TEXT	ENDS
EXTRN	_lua_pushinteger:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Push@Details@FLua@@YAXPAUlua_State@@H@Z
_TEXT	SEGMENT
?Push@Details@FLua@@YAXPAUlua_State@@H@Z PROC		; FLua::Details::Push, COMDAT
; _L$ = ecx
; _iVal$ = eax

; 509  : 		static inline void Push(lua_State *L, const lua_Integer iVal) { lua_pushinteger(L, iVal); }

	push	eax
	push	ecx
	call	_lua_pushinteger
	add	esp, 8
	ret	0
?Push@Details@FLua@@YAXPAUlua_State@@H@Z ENDP		; FLua::Details::Push
_TEXT	ENDS
EXTRN	_lua_pushstring:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Push@Details@FLua@@YAXPAUlua_State@@PBD@Z
_TEXT	SEGMENT
?Push@Details@FLua@@YAXPAUlua_State@@PBD@Z PROC		; FLua::Details::Push, COMDAT
; _L$ = ecx
; _szVal$ = eax

; 512  : 		static inline void Push(lua_State *L, _In_z_ const char *szVal) { lua_pushstring(L, szVal); }

	push	eax
	push	ecx
	call	_lua_pushstring
	add	esp, 8
	ret	0
?Push@Details@FLua@@YAXPAUlua_State@@PBD@Z ENDP		; FLua::Details::Push
_TEXT	ENDS
PUBLIC	?GetLuaState@Value@FLua@@QBEPAUlua_State@@XZ	; FLua::Value::GetLuaState
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\flua\include\fluatypes.h
;	COMDAT ?GetLuaState@Value@FLua@@QBEPAUlua_State@@XZ
_TEXT	SEGMENT
?GetLuaState@Value@FLua@@QBEPAUlua_State@@XZ PROC	; FLua::Value::GetLuaState, COMDAT
; _this$ = ecx

; 143  : 		inline lua_State *GetLuaState() const { return m_pkLuaState; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetLuaState@Value@FLua@@QBEPAUlua_State@@XZ ENDP	; FLua::Value::GetLuaState
_TEXT	ENDS
PUBLIC	??0Table@FLua@@QAE@PAUlua_State@@H@Z		; FLua::Table::Table
EXTRN	??0Value@FLua@@QAE@PAUlua_State@@H@Z:PROC	; FLua::Value::Value
; Function compile flags: /Ogtpy
;	COMDAT ??0Table@FLua@@QAE@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_iStackIndex$ = 12					; size = 4
??0Table@FLua@@QAE@PAUlua_State@@H@Z PROC		; FLua::Table::Table, COMDAT
; _this$ = ecx

; 215  : 		Table(lua_State *L, int iStackIndex) : m_kLuaVal(L, iStackIndex) {}

	mov	eax, DWORD PTR _iStackIndex$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _L$[esp]
	push	eax
	push	ecx
	mov	ecx, esi
	call	??0Value@FLua@@QAE@PAUlua_State@@H@Z	; FLua::Value::Value
	mov	eax, esi
	pop	esi
	ret	8
??0Table@FLua@@QAE@PAUlua_State@@H@Z ENDP		; FLua::Table::Table
_TEXT	ENDS
PUBLIC	??1Table@FLua@@QAE@XZ				; FLua::Table::~Table
; Function compile flags: /Ogtpy
;	COMDAT ??1Table@FLua@@QAE@XZ
_TEXT	SEGMENT
??1Table@FLua@@QAE@XZ PROC				; FLua::Table::~Table, COMDAT
; _this$ = ecx

; 218  : 		~Table() {}

	jmp	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value
??1Table@FLua@@QAE@XZ ENDP				; FLua::Table::~Table
_TEXT	ENDS
PUBLIC	?GetLuaState@Table@FLua@@QBEPAUlua_State@@XZ	; FLua::Table::GetLuaState
; Function compile flags: /Ogtpy
;	COMDAT ?GetLuaState@Table@FLua@@QBEPAUlua_State@@XZ
_TEXT	SEGMENT
?GetLuaState@Table@FLua@@QBEPAUlua_State@@XZ PROC	; FLua::Table::GetLuaState, COMDAT
; _this$ = ecx

; 256  : 		inline lua_State *GetLuaState() const { return m_kLuaVal.GetLuaState(); }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetLuaState@Table@FLua@@QBEPAUlua_State@@XZ ENDP	; FLua::Table::GetLuaState
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator!=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ??D?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ
_TEXT	SEGMENT
??D?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator*, COMDAT
; _this$ = ecx

; 212  : 
; 213  :  #if _HAS_ITERATOR_DEBUGGING
; 214  : 			if (this->_Mycont == 0
; 215  : 				|| _Ptr == 0
; 216  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 217  : 				{
; 218  : 				_DEBUG_ERROR("list iterator not dereferencable");
; 219  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 220  : 				}
; 221  :  #else
; 222  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());
; 223  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 224  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 225  : 
; 226  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 227  : 			}

	ret	0
??D?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@2@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator++, COMDAT
; _this$ = ecx

; 235  : 			{	// preincrement

	mov	eax, ecx

; 236  : 
; 237  :  #if _HAS_ITERATOR_DEBUGGING
; 238  : 			if (this->_Mycont == 0
; 239  : 				|| _Ptr == 0
; 240  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 241  : 				{
; 242  : 				_DEBUG_ERROR("list iterator not incrementable");
; 243  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 244  : 				}
; 245  :  #else
; 246  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());
; 247  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 248  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 249  : 
; 250  : 			_Ptr = _Nextnode(_Ptr);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 251  : 			return (*this);
; 252  : 			}

	ret	0
??E?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator++
_TEXT	ENDS
PUBLIC	??9?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator!=, COMDAT
; _this$ = ecx

; 303  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 304  : 			}

	ret	4
??9?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE_NABV012@@Z ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::_Const_iterator<0>::operator!=
_TEXT	ENDS
PUBLIC	?begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::begin, COMDAT
; _this$ = ecx

; 565  : 		return (const_iterator(_Nextnode(_Myhead)));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 566  : 		}

	ret	4
?begin@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::begin
_TEXT	ENDS
PUBLIC	?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ PROC ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::end, COMDAT
; _this$ = ecx

; 575  : 		return (const_iterator(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 576  : 		}

	ret	4
?end@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ ENDP ; std::list<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> > >::end
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z ; std::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z PROC ; std::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE@PAPAVCvActionInfo@@@Z ENDP ; std::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >::_Vector_iterator<CvActionInfo *,std::allocator<CvActionInfo *> >
_TEXT	ENDS
PUBLIC	??$?0PBD@Field@Table@FLua@@AAE@ABV12@PBD@Z	; FLua::Table::Field::Field<char const *>
EXTRN	_lua_settop:PROC
EXTRN	?Set@Value@FLua@@QAEXPAUlua_State@@H@Z:PROC	; FLua::Value::Set
EXTRN	_lua_checkstack:PROC
EXTRN	??0Value@FLua@@QAE@XZ:PROC			; FLua::Value::Value
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\flua\include\fluacommon.h
xdata$x	SEGMENT
__unwindtable$??$?0PBD@Field@Table@FLua@@AAE@ABV12@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0PBD@Field@Table@FLua@@AAE@ABV12@PBD@Z$0
__ehfuncinfo$??$?0PBD@Field@Table@FLua@@AAE@ABV12@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0PBD@Field@Table@FLua@@AAE@ABV12@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\flua\include\fluatypes.h
xdata$x	ENDS
;	COMDAT ??$?0PBD@Field@Table@FLua@@AAE@ABV12@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_kTable$ = 8						; size = 4
_key$ = 12						; size = 4
??$?0PBD@Field@Table@FLua@@AAE@ABV12@PBD@Z PROC		; FLua::Table::Field::Field<char const *>, COMDAT
; _this$ = ecx

; 265  : 			template<class T> Field(const Table &kTable, T key) : m_kTable((Table&)kTable) {

	push	-1
	push	__ehhandler$??$?0PBD@Field@Table@FLua@@AAE@ABV12@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, DWORD PTR _kTable$[esp+20]
	push	edi
	mov	edi, ecx
	lea	ebx, DWORD PTR [edi+4]
	mov	ecx, ebx
	mov	DWORD PTR _this$[esp+28], edi
	mov	DWORD PTR [edi], esi
	call	??0Value@FLua@@QAE@XZ			; FLua::Value::Value

; 266  : 				typedef Details::PushAnalog<T>::Result KeyAnalog;
; 267  : 				lua_State *L = kTable.GetLuaState();

	mov	esi, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[esp+36], 0

; 268  : 				if( L != NULL )

	test	esi, esi
	je	SHORT $LN13@Field

; 269  : 				{
; 270  : 					KeyAnalog keyAnalog = Details::ToLuaAnalog<KeyAnalog>::Convert(key);
; 271  : 					lua_checkstack(L, 1);

	push	1
	push	esi
	call	_lua_checkstack

; 272  : 					Details::Push(L, keyAnalog); // Push the key

	mov	eax, DWORD PTR _key$[esp+32]
	push	eax
	push	esi
	call	_lua_pushstring
	add	esp, 16					; 00000010H

; 273  : 					m_kKey.Set(L, -1);	// Ref the key

	push	-1
	push	esi
	mov	ecx, ebx
	call	?Set@Value@FLua@@QAEXPAUlua_State@@H@Z	; FLua::Value::Set

; 274  : 					lua_pop(L, 1); // Pop the key

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	add	esp, 8
$LN13@Field:

; 275  : 				}
; 276  : 			}

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0PBD@Field@Table@FLua@@AAE@ABV12@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value
__ehhandler$??$?0PBD@Field@Table@FLua@@AAE@ABV12@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?0PBD@Field@Table@FLua@@AAE@ABV12@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0PBD@Field@Table@FLua@@AAE@ABV12@PBD@Z ENDP		; FLua::Table::Field::Field<char const *>
PUBLIC	??_C@_0CK@ILAFJLND@Invalid?5key?5sent?5to?5FLua?3?3Table?3@ ; `string'
PUBLIC	??_C@_0CG@IHIEJLDN@nil?5key?5sent?5to?5FLua?3?3Table?3?3Set@ ; `string'
PUBLIC	??_C@_0ED@FEEIEOLF@Key?5sent?5to?5FLua?3?3Table?3?3SetFiel@ ; `string'
PUBLIC	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z	; FLua::Table::SetField<int>
EXTRN	_lua_rawset:PROC
EXTRN	_lua_type:PROC
EXTRN	?Push@Value@FLua@@QBE_NXZ:PROC			; FLua::Value::Push
EXTRN	?Push@Table@FLua@@QBE_NXZ:PROC			; FLua::Table::Push
EXTRN	?Error@Details@FLua@@YAXPBDZZ:PROC		; FLua::Details::Error
;	COMDAT ??_C@_0CK@ILAFJLND@Invalid?5key?5sent?5to?5FLua?3?3Table?3@
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\flua\include\fluacommon.h
CONST	SEGMENT
??_C@_0CK@ILAFJLND@Invalid?5key?5sent?5to?5FLua?3?3Table?3@ DB 'Invalid k'
	DB	'ey sent to FLua::Table::SetField', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IHIEJLDN@nil?5key?5sent?5to?5FLua?3?3Table?3?3Set@
CONST	SEGMENT
??_C@_0CG@IHIEJLDN@nil?5key?5sent?5to?5FLua?3?3Table?3?3Set@ DB 'nil key '
	DB	'sent to FLua::Table::SetField', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@FEEIEOLF@Key?5sent?5to?5FLua?3?3Table?3?3SetFiel@
CONST	SEGMENT
??_C@_0ED@FEEIEOLF@Key?5sent?5to?5FLua?3?3Table?3?3SetFiel@ DB 'Key sent '
	DB	'to FLua::Table::SetField belongs to a different lua state', 00H ; `string'
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\flua\include\fluatypes.h
CONST	ENDS
;	COMDAT ??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z
_TEXT	SEGMENT
_kKey$ = 8						; size = 4
_val$ = 12						; size = 4
??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z PROC	; FLua::Table::SetField<int>, COMDAT
; _this$ = ecx

; 336  : 		void SetField(const Value &kKey, T val) {

	push	esi

; 337  : 			lua_State *L = m_kLuaVal.GetLuaState();

	mov	esi, DWORD PTR [ecx]
	push	edi

; 338  : 			if( L != kKey.GetLuaState() ) {

	mov	edi, DWORD PTR _kKey$[esp+4]
	cmp	esi, DWORD PTR [edi]
	je	SHORT $LN7@SetField

; 339  : 				Details::Error("Key sent to FLua::Table::SetField belongs to a different lua state");

	push	OFFSET ??_C@_0ED@FEEIEOLF@Key?5sent?5to?5FLua?3?3Table?3?3SetFiel@
	call	?Error@Details@FLua@@YAXPBDZZ		; FLua::Details::Error
	add	esp, 4
	pop	edi
	pop	esi

; 359  : 			}
; 360  : 		}

	ret	8
$LN7@SetField:

; 340  : 			}
; 341  : 			else if( Push() ) {

	call	?Push@Table@FLua@@QBE_NXZ		; FLua::Table::Push
	test	al, al
	je	$LN5@SetField

; 342  : 				if( kKey.Push() ) {

	mov	ecx, edi
	call	?Push@Value@FLua@@QBE_NXZ		; FLua::Value::Push
	test	al, al
	je	SHORT $LN4@SetField

; 343  : 					if( lua_isnil(L, -1) )

	push	-1
	push	esi
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@SetField

; 344  : 					{
; 345  : 						lua_pop(L, 1); // Pop the nil key

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 346  : 						Details::Error("nil key sent to FLua::Table::SetField");

	push	OFFSET ??_C@_0CG@IHIEJLDN@nil?5key?5sent?5to?5FLua?3?3Table?3?3Set@
	call	?Error@Details@FLua@@YAXPBDZZ		; FLua::Details::Error
	add	esp, 12					; 0000000cH

; 358  : 				lua_pop(L, 1); // Pop the table

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	add	esp, 8
	pop	edi
	pop	esi

; 359  : 			}
; 360  : 		}

	ret	8
$LN3@SetField:

; 347  : 					}
; 348  : 					else
; 349  : 					{
; 350  : 						typedef Details::PushAnalog<T>::Result Analog;
; 351  : 						Analog analog = Details::ToLuaAnalog<Analog>::Convert(val);
; 352  : 						lua_checkstack(L, 1);

	push	1
	push	esi
	call	_lua_checkstack

; 353  : 						Details::Push(L, analog); // Push the value

	mov	eax, DWORD PTR _val$[esp+12]
	push	eax
	push	esi
	call	_lua_pushinteger

; 354  : 						lua_rawset(L, -3); // Set the field (pops key and value)

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset
	add	esp, 24					; 00000018H

; 358  : 				lua_pop(L, 1); // Pop the table

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	add	esp, 8
	pop	edi
	pop	esi

; 359  : 			}
; 360  : 		}

	ret	8
$LN4@SetField:

; 355  : 					}
; 356  : 				}
; 357  : 				else Details::Error("Invalid key sent to FLua::Table::SetField");

	push	OFFSET ??_C@_0CK@ILAFJLND@Invalid?5key?5sent?5to?5FLua?3?3Table?3@
	call	?Error@Details@FLua@@YAXPBDZZ		; FLua::Details::Error
	add	esp, 4

; 358  : 				lua_pop(L, 1); // Pop the table

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	add	esp, 8
$LN5@SetField:
	pop	edi
	pop	esi

; 359  : 			}
; 360  : 		}

	ret	8
??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ENDP	; FLua::Table::SetField<int>
_TEXT	ENDS
PUBLIC	??$SetField@_N@Table@FLua@@QAEXABVValue@1@_N@Z	; FLua::Table::SetField<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$SetField@_N@Table@FLua@@QAEXABVValue@1@_N@Z
_TEXT	SEGMENT
_kKey$ = 8						; size = 4
_val$ = 12						; size = 1
??$SetField@_N@Table@FLua@@QAEXABVValue@1@_N@Z PROC	; FLua::Table::SetField<bool>, COMDAT
; _this$ = ecx

; 336  : 		void SetField(const Value &kKey, T val) {

	push	esi

; 337  : 			lua_State *L = m_kLuaVal.GetLuaState();

	mov	esi, DWORD PTR [ecx]
	push	edi

; 338  : 			if( L != kKey.GetLuaState() ) {

	mov	edi, DWORD PTR _kKey$[esp+4]
	cmp	esi, DWORD PTR [edi]
	je	SHORT $LN7@SetField@2

; 339  : 				Details::Error("Key sent to FLua::Table::SetField belongs to a different lua state");

	push	OFFSET ??_C@_0ED@FEEIEOLF@Key?5sent?5to?5FLua?3?3Table?3?3SetFiel@
	call	?Error@Details@FLua@@YAXPBDZZ		; FLua::Details::Error
	add	esp, 4
	pop	edi
	pop	esi

; 359  : 			}
; 360  : 		}

	ret	8
$LN7@SetField@2:

; 340  : 			}
; 341  : 			else if( Push() ) {

	call	?Push@Table@FLua@@QBE_NXZ		; FLua::Table::Push
	test	al, al
	je	$LN5@SetField@2

; 342  : 				if( kKey.Push() ) {

	mov	ecx, edi
	call	?Push@Value@FLua@@QBE_NXZ		; FLua::Value::Push
	test	al, al
	je	SHORT $LN4@SetField@2

; 343  : 					if( lua_isnil(L, -1) )

	push	-1
	push	esi
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@SetField@2

; 344  : 					{
; 345  : 						lua_pop(L, 1); // Pop the nil key

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 346  : 						Details::Error("nil key sent to FLua::Table::SetField");

	push	OFFSET ??_C@_0CG@IHIEJLDN@nil?5key?5sent?5to?5FLua?3?3Table?3?3Set@
	call	?Error@Details@FLua@@YAXPBDZZ		; FLua::Details::Error
	add	esp, 12					; 0000000cH

; 358  : 				lua_pop(L, 1); // Pop the table

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	add	esp, 8
	pop	edi
	pop	esi

; 359  : 			}
; 360  : 		}

	ret	8
$LN3@SetField@2:

; 347  : 					}
; 348  : 					else
; 349  : 					{
; 350  : 						typedef Details::PushAnalog<T>::Result Analog;
; 351  : 						Analog analog = Details::ToLuaAnalog<Analog>::Convert(val);
; 352  : 						lua_checkstack(L, 1);

	push	1
	push	esi
	call	_lua_checkstack

; 353  : 						Details::Push(L, analog); // Push the value

	movzx	eax, BYTE PTR _val$[esp+12]
	push	eax
	push	esi
	call	_lua_pushboolean

; 354  : 						lua_rawset(L, -3); // Set the field (pops key and value)

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset
	add	esp, 24					; 00000018H

; 358  : 				lua_pop(L, 1); // Pop the table

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	add	esp, 8
	pop	edi
	pop	esi

; 359  : 			}
; 360  : 		}

	ret	8
$LN4@SetField@2:

; 355  : 					}
; 356  : 				}
; 357  : 				else Details::Error("Invalid key sent to FLua::Table::SetField");

	push	OFFSET ??_C@_0CK@ILAFJLND@Invalid?5key?5sent?5to?5FLua?3?3Table?3@
	call	?Error@Details@FLua@@YAXPBDZZ		; FLua::Details::Error
	add	esp, 4

; 358  : 				lua_pop(L, 1); // Pop the table

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	add	esp, 8
$LN5@SetField@2:
	pop	edi
	pop	esi

; 359  : 			}
; 360  : 		}

	ret	8
??$SetField@_N@Table@FLua@@QAEXABVValue@1@_N@Z ENDP	; FLua::Table::SetField<bool>
_TEXT	ENDS
PUBLIC	??$SetField@PBD@Table@FLua@@QAEXABVValue@1@PBD@Z ; FLua::Table::SetField<char const *>
; Function compile flags: /Ogtpy
;	COMDAT ??$SetField@PBD@Table@FLua@@QAEXABVValue@1@PBD@Z
_TEXT	SEGMENT
_kKey$ = 8						; size = 4
_val$ = 12						; size = 4
??$SetField@PBD@Table@FLua@@QAEXABVValue@1@PBD@Z PROC	; FLua::Table::SetField<char const *>, COMDAT
; _this$ = ecx

; 336  : 		void SetField(const Value &kKey, T val) {

	push	esi

; 337  : 			lua_State *L = m_kLuaVal.GetLuaState();

	mov	esi, DWORD PTR [ecx]
	push	edi

; 338  : 			if( L != kKey.GetLuaState() ) {

	mov	edi, DWORD PTR _kKey$[esp+4]
	cmp	esi, DWORD PTR [edi]
	je	SHORT $LN7@SetField@3

; 339  : 				Details::Error("Key sent to FLua::Table::SetField belongs to a different lua state");

	push	OFFSET ??_C@_0ED@FEEIEOLF@Key?5sent?5to?5FLua?3?3Table?3?3SetFiel@
	call	?Error@Details@FLua@@YAXPBDZZ		; FLua::Details::Error
	add	esp, 4
	pop	edi
	pop	esi

; 359  : 			}
; 360  : 		}

	ret	8
$LN7@SetField@3:

; 340  : 			}
; 341  : 			else if( Push() ) {

	call	?Push@Table@FLua@@QBE_NXZ		; FLua::Table::Push
	test	al, al
	je	$LN5@SetField@3

; 342  : 				if( kKey.Push() ) {

	mov	ecx, edi
	call	?Push@Value@FLua@@QBE_NXZ		; FLua::Value::Push
	test	al, al
	je	SHORT $LN4@SetField@3

; 343  : 					if( lua_isnil(L, -1) )

	push	-1
	push	esi
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@SetField@3

; 344  : 					{
; 345  : 						lua_pop(L, 1); // Pop the nil key

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 346  : 						Details::Error("nil key sent to FLua::Table::SetField");

	push	OFFSET ??_C@_0CG@IHIEJLDN@nil?5key?5sent?5to?5FLua?3?3Table?3?3Set@
	call	?Error@Details@FLua@@YAXPBDZZ		; FLua::Details::Error
	add	esp, 12					; 0000000cH

; 358  : 				lua_pop(L, 1); // Pop the table

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	add	esp, 8
	pop	edi
	pop	esi

; 359  : 			}
; 360  : 		}

	ret	8
$LN3@SetField@3:

; 347  : 					}
; 348  : 					else
; 349  : 					{
; 350  : 						typedef Details::PushAnalog<T>::Result Analog;
; 351  : 						Analog analog = Details::ToLuaAnalog<Analog>::Convert(val);
; 352  : 						lua_checkstack(L, 1);

	push	1
	push	esi
	call	_lua_checkstack

; 353  : 						Details::Push(L, analog); // Push the value

	mov	eax, DWORD PTR _val$[esp+12]
	push	eax
	push	esi
	call	_lua_pushstring

; 354  : 						lua_rawset(L, -3); // Set the field (pops key and value)

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset
	add	esp, 24					; 00000018H

; 358  : 				lua_pop(L, 1); // Pop the table

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	add	esp, 8
	pop	edi
	pop	esi

; 359  : 			}
; 360  : 		}

	ret	8
$LN4@SetField@3:

; 355  : 					}
; 356  : 				}
; 357  : 				else Details::Error("Invalid key sent to FLua::Table::SetField");

	push	OFFSET ??_C@_0CK@ILAFJLND@Invalid?5key?5sent?5to?5FLua?3?3Table?3@
	call	?Error@Details@FLua@@YAXPBDZZ		; FLua::Details::Error
	add	esp, 4

; 358  : 				lua_pop(L, 1); // Pop the table

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	add	esp, 8
$LN5@SetField@3:
	pop	edi
	pop	esi

; 359  : 			}
; 360  : 		}

	ret	8
??$SetField@PBD@Table@FLua@@QAEXABVValue@1@PBD@Z ENDP	; FLua::Table::SetField<char const *>
_TEXT	ENDS
PUBLIC	?begin@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::begin
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xhash
;	COMDAT ?begin@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 382  : 		return (_List.begin());

	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 383  : 		}

	ret	4
?begin@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ PROC ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 392  : 		return (_List.end());

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 393  : 		}

	ret	4
?end@?$_Hash@V?$_Hmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@$0A@@stdext@@@stdext@@QBE?AV?$_Const_iterator@$0A@@?$list@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@std@@XZ ENDP ; stdext::_Hash<stdext::_Hmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,stdext::hash_compare<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int> >,0> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::begin
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ PROC ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@2@XZ ENDP ; std::vector<CvActionInfo *,std::allocator<CvActionInfo *> >::end
_TEXT	ENDS
PUBLIC	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z	; FLua::Table::operator[]<char const *>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\flua\include\fluatypes.h
;	COMDAT ??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z
_TEXT	SEGMENT
$T218067 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_key$ = 12						; size = 4
??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z PROC		; FLua::Table::operator[]<char const *>, COMDAT
; _this$ = ecx

; 299  : 		template<class T> inline Field operator [](T key) { return Field(*this, key); }

	push	ecx
	mov	eax, DWORD PTR _key$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	eax
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR $T218067[esp+16], 0
	call	??$?0PBD@Field@Table@FLua@@AAE@ABV12@PBD@Z ; FLua::Table::Field::Field<char const *>
	mov	eax, esi
	pop	esi
	pop	ecx
	ret	8
??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ENDP		; FLua::Table::operator[]<char const *>
_TEXT	ENDS
PUBLIC	??$?4H@Field@Table@FLua@@QAEABV012@H@Z		; FLua::Table::Field::operator=<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$?4H@Field@Table@FLua@@QAEABV012@H@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
??$?4H@Field@Table@FLua@@QAEABV012@H@Z PROC		; FLua::Table::Field::operator=<int>, COMDAT
; _this$ = ecx

; 288  : 			template<class T> inline const Field &operator =(T val) { m_kTable.SetField<T>(m_kKey, val); return *this; }

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, ecx
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	mov	eax, esi
	pop	esi
	ret	4
??$?4H@Field@Table@FLua@@QAEABV012@H@Z ENDP		; FLua::Table::Field::operator=<int>
_TEXT	ENDS
PUBLIC	??$?4_N@Field@Table@FLua@@QAEABV012@_N@Z	; FLua::Table::Field::operator=<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$?4_N@Field@Table@FLua@@QAEABV012@_N@Z
_TEXT	SEGMENT
_val$ = 8						; size = 1
??$?4_N@Field@Table@FLua@@QAEABV012@_N@Z PROC		; FLua::Table::Field::operator=<bool>, COMDAT
; _this$ = ecx

; 288  : 			template<class T> inline const Field &operator =(T val) { m_kTable.SetField<T>(m_kKey, val); return *this; }

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, ecx
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	??$SetField@_N@Table@FLua@@QAEXABVValue@1@_N@Z ; FLua::Table::SetField<bool>
	mov	eax, esi
	pop	esi
	ret	4
??$?4_N@Field@Table@FLua@@QAEABV012@_N@Z ENDP		; FLua::Table::Field::operator=<bool>
_TEXT	ENDS
PUBLIC	??$?4PBD@Field@Table@FLua@@QAEABV012@PBD@Z	; FLua::Table::Field::operator=<char const *>
; Function compile flags: /Ogtpy
;	COMDAT ??$?4PBD@Field@Table@FLua@@QAEABV012@PBD@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
??$?4PBD@Field@Table@FLua@@QAEABV012@PBD@Z PROC		; FLua::Table::Field::operator=<char const *>, COMDAT
; _this$ = ecx

; 288  : 			template<class T> inline const Field &operator =(T val) { m_kTable.SetField<T>(m_kKey, val); return *this; }

	mov	eax, DWORD PTR _val$[esp-4]
	push	esi
	mov	esi, ecx
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	??$SetField@PBD@Table@FLua@@QAEXABVValue@1@PBD@Z ; FLua::Table::SetField<char const *>
	mov	eax, esi
	pop	esi
	ret	4
??$?4PBD@Field@Table@FLua@@QAEABV012@PBD@Z ENDP		; FLua::Table::Field::operator=<char const *>
_TEXT	ENDS
PUBLIC	?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z ; CvLuaGameInfo::pRegisterActions
EXTRN	_lua_rawseti:PROC
EXTRN	?GetDisabledHelp@CvActionInfo@@QBEPBDXZ:PROC	; CvActionInfo::GetDisabledHelp
EXTRN	?GetHelp@CvActionInfo@@QBEPBDXZ:PROC		; CvActionInfo::GetHelp
EXTRN	?getHotKeyString@CvActionInfo@@QBEPBDXZ:PROC	; CvActionInfo::getHotKeyString
EXTRN	?isCtrlDownAlt@CvActionInfo@@QBE_NXZ:PROC	; CvActionInfo::isCtrlDownAlt
EXTRN	?isShiftDownAlt@CvActionInfo@@QBE_NXZ:PROC	; CvActionInfo::isShiftDownAlt
EXTRN	?isAltDownAlt@CvActionInfo@@QBE_NXZ:PROC	; CvActionInfo::isAltDownAlt
EXTRN	?isCtrlDown@CvActionInfo@@QBE_NXZ:PROC		; CvActionInfo::isCtrlDown
EXTRN	?isShiftDown@CvActionInfo@@QBE_NXZ:PROC		; CvActionInfo::isShiftDown
EXTRN	?isAltDown@CvActionInfo@@QBE_NXZ:PROC		; CvActionInfo::isAltDown
EXTRN	?getOrderPriority@CvActionInfo@@QBEHXZ:PROC	; CvActionInfo::getOrderPriority
EXTRN	?getHotKeyPriorityAlt@CvActionInfo@@QBEHXZ:PROC	; CvActionInfo::getHotKeyPriorityAlt
EXTRN	?getHotKeyValAlt@CvActionInfo@@QBEHXZ:PROC	; CvActionInfo::getHotKeyValAlt
EXTRN	?getHotKeyPriority@CvActionInfo@@QBEHXZ:PROC	; CvActionInfo::getHotKeyPriority
EXTRN	?getHotKeyVal@CvActionInfo@@QBEHXZ:PROC		; CvActionInfo::getHotKeyVal
EXTRN	?getActionInfoIndex@CvActionInfo@@QBEHXZ:PROC	; CvActionInfo::getActionInfoIndex
EXTRN	?GetTextKey@CvActionInfo@@QBEPBDXZ:PROC		; CvActionInfo::GetTextKey
EXTRN	?GetType@CvActionInfo@@QBEPBDXZ:PROC		; CvActionInfo::GetType
EXTRN	?getSubType@CvActionInfo@@QBE?AW4ActionSubTypes@@XZ:PROC ; CvActionInfo::getSubType
EXTRN	?isVisible@CvActionInfo@@QBE_NXZ:PROC		; CvActionInfo::isVisible
EXTRN	?isConfirmCommand@CvActionInfo@@QBE_NXZ:PROC	; CvActionInfo::isConfirmCommand
EXTRN	?getOriginalIndex@CvActionInfo@@QBEHXZ:PROC	; CvActionInfo::getOriginalIndex
EXTRN	?getControlType@CvActionInfo@@QBEHXZ:PROC	; CvActionInfo::getControlType
EXTRN	?getCommandType@CvActionInfo@@QBEHXZ:PROC	; CvActionInfo::getCommandType
EXTRN	?getMissionType@CvActionInfo@@QBEHXZ:PROC	; CvActionInfo::getMissionType
EXTRN	?getInterfaceModeType@CvActionInfo@@QBEHXZ:PROC	; CvActionInfo::getInterfaceModeType
EXTRN	?getAutomateType@CvActionInfo@@QBEHXZ:PROC	; CvActionInfo::getAutomateType
EXTRN	?getCommandData@CvActionInfo@@QBEHXZ:PROC	; CvActionInfo::getCommandData
EXTRN	?getMissionData@CvActionInfo@@QBEHXZ:PROC	; CvActionInfo::getMissionData
EXTRN	?getActionInfo@CvGlobals@@QAEAAV?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@XZ:PROC ; CvGlobals::getActionInfo
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	_lua_gettop:PROC
EXTRN	_lua_setfield:PROC
EXTRN	_lua_pushvalue:PROC
EXTRN	_lua_createtable:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z DD 019930522H
	DD	01dH
	DD	FLAT:__unwindtable$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$13
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$14
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$15
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$16
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$17
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$18
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$19
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$20
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$21
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$22
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$23
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$24
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$25
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$26
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$27
	DD	00H
	DD	FLAT:__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$28
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluagameinfo.cpp
xdata$x	ENDS
;	COMDAT ?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T218436 = -412						; size = 4
$T218427 = -412						; size = 4
$T218418 = -412						; size = 4
$T218409 = -412						; size = 4
$T218400 = -412						; size = 4
$T218391 = -412						; size = 4
$T218382 = -412						; size = 4
$T218373 = -412						; size = 4
$T218364 = -412						; size = 4
$T218355 = -412						; size = 4
$T218346 = -412						; size = 4
$T218337 = -412						; size = 4
$T218328 = -412						; size = 4
$T218319 = -412						; size = 4
$T218310 = -412						; size = 4
$T218301 = -412						; size = 4
$T218292 = -412						; size = 4
$T218283 = -412						; size = 4
$T218274 = -412						; size = 4
$T218265 = -412						; size = 4
$T218256 = -412						; size = 4
$T218247 = -412						; size = 4
$T218238 = -412						; size = 4
$T218229 = -412						; size = 4
$T218220 = -412						; size = 4
$T218211 = -412						; size = 4
$T218202 = -412						; size = 4
$T218193 = -412						; size = 4
_kEntry$217344 = -408					; size = 8
_it$217294 = -400					; size = 4
_idx$ = -396						; size = 4
$T218374 = -392						; size = 1
$T218401 = -388						; size = 1
$T218365 = -384						; size = 1
$T218410 = -380						; size = 1
$T218383 = -376						; size = 1
_t$ = -372						; size = 4
$T218266 = -368						; size = 1
_infos$ = -364						; size = 4
$T218392 = -360						; size = 1
$T218275 = -356						; size = 1
$T218089 = -352						; size = 12
$T218097 = -340						; size = 12
$T218084 = -328						; size = 12
$T218098 = -316						; size = 12
$T218086 = -304						; size = 12
$T218099 = -292						; size = 12
$T218088 = -280						; size = 12
$T218100 = -268						; size = 12
$T218090 = -256						; size = 12
$T218101 = -244						; size = 12
$T218092 = -232						; size = 12
$T218102 = -220						; size = 12
$T218094 = -208						; size = 12
$T218103 = -196						; size = 12
$T218096 = -184						; size = 12
$T218104 = -172						; size = 12
$T218087 = -160						; size = 12
$T218105 = -148						; size = 12
$T218091 = -136						; size = 12
$T218106 = -124						; size = 12
$T218095 = -112						; size = 12
$T218107 = -100						; size = 12
$T218083 = -88						; size = 12
$T218108 = -76						; size = 12
$T218085 = -64						; size = 12
$T218109 = -52						; size = 12
$T218093 = -40						; size = 12
$T218110 = -28						; size = 12
__$EHRec$ = -12						; size = 12
_L$ = 8							; size = 4
?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z PROC ; CvLuaGameInfo::pRegisterActions, COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 400				; 00000190H
	push	ebx
	push	esi
	push	edi

; 35   : 	lua_newtable(L);

	mov	edi, DWORD PTR _L$[ebp]
	xor	ebx, ebx
	push	ebx
	push	ebx
	push	edi
	call	_lua_createtable

; 36   : 	lua_pushvalue(L, -1);

	push	-1
	push	edi
	call	_lua_pushvalue

; 37   : 	lua_setglobal(L, "GameInfoActions");

	push	OFFSET $SG217181
	push	-10002					; ffffd8eeH
	push	edi
	call	_lua_setfield

; 38   : 
; 39   : 	const int t = lua_gettop(L);

	push	edi
	call	_lua_gettop
	add	esp, 36					; 00000024H

; 40   : 	int idx = 0;
; 41   : 
; 42   : #ifdef AUI_CONSTIFY
; 43   : 	const std::vector<CvActionInfo*>& infos = GC.getActionInfo();
; 44   : 	for (std::vector<CvActionInfo*>::const_iterator it = infos.begin(); it != infos.end(); ++it)
; 45   : 	{
; 46   : 		const CvActionInfo* pEntry = (*it);
; 47   : #else
; 48   : 	typedef std::vector<CvActionInfo*> ActionInfos;
; 49   : 	ActionInfos& infos = GC.getActionInfo();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _t$[esp+424], eax
	mov	DWORD PTR _idx$[esp+424], ebx
	call	?getActionInfo@CvGlobals@@QAEAAV?$vector@PAVCvActionInfo@@V?$allocator@PAVCvActionInfo@@@std@@@std@@XZ ; CvGlobals::getActionInfo

; 50   : 	for(ActionInfos::const_iterator it = infos.begin();

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _infos$[esp+424], eax
	mov	DWORD PTR _it$217294[esp+424], ecx

; 51   : 	        it != infos.end(); ++it)

	cmp	ecx, DWORD PTR [eax+8]
	je	$LN203@pRegisterA
	jmp	SHORT $LN41@pRegisterA
	npad	6
$LL204@pRegisterA:
	mov	ecx, DWORD PTR _it$217294[esp+424]
$LN41@pRegisterA:

; 52   : 	{
; 53   : 		CvActionInfo* pEntry = (*it);

	mov	esi, DWORD PTR [ecx]

; 54   : #endif
; 55   : 		lua_createtable(L, 0, 0);

	push	ebx
	push	ebx
	push	edi
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 56   : 
; 57   : 		Table kEntry(L, -1);

	push	-1
	push	edi
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??0Value@FLua@@QAE@PAUlua_State@@H@Z	; FLua::Value::Value

; 58   : 
; 59   : 		kEntry["MissionData"]		= pEntry->getMissionData();

	push	OFFSET $SG217355
	lea	eax, DWORD PTR $T218083[esp+428]
	push	eax
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	mov	DWORD PTR __$EHRec$[esp+440], ebx
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218193[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 1
	call	?getMissionData@CvActionInfo@@QBEHXZ	; CvActionInfo::getMissionData
	push	eax
	mov	eax, DWORD PTR $T218193[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	lea	ecx, DWORD PTR $T218083[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 60   : 		kEntry["CommandData"]		= pEntry->getCommandData();

	push	OFFSET $SG217357
	lea	edx, DWORD PTR $T218084[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218202[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 2
	call	?getCommandData@CvActionInfo@@QBEHXZ	; CvActionInfo::getCommandData
	push	eax
	mov	eax, DWORD PTR $T218202[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	lea	ecx, DWORD PTR $T218084[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 61   : 
; 62   : 		kEntry["AutomateType"]		= pEntry->getAutomateType();

	push	OFFSET $SG217359
	lea	edx, DWORD PTR $T218085[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218211[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 3
	call	?getAutomateType@CvActionInfo@@QBEHXZ	; CvActionInfo::getAutomateType
	push	eax
	mov	eax, DWORD PTR $T218211[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	lea	ecx, DWORD PTR $T218085[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 63   : 		kEntry["InterfaceModeType"]	= pEntry->getInterfaceModeType();

	push	OFFSET $SG217361
	lea	edx, DWORD PTR $T218086[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218220[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 4
	call	?getInterfaceModeType@CvActionInfo@@QBEHXZ ; CvActionInfo::getInterfaceModeType
	push	eax
	mov	eax, DWORD PTR $T218220[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	lea	ecx, DWORD PTR $T218086[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 64   : 		kEntry["MissionType"]		= pEntry->getMissionType();

	push	OFFSET $SG217363
	lea	edx, DWORD PTR $T218087[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218229[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 5
	call	?getMissionType@CvActionInfo@@QBEHXZ	; CvActionInfo::getMissionType
	push	eax
	mov	eax, DWORD PTR $T218229[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	lea	ecx, DWORD PTR $T218087[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 65   : 		kEntry["CommandType"]		= pEntry->getCommandType();

	push	OFFSET $SG217365
	lea	edx, DWORD PTR $T218088[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218238[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 6
	call	?getCommandType@CvActionInfo@@QBEHXZ	; CvActionInfo::getCommandType
	push	eax
	mov	eax, DWORD PTR $T218238[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	lea	ecx, DWORD PTR $T218088[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 66   : 		kEntry["ControlType"]		= pEntry->getControlType();

	push	OFFSET $SG217367
	lea	edx, DWORD PTR $T218089[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218247[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 7
	call	?getControlType@CvActionInfo@@QBEHXZ	; CvActionInfo::getControlType
	push	eax
	mov	eax, DWORD PTR $T218247[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	lea	ecx, DWORD PTR $T218089[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 67   : 		kEntry["OriginalIndex"]		= pEntry->getOriginalIndex();

	push	OFFSET $SG217369
	lea	edx, DWORD PTR $T218090[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218256[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 8
	call	?getOriginalIndex@CvActionInfo@@QBEHXZ	; CvActionInfo::getOriginalIndex
	push	eax
	mov	eax, DWORD PTR $T218256[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	mov	BYTE PTR __$EHRec$[esp+432], bl
	lea	ecx, DWORD PTR $T218090[esp+428]
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 68   : 
; 69   : 		kEntry["ConfirmCommand"]	= pEntry->isConfirmCommand();

	push	OFFSET $SG217374
	lea	edx, DWORD PTR $T218091[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218265[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 9
	call	?isConfirmCommand@CvActionInfo@@QBE_NXZ	; CvActionInfo::isConfirmCommand
	mov	BYTE PTR $T218266[esp+424], al
	mov	eax, DWORD PTR $T218266[esp+424]
	push	eax
	mov	eax, DWORD PTR $T218265[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@_N@Table@FLua@@QAEXABVValue@1@_N@Z ; FLua::Table::SetField<bool>
	lea	ecx, DWORD PTR $T218091[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 70   : 		kEntry["Visible"]			= pEntry->isVisible();

	push	OFFSET $SG217376
	lea	edx, DWORD PTR $T218092[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218274[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 10		; 0000000aH
	call	?isVisible@CvActionInfo@@QBE_NXZ	; CvActionInfo::isVisible
	mov	BYTE PTR $T218275[esp+424], al
	mov	eax, DWORD PTR $T218275[esp+424]
	push	eax
	mov	eax, DWORD PTR $T218274[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@_N@Table@FLua@@QAEXABVValue@1@_N@Z ; FLua::Table::SetField<bool>
	lea	ecx, DWORD PTR $T218092[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 71   : 		kEntry["SubType"]			= (int)pEntry->getSubType();

	push	OFFSET $SG217379
	lea	edx, DWORD PTR $T218093[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218283[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 11		; 0000000bH
	call	?getSubType@CvActionInfo@@QBE?AW4ActionSubTypes@@XZ ; CvActionInfo::getSubType
	push	eax
	mov	eax, DWORD PTR $T218283[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	lea	ecx, DWORD PTR $T218093[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 72   : 
; 73   : 		kEntry["Type"]				= pEntry->GetType();

	push	OFFSET $SG217384
	lea	edx, DWORD PTR $T218094[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218292[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 12		; 0000000cH
	call	?GetType@CvActionInfo@@QBEPBDXZ		; CvActionInfo::GetType
	push	eax
	mov	eax, DWORD PTR $T218292[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@PBD@Table@FLua@@QAEXABVValue@1@PBD@Z ; FLua::Table::SetField<char const *>
	mov	BYTE PTR __$EHRec$[esp+432], bl
	lea	ecx, DWORD PTR $T218094[esp+428]
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 74   : 		kEntry["TextKey"]			= pEntry->GetTextKey();

	push	OFFSET $SG217386
	lea	edx, DWORD PTR $T218095[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218301[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 13		; 0000000dH
	call	?GetTextKey@CvActionInfo@@QBEPBDXZ	; CvActionInfo::GetTextKey
	push	eax
	mov	eax, DWORD PTR $T218301[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@PBD@Table@FLua@@QAEXABVValue@1@PBD@Z ; FLua::Table::SetField<char const *>
	lea	ecx, DWORD PTR $T218095[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 75   : 
; 76   : 		kEntry["ActionInfoIndex"]	= pEntry->getActionInfoIndex();

	push	OFFSET $SG217388
	lea	edx, DWORD PTR $T218096[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218310[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 14		; 0000000eH
	call	?getActionInfoIndex@CvActionInfo@@QBEHXZ ; CvActionInfo::getActionInfoIndex
	push	eax
	mov	eax, DWORD PTR $T218310[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	lea	ecx, DWORD PTR $T218096[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 77   : 		kEntry["HotKeyVal"]			= pEntry->getHotKeyVal();

	push	OFFSET $SG217390
	lea	edx, DWORD PTR $T218097[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218319[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 15		; 0000000fH
	call	?getHotKeyVal@CvActionInfo@@QBEHXZ	; CvActionInfo::getHotKeyVal
	push	eax
	mov	eax, DWORD PTR $T218319[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	lea	ecx, DWORD PTR $T218097[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 78   : 		kEntry["HotKeyPriority"]	= pEntry->getHotKeyPriority();

	push	OFFSET $SG217392
	lea	edx, DWORD PTR $T218098[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218328[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 16		; 00000010H
	call	?getHotKeyPriority@CvActionInfo@@QBEHXZ	; CvActionInfo::getHotKeyPriority
	push	eax
	mov	eax, DWORD PTR $T218328[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	lea	ecx, DWORD PTR $T218098[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 79   : 		kEntry["HotKeyValAlt"]		= pEntry->getHotKeyValAlt();

	push	OFFSET $SG217394
	lea	edx, DWORD PTR $T218099[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218337[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 17		; 00000011H
	call	?getHotKeyValAlt@CvActionInfo@@QBEHXZ	; CvActionInfo::getHotKeyValAlt
	push	eax
	mov	eax, DWORD PTR $T218337[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	lea	ecx, DWORD PTR $T218099[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 80   : 		kEntry["HotKeyPriorityAlt"]	= pEntry->getHotKeyPriorityAlt();

	push	OFFSET $SG217396
	lea	edx, DWORD PTR $T218100[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218346[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 18		; 00000012H
	call	?getHotKeyPriorityAlt@CvActionInfo@@QBEHXZ ; CvActionInfo::getHotKeyPriorityAlt
	push	eax
	mov	eax, DWORD PTR $T218346[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	lea	ecx, DWORD PTR $T218100[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 81   : 		kEntry["OrderPriority"]		= pEntry->getOrderPriority();

	push	OFFSET $SG217398
	lea	edx, DWORD PTR $T218101[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218355[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 19		; 00000013H
	call	?getOrderPriority@CvActionInfo@@QBEHXZ	; CvActionInfo::getOrderPriority
	push	eax
	mov	eax, DWORD PTR $T218355[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@H@Table@FLua@@QAEXABVValue@1@H@Z ; FLua::Table::SetField<int>
	lea	ecx, DWORD PTR $T218101[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 82   : 
; 83   : 		kEntry["AltDown"]			= pEntry->isAltDown();

	push	OFFSET $SG217400
	lea	edx, DWORD PTR $T218102[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218364[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 20		; 00000014H
	call	?isAltDown@CvActionInfo@@QBE_NXZ	; CvActionInfo::isAltDown
	mov	BYTE PTR $T218365[esp+424], al
	mov	eax, DWORD PTR $T218365[esp+424]
	push	eax
	mov	eax, DWORD PTR $T218364[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@_N@Table@FLua@@QAEXABVValue@1@_N@Z ; FLua::Table::SetField<bool>
	lea	ecx, DWORD PTR $T218102[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 84   : 		kEntry["ShiftDown"]			= pEntry->isShiftDown();

	push	OFFSET $SG217402
	lea	edx, DWORD PTR $T218103[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218373[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 21		; 00000015H
	call	?isShiftDown@CvActionInfo@@QBE_NXZ	; CvActionInfo::isShiftDown
	mov	BYTE PTR $T218374[esp+424], al
	mov	eax, DWORD PTR $T218374[esp+424]
	push	eax
	mov	eax, DWORD PTR $T218373[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@_N@Table@FLua@@QAEXABVValue@1@_N@Z ; FLua::Table::SetField<bool>
	lea	ecx, DWORD PTR $T218103[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 85   : 		kEntry["CtrlDown"]			= pEntry->isCtrlDown();

	push	OFFSET $SG217404
	lea	edx, DWORD PTR $T218104[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218382[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 22		; 00000016H
	call	?isCtrlDown@CvActionInfo@@QBE_NXZ	; CvActionInfo::isCtrlDown
	mov	BYTE PTR $T218383[esp+424], al
	mov	eax, DWORD PTR $T218383[esp+424]
	push	eax
	mov	eax, DWORD PTR $T218382[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@_N@Table@FLua@@QAEXABVValue@1@_N@Z ; FLua::Table::SetField<bool>
	lea	ecx, DWORD PTR $T218104[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 86   : 		kEntry["AltDownAlt"]		= pEntry->isAltDownAlt();

	push	OFFSET $SG217406
	lea	edx, DWORD PTR $T218105[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218391[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 23		; 00000017H
	call	?isAltDownAlt@CvActionInfo@@QBE_NXZ	; CvActionInfo::isAltDownAlt
	mov	BYTE PTR $T218392[esp+424], al
	mov	eax, DWORD PTR $T218392[esp+424]
	push	eax
	mov	eax, DWORD PTR $T218391[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@_N@Table@FLua@@QAEXABVValue@1@_N@Z ; FLua::Table::SetField<bool>
	lea	ecx, DWORD PTR $T218105[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 87   : 		kEntry["ShiftDownAlt"]		= pEntry->isShiftDownAlt();

	push	OFFSET $SG217408
	lea	edx, DWORD PTR $T218106[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218400[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 24		; 00000018H
	call	?isShiftDownAlt@CvActionInfo@@QBE_NXZ	; CvActionInfo::isShiftDownAlt
	mov	BYTE PTR $T218401[esp+424], al
	mov	eax, DWORD PTR $T218401[esp+424]
	push	eax
	mov	eax, DWORD PTR $T218400[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@_N@Table@FLua@@QAEXABVValue@1@_N@Z ; FLua::Table::SetField<bool>
	lea	ecx, DWORD PTR $T218106[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 88   : 		kEntry["CtrlDownAlt"]		= pEntry->isCtrlDownAlt();

	push	OFFSET $SG217410
	lea	edx, DWORD PTR $T218107[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218409[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 25		; 00000019H
	call	?isCtrlDownAlt@CvActionInfo@@QBE_NXZ	; CvActionInfo::isCtrlDownAlt
	mov	BYTE PTR $T218410[esp+424], al
	mov	eax, DWORD PTR $T218410[esp+424]
	push	eax
	mov	eax, DWORD PTR $T218409[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@_N@Table@FLua@@QAEXABVValue@1@_N@Z ; FLua::Table::SetField<bool>
	lea	ecx, DWORD PTR $T218107[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 89   : 
; 90   : 		kEntry["HotKey"]			= pEntry->getHotKeyString();

	push	OFFSET $SG217412
	lea	edx, DWORD PTR $T218108[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218418[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 26		; 0000001aH
	call	?getHotKeyString@CvActionInfo@@QBEPBDXZ	; CvActionInfo::getHotKeyString
	push	eax
	mov	eax, DWORD PTR $T218418[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@PBD@Table@FLua@@QAEXABVValue@1@PBD@Z ; FLua::Table::SetField<char const *>
	lea	ecx, DWORD PTR $T218108[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 91   : 		kEntry["Help"]				= pEntry->GetHelp();

	push	OFFSET $SG217414
	lea	edx, DWORD PTR $T218109[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218427[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 27		; 0000001bH
	call	?GetHelp@CvActionInfo@@QBEPBDXZ		; CvActionInfo::GetHelp
	push	eax
	mov	eax, DWORD PTR $T218427[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@PBD@Table@FLua@@QAEXABVValue@1@PBD@Z ; FLua::Table::SetField<char const *>
	lea	ecx, DWORD PTR $T218109[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 92   : 		kEntry["DisabledHelp"]		= pEntry->GetDisabledHelp();

	push	OFFSET $SG217416
	lea	edx, DWORD PTR $T218110[esp+428]
	push	edx
	lea	ecx, DWORD PTR _kEntry$217344[esp+432]
	call	??$?APBD@Table@FLua@@QAE?AVField@01@PBD@Z ; FLua::Table::operator[]<char const *>
	mov	DWORD PTR $T218436[esp+424], eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+432], 28		; 0000001cH
	call	?GetDisabledHelp@CvActionInfo@@QBEPBDXZ	; CvActionInfo::GetDisabledHelp
	push	eax
	mov	eax, DWORD PTR $T218436[esp+428]
	lea	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR [eax]
	call	??$SetField@PBD@Table@FLua@@QAEXABVValue@1@PBD@Z ; FLua::Table::SetField<char const *>
	lea	ecx, DWORD PTR $T218110[esp+428]
	mov	BYTE PTR __$EHRec$[esp+432], bl
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value

; 93   : 
; 94   : 		lua_rawseti(L, t, idx);

	mov	esi, DWORD PTR _idx$[esp+424]
	mov	edx, DWORD PTR _t$[esp+424]
	push	esi
	push	edx
	push	edi
	call	_lua_rawseti
	add	esp, 12					; 0000000cH

; 95   : 
; 96   : 		++idx;

	inc	esi

; 97   : 	}

	lea	ecx, DWORD PTR _kEntry$217344[esp+424]
	mov	DWORD PTR _idx$[esp+424], esi
	mov	DWORD PTR __$EHRec$[esp+432], -1
	call	??1Value@FLua@@QAE@XZ			; FLua::Value::~Value
	mov	eax, DWORD PTR _it$217294[esp+424]
	mov	ecx, DWORD PTR _infos$[esp+424]
	add	eax, 4
	mov	DWORD PTR _it$217294[esp+424], eax
	cmp	eax, DWORD PTR [ecx+8]
	jne	$LL204@pRegisterA
$LN203@pRegisterA:

; 98   : 
; 99   : 	return 0;
; 100  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+424]
	pop	edi
	pop	esi
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$0:
	lea	ecx, DWORD PTR _kEntry$217344[ebp]
	jmp	??1Table@FLua@@QAE@XZ			; FLua::Table::~Table
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$1:
	lea	ecx, DWORD PTR $T218083[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$2:
	lea	ecx, DWORD PTR $T218084[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$3:
	lea	ecx, DWORD PTR $T218085[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$4:
	lea	ecx, DWORD PTR $T218086[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$5:
	lea	ecx, DWORD PTR $T218087[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$6:
	lea	ecx, DWORD PTR $T218088[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$7:
	lea	ecx, DWORD PTR $T218089[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$8:
	lea	ecx, DWORD PTR $T218090[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$9:
	lea	ecx, DWORD PTR $T218091[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$10:
	lea	ecx, DWORD PTR $T218092[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$11:
	lea	ecx, DWORD PTR $T218093[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$12:
	lea	ecx, DWORD PTR $T218094[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$13:
	lea	ecx, DWORD PTR $T218095[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$14:
	lea	ecx, DWORD PTR $T218096[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$15:
	lea	ecx, DWORD PTR $T218097[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$16:
	lea	ecx, DWORD PTR $T218098[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$17:
	lea	ecx, DWORD PTR $T218099[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$18:
	lea	ecx, DWORD PTR $T218100[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$19:
	lea	ecx, DWORD PTR $T218101[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$20:
	lea	ecx, DWORD PTR $T218102[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$21:
	lea	ecx, DWORD PTR $T218103[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$22:
	lea	ecx, DWORD PTR $T218104[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$23:
	lea	ecx, DWORD PTR $T218105[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$24:
	lea	ecx, DWORD PTR $T218106[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$25:
	lea	ecx, DWORD PTR $T218107[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$26:
	lea	ecx, DWORD PTR $T218108[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$27:
	lea	ecx, DWORD PTR $T218109[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__unwindfunclet$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z$28:
	lea	ecx, DWORD PTR $T218110[ebp]
	jmp	??1Field@Table@FLua@@QAE@XZ
__ehhandler$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z ENDP ; CvLuaGameInfo::pRegisterActions
PUBLIC	?pRegisterTypesInfo@CvLuaGameInfo@@CAHPAUlua_State@@@Z ; CvLuaGameInfo::pRegisterTypesInfo
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?GetInfoTypes@CvGlobals@@QBEABV?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@XZ:PROC ; CvGlobals::GetInfoTypes
; Function compile flags: /Ogtpy
;	COMDAT ?pRegisterTypesInfo@CvLuaGameInfo@@CAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?pRegisterTypesInfo@CvLuaGameInfo@@CAHPAUlua_State@@@Z PROC ; CvLuaGameInfo::pRegisterTypesInfo, COMDAT

; 103  : {

	push	ebx
	push	esi
	push	edi

; 104  : 	lua_newtable(L);

	mov	edi, DWORD PTR _L$[esp+8]
	push	0
	push	0
	push	edi
	call	_lua_createtable

; 105  : 	lua_pushvalue(L, -1);

	push	-1
	push	edi
	call	_lua_pushvalue

; 106  : 	lua_setglobal(L, "GameInfoTypes");

	push	OFFSET $SG217422
	push	-10002					; ffffd8eeH
	push	edi
	call	_lua_setfield
	add	esp, 32					; 00000020H

; 107  : 
; 108  : 	const CvGlobals::InfosMap& kInfosMap = GC.GetInfoTypes();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInfoTypes@CvGlobals@@QBEABV?$hash_map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HV?$hash_compare@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@@2@@stdext@@XZ ; CvGlobals::GetInfoTypes
	mov	ebx, eax

; 109  : 	for(CvGlobals::InfosMap::const_iterator it = kInfosMap.begin();

	mov	eax, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [eax]

; 110  : 	        it != kInfosMap.end(); ++ it)

	cmp	esi, eax
	je	SHORT $LN38@pRegisterT
$LL14@pRegisterT:

; 111  : 	{
; 112  : 		lua_pushinteger(L, (*it).second);

	mov	eax, DWORD PTR [esi+36]
	push	eax
	push	edi
	call	_lua_pushinteger
	add	esp, 8

; 113  : 		lua_setfield(L, -2, (*it).first.c_str());

	lea	ecx, DWORD PTR [esi+8]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-2					; fffffffeH
	push	edi
	call	_lua_setfield
	mov	esi, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@pRegisterT
$LN38@pRegisterT:
	pop	edi
	pop	esi

; 114  : 	}
; 115  : 
; 116  : 	return 0;

	xor	eax, eax
	pop	ebx

; 117  : }

	ret	0
?pRegisterTypesInfo@CvLuaGameInfo@@CAHPAUlua_State@@@Z ENDP ; CvLuaGameInfo::pRegisterTypesInfo
_TEXT	ENDS
PUBLIC	?Register@CvLuaGameInfo@@SAXPAUlua_State@@@Z	; CvLuaGameInfo::Register
EXTRN	?CCallWithErrorHandling@Details@FLua@@YA_NPAUlua_State@@P6AH0@ZPAX@Z:PROC ; FLua::Details::CCallWithErrorHandling
; Function compile flags: /Ogtpy
;	COMDAT ?Register@CvLuaGameInfo@@SAXPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?Register@CvLuaGameInfo@@SAXPAUlua_State@@@Z PROC	; CvLuaGameInfo::Register, COMDAT

; 26   : {

	push	esi

; 27   : 	//Register other game info structures.
; 28   : 	Lua::CCallWithErrorHandling(L, pRegisterActions);

	mov	esi, DWORD PTR _L$[esp]
	push	0
	push	OFFSET ?pRegisterActions@CvLuaGameInfo@@CAHPAUlua_State@@@Z ; CvLuaGameInfo::pRegisterActions
	push	esi
	call	?CCallWithErrorHandling@Details@FLua@@YA_NPAUlua_State@@P6AH0@ZPAX@Z ; FLua::Details::CCallWithErrorHandling

; 29   : 	Lua::CCallWithErrorHandling(L, pRegisterTypesInfo);

	push	0
	push	OFFSET ?pRegisterTypesInfo@CvLuaGameInfo@@CAHPAUlua_State@@@Z ; CvLuaGameInfo::pRegisterTypesInfo
	push	esi
	call	?CCallWithErrorHandling@Details@FLua@@YA_NPAUlua_State@@P6AH0@ZPAX@Z ; FLua::Details::CCallWithErrorHandling
	add	esp, 24					; 00000018H
	pop	esi

; 30   : }

	ret	0
?Register@CvLuaGameInfo@@SAXPAUlua_State@@@Z ENDP	; CvLuaGameInfo::Register
_TEXT	ENDS
END
