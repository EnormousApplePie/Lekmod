; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvMapGenerator.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG217253 DB	'Map Script', 00H
	ORG $+1
$SG217272 DB	'SELECT * from Worlds where ID = ? LIMIT 1', 00H
	ORG $+2
$SG217296 DB	'CvMapGenerator - GetMapInitData()', 00H
	ORG $+2
$SG217299 DB	'GetMapInitData', 00H
	ORG $+1
$SG217303 DB	'Width', 00H
	ORG $+2
$SG217305 DB	'Height', 00H
	ORG $+1
$SG217307 DB	'WrapX', 00H
	ORG $+2
$SG217309 DB	'WrapY', 00H
	ORG $+2
$SG217311 DB	'TopLatitude', 00H
$SG217313 DB	'BottomLatitude', 00H
	ORG $+1
$SG217320 DB	'CvMapGenerator - GetGameInitialItemsOverrides()', 00H
$SG217323 DB	'GetGameInitialItemsOverrides', 00H
	ORG $+3
$SG217327 DB	'GrantInitialFreeTechsPerTeam', 00H
	ORG $+3
$SG217338 DB	'GrantInitialGoldPerPlayer', 00H
	ORG $+2
$SG217349 DB	'GrantInitialCulturePerPlayer', 00H
	ORG $+3
$SG217360 DB	'ClearResearchQueuePerPlayer', 00H
$SG217371 DB	'GrantInitialUnitsPerPlayer', 00H
	ORG $+1
$SG217387 DB	'CvMapGenerator - GenerateRandomMap()', 00H
	ORG $+3
$SG217390 DB	'GenerateMap', 00H
$SG217392 DB	'Cannot find map script entry point GenerateMap()', 00H
CONST	ENDS
PUBLIC	?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z ; CvMapGenerator::pGetMapInitData
EXTRN	??1cvStopWatch@@QAE@XZ:PROC			; cvStopWatch::~cvStopWatch
EXTRN	_lua_toboolean:PROC
EXTRN	_lua_settop:PROC
EXTRN	_lua_tointeger:PROC
EXTRN	_lua_gettop:PROC
EXTRN	_lua_pushinteger:PROC
EXTRN	_lua_type:PROC
EXTRN	_lua_getfield:PROC
EXTRN	_lua_touserdata:PROC
EXTRN	??0cvStopWatch@@QAE@PBD0I_N1@Z:PROC		; cvStopWatch::cvStopWatch
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmapgenerator.cpp
xdata$x	SEGMENT
__unwindtable$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z$0
__ehfuncinfo$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_stopWatch$ = -52					; size = 40
__$EHRec$ = -12						; size = 12
_L$ = 8							; size = 4
?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z PROC ; CvMapGenerator::pGetMapInitData, COMDAT

; 104  : {

	push	-1
	push	__ehhandler$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi

; 105  : 	cvStopWatch stopWatch("CvMapGenerator - GetMapInitData()");

	xor	ebx, ebx
	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	OFFSET $SG217296
	lea	ecx, DWORD PTR _stopWatch$[esp+84]
	call	??0cvStopWatch@@QAE@PBD0I_N1@Z		; cvStopWatch::cvStopWatch

; 106  : 	GetMapInitDataArgs* pArgs = (GetMapInitDataArgs*)lua_touserdata(L, 1);

	mov	esi, DWORD PTR _L$[esp+60]
	push	1
	push	esi
	mov	DWORD PTR __$EHRec$[esp+80], ebx
	call	_lua_touserdata

; 107  : 
; 108  : 	pArgs->bSuccess = false;
; 109  : 	lua_getglobal(L, "GetMapInitData");

	push	OFFSET $SG217299
	mov	edi, eax
	push	-10002					; ffffd8eeH
	push	esi
	mov	BYTE PTR [edi+12], bl
	call	_lua_getfield

; 110  : 	if(lua_isfunction(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 28					; 0000001cH
	cmp	eax, 6
	jne	$LN7@pGetMapIni

; 111  : 	{
; 112  : 		lua_pushinteger(L, pArgs->WorldSize);

	mov	eax, DWORD PTR [edi+8]
	push	eax
	push	esi
	call	_lua_pushinteger

; 113  : 		pArgs->pkScriptSystem->CallFunction(L, 1, 1);

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+28]
	add	esp, 8
	push	1
	push	1
	push	esi
	call	eax

; 114  : 		const int t = lua_gettop(L);

	push	esi
	call	_lua_gettop
	mov	ebx, eax

; 115  : 		if(lua_istable(L, t))

	push	ebx
	push	esi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	$LN7@pGetMapIni

; 116  : 		{
; 117  : 			lua_getfield(L, t, "Width");

	push	OFFSET $SG217303
	push	ebx
	push	esi
	call	_lua_getfield

; 118  : 			if(!lua_isnoneornil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	jle	SHORT $LN6@pGetMapIni

; 119  : 				pArgs->pkMapInitData->m_iGridW = lua_tointeger(L, -1);

	push	-1
	push	esi
	call	_lua_tointeger
	mov	ecx, DWORD PTR [edi+4]
	add	esp, 8
	mov	DWORD PTR [ecx], eax
$LN6@pGetMapIni:

; 120  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 121  : 
; 122  : 			lua_getfield(L, t, "Height");

	push	OFFSET $SG217305
	push	ebx
	push	esi
	call	_lua_getfield

; 123  : 			if(!lua_isnoneornil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 28					; 0000001cH
	test	eax, eax
	jle	SHORT $LN5@pGetMapIni

; 124  : 				pArgs->pkMapInitData->m_iGridH = lua_tointeger(L, -1);

	push	-1
	push	esi
	call	_lua_tointeger
	mov	edx, DWORD PTR [edi+4]
	add	esp, 8
	mov	DWORD PTR [edx+4], eax
$LN5@pGetMapIni:

; 125  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 126  : 
; 127  : 			lua_getfield(L, t, "WrapX");

	push	OFFSET $SG217307
	push	ebx
	push	esi
	call	_lua_getfield

; 128  : 			if(!lua_isnoneornil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 28					; 0000001cH
	test	eax, eax
	jle	SHORT $LN4@pGetMapIni

; 129  : 				pArgs->pkMapInitData->m_bWrapX = lua_toboolean(L, -1);

	push	-1
	push	esi
	call	_lua_toboolean
	mov	ecx, DWORD PTR [edi+4]
	add	esp, 8
	test	eax, eax
	setne	al
	mov	BYTE PTR [ecx+16], al
$LN4@pGetMapIni:

; 130  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 131  : 
; 132  : 			lua_getfield(L, t, "WrapY");

	push	OFFSET $SG217309
	push	ebx
	push	esi
	call	_lua_getfield

; 133  : 			if(!lua_isnoneornil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 28					; 0000001cH
	test	eax, eax
	jle	SHORT $LN3@pGetMapIni

; 134  : 				pArgs->pkMapInitData->m_bWrapY = lua_toboolean(L, -1);

	push	-1
	push	esi
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	mov	eax, DWORD PTR [edi+4]
	setne	dl
	mov	BYTE PTR [eax+17], dl
$LN3@pGetMapIni:

; 135  : 
; 136  : 			lua_getfield(L, t, "TopLatitude");

	push	OFFSET $SG217311
	push	ebx
	push	esi
	call	_lua_getfield

; 137  : 			if(!lua_isnoneornil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	jle	SHORT $LN2@pGetMapIni

; 138  : 				pArgs->pkMapInitData->m_iTopLatitude = lua_tointeger(L, -1);

	push	-1
	push	esi
	call	_lua_tointeger
	mov	ecx, DWORD PTR [edi+4]
	add	esp, 8
	mov	DWORD PTR [ecx+8], eax
$LN2@pGetMapIni:

; 139  : 
; 140  : 			lua_getfield(L, t, "BottomLatitude");

	push	OFFSET $SG217313
	push	ebx
	push	esi
	call	_lua_getfield

; 141  : 			if(!lua_isnoneornil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	jle	SHORT $LN1@pGetMapIni

; 142  : 				pArgs->pkMapInitData->m_iBottomLatitude = lua_tointeger(L, -1);

	push	-1
	push	esi
	call	_lua_tointeger
	mov	edx, DWORD PTR [edi+4]
	add	esp, 8
	mov	DWORD PTR [edx+12], eax
$LN1@pGetMapIni:

; 143  : 
; 144  : 			pArgs->bSuccess = true;

	mov	BYTE PTR [edi+12], 1
$LN7@pGetMapIni:

; 145  : 		}
; 146  : 	}
; 147  : 
; 148  : 	return 0;

	lea	ecx, DWORD PTR _stopWatch$[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	??1cvStopWatch@@QAE@XZ			; cvStopWatch::~cvStopWatch

; 149  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z$0:
	lea	ecx, DWORD PTR _stopWatch$[ebp]
	jmp	??1cvStopWatch@@QAE@XZ			; cvStopWatch::~cvStopWatch
__ehhandler$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z ENDP ; CvMapGenerator::pGetMapInitData
PUBLIC	?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z ; CvMapGenerator::pGenerateRandomMap
EXTRN	_luaL_error:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z$0
__ehfuncinfo$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_stopWatch$ = -52					; size = 40
__$EHRec$ = -12						; size = 12
_L$ = 8							; size = 4
?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z PROC ; CvMapGenerator::pGenerateRandomMap, COMDAT

; 277  : {

	push	-1
	push	__ehhandler$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	esi
	push	edi

; 278  : 	cvStopWatch stopWatch("CvMapGenerator - GenerateRandomMap()");

	push	0
	push	0
	push	0
	push	0
	push	OFFSET $SG217387
	lea	ecx, DWORD PTR _stopWatch$[esp+80]
	call	??0cvStopWatch@@QAE@PBD0I_N1@Z		; cvStopWatch::cvStopWatch

; 279  : 	ICvEngineScriptSystem1* pkScriptSystem = (ICvEngineScriptSystem1*)lua_touserdata(L, 1);

	mov	esi, DWORD PTR _L$[esp+56]
	push	1
	push	esi
	mov	DWORD PTR __$EHRec$[esp+76], 0
	call	_lua_touserdata

; 280  : 
; 281  : 	lua_getglobal(L, "GenerateMap");

	push	OFFSET $SG217390
	push	-10002					; ffffd8eeH
	push	esi
	mov	edi, eax
	call	_lua_getfield

; 282  : 	if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN1@pGenerateR

; 283  : 		luaL_error(L, "Cannot find map script entry point GenerateMap()");

	push	OFFSET $SG217392
	push	esi
	call	_luaL_error
	add	esp, 8
$LN1@pGenerateR:

; 284  : 
; 285  : 	pkScriptSystem->CallFunction(L, 0, 0);

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+28]
	push	0
	push	0
	push	esi
	mov	ecx, edi
	call	edx

; 286  : 
; 287  : 	return 0;

	lea	ecx, DWORD PTR _stopWatch$[esp+60]
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	??1cvStopWatch@@QAE@XZ			; cvStopWatch::~cvStopWatch

; 288  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	edi
	xor	eax, eax
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z$0:
	lea	ecx, DWORD PTR _stopWatch$[ebp]
	jmp	??1cvStopWatch@@QAE@XZ			; cvStopWatch::~cvStopWatch
__ehhandler$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z ENDP ; CvMapGenerator::pGenerateRandomMap
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?GetID@CvBaseInfo@@QBEHXZ			; CvBaseInfo::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetID@CvBaseInfo@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvBaseInfo@@QBEHXZ PROC				; CvBaseInfo::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvBaseInfo@@QBEHXZ ENDP				; CvBaseInfo::GetID
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ ; CvGlobals::GetGameDatabase
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ
_TEXT	SEGMENT
?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ PROC ; CvGlobals::GetGameDatabase, COMDAT
; _this$ = ecx

; 9745 : 	return m_pGameDatabase;

	mov	eax, DWORD PTR [ecx+912]

; 9746 : }

	ret	0
?GetGameDatabase@CvGlobals@@QAEPAVConnection@Database@@XZ ENDP ; CvGlobals::GetGameDatabase
_TEXT	ENDS
PUBLIC	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=, COMDAT
; _this$ = ecx

; 1602 : 		{	// increment by integer

	mov	eax, ecx

; 1603 : 		if (_Off == 0)

	mov	ecx, DWORD PTR __Off$[esp-4]
	test	ecx, ecx

; 1604 : 			return (*this); // early out

	je	SHORT $LN6@operator
	push	esi

; 1605 : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1606 : 		if (_Off < 0)
; 1607 : 			{
; 1608 : 			_SCL_SECURE_VALIDATE_RANGE(this->_My_actual_offset() >= ((size_type)-_Off));
; 1609 : 			}
; 1610 : 		else
; 1611 : 			{
; 1612 : 			_SCL_SECURE_VALIDATE_RANGE((this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1613 : 			}
; 1614 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	jge	SHORT $LN2@operator
	mov	edx, DWORD PTR [eax+4]
	mov	esi, ecx
	neg	esi
	cmp	edx, esi
	jae	SHORT $LN2@operator

; 1615 : 			{	/* add negative increment */
; 1616 : 			this->_Myoff += _Off;

	add	ecx, edx

; 1617 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	or	edx, -1
	sub	edx, ecx
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	mov	esi, -4					; fffffffcH
	sub	esi, edx
	add	DWORD PTR [eax], esi

; 1624 : 			this->_Myoff %= _VBITS;

	and	ecx, 31					; 0000001fH
	mov	DWORD PTR [eax+4], ecx
	pop	esi

; 1625 : 			}
; 1626 : 		return (*this);
; 1627 : 		}

	ret	4
$LN2@operator:

; 1618 : 			this->_Myoff %= _VBITS;
; 1619 : 			}
; 1620 : 		else
; 1621 : 			{	/* add non-negative increment */
; 1622 : 			this->_Myoff += _Off;

	mov	edx, DWORD PTR [eax+4]
	add	ecx, edx

; 1623 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	edx, ecx
	shr	edx, 5
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 1624 : 			this->_Myoff %= _VBITS;

	and	ecx, 31					; 0000001fH
	mov	DWORD PTR [eax+4], ecx
	pop	esi
$LN6@operator:

; 1625 : 			}
; 1626 : 		return (*this);
; 1627 : 		}

	ret	4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z ; std::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z PROC ; std::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1403 : 		{	// construct with offset and pointer

	mov	edx, DWORD PTR __Off$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1404 : 		}

	ret	8
??0?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAII@Z ENDP ; std::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iter_base<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1465 : 		{	// construct with base

	mov	eax, ecx
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1466 : 		}

	ret	4
??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Getptr
; Function compile flags: /Ogtpy
;	COMDAT ?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ
_TEXT	SEGMENT
?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Getptr, COMDAT
; _this$ = ecx

; 1500 : 
; 1501 :  #if _HAS_ITERATOR_DEBUGGING
; 1502 : 		if (this->_Mycont == 0 || this->_Myptr == 0)
; 1503 : 			{
; 1504 : 			_DEBUG_ERROR("vector<bool> iterator not dereferencable");
; 1505 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1506 : 			}
; 1507 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1508 :  		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1509 : 		_SCL_SECURE_VALIDATE_RANGE(this->_My_actual_offset() < ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1510 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1511 : 
; 1512 : 		return (this->_Myptr);

	mov	eax, DWORD PTR [ecx]

; 1513 : 		}

	ret	0
?_Getptr@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBEPAIXZ ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Getptr
_TEXT	ENDS
PUBLIC	?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Mask
; Function compile flags: /Ogtpy
;	COMDAT ?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ
_TEXT	SEGMENT
?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Mask, COMDAT
; _this$ = ecx

; 1518 : 		return ((_Vbase)(1 << this->_Myoff));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, 1
	shl	eax, cl

; 1519 : 		}

	ret	0
?_Mask@?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@IBEIXZ ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Mask
_TEXT	ENDS
PUBLIC	??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*, COMDAT
; _this$ = ecx

; 1791 : 		return (_Reft(*this));

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 1792 : 		}

	ret	4
??D?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@XZ ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
_TEXT	ENDS
PUBLIC	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 1
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=, COMDAT
; _this$ = ecx

; 1475 : 		{	// assign _Val to bit

	mov	eax, ecx

; 1476 : 		if (_Val)
; 1477 : 			*_Getptr() |= _Mask();

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, 1
	shl	esi, cl
	cmp	BYTE PTR __Val$[esp], 0
	je	SHORT $LN2@operator@2
	or	DWORD PTR [edx], esi
	pop	esi

; 1480 : 		return (*this);
; 1481 : 		}

	ret	4
$LN2@operator@2:

; 1478 : 		else
; 1479 : 			*_Getptr() &= ~_Mask();

	not	esi
	and	DWORD PTR [edx], esi
	pop	esi

; 1480 : 		return (*this);
; 1481 : 		}

	ret	4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
_TEXT	ENDS
PUBLIC	??_7CvMapGenerator@@6B@				; CvMapGenerator::`vftable'
PUBLIC	??0CvMapGenerator@@QAE@PBD@Z			; CvMapGenerator::CvMapGenerator
PUBLIC	??_R4CvMapGenerator@@6B@			; CvMapGenerator::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvMapGenerator@@@8			; CvMapGenerator `RTTI Type Descriptor'
PUBLIC	??_R3CvMapGenerator@@8				; CvMapGenerator::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvMapGenerator@@8				; CvMapGenerator::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvMapGenerator@@8			; CvMapGenerator::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECvMapGenerator@@UAEPAXI@Z:PROC		; CvMapGenerator::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvMapGenerator@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvMapGenerator@@8 DD FLAT:??_R0?AVCvMapGenerator@@@8 ; CvMapGenerator::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvMapGenerator@@8
rdata$r	ENDS
;	COMDAT ??_R2CvMapGenerator@@8
rdata$r	SEGMENT
??_R2CvMapGenerator@@8 DD FLAT:??_R1A@?0A@EA@CvMapGenerator@@8 ; CvMapGenerator::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvMapGenerator@@8
rdata$r	SEGMENT
??_R3CvMapGenerator@@8 DD 00H				; CvMapGenerator::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvMapGenerator@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvMapGenerator@@@8
_DATA	SEGMENT
??_R0?AVCvMapGenerator@@@8 DD FLAT:??_7type_info@@6B@	; CvMapGenerator `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvMapGenerator@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvMapGenerator@@6B@
rdata$r	SEGMENT
??_R4CvMapGenerator@@6B@ DD 00H				; CvMapGenerator::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvMapGenerator@@@8
	DD	FLAT:??_R3CvMapGenerator@@8
rdata$r	ENDS
;	COMDAT ??_7CvMapGenerator@@6B@
CONST	SEGMENT
??_7CvMapGenerator@@6B@ DD FLAT:??_R4CvMapGenerator@@6B@ ; CvMapGenerator::`vftable'
	DD	FLAT:??_ECvMapGenerator@@UAEPAXI@Z
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmapgenerator.cpp
CONST	ENDS
;	COMDAT ??0CvMapGenerator@@QAE@PBD@Z
_TEXT	SEGMENT
_szMapScriptName$ = 8					; size = 4
??0CvMapGenerator@@QAE@PBD@Z PROC			; CvMapGenerator::CvMapGenerator, COMDAT
; _this$ = ecx

; 33   : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvMapGenerator@@6B@
	mov	DWORD PTR [esi+4], 0

; 34   : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	push	edi
	call	edx
	mov	edi, eax

; 35   : 	m_pkLuaState = pkScriptSystem->CreateLuaThread("Map Script");

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	OFFSET $SG217253
	mov	ecx, edi
	call	edx

; 36   : 	const bool bLoaded = pkScriptSystem->LoadFile(m_pkLuaState, szMapScriptName);

	mov	ecx, DWORD PTR _szMapScriptName$[esp+4]
	mov	DWORD PTR [esi+4], eax
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+8]
	push	ecx
	push	eax
	mov	ecx, edi
	call	edx
	pop	edi

; 37   : 	DEBUG_VARIABLE(bLoaded);
; 38   : 	CvAssertMsg(bLoaded, "Cannot load mapscript.");
; 39   : }

	mov	eax, esi
	pop	esi
	ret	4
??0CvMapGenerator@@QAE@PBD@Z ENDP			; CvMapGenerator::CvMapGenerator
_TEXT	ENDS
PUBLIC	??1CvMapGenerator@@UAE@XZ			; CvMapGenerator::~CvMapGenerator
; Function compile flags: /Ogtpy
;	COMDAT ??1CvMapGenerator@@UAE@XZ
_TEXT	SEGMENT
??1CvMapGenerator@@UAE@XZ PROC				; CvMapGenerator::~CvMapGenerator, COMDAT
; _this$ = ecx

; 42   : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvMapGenerator@@6B@

; 43   : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 44   : 	pkScriptSystem->FreeLuaThread(m_pkLuaState);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+4]
	push	ecx
	mov	ecx, eax
	call	edx
	pop	esi

; 45   : }

	ret	0
??1CvMapGenerator@@UAE@XZ ENDP				; CvMapGenerator::~CvMapGenerator
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	?GenerateRandomMap@CvMapGenerator@@QAEXXZ	; CvMapGenerator::GenerateRandomMap
EXTRN	_lua_gc:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GenerateRandomMap@CvMapGenerator@@QAEXXZ
_TEXT	SEGMENT
?GenerateRandomMap@CvMapGenerator@@QAEXXZ PROC		; CvMapGenerator::GenerateRandomMap, COMDAT
; _this$ = ecx

; 82   : {

	push	esi
	mov	esi, ecx

; 83   : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 84   : 
; 85   : 	pkScriptSystem->CallCFunction(m_pkLuaState, pGenerateRandomMap, pkScriptSystem);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+24]
	push	eax
	push	OFFSET ?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z ; CvMapGenerator::pGenerateRandomMap
	push	ecx
	mov	ecx, eax
	call	edx

; 86   : 
; 87   : 	lua_gc(m_pkLuaState, LUA_GCCOLLECT, 0);

	mov	eax, DWORD PTR [esi+4]
	push	0
	push	2
	push	eax
	call	_lua_gc
	add	esp, 12					; 0000000cH
	pop	esi

; 88   : }

	ret	0
?GenerateRandomMap@CvMapGenerator@@QAEXXZ ENDP		; CvMapGenerator::GenerateRandomMap
_TEXT	ENDS
PUBLIC	??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=, COMDAT
; _this$ = ecx

; 1822 : 		*(_Mybase *)this += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=

; 1823 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1824 : 		}

	ret	4
??Y?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
_TEXT	ENDS
PUBLIC	??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+, COMDAT
; _this$ = ecx

; 1827 : 		{	// return this + integer

	sub	esp, 8

; 1828 : 		_Mytype _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]

; 1829 : 		return (_Tmp += _Off);

	mov	edx, DWORD PTR __Off$[esp+4]
	mov	DWORD PTR __Tmp$[esp+12], ecx
	push	edx
	lea	ecx, DWORD PTR __Tmp$[esp+12]
	mov	DWORD PTR __Tmp$[esp+12], eax
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Tmp$[esp+8]
	mov	edx, DWORD PTR __Tmp$[esp+12]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1830 : 		}

	add	esp, 8
	ret	8
??H?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+
_TEXT	ENDS
PUBLIC	??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1567 : 		{	// construct with offset and pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1568 : 		}

	ret	4
??0?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PBI@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAI@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvMapGenerator@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvMapGenerator@@UAEPAXI@Z PROC			; CvMapGenerator::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvMapGenerator@@6B@
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+4]
	push	ecx
	mov	ecx, eax
	call	edx
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvMapGenerator@@UAEPAXI@Z ENDP			; CvMapGenerator::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CvWorldInfo@@QAE@XZ				; CvWorldInfo::~CvWorldInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CvWorldInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvWorldInfo@@QAE@XZ PROC				; CvWorldInfo::~CvWorldInfo, COMDAT
; _this$ = ecx
	jmp	??1CvBaseInfo@@QAE@XZ
??1CvWorldInfo@@QAE@XZ ENDP				; CvWorldInfo::~CvWorldInfo
_TEXT	ENDS
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
_TEXT	ENDS
PUBLIC	??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z PROC ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1786 : 		{	// construct with offset and pointer

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1787 : 		}

	ret	4
??0?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@PAI@Z ENDP ; std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z ; CvMapGenerator::GetMapInitData
EXTRN	__imp_??1Results@Database@@UAE@XZ:PROC
EXTRN	?getGridWidth@CvWorldInfo@@QBEHXZ:PROC		; CvWorldInfo::getGridWidth
EXTRN	?getGridHeight@CvWorldInfo@@QBEHXZ:PROC		; CvWorldInfo::getGridHeight
EXTRN	?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z:PROC ; CvBaseInfo::CacheResult
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHH@Z:PROC
EXTRN	__imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z:PROC
EXTRN	__imp_??0Results@Database@@QAE@PBD@Z:PROC
EXTRN	??0CvWorldInfo@@QAE@XZ:PROC			; CvWorldInfo::CvWorldInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmapgenerator.cpp
xdata$x	SEGMENT
__unwindtable$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z$1
__ehfuncinfo$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z
_TEXT	SEGMENT
_args$ = -432						; size = 16
_kQuery$ = -416						; size = 64
_kWorldInfo$ = -352					; size = 340
__$EHRec$ = -12						; size = 12
_kData$ = 8						; size = 4
_eWorldSize$ = 12					; size = 4
?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z PROC ; CvMapGenerator::GetMapInitData, COMDAT
; _this$ = ecx

; 48   : {

	push	-1
	push	__ehhandler$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 420				; 000001a4H
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 49   : 	CvWorldInfo	kWorldInfo;

	lea	ecx, DWORD PTR _kWorldInfo$[esp+444]
	call	??0CvWorldInfo@@QAE@XZ			; CvWorldInfo::CvWorldInfo

; 50   : 	Database::Connection& db = *GC.GetGameDatabase();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912

; 51   : 
; 52   : 	//Query
; 53   : 	Database::Results kQuery;

	push	0
	lea	ecx, DWORD PTR _kQuery$[esp+448]
	mov	DWORD PTR __$EHRec$[esp+456], 0
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z

; 54   : 	db.Execute(kQuery, "SELECT * from Worlds where ID = ? LIMIT 1");

	push	-1
	push	OFFSET $SG217272
	lea	eax, DWORD PTR _kQuery$[esp+452]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+464], 1
	call	DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z

; 55   : 	kQuery.Bind(1, eWorldSize);

	mov	ecx, DWORD PTR _eWorldSize$[esp+440]
	push	ecx
	push	1
	lea	ecx, DWORD PTR _kQuery$[esp+452]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHH@Z

; 56   : 
; 57   : 	if(kQuery.Step())

	lea	ecx, DWORD PTR _kQuery$[esp+444]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN2@GetMapInit

; 58   : 	{
; 59   : 		kWorldInfo.CacheResult(kQuery);

	lea	edx, DWORD PTR _kQuery$[esp+444]
	push	edx
	lea	ecx, DWORD PTR _kWorldInfo$[esp+448]
	call	?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z ; CvBaseInfo::CacheResult
$LN2@GetMapInit:

; 60   : 	}
; 61   : 	else
; 62   : 	{
; 63   : 		CvAssertMsg(false, "Could not find world size entry.")
; 64   : 	}
; 65   : 
; 66   : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 67   : 
; 68   : 	kData.m_iGridH = kWorldInfo.getGridHeight();

	lea	ecx, DWORD PTR _kWorldInfo$[esp+444]
	mov	esi, eax
	call	?getGridHeight@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getGridHeight
	mov	edi, DWORD PTR _kData$[esp+440]

; 69   : 	kData.m_iGridW = kWorldInfo.getGridWidth();

	lea	ecx, DWORD PTR _kWorldInfo$[esp+444]
	mov	DWORD PTR [edi+4], eax
	call	?getGridWidth@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getGridWidth
	mov	DWORD PTR [edi], eax

; 70   : 
; 71   : 	GetMapInitDataArgs args;
; 72   : 	args.pkScriptSystem = pkScriptSystem;
; 73   : 	args.pkMapInitData = &kData;
; 74   : 	args.WorldSize = kWorldInfo.GetID();

	mov	eax, DWORD PTR _kWorldInfo$[esp+448]

; 75   : 	args.bSuccess = false;
; 76   : 
; 77   : 	pkScriptSystem->CallCFunction(m_pkLuaState, pGetMapInitData, &args);

	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR _args$[esp+452], eax
	lea	eax, DWORD PTR _args$[esp+444]
	push	eax
	mov	DWORD PTR _args$[esp+448], esi
	mov	DWORD PTR _args$[esp+452], edi
	mov	BYTE PTR _args$[esp+460], 0
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+24]
	push	OFFSET ?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z ; CvMapGenerator::pGetMapInitData
	push	ecx
	mov	ecx, esi
	call	edx

; 78   : 	return args.bSuccess;

	mov	bl, BYTE PTR _args$[esp+456]
	lea	ecx, DWORD PTR _kQuery$[esp+444]
	mov	BYTE PTR __$EHRec$[esp+452], 0
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ
	lea	ecx, DWORD PTR _kWorldInfo$[esp+444]
	mov	DWORD PTR __$EHRec$[esp+452], -1
	call	??1CvBaseInfo@@QAE@XZ

; 79   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+444]
	pop	edi
	pop	esi
	mov	al, bl
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 432				; 000001b0H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z$0:
	lea	ecx, DWORD PTR _kWorldInfo$[ebp]
	jmp	??1CvWorldInfo@@QAE@XZ
__unwindfunclet$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z$1:
	lea	ecx, DWORD PTR _kQuery$[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__ehhandler$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z ENDP ; CvMapGenerator::GetMapInitData
PUBLIC	?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::begin, COMDAT
; _this$ = ecx

; 1985 : 		return (iterator(_VEC_ITER_BASE(_Myvec.begin())));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], 0

; 1986 : 		}

	ret	4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::begin
_TEXT	ENDS
PUBLIC	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z
_TEXT	SEGMENT
__Tmp$217831 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z PROC ; std::vector<bool,std::allocator<bool> >::operator[], COMDAT
; _this$ = ecx

; 2090 : 		{	// subscript mutable sequence

	sub	esp, 8

; 2091 : 		return (*(begin() + _Off));

	mov	ecx, DWORD PTR [ecx+8]
	xor	eax, eax
	mov	DWORD PTR __Tmp$217831[esp+12], eax
	mov	eax, DWORD PTR __Off$[esp+4]
	mov	DWORD PTR __Tmp$217831[esp+8], ecx
	push	eax
	lea	ecx, DWORD PTR __Tmp$217831[esp+12]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Tmp$217831[esp+8]
	mov	edx, DWORD PTR __Tmp$217831[esp+12]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 2092 : 		}

	add	esp, 8
	ret	8
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::operator[]
_TEXT	ENDS
PUBLIC	?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z ; CvMapGenerator::pGetGameInitialItemsOverrides
EXTRN	_lua_isnumber:PROC
EXTRN	_lua_next:PROC
EXTRN	_lua_pushnil:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmapgenerator.cpp
xdata$x	SEGMENT
__unwindtable$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z$0
__ehfuncinfo$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bOverride$217379 = -64					; size = 1
_bOverride$217368 = -64					; size = 1
_bOverride$217357 = -64					; size = 1
_bOverride$217346 = -64					; size = 1
_bOverride$217335 = -64					; size = 1
$T217859 = -60						; size = 8
$T217858 = -60						; size = 8
$T217857 = -60						; size = 8
$T217856 = -60						; size = 8
$T217855 = -60						; size = 8
_stopWatch$ = -52					; size = 40
__$EHRec$ = -12						; size = 12
_L$ = 8							; size = 4
?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z PROC ; CvMapGenerator::pGetGameInitialItemsOverrides, COMDAT

; 152  : {

	push	-1
	push	__ehhandler$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	ebp
	push	esi

; 153  : 	cvStopWatch stopWatch("CvMapGenerator - GetGameInitialItemsOverrides()");

	xor	ebx, ebx
	push	ebx
	push	ebx
	push	ebx
	push	ebx
	push	OFFSET $SG217320
	lea	ecx, DWORD PTR _stopWatch$[esp+96]
	call	??0cvStopWatch@@QAE@PBD0I_N1@Z		; cvStopWatch::cvStopWatch

; 154  : 	GetGameInitialItemsOverridesArgs* pArgs = (GetGameInitialItemsOverridesArgs*)lua_touserdata(L, 1);

	mov	esi, DWORD PTR _L$[esp+72]
	push	1
	push	esi
	mov	DWORD PTR __$EHRec$[esp+92], ebx
	call	_lua_touserdata

; 155  : 
; 156  : 	pArgs->bSuccess = false;
; 157  : 	lua_getglobal(L, "GetGameInitialItemsOverrides");

	push	OFFSET $SG217323
	mov	ebp, eax
	push	-10002					; ffffd8eeH
	push	esi
	mov	BYTE PTR [ebp+8], bl
	call	_lua_getfield

; 158  : 	if(lua_isfunction(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 28					; 0000001cH
	cmp	eax, 6
	jne	$LN26@pGetGameIn

; 159  : 	{
; 160  : 		pArgs->pkScriptSystem->CallFunction(L, 0, 1);

	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+28]
	push	1
	push	ebx
	push	esi
	call	edx

; 161  : 		const int t = lua_gettop(L);

	push	esi
	call	_lua_gettop
	mov	ebx, eax

; 162  : 		if(lua_istable(L, t))

	push	ebx
	push	esi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	$LN26@pGetGameIn
	push	edi

; 163  : 		{
; 164  : 
; 165  : 			//Initial Free Techs per Team
; 166  : 			lua_getfield(L, t, "GrantInitialFreeTechsPerTeam");

	push	OFFSET $SG217327
	push	ebx
	push	esi
	call	_lua_getfield

; 167  : 			if(lua_istable(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 5
	jne	$LN42@pGetGameIn

; 168  : 			{
; 169  : 				lua_pushnil(L);  /* first key */

	push	esi
	call	_lua_pushnil

; 170  : 				while(lua_next(L, -2) != 0)

	push	-2					; fffffffeH
	push	esi
	call	_lua_next
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN42@pGetGameIn
$LL24@pGetGameIn:

; 171  : 				{
; 172  : 					if(lua_isnumber(L, -2) && lua_isboolean(L, -1))

	push	-2					; fffffffeH
	push	esi
	call	_lua_isnumber
	add	esp, 8
	test	eax, eax
	je	SHORT $LN41@pGetGameIn
	push	-1
	push	esi
	call	_lua_type
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN41@pGetGameIn

; 173  : 					{
; 174  : 						const TeamTypes eTeam = static_cast<TeamTypes>(lua_tointeger(L, -2));

	push	-2					; fffffffeH
	push	esi
	call	_lua_tointeger

; 175  : 						const bool bOverride = lua_toboolean(L, -1);

	push	-1
	push	esi
	mov	edi, eax
	call	_lua_toboolean
	add	esp, 16					; 00000010H
	test	eax, eax
	setne	al
	mov	BYTE PTR _bOverride$217335[esp+80], al

; 176  : 						if(eTeam >= 0 && eTeam < MAX_TEAMS)

	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN41@pGetGameIn

; 177  : 						{
; 178  : 							pArgs->pkOverrides->GrantInitialFreeTechsPerTeam[eTeam] = bOverride;

	mov	ecx, DWORD PTR _bOverride$217335[esp+80]
	push	ecx
	mov	ecx, DWORD PTR [ebp+4]
	push	edi
	lea	edx, DWORD PTR $T217855[esp+88]
	push	edx
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	ecx, eax
	call	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
$LN41@pGetGameIn:

; 179  : 						}
; 180  : 					}
; 181  : 					lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	push	-2					; fffffffeH
	push	esi
	call	_lua_next
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LL24@pGetGameIn
$LN42@pGetGameIn:

; 182  : 				}
; 183  : 			}
; 184  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 185  : 
; 186  : 			//Initial Gold per Player
; 187  : 			lua_getfield(L, t, "GrantInitialGoldPerPlayer");

	push	OFFSET $SG217338
	push	ebx
	push	esi
	call	_lua_getfield

; 188  : 			if(lua_istable(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 28					; 0000001cH
	cmp	eax, 5
	jne	$LN18@pGetGameIn

; 189  : 			{
; 190  : 				lua_pushnil(L);  /* first key */

	push	esi
	call	_lua_pushnil

; 191  : 				while(lua_next(L, -2) != 0)

	push	-2					; fffffffeH
	push	esi
	call	_lua_next
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN18@pGetGameIn
$LL19@pGetGameIn:

; 192  : 				{
; 193  : 					if(lua_isnumber(L, -2) && lua_isboolean(L, -1))

	push	-2					; fffffffeH
	push	esi
	call	_lua_isnumber
	add	esp, 8
	test	eax, eax
	je	SHORT $LN43@pGetGameIn
	push	-1
	push	esi
	call	_lua_type
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN43@pGetGameIn

; 194  : 					{
; 195  : 						const PlayerTypes ePlayer = static_cast<PlayerTypes>(lua_tointeger(L, -2));

	push	-2					; fffffffeH
	push	esi
	call	_lua_tointeger

; 196  : 						const bool bOverride = lua_toboolean(L, -1);

	push	-1
	push	esi
	mov	edi, eax
	call	_lua_toboolean
	add	esp, 16					; 00000010H
	test	eax, eax
	setne	al
	mov	BYTE PTR _bOverride$217346[esp+80], al

; 197  : 						if(ePlayer >= 0 && ePlayer < MAX_PLAYERS)

	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN43@pGetGameIn

; 198  : 						{
; 199  : 							pArgs->pkOverrides->GrantInitialGoldPerPlayer[ePlayer] = bOverride;

	mov	ecx, DWORD PTR _bOverride$217346[esp+80]
	push	ecx
	mov	ecx, DWORD PTR [ebp+4]
	push	edi
	lea	edx, DWORD PTR $T217856[esp+88]
	push	edx
	add	ecx, 20					; 00000014H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	ecx, eax
	call	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
$LN43@pGetGameIn:

; 200  : 						}
; 201  : 					}
; 202  : 					lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	push	-2					; fffffffeH
	push	esi
	call	_lua_next
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LL19@pGetGameIn
$LN18@pGetGameIn:

; 203  : 				}
; 204  : 			}
; 205  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 206  : 
; 207  : 			//Initial Culture per Player
; 208  : 			lua_getfield(L, t, "GrantInitialCulturePerPlayer");

	push	OFFSET $SG217349
	push	ebx
	push	esi
	call	_lua_getfield

; 209  : 			if(lua_istable(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 28					; 0000001cH
	cmp	eax, 5
	jne	$LN13@pGetGameIn

; 210  : 			{
; 211  : 				lua_pushnil(L);  /* first key */

	push	esi
	call	_lua_pushnil

; 212  : 				while(lua_next(L, -2) != 0)

	push	-2					; fffffffeH
	push	esi
	call	_lua_next
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN13@pGetGameIn
	npad	2
$LL14@pGetGameIn:

; 213  : 				{
; 214  : 					if(lua_isnumber(L, -2) && lua_isboolean(L, -1))

	push	-2					; fffffffeH
	push	esi
	call	_lua_isnumber
	add	esp, 8
	test	eax, eax
	je	SHORT $LN44@pGetGameIn
	push	-1
	push	esi
	call	_lua_type
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN44@pGetGameIn

; 215  : 					{
; 216  : 						const PlayerTypes ePlayer = static_cast<PlayerTypes>(lua_tointeger(L, -2));

	push	-2					; fffffffeH
	push	esi
	call	_lua_tointeger

; 217  : 						const bool bOverride = lua_toboolean(L, -1);

	push	-1
	push	esi
	mov	edi, eax
	call	_lua_toboolean
	add	esp, 16					; 00000010H
	test	eax, eax
	setne	al
	mov	BYTE PTR _bOverride$217357[esp+80], al

; 218  : 						if(ePlayer >= 0 && ePlayer < MAX_PLAYERS)

	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN44@pGetGameIn

; 219  : 						{
; 220  : 							pArgs->pkOverrides->GrantInitialCulturePerPlayer[ePlayer] = bOverride;

	mov	ecx, DWORD PTR _bOverride$217357[esp+80]
	push	ecx
	mov	ecx, DWORD PTR [ebp+4]
	push	edi
	lea	edx, DWORD PTR $T217857[esp+88]
	push	edx
	add	ecx, 40					; 00000028H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	ecx, eax
	call	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
$LN44@pGetGameIn:

; 221  : 						}
; 222  : 					}
; 223  : 					lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	push	-2					; fffffffeH
	push	esi
	call	_lua_next
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LL14@pGetGameIn
$LN13@pGetGameIn:

; 224  : 				}
; 225  : 			}
; 226  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 227  : 
; 228  : 			//Clear research queue per Player
; 229  : 			lua_getfield(L, t, "ClearResearchQueuePerPlayer");

	push	OFFSET $SG217360
	push	ebx
	push	esi
	call	_lua_getfield

; 230  : 			if(lua_istable(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 28					; 0000001cH
	cmp	eax, 5
	jne	$LN8@pGetGameIn

; 231  : 			{
; 232  : 				lua_pushnil(L);  /* first key */

	push	esi
	call	_lua_pushnil

; 233  : 				while(lua_next(L, -2) != 0)

	push	-2					; fffffffeH
	push	esi
	call	_lua_next
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@pGetGameIn
$LL9@pGetGameIn:

; 234  : 				{
; 235  : 					if(lua_isnumber(L, -2) && lua_isboolean(L, -1))

	push	-2					; fffffffeH
	push	esi
	call	_lua_isnumber
	add	esp, 8
	test	eax, eax
	je	SHORT $LN45@pGetGameIn
	push	-1
	push	esi
	call	_lua_type
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN45@pGetGameIn

; 236  : 					{
; 237  : 						const PlayerTypes ePlayer = static_cast<PlayerTypes>(lua_tointeger(L, -2));

	push	-2					; fffffffeH
	push	esi
	call	_lua_tointeger

; 238  : 						const bool bOverride = lua_toboolean(L, -1);

	push	-1
	push	esi
	mov	edi, eax
	call	_lua_toboolean
	add	esp, 16					; 00000010H
	test	eax, eax
	setne	al
	mov	BYTE PTR _bOverride$217368[esp+80], al

; 239  : 						if(ePlayer >= 0 && ePlayer < MAX_PLAYERS)

	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN45@pGetGameIn

; 240  : 						{
; 241  : 							pArgs->pkOverrides->ClearResearchQueuePerPlayer[ePlayer] = bOverride;

	mov	ecx, DWORD PTR _bOverride$217368[esp+80]
	push	ecx
	mov	ecx, DWORD PTR [ebp+4]
	push	edi
	lea	edx, DWORD PTR $T217858[esp+88]
	push	edx
	add	ecx, 60					; 0000003cH
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	ecx, eax
	call	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
$LN45@pGetGameIn:

; 242  : 						}
; 243  : 					}
; 244  : 					lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	push	-2					; fffffffeH
	push	esi
	call	_lua_next
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LL9@pGetGameIn
$LN8@pGetGameIn:

; 245  : 				}
; 246  : 			}
; 247  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 248  : 
; 249  : 			//Initial Units per Player
; 250  : 			lua_getfield(L, t, "GrantInitialUnitsPerPlayer");

	push	OFFSET $SG217371
	push	ebx
	push	esi
	call	_lua_getfield

; 251  : 			if(lua_istable(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 28					; 0000001cH
	cmp	eax, 5
	jne	$LN3@pGetGameIn

; 252  : 			{
; 253  : 				lua_pushnil(L);  /* first key */

	push	esi
	call	_lua_pushnil

; 254  : 				while(lua_next(L, -2) != 0)

	push	-2					; fffffffeH
	push	esi
	call	_lua_next
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN3@pGetGameIn
	npad	6
$LL4@pGetGameIn:

; 255  : 				{
; 256  : 					if(lua_isnumber(L, -2) && lua_isboolean(L, -1))

	push	-2					; fffffffeH
	push	esi
	call	_lua_isnumber
	add	esp, 8
	test	eax, eax
	je	SHORT $LN46@pGetGameIn
	push	-1
	push	esi
	call	_lua_type
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN46@pGetGameIn

; 257  : 					{
; 258  : 						const PlayerTypes ePlayer = static_cast<PlayerTypes>(lua_tointeger(L, -2));

	push	-2					; fffffffeH
	push	esi
	call	_lua_tointeger

; 259  : 						const bool bOverride = lua_toboolean(L, -1);

	push	-1
	push	esi
	mov	edi, eax
	call	_lua_toboolean
	add	esp, 16					; 00000010H
	test	eax, eax
	setne	al
	mov	BYTE PTR _bOverride$217379[esp+80], al

; 260  : 						if(ePlayer >= 0 && ePlayer < MAX_PLAYERS)

	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN46@pGetGameIn

; 261  : 						{
; 262  : 							pArgs->pkOverrides->GrantInitialUnitsPerPlayer[ePlayer] = bOverride;

	mov	ecx, DWORD PTR _bOverride$217379[esp+80]
	push	ecx
	mov	ecx, DWORD PTR [ebp+4]
	push	edi
	lea	edx, DWORD PTR $T217859[esp+88]
	push	edx
	add	ecx, 80					; 00000050H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	ecx, eax
	call	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
$LN46@pGetGameIn:

; 263  : 						}
; 264  : 					}
; 265  : 					lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	push	-2					; fffffffeH
	push	esi
	call	_lua_next
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LL4@pGetGameIn
$LN3@pGetGameIn:

; 266  : 				}
; 267  : 			}
; 268  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop
	add	esp, 8

; 269  : 			pArgs->bSuccess = true;

	mov	BYTE PTR [ebp+8], 1
	pop	edi
$LN26@pGetGameIn:

; 270  : 		}
; 271  : 	}
; 272  : 
; 273  : 	return 0;

	lea	ecx, DWORD PTR _stopWatch$[esp+76]
	mov	DWORD PTR __$EHRec$[esp+84], -1
	call	??1cvStopWatch@@QAE@XZ			; cvStopWatch::~cvStopWatch

; 274  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 64					; 00000040H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z$0:
	lea	ecx, DWORD PTR _stopWatch$[ebp]
	jmp	??1cvStopWatch@@QAE@XZ			; cvStopWatch::~cvStopWatch
__ehhandler$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z ENDP ; CvMapGenerator::pGetGameInitialItemsOverrides
PUBLIC	?GetGameInitialItemsOverrides@CvMapGenerator@@QAE_NAAVCvGameInitialItemsOverrides@@@Z ; CvMapGenerator::GetGameInitialItemsOverrides
; Function compile flags: /Ogtpy
;	COMDAT ?GetGameInitialItemsOverrides@CvMapGenerator@@QAE_NAAVCvGameInitialItemsOverrides@@@Z
_TEXT	SEGMENT
_args$ = -12						; size = 12
_kOverrides$ = 8					; size = 4
?GetGameInitialItemsOverrides@CvMapGenerator@@QAE_NAAVCvGameInitialItemsOverrides@@@Z PROC ; CvMapGenerator::GetGameInitialItemsOverrides, COMDAT
; _this$ = ecx

; 91   : {

	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 92   : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 93   : 
; 94   : 	GetGameInitialItemsOverridesArgs args;
; 95   : 	args.pkScriptSystem = pkScriptSystem;
; 96   : 	args.pkOverrides = &kOverrides;

	mov	ecx, DWORD PTR _kOverrides$[esp+12]
	mov	DWORD PTR _args$[esp+20], ecx

; 97   : 	args.bSuccess = false;
; 98   : 
; 99   : 	pkScriptSystem->CallCFunction(m_pkLuaState, pGetGameInitialItemsOverrides, &args);

	lea	ecx, DWORD PTR _args$[esp+16]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _args$[esp+20], eax
	mov	BYTE PTR _args$[esp+28], 0
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+24]
	push	OFFSET ?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z ; CvMapGenerator::pGetGameInitialItemsOverrides
	push	ecx
	mov	ecx, eax
	call	edx

; 100  : 	return args.bSuccess;

	mov	al, BYTE PTR _args$[esp+24]
	pop	esi

; 101  : }

	add	esp, 12					; 0000000cH
	ret	4
?GetGameInitialItemsOverrides@CvMapGenerator@@QAE_NAAVCvGameInitialItemsOverrides@@@Z ENDP ; CvMapGenerator::GetGameInitialItemsOverrides
_TEXT	ENDS
END
