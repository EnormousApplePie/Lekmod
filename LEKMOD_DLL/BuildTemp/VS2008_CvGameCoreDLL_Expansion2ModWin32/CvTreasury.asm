; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Lekmod Files\Lekmod DLL versions\v29\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTreasury.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG217909 DB	'.csv', 00H
$SG217937 DB	00H
$SG217950 DB	00H
$SG217963 DB	00H
$SG217910 DB	'ExpenditureLog_', 00H
$SG217912 DB	'ExpenditureLog.csv', 00H
$SG217976 DB	00H
$SG217917 DB	'Civ Name', 00H
$SG217989 DB	00H
$SG218002 DB	00H
$SG218015 DB	00H
$SG217919 DB	'Turn', 00H
$SG218028 DB	00H
	ORG $+2
$SG217921 DB	'Treasury Before Purchase', 00H
	ORG $+3
$SG217924 DB	'Cost of Plot:', 00H
	ORG $+2
$SG217927 DB	'Cost of Plot:', 00H
	ORG $+2
$SG217931 DB	'City Bought:', 00H
	ORG $+3
$SG217933 DB	'City Spent:', 00H
$SG217938 DB	'City Bought:', 00H
	ORG $+3
$SG217940 DB	'City Spent:', 00H
$SG217944 DB	'Unit Upgraded:', 00H
	ORG $+1
$SG217946 DB	'Spent on Upgrade:', 00H
	ORG $+2
$SG217951 DB	'Unit Upgrade:', 00H
	ORG $+2
$SG217953 DB	'Spent on Upgrade:', 00H
	ORG $+2
$SG217957 DB	'City State Gold Gifted:', 00H
$SG217959 DB	'Gold Gift Amount:', 00H
	ORG $+2
$SG217964 DB	'City State Gold Gifted:', 00H
$SG217966 DB	'Gold Gift Amount:', 00H
	ORG $+2
$SG217970 DB	'City State Improved:', 00H
	ORG $+3
$SG217972 DB	'Gold for Improvement Amount:', 00H
	ORG $+3
$SG217977 DB	'City State Improved:', 00H
	ORG $+3
$SG217979 DB	'Gold for Improvement Amount:', 00H
	ORG $+3
$SG217983 DB	'City State Bought:', 00H
	ORG $+1
$SG217985 DB	'Bought for:', 00H
$SG217990 DB	'City State Bought:', 00H
	ORG $+1
$SG217992 DB	'Bought for:', 00H
$SG217996 DB	'Emergency Unit:', 00H
$SG217998 DB	'Emergency Unit Cost:', 00H
	ORG $+3
$SG218003 DB	'Emergency Unit:', 00H
$SG218005 DB	'Emergency Unit Cost:', 00H
	ORG $+3
$SG218009 DB	'Emergency Building:', 00H
$SG218011 DB	'Emergency Building Cost:', 00H
	ORG $+3
$SG218016 DB	'Emergency Building:', 00H
$SG218018 DB	'Emergency Building Cost:', 00H
	ORG $+3
$SG218022 DB	'Research Agreement with:', 00H
	ORG $+3
$SG218024 DB	'Research Agreement Cost:', 00H
	ORG $+3
$SG218029 DB	'Research Agreement with:', 00H
	ORG $+3
$SG218031 DB	'Research Agreement Cost:', 00H
	ORG $+3
$SG218049 DB	',', 00H
	ORG $+2
$SG218050 DB	',', 00H
	ORG $+2
$SG218057 DB	',', 00H
	ORG $+2
$SG218059 DB	'%d,', 00H
$SG218066 DB	',', 00H
	ORG $+2
$SG218068 DB	'%.2f,', 00H
CONST	ENDS
PUBLIC	?Uninit@CvTreasury@@QAEXXZ			; CvTreasury::Uninit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
;	COMDAT ?Uninit@CvTreasury@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvTreasury@@QAEXXZ PROC				; CvTreasury::Uninit, COMDAT
; _this$ = ecx

; 74   : 
; 75   : }

	ret	0
?Uninit@CvTreasury@@QAEXXZ ENDP				; CvTreasury::Uninit
_TEXT	ENDS
PUBLIC	?GetGold@CvTreasury@@QBEHXZ			; CvTreasury::GetGold
; Function compile flags: /Ogtpy
;	COMDAT ?GetGold@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
?GetGold@CvTreasury@@QBEHXZ PROC			; CvTreasury::GetGold, COMDAT
; _this$ = ecx

; 155  : 	return m_iGold / 100;

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 156  : }

	ret	0
?GetGold@CvTreasury@@QBEHXZ ENDP			; CvTreasury::GetGold
_TEXT	ENDS
PUBLIC	?GetGoldTimes100@CvTreasury@@QBEHXZ		; CvTreasury::GetGoldTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldTimes100@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
?GetGoldTimes100@CvTreasury@@QBEHXZ PROC		; CvTreasury::GetGoldTimes100, COMDAT
; _this$ = ecx

; 173  : 	return m_iGold;

	mov	eax, DWORD PTR [ecx+8]

; 174  : }

	ret	0
?GetGoldTimes100@CvTreasury@@QBEHXZ ENDP		; CvTreasury::GetGoldTimes100
_TEXT	ENDS
PUBLIC	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z	; CvTreasury::GetGoldFromCitiesTimes100
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRateTimes100
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
_bExcludeTradeRoutes$ = 8				; size = 1
?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z PROC	; CvTreasury::GetGoldFromCitiesTimes100, COMDAT
; _this$ = ecx

; 224  : {

	push	ecx
	push	esi
	push	edi

; 225  : 	int iGold = 0;

	xor	edi, edi
	mov	esi, ecx

; 226  : 
; 227  : 	CvCity* pLoopCity;
; 228  : 
; 229  : 	int iLoop;
; 230  : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	lea	eax, DWORD PTR _iLoop$[esp+16]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN8@GetGoldFro
	push	ebx
	mov	ebx, DWORD PTR _bExcludeTradeRoutes$[esp+12]
	npad	2
$LL3@GetGoldFro:

; 231  : 	{
; 232  : 		iGold += pLoopCity->getYieldRateTimes100(YIELD_GOLD, bExcludeTradeRoutes);

	push	ebx
	push	2
	mov	ecx, eax
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	add	edi, eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL3@GetGoldFro
	pop	ebx
$LN8@GetGoldFro:

; 233  : 	}
; 234  : 
; 235  : 	return iGold;

	mov	eax, edi
	pop	edi
	pop	esi

; 236  : }

	pop	ecx
	ret	4
?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ENDP	; CvTreasury::GetGoldFromCitiesTimes100
_TEXT	ENDS
PUBLIC	?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ	; CvTreasury::GetGoldPerTurnFromDiplomacy
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetGoldPerTurnFromDiplomacy, COMDAT
; _this$ = ecx

; 241  : 	return m_iGoldPerTurnFromDiplomacy;

	mov	eax, DWORD PTR [ecx+12]

; 242  : }

	ret	0
?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetGoldPerTurnFromDiplomacy
_TEXT	ENDS
PUBLIC	?SetGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::SetGoldPerTurnFromDiplomacy
; Function compile flags: /Ogtpy
;	COMDAT ?SetGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z PROC	; CvTreasury::SetGoldPerTurnFromDiplomacy, COMDAT
; _this$ = ecx

; 247  : 	m_iGoldPerTurnFromDiplomacy = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 248  : }

	ret	4
?SetGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ENDP	; CvTreasury::SetGoldPerTurnFromDiplomacy
_TEXT	ENDS
PUBLIC	?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeGoldPerTurnFromDiplomacy
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z PROC ; CvTreasury::ChangeGoldPerTurnFromDiplomacy, COMDAT
; _this$ = ecx

; 253  : 	SetGoldPerTurnFromDiplomacy(GetGoldPerTurnFromDiplomacy() + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+12], eax

; 254  : }

	ret	4
?ChangeGoldPerTurnFromDiplomacy@CvTreasury@@QAEXH@Z ENDP ; CvTreasury::ChangeGoldPerTurnFromDiplomacy
_TEXT	ENDS
PUBLIC	?GetCityConnectionGold@CvTreasury@@QBEHXZ	; CvTreasury::GetCityConnectionGold
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityConnectionGold@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
?GetCityConnectionGold@CvTreasury@@QBEHXZ PROC		; CvTreasury::GetCityConnectionGold, COMDAT
; _this$ = ecx

; 289  : 	return m_iCityConnectionGoldTimes100 / 100;

	mov	ecx, DWORD PTR [ecx+24]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 290  : }

	ret	0
?GetCityConnectionGold@CvTreasury@@QBEHXZ ENDP		; CvTreasury::GetCityConnectionGold
_TEXT	ENDS
PUBLIC	?GetCityConnectionGoldTimes100@CvTreasury@@QBEHXZ ; CvTreasury::GetCityConnectionGoldTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityConnectionGoldTimes100@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
?GetCityConnectionGoldTimes100@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetCityConnectionGoldTimes100, COMDAT
; _this$ = ecx

; 295  : 	return m_iCityConnectionGoldTimes100;

	mov	eax, DWORD PTR [ecx+24]

; 296  : }

	ret	0
?GetCityConnectionGoldTimes100@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetCityConnectionGoldTimes100
_TEXT	ENDS
PUBLIC	?GetCityConnectionTradeRouteGoldModifier@CvTreasury@@QBEHXZ ; CvTreasury::GetCityConnectionTradeRouteGoldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityConnectionTradeRouteGoldModifier@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
?GetCityConnectionTradeRouteGoldModifier@CvTreasury@@QBEHXZ PROC ; CvTreasury::GetCityConnectionTradeRouteGoldModifier, COMDAT
; _this$ = ecx

; 330  : 	return m_iCityConnectionTradeRouteGoldModifier;

	mov	eax, DWORD PTR [ecx+28]

; 331  : }

	ret	0
?GetCityConnectionTradeRouteGoldModifier@CvTreasury@@QBEHXZ ENDP ; CvTreasury::GetCityConnectionTradeRouteGoldModifier
_TEXT	ENDS
PUBLIC	?GetCityConnectionTradeRouteGoldChange@CvTreasury@@QBEHXZ ; CvTreasury::GetCityConnectionTradeRouteGoldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityConnectionTradeRouteGoldChange@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
?GetCityConnectionTradeRouteGoldChange@CvTreasury@@QBEHXZ PROC ; CvTreasury::GetCityConnectionTradeRouteGoldChange, COMDAT
; _this$ = ecx

; 347  : 	return m_iCityConnectionTradeRouteGoldChange;

	mov	eax, DWORD PTR [ecx+32]

; 348  : }

	ret	0
?GetCityConnectionTradeRouteGoldChange@CvTreasury@@QBEHXZ ENDP ; CvTreasury::GetCityConnectionTradeRouteGoldChange
_TEXT	ENDS
PUBLIC	?GetGoldPerTurnFromTradeRoutes@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromTradeRoutes
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldPerTurnFromTradeRoutes@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
?GetGoldPerTurnFromTradeRoutes@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetGoldPerTurnFromTradeRoutes, COMDAT
; _this$ = ecx

; 432  : 	// needs fixin
; 433  : 	return 0;

	xor	eax, eax

; 434  : 	//return GetGoldPerTurnFromTradeRoutesTimes100() / 100;
; 435  : }

	ret	0
?GetGoldPerTurnFromTradeRoutes@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetGoldPerTurnFromTradeRoutes
_TEXT	ENDS
PUBLIC	?GetGoldPerTurnFromTradeRoutesTimes100@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromTradeRoutesTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldPerTurnFromTradeRoutesTimes100@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
?GetGoldPerTurnFromTradeRoutesTimes100@CvTreasury@@QBEHXZ PROC ; CvTreasury::GetGoldPerTurnFromTradeRoutesTimes100, COMDAT
; _this$ = ecx

; 440  : 	return 0;

	xor	eax, eax

; 441  : 	//return m_pPlayer->GetTrade()->GetAllTradeValueTimes100(YIELD_GOLD);
; 442  : }

	ret	0
?GetGoldPerTurnFromTradeRoutesTimes100@CvTreasury@@QBEHXZ ENDP ; CvTreasury::GetGoldPerTurnFromTradeRoutesTimes100
_TEXT	ENDS
PUBLIC	?GetLifetimeGrossGold@CvTreasury@@QAEHXZ	; CvTreasury::GetLifetimeGrossGold
; Function compile flags: /Ogtpy
;	COMDAT ?GetLifetimeGrossGold@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
?GetLifetimeGrossGold@CvTreasury@@QAEHXZ PROC		; CvTreasury::GetLifetimeGrossGold, COMDAT
; _this$ = ecx

; 519  : 	return m_iLifetimeGrossGoldIncome;

	mov	eax, DWORD PTR [ecx+44]

; 520  : }

	ret	0
?GetLifetimeGrossGold@CvTreasury@@QAEHXZ ENDP		; CvTreasury::GetLifetimeGrossGold
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	?GetBaseBuildingGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetBaseBuildingGoldMaintenance
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
;	COMDAT ?GetBaseBuildingGoldMaintenance@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
?GetBaseBuildingGoldMaintenance@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetBaseBuildingGoldMaintenance, COMDAT
; _this$ = ecx

; 811  : 	return m_iBaseBuildingGoldMaintenance;

	mov	eax, DWORD PTR [ecx+36]

; 812  : }

	ret	0
?GetBaseBuildingGoldMaintenance@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetBaseBuildingGoldMaintenance
_TEXT	ENDS
PUBLIC	?SetBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::SetBaseBuildingGoldMaintenance
; Function compile flags: /Ogtpy
;	COMDAT ?SetBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z PROC ; CvTreasury::SetBaseBuildingGoldMaintenance, COMDAT
; _this$ = ecx

; 817  : 	m_iBaseBuildingGoldMaintenance = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+36], eax

; 818  : 
; 819  : 	if(m_iBaseBuildingGoldMaintenance < 0)

	test	eax, eax
	jge	SHORT $LN1@SetBaseBui

; 820  : 		m_iBaseBuildingGoldMaintenance = 0;

	mov	DWORD PTR [ecx+36], 0
$LN1@SetBaseBui:

; 821  : 
; 822  : 	CvAssertMsg(m_iBaseBuildingGoldMaintenance >= 0, "Building Maintenance is negative somehow. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 823  : }

	ret	4
?SetBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z ENDP ; CvTreasury::SetBaseBuildingGoldMaintenance
_TEXT	ENDS
PUBLIC	?ChangeBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseBuildingGoldMaintenance
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z PROC ; CvTreasury::ChangeBaseBuildingGoldMaintenance, COMDAT
; _this$ = ecx

; 828  : 	SetBaseBuildingGoldMaintenance(GetBaseBuildingGoldMaintenance() + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+36], eax
	jns	SHORT $LN5@ChangeBase
	mov	DWORD PTR [ecx+36], 0
$LN5@ChangeBase:

; 829  : }

	ret	4
?ChangeBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z ENDP ; CvTreasury::ChangeBaseBuildingGoldMaintenance
_TEXT	ENDS
PUBLIC	?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetImprovementGoldMaintenance
EXTRN	?getRouteCostPercent@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getRouteCostPercent
EXTRN	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvPlayer::getHandicapInfo
EXTRN	?GetRouteGoldMaintenanceMod@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetRouteGoldMaintenanceMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetImprovementGoldMaintenance, COMDAT
; _this$ = ecx

; 833  : {

	push	esi
	push	edi
	mov	edi, ecx

; 834  : 	int iMaintenance = m_iBaseImprovementGoldMaintenance;
; 835  : 
; 836  : 	// Player modifier
; 837  : 	iMaintenance *= (100 + m_pPlayer->GetRouteGoldMaintenanceMod());

	mov	ecx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [edi+40]
	call	?GetRouteGoldMaintenanceMod@CvPlayer@@QBEHXZ ; CvPlayer::GetRouteGoldMaintenanceMod
	mov	ecx, eax
	add	ecx, 100				; 00000064H
	imul	ecx, esi

; 838  : 	iMaintenance /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 839  : 
; 840  : 	// Handicap
; 841  : 	iMaintenance *= m_pPlayer->getHandicapInfo().getRouteCostPercent();

	mov	ecx, DWORD PTR [edi+4]
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	call	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ ; CvPlayer::getHandicapInfo
	mov	ecx, eax
	call	?getRouteCostPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getRouteCostPercent
	mov	ecx, eax
	imul	ecx, esi

; 842  : 	iMaintenance /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	edi
	add	eax, edx
	pop	esi

; 843  : 
; 844  : 	return iMaintenance;
; 845  : }

	ret	0
?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetImprovementGoldMaintenance
_TEXT	ENDS
PUBLIC	?GetBaseImprovementGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetBaseImprovementGoldMaintenance
; Function compile flags: /Ogtpy
;	COMDAT ?GetBaseImprovementGoldMaintenance@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
?GetBaseImprovementGoldMaintenance@CvTreasury@@QBEHXZ PROC ; CvTreasury::GetBaseImprovementGoldMaintenance, COMDAT
; _this$ = ecx

; 850  : 	return m_iBaseImprovementGoldMaintenance;

	mov	eax, DWORD PTR [ecx+40]

; 851  : }

	ret	0
?GetBaseImprovementGoldMaintenance@CvTreasury@@QBEHXZ ENDP ; CvTreasury::GetBaseImprovementGoldMaintenance
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@H$00@@QAEAAHI@Z			; BaseVector<int,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@H$00@@QAEAAHI@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@H$00@@QAEAAHI@Z PROC			; BaseVector<int,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@H$00@@QAEAAHI@Z ENDP			; BaseVector<int,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@H$00@@QBEIXZ			; BaseVector<int,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@H$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@H$00@@QBEIXZ PROC			; BaseVector<int,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@H$00@@QBEIXZ ENDP			; BaseVector<int,1>::size
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@HV?$allocator@H@std@@@0@AAPAH@Z ; std::_Ptr_cat<std::_Vector_iterator<int,std::allocator<int> >,int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@HV?$allocator@H@std@@@0@AAPAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@HV?$allocator@H@std@@@0@AAPAH@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<int,std::allocator<int> >,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAH@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@HV?$allocator@H@std@@@0@AAPAH@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<int,std::allocator<int> >,int *>
_TEXT	ENDS
PUBLIC	??$_Construct@HH@std@@YAXPAHABH@Z		; std::_Construct<int,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@HH@std@@YAXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@HH@std@@YAXPAHABH@Z PROC			; std::_Construct<int,int>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@HH@std@@YAXPAHABH@Z ENDP			; std::_Construct<int,int>
_TEXT	ENDS
PUBLIC	??$_Destroy@H@std@@YAXPAH@Z			; std::_Destroy<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@H@std@@YAXPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@H@std@@YAXPAH@Z PROC			; std::_Destroy<int>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@H@std@@YAXPAH@Z ENDP			; std::_Destroy<int>
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getINITIAL_FREE_OUTSIDE_UNITS@CvGlobals@@QAEHXZ ; CvGlobals::getINITIAL_FREE_OUTSIDE_UNITS
; Function compile flags: /Ogtpy
;	COMDAT ?getINITIAL_FREE_OUTSIDE_UNITS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getINITIAL_FREE_OUTSIDE_UNITS@CvGlobals@@QAEHXZ PROC	; CvGlobals::getINITIAL_FREE_OUTSIDE_UNITS, COMDAT
; _this$ = ecx

; 5592 : 		return m_iINITIAL_FREE_OUTSIDE_UNITS;

	mov	eax, DWORD PTR [ecx+6516]

; 5593 : 	}

	ret	0
?getINITIAL_FREE_OUTSIDE_UNITS@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getINITIAL_FREE_OUTSIDE_UNITS
_TEXT	ENDS
PUBLIC	?getINITIAL_OUTSIDE_UNIT_GOLD_PERCENT@CvGlobals@@QAEHXZ ; CvGlobals::getINITIAL_OUTSIDE_UNIT_GOLD_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getINITIAL_OUTSIDE_UNIT_GOLD_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getINITIAL_OUTSIDE_UNIT_GOLD_PERCENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getINITIAL_OUTSIDE_UNIT_GOLD_PERCENT, COMDAT
; _this$ = ecx

; 5596 : 		return m_iINITIAL_OUTSIDE_UNIT_GOLD_PERCENT;

	mov	eax, DWORD PTR [ecx+6520]

; 5597 : 	}

	ret	0
?getINITIAL_OUTSIDE_UNIT_GOLD_PERCENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getINITIAL_OUTSIDE_UNIT_GOLD_PERCENT
_TEXT	ENDS
PUBLIC	?getUNIT_MAINTENANCE_GAME_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getUNIT_MAINTENANCE_GAME_MULTIPLIER
; Function compile flags: /Ogtpy
;	COMDAT ?getUNIT_MAINTENANCE_GAME_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getUNIT_MAINTENANCE_GAME_MULTIPLIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getUNIT_MAINTENANCE_GAME_MULTIPLIER, COMDAT
; _this$ = ecx

; 5600 : 		return m_iUNIT_MAINTENANCE_GAME_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+6524]

; 5601 : 	}

	ret	0
?getUNIT_MAINTENANCE_GAME_MULTIPLIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getUNIT_MAINTENANCE_GAME_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getUNIT_MAINTENANCE_GAME_EXPONENT_DIVISOR@CvGlobals@@QAEHXZ ; CvGlobals::getUNIT_MAINTENANCE_GAME_EXPONENT_DIVISOR
; Function compile flags: /Ogtpy
;	COMDAT ?getUNIT_MAINTENANCE_GAME_EXPONENT_DIVISOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getUNIT_MAINTENANCE_GAME_EXPONENT_DIVISOR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getUNIT_MAINTENANCE_GAME_EXPONENT_DIVISOR, COMDAT
; _this$ = ecx

; 5604 : 		return m_iUNIT_MAINTENANCE_GAME_EXPONENT_DIVISOR;

	mov	eax, DWORD PTR [ecx+6528]

; 5605 : 	}

	ret	0
?getUNIT_MAINTENANCE_GAME_EXPONENT_DIVISOR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getUNIT_MAINTENANCE_GAME_EXPONENT_DIVISOR
_TEXT	ENDS
PUBLIC	?getTRADE_ROUTE_BASE_GOLD@CvGlobals@@QAEHXZ	; CvGlobals::getTRADE_ROUTE_BASE_GOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getTRADE_ROUTE_BASE_GOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getTRADE_ROUTE_BASE_GOLD@CvGlobals@@QAEHXZ PROC	; CvGlobals::getTRADE_ROUTE_BASE_GOLD, COMDAT
; _this$ = ecx

; 5612 : 		return m_iTRADE_ROUTE_BASE_GOLD;

	mov	eax, DWORD PTR [ecx+6536]

; 5613 : 	}

	ret	0
?getTRADE_ROUTE_BASE_GOLD@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getTRADE_ROUTE_BASE_GOLD
_TEXT	ENDS
PUBLIC	?getTRADE_ROUTE_CAPITAL_POP_GOLD_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getTRADE_ROUTE_CAPITAL_POP_GOLD_MULTIPLIER
; Function compile flags: /Ogtpy
;	COMDAT ?getTRADE_ROUTE_CAPITAL_POP_GOLD_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getTRADE_ROUTE_CAPITAL_POP_GOLD_MULTIPLIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getTRADE_ROUTE_CAPITAL_POP_GOLD_MULTIPLIER, COMDAT
; _this$ = ecx

; 5616 : 		return m_iTRADE_ROUTE_CAPITAL_POP_GOLD_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+6540]

; 5617 : 	}

	ret	0
?getTRADE_ROUTE_CAPITAL_POP_GOLD_MULTIPLIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getTRADE_ROUTE_CAPITAL_POP_GOLD_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getTRADE_ROUTE_CITY_POP_GOLD_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getTRADE_ROUTE_CITY_POP_GOLD_MULTIPLIER
; Function compile flags: /Ogtpy
;	COMDAT ?getTRADE_ROUTE_CITY_POP_GOLD_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getTRADE_ROUTE_CITY_POP_GOLD_MULTIPLIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getTRADE_ROUTE_CITY_POP_GOLD_MULTIPLIER, COMDAT
; _this$ = ecx

; 5620 : 		return m_iTRADE_ROUTE_CITY_POP_GOLD_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+6544]

; 5621 : 	}

	ret	0
?getTRADE_ROUTE_CITY_POP_GOLD_MULTIPLIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getTRADE_ROUTE_CITY_POP_GOLD_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getDEFICIT_UNIT_DISBANDING_THRESHOLD@CvGlobals@@QAEHXZ ; CvGlobals::getDEFICIT_UNIT_DISBANDING_THRESHOLD
; Function compile flags: /Ogtpy
;	COMDAT ?getDEFICIT_UNIT_DISBANDING_THRESHOLD@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getDEFICIT_UNIT_DISBANDING_THRESHOLD@CvGlobals@@QAEHXZ PROC ; CvGlobals::getDEFICIT_UNIT_DISBANDING_THRESHOLD, COMDAT
; _this$ = ecx

; 5624 : 		return m_iDEFICIT_UNIT_DISBANDING_THRESHOLD;

	mov	eax, DWORD PTR [ecx+6548]

; 5625 : 	}

	ret	0
?getDEFICIT_UNIT_DISBANDING_THRESHOLD@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getDEFICIT_UNIT_DISBANDING_THRESHOLD
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7713 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8568]

; 7714 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?GetLandUnitMaintenanceModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetLandUnitMaintenanceModifier
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.h
;	COMDAT ?GetLandUnitMaintenanceModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetLandUnitMaintenanceModifier@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetLandUnitMaintenanceModifier, COMDAT
; _this$ = ecx

; 627  : 		return m_iLandUnitMaintenanceModifier;

	mov	eax, DWORD PTR [ecx+240]

; 628  : 	};

	ret	0
?GetLandUnitMaintenanceModifier@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetLandUnitMaintenanceModifier
_TEXT	ENDS
PUBLIC	?GetNavalUnitMaintenanceModifier@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetNavalUnitMaintenanceModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetNavalUnitMaintenanceModifier@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetNavalUnitMaintenanceModifier@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetNavalUnitMaintenanceModifier, COMDAT
; _this$ = ecx

; 631  : 		return m_iNavalUnitMaintenanceModifier;

	mov	eax, DWORD PTR [ecx+244]

; 632  : 	};

	ret	0
?GetNavalUnitMaintenanceModifier@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetNavalUnitMaintenanceModifier
_TEXT	ENDS
PUBLIC	?GetYieldChangePerTradePartner@CvPlayerTraits@@QBEHW4YieldTypes@@@Z ; CvPlayerTraits::GetYieldChangePerTradePartner
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangePerTradePartner@CvPlayerTraits@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_eYield$ = 8						; size = 4
?GetYieldChangePerTradePartner@CvPlayerTraits@@QBEHW4YieldTypes@@@Z PROC ; CvPlayerTraits::GetYieldChangePerTradePartner, COMDAT
; _this$ = ecx

; 847  : 		return m_iYieldChangePerTradePartner[(int)eYield];

	mov	eax, DWORD PTR _eYield$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+496]

; 848  : 	};

	ret	4
?GetYieldChangePerTradePartner@CvPlayerTraits@@QBEHW4YieldTypes@@@Z ENDP ; CvPlayerTraits::GetYieldChangePerTradePartner
_TEXT	ENDS
PUBLIC	?GetTradePartnerYieldFlatBonusPerEra@CvPlayerTraits@@QBEHXZ ; CvPlayerTraits::GetTradePartnerYieldFlatBonusPerEra
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradePartnerYieldFlatBonusPerEra@CvPlayerTraits@@QBEHXZ
_TEXT	SEGMENT
?GetTradePartnerYieldFlatBonusPerEra@CvPlayerTraits@@QBEHXZ PROC ; CvPlayerTraits::GetTradePartnerYieldFlatBonusPerEra, COMDAT
; _this$ = ecx

; 852  : 		return 1; //m_iYieldChangePerTradePartner[(int)eYield]; // TODO: finish this to get the trait "TradePartnerYieldFlatBonusPerEra" from SQL

	mov	eax, 1

; 853  : 	};

	ret	0
?GetTradePartnerYieldFlatBonusPerEra@CvPlayerTraits@@QBEHXZ ENDP ; CvPlayerTraits::GetTradePartnerYieldFlatBonusPerEra
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T218939 = -80						; size = 28
$T218938 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T218939[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T218938[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T218939[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T218938[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T218938[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T218938[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T218938[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T218939[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T218938[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T219002 = -12						; size = 12
$T219006 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T219006[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T219002[esp+16]
	mov	DWORD PTR $T219006[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T219002[esp+16]
	push	ecx
	mov	DWORD PTR $T219002[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
$T219054 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx

; 70   : 		m_saveTo << container.size();

	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T219054[esp]
	sar	edx, 2
	push	eax
	mov	DWORD PTR $T219054[esp+4], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAEXABH@Z ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAEXABH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAEXABH@Z PROC ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::operator(), COMDAT
; _this$ = ecx

; 75   : 		m_saveTo << i;

	mov	ecx, DWORD PTR [ecx]
	jmp	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
??R?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAEXABH@Z ENDP ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::operator()
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?GetGoldFromCities@CvTreasury@@QBEHXZ		; CvTreasury::GetGoldFromCities
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
;	COMDAT ?GetGoldFromCities@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
?GetGoldFromCities@CvTreasury@@QBEHXZ PROC		; CvTreasury::GetGoldFromCities, COMDAT
; _this$ = ecx

; 219  : 	return GetGoldFromCitiesTimes100() / 100;

	push	0
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100
	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 220  : }

	ret	0
?GetGoldFromCities@CvTreasury@@QBEHXZ ENDP		; CvTreasury::GetGoldFromCities
_TEXT	ENDS
PUBLIC	?GetCityConnectionRouteGoldTimes100@CvTreasury@@QBEHPAVCvCity@@@Z ; CvTreasury::GetCityConnectionRouteGoldTimes100
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityConnectionRouteGoldTimes100@CvTreasury@@QBEHPAVCvCity@@@Z
_TEXT	SEGMENT
_iTradeRouteCityGoldMultiplier$ = -4			; size = 4
_pNonCapitalCity$ = 8					; size = 4
?GetCityConnectionRouteGoldTimes100@CvTreasury@@QBEHPAVCvCity@@@Z PROC ; CvTreasury::GetCityConnectionRouteGoldTimes100, COMDAT
; _this$ = ecx

; 258  : {

	push	ecx
	push	edi
	mov	edi, ecx

; 259  : 	CvCity* pCapitalCity = m_pPlayer->getCapitalCity();

	mov	ecx, DWORD PTR [edi+4]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 260  : 	if(!pNonCapitalCity || pNonCapitalCity == pCapitalCity || pCapitalCity == NULL)

	mov	ecx, DWORD PTR _pNonCapitalCity$[esp+4]
	test	ecx, ecx
	je	SHORT $LN2@GetCityCon
	cmp	ecx, eax
	je	SHORT $LN2@GetCityCon
	test	eax, eax
	je	SHORT $LN2@GetCityCon

; 263  : 	}
; 264  : 
; 265  : 	int iGold = 0;
; 266  : 
; 267  : 	int iTradeRouteBaseGold = /*100*/ GC.getTRADE_ROUTE_BASE_GOLD();
; 268  : 	int iTradeRouteCapitalGoldMultiplier = /*0*/ GC.getTRADE_ROUTE_CAPITAL_POP_GOLD_MULTIPLIER();
; 269  : 	int iTradeRouteCityGoldMultiplier = /*125*/ GC.getTRADE_ROUTE_CITY_POP_GOLD_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6544
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6536
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6540
	mov	DWORD PTR _iTradeRouteCityGoldMultiplier$[esp+16], ecx
	push	esi

; 270  : 
; 271  : 	iGold += iTradeRouteBaseGold;	// Base Gold: 0
; 272  : 	iGold += (pCapitalCity->getPopulation() * iTradeRouteCapitalGoldMultiplier);	// Capital Multiplier

	mov	ecx, eax
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation

; 273  : 	iGold += (pNonCapitalCity->getPopulation() * iTradeRouteCityGoldMultiplier);	// City Multiplier

	mov	ecx, DWORD PTR _pNonCapitalCity$[esp+16]
	mov	esi, eax
	imul	esi, ebp
	add	esi, ebx
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	imul	eax, DWORD PTR _iTradeRouteCityGoldMultiplier$[esp+20]

; 274  : 	iGold += GetCityConnectionTradeRouteGoldChange() * 100;

	mov	edx, DWORD PTR [edi+32]

; 275  : 
; 276  : 	if(GetCityConnectionTradeRouteGoldModifier() != 0)

	mov	edi, DWORD PTR [edi+28]
	imul	edx, 100				; 00000064H
	add	esi, eax
	add	esi, edx
	test	edi, edi
	je	SHORT $LN1@GetCityCon

; 277  : 	{
; 278  : 		iGold *= (100 + GetCityConnectionTradeRouteGoldModifier());

	lea	ecx, DWORD PTR [edi+100]
	imul	ecx, esi

; 279  : 		iGold /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax
$LN1@GetCityCon:

; 280  : 	}
; 281  : 
; 282  : 	return iGold;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 283  : }

	pop	ecx
	ret	4
$LN2@GetCityCon:

; 261  : 	{
; 262  : 		return 0;

	xor	eax, eax
	pop	edi

; 283  : }

	pop	ecx
	ret	4
?GetCityConnectionRouteGoldTimes100@CvTreasury@@QBEHPAVCvCity@@@Z ENDP ; CvTreasury::GetCityConnectionRouteGoldTimes100
_TEXT	ENDS
PUBLIC	?HasCityConnectionRouteBetweenCities@CvTreasury@@QBE_NPAVCvCity@@0_N@Z ; CvTreasury::HasCityConnectionRouteBetweenCities
EXTRN	?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z:PROC ; CvCityConnections::GetRouteInfo
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ:PROC ; CvPlayer::GetCityConnections
; Function compile flags: /Ogtpy
;	COMDAT ?HasCityConnectionRouteBetweenCities@CvTreasury@@QBE_NPAVCvCity@@0_N@Z
_TEXT	SEGMENT
_iFirstCityIndex$ = -8					; size = 4
_iSecondCityIndex$ = -4					; size = 4
_pFirstCity$ = 8					; size = 4
_pSecondCity$ = 12					; size = 4
_bBestRoute$ = 16					; size = 1
?HasCityConnectionRouteBetweenCities@CvTreasury@@QBE_NPAVCvCity@@0_N@Z PROC ; CvTreasury::HasCityConnectionRouteBetweenCities, COMDAT
; _this$ = ecx

; 364  : 	CvCityConnections* pCityConnections = m_pPlayer->GetCityConnections();

	mov	ecx, DWORD PTR [ecx+4]
	sub	esp, 8
	push	ebx
	call	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ ; CvPlayer::GetCityConnections
	mov	ebx, eax

; 365  : 	FASSERT(pCityConnections, "m_pCityConnections is null");
; 366  : 	if(!pCityConnections)

	test	ebx, ebx
	jne	SHORT $LN15@HasCityCon
$LN30@HasCityCon:

; 367  : 	{
; 368  : 		// invalid value
; 369  : 		return FALSE;

	xor	al, al
	pop	ebx

; 423  : 		}
; 424  : 	}
; 425  : 
; 426  : 	return FALSE;
; 427  : }

	add	esp, 8
	ret	12					; 0000000cH
$LN15@HasCityCon:

; 370  : 	}
; 371  : 
; 372  : 	FASSERT(pFirstCity, "pFirstCity is null. Invalid!");
; 373  : 	FASSERT(pSecondCity, "pSecondCity is null. Invalid!");
; 374  : 	if(!pFirstCity || !pSecondCity)

	mov	ecx, DWORD PTR _pFirstCity$[esp+8]
	test	ecx, ecx
	je	SHORT $LN30@HasCityCon
	mov	eax, DWORD PTR _pSecondCity$[esp+8]
	test	eax, eax
	je	SHORT $LN30@HasCityCon

; 375  : 	{
; 376  : 		// null city passed in
; 377  : 		return FALSE;
; 378  : 	}
; 379  : 
; 380  : 	FASSERT(pFirstCity != pSecondCity, "Cities are the same and are by default connected?");
; 381  : 	if(pFirstCity == pSecondCity)

	cmp	ecx, eax

; 382  : 	{
; 383  : 		// trying to go to the same city
; 384  : 		return FALSE;

	je	SHORT $LN30@HasCityCon
	push	edi

; 385  : 	}
; 386  : 
; 387  : 	int iFirstCityIndex = -1;

	or	eax, -1

; 388  : 	int iSecondCityIndex = -1;
; 389  : 	for(uint ui = 0; ui < pCityConnections->m_aiCityPlotIDs.size(); ui++)

	xor	edi, edi
	mov	DWORD PTR _iFirstCityIndex$[esp+16], eax
	mov	DWORD PTR _iSecondCityIndex$[esp+16], eax
	cmp	DWORD PTR [ebx+16], edi
	jbe	$LN4@HasCityCon
	push	ebp
	push	esi
	jmp	SHORT $LN11@HasCityCon
	npad	6
$LL27@HasCityCon:
	mov	ecx, DWORD PTR _pFirstCity$[esp+20]
$LN11@HasCityCon:
	mov	esi, DWORD PTR [ebx+12]
	lea	ebp, DWORD PTR [edi*4]
	add	esi, ebp

; 390  : 	{
; 391  : 		if(pFirstCity->plot()->GetPlotIndex() == pCityConnections->m_aiCityPlotIDs[ui])

	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN8@HasCityCon

; 392  : 		{
; 393  : 			iFirstCityIndex = ui;

	mov	DWORD PTR _iFirstCityIndex$[esp+24], edi
$LN8@HasCityCon:

; 388  : 	int iSecondCityIndex = -1;
; 389  : 	for(uint ui = 0; ui < pCityConnections->m_aiCityPlotIDs.size(); ui++)

	mov	esi, DWORD PTR [ebx+12]

; 394  : 		}
; 395  : 
; 396  : 		if(pSecondCity->plot()->GetPlotIndex() == pCityConnections->m_aiCityPlotIDs[ui])

	mov	ecx, DWORD PTR _pSecondCity$[esp+20]
	add	esi, ebp
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN28@HasCityCon

; 397  : 		{
; 398  : 			iSecondCityIndex = ui;

	mov	eax, edi
	mov	DWORD PTR _iSecondCityIndex$[esp+24], eax
	jmp	SHORT $LN7@HasCityCon
$LN28@HasCityCon:
	mov	eax, DWORD PTR _iSecondCityIndex$[esp+24]
$LN7@HasCityCon:

; 399  : 		}
; 400  : 
; 401  : 		if(iFirstCityIndex >= 0 && iSecondCityIndex >= 0)

	mov	ecx, DWORD PTR _iFirstCityIndex$[esp+24]
	test	ecx, ecx
	jl	SHORT $LN10@HasCityCon
	test	eax, eax
	jge	SHORT $LN25@HasCityCon
$LN10@HasCityCon:

; 388  : 	int iSecondCityIndex = -1;
; 389  : 	for(uint ui = 0; ui < pCityConnections->m_aiCityPlotIDs.size(); ui++)

	inc	edi
	cmp	edi, DWORD PTR [ebx+16]
	jb	SHORT $LL27@HasCityCon
	mov	ecx, DWORD PTR _iFirstCityIndex$[esp+24]
	mov	eax, DWORD PTR _iSecondCityIndex$[esp+24]
$LN25@HasCityCon:
	pop	esi
	pop	ebp

; 402  : 		{
; 403  : 			break;
; 404  : 		}
; 405  : 	}
; 406  : 
; 407  : 	if(iFirstCityIndex < 0 || iSecondCityIndex < 0)

	test	ecx, ecx
	jl	SHORT $LN4@HasCityCon
	test	eax, eax
	jl	SHORT $LN4@HasCityCon

; 411  : 	}
; 412  : 
; 413  : 	CvCityConnections::RouteInfo* pRouteInfo = pCityConnections->GetRouteInfo(iFirstCityIndex, iSecondCityIndex);

	push	eax
	push	ecx
	mov	ecx, ebx
	call	?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z ; CvCityConnections::GetRouteInfo

; 414  : 	if(pRouteInfo)

	test	eax, eax
	je	SHORT $LN4@HasCityCon

; 415  : 	{
; 416  : 		if(bBestRoute)

	cmp	BYTE PTR _bBestRoute$[esp+12], 0

; 417  : 		{
; 418  : 			return pRouteInfo->m_cRouteState & CvCityConnections::HAS_BEST_ROUTE;

	movsx	eax, BYTE PTR [eax]
	je	SHORT $LN2@HasCityCon
	shr	eax, 2
	pop	edi
	and	al, 1
	pop	ebx

; 423  : 		}
; 424  : 	}
; 425  : 
; 426  : 	return FALSE;
; 427  : }

	add	esp, 8
	ret	12					; 0000000cH
$LN2@HasCityCon:
	pop	edi

; 419  : 		}
; 420  : 		else
; 421  : 		{
; 422  : 			return pRouteInfo->m_cRouteState & CvCityConnections::HAS_ANY_ROUTE;

	and	eax, 1
	pop	ebx

; 423  : 		}
; 424  : 	}
; 425  : 
; 426  : 	return FALSE;
; 427  : }

	add	esp, 8
	ret	12					; 0000000cH
$LN4@HasCityCon:
	pop	edi

; 408  : 	{
; 409  : 		// did not find one or both of the cities
; 410  : 		return FALSE;

	xor	al, al
	pop	ebx

; 423  : 		}
; 424  : 	}
; 425  : 
; 426  : 	return FALSE;
; 427  : }

	add	esp, 8
	ret	12					; 0000000cH
?HasCityConnectionRouteBetweenCities@CvTreasury@@QBE_NPAVCvCity@@0_N@Z ENDP ; CvTreasury::HasCityConnectionRouteBetweenCities
_TEXT	ENDS
PUBLIC	?GetGoldPerTurnFromTraits@CvTreasury@@QBEHXZ	; CvTreasury::GetGoldPerTurnFromTraits
EXTRN	?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ:PROC ; CvPlayerTrade::GetNumDifferentTradingPartners
EXTRN	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ:PROC ; CvPlayer::GetTrade
EXTRN	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ:PROC ; CvPlayer::GetCurrentEra
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldPerTurnFromTraits@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
?GetGoldPerTurnFromTraits@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetGoldPerTurnFromTraits, COMDAT
; _this$ = ecx

; 446  : {

	push	esi
	mov	esi, ecx

; 447  : 	// NQMP GJS - Morocco UA Gateway To Africa now scales with era BEGIN TradePartnerYieldFlatBonusPerEra
; 448  : 	int bonus = m_pPlayer->GetPlayerTraits()->GetYieldChangePerTradePartner(YIELD_GOLD);

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	edi, DWORD PTR [eax+504]

; 449  : 	if (bonus > 0) // temp fix since the GetTradePartnerYieldFlatBonusPerEra() stat is currently hard-coded to return 1 instead of reading from SQL

	test	edi, edi
	jle	SHORT $LN8@GetGoldPer

; 450  : 	{
; 451  : 		bonus += m_pPlayer->GetPlayerTraits()->GetTradePartnerYieldFlatBonusPerEra() * m_pPlayer->GetCurrentEra();

	mov	ecx, DWORD PTR [esi+4]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, DWORD PTR [esi+4]
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra

; 452  : 		bonus *= m_pPlayer->GetTrade()->GetNumDifferentTradingPartners();

	mov	ecx, DWORD PTR [esi+4]
	add	edi, eax
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ ; CvPlayerTrade::GetNumDifferentTradingPartners
	imul	eax, edi
	pop	edi
	pop	esi

; 455  : 	//return m_pPlayer->GetPlayerTraits()->GetYieldChangePerTradePartner(YIELD_GOLD) * m_pPlayer->GetTrade()->GetNumDifferentTradingPartners();
; 456  : 	// NQMP GJS - Morocco UA Gateway To Africa now scales with era END
; 457  : }

	ret	0
$LN8@GetGoldPer:

; 453  : 	}
; 454  : 	return bonus;

	mov	eax, edi
	pop	edi
	pop	esi

; 455  : 	//return m_pPlayer->GetPlayerTraits()->GetYieldChangePerTradePartner(YIELD_GOLD) * m_pPlayer->GetTrade()->GetNumDifferentTradingPartners();
; 456  : 	// NQMP GJS - Morocco UA Gateway To Africa now scales with era END
; 457  : }

	ret	0
?GetGoldPerTurnFromTraits@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetGoldPerTurnFromTraits
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	?CalculateUnitCost@CvTreasury@@QAEHAAH000@Z	; CvTreasury::CalculateUnitCost
EXTRN	?getAIUnitCostPercent@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getAIUnitCostPercent
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?IsAITeammateOfHuman@CvPlayer@@QBE_NXZ:PROC	; CvPlayer::IsAITeammateOfHuman
EXTRN	?getUnitCostPercent@CvHandicapInfo@@QBEHXZ:PROC	; CvHandicapInfo::getUnitCostPercent
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?GetUnitGoldMaintenanceMod@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetUnitGoldMaintenanceMod
EXTRN	_pow:PROC
EXTRN	?getDefaultEstimateEndTurn@CvGame@@QBEHXZ:PROC	; CvGame::getDefaultEstimateEndTurn
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?getExtraUnitCost@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getExtraUnitCost
EXTRN	?GetNumUnitsWithUnitCombat@CvPlayer@@QAEHW4UnitCombatTypes@@@Z:PROC ; CvPlayer::GetNumUnitsWithUnitCombat
EXTRN	?GetMaintenanceModifierUnitCombat@CvPlayerTraits@@QBEHH@Z:PROC ; CvPlayerTraits::GetMaintenanceModifierUnitCombat
EXTRN	?getUnitCombatClassInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4UnitCombatTypes@@@Z:PROC ; CvGlobals::getUnitCombatClassInfo
EXTRN	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumUnitCombatClassInfos
EXTRN	?GetNumUnitsWithDomain@CvPlayer@@QAEHW4DomainTypes@@_N@Z:PROC ; CvPlayer::GetNumUnitsWithDomain
EXTRN	?getGoldPerUnitTimes100@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getGoldPerUnitTimes100
EXTRN	?getNumUnits@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumUnits
EXTRN	?getBaseFreeUnits@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getBaseFreeUnits
EXTRN	?GetNumMaintenanceFreeUnits@CvPlayer@@QBEHW4DomainTypes@@_N@Z:PROC ; CvPlayer::GetNumMaintenanceFreeUnits
EXTRN	?getGoldFreeUnits@CvHandicapInfo@@QBEHXZ:PROC	; CvHandicapInfo::getGoldFreeUnits
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse_excpt:PROC
;	COMDAT __real@4059000000000000
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
CONST	ENDS
;	COMDAT ?CalculateUnitCost@CvTreasury@@QAEHAAH000@Z
_TEXT	SEGMENT
tv225 = -32						; size = 8
_fExponentialFactor$ = -32				; size = 8
_iNumUnits$217774 = -32					; size = 4
$T219176 = -32						; size = 4
_dFinalCost$ = -24					; size = 8
_iI$217764 = -24					; size = 4
_iNavalUnitMod$ = -24					; size = 4
_iLandUnitMod$ = -24					; size = 4
$T219175 = -24						; size = 4
_iSupport$ = -24					; size = 4
tv436 = -16						; size = 4
tv432 = -16						; size = 4
tv412 = -16						; size = 4
$T219178 = -16						; size = 4
_fTempCost$ = -16					; size = 8
_fMultiplyFactor$ = -16					; size = 8
_fGameProgressFactor$ = -16				; size = 8
_iModifier$217772 = -16					; size = 4
tv408 = -4						; size = 4
tv403 = -4						; size = 4
$T219177 = -4						; size = 4
_playerHandicap$ = -4					; size = 4
_iFreeUnits$ = 8					; size = 4
_iPaidUnits$ = 12					; size = 4
_iBaseUnitCost$ = 16					; size = 4
_iExtraCost$ = 20					; size = 4
?CalculateUnitCost@CvTreasury@@QAEHAAH000@Z PROC	; CvTreasury::CalculateUnitCost, COMDAT
; _this$ = ecx

; 542  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	mov	esi, ecx

; 543  : 	// If player has 0 Cities then no Unit cost
; 544  : 	if(m_pPlayer->getNumCities() == 0)

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	test	eax, eax
	jne	SHORT $LN12@CalculateU

; 646  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN12@CalculateU:

; 545  : 	{
; 546  : 		return 0;
; 547  : 	}
; 548  : 
; 549  : 	int iSupport = 0;
; 550  : 
; 551  : 	CvHandicapInfo& playerHandicap = m_pPlayer->getHandicapInfo();

	mov	ecx, DWORD PTR [esi+4]
	call	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ ; CvPlayer::getHandicapInfo

; 552  : 	iFreeUnits = playerHandicap.getGoldFreeUnits();

	mov	ecx, eax
	mov	DWORD PTR _playerHandicap$[esp+64], eax
	call	?getGoldFreeUnits@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getGoldFreeUnits
	mov	edi, DWORD PTR _iFreeUnits$[ebp]

; 553  : 
; 554  : 	// Defined in XML by unit info type
; 555  : 	iFreeUnits += m_pPlayer->GetNumMaintenanceFreeUnits();

	push	0
	mov	DWORD PTR [edi], eax
	mov	ecx, DWORD PTR [esi+4]
	push	-1
	call	?GetNumMaintenanceFreeUnits@CvPlayer@@QBEHW4DomainTypes@@_N@Z ; CvPlayer::GetNumMaintenanceFreeUnits
	add	DWORD PTR [edi], eax

; 556  : 	iFreeUnits += m_pPlayer->getBaseFreeUnits();

	mov	ecx, DWORD PTR [esi+4]
	call	?getBaseFreeUnits@CvPlayer@@QBEHXZ	; CvPlayer::getBaseFreeUnits
	add	DWORD PTR [edi], eax

; 557  : 
; 558  : 	iPaidUnits = max(0, m_pPlayer->getNumUnits() - iFreeUnits);

	mov	ecx, DWORD PTR [esi+4]
	call	?getNumUnits@CvPlayer@@QBEHXZ		; CvPlayer::getNumUnits
	sub	eax, DWORD PTR [edi]
	mov	DWORD PTR $T219176[esp+64], 0
	mov	DWORD PTR $T219175[esp+64], eax
	test	eax, eax
	lea	eax, DWORD PTR $T219175[esp+64]
	jg	SHORT $LN18@CalculateU
	lea	eax, DWORD PTR $T219176[esp+64]
$LN18@CalculateU:
	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR _iPaidUnits$[ebp]
	mov	DWORD PTR [edi], eax

; 559  : 
; 560  : 	iBaseUnitCost = iPaidUnits * m_pPlayer->getGoldPerUnitTimes100();

	mov	ecx, DWORD PTR [esi+4]
	call	?getGoldPerUnitTimes100@CvPlayer@@QBEHXZ ; CvPlayer::getGoldPerUnitTimes100
	imul	eax, DWORD PTR [edi]
	mov	edi, DWORD PTR _iBaseUnitCost$[ebp]
	mov	DWORD PTR [edi], eax

; 561  : 
; 562  : 	// Discount on land unit maintenance?
; 563  : 	int iLandUnitMod = m_pPlayer->GetPlayerTraits()->GetLandUnitMaintenanceModifier();

	mov	ecx, DWORD PTR [esi+4]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	eax, DWORD PTR [eax+240]
	mov	DWORD PTR _iLandUnitMod$[esp+64], eax

; 564  : 	if(iLandUnitMod != 0)

	test	eax, eax
	je	SHORT $LN11@CalculateU

; 565  : 	{
; 566  : 		int iLandUnits = m_pPlayer->GetNumUnitsWithDomain(DOMAIN_LAND, true /*bMilitaryOnly*/);

	mov	ecx, DWORD PTR [esi+4]
	push	1
	push	2
	call	?GetNumUnitsWithDomain@CvPlayer@@QAEHW4DomainTypes@@_N@Z ; CvPlayer::GetNumUnitsWithDomain

; 567  : 		int iFreeLandUnits = m_pPlayer->GetNumMaintenanceFreeUnits(DOMAIN_LAND, true);

	mov	ecx, DWORD PTR [esi+4]
	push	1
	push	2
	mov	ebx, eax
	call	?GetNumMaintenanceFreeUnits@CvPlayer@@QBEHW4DomainTypes@@_N@Z ; CvPlayer::GetNumMaintenanceFreeUnits

; 568  : 		int iPaidLandUnits = iLandUnits - iFreeLandUnits;
; 569  : 		iBaseUnitCost += (iLandUnitMod * iPaidLandUnits * m_pPlayer->getGoldPerUnitTimes100()) / 100;

	mov	ecx, DWORD PTR [esi+4]
	sub	ebx, eax
	call	?getGoldPerUnitTimes100@CvPlayer@@QBEHXZ ; CvPlayer::getGoldPerUnitTimes100
	mov	ecx, eax
	imul	ecx, ebx
	imul	ecx, DWORD PTR _iLandUnitMod$[esp+64]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [edi], ecx
$LN11@CalculateU:

; 570  : 	}
; 571  : 
; 572  : 	// Discount on naval unit maintenance?
; 573  : 	int iNavalUnitMod = m_pPlayer->GetPlayerTraits()->GetNavalUnitMaintenanceModifier();

	mov	ecx, DWORD PTR [esi+4]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	eax, DWORD PTR [eax+244]
	mov	DWORD PTR _iNavalUnitMod$[esp+64], eax

; 574  : 	if(iNavalUnitMod != 0)

	test	eax, eax
	je	SHORT $LN10@CalculateU

; 575  : 	{
; 576  : 		int iNavalUnits = m_pPlayer->GetNumUnitsWithDomain(DOMAIN_SEA, true /*bMilitaryOnly*/);

	mov	ecx, DWORD PTR [esi+4]
	push	1
	push	0
	call	?GetNumUnitsWithDomain@CvPlayer@@QAEHW4DomainTypes@@_N@Z ; CvPlayer::GetNumUnitsWithDomain

; 577  : 		int iFreeNavalUnits = m_pPlayer->GetNumMaintenanceFreeUnits(DOMAIN_SEA, true);

	mov	ecx, DWORD PTR [esi+4]
	push	1
	push	0
	mov	ebx, eax
	call	?GetNumMaintenanceFreeUnits@CvPlayer@@QBEHW4DomainTypes@@_N@Z ; CvPlayer::GetNumMaintenanceFreeUnits

; 578  : 		int iPaidNavalUnits = iNavalUnits - iFreeNavalUnits;
; 579  : 		iBaseUnitCost += (iNavalUnitMod * iPaidNavalUnits * m_pPlayer->getGoldPerUnitTimes100()) / 100;

	mov	ecx, DWORD PTR [esi+4]
	sub	ebx, eax
	call	?getGoldPerUnitTimes100@CvPlayer@@QBEHXZ ; CvPlayer::getGoldPerUnitTimes100
	mov	ecx, eax
	imul	ecx, ebx
	imul	ecx, DWORD PTR _iNavalUnitMod$[esp+64]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	DWORD PTR [edi], eax
$LN10@CalculateU:

; 580  : 	}
; 581  : 
; 582  : 	// Discounts for units of certain UnitCombat classes
; 583  : #ifdef AUI_WARNING_FIXES
; 584  : 	for (uint iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)
; 585  : #else
; 586  : 	for(int iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)

	xor	ebx, ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iI$217764[esp+64], ebx
	call	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumUnitCombatClassInfos
	test	eax, eax
	jle	$LN7@CalculateU
$LL9@CalculateU:

; 587  : #endif
; 588  : 	{
; 589  : 		const UnitCombatTypes eUnitCombatClass = static_cast<UnitCombatTypes>(iI);
; 590  : 		CvBaseInfo* pkUnitCombatClassInfo = GC.getUnitCombatClassInfo(eUnitCombatClass);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitCombatClassInfo@CvGlobals@@QAEPAVCvBaseInfo@@W4UnitCombatTypes@@@Z ; CvGlobals::getUnitCombatClassInfo

; 591  : 		if(pkUnitCombatClassInfo)

	test	eax, eax
	je	SHORT $LN8@CalculateU

; 592  : 		{
; 593  : 			int iModifier = m_pPlayer->GetPlayerTraits()->GetMaintenanceModifierUnitCombat(eUnitCombatClass);

	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetMaintenanceModifierUnitCombat@CvPlayerTraits@@QBEHH@Z ; CvPlayerTraits::GetMaintenanceModifierUnitCombat
	mov	DWORD PTR _iModifier$217772[esp+64], eax

; 594  : 			if (iModifier != 0)

	test	eax, eax
	je	SHORT $LN8@CalculateU

; 595  : 			{
; 596  : 				int iNumUnits = m_pPlayer->GetNumUnitsWithUnitCombat(eUnitCombatClass);

	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	call	?GetNumUnitsWithUnitCombat@CvPlayer@@QAEHW4UnitCombatTypes@@@Z ; CvPlayer::GetNumUnitsWithUnitCombat

; 597  : 				int iCost = iNumUnits * m_pPlayer->getGoldPerUnitTimes100(); 

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _iNumUnits$217774[esp+64], eax
	call	?getGoldPerUnitTimes100@CvPlayer@@QBEHXZ ; CvPlayer::getGoldPerUnitTimes100

; 598  : 				int iModifiedCost = iNumUnits * m_pPlayer->getGoldPerUnitTimes100() * (100 + iModifier) / 100; 

	mov	ecx, DWORD PTR [esi+4]
	mov	ebx, eax
	imul	ebx, DWORD PTR _iNumUnits$217774[esp+64]
	call	?getGoldPerUnitTimes100@CvPlayer@@QBEHXZ ; CvPlayer::getGoldPerUnitTimes100
	mov	edx, DWORD PTR _iModifier$217772[esp+64]
	mov	ecx, eax
	add	edx, 100				; 00000064H
	imul	ecx, edx
	imul	ecx, DWORD PTR _iNumUnits$217774[esp+64]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 599  : 				
; 600  : 				// Reduce cost based on difference
; 601  : 				iBaseUnitCost += (iModifiedCost - iCost);

	sub	eax, ebx
	add	DWORD PTR [edi], eax
	mov	ebx, DWORD PTR _iI$217764[esp+64]
$LN8@CalculateU:
	inc	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iI$217764[esp+64], ebx
	call	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumUnitCombatClassInfos
	cmp	ebx, eax
	jl	$LL9@CalculateU
$LN7@CalculateU:

; 602  : 			}
; 603  : 		}
; 604  : 	}
; 605  : 
; 606  : 	iExtraCost = m_pPlayer->getExtraUnitCost() * 100;	// In hundreds to avoid rounding errors

	mov	ecx, DWORD PTR [esi+4]
	call	?getExtraUnitCost@CvPlayer@@QBEHXZ	; CvPlayer::getExtraUnitCost
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _iExtraCost$[ebp]
	mov	DWORD PTR [ecx], eax

; 607  : 
; 608  : 	iSupport = iBaseUnitCost + iExtraCost;

	mov	edx, DWORD PTR [edi]

; 609  : 
; 610  : 	// Game progress factor ranges from 0.0 to 1.0 based on how far into the game we are
; 611  : 	double fGameProgressFactor = double(GC.getGame().getElapsedGameTurns()) / GC.getGame().getDefaultEstimateEndTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	edx, eax
	mov	DWORD PTR _iSupport$[esp+64], edx
	mov	edi, ecx
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	mov	DWORD PTR tv436[esp+64], eax
	fild	DWORD PTR tv436[esp+64]
	mov	ecx, edi
	fstp	QWORD PTR tv225[esp+64]
	call	?getDefaultEstimateEndTurn@CvGame@@QBEHXZ ; CvGame::getDefaultEstimateEndTurn
	mov	DWORD PTR tv432[esp+64], eax
	fild	DWORD PTR tv432[esp+64]

; 612  : 
; 613  : 	// Multiplicative increase - helps scale costs as game goes on - the HIGHER this number the more is paid
; 614  : 	double fMultiplyFactor = 1.0 + (fGameProgressFactor* /*8*/ GC.getUNIT_MAINTENANCE_GAME_MULTIPLIER());
; 615  : 	// Exponential increase - this one really punishes those with a HUGE military - the LOWER this number the more is paid
; 616  : 	double fExponentialFactor = 1.0 + (fGameProgressFactor / /*7*/ GC.getUNIT_MAINTENANCE_GAME_EXPONENT_DIVISOR());
; 617  : 
; 618  : 	double fTempCost = fMultiplyFactor * iSupport;
; 619  : 	fTempCost /= 100;	// Take this out of hundreds now
; 620  : 
; 621  : 	double dFinalCost = pow(fTempCost, fExponentialFactor);

	sub	esp, 8
	mov	eax, esp
	fdivr	QWORD PTR tv225[esp+72]
	sub	esp, 8
	fstp	QWORD PTR _fGameProgressFactor$[esp+80]
	fild	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6524
	fld	QWORD PTR _fGameProgressFactor$[esp+80]
	fmul	ST(1), ST(0)
	fld1
	fadd	ST(2), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR _fMultiplyFactor$[esp+80]
	fidiv	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6528
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _fExponentialFactor$[esp+80]
	mov	ecx, DWORD PTR _fExponentialFactor$[esp+80]
	fild	DWORD PTR _iSupport$[esp+80]
	mov	edx, DWORD PTR _fExponentialFactor$[esp+84]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	fmul	QWORD PTR _fMultiplyFactor$[esp+80]
	mov	eax, esp
	fstp	QWORD PTR _fTempCost$[esp+80]
	fld	QWORD PTR _fTempCost$[esp+80]
	fdiv	QWORD PTR __real@4059000000000000
	fstp	QWORD PTR _fTempCost$[esp+80]
	mov	ecx, DWORD PTR _fTempCost$[esp+80]
	mov	edx, DWORD PTR _fTempCost$[esp+84]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	call	_pow
	fstp	QWORD PTR _dFinalCost$[esp+80]

; 622  : 
; 623  : 	// A mod at the player level? (Policies, etc.)
; 624  : 	if(m_pPlayer->GetUnitGoldMaintenanceMod() != 0)

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 16					; 00000010H
	call	?GetUnitGoldMaintenanceMod@CvPlayer@@QBEHXZ ; CvPlayer::GetUnitGoldMaintenanceMod
	test	eax, eax
	je	SHORT $LN4@CalculateU

; 625  : 	{
; 626  : 		dFinalCost *= (100 + m_pPlayer->GetUnitGoldMaintenanceMod());

	mov	ecx, DWORD PTR [esi+4]
	call	?GetUnitGoldMaintenanceMod@CvPlayer@@QBEHXZ ; CvPlayer::GetUnitGoldMaintenanceMod
	add	eax, 100				; 00000064H
	mov	DWORD PTR tv412[esp+64], eax
	fild	DWORD PTR tv412[esp+64]
	fmul	QWORD PTR _dFinalCost$[esp+64]
	fstp	QWORD PTR _dFinalCost$[esp+64]

; 627  : 		dFinalCost /= 100;

	fld	QWORD PTR _dFinalCost$[esp+64]
	fdiv	QWORD PTR __real@4059000000000000
	fstp	QWORD PTR _dFinalCost$[esp+64]
$LN4@CalculateU:

; 628  : 	}
; 629  : 
; 630  : 	// Human bonus for unit maintenance costs
; 631  : 	if(m_pPlayer->isHuman())

	mov	ecx, DWORD PTR [esi+4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN3@CalculateU

; 632  : 	{
; 633  : 		dFinalCost *= playerHandicap.getUnitCostPercent();

	mov	ecx, DWORD PTR _playerHandicap$[esp+64]
	call	?getUnitCostPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getUnitCostPercent
	mov	DWORD PTR tv408[esp+64], eax
	fild	DWORD PTR tv408[esp+64]

; 634  : 		dFinalCost /= 100;

	jmp	SHORT $LN40@CalculateU
$LN3@CalculateU:

; 635  : 	}
; 636  : 	// AI bonus for unit maintenance costs
; 637  : 	else if(!m_pPlayer->IsAITeammateOfHuman())

	mov	ecx, DWORD PTR [esi+4]
	call	?IsAITeammateOfHuman@CvPlayer@@QBE_NXZ	; CvPlayer::IsAITeammateOfHuman
	test	al, al
	jne	SHORT $LN1@CalculateU

; 638  : 	{
; 639  : 		dFinalCost *= GC.getGame().getHandicapInfo().getAIUnitCostPercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?getAIUnitCostPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIUnitCostPercent
	mov	DWORD PTR tv403[esp+64], eax
	fild	DWORD PTR tv403[esp+64]
$LN40@CalculateU:
	fmul	QWORD PTR _dFinalCost$[esp+64]
	fstp	QWORD PTR _dFinalCost$[esp+64]

; 640  : 		dFinalCost /= 100;

	fld	QWORD PTR _dFinalCost$[esp+64]
	fdiv	QWORD PTR __real@4059000000000000
	fstp	QWORD PTR _dFinalCost$[esp+64]
$LN1@CalculateU:

; 641  : 	}
; 642  : 
; 643  : 	//iFinalCost /= 100;
; 644  : 
; 645  : 	return std::max(0, int(dFinalCost));

	fld	QWORD PTR _dFinalCost$[esp+64]
	call	__ftol2_sse_excpt
	mov	DWORD PTR $T219177[esp+64], eax
	test	eax, eax
	mov	DWORD PTR $T219178[esp+64], 0
	lea	eax, DWORD PTR $T219177[esp+64]
	jg	SHORT $LN36@CalculateU
	lea	eax, DWORD PTR $T219178[esp+64]
$LN36@CalculateU:
	mov	eax, DWORD PTR [eax]

; 646  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CalculateUnitCost@CvTreasury@@QAEHAAH000@Z ENDP	; CvTreasury::CalculateUnitCost
_TEXT	ENDS
PUBLIC	?CalculateUnitSupply@CvTreasury@@QAEHAAH0@Z	; CvTreasury::CalculateUnitSupply
EXTRN	?GetUnitSupplyMod@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetUnitSupplyMod
EXTRN	?getEstimateEndTurn@CvGame@@QBEHXZ:PROC		; CvGame::getEstimateEndTurn
EXTRN	?getAIPerEraModifier@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getAIPerEraModifier
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?getNumOutsideUnits@CvPlayer@@QAEHXZ:PROC	; CvPlayer::getNumOutsideUnits
; Function compile flags: /Ogtpy
;	COMDAT ?CalculateUnitSupply@CvTreasury@@QAEHAAH0@Z
_TEXT	SEGMENT
_fTempCost$ = -16					; size = 8
_fMultiplyFactor$ = -16					; size = 8
$T219237 = -16						; size = 4
tv158 = -8						; size = 8
_fExponentialFactor$ = -8				; size = 8
_fGameProgressFactor$ = -8				; size = 8
$T219238 = -8						; size = 4
$T219239 = 8						; size = 4
_iSupply$ = 8						; size = 4
_iPaidUnits$ = 8					; size = 4
tv269 = 12						; size = 4
tv267 = 12						; size = 4
$T219240 = 12						; size = 4
_iBaseSupplyCost$ = 12					; size = 4
?CalculateUnitSupply@CvTreasury@@QAEHAAH0@Z PROC	; CvTreasury::CalculateUnitSupply, COMDAT
; _this$ = ecx

; 650  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 651  : 	int iSupply;
; 652  : 
; 653  : 	iPaidUnits = std::max(0, (m_pPlayer->getNumOutsideUnits() - /*3*/ GC.getINITIAL_FREE_OUTSIDE_UNITS()));

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6516
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi+4]
	call	?getNumOutsideUnits@CvPlayer@@QAEHXZ	; CvPlayer::getNumOutsideUnits
	sub	eax, esi
	mov	DWORD PTR $T219237[esp+28], eax
	test	eax, eax
	mov	DWORD PTR $T219238[esp+28], 0
	lea	eax, DWORD PTR $T219237[esp+28]
	jg	SHORT $LN10@CalculateU@2
	lea	eax, DWORD PTR $T219238[esp+28]
$LN10@CalculateU@2:
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR _iPaidUnits$[esp+24]
	mov	DWORD PTR [ecx], eax

; 654  : 
; 655  : 	// JON: This is set to 0 right now, which pretty much means it's disabled
; 656  : 	iBaseSupplyCost = iPaidUnits* /*0*/ GC.getINITIAL_OUTSIDE_UNIT_GOLD_PERCENT();

	imul	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6520

; 657  : 	iBaseSupplyCost /= 100;

	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	edx, DWORD PTR _iBaseSupplyCost$[esp+24]
	mov	DWORD PTR [edx], esi

; 658  : 
; 659  : 	iSupply = iBaseSupplyCost;
; 660  : 
; 661  : 	CvHandicapInfo& playerHandicap = m_pPlayer->getHandicapInfo();

	mov	ecx, DWORD PTR [edi+4]
	call	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ ; CvPlayer::getHandicapInfo

; 662  : 	iSupply *= playerHandicap.getUnitCostPercent();

	mov	ecx, eax
	call	?getUnitCostPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getUnitCostPercent
	mov	ecx, eax
	imul	ecx, esi

; 663  : 	iSupply /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 664  : 
; 665  : 	if(!m_pPlayer->isHuman() && !m_pPlayer->IsAITeammateOfHuman() && !m_pPlayer->isBarbarian())

	mov	ecx, DWORD PTR [edi+4]
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	DWORD PTR _iSupply$[esp+24], esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN2@CalculateU@2
	mov	ecx, DWORD PTR [edi+4]
	call	?IsAITeammateOfHuman@CvPlayer@@QBE_NXZ	; CvPlayer::IsAITeammateOfHuman
	test	al, al
	jne	SHORT $LN2@CalculateU@2
	mov	ecx, DWORD PTR [edi+4]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN2@CalculateU@2

; 666  : 	{
; 667  : 		//iSupply *= gameHandicap->getAIUnitSupplyPercent();	// This is no longer valid
; 668  : 		//iSupply /= 100;
; 669  : 
; 670  : 		iSupply *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * m_pPlayer->GetCurrentEra()) + 100));

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?getAIPerEraModifier@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIPerEraModifier
	mov	ecx, DWORD PTR [edi+4]
	mov	ebx, eax
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	imul	ebx, eax
	add	ebx, 100				; 00000064H
	mov	DWORD PTR $T219239[esp+24], ebx
	mov	DWORD PTR $T219240[esp+24], 0
	lea	eax, DWORD PTR $T219239[esp+24]
	test	ebx, ebx
	jg	SHORT $LN18@CalculateU@2
	lea	eax, DWORD PTR $T219240[esp+24]
$LN18@CalculateU@2:
	mov	ecx, DWORD PTR [eax]
	imul	ecx, esi

; 671  : 		iSupply /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iSupply$[esp+24], eax
$LN2@CalculateU@2:

; 672  : 	}
; 673  : 
; 674  : 	// Game progress factor ranges from 0.0 to 1.0 based on how far into the game we are
; 675  : 	double fGameProgressFactor = float(GC.getGame().getElapsedGameTurns()) / GC.getGame().getEstimateEndTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, ecx
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	mov	DWORD PTR tv269[esp+24], eax
	fild	DWORD PTR tv269[esp+24]
	mov	ecx, esi
	fstp	QWORD PTR tv158[esp+28]
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	mov	DWORD PTR tv267[esp+24], eax
	fild	DWORD PTR tv267[esp+24]

; 676  : 
; 677  : 	// Multiplicative increase - helps scale costs as game goes on - the HIGHER this number the more is paid
; 678  : 	double fMultiplyFactor = 1.0 + (fGameProgressFactor* /*8*/ GC.getUNIT_MAINTENANCE_GAME_MULTIPLIER());
; 679  : 	// Exponential increase - this one really punishes those with a HUGE military - the LOWER this number the more is paid
; 680  : 	double fExponentialFactor = 1.0 + (fGameProgressFactor / /*7*/ GC.getUNIT_MAINTENANCE_GAME_EXPONENT_DIVISOR());
; 681  : 
; 682  : 	double fTempCost = fMultiplyFactor * iSupply;
; 683  : 	int iFinalCost = (int) pow(fTempCost, fExponentialFactor);

	sub	esp, 8
	mov	eax, esp
	fdivr	QWORD PTR tv158[esp+36]
	sub	esp, 8
	fstp	QWORD PTR _fGameProgressFactor$[esp+44]
	fild	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6524
	fld	QWORD PTR _fGameProgressFactor$[esp+44]
	fmul	ST(1), ST(0)
	fld1
	fadd	ST(2), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR _fMultiplyFactor$[esp+44]
	fidiv	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6528
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _fExponentialFactor$[esp+44]
	mov	ecx, DWORD PTR _fExponentialFactor$[esp+44]
	fild	DWORD PTR _iSupply$[esp+40]
	mov	edx, DWORD PTR _fExponentialFactor$[esp+48]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	fmul	QWORD PTR _fMultiplyFactor$[esp+44]
	mov	eax, esp
	fstp	QWORD PTR _fTempCost$[esp+44]
	mov	ecx, DWORD PTR _fTempCost$[esp+44]
	mov	edx, DWORD PTR _fTempCost$[esp+48]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	call	_pow
	add	esp, 16					; 00000010H
	call	__ftol2_sse_excpt

; 684  : 
; 685  : 	// A mod at the player level? (Policies, etc.)
; 686  : 	if(m_pPlayer->GetUnitSupplyMod() != 0)

	mov	ecx, DWORD PTR [edi+4]
	mov	esi, eax
	call	?GetUnitSupplyMod@CvPlayer@@QBEHXZ	; CvPlayer::GetUnitSupplyMod
	test	eax, eax
	je	SHORT $LN27@CalculateU@2

; 687  : 	{
; 688  : 		iFinalCost *= (100 + m_pPlayer->GetUnitSupplyMod());

	mov	ecx, DWORD PTR [edi+4]
	call	?GetUnitSupplyMod@CvPlayer@@QBEHXZ	; CvPlayer::GetUnitSupplyMod
	mov	ecx, eax
	add	ecx, 100				; 00000064H
	imul	ecx, esi

; 689  : 		iFinalCost /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 690  : 	}
; 691  : 
; 692  : 	CvAssert(iFinalCost >= 0);
; 693  : 
; 694  : 	return iFinalCost;
; 695  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
$LN27@CalculateU@2:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	8
?CalculateUnitSupply@CvTreasury@@QAEHAAH0@Z ENDP	; CvTreasury::CalculateUnitSupply
_TEXT	ENDS
PUBLIC	?CalculateInflationRate@CvTreasury@@QAEHXZ	; CvTreasury::CalculateInflationRate
EXTRN	?getAIInflationPercent@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getAIInflationPercent
EXTRN	?getInflationPercent@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getInflationPercent
EXTRN	?getInflationPercent@CvGameSpeedInfo@@QBEHXZ:PROC ; CvGameSpeedInfo::getInflationPercent
EXTRN	?getInflationOffset@CvGameSpeedInfo@@QBEHXZ:PROC ; CvGameSpeedInfo::getInflationOffset
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
; Function compile flags: /Ogtpy
;	COMDAT ?CalculateInflationRate@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
tv197 = -12						; size = 4
$T219292 = -12						; size = 4
$T219294 = -8						; size = 4
$T219291 = -8						; size = 4
_gameHandicap$ = -8					; size = 4
$T219293 = -4						; size = 4
_iAIModifier$217828 = -4				; size = 4
?CalculateInflationRate@CvTreasury@@QAEHXZ PROC		; CvTreasury::CalculateInflationRate, COMDAT
; _this$ = ecx

; 721  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi

; 722  : 	CvGame& kGame = GC.getGame();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, ecx

; 723  : 
; 724  : 	CvHandicapInfo& playerHandicap = m_pPlayer->getHandicapInfo();

	mov	ecx, DWORD PTR [ebp+4]
	push	edi
	call	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ ; CvPlayer::getHandicapInfo

; 725  : 	CvHandicapInfo& gameHandicap = kGame.getHandicapInfo();

	mov	ecx, esi
	mov	ebx, eax
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo

; 726  : 	CvGameSpeedInfo& gameSpeedInfo = kGame.getGameSpeedInfo();

	mov	ecx, esi
	mov	DWORD PTR _gameHandicap$[esp+28], eax
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo

; 727  : 
; 728  : 	int iTurns = ((kGame.getGameTurn() + kGame.getElapsedGameTurns()) / 2);

	mov	ecx, esi
	mov	edi, eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, esi
	mov	DWORD PTR tv197[esp+28], eax
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	mov	ecx, DWORD PTR tv197[esp+28]
	add	eax, ecx
	cdq
	sub	eax, edx
	mov	esi, eax

; 729  : 	iTurns += gameSpeedInfo.getInflationOffset();

	mov	ecx, edi
	sar	esi, 1
	call	?getInflationOffset@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getInflationOffset
	add	esi, eax

; 730  : 
; 731  : 	if(iTurns <= 0)

	test	esi, esi
	jg	SHORT $LN2@CalculateI
	pop	edi
	pop	esi
	pop	ebp

; 732  : 	{
; 733  : 		return 0;

	xor	eax, eax
	pop	ebx

; 761  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN2@CalculateI:

; 734  : 	}
; 735  : 
; 736  : 	int iInflationPerTurnTimes10000 = gameSpeedInfo.getInflationPercent();

	mov	ecx, edi
	call	?getInflationPercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getInflationPercent

; 737  : 	iInflationPerTurnTimes10000 *= playerHandicap.getInflationPercent();

	mov	ecx, ebx
	mov	edi, eax
	call	?getInflationPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getInflationPercent
	mov	ecx, eax
	imul	ecx, edi

; 738  : 	iInflationPerTurnTimes10000 /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 739  : 
; 740  : 	int iModifier = 0;
; 741  : 
; 742  : 	if(!m_pPlayer->isHuman() && !m_pPlayer->isBarbarian())

	mov	ecx, DWORD PTR [ebp+4]
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	xor	ebx, ebx
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN1@CalculateI
	mov	ecx, DWORD PTR [ebp+4]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN1@CalculateI

; 743  : 	{
; 744  : 		int iAIModifier = gameHandicap.getAIInflationPercent();

	mov	ebx, DWORD PTR _gameHandicap$[esp+28]
	mov	ecx, ebx
	call	?getAIInflationPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIInflationPercent

; 745  : 		iAIModifier *= std::max(0, ((gameHandicap.getAIPerEraModifier() * m_pPlayer->GetCurrentEra()) + 100));

	mov	ecx, ebx
	mov	DWORD PTR _iAIModifier$217828[esp+28], eax
	call	?getAIPerEraModifier@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIPerEraModifier
	mov	ecx, DWORD PTR [ebp+4]
	mov	ebx, eax
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	imul	ebx, eax
	add	ebx, 100				; 00000064H
	mov	DWORD PTR $T219291[esp+28], ebx
	mov	DWORD PTR $T219292[esp+28], 0
	lea	eax, DWORD PTR $T219291[esp+28]
	test	ebx, ebx
	jg	SHORT $LN10@CalculateI
	lea	eax, DWORD PTR $T219292[esp+28]
$LN10@CalculateI:
	mov	ecx, DWORD PTR [eax]
	imul	ecx, DWORD PTR _iAIModifier$217828[esp+28]

; 746  : 		iAIModifier /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	lea	ebx, DWORD PTR [edx+eax-100]
$LN1@CalculateI:

; 747  : 
; 748  : 		iModifier += iAIModifier - 100;
; 749  : 	}
; 750  : 
; 751  : 	iInflationPerTurnTimes10000 *= std::max(0, 100 + iModifier);

	add	ebx, 100				; 00000064H
	mov	DWORD PTR $T219293[esp+28], ebx
	mov	DWORD PTR $T219294[esp+28], 0
	lea	eax, DWORD PTR $T219293[esp+28]
	test	ebx, ebx
	jg	SHORT $LN14@CalculateI
	lea	eax, DWORD PTR $T219294[esp+28]
$LN14@CalculateI:
	mov	ecx, DWORD PTR [eax]
	imul	ecx, edi

; 752  : 	iInflationPerTurnTimes10000 /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 753  : 
; 754  : 	// Keep up to second order terms in binomial series
; 755  : 	int iRatePercent = (iTurns * iInflationPerTurnTimes10000) / 100;
; 756  : 	iRatePercent += (iTurns * (iTurns - 1) * iInflationPerTurnTimes10000 * iInflationPerTurnTimes10000) / 2000000;

	lea	edx, DWORD PTR [esi-1]
	imul	edx, ecx

; 757  : 
; 758  : 	CvAssert(iRatePercent >= 0);
; 759  : 
; 760  : 	return iRatePercent;

	imul	edx, ecx
	imul	ecx, esi
	imul	edx, esi
	mov	eax, 1125899907				; 431bde83H
	imul	edx
	sar	edx, 19					; 00000013H
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	add	edi, edx
	shr	eax, 31					; 0000001fH
	add	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 761  : }

	add	esp, 12					; 0000000cH
	ret	0
?CalculateInflationRate@CvTreasury@@QAEHXZ ENDP		; CvTreasury::CalculateInflationRate
_TEXT	ENDS
PUBLIC	?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ	; CvTreasury::GetBuildingGoldMaintenance
EXTRN	?getBuildingMaintenancePercent@CvEraInfo@@QBEHXZ:PROC ; CvEraInfo::getBuildingMaintenancePercent
EXTRN	?getStartEraInfo@CvGame@@QBEAAVCvEraInfo@@XZ:PROC ; CvGame::getStartEraInfo
EXTRN	?getAIBuildingCostPercent@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getAIBuildingCostPercent
EXTRN	?getBuildingCostPercent@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getBuildingCostPercent
EXTRN	?GetBuildingGoldMaintenanceMod@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetBuildingGoldMaintenanceMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetBuildingGoldMaintenance, COMDAT
; _this$ = ecx

; 776  : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 777  : 	int iMaintenance = GetBaseBuildingGoldMaintenance();
; 778  : 
; 779  : 	// Player modifier
; 780  : 	iMaintenance *= (100 + m_pPlayer->GetBuildingGoldMaintenanceMod());

	mov	ecx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [edi+36]
	call	?GetBuildingGoldMaintenanceMod@CvPlayer@@QBEHXZ ; CvPlayer::GetBuildingGoldMaintenanceMod
	mov	ecx, eax
	add	ecx, 100				; 00000064H
	imul	ecx, esi

; 781  : 	iMaintenance /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 782  : 
; 783  : 	// Modifier for difficulty level
; 784  : 	CvHandicapInfo& playerHandicap = m_pPlayer->getHandicapInfo();

	mov	ecx, DWORD PTR [edi+4]
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	call	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ ; CvPlayer::getHandicapInfo

; 785  : 	//iMaintenance *= playerHandicap->getBuildingCostPercent();
; 786  : 	//iMaintenance /= 100;
; 787  : 
; 788  : 	// Human bonus for Building maintenance costs
; 789  : 	if(m_pPlayer->isHuman())

	mov	ecx, DWORD PTR [edi+4]
	mov	ebx, eax
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN3@GetBuildin

; 790  : 	{
; 791  : 		iMaintenance *= playerHandicap.getBuildingCostPercent();

	mov	ecx, ebx
	call	?getBuildingCostPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getBuildingCostPercent
	mov	ecx, eax
	imul	ecx, esi

; 792  : 		iMaintenance /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax
	jmp	SHORT $LN1@GetBuildin
$LN3@GetBuildin:

; 793  : 	}
; 794  : 	// AI bonus for Building maintenance costs
; 795  : 	else if(!m_pPlayer->IsAITeammateOfHuman())

	mov	ecx, DWORD PTR [edi+4]
	call	?IsAITeammateOfHuman@CvPlayer@@QBE_NXZ	; CvPlayer::IsAITeammateOfHuman
	test	al, al
	jne	SHORT $LN1@GetBuildin

; 796  : 	{
; 797  : 		iMaintenance *= GC.getGame().getHandicapInfo().getAIBuildingCostPercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?getAIBuildingCostPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getAIBuildingCostPercent
	mov	ecx, eax
	imul	ecx, esi

; 798  : 		iMaintenance /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx
$LN1@GetBuildin:

; 799  : 	}
; 800  : 
; 801  : 	// Start Era mod
; 802  : 	iMaintenance *= GC.getGame().getStartEraInfo().getBuildingMaintenancePercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getStartEraInfo@CvGame@@QBEAAVCvEraInfo@@XZ ; CvGame::getStartEraInfo
	mov	ecx, eax
	call	?getBuildingMaintenancePercent@CvEraInfo@@QBEHXZ ; CvEraInfo::getBuildingMaintenancePercent
	mov	ecx, eax
	imul	ecx, esi

; 803  : 	iMaintenance /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	pop	edi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	esi
	add	eax, edx
	pop	ebx

; 804  : 
; 805  : 	return iMaintenance;
; 806  : }

	ret	0
?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetBuildingGoldMaintenance
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	?AverageIncome@CvTreasury@@QAENH@Z		; CvTreasury::AverageIncome
;	COMDAT __real@0000000000000000
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
CONST	ENDS
;	COMDAT ?AverageIncome@CvTreasury@@QAENH@Z
_TEXT	SEGMENT
$T219333 = -8						; size = 8
_iSamples$217881 = -8					; size = 4
tv248 = 8						; size = 4
_iTurns$ = 8						; size = 4
?AverageIncome@CvTreasury@@QAENH@Z PROC			; CvTreasury::AverageIncome, COMDAT
; _this$ = ecx

; 879  : 	CvAssertMsg(iTurns > 0, "Invalid number of turns parameter");
; 880  : 
; 881  : 	if(m_GoldChangeForTurnTimes100.size() > 0)

	mov	eax, DWORD PTR [ecx+72]
	sub	eax, DWORD PTR [ecx+68]
	sub	esp, 8
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN3@AverageInc

; 882  : 	{
; 883  : 		int iSamples = 0;
; 884  : 		int iIndex = m_GoldChangeForTurnTimes100.size() - 1;

	mov	eax, DWORD PTR [ecx+72]
	sub	eax, DWORD PTR [ecx+68]
	push	ebx

; 885  : 		int iTotal = 0;
; 886  : 
; 887  : 		while(iSamples < iTurns)

	mov	ebx, DWORD PTR _iTurns$[esp+8]
	push	ebp
	push	esi
	sar	eax, 2
	push	edi
	xor	edi, edi
	xor	edx, edx
	xor	esi, esi
	dec	eax
	xor	ebp, ebp
	cmp	ebx, 2
	mov	DWORD PTR _iSamples$217881[esp+24], edi
	jl	SHORT $LN16@AverageInc

; 888  : 		{
; 889  : 			iTotal += m_GoldChangeForTurnTimes100[iIndex];

	mov	esi, DWORD PTR [ecx+68]
	mov	esi, DWORD PTR [esi+eax*4]
	lea	edx, DWORD PTR [ebx-2]
	shr	edx, 1
	inc	edx
	imul	esi, edx
	lea	edi, DWORD PTR [edx+edx]
	mov	DWORD PTR _iSamples$217881[esp+24], edi
	mov	edx, esi
$LN16@AverageInc:

; 885  : 		int iTotal = 0;
; 886  : 
; 887  : 		while(iSamples < iTurns)

	cmp	edi, ebx
	jge	SHORT $LN14@AverageInc

; 888  : 		{
; 889  : 			iTotal += m_GoldChangeForTurnTimes100[iIndex];

	mov	ecx, DWORD PTR [ecx+68]
	mov	ebp, DWORD PTR [ecx+eax*4]

; 890  : 			iSamples++;

	inc	edi
	mov	DWORD PTR _iSamples$217881[esp+24], edi
$LN14@AverageInc:
	add	esi, edx

; 891  : 		}
; 892  : 
; 893  : 		return ((double)iTotal / (double)iSamples / 100);

	add	esi, ebp
	mov	DWORD PTR tv248[esp+20], esi
	fild	DWORD PTR tv248[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	fidiv	DWORD PTR _iSamples$217881[esp+12]
	pop	ebx
	fdiv	QWORD PTR __real@4059000000000000
	fstp	QWORD PTR $T219333[esp+8]
	fld	QWORD PTR $T219333[esp+8]

; 897  : }

	add	esp, 8
	ret	4
$LN3@AverageInc:

; 894  : 	}
; 895  : 
; 896  : 	return 0;

	fldz

; 897  : }

	add	esp, 8
	ret	4
?AverageIncome@CvTreasury@@QAENH@Z ENDP			; CvTreasury::AverageIncome
_TEXT	ENDS
PUBLIC	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z$1
__ehfuncinfo$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
xdata$x	ENDS
;	COMDAT ?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_strHeader$ = 8						; size = 4
_strLog$ = 12						; size = 4
_strHeaderValue$ = 16					; size = 28
_strValue$ = 44						; size = 28
?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z PROC ; TreasuryHelpers::AppendToLog, COMDAT

; 1092 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi

; 1093 : 	strHeader += strHeaderValue;

	mov	esi, DWORD PTR _strHeader$[esp+12]
	lea	eax, DWORD PTR _strHeaderValue$[esp+12]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1094 : 	strHeader += ",";

	push	OFFSET $SG218049
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1095 : 	strLog += strValue;

	mov	esi, DWORD PTR _strLog$[esp+12]
	lea	ecx, DWORD PTR _strValue$[esp+12]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1096 : 	strLog += ",";

	push	OFFSET $SG218050
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1097 : }

	lea	ecx, DWORD PTR _strHeaderValue$[esp+12]
	mov	BYTE PTR __$EHRec$[esp+24], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strValue$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z$0:
	lea	ecx, DWORD PTR _strValue$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z$1:
	lea	ecx, DWORD PTR _strHeaderValue$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z:
	mov	eax, OFFSET __ehfuncinfo$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ENDP ; TreasuryHelpers::AppendToLog
PUBLIC	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z$1
__ehfuncinfo$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
xdata$x	ENDS
;	COMDAT ?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z
_TEXT	SEGMENT
_str$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strHeader$ = 8						; size = 4
_strLog$ = 12						; size = 4
_strHeaderValue$ = 16					; size = 28
_iValue$ = 44						; size = 4
?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z PROC ; TreasuryHelpers::AppendToLog, COMDAT

; 1100 : {

	push	-1
	push	__ehhandler$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 1101 : 	strHeader += strHeaderValue;

	mov	esi, DWORD PTR _strHeader$[esp+40]
	lea	eax, DWORD PTR _strHeaderValue$[esp+40]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+56], 0
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1102 : 	strHeader += ",";

	push	OFFSET $SG218057
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1103 : 	CvString str;

	lea	ecx, DWORD PTR _str$[esp+44]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1104 : 	str.Format("%d,", iValue);

	mov	ecx, DWORD PTR _iValue$[esp+40]
	push	ecx
	lea	edx, DWORD PTR _str$[esp+48]
	push	OFFSET $SG218059
	push	edx
	mov	BYTE PTR __$EHRec$[esp+64], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1105 : 	strLog += str;

	mov	ecx, DWORD PTR _strLog$[esp+52]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR _str$[esp+44]
	push	eax
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1106 : }

	lea	ecx, DWORD PTR _str$[esp+44]
	mov	BYTE PTR __$EHRec$[esp+52], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strHeaderValue$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z$0:
	lea	ecx, DWORD PTR _strHeaderValue$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ENDP ; TreasuryHelpers::AppendToLog
PUBLIC	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z ; TreasuryHelpers::AppendToLog
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z$1
__ehfuncinfo$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
xdata$x	ENDS
;	COMDAT ?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z
_TEXT	SEGMENT
_str$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strHeader$ = 8						; size = 4
_strLog$ = 12						; size = 4
_strHeaderValue$ = 16					; size = 28
_fValue$ = 44						; size = 4
?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z PROC ; TreasuryHelpers::AppendToLog, COMDAT

; 1109 : {

	push	-1
	push	__ehhandler$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 1110 : 	strHeader += strHeaderValue;

	mov	esi, DWORD PTR _strHeader$[esp+40]
	lea	eax, DWORD PTR _strHeaderValue$[esp+40]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+56], 0
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1111 : 	strHeader += ",";

	push	OFFSET $SG218066
	mov	ecx, esi
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1112 : 	CvString str;

	lea	ecx, DWORD PTR _str$[esp+44]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1113 : 	str.Format("%.2f,", fValue);

	fld	DWORD PTR _fValue$[esp+40]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	ecx, DWORD PTR _str$[esp+52]
	push	OFFSET $SG218068
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+68], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1114 : 	strLog += str;

	mov	ecx, DWORD PTR _strLog$[esp+56]
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR _str$[esp+44]
	push	edx
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1115 : }

	lea	ecx, DWORD PTR _str$[esp+44]
	mov	BYTE PTR __$EHRec$[esp+52], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strHeaderValue$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z$0:
	lea	ecx, DWORD PTR _strHeaderValue$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z:
	mov	eax, OFFSET __ehfuncinfo$?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@M@Z ENDP ; TreasuryHelpers::AppendToLog
PUBLIC	?construct@?$allocator@H@std@@QAEXPAHABH@Z	; std::allocator<int>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@H@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@H@std@@QAEXPAHABH@Z PROC		; std::allocator<int>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@H@std@@QAEXPAHABH@Z ENDP		; std::allocator<int>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@H@std@@QAEXPAH@Z		; std::allocator<int>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@H@std@@QAEXPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@H@std@@QAEXPAH@Z PROC		; std::allocator<int>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@H@std@@QAEXPAH@Z ENDP		; std::allocator<int>::destroy
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::_Vector_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@V?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<int,std::allocator<int> >,SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@V?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0U1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@V?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_const_iterator<int,std::allocator<int> >,SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const > >, COMDAT

; 23   : 	{	// perform function for each element

	push	esi

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));

	mov	esi, DWORD PTR __First$[esp]
	push	edi

; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	edi, DWORD PTR __Last$[esp+4]

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, edi
	je	SHORT $LN1@for_each
	npad	2
$LL6@for_each:

; 29   : 		_Func(*_ChkFirst);

	mov	ecx, DWORD PTR __Func$[esp+4]
	push	esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	cmp	esi, edi
	jne	SHORT $LL6@for_each
$LN1@for_each:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Func$[esp+4]
	mov	edx, DWORD PTR __Func$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 31   : 	}

	ret	0
??$for_each@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@V?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_const_iterator<int,std::allocator<int> >,SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const > >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@2
	pop	esi
$LN3@Fill_n@2:

; 3243 : 	}

	ret	0
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?SetGoldTimes100@CvTreasury@@QAEXH@Z		; CvTreasury::SetGoldTimes100
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
;	COMDAT ?SetGoldTimes100@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?SetGoldTimes100@CvTreasury@@QAEXH@Z PROC		; CvTreasury::SetGoldTimes100, COMDAT
; _this$ = ecx

; 179  : 	// Minors don't get Gold!
; 180  : 	if(GetGoldTimes100() != iNewValue)

	mov	eax, DWORD PTR _iNewValue$[esp-4]
	cmp	DWORD PTR [ecx+8], eax
	je	SHORT $LN1@SetGoldTim

; 181  : 	{
; 182  : 		if(iNewValue < 0)
; 183  : 		{
; 184  : 			CvAssertMsg(false, "GAMEPLAY: Player is being set to a negative Gold value. Please send Jon this with your last 5 autosaves.");
; 185  : 		}
; 186  : 
; 187  : 		m_iGold = iNewValue;

	mov	DWORD PTR [ecx+8], eax

; 188  : 
; 189  : 		if(m_pPlayer->GetID() == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	mov	esi, DWORD PTR [eax+44]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	pop	esi
	jne	SHORT $LN1@SetGoldTim

; 190  : 		{
; 191  : 			// Are we now able to buy a Plot when we weren't before?
; 192  : 			//if (GetGold() >= m_pPlayer->GetBuyPlotCost() && iOldGold < m_pPlayer->GetBuyPlotCost() && m_pPlayer->getNumCities() > 0)
; 193  : 			//{
; 194  : 			//	CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_GOLD_TO_BUY_PLOT");
; 195  : 			//	CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ENOUGH_GOLD_TO_BUY_PLOT");
; 196  : 			//	CvNotifications* pNotifications = m_pPlayer->GetNotifications();
; 197  : 			//	if (pNotifications)
; 198  : 			//	{
; 199  : 			//		pNotifications->Add(NOTIFICATION_BUY_TILE, strBuffer, strSummary, -1, -1, -1);
; 200  : 			//	}
; 201  : 			//}
; 202  : 
; 203  : 			GC.GetEngineUserInterface()->setDirty(MiscButtons_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	4
	call	eax

; 204  : 			GC.GetEngineUserInterface()->setDirty(SelectionButtons_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	6
	call	eax

; 205  : 			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	11					; 0000000bH
	call	eax
$LN1@SetGoldTim:

; 206  : 		}
; 207  : 	}
; 208  : }

	ret	4
?SetGoldTimes100@CvTreasury@@QAEXH@Z ENDP		; CvTreasury::SetGoldTimes100
_TEXT	ENDS
PUBLIC	?ChangeGoldTimes100@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGoldTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeGoldTimes100@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeGoldTimes100@CvTreasury@@QAEXH@Z PROC		; CvTreasury::ChangeGoldTimes100, COMDAT
; _this$ = ecx

; 213  : 	SetGoldTimes100(GetGoldTimes100() + iChange);

	mov	eax, DWORD PTR [ecx+8]
	add	eax, DWORD PTR _iChange$[esp-4]
	mov	DWORD PTR _iChange$[esp-4], eax
	jmp	?SetGoldTimes100@CvTreasury@@QAEXH@Z	; CvTreasury::SetGoldTimes100
?ChangeGoldTimes100@CvTreasury@@QAEXH@Z ENDP		; CvTreasury::ChangeGoldTimes100
_TEXT	ENDS
PUBLIC	?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ	; CvTreasury::DoUpdateCityConnectionGold
; Function compile flags: /Ogtpy
;	COMDAT ?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ
_TEXT	SEGMENT
_iLoop$217654 = -4					; size = 4
?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ PROC	; CvTreasury::DoUpdateCityConnectionGold, COMDAT
; _this$ = ecx

; 300  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 301  : 	int iNumGold = 0;
; 302  : 
; 303  : 	CvCity* pCapitalCity = m_pPlayer->getCapitalCity();

	mov	ecx, DWORD PTR [esi+4]
	xor	ebp, ebp
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ebx, eax

; 304  : 
; 305  : 	// Must have a capital before we can check if other Cities are connected to it!
; 306  : 	if(pCapitalCity != NULL && m_pPlayer->getNumCities() > 1)

	test	ebx, ebx
	je	SHORT $LN12@DoUpdateCi
	mov	ecx, DWORD PTR [esi+4]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	jle	SHORT $LN12@DoUpdateCi

; 307  : 	{
; 308  : 		CvCity* pLoopCity;
; 309  : 
; 310  : 		int iLoop;
; 311  : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	push	ebp
	lea	eax, DWORD PTR _iLoop$217654[esp+24]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN11@DoUpdateCi
$LL14@DoUpdateCi:

; 312  : 		{
; 313  : 			if(pLoopCity != pCapitalCity)

	cmp	edi, ebx
	je	SHORT $LN4@DoUpdateCi

; 314  : 			{
; 315  : 				if(HasCityConnectionRouteBetweenCities(pCapitalCity, pLoopCity))

	push	0
	push	edi
	push	ebx
	mov	ecx, esi
	call	?HasCityConnectionRouteBetweenCities@CvTreasury@@QBE_NPAVCvCity@@0_N@Z ; CvTreasury::HasCityConnectionRouteBetweenCities
	test	al, al
	je	SHORT $LN4@DoUpdateCi

; 316  : 				{
; 317  : 					iNumGold += GetCityConnectionRouteGoldTimes100(pLoopCity);

	push	edi
	mov	ecx, esi
	call	?GetCityConnectionRouteGoldTimes100@CvTreasury@@QBEHPAVCvCity@@@Z ; CvTreasury::GetCityConnectionRouteGoldTimes100
	add	ebp, eax
$LN4@DoUpdateCi:
	push	0
	lea	ecx, DWORD PTR _iLoop$217654[esp+24]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL14@DoUpdateCi
$LN11@DoUpdateCi:
	pop	edi

; 318  : 				}
; 319  : 			}
; 320  : 		}
; 321  : 	}
; 322  : 
; 323  : 	m_iCityConnectionGoldTimes100 = iNumGold;

	mov	DWORD PTR [esi+24], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 324  : }

	pop	ecx
	ret	0
$LN12@DoUpdateCi:

; 318  : 				}
; 319  : 			}
; 320  : 		}
; 321  : 	}
; 322  : 
; 323  : 	m_iCityConnectionGoldTimes100 = iNumGold;

	mov	DWORD PTR [esi+24], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 324  : }

	pop	ecx
	ret	0
?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ ENDP	; CvTreasury::DoUpdateCityConnectionGold
_TEXT	ENDS
PUBLIC	?ChangeCityConnectionTradeRouteGoldModifier@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeCityConnectionTradeRouteGoldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeCityConnectionTradeRouteGoldModifier@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeCityConnectionTradeRouteGoldModifier@CvTreasury@@QAEXH@Z PROC ; CvTreasury::ChangeCityConnectionTradeRouteGoldModifier, COMDAT
; _this$ = ecx

; 336  : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	test	eax, eax
	je	SHORT $LN1@ChangeCity

; 337  : 	{
; 338  : 		m_iCityConnectionTradeRouteGoldModifier += iChange;

	add	DWORD PTR [ecx+28], eax

; 339  : 
; 340  : 		DoUpdateCityConnectionGold();

	call	?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ ; CvTreasury::DoUpdateCityConnectionGold
$LN1@ChangeCity:

; 341  : 	}
; 342  : }

	ret	4
?ChangeCityConnectionTradeRouteGoldModifier@CvTreasury@@QAEXH@Z ENDP ; CvTreasury::ChangeCityConnectionTradeRouteGoldModifier
_TEXT	ENDS
PUBLIC	?ChangeCityConnectionTradeRouteGoldChange@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeCityConnectionTradeRouteGoldChange
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeCityConnectionTradeRouteGoldChange@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeCityConnectionTradeRouteGoldChange@CvTreasury@@QAEXH@Z PROC ; CvTreasury::ChangeCityConnectionTradeRouteGoldChange, COMDAT
; _this$ = ecx

; 353  : 	if(iChange != 0)

	mov	eax, DWORD PTR _iChange$[esp-4]
	test	eax, eax
	je	SHORT $LN1@ChangeCity@2

; 354  : 	{
; 355  : 		m_iCityConnectionTradeRouteGoldChange += iChange;

	add	DWORD PTR [ecx+32], eax

; 356  : 
; 357  : 		DoUpdateCityConnectionGold();

	call	?DoUpdateCityConnectionGold@CvTreasury@@QAEXXZ ; CvTreasury::DoUpdateCityConnectionGold
$LN1@ChangeCity@2:

; 358  : 	}
; 359  : }

	ret	4
?ChangeCityConnectionTradeRouteGoldChange@CvTreasury@@QAEXH@Z ENDP ; CvTreasury::ChangeCityConnectionTradeRouteGoldChange
_TEXT	ENDS
PUBLIC	?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ	; CvTreasury::GetGoldPerTurnFromReligion
EXTRN	?GetNumFollowers@CvGameReligions@@QBEHW4ReligionTypes@@@Z:PROC ; CvGameReligions::GetNumFollowers
EXTRN	?GetGoldPerXFollowers@CvReligionBeliefs@@QBEHXZ:PROC ; CvReligionBeliefs::GetGoldPerXFollowers
EXTRN	?GetNumCitiesFollowing@CvGameReligions@@QBEHW4ReligionTypes@@@Z:PROC ; CvGameReligions::GetNumCitiesFollowing
EXTRN	?GetGoldPerFollowingCity@CvReligionBeliefs@@QBEHXZ:PROC ; CvReligionBeliefs::GetGoldPerFollowingCity
EXTRN	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligion
EXTRN	?GetFounderBenefitsReligion@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetFounderBenefitsReligion
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ
_TEXT	SEGMENT
_iGoldPerFollowingCity$217722 = -4			; size = 4
?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ PROC	; CvTreasury::GetGoldPerTurnFromReligion, COMDAT
; _this$ = ecx

; 461  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 462  : 	int iGoldFromReligion = 0;
; 463  : 
; 464  : 	CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	edi
	xor	ebp, ebp
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	edi, eax

; 465  : 
; 466  : 	// Founder beliefs
; 467  : 	ReligionTypes eFoundedReligion = pReligions->GetFounderBenefitsReligion(m_pPlayer->GetID());

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, edi
	call	?GetFounderBenefitsReligion@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetFounderBenefitsReligion
	mov	ebx, eax

; 468  : 	if(eFoundedReligion != NO_RELIGION)

	cmp	ebx, -1
	je	SHORT $LN14@GetGoldPer@2

; 469  : 	{
; 470  : 		const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, NO_PLAYER);

	push	-1
	push	ebx
	mov	ecx, edi
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion

; 471  : 		if(pReligion)

	test	eax, eax
	je	SHORT $LN14@GetGoldPer@2

; 472  : 		{
; 473  : 			int iGoldPerFollowingCity = pReligion->m_Beliefs.GetGoldPerFollowingCity();

	lea	ebp, DWORD PTR [eax+152]
	mov	ecx, ebp
	call	?GetGoldPerFollowingCity@CvReligionBeliefs@@QBEHXZ ; CvReligionBeliefs::GetGoldPerFollowingCity

; 474  : 			iGoldFromReligion += (pReligions->GetNumCitiesFollowing(eFoundedReligion) * iGoldPerFollowingCity);

	push	ebx
	mov	ecx, edi
	mov	DWORD PTR _iGoldPerFollowingCity$217722[esp+24], eax
	call	?GetNumCitiesFollowing@CvGameReligions@@QBEHW4ReligionTypes@@@Z ; CvGameReligions::GetNumCitiesFollowing
	mov	esi, eax
	imul	esi, DWORD PTR _iGoldPerFollowingCity$217722[esp+20]

; 475  : 
; 476  : 			int iGoldPerXFollowers = pReligion->m_Beliefs.GetGoldPerXFollowers();

	mov	ecx, ebp
	call	?GetGoldPerXFollowers@CvReligionBeliefs@@QBEHXZ ; CvReligionBeliefs::GetGoldPerXFollowers
	mov	ebp, eax

; 477  : 			if(iGoldPerXFollowers > 0)

	test	ebp, ebp
	jle	SHORT $LN12@GetGoldPer@2

; 478  : 			{
; 479  : 				iGoldFromReligion += (pReligions->GetNumFollowers(eFoundedReligion) / iGoldPerXFollowers);

	push	ebx
	mov	ecx, edi
	call	?GetNumFollowers@CvGameReligions@@QBEHW4ReligionTypes@@@Z ; CvGameReligions::GetNumFollowers
	cdq
	idiv	ebp
	add	esi, eax
$LN12@GetGoldPer@2:
	pop	edi

; 480  : 			}
; 481  : 		}
; 482  : 	}
; 483  : 
; 484  : 	return iGoldFromReligion;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 485  : }

	pop	ecx
	ret	0
$LN14@GetGoldPer@2:
	pop	edi
	pop	esi

; 480  : 			}
; 481  : 		}
; 482  : 	}
; 483  : 
; 484  : 	return iGoldFromReligion;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 485  : }

	pop	ecx
	ret	0
?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ ENDP	; CvTreasury::GetGoldPerTurnFromReligion
_TEXT	ENDS
PUBLIC	?CalculateGrossGoldTimes100@CvTreasury@@QAEHXZ	; CvTreasury::CalculateGrossGoldTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?CalculateGrossGoldTimes100@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
?CalculateGrossGoldTimes100@CvTreasury@@QAEHXZ PROC	; CvTreasury::CalculateGrossGoldTimes100, COMDAT
; _this$ = ecx

; 495  : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 496  : 	int iNetGold;
; 497  : 
; 498  : 	// Gold from Cities
; 499  : 	iNetGold = GetGoldFromCitiesTimes100();

	push	0
	mov	esi, ecx
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100

; 500  : 
; 501  : 	// Gold per Turn from Diplomacy
; 502  : 	iNetGold += GetGoldPerTurnFromDiplomacy() * 100;

	mov	edi, DWORD PTR [esi+12]

; 503  : 
; 504  : 	// City connection bonuses
; 505  : 	iNetGold += GetCityConnectionGoldTimes100();

	mov	ebp, DWORD PTR [esi+24]

; 506  : 
; 507  : 	// Religion
; 508  : 	iNetGold += GetGoldPerTurnFromReligion() * 100;

	mov	ecx, esi
	mov	ebx, eax
	call	?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromReligion

; 509  : 
; 510  : 	// International trade
; 511  : 	iNetGold += GetGoldPerTurnFromTraits() * 100;

	mov	ecx, DWORD PTR [esi+4]
	add	eax, edi
	imul	eax, 100				; 00000064H
	add	eax, ebp
	add	ebx, eax
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	edi, DWORD PTR [eax+504]
	test	edi, edi
	jle	SHORT $LN7@CalculateG
	mov	ecx, DWORD PTR [esi+4]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, DWORD PTR [esi+4]
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	mov	ecx, DWORD PTR [esi+4]
	add	edi, eax
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ ; CvPlayerTrade::GetNumDifferentTradingPartners
	imul	edi, eax
$LN7@CalculateG:
	mov	eax, edi
	imul	eax, 100				; 00000064H
	pop	edi
	pop	esi
	pop	ebp
	add	eax, ebx
	pop	ebx

; 512  : 
; 513  : 	return iNetGold;
; 514  : }

	ret	0
?CalculateGrossGoldTimes100@CvTreasury@@QAEHXZ ENDP	; CvTreasury::CalculateGrossGoldTimes100
_TEXT	ENDS
PUBLIC	?CalculatePreInflatedCosts@CvTreasury@@QAEHXZ	; CvTreasury::CalculatePreInflatedCosts
; Function compile flags: /Ogtpy
;	COMDAT ?CalculatePreInflatedCosts@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
_iPaidUnits$ = -16					; size = 4
_iExtraCost$ = -12					; size = 4
_iBaseUnitCost$ = -8					; size = 4
_iBaseSupplyCost$ = -4					; size = 4
_iFreeUnits$ = -4					; size = 4
?CalculatePreInflatedCosts@CvTreasury@@QAEHXZ PROC	; CvTreasury::CalculatePreInflatedCosts, COMDAT
; _this$ = ecx

; 699  : {

	sub	esp, 16					; 00000010H
	push	esi
	push	edi
	mov	esi, ecx

; 700  : 	int iFreeUnits;
; 701  : 	int iPaidUnits;
; 702  : 	int iBaseUnitCost;
; 703  : 	int iExtraCost;
; 704  : 	int iBaseSupplyCost;
; 705  : 
; 706  : 	m_iExpensePerTurnUnitMaintenance = CalculateUnitCost(iFreeUnits, iPaidUnits, iBaseUnitCost, iExtraCost);

	lea	eax, DWORD PTR _iExtraCost$[esp+24]
	push	eax
	lea	ecx, DWORD PTR _iBaseUnitCost$[esp+28]
	push	ecx
	lea	edx, DWORD PTR _iPaidUnits$[esp+32]
	push	edx
	lea	eax, DWORD PTR _iFreeUnits$[esp+36]
	push	eax
	mov	ecx, esi
	call	?CalculateUnitCost@CvTreasury@@QAEHAAH000@Z ; CvTreasury::CalculateUnitCost

; 707  : 	m_iExpensePerTurnUnitSupply = CalculateUnitSupply(iPaidUnits, iBaseSupplyCost);

	lea	ecx, DWORD PTR _iBaseSupplyCost$[esp+24]
	push	ecx
	lea	edx, DWORD PTR _iPaidUnits$[esp+28]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR [esi+16], eax
	call	?CalculateUnitSupply@CvTreasury@@QAEHAAH0@Z ; CvTreasury::CalculateUnitSupply

; 708  : 
; 709  : 	int iTotalCosts = 0;
; 710  : 
; 711  : 	iTotalCosts += m_iExpensePerTurnUnitMaintenance;
; 712  : 	iTotalCosts += m_iExpensePerTurnUnitSupply;

	mov	edi, DWORD PTR [esi+16]

; 713  : 	iTotalCosts += GetBuildingGoldMaintenance();

	mov	ecx, esi
	mov	DWORD PTR [esi+20], eax
	add	edi, eax
	call	?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetBuildingGoldMaintenance

; 714  : 	iTotalCosts += GetImprovementGoldMaintenance();

	mov	ecx, esi
	add	edi, eax
	call	?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetImprovementGoldMaintenance
	add	eax, edi
	pop	edi
	pop	esi

; 715  : 
; 716  : 	return iTotalCosts;
; 717  : }

	add	esp, 16					; 00000010H
	ret	0
?CalculatePreInflatedCosts@CvTreasury@@QAEHXZ ENDP	; CvTreasury::CalculatePreInflatedCosts
_TEXT	ENDS
PUBLIC	?CalculateInflatedCosts@CvTreasury@@QAEHXZ	; CvTreasury::CalculateInflatedCosts
; Function compile flags: /Ogtpy
;	COMDAT ?CalculateInflatedCosts@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
?CalculateInflatedCosts@CvTreasury@@QAEHXZ PROC		; CvTreasury::CalculateInflatedCosts, COMDAT
; _this$ = ecx

; 766  : 	int iCosts = CalculatePreInflatedCosts();

	jmp	?CalculatePreInflatedCosts@CvTreasury@@QAEHXZ ; CvTreasury::CalculatePreInflatedCosts
?CalculateInflatedCosts@CvTreasury@@QAEHXZ ENDP		; CvTreasury::CalculateInflatedCosts
_TEXT	ENDS
PUBLIC	?SetBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::SetBaseImprovementGoldMaintenance
; Function compile flags: /Ogtpy
;	COMDAT ?SetBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z PROC ; CvTreasury::SetBaseImprovementGoldMaintenance, COMDAT
; _this$ = ecx

; 856  : 	if(GetBaseImprovementGoldMaintenance() != iValue)

	mov	eax, DWORD PTR _iValue$[esp-4]
	cmp	DWORD PTR [ecx+40], eax
	je	SHORT $LN1@SetBaseImp

; 857  : 	{
; 858  : 		m_iBaseImprovementGoldMaintenance = iValue;

	mov	DWORD PTR [ecx+40], eax

; 859  : 
; 860  : 		CvAssertMsg(m_iBaseImprovementGoldMaintenance >= 0, "Improvement Maintenance is negative somehow. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 861  : 
; 862  : 		if(m_iBaseImprovementGoldMaintenance < 0)

	test	eax, eax
	jge	SHORT $LN2@SetBaseImp

; 863  : 			m_iBaseImprovementGoldMaintenance = 0;

	mov	DWORD PTR [ecx+40], 0
$LN2@SetBaseImp:

; 864  : 
; 865  : 		if(m_pPlayer->GetID() == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	mov	esi, DWORD PTR [eax+44]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	pop	esi
	jne	SHORT $LN1@SetBaseImp

; 866  : 			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	11					; 0000000bH
	call	eax
$LN1@SetBaseImp:

; 867  : 	}
; 868  : }

	ret	4
?SetBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ENDP ; CvTreasury::SetBaseImprovementGoldMaintenance
_TEXT	ENDS
PUBLIC	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z PROC ; CvTreasury::ChangeBaseImprovementGoldMaintenance, COMDAT
; _this$ = ecx

; 873  : 	SetBaseImprovementGoldMaintenance(GetBaseImprovementGoldMaintenance() + iChange);

	mov	eax, DWORD PTR [ecx+40]
	add	eax, DWORD PTR _iChange$[esp-4]
	cmp	DWORD PTR [ecx+40], eax
	je	SHORT $LN5@ChangeBase@2
	mov	DWORD PTR [ecx+40], eax
	test	eax, eax
	jge	SHORT $LN6@ChangeBase@2
	mov	DWORD PTR [ecx+40], 0
$LN6@ChangeBase@2:
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	esi
	mov	esi, DWORD PTR [eax+44]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	esi, eax
	pop	esi
	jne	SHORT $LN5@ChangeBase@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	11					; 0000000bH
	call	eax
$LN5@ChangeBase@2:

; 874  : }

	ret	4
?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ENDP ; CvTreasury::ChangeBaseImprovementGoldMaintenance
_TEXT	ENDS
PUBLIC	?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z	; CvTreasury::LogExpenditure
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT ?bFirstRun@?7??LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z@4_NA
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_DATA	SEGMENT
?bFirstRun@?7??LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z@4_NA DB 01H ; `CvTreasury::LogExpenditure'::`8'::bFirstRun
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z DD 019930522H
	DD	019H
	DD	FLAT:__unwindtable$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$14
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$17
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$20
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$23
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$26
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$29
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$32
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$35
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$38
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$41
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$44
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$47
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$50
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$53
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$56
	DD	07H
	DD	FLAT:__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$59
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
xdata$x	ENDS
;	COMDAT ?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z
_TEXT	SEGMENT
$T219883 = -220						; size = 4
$T219881 = -220						; size = 4
$T219880 = -220						; size = 4
$T219878 = -220						; size = 4
$T219877 = -220						; size = 4
$T219875 = -220						; size = 4
$T219874 = -220						; size = 4
$T219872 = -220						; size = 4
$T219871 = -220						; size = 4
$T219869 = -220						; size = 4
$T219868 = -220						; size = 4
$T219866 = -220						; size = 4
$T219865 = -220						; size = 4
$T219863 = -220						; size = 4
$T219862 = -220						; size = 4
$T219860 = -220						; size = 4
$T219859 = -220						; size = 4
$T219857 = -220						; size = 4
$T219856 = -220						; size = 4
$T219854 = -220						; size = 4
$T219853 = -220						; size = 4
$T219851 = -220						; size = 4
$T219850 = -220						; size = 4
$T219848 = -220						; size = 4
$T219847 = -220						; size = 4
$T219845 = -220						; size = 4
$T219844 = -220						; size = 4
$T219842 = -220						; size = 4
$T219841 = -220						; size = 4
$T219839 = -220						; size = 4
$T219838 = -220						; size = 4
$T219836 = -220						; size = 4
$T219835 = -220						; size = 4
$T219834 = -220						; size = 4
$T219833 = -220						; size = 4
$T219832 = -220						; size = 4
$T219831 = -220						; size = 4
$T219882 = -216						; size = 4
$T219879 = -216						; size = 4
$T219876 = -216						; size = 4
$T219873 = -216						; size = 4
$T219870 = -216						; size = 4
$T219867 = -216						; size = 4
$T219864 = -216						; size = 4
$T219861 = -216						; size = 4
$T219858 = -216						; size = 4
$T219855 = -216						; size = 4
$T219852 = -216						; size = 4
$T219849 = -216						; size = 4
$T219846 = -216						; size = 4
$T219843 = -216						; size = 4
$T219840 = -216						; size = 4
$T219837 = -216						; size = 4
$T219830 = -216						; size = 4
_bBuildHeader$ = -209					; size = 1
_strHeader$ = -208					; size = 28
_strLog$ = -180						; size = 28
_strPlayerName$ = -152					; size = 28
_strLogName$ = -124					; size = 28
$T219828 = -96						; size = 28
$T219829 = -68						; size = 28
_str$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strExpenditure$ = 8					; size = 28
_iAmount$ = 36						; size = 4
_iColumn$ = 40						; size = 4
?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z PROC	; CvTreasury::LogExpenditure, COMDAT
; _this$ = ecx

; 900  : {

	push	-1
	push	__ehhandler$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 901  : 	if(!(GC.getLogging() && GC.getAILogging()))

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+244], 0
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN24@LogExpendi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN24@LogExpendi

; 902  : 	{
; 903  : 		return;
; 904  : 	}
; 905  : 
; 906  : 	// don't log minor civs for now
; 907  : 	if(m_pPlayer->isMinorCiv())

	mov	ecx, DWORD PTR [edi+4]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al

; 908  : 	{
; 909  : 		return;

	jne	$LN24@LogExpendi

; 910  : 	}
; 911  : 
; 912  : 	static bool bFirstRun = true;
; 913  : 	bool bBuildHeader = false;
; 914  : 	CvString strHeader;

	lea	ecx, DWORD PTR _strHeader$[esp+236]
	mov	BYTE PTR _bBuildHeader$[esp+236], al
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 915  : 	if(bFirstRun)

	cmp	BYTE PTR ?bFirstRun@?7??LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z@4_NA, 0
	mov	BYTE PTR __$EHRec$[esp+244], 1
	je	SHORT $LN22@LogExpendi

; 916  : 	{
; 917  : 		bFirstRun = false;

	mov	BYTE PTR ?bFirstRun@?7??LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z@4_NA, 0

; 918  : 		bBuildHeader = true;

	mov	BYTE PTR _bBuildHeader$[esp+236], 1
$LN22@LogExpendi:

; 919  : 	}
; 920  : 
; 921  : 	CvString strLog;

	lea	ecx, DWORD PTR _strLog$[esp+236]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 922  : 
; 923  : 	// Find the name of this civ and city
; 924  : 	CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$[esp+236]
	mov	BYTE PTR __$EHRec$[esp+244], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 925  : 	strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi+4]
	mov	BYTE PTR __$EHRec$[esp+244], 3
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$[esp+236]
	test	eax, eax
	je	SHORT $LN106@LogExpendi
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN105@LogExpendi
$LN106@LogExpendi:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN105@LogExpendi:

; 926  : 	CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$[esp+236]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 927  : 
; 928  : 	// Open the log file
; 929  : 	if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR __$EHRec$[esp+244], 4
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	test	al, al
	je	SHORT $LN21@LogExpendi

; 930  : 	{
; 931  : 		strLogName = "ExpenditureLog_" + strPlayerName + ".csv";

	lea	eax, DWORD PTR _strPlayerName$[esp+236]
	push	eax
	lea	ecx, DWORD PTR $T219828[esp+240]
	push	OFFSET $SG217910
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG217909
	push	eax
	lea	edx, DWORD PTR $T219829[esp+256]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+268], 5
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+244], 6
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$[esp+240]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T219829[esp+236]
	mov	BYTE PTR __$EHRec$[esp+244], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T219828[esp+236]
	mov	BYTE PTR __$EHRec$[esp+244], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 932  : 	}
; 933  : 	else

	jmp	SHORT $LN20@LogExpendi
$LN21@LogExpendi:

; 934  : 	{
; 935  : 		strLogName = "ExpenditureLog.csv";

	push	OFFSET $SG217912
	lea	ecx, DWORD PTR _strLogName$[esp+240]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
$LN20@LogExpendi:

; 936  : 	}
; 937  : 
; 938  : 
; 939  : 	FILogFile* pLog;
; 940  : 	pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strLogName$[esp+236]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 941  : 
; 942  : 	CvString str;

	lea	ecx, DWORD PTR _str$[esp+236]
	mov	ebp, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 943  : 
; 944  : 	// civ name
; 945  : 	TreasuryHelpers::AppendToLog(strHeader, strLog, "Civ Name", strPlayerName);

	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strPlayerName$[esp+264]
	mov	DWORD PTR $T219830[esp+264], esp
	mov	ecx, esp
	mov	ebx, 7
	push	edx
	mov	BYTE PTR __$EHRec$[esp+276], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219831[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG217917
	mov	BYTE PTR __$EHRec$[esp+304], 8
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+292]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+296]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog

; 946  : 
; 947  : 	// turn
; 948  : 	TreasuryHelpers::AppendToLog(strHeader, strLog, "Turn", GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	esp, 64					; 00000040H
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219832[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG217919
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+268]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+272]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog

; 949  : 
; 950  : 	// treasury at turn start
; 951  : 	TreasuryHelpers::AppendToLog(strHeader, strLog, "Treasury Before Purchase", m_pPlayer->GetTreasury()->GetGold());

	mov	ecx, DWORD PTR [edi+4]
	add	esp, 40					; 00000028H
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219833[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG217921
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+268]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+272]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog

; 952  : 	
; 953  : 	// Cost of Plot
; 954  : 	if (iColumn == 1){

	mov	esi, DWORD PTR _iColumn$[esp+272]
	mov	edi, DWORD PTR _iAmount$[esp+272]
	add	esp, 40					; 00000028H
	cmp	esi, 1
	jne	$LN19@LogExpendi

; 955  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Cost of Plot:", iAmount);

	push	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219834[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG217924
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+268]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+272]
	push	edx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN17@LogExpendi:

; 965  : 	}
; 966  : 	else{
; 967  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City Bought:", "");

	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219839[esp+264], esp
	mov	ecx, esp
	push	OFFSET $SG217937
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219840[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG217938
	mov	BYTE PTR __$EHRec$[esp+304], 10		; 0000000aH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+292]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+296]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 968  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City Spent:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219841[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG217940
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+268]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+272]
	push	ecx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 969  : 	}
; 970  : 	
; 971  : 	// Unit Upgrade and cost
; 972  : 	if (iColumn == 3){

	cmp	esi, 3
	jne	$LN15@LogExpendi

; 973  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Unit Upgraded:", strExpenditure);

	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strExpenditure$[esp+260]
	mov	DWORD PTR $T219842[esp+264], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219843[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG217944
	mov	BYTE PTR __$EHRec$[esp+304], 11		; 0000000bH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+292]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+296]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 974  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Spent on Upgrade:", iAmount);

	push	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219844[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG217946
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+268]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+272]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN13@LogExpendi:

; 985  : 	}
; 986  : 	else{
; 987  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City State Gold Gifted:", "");

	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219851[esp+264], esp
	mov	ecx, esp
	push	OFFSET $SG217963
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219852[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG217964
	mov	BYTE PTR __$EHRec$[esp+304], 14		; 0000000eH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+292]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+296]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 988  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Gold Gift Amount:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219853[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG217966
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+268]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+272]
	push	ecx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 989  : 	}
; 990  : 	
; 991  : 	// City State Improved and Amount
; 992  : 	if (iColumn == 5){

	cmp	esi, 5
	jne	$LN11@LogExpendi

; 993  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City State Improved:", strExpenditure);

	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strExpenditure$[esp+260]
	mov	DWORD PTR $T219854[esp+264], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219855[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG217970
	mov	BYTE PTR __$EHRec$[esp+304], 15		; 0000000fH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+292]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+296]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 994  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Gold for Improvement Amount:", iAmount);

	push	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219856[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG217972
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+268]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+272]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN9@LogExpendi:

; 1005 : 	}
; 1006 : 	else{
; 1007 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City State Bought:", "");

	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219863[esp+264], esp
	mov	ecx, esp
	push	OFFSET $SG217989
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219864[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG217990
	mov	BYTE PTR __$EHRec$[esp+304], 18		; 00000012H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+292]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+296]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1008 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Bought for:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219865[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG217992
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+268]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+272]
	push	ecx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 1009 : 	}
; 1010 : 	
; 1011 : 	// Emergency City Expenditure Unit and Amount
; 1012 : 	if (iColumn == 7){

	cmp	esi, ebx
	jne	$LN7@LogExpendi

; 1013 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Unit:", strExpenditure);

	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strExpenditure$[esp+260]
	mov	DWORD PTR $T219866[esp+264], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219867[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG217996
	mov	BYTE PTR __$EHRec$[esp+304], 19		; 00000013H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+292]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+296]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1014 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Unit Cost:", iAmount);

	push	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219868[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG217998
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+268]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+272]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN5@LogExpendi:

; 1025 : 	}
; 1026 : 	else{
; 1027 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Building:", "");

	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219875[esp+264], esp
	mov	ecx, esp
	push	OFFSET $SG218015
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219876[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG218016
	mov	BYTE PTR __$EHRec$[esp+304], 22		; 00000016H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+292]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+296]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1028 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Building Cost:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219877[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG218018
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+268]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+272]
	push	ecx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 1029 : 	}
; 1030 : 
; 1031 : 	// Research Agreement and Amount
; 1032 : 	if (iColumn == 9){

	cmp	esi, 9
	jne	$LN3@LogExpendi

; 1033 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Research Agreement with:", strExpenditure);

	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strExpenditure$[esp+260]
	mov	DWORD PTR $T219878[esp+264], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219879[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG218022
	mov	BYTE PTR __$EHRec$[esp+304], 23		; 00000017H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+292]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+296]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1034 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Research Agreement Cost:", iAmount);

	push	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219880[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG218024
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+268]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+272]
	push	eax

; 1035 : 	}
; 1036 : 	else{

	jmp	$LN398@LogExpendi
$LN19@LogExpendi:

; 956  : 	}
; 957  : 	else{
; 958  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Cost of Plot:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219835[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG217927
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+268]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+272]
	push	ecx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 959  : 	}
; 960  : 	
; 961  : 	// City Expenditure and Amount
; 962  : 	if (iColumn == 2){

	cmp	esi, 2
	jne	$LN17@LogExpendi

; 963  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City Bought:", strExpenditure);

	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strExpenditure$[esp+260]
	mov	DWORD PTR $T219836[esp+264], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219837[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG217931
	mov	BYTE PTR __$EHRec$[esp+304], 9
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+292]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+296]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog

; 964  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City Spent:", iAmount);

	mov	edi, DWORD PTR _iAmount$[esp+296]
	add	esp, 64					; 00000040H
	push	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219838[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG217933
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+268]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+272]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN15@LogExpendi:

; 975  : 	}
; 976  : 	else{
; 977  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Unit Upgrade:", "");

	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219845[esp+264], esp
	mov	ecx, esp
	push	OFFSET $SG217950
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219846[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG217951
	mov	BYTE PTR __$EHRec$[esp+304], 12		; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+292]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+296]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 978  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Spent on Upgrade:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219847[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG217953
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+268]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+272]
	push	ecx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 979  : 	}
; 980  : 
; 981  : 	// City State Gifted and Amount
; 982  : 	if (iColumn == 4){

	cmp	esi, 4
	jne	$LN13@LogExpendi

; 983  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City State Gold Gifted:", strExpenditure);

	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strExpenditure$[esp+260]
	mov	DWORD PTR $T219848[esp+264], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219849[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG217957
	mov	BYTE PTR __$EHRec$[esp+304], 13		; 0000000dH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+292]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+296]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 984  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Gold Gift Amount:", iAmount);

	push	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219850[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG217959
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+268]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+272]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN11@LogExpendi:

; 995  : 	}
; 996  : 	else{
; 997  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City State Improved:", "");

	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219857[esp+264], esp
	mov	ecx, esp
	push	OFFSET $SG217976
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219858[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG217977
	mov	BYTE PTR __$EHRec$[esp+304], 16		; 00000010H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+292]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+296]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 998  : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Gold for Improvement Amount:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219859[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG217979
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+268]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+272]
	push	ecx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 999  : 	}
; 1000 : 
; 1001 : 	// City State Bought and Amount
; 1002 : 	if (iColumn == 6){

	cmp	esi, 6
	jne	$LN9@LogExpendi

; 1003 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "City State Bought:", strExpenditure);

	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strExpenditure$[esp+260]
	mov	DWORD PTR $T219860[esp+264], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219861[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG217983
	mov	BYTE PTR __$EHRec$[esp+304], 17		; 00000011H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+292]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+296]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1004 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Bought for:", iAmount);

	push	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219862[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG217985
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+268]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+272]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN7@LogExpendi:

; 1015 : 	}
; 1016 : 	else{
; 1017 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Unit:", "");

	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219869[esp+264], esp
	mov	ecx, esp
	push	OFFSET $SG218002
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219870[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG218003
	mov	BYTE PTR __$EHRec$[esp+304], 20		; 00000014H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+292]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+296]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1018 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Unit Cost:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219871[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG218005
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+268]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+272]
	push	ecx
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 1019 : 	}
; 1020 : 	
; 1021 : 	// Emergency City Expenditure Unit and Amount
; 1022 : 	if (iColumn == 8){

	cmp	esi, 8
	jne	$LN5@LogExpendi

; 1023 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Building:", strExpenditure);

	sub	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strExpenditure$[esp+260]
	mov	DWORD PTR $T219872[esp+264], esp
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219873[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG218009
	mov	BYTE PTR __$EHRec$[esp+304], 21		; 00000015H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+292]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+296]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1024 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Emergency Building Cost:", iAmount);

	push	edi
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219874[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG218011
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	edx, DWORD PTR _strLog$[esp+268]
	push	edx
	lea	eax, DWORD PTR _strHeader$[esp+272]
	push	eax
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H
$LN3@LogExpendi:

; 1037 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Research Agreement with:", "");

	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219881[esp+264], esp
	mov	ecx, esp
	push	OFFSET $SG218028
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219882[esp+292], esp
	mov	ecx, esp
	push	OFFSET $SG218029
	mov	BYTE PTR __$EHRec$[esp+304], 24		; 00000018H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR _strLog$[esp+292]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[esp+296]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+308], bl
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@1@Z ; TreasuryHelpers::AppendToLog
	add	esp, 64					; 00000040H

; 1038 : 		TreasuryHelpers::AppendToLog(strHeader, strLog, "Research Agreement Cost:", 0);

	push	0
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR $T219883[esp+268], esp
	mov	ecx, esp
	push	OFFSET $SG218031
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	eax, DWORD PTR _strLog$[esp+268]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[esp+272]
	push	ecx
$LN398@LogExpendi:
	call	?AppendToLog@TreasuryHelpers@@YAXAAVCvString@@0V2@H@Z ; TreasuryHelpers::AppendToLog
	add	esp, 40					; 00000028H

; 1039 : 	}
; 1040 : 
; 1041 : 	if(bBuildHeader)

	cmp	BYTE PTR _bBuildHeader$[esp+236], 0
	je	SHORT $LN1@LogExpendi

; 1042 : 	{
; 1043 : 		pLog->Msg(strHeader);

	lea	ecx, DWORD PTR _strHeader$[esp+236]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [ebp]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ebp
	call	eax
	add	esp, 8
$LN1@LogExpendi:

; 1044 : 	}
; 1045 : 	pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$[esp+236]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	ebp
	call	edx
	add	esp, 8

; 1046 : }

	lea	ecx, DWORD PTR _str$[esp+236]
	mov	BYTE PTR __$EHRec$[esp+244], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogName$[esp+236]
	mov	BYTE PTR __$EHRec$[esp+244], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strPlayerName$[esp+236]
	mov	BYTE PTR __$EHRec$[esp+244], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLog$[esp+236]
	mov	BYTE PTR __$EHRec$[esp+244], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strHeader$[esp+236]
	mov	BYTE PTR __$EHRec$[esp+244], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN24@LogExpendi:
	lea	ecx, DWORD PTR _strExpenditure$[esp+232]
	mov	DWORD PTR __$EHRec$[esp+244], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+236]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 220				; 000000dcH
	ret	36					; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$0:
	lea	ecx, DWORD PTR _strExpenditure$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$1:
	lea	ecx, DWORD PTR _strHeader$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$2:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$3:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$4:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$5:
	lea	ecx, DWORD PTR $T219828[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$6:
	lea	ecx, DWORD PTR $T219829[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$7:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$8:
	mov	ecx, DWORD PTR $T219830[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$17:
	mov	ecx, DWORD PTR $T219839[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$20:
	mov	ecx, DWORD PTR $T219842[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$29:
	mov	ecx, DWORD PTR $T219851[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$32:
	mov	ecx, DWORD PTR $T219854[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$41:
	mov	ecx, DWORD PTR $T219863[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$44:
	mov	ecx, DWORD PTR $T219866[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$53:
	mov	ecx, DWORD PTR $T219875[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$56:
	mov	ecx, DWORD PTR $T219878[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$14:
	mov	ecx, DWORD PTR $T219836[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$23:
	mov	ecx, DWORD PTR $T219845[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$26:
	mov	ecx, DWORD PTR $T219848[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$35:
	mov	ecx, DWORD PTR $T219857[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$38:
	mov	ecx, DWORD PTR $T219860[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$47:
	mov	ecx, DWORD PTR $T219869[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$50:
	mov	ecx, DWORD PTR $T219872[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z$59:
	mov	ecx, DWORD PTR $T219881[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogExpenditure@CvTreasury@@QAEXVCvString@@HH@Z ENDP	; CvTreasury::LogExpenditure
PUBLIC	??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
$LL16@Uninit_cop@2:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@2
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@2:
	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[esp], ecx
	cmp	ecx, edx
	jne	SHORT $LL16@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator<<<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T220629 = 12						; size = 4
_readFrom$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; operator<<<int>, COMDAT

; 198  : {

	push	ebx

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	ebx, DWORD PTR _saveTo$[esp]
	push	esi
	mov	esi, DWORD PTR _readFrom$[esp+4]
	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	push	edi
	lea	ecx, DWORD PTR $T220629[esp+8]
	sar	eax, 2
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR $T220629[esp+12], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	edi, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+4]
	cmp	esi, edi
	je	SHORT $LN36@operator@2
	npad	2
$LL22@operator@2:
	push	esi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	cmp	esi, edi
	jne	SHORT $LL22@operator@2
$LN36@operator@2:
	pop	edi
	pop	esi

; 200  : 	return saveTo;

	mov	eax, ebx
	pop	ebx

; 201  : }

	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@3
	pop	esi
$LN7@unchecked_@3:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?SetGold@CvTreasury@@QAEXH@Z			; CvTreasury::SetGold
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
;	COMDAT ?SetGold@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?SetGold@CvTreasury@@QAEXH@Z PROC			; CvTreasury::SetGold, COMDAT
; _this$ = ecx

; 161  : 	SetGoldTimes100(iNewValue * 100);

	mov	eax, DWORD PTR _iNewValue$[esp-4]
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iNewValue$[esp-4], eax
	jmp	?SetGoldTimes100@CvTreasury@@QAEXH@Z	; CvTreasury::SetGoldTimes100
?SetGold@CvTreasury@@QAEXH@Z ENDP			; CvTreasury::SetGold
_TEXT	ENDS
PUBLIC	?ChangeGold@CvTreasury@@QAEXH@Z			; CvTreasury::ChangeGold
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeGold@CvTreasury@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeGold@CvTreasury@@QAEXH@Z PROC			; CvTreasury::ChangeGold, COMDAT
; _this$ = ecx

; 167  : 	ChangeGoldTimes100(iChange*100);

	mov	eax, DWORD PTR _iChange$[esp-4]
	imul	eax, 100				; 00000064H
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _iChange$[esp-4], eax
	jmp	?SetGoldTimes100@CvTreasury@@QAEXH@Z	; CvTreasury::SetGoldTimes100
?ChangeGold@CvTreasury@@QAEXH@Z ENDP			; CvTreasury::ChangeGold
_TEXT	ENDS
PUBLIC	?CalculateGrossGold@CvTreasury@@QAEHXZ		; CvTreasury::CalculateGrossGold
; Function compile flags: /Ogtpy
;	COMDAT ?CalculateGrossGold@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
?CalculateGrossGold@CvTreasury@@QAEHXZ PROC		; CvTreasury::CalculateGrossGold, COMDAT
; _this$ = ecx

; 490  : 	return CalculateGrossGoldTimes100() / 100;

	call	?CalculateGrossGoldTimes100@CvTreasury@@QAEHXZ ; CvTreasury::CalculateGrossGoldTimes100
	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 491  : }

	ret	0
?CalculateGrossGold@CvTreasury@@QAEHXZ ENDP		; CvTreasury::CalculateGrossGold
_TEXT	ENDS
PUBLIC	?CalculateBaseNetGoldTimes100@CvTreasury@@QAEHXZ ; CvTreasury::CalculateBaseNetGoldTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?CalculateBaseNetGoldTimes100@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
?CalculateBaseNetGoldTimes100@CvTreasury@@QAEHXZ PROC	; CvTreasury::CalculateBaseNetGoldTimes100, COMDAT
; _this$ = ecx

; 530  : {

	push	esi
	push	edi
	mov	esi, ecx

; 531  : 	int iNetGold = CalculateGrossGoldTimes100();

	call	?CalculateGrossGoldTimes100@CvTreasury@@QAEHXZ ; CvTreasury::CalculateGrossGoldTimes100

; 532  : 
; 533  : 	// Remove costs
; 534  : 	iNetGold -= CalculateInflatedCosts() * 100;

	mov	ecx, esi
	mov	edi, eax
	call	?CalculatePreInflatedCosts@CvTreasury@@QAEHXZ ; CvTreasury::CalculatePreInflatedCosts
	mov	ecx, eax
	imul	ecx, 100				; 00000064H
	mov	eax, edi
	pop	edi
	sub	eax, ecx
	pop	esi

; 535  : 
; 536  : 	return iNetGold;
; 537  : }

	ret	0
?CalculateBaseNetGoldTimes100@CvTreasury@@QAEHXZ ENDP	; CvTreasury::CalculateBaseNetGoldTimes100
_TEXT	ENDS
PUBLIC	?Write@CvTreasury@@QAEXAAVFDataStream@@@Z	; CvTreasury::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvTreasury@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvTreasury@@QAEXAAVFDataStream@@@Z PROC		; CvTreasury::Write, COMDAT
; _this$ = ecx

; 1072 : {

	push	ecx
	push	esi
	push	edi

; 1073 : 	// Current version number
; 1074 : 	uint uiVersion = 1;
; 1075 : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+16], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 1076 : 
; 1077 : 	kStream << m_iGold;

	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1078 : 	kStream << m_iGoldPerTurnFromDiplomacy;

	lea	edx, DWORD PTR [esi+12]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1079 : 	kStream << m_iExpensePerTurnUnitMaintenance;

	lea	eax, DWORD PTR [esi+16]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1080 : 	kStream << m_iExpensePerTurnUnitSupply;

	lea	ecx, DWORD PTR [esi+20]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1081 : 	kStream << m_iCityConnectionGoldTimes100;

	lea	edx, DWORD PTR [esi+24]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1082 : 	kStream << m_iCityConnectionTradeRouteGoldModifier;

	lea	eax, DWORD PTR [esi+28]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1083 : 	kStream << m_iCityConnectionTradeRouteGoldChange;

	lea	ecx, DWORD PTR [esi+32]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1084 : 	kStream << m_iBaseBuildingGoldMaintenance;

	lea	edx, DWORD PTR [esi+36]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1085 : 	kStream << m_iBaseImprovementGoldMaintenance;

	lea	eax, DWORD PTR [esi+40]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1086 : 	kStream << m_GoldBalanceForTurnTimes100;

	lea	ecx, DWORD PTR [esi+48]
	push	ecx
	push	edi
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator<<<int>

; 1087 : 	kStream << m_GoldChangeForTurnTimes100;

	lea	edx, DWORD PTR [esi+64]
	push	edx
	push	edi
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator<<<int>
	add	esp, 16					; 00000010H

; 1088 : 	kStream << m_iLifetimeGrossGoldIncome;

	add	esi, 44					; 0000002cH
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi
	pop	esi

; 1089 : }

	pop	ecx
	ret	4
?Write@CvTreasury@@QAEXAAVFDataStream@@@Z ENDP		; CvTreasury::Write
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z
_TEXT	SEGMENT
$T220893 = -4						; size = 1
__Cat$220897 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T220893[esp+4], 0
	mov	eax, DWORD PTR $T220893[esp+4]
	mov	ecx, DWORD PTR __Cat$220897[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil
	pop	esi
$LN9@Uninit_fil:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?CalculateBaseNetGold@CvTreasury@@QAEHXZ	; CvTreasury::CalculateBaseNetGold
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
;	COMDAT ?CalculateBaseNetGold@CvTreasury@@QAEHXZ
_TEXT	SEGMENT
?CalculateBaseNetGold@CvTreasury@@QAEHXZ PROC		; CvTreasury::CalculateBaseNetGold, COMDAT
; _this$ = ecx

; 524  : {

	push	esi
	push	edi
	mov	edi, ecx

; 525  : 	return CalculateBaseNetGoldTimes100() / 100;

	call	?CalculateGrossGoldTimes100@CvTreasury@@QAEHXZ ; CvTreasury::CalculateGrossGoldTimes100
	mov	ecx, edi
	mov	esi, eax
	call	?CalculatePreInflatedCosts@CvTreasury@@QAEHXZ ; CvTreasury::CalculatePreInflatedCosts
	imul	eax, 100				; 00000064H
	sub	esi, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	esi
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	pop	edi
	add	eax, edx
	pop	esi

; 526  : }

	ret	0
?CalculateBaseNetGold@CvTreasury@@QAEHXZ ENDP		; CvTreasury::CalculateBaseNetGold
_TEXT	ENDS
PUBLIC	??$_Uninit_move@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@U_Undefined_move_tag@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@U_Undefined_move_tag@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T221224 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$221229 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@U_Undefined_move_tag@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$221229[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T221224[esp+4], 0
	mov	eax, DWORD PTR $T221224[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@U_Undefined_move_tag@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@4
	pop	esi
$LN13@unchecked_@4:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	??_7CvTreasury@@6B@				; CvTreasury::`vftable'
PUBLIC	??0CvTreasury@@QAE@XZ				; CvTreasury::CvTreasury
PUBLIC	??_R4CvTreasury@@6B@				; CvTreasury::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvTreasury@@@8				; CvTreasury `RTTI Type Descriptor'
PUBLIC	??_R3CvTreasury@@8				; CvTreasury::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvTreasury@@8				; CvTreasury::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvTreasury@@8			; CvTreasury::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_ECvTreasury@@UAEPAXI@Z:PROC			; CvTreasury::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvTreasury@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@CvTreasury@@8 DD FLAT:??_R0?AVCvTreasury@@@8 ; CvTreasury::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvTreasury@@8
rdata$r	ENDS
;	COMDAT ??_R2CvTreasury@@8
rdata$r	SEGMENT
??_R2CvTreasury@@8 DD FLAT:??_R1A@?0A@EA@CvTreasury@@8	; CvTreasury::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvTreasury@@8
rdata$r	SEGMENT
??_R3CvTreasury@@8 DD 00H				; CvTreasury::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvTreasury@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvTreasury@@@8
_DATA	SEGMENT
??_R0?AVCvTreasury@@@8 DD FLAT:??_7type_info@@6B@	; CvTreasury `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvTreasury@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvTreasury@@6B@
rdata$r	SEGMENT
??_R4CvTreasury@@6B@ DD 00H				; CvTreasury::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvTreasury@@@8
	DD	FLAT:??_R3CvTreasury@@8
rdata$r	ENDS
;	COMDAT ??_7CvTreasury@@6B@
CONST	SEGMENT
??_7CvTreasury@@6B@ DD FLAT:??_R4CvTreasury@@6B@	; CvTreasury::`vftable'
	DD	FLAT:??_ECvTreasury@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvTreasury@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTreasury@@QAE@XZ$0
__ehfuncinfo$??0CvTreasury@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvTreasury@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
xdata$x	ENDS
;	COMDAT ??0CvTreasury@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvTreasury@@QAE@XZ PROC				; CvTreasury::CvTreasury, COMDAT
; _this$ = ecx

; 36   : {

	push	-1
	push	__ehhandler$??0CvTreasury@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7CvTreasury@@6B@
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+44], ecx
	mov	DWORD PTR [eax+52], ecx
	mov	DWORD PTR [eax+56], ecx
	mov	DWORD PTR [eax+60], ecx
	mov	DWORD PTR [eax+68], ecx
	mov	DWORD PTR [eax+72], ecx
	mov	DWORD PTR [eax+76], ecx

; 37   : 
; 38   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTreasury@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$??0CvTreasury@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvTreasury@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTreasury@@QAE@XZ ENDP				; CvTreasury::CvTreasury
PUBLIC	??1CvTreasury@@UAE@XZ				; CvTreasury::~CvTreasury
; Function compile flags: /Ogtpy
;	COMDAT ??1CvTreasury@@UAE@XZ
_TEXT	SEGMENT
??1CvTreasury@@UAE@XZ PROC				; CvTreasury::~CvTreasury, COMDAT
; _this$ = ecx

; 42   : {

	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR [esi], OFFSET ??_7CvTreasury@@6B@

; 43   : }

	mov	eax, DWORD PTR [esi+68]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN10@CvTreasury
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@CvTreasury:
	mov	DWORD PTR [esi+68], edi
	mov	DWORD PTR [esi+72], edi
	mov	DWORD PTR [esi+76], edi
	mov	eax, DWORD PTR [esi+52]
	cmp	eax, edi
	je	SHORT $LN17@CvTreasury
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@CvTreasury:
	mov	DWORD PTR [esi+52], edi
	mov	DWORD PTR [esi+56], edi
	mov	DWORD PTR [esi+60], edi
	pop	edi
	pop	esi
	ret	0
??1CvTreasury@@UAE@XZ ENDP				; CvTreasury::~CvTreasury
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z
_TEXT	SEGMENT
$T221923 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$221926 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$221926[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T221923[esp+4], 0
	mov	eax, DWORD PTR $T221923[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@stdext@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@std@@0PAHAAV?$allocator@H@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$214846 = 16					; size = 4
__Tmp$214836 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$214836[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214836[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214836[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$214846[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvTreasury@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvTreasury@@UAEPAXI@Z PROC				; CvTreasury::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR [esi], OFFSET ??_7CvTreasury@@6B@
	mov	eax, DWORD PTR [esi+68]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN11@scalar@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@scalar@4:
	mov	DWORD PTR [esi+68], edi
	mov	DWORD PTR [esi+72], edi
	mov	DWORD PTR [esi+76], edi
	mov	eax, DWORD PTR [esi+52]
	cmp	eax, edi
	je	SHORT $LN18@scalar@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN18@scalar@4:
	test	BYTE PTR ___flags$[esp+4], 1
	mov	DWORD PTR [esi+52], edi
	mov	DWORD PTR [esi+56], edi
	mov	DWORD PTR [esi+60], edi
	je	SHORT $LN20@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@scalar@4:
	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??_GCvTreasury@@UAEPAXI@Z ENDP				; CvTreasury::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Umove@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_iterator@HV?$allocator@H@std@@@1@0PAH@Z ; std::vector<int,std::allocator<int> >::_Umove<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_iterator@HV?$allocator@H@std@@@1@0PAH@Z
_TEXT	SEGMENT
$T222221 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$222224 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_iterator@HV?$allocator@H@std@@@1@0PAH@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$222224[esp]
	mov	BYTE PTR $T222221[esp+4], 0
	mov	eax, DWORD PTR $T222221[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@?$vector@HV?$allocator@H@std@@@std@@IAEPAHV?$_Vector_iterator@HV?$allocator@H@std@@@1@0PAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$218076 = -24					; size = 4
$T222427 = -20						; size = 1
__$EHRec$ = -16						; size = 16
__Cat$222430 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::vector<int,std::allocator<int> >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH

; 603  : 		if (max_size() < _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	cmp	edx, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@reserve

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN57@reserve:
$LN5@reserve:

; 605  : 		else if (capacity() < _Count)

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LN20@reserve
	xor	eax, eax
	jmp	SHORT $LN21@reserve
$LN20@reserve:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN21@reserve:
	cmp	eax, edx
	jae	SHORT $LN3@reserve

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	push	0
	push	edx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 608  : 
; 609  : 			_TRY_BEGIN
; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR $T222427[ebp], 0
	mov	edx, DWORD PTR $T222427[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$222430[ebp]
	push	edx
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+8]
	push	esi
	push	ebx
	push	eax
	push	ecx
	mov	DWORD PTR __Ptr$218076[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<int,std::allocator<int> >,int *,std::allocator<int> >

; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi+8]
	sub	edi, eax
	add	esp, 32					; 00000020H
	sar	edi, 2

; 617  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN52@reserve

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);
; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN52@reserve:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [ebx+eax*4]

; 628  : 			_Mylast = _Ptr + _Size;

	lea	edx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+8], edx

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+4], ebx
$LN3@reserve:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Ptr$218076[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN58@reserve:
$LN56@reserve:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::reserve
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back
	xor	eax, eax
	jmp	SHORT $LN10@push_back
$LN9@push_back:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?Init@CvTreasury@@QAEXPAVCvPlayer@@@Z		; CvTreasury::Init
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
;	COMDAT ?Init@CvTreasury@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
tv384 = 8						; size = 4
_pPlayer$ = 8						; size = 4
?Init@CvTreasury@@QAEXPAVCvPlayer@@@Z PROC		; CvTreasury::Init, COMDAT
; _this$ = ecx

; 48   : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _pPlayer$[esp-4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 49   : 
; 50   : 	m_iGold = 0;

	xor	edi, edi

; 51   : 	m_iGoldPerTurnFromDiplomacy = 0;
; 52   : 	m_iExpensePerTurnUnitMaintenance = 0;
; 53   : 	m_iExpensePerTurnUnitSupply = 0;
; 54   : 	m_iCityConnectionGoldTimes100 = 0;
; 55   : 	m_iCityConnectionTradeRouteGoldModifier = 0;
; 56   : 	m_iCityConnectionTradeRouteGoldChange = 0;
; 57   : 	m_iBaseBuildingGoldMaintenance = 0;
; 58   : 	m_iBaseImprovementGoldMaintenance = 0;
; 59   : 	m_iLifetimeGrossGoldIncome = 0;
; 60   : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 61   : 	m_iCurrentGoldChange = 0;
; 62   : 	m_iCurrentGrossGoldChange = 0;
; 63   : #endif
; 64   : 
; 65   : 	m_GoldBalanceForTurnTimes100.clear();

	lea	ebx, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+36], edi
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	mov	ecx, DWORD PTR [ebx+8]
	mov	edx, DWORD PTR [ebx+4]
	cmp	edx, ecx
	je	SHORT $LN17@Init
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	ebp, DWORD PTR [eax*4]
	mov	DWORD PTR tv384[esp+12], ebp
	add	ebp, edx
	cmp	eax, edi
	jle	SHORT $LN87@Init
	mov	eax, DWORD PTR tv384[esp+12]
	push	eax
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN87@Init:
	mov	DWORD PTR [ebx+8], ebp
$LN17@Init:

; 66   : 	m_GoldBalanceForTurnTimes100.reserve(750);

	push	750					; 000002eeH
	mov	ecx, ebx
	call	?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve

; 67   : 	m_GoldChangeForTurnTimes100.clear();

	mov	ecx, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [esi+68]
	add	esi, 64					; 00000040H
	cmp	edx, ecx
	je	SHORT $LN59@Init
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	cmp	eax, edi
	lea	ebx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [ebx+edx]
	jle	SHORT $LN84@Init
	push	ebx
	push	ecx
	push	ebx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN84@Init:
	mov	DWORD PTR [esi+8], ebp
$LN59@Init:

; 68   : 	m_GoldChangeForTurnTimes100.reserve(750);

	push	750					; 000002eeH
	mov	ecx, esi
	call	?reserve@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::reserve
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 69   : }

	ret	4
?Init@CvTreasury@@QAEXPAVCvPlayer@@@Z ENDP		; CvTreasury::Init
_TEXT	ENDS
PUBLIC	?DoGold@CvTreasury@@QAEXXZ			; CvTreasury::DoGold
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	?DoDeficit@CvPlayer@@QAEXXZ:PROC		; CvPlayer::DoDeficit
EXTRN	?calculateGoldRateTimes100@CvPlayer@@QBEHXZ:PROC ; CvPlayer::calculateGoldRateTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?DoGold@CvTreasury@@QAEXXZ
_TEXT	SEGMENT
_iGoldChange$ = -8					; size = 4
$T223142 = -4						; size = 4
?DoGold@CvTreasury@@QAEXXZ PROC				; CvTreasury::DoGold, COMDAT
; _this$ = ecx

; 97   : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 98   : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 99   : 	int iGoldChange = getGoldT100ForThisTurn();
; 100  : #else
; 101  : 	int iGoldChange;
; 102  : 
; 103  : 	iGoldChange = m_pPlayer->calculateGoldRateTimes100();

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	call	?calculateGoldRateTimes100@CvPlayer@@QBEHXZ ; CvPlayer::calculateGoldRateTimes100

; 104  : #endif
; 105  : 
; 106  : 	int iGoldAfterThisTurn = iGoldChange + GetGoldTimes100();

	mov	ecx, DWORD PTR [esi+8]
	lea	edi, DWORD PTR [ecx+eax]
	mov	DWORD PTR _iGoldChange$[esp+16], eax

; 107  : 	if(iGoldAfterThisTurn < 0)
; 108  : 	{
; 109  : 		SetGold(0);

	mov	ecx, esi
	test	edi, edi
	jge	SHORT $LN8@DoGold
	push	0
	call	?SetGoldTimes100@CvTreasury@@QAEXH@Z	; CvTreasury::SetGoldTimes100

; 110  : 
; 111  : 		if(iGoldAfterThisTurn <= /*-5*/ GC.getDEFICIT_UNIT_DISBANDING_THRESHOLD() * 100)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6548
	imul	edx, 100				; 00000064H
	cmp	edi, edx
	jg	SHORT $LN17@DoGold

; 112  : 			m_pPlayer->DoDeficit();

	mov	ecx, DWORD PTR [esi+4]
	call	?DoDeficit@CvPlayer@@QAEXXZ		; CvPlayer::DoDeficit

; 113  : 	}
; 114  : 	else

	jmp	SHORT $LN17@DoGold
$LN8@DoGold:

; 115  : 	{
; 116  : 		ChangeGoldTimes100(iGoldChange);

	push	edi
	call	?SetGoldTimes100@CvTreasury@@QAEXH@Z	; CvTreasury::SetGoldTimes100
$LN17@DoGold:

; 117  : 	}
; 118  : 
; 119  : 	// Update the amount of gold grossed across lifetime of game
; 120  : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 121  : 	int iGrossGoldChange = getGrossGoldForThisTurn();
; 122  : #else
; 123  : 	int iGrossGoldChange = CalculateGrossGold();

	mov	ecx, esi
	call	?CalculateGrossGoldTimes100@CvTreasury@@QAEHXZ ; CvTreasury::CalculateGrossGoldTimes100
	mov	ecx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 124  : #endif
; 125  : 	if(iGrossGoldChange > 0)

	test	eax, eax
	jle	SHORT $LN5@DoGold

; 126  : 	{
; 127  : 		m_iLifetimeGrossGoldIncome += iGrossGoldChange;

	add	DWORD PTR [esi+44], eax
$LN5@DoGold:

; 128  : 	}
; 129  : 
; 130  : 	FAssertMsg(m_GoldBalanceForTurnTimes100.size() <= (unsigned int) GC.getGame().getGameTurn(), "History of Gold Balances corrupted");
; 131  : 	if(m_GoldBalanceForTurnTimes100.size() < (unsigned int) GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	ebx
	mov	ebx, DWORD PTR [esi+56]
	sub	ebx, DWORD PTR [esi+52]
	lea	edi, DWORD PTR [esi+48]
	sar	ebx, 2
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	ebx, eax
	jae	SHORT $LN84@DoGold

; 132  : 	{
; 133  : 		m_GoldBalanceForTurnTimes100.push_back(GetGoldTimes100());

	mov	edx, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [esi+8]
	mov	DWORD PTR $T223142[esp+20], ebx
	test	edx, edx
	jne	SHORT $LN37@DoGold
	xor	eax, eax
	jmp	SHORT $LN38@DoGold
$LN37@DoGold:
	mov	eax, DWORD PTR [edi+12]
	sub	eax, edx
	sar	eax, 2
$LN38@DoGold:
	mov	ecx, DWORD PTR [edi+8]
	push	ebp
	mov	ebp, ecx
	sub	ebp, edx
	sar	ebp, 2
	cmp	ebp, eax
	pop	ebp
	jae	SHORT $LN30@DoGold
	mov	DWORD PTR [ecx], ebx
	add	ecx, 4
	mov	DWORD PTR [edi+8], ecx
	jmp	SHORT $LN84@DoGold
$LN30@DoGold:
	lea	eax, DWORD PTR $T223142[esp+20]
	push	eax
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
$LN84@DoGold:

; 134  : 	}
; 135  : 
; 136  : 	FAssertMsg(m_GoldChangeForTurnTimes100.size() <= (unsigned int) GC.getGame().getGameTurn(), "History of Gold Changes corrupted");
; 137  : 	if(m_GoldChangeForTurnTimes100.size() < (unsigned int) GC.getGame().getGameTurn())

	mov	ebx, DWORD PTR [esi+72]
	sub	ebx, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	lea	edi, DWORD PTR [esi+64]
	sar	ebx, 2
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	ebx, eax
	jae	SHORT $LN163@DoGold

; 138  : 	{
; 139  : 		m_GoldChangeForTurnTimes100.push_back(iGoldChange);

	mov	edx, DWORD PTR [edi+4]
	test	edx, edx
	jne	SHORT $LN102@DoGold
	xor	eax, eax
	jmp	SHORT $LN103@DoGold
$LN102@DoGold:
	mov	eax, DWORD PTR [edi+12]
	sub	eax, edx
	sar	eax, 2
$LN103@DoGold:
	mov	ecx, DWORD PTR [edi+8]
	mov	ebx, ecx
	sub	ebx, edx
	sar	ebx, 2
	cmp	ebx, eax
	jae	SHORT $LN95@DoGold
	mov	edx, DWORD PTR _iGoldChange$[esp+20]
	mov	DWORD PTR [ecx], edx
	add	ecx, 4
	mov	DWORD PTR [edi+8], ecx
	jmp	SHORT $LN163@DoGold
$LN95@DoGold:
	lea	eax, DWORD PTR _iGoldChange$[esp+20]
	push	eax
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
$LN163@DoGold:

; 140  : 	}
; 141  : 
; 142  : 	if (m_pPlayer->isHuman() && !GC.getGame().isGameMultiPlayer())

	mov	ecx, DWORD PTR [esi+4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	pop	ebx
	test	al, al
	je	SHORT $LN1@DoGold
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	SHORT $LN1@DoGold

; 143  : 	{
; 144  : 		int iGoldDelta = (GetGoldFromCitiesTimes100(false) - GetGoldFromCitiesTimes100(true)) / 100;

	push	1
	mov	ecx, esi
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100
	push	0
	mov	ecx, esi
	mov	edi, eax
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100
	mov	ecx, eax
	sub	ecx, edi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 145  : 		if (iGoldDelta >= 200)

	cmp	ecx, 200				; 000000c8H
	jl	SHORT $LN1@DoGold

; 146  : 		{
; 147  : 			gDLL->UnlockAchievement(ACHIEVEMENT_XP2_32);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	274					; 00000112H
	call	eax
$LN1@DoGold:
	pop	edi
	pop	esi

; 148  : 		}
; 149  : 	}
; 150  : }

	add	esp, 8
	ret	0
?DoGold@CvTreasury@@QAEXXZ ENDP				; CvTreasury::DoGold
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_v$213776 = -4						; size = 4
_loadFrom$ = 8						; size = 4
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >, COMDAT

; 83   : {

	push	ecx
	push	ebx
	push	esi

; 84   : 	container.clear();

	mov	esi, DWORD PTR _container$[esp+8]
	mov	ecx, DWORD PTR [esi+8]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	cmp	edi, ecx
	je	SHORT $LN20@SerializeT
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebx, DWORD PTR [edx+edi]
	test	eax, eax
	jle	SHORT $LN45@SerializeT
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN45@SerializeT:
	mov	DWORD PTR [esi+8], ebx
$LN20@SerializeT:

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	edi, DWORD PTR _loadFrom$[esp+12]
	lea	eax, DWORD PTR _count$[esp+12]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _count$[esp+16], 0
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	xor	ebx, ebx
	cmp	DWORD PTR _count$[esp+12], ebx
	jbe	SHORT $LN1@SerializeT
	push	ebp
$LL117@SerializeT:

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	ecx, DWORD PTR _v$213776[esp+20]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 92   : 		container.push_back(v);

	mov	edx, DWORD PTR [esi+4]
	test	edx, edx
	jne	SHORT $LN60@SerializeT
	xor	eax, eax
	jmp	SHORT $LN61@SerializeT
$LN60@SerializeT:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
$LN61@SerializeT:
	mov	ecx, DWORD PTR [esi+8]
	mov	ebp, ecx
	sub	ebp, edx
	sar	ebp, 2
	cmp	ebp, eax
	jae	SHORT $LN53@SerializeT
	mov	edx, DWORD PTR _v$213776[esp+20]
	mov	DWORD PTR [ecx], edx
	add	ecx, 4
	mov	DWORD PTR [esi+8], ecx
	jmp	SHORT $LN2@SerializeT
$LN53@SerializeT:
	lea	eax, DWORD PTR _v$213776[esp+20]
	push	eax
	push	1
	push	ecx
	mov	ecx, esi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
$LN2@SerializeT:
	inc	ebx
	cmp	ebx, DWORD PTR _count$[esp+16]
	jb	SHORT $LL117@SerializeT
	pop	ebp
$LN1@SerializeT:
	pop	edi
	pop	esi
	pop	ebx

; 93   : 	}
; 94   : }

	pop	ecx
	ret	0
??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator>><int>
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; operator>><int>, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; operator>><int>
_TEXT	ENDS
PUBLIC	?Read@CvTreasury@@QAEXAAVFDataStream@@@Z	; CvTreasury::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvtreasury.cpp
;	COMDAT ?Read@CvTreasury@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvTreasury@@QAEXAAVFDataStream@@@Z PROC		; CvTreasury::Read, COMDAT
; _this$ = ecx

; 1050 : {

	push	esi
	push	edi

; 1051 : 	// Version number to maintain backwards compatibility
; 1052 : 	uint uiVersion;
; 1053 : 
; 1054 : 	kStream >> uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+4]
	lea	eax, DWORD PTR _uiVersion$[esp+4]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 1055 : 
; 1056 : 	kStream >> m_iGold;

	lea	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1057 : 	kStream >> m_iGoldPerTurnFromDiplomacy;

	lea	edx, DWORD PTR [esi+12]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1058 : 	kStream >> m_iExpensePerTurnUnitMaintenance;

	lea	eax, DWORD PTR [esi+16]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1059 : 	kStream >> m_iExpensePerTurnUnitSupply;

	lea	ecx, DWORD PTR [esi+20]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1060 : 	kStream >> m_iCityConnectionGoldTimes100;

	lea	edx, DWORD PTR [esi+24]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1061 : 	kStream >> m_iCityConnectionTradeRouteGoldModifier;

	lea	eax, DWORD PTR [esi+28]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1062 : 	kStream >> m_iCityConnectionTradeRouteGoldChange;

	lea	ecx, DWORD PTR [esi+32]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1063 : 	kStream >> m_iBaseBuildingGoldMaintenance;

	lea	edx, DWORD PTR [esi+36]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1064 : 	kStream >> m_iBaseImprovementGoldMaintenance;

	lea	eax, DWORD PTR [esi+40]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1065 : 	kStream >> m_GoldBalanceForTurnTimes100;

	lea	ecx, DWORD PTR [esi+48]
	push	ecx
	push	edi
	call	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >

; 1066 : 	kStream >> m_GoldChangeForTurnTimes100;

	lea	edx, DWORD PTR [esi+64]
	push	edx
	push	edi
	call	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
	add	esp, 16					; 00000010H

; 1067 : 	kStream >> m_iLifetimeGrossGoldIncome;

	add	esi, 44					; 0000002cH
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi
	pop	esi

; 1068 : }

	ret	4
?Read@CvTreasury@@QAEXAAVFDataStream@@@Z ENDP		; CvTreasury::Read
_TEXT	ENDS
END
