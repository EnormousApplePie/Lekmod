; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvCityManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::size
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 32					; 00000020H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Isnil
; Function compile flags: /Ogtpy
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 33					; 00000021H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Left
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Parent
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Right
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAAAU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Myval
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 129  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@

; 130  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 134  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lmost
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Max
; Function compile flags: /Ogtpy
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN1@Max
	npad	3
$LL2@Max:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LL2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Min
; Function compile flags: /Ogtpy
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Min, COMDAT

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN1@Min
	npad	4
$LL2@Min:

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LL2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);
; 1316 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Min
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Root
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+33], 0
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@SAABQAVCvCity@@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ; std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@SAABQAVCvCity@@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@SAABQAVCvCity@@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z PROC ; std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>::_Kfn, COMDAT

; 65   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[esp-4]

; 66   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@SAABQAVCvCity@@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ENDP ; std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>::_Kfn
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >::~_Container_base_aux_alloc_empty<std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >
_TEXT	ENDS
PUBLIC	??R?$less@PAVCvCity@@@std@@QBE_NABQAVCvCity@@0@Z ; std::less<CvCity *>::operator()
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
;	COMDAT ??R?$less@PAVCvCity@@@std@@QBE_NABQAVCvCity@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@PAVCvCity@@@std@@QBE_NABQAVCvCity@@0@Z PROC	; std::less<CvCity *>::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [edx]
	sbb	eax, eax
	neg	eax

; 144  : 		}

	ret	8
??R?$less@PAVCvCity@@@std@@QBE_NABQAVCvCity@@0@Z ENDP	; std::less<CvCity *>::operator()
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvCity@@@std@@QAE@XZ		; std::allocator<CvCity *>::allocator<CvCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$allocator@PAVCvCity@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvCity@@@std@@QAE@XZ PROC		; std::allocator<CvCity *>::allocator<CvCity *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvCity@@@std@@QAE@XZ ENDP		; std::allocator<CvCity *>::allocator<CvCity *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z ; std::allocator<CvCity *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z PROC ; std::allocator<CvCity *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z ENDP ; std::allocator<CvCity *>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::capacity
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T220893 = -80						; size = 28
$T220892 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T220893[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T220892[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T220893[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T220892[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T220892[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T220892[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T220892[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T220893[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T220892[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEABQAVCvCity@@XZ ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEABQAVCvCity@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEABQAVCvCity@@XZ PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEABQAVCvCity@@XZ ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator++
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator-
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator==
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator,bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z	; std::allocator<CvCity *>::allocator<CvCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvCity *>::allocator<CvCity *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvCity *>::allocator<CvCity *>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ	; std::allocator<CvCity *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ PROC	; std::allocator<CvCity *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ ENDP	; std::allocator<CvCity *>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN3@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+33], 0
	jne	SHORT $LN34@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN17@Inc
	npad	7
$LL18@Inc:
	mov	edx, eax
	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL18@Inc
$LN17@Inc:
	mov	DWORD PTR [ecx], edx

; 405  : 				}
; 406  : 			}

	ret	0
$LN34@Inc:

; 398  : 			else
; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN1@Inc
$LL2@Inc:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [ecx], eax
$LN3@Inc:

; 405  : 				}
; 406  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 214748364				; 0cccccccH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >::max_size
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+33], 0
	jne	SHORT $LN43@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN24@Dec
	npad	1
$LL25@Dec:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL25@Dec
$LN24@Dec:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN3@Dec
$LL4@Dec:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+33], 0
	jne	SHORT $LN1@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >::_Container_base_aux_alloc_empty<std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z
_TEXT	SEGMENT
$T221089 = -12						; size = 12
$T221093 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z PROC ; std::_Allocate<CvCity *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T221093[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T221089[esp+16]
	mov	DWORD PTR $T221093[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T221089[esp+16]
	push	ecx
	mov	DWORD PTR $T221089[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ENDP ; std::_Allocate<CvCity *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *><std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *><std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *><std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T221105 = -12						; size = 12
$T221109 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*8]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 36					; 00000024H
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T221109[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T221105[esp+16]
	mov	DWORD PTR $T221109[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T221105[esp+16]
	push	ecx
	mov	DWORD PTR $T221105[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node><std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node><std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node><std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z ; std::_Iter_random<CvCity * *,CvCity * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z PROC ; std::_Iter_random<CvCity * *,CvCity * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z ENDP ; std::_Iter_random<CvCity * *,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z ; std::_Ptr_cat<CvCity * *,CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z PROC ; std::_Ptr_cat<CvCity * *,CvCity * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z ENDP ; std::_Ptr_cat<CvCity * *,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvCity *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::_Fill<CvCity * *,CvCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z PROC ; std::_Fill<CvCity * *,CvCity *>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ENDP ; std::_Fill<CvCity * *,CvCity *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z ; std::_Move_cat<CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z PROC ; std::_Move_cat<CvCity * *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z ENDP ; std::_Move_cat<CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@AAPAPAVCvCity@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@AAPAPAVCvCity@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@AAPAPAVCvCity@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@AAPAPAVCvCity@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z ; std::_Iter_cat<CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z PROC ; std::_Iter_cat<CvCity * *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z ENDP ; std::_Iter_cat<CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Construct@PAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@ABQAV1@@Z ; std::_Construct<CvCity *,CvCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@PAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@ABQAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@ABQAV1@@Z PROC ; std::_Construct<CvCity *,CvCity *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@PAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@ABQAV1@@Z ENDP ; std::_Construct<CvCity *,CvCity *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAVCvCity@@@std@@YAXPAPAVCvCity@@@Z	; std::_Destroy<CvCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAVCvCity@@@std@@YAXPAPAVCvCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAVCvCity@@@std@@YAXPAPAVCvCity@@@Z PROC	; std::_Destroy<CvCity *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAVCvCity@@@std@@YAXPAPAVCvCity@@@Z ENDP	; std::_Destroy<CvCity *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@AAPAPAVCvCity@@@Z ; std::_Ptr_cat<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@AAPAPAVCvCity@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@AAPAPAVCvCity@@@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@AAPAPAVCvCity@@@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<CvCity * *,unsigned int,CvCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<CvCity * *,unsigned int,CvCity *>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<CvCity * *,unsigned int,CvCity *>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	dl, BYTE PTR [eax]
	push	ebx

; 21   : 
; 22   : 		_Left = _Right;

	mov	bl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], bl

; 23   : 		_Right = _Tmp;

	mov	BYTE PTR [ecx], dl
	pop	ebx
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEAAPAVCvCity@@XZ ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEAAPAVCvCity@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEAAPAVCvCity@@XZ PROC ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEAAPAVCvCity@@XZ ENDP ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator!=
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 265  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 317  : 			}

	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??1?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@QAE@XZ ; std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>::~_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>::~_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>::~_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAABQAVCvCity@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Key
; Function compile flags: /Ogtpy
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAABQAVCvCity@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAABQAVCvCity@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAABQAVCvCity@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Key
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+33], 0
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z ; std::allocator<CvCity *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z PROC ; std::allocator<CvCity *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z ENDP ; std::allocator<CvCity *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::max_size
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::_Vector_val<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z PROC ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::_Vector_val<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ENDP ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::_Vector_val<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_iterator<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z PROC ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_iterator<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ENDP ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_iterator<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 274  : 			_Inc();

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, esi
	pop	esi

; 276  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 214748364				; 0cccccccH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABQAVCvCity@@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lbound
; Function compile flags: /Ogtpy
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABQAVCvCity@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABQAVCvCity@@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax+4]

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+33], 0
	jne	SHORT $LN3@Lbound
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL4@Lbound:

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	cmp	DWORD PTR [ecx+12], edx
	jae	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	eax, ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LL4@Lbound
$LN3@Lbound:

; 1274 : 				}
; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate
; 1277 : 		}

	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABQAVCvCity@@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::end
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax

; 281  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Inc

; 282  : 			return (_Tmp);

	mov	eax, esi
	pop	esi

; 283  : 			}

	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@QAE@U?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ; std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@QAE@U?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@QAE@U?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	mov	eax, ecx

; 40   : 		}

	ret	8
??0?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@QAE@U?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::unchecked_copy<CvCity * *,CvCity * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvCity * *,CvCity * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvCity * *,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z ; std::_Destroy_range<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvCity *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::fill<CvCity * *,CvCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z PROC ; std::fill<CvCity * *,CvCity *>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ENDP ; std::fill<CvCity * *,CvCity *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@ABQAV3@@Z ; std::allocator<CvCity *>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@ABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@ABQAV3@@Z PROC ; std::allocator<CvCity *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@2:

; 156  : 		}

	ret	8
?construct@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@ABQAV3@@Z ENDP ; std::allocator<CvCity *>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@@Z ; std::allocator<CvCity *>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@@Z PROC ; std::allocator<CvCity *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@@Z ENDP ; std::allocator<CvCity *>::destroy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<CvCity * *,unsigned int,CvCity *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<CvCity * *,unsigned int,CvCity *,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@2
	pop	esi
$LN3@Fill_n@2:

; 3243 : 	}

	ret	0
??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<CvCity * *,unsigned int,CvCity *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
$LL16@Uninit_cop@2:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@2
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@2:
	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[esp], ecx
	cmp	ecx, edx
	jne	SHORT $LL16@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::end, COMDAT
; _this$ = ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 567  : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::end
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::end
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 12					; 0000000cH

; 466  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBEAAU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 474  : 			{	// preincrement

	push	esi
	mov	esi, ecx

; 475  : 			++(*(const_iterator *)this);

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Inc

; 476  : 			return (*this);

	mov	eax, esi
	pop	esi

; 477  : 			}

	ret	0
??Eiterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::~_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::~_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::~_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 577  : 		}

	ret	8
?_Make_iter@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Make_iter
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::lower_bound
; Function compile flags: /Ogtpy
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN32@lower_boun
	mov	edx, DWORD PTR __Keyval$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL6@lower_boun:
	cmp	DWORD PTR [eax+12], edx
	jae	SHORT $LN4@lower_boun
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN3@lower_boun
$LN4@lower_boun:
	mov	ecx, eax
	mov	eax, DWORD PTR [eax]
$LN3@lower_boun:
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL6@lower_boun
$LN32@lower_boun:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1005 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1385 : 		int _Linkcnt = 0;
; 1386 : 
; 1387 : 		_TRY_BEGIN
; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $LN27@Buynode
	mov	DWORD PTR [eax], 0
$LN27@Buynode:

; 1389 : 		++_Linkcnt;
; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode
	mov	DWORD PTR [ecx], 0
$LN37@Buynode:

; 1391 : 		++_Linkcnt;
; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode
	mov	DWORD PTR [ecx], 0
$LN47@Buynode:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1399 : 		_RERAISE;
; 1400 : 		_CATCH_END
; 1401 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+32], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+33], 0

; 1403 : 		return (_Wherenode);
; 1404 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	mov	eax, ecx

; 53   : 		}

	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@3
	push	esi
$LL14@Uninit_cop@3:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@3
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
$LN5@Uninit_cop@3:
	add	ecx, 4
	add	eax, 4
	mov	DWORD PTR __First$[esp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@3
	pop	esi
$LN4@Uninit_cop@3:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvCity * *,CvCity * *,std::allocator<CvCity *>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvCity * *,CvCity * *,std::allocator<CvCity *>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvCity * *,CvCity * *,std::allocator<CvCity *>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z PROC ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@3
	pop	esi
$LN7@unchecked_@3:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ENDP ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z
_TEXT	SEGMENT
$T222558 = -4						; size = 1
__Cat$222562 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T222558[esp+4], 0
	mov	eax, DWORD PTR $T222558[esp+4]
	mov	ecx, DWORD PTR __Cat$222562[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::find
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z
_TEXT	SEGMENT
$T222570 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::find, COMDAT
; _this$ = ecx

; 977  : 		{	// find an element in mutable sequence that matches _Keyval

	push	ecx

; 978  : 		iterator _Where = lower_bound(_Keyval);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+33], 0
	push	edi
	mov	edi, DWORD PTR __Keyval$[esp+4]
	jne	SHORT $LN9@find
	push	esi
	mov	esi, DWORD PTR [edi]
$LL10@find:
	cmp	DWORD PTR [eax+12], esi
	jae	SHORT $LN8@find
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN7@find
$LN8@find:
	mov	edx, eax
	mov	eax, DWORD PTR [eax]
$LN7@find:
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL10@find
	pop	esi
$LN9@find:

; 979  : 		return (_Where == end()
; 980  : 			|| _DEBUG_LT_PRED(this->comp,
; 981  : 				_Keyval, _Key(_Where._Mynode()))
; 982  : 					? end() : _Where);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Where$[esp+4], edx
	cmp	edx, eax
	je	SHORT $LN3@find
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [edx+12]
	jb	SHORT $LN3@find
	lea	eax, DWORD PTR __Where$[esp+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 983  : 		}

	pop	ecx
	ret	8
$LN3@find:

; 979  : 		return (_Where == end()
; 980  : 			|| _DEBUG_LT_PRED(this->comp,
; 981  : 				_Keyval, _Key(_Where._Mynode()))
; 982  : 					? end() : _Where);

	mov	DWORD PTR $T222570[esp+8], eax
	lea	eax, DWORD PTR $T222570[esp+8]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	edi

; 983  : 		}

	pop	ecx
	ret	8
?find@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::find
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::erase, COMDAT
; _this$ = ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	edx, DWORD PTR __Where$[esp-4]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [edx+4]
	sub	eax, ecx
	sar	eax, 2
	test	eax, eax
	jle	SHORT $LN9@erase
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove_s
	mov	edx, DWORD PTR __Where$[esp+16]
	add	esp, 16					; 00000010H
$LN9@erase:

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);
; 1021 : 		--_Mylast;
; 1022 : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	add	DWORD PTR [esi+8], -4			; fffffffcH
	mov	DWORD PTR [eax], edx
	pop	esi

; 1023 : 		}

	ret	8
?erase@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::erase
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::~_Tree_ptr<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_ptr@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::~_Tree_ptr<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_ptr@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::~_Tree_ptr<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Init
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	esi
	mov	esi, ecx

; 1178 : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+33], 1

; 1180 : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 1182 : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0
	pop	esi

; 1183 : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Init
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree_ptr<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree_ptr<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 79   : 		}

	ret	8
??0?$_Tree_ptr@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree_ptr<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z
_TEXT	SEGMENT
$T222891 = -4						; size = 1
__Cat$222896 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T222891[esp+4], 0
	mov	eax, DWORD PTR $T222891[esp+4]
	mov	ecx, DWORD PTR __Cat$222896[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvCity * *,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil
	pop	esi
$LN9@Uninit_fil:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T223015 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$223018 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$223018[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T223015[esp+4], 0
	mov	eax, DWORD PTR $T223015[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@U_Undefined_move_tag@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ ; std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >::~pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ PROC ; std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >::~pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN9@pair
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@pair:
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	pop	esi
	ret	0
??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ ENDP ; std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >::~pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >
_TEXT	ENDS
PUBLIC	?GetNearbyCities@CvCityManager@@SAABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAVCvCity@@@Z ; CvCityManager::GetNearbyCities
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcitymanager.cpp
;	COMDAT ?GetNearbyCities@CvCityManager@@SAABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAVCvCity@@@Z
_TEXT	SEGMENT
$T223050 = -4						; size = 4
_pkCity$ = 8						; size = 4
?GetNearbyCities@CvCityManager@@SAABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAVCvCity@@@Z PROC ; CvCityManager::GetNearbyCities, COMDAT

; 126  : {

	push	ecx

; 127  : 	CvAssert(pkCity);
; 128  : 	if (pkCity)

	cmp	DWORD PTR _pkCity$[esp], 0
	je	SHORT $LN1@GetNearbyC

; 129  : 	{
; 130  : 		CityMap::const_iterator itr = ms_kCityMap.find(pkCity);

	lea	eax, DWORD PTR _pkCity$[esp]
	push	eax
	lea	ecx, DWORD PTR $T223050[esp+8]
	push	ecx
	mov	ecx, OFFSET _ms_kCityMap
	call	?find@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::find
	mov	eax, DWORD PTR [eax]

; 131  : 
; 132  : 		CvAssert(itr != ms_kCityMap.end());
; 133  : 		if (itr != ms_kCityMap.end())

	cmp	eax, DWORD PTR _ms_kCityMap+4
	je	SHORT $LN1@GetNearbyC

; 134  : 		{
; 135  : 			return (*itr).second;

	add	eax, 16					; 00000010H

; 141  : }

	pop	ecx
	ret	0
$LN1@GetNearbyC:

; 136  : 		}
; 137  : 	}
; 138  : 
; 139  : 	// This should not happen, but I wont' assume.
; 140  : 	return ms_kEmptyList;

	mov	eax, OFFSET _ms_kEmptyList

; 141  : }

	pop	ecx
	ret	0
?GetNearbyCities@CvCityManager@@SAABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAVCvCity@@@Z ENDP ; CvCityManager::GetNearbyCities
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::~_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::~_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::~_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 98   : 		}

	ret	8
??0?$_Tree_val@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE@ABU?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
_TEXT	ENDS
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@0PAPAV2@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ucopy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@0PAPAV2@@Z
_TEXT	SEGMENT
$T223183 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$223186 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@0PAPAV2@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ucopy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$223186[esp]
	mov	BYTE PTR $T223183[esp+4], 0
	mov	eax, DWORD PTR $T223183[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@0PAPAV2@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ucopy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> > >
_TEXT	ENDS
PUBLIC	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@4
	pop	esi
$LN13@unchecked_@4:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??1_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node::~_Node
; Function compile flags: /Ogtpy
;	COMDAT ??1_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node::~_Node, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN11@Node
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@Node:
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	pop	esi
	ret	0
??1_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node::~_Node
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z
_TEXT	SEGMENT
$T223408 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$223411 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$223411[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T223408[esp+4], 0
	mov	eax, DWORD PTR $T223408[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@stdext@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@0PAPAV1@AAV?$allocator@PAVCvCity@@@3@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	esi
	mov	esi, ecx

; 510  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 511  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T223696 = 8						; size = 1
__Cat$223700 = 8					; size = 1
__Right$ = 8						; size = 4
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx

; 501  : 		if (_Buy(_Right.size()))

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx+8]
	sub	edi, DWORD PTR [ebx+4]
	xor	eax, eax
	mov	esi, ecx
	sar	edi, 2
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	je	SHORT $LN7@vector@2
	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN22@vector@2
	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
$LN54@vector@2:
$LN22@vector@2:
	push	eax
	push	edi
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>

; 502  : 			_TRY_BEGIN
; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	BYTE PTR $T223696[ebp], 0
	mov	edx, DWORD PTR $T223696[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$223700[ebp]
	push	edx
	lea	ecx, DWORD PTR [eax+edi*4]
	push	esi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ebx+4]
	push	eax
	push	ecx
	push	ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi+8], eax
$LN7@vector@2:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN55@vector@2:
$LN53@vector@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
PUBLIC	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@ABU01@@Z ; std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@ABU01@@Z PROC ; std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR [esi], ecx
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
	mov	eax, esi
	pop	esi
	ret	4
??0?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@ABU01@@Z ENDP ; std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >
_TEXT	ENDS
PUBLIC	??$_Umove@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@0PAPAV2@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@0PAPAV2@@Z
_TEXT	SEGMENT
$T223871 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$223874 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@0PAPAV2@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> > >, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$223874[esp]
	mov	BYTE PTR $T223871[esp+4], 0
	mov	eax, DWORD PTR $T223871[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@0PAPAV2@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> > >
_TEXT	ENDS
PUBLIC	??_G_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEPAXI@Z ; std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_G_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEPAXI@Z PROC ; std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN13@scalar@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@5:
	test	BYTE PTR ___flags$[esp], 1
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	je	SHORT $LN15@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEPAXI@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::reserve
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$219087 = -24					; size = 4
$T224057 = -20						; size = 1
__$EHRec$ = -16						; size = 16
__Cat$224060 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH

; 603  : 		if (max_size() < _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	cmp	edx, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@reserve

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
$LN57@reserve:
$LN5@reserve:

; 605  : 		else if (capacity() < _Count)

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LN20@reserve
	xor	eax, eax
	jmp	SHORT $LN21@reserve
$LN20@reserve:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 2
$LN21@reserve:
	cmp	eax, edx
	jae	SHORT $LN3@reserve

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	push	0
	push	edx
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>

; 608  : 
; 609  : 			_TRY_BEGIN
; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR $T224057[ebp], 0
	mov	edx, DWORD PTR $T224057[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$224060[ebp]
	push	edx
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+8]
	push	esi
	push	ebx
	push	eax
	push	ecx
	mov	DWORD PTR __Ptr$219087[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >

; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [esi+8]
	sub	edi, eax
	add	esp, 32					; 00000020H
	sar	edi, 2

; 617  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN52@reserve

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);
; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN52@reserve:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [ebx+eax*4]

; 628  : 			_Mylast = _Ptr + _Size;

	lea	edx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+8], edx

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+4], ebx
$LN3@reserve:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Ptr$219087[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN58@reserve:
$LN56@reserve:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::reserve
PUBLIC	??0?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@ABQAVCvCity@@ABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@@Z ; std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@ABQAVCvCity@@ABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@ABQAVCvCity@@ABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@@Z PROC ; std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR __Val2$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	push	edx
	lea	ecx, DWORD PTR [esi+4]
	call	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >

; 51   : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@ABQAVCvCity@@ABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@1@@Z ENDP ; std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$219383 = 16					; size = 4
__Tmp$219373 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$219373[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$219373[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$219373[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::fill<CvCity * *,CvCity *>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$219383[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::fill<CvCity * *,CvCity *>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	eax, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Rarg$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR __Parg$[esp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Val$[esp]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], edx
	mov	ecx, DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR [esi+12], ecx
	push	eax
	lea	ecx, DWORD PTR [esi+16]
	call	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
	mov	dl, BYTE PTR __Carg$[esp]
	mov	BYTE PTR [esi+32], dl
	mov	BYTE PTR [esi+33], 0

; 39   : 			}

	mov	eax, esi
	pop	esi
	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	esi

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN15@Destroy
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@Destroy:
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	pop	esi

; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	esi

; 160  : 		_Destroy(_Ptr);

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN17@destroy
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@destroy:
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	pop	esi

; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z$5
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z
_TEXT	SEGMENT
$T224389 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR __Wherenode$[ebp], esi

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	DWORD PTR $T224389[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	test	esi, esi
	je	SHORT $LN4@Buynode@2
	mov	eax, DWORD PTR __Larg$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	edx, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], edx
	mov	ecx, DWORD PTR [eax]
	add	eax, 4
	mov	DWORD PTR [esi+12], ecx
	push	eax
	lea	ecx, DWORD PTR [esi+16]
	call	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [esi+32], dl
	mov	BYTE PTR [esi+33], 0
$LN4@Buynode@2:

; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN35@Buynode@2:
$LN34@Buynode@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224389[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T224457 = -80						; size = 28
$T224456 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+80]
	cmp	BYTE PTR [eax+33], 0
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$[esp+88], ebx
	je	SHORT $LN40@erase@2

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T224457[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T224456[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T224457[esp+88]
	push	eax
	lea	ecx, DWORD PTR $T224456[esp+104]
	mov	BYTE PTR __$EHRec$[esp+100], 1
	mov	DWORD PTR $T224456[esp+92], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T224456[esp+92]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+104], 0
	mov	DWORD PTR $T224456[esp+96], OFFSET ??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$LN311@erase@2:
$LN40@erase@2:
	push	ebp
	push	esi
	push	edi

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[esp+96]
	mov	ebp, eax
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;
; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [ebp]
	cmp	BYTE PTR [ecx+33], 0
	je	SHORT $LN39@erase@2

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebp+8]
	jmp	SHORT $LN306@erase@2
$LN39@erase@2:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [ebp+8]
	cmp	BYTE PTR [edx+33], 0
	je	SHORT $LN37@erase@2

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, ecx

; 788  : 		else

	jmp	SHORT $LN306@erase@2
$LN37@erase@2:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	mov	eax, DWORD PTR __Where$[esp+96]

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edi, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [eax+8]

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	cmp	eax, ebp
	jne	SHORT $LN35@erase@2
$LN306@erase@2:

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);
; 797  : 			if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+33], 0
	mov	esi, DWORD PTR [ebp+4]
	jne	SHORT $LN34@erase@2

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN34@erase@2:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	eax, DWORD PTR [ebx+4]
	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN33@erase@2

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN30@erase@2
$LN33@erase@2:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	cmp	DWORD PTR [esi], ebp
	jne	SHORT $LN31@erase@2

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 804  : 			else

	jmp	SHORT $LN30@erase@2
$LN31@erase@2:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$LN30@erase@2:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ebx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ebx], ebp
	jne	SHORT $LN29@erase@2

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	cmp	BYTE PTR [edi+33], 0
	je	SHORT $LN43@erase@2
	mov	eax, esi
	jmp	SHORT $LN44@erase@2
$LN43@erase@2:
	push	edi
	call	?_Min@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Min
	add	esp, 4
$LN44@erase@2:
	mov	DWORD PTR [ebx], eax
$LN29@erase@2:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	eax, DWORD PTR _this$[esp+100]
	mov	ebx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ebx+8], ebp
	jne	SHORT $LN173@erase@2

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	cmp	BYTE PTR [edi+33], 0
	je	SHORT $LN45@erase@2
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase@2
$LN45@erase@2:

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	push	edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax

; 816  : 			}
; 817  : 		else

	jmp	SHORT $LN173@erase@2
$LN35@erase@2:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [ecx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	cmp	eax, DWORD PTR [ebp+8]
	jne	SHORT $LN26@erase@2

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, eax

; 824  : 			else

	jmp	SHORT $LN25@erase@2
$LN26@erase@2:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 827  : 				if (!_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+33], 0
	mov	esi, DWORD PTR [eax+4]
	jne	SHORT $LN24@erase@2

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN24@erase@2:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [edx], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR [edx+4], eax
$LN25@erase@2:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx+4], ebp
	jne	SHORT $LN23@erase@2

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN20@erase@2
$LN23@erase@2:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx], ebp
	jne	SHORT $LN21@erase@2

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [ecx], eax

; 838  : 			else

	jmp	SHORT $LN20@erase@2
$LN21@erase@2:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [ecx+8], eax
$LN20@erase@2:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	lea	ecx, DWORD PTR [ebp+32]
	add	eax, 32					; 00000020H
	cmp	eax, ecx
	je	SHORT $LN173@erase@2
	mov	bl, BYTE PTR [ecx]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax], bl
	mov	BYTE PTR [ecx], dl
$LN173@erase@2:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	bl, 1
	cmp	BYTE PTR [ebp+32], bl
	jne	$LN19@erase@2

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	ecx, DWORD PTR _this$[esp+100]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [edx+4]
	je	$LN16@erase@2
	npad	8
$LL18@erase@2:
	cmp	BYTE PTR [edi+32], bl
	jne	$LN16@erase@2

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR [esi]
	cmp	edi, eax
	jne	SHORT $LN15@erase@2

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]

; 852  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+32], 0
	jne	SHORT $LN14@erase@2

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+32], bl

; 855  : 						_Color(_Fixnodeparent) = _Red;
; 856  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [esi+32], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _this$[esp+100]
$LN14@erase@2:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+33], 0

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $LN309@erase@2

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+32], bl
	jne	SHORT $LN11@erase@2
	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+32], bl
	je	SHORT $LN310@erase@2
$LN11@erase@2:

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;
; 866  : 						_Fixnode = _Fixnodeparent;
; 867  : 						}
; 868  : 					else
; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+32], bl
	jne	SHORT $LN9@erase@2

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax]
	mov	BYTE PTR [edx+32], bl

; 873  : 							_Color(_Pnode) = _Red;
; 874  : 							_Rrotate(_Pnode);

	push	eax
	mov	BYTE PTR [eax+32], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _this$[esp+100]
$LN9@erase@2:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+32]
	mov	BYTE PTR [eax+32], dl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+32], bl

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR [eax+8]

; 881  : 						_Lrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [eax+32], bl
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@2
$LN15@erase@2:

; 883  : 						}
; 884  : 					}
; 885  : 				else
; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);
; 888  : 					if (_Color(_Pnode) == _Red)

	cmp	BYTE PTR [eax+32], 0
	jne	SHORT $LN7@erase@2

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [eax+32], bl

; 891  : 						_Color(_Fixnodeparent) = _Red;
; 892  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [esi+32], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _this$[esp+100]
$LN7@erase@2:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	cmp	BYTE PTR [eax+33], 0

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $LN309@erase@2

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax+8]
	cmp	BYTE PTR [edx+32], bl
	jne	SHORT $LN4@erase@2
	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+32], bl
	jne	SHORT $LN4@erase@2
$LN310@erase@2:

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [eax+32], 0
$LN309@erase@2:

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [ecx+4]

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	mov	esi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [eax+4]
	jne	$LL18@erase@2

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN16@erase@2
$LN4@erase@2:

; 902  : 						}
; 903  : 					else
; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+32], bl
	jne	SHORT $LN2@erase@2

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR [eax+8]
	mov	BYTE PTR [edx+32], bl

; 908  : 							_Color(_Pnode) = _Red;
; 909  : 							_Lrotate(_Pnode);

	push	eax
	mov	BYTE PTR [eax+32], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _this$[esp+100]
$LN2@erase@2:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	dl, BYTE PTR [esi+32]
	mov	BYTE PTR [eax+32], dl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+32], bl

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR [eax]

; 916  : 						_Rrotate(_Fixnodeparent);

	push	esi
	mov	BYTE PTR [eax+32], bl
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate
$LN16@erase@2:

; 917  : 						break;	// tree now recolored/rebalanced
; 918  : 						}
; 919  : 					}
; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+32], bl
$LN19@erase@2:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	mov	eax, DWORD PTR [ebp+20]
	xor	esi, esi
	cmp	eax, esi
	je	SHORT $LN294@erase@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN294@erase@2:

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	ebp
	mov	DWORD PTR [ebp+20], esi
	mov	DWORD PTR [ebp+24], esi
	mov	DWORD PTR [ebp+28], esi
	call	??3@YAXPAX@Z				; operator delete

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR _this$[esp+104]
	mov	eax, DWORD PTR [ecx+8]
	add	esp, 4
	pop	edi
	cmp	eax, esi
	pop	esi
	pop	ebp
	jbe	SHORT $LN1@erase@2

; 928  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ecx+8], eax
$LN1@erase@2:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[esp+84]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	DWORD PTR [eax], ecx

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 84					; 00000054H
	ret	8
$LN308@erase@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T224457[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$2:
	lea	ecx, DWORD PTR $T224456[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back
	xor	eax, eax
	jmp	SHORT $LN10@push_back
$LN9@push_back:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebx
	push	ebp
	push	esi

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	esi, DWORD PTR __Rootnode$[esp+8]
	xor	ebx, ebx
	push	edi
	mov	ebp, ecx
	mov	edi, esi
	cmp	BYTE PTR [esi+33], bl
	jne	SHORT $LN1@Erase
$LL3@Erase:

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [edi+8]
	push	eax
	mov	ecx, ebp
	call	?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);
; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	eax, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [edi]
	cmp	eax, ebx
	je	SHORT $LN28@Erase
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN28@Erase:

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	esi
	mov	DWORD PTR [esi+20], ebx
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+28], ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	esi, edi
	cmp	BYTE PTR [edi+33], bl
	je	SHORT $LL3@Erase
$LN1@Erase:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1173 : 			}
; 1174 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Erase
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T225327 = -80						; size = 28
$T225326 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 214748363		; 0ccccccbH
	jb	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T225327[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T225326[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T225327[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T225326[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T225326[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T225326[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T225326[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert:
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+32], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert
	npad	5
$LL10@Insert:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+32], 0
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+32], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+32], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+32], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lrotate
$LN5@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+32], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+32], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+32], 0
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+32], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+32], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+32], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+32], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+32], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+33], 0
	jne	SHORT $LN170@Insert
	mov	DWORD PTR [edx+4], eax
$LN170@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert
$LN169@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert
$LN167@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+32], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert
$LN9@Insert:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+32], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR $T225327[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z$2:
	lea	ecx, DWORD PTR $T225326[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Insert
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcitymanager.cpp
;	COMDAT ?AddToSortedList@@YAXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@HHPAVCvCity@@@Z
_TEXT	SEGMENT
tv514 = -8						; size = 4
_iAddDistance$218583 = -4				; size = 4
_iFromX$ = 8						; size = 4
_iFromY$ = 12						; size = 4
_pkAddCity$ = 16					; size = 4
?AddToSortedList@@YAXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@HHPAVCvCity@@@Z PROC ; AddToSortedList, COMDAT
; _kCityList$ = ebx

; 34   : 	if (kCityList.size() == 0)

	mov	ecx, DWORD PTR [ebx+8]
	sub	esp, 8
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	push	edi
	mov	edi, ecx
	sub	edi, ebp
	sar	edi, 2
	test	edi, edi
	jne	SHORT $LN7@AddToSorte

; 35   : 	{
; 36   : 		// First one
; 37   : 		kCityList.push_back(pkAddCity);

	test	ebp, ebp
	jne	SHORT $LN20@AddToSorte
	xor	eax, eax
	jmp	SHORT $LN21@AddToSorte
$LN20@AddToSorte:
	mov	eax, DWORD PTR [ebx+12]
	sub	eax, ebp
	sar	eax, 2
$LN21@AddToSorte:
	test	eax, eax
	jbe	SHORT $LN13@AddToSorte
	mov	eax, DWORD PTR _pkAddCity$[esp+12]
	mov	DWORD PTR [ecx], eax
	add	ecx, 4
	pop	edi
	mov	DWORD PTR [ebx+8], ecx
	pop	ebp

; 58   : 	}
; 59   : }

	add	esp, 8
	ret	0

; 35   : 	{
; 36   : 		// First one
; 37   : 		kCityList.push_back(pkAddCity);

$LN13@AddToSorte:
	lea	edx, DWORD PTR _pkAddCity$[esp+12]
	push	edx
	push	1
	push	ecx
	mov	ecx, ebx
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
	pop	edi
	pop	ebp

; 58   : 	}
; 59   : }

	add	esp, 8
	ret	0
$LN7@AddToSorte:

; 38   : 	}
; 39   : 	else
; 40   : 	{
; 41   : 		// Add to the pre-sorted list.
; 42   : 		int iAddDistance = plotDistance(iFromX, iFromY, pkAddCity->getX(), pkAddCity->getY());

	mov	eax, DWORD PTR _pkAddCity$[esp+12]
	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR [eax+96]
	mov	eax, DWORD PTR _iFromY$[esp+12]
	push	esi
	push	ecx
	mov	ecx, DWORD PTR _iFromX$[esp+20]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance

; 43   : 		bool bAdded = false;
; 44   : 		for (CvCityManager::CityList::iterator itrNearby = kCityList.begin(); itrNearby != kCityList.end(); ++itrNearby)

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, ebp
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iAddDistance$218583[esp+20], eax
	cmp	esi, ecx
	je	SHORT $LN207@AddToSorte
	npad	3
$LL89@AddToSorte:

; 45   : 		{
; 46   : 			CvCity* pkNearbyCity = (*itrNearby);

	mov	eax, DWORD PTR [esi]

; 47   : 			int iDistance = plotDistance(iFromX, iFromY, pkNearbyCity->getX(), pkNearbyCity->getY());

	mov	edx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	mov	ecx, DWORD PTR _iFromY$[esp+16]
	push	edx
	mov	edx, DWORD PTR _iFromX$[esp+20]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 48   : 			if (iAddDistance <= iDistance)

	cmp	DWORD PTR _iAddDistance$218583[esp+20], eax
	jle	SHORT $LN203@AddToSorte
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL89@AddToSorte
	mov	ecx, DWORD PTR [ebx+8]
$LN207@AddToSorte:

; 51   : 				bAdded = true;
; 52   : 				break;
; 53   : 			}
; 54   : 		}
; 55   : 
; 56   : 		if (!bAdded)
; 57   : 			kCityList.push_back(pkAddCity);

	test	ebp, ebp
	jne	SHORT $LN147@AddToSorte
	xor	eax, eax
	jmp	SHORT $LN148@AddToSorte
$LN203@AddToSorte:

; 49   : 			{
; 50   : 				kCityList.insert(itrNearby, pkAddCity);

	lea	eax, DWORD PTR _pkAddCity$[esp+16]
	push	eax
	push	1
	push	esi

; 51   : 				bAdded = true;
; 52   : 				break;
; 53   : 			}
; 54   : 		}
; 55   : 
; 56   : 		if (!bAdded)
; 57   : 			kCityList.push_back(pkAddCity);

	mov	ecx, ebx
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
	pop	esi
	pop	edi
	pop	ebp

; 58   : 	}
; 59   : }

	add	esp, 8
	ret	0

; 51   : 				bAdded = true;
; 52   : 				break;
; 53   : 			}
; 54   : 		}
; 55   : 
; 56   : 		if (!bAdded)
; 57   : 			kCityList.push_back(pkAddCity);

$LN147@AddToSorte:
	mov	eax, DWORD PTR [ebx+12]
	sub	eax, ebp
	sar	eax, 2
$LN148@AddToSorte:
	cmp	edi, eax
	jae	SHORT $LN140@AddToSorte
	mov	edx, DWORD PTR _pkAddCity$[esp+16]
	pop	esi
	mov	DWORD PTR [ecx], edx
	add	ecx, 4
	pop	edi
	mov	DWORD PTR [ebx+8], ecx
	pop	ebp

; 58   : 	}
; 59   : }

	add	esp, 8
	ret	0

; 51   : 				bAdded = true;
; 52   : 				break;
; 53   : 			}
; 54   : 		}
; 55   : 
; 56   : 		if (!bAdded)
; 57   : 			kCityList.push_back(pkAddCity);

$LN140@AddToSorte:
	lea	eax, DWORD PTR _pkAddCity$[esp+16]
	push	eax
	push	1
	push	ecx
	mov	ecx, ebx
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
	pop	esi
	pop	edi
	pop	ebp

; 58   : 	}
; 59   : }

	add	esp, 8
	ret	0
?AddToSortedList@@YAXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@HHPAVCvCity@@@Z ENDP ; AddToSortedList
_TEXT	ENDS
PUBLIC	?OnCityDestroyed@CvCityManager@@SAXPAVCvCity@@@Z ; CvCityManager::OnCityDestroyed
; Function compile flags: /Ogtpy
;	COMDAT ?OnCityDestroyed@CvCityManager@@SAXPAVCvCity@@@Z
_TEXT	SEGMENT
$T226573 = -4						; size = 4
_itr$ = -4						; size = 4
_pkCity$ = 8						; size = 4
?OnCityDestroyed@CvCityManager@@SAXPAVCvCity@@@Z PROC	; CvCityManager::OnCityDestroyed, COMDAT

; 98   : {

	push	ecx
	push	esi
	push	edi

; 99   : 	// Remove it from all the other city lists
; 100  : 	for (CityMap::iterator itr = ms_kCityMap.begin(); itr != ms_kCityMap.end(); ++itr)

	mov	edi, DWORD PTR _ms_kCityMap+4
	mov	esi, DWORD PTR [edi]
	cmp	esi, edi
	je	$LN7@OnCityDest
	push	ebx
	mov	ebx, DWORD PTR _pkCity$[esp+12]
	push	ebp
	mov	ebp, DWORD PTR __imp__memmove_s
	npad	1
$LL28@OnCityDest:

; 101  : 	{
; 102  : 		if ((*itr).first != pkCity)

	cmp	DWORD PTR [esi+12], ebx
	je	SHORT $LN8@OnCityDest

; 103  : 		{
; 104  : 			CityList &kCityList = (*itr).second;
; 105  : 			for (CityList::iterator itrNearby = kCityList.begin(); itrNearby != kCityList.end(); ++itrNearby)

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+24]
	cmp	eax, ecx
	je	SHORT $LN8@OnCityDest
	npad	1
$LL88@OnCityDest:

; 106  : 			{
; 107  : 				if ((*itrNearby) == pkCity)

	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN135@OnCityDest
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL88@OnCityDest
	jmp	SHORT $LN8@OnCityDest
$LN135@OnCityDest:

; 108  : 				{
; 109  : 					kCityList.erase(itrNearby);

	lea	edx, DWORD PTR [eax+4]
	sub	ecx, edx
	sar	ecx, 2
	test	ecx, ecx
	jle	SHORT $LN112@OnCityDest
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	ecx
	push	eax
	call	ebp
	add	esp, 16					; 00000010H
$LN112@OnCityDest:
	add	DWORD PTR [esi+24], -4			; fffffffcH
	mov	edi, DWORD PTR _ms_kCityMap+4
$LN8@OnCityDest:

; 99   : 	// Remove it from all the other city lists
; 100  : 	for (CityMap::iterator itr = ms_kCityMap.begin(); itr != ms_kCityMap.end(); ++itr)

	cmp	BYTE PTR [esi+33], 0
	jne	SHORT $LN139@OnCityDest
	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN134@OnCityDest
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN139@OnCityDest
	npad	7
$LL43@OnCityDest:
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL43@OnCityDest
	jmp	SHORT $LN139@OnCityDest
$LN134@OnCityDest:
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN26@OnCityDest
$LL27@OnCityDest:
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN26@OnCityDest
	mov	esi, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL27@OnCityDest
$LN26@OnCityDest:
	mov	esi, eax
$LN139@OnCityDest:
	cmp	esi, edi
	jne	$LL28@OnCityDest
	pop	ebp
	pop	ebx
$LN7@OnCityDest:

; 110  : 					break;
; 111  : 				}
; 112  : 			}
; 113  : 		}
; 114  : 	}
; 115  : 
; 116  : 	// Then remove its list
; 117  : 	CityMap::iterator itr = ms_kCityMap.find(pkCity);

	lea	eax, DWORD PTR _pkCity$[esp+8]
	push	eax
	lea	ecx, DWORD PTR _itr$[esp+16]
	push	ecx
	mov	ecx, OFFSET _ms_kCityMap
	call	?find@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::find

; 118  : 	if (itr != ms_kCityMap.end())

	mov	eax, DWORD PTR _itr$[esp+12]
	cmp	eax, edi
	pop	edi
	pop	esi
	je	SHORT $LN1@OnCityDest

; 119  : 	{
; 120  : 		ms_kCityMap.erase(itr);

	push	eax
	lea	edx, DWORD PTR $T226573[esp+8]
	push	edx
	mov	ecx, OFFSET _ms_kCityMap
	call	?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase
$LN1@OnCityDest:

; 121  : 	}
; 122  : }

	pop	ecx
	ret	0
?OnCityDestroyed@CvCityManager@@SAXPAVCvCity@@@Z ENDP	; CvCityManager::OnCityDestroyed
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T226988 = 12						; size = 4
$T226986 = 12						; size = 4
__Where$218992 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+33], 0
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+16], cl
	jne	SHORT $LN9@insert@2
	mov	edx, DWORD PTR [ebp]
	npad	1
$LL10@insert@2:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+12]
	mov	esi, eax
	setb	cl
	mov	BYTE PTR __Addleft$[esp+16], cl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	cl, cl
	je	SHORT $LN13@insert@2
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert@2
$LN13@insert@2:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert@2:

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL10@insert@2
$LN9@insert@2:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, esi
	mov	DWORD PTR __Where$218992[esp+12], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN57@insert@2

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	lea	ecx, DWORD PTR $T226986[esp+12]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN4@insert@2
	push	ebp
	push	esi
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN4@insert@2:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$218992[esp+12]
$LN57@insert@2:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR [ebp]
	jae	SHORT $LN2@insert@2

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Addleft$[esp+16]
	push	ebp
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T226988[esp+24]
	push	edx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN2@insert@2:

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::insert
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 974  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::clear
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
$T227156 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN101@erase@3
	cmp	edx, eax
	jne	SHORT $LN101@erase@3

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 938  : 			return (begin());

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], edx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN101@erase@3:

; 939  : 			}
; 940  : 		else
; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	cmp	ecx, edx
	je	SHORT $LN1@erase@3
	npad	2
$LL2@erase@3:

; 943  : 				erase(_First++);

	cmp	BYTE PTR [ecx+33], 0
	mov	edx, ecx
	jne	SHORT $LN65@erase@3
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN103@erase@3
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN79@erase@3
	npad	5
$LL80@erase@3:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL80@erase@3
$LN79@erase@3:
	mov	DWORD PTR __First$[esp+4], ecx
	jmp	SHORT $LN65@erase@3
$LN103@erase@3:
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN63@erase@3
	npad	7
$LL64@erase@3:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN63@erase@3
	mov	ecx, eax
	mov	DWORD PTR __First$[esp+4], ecx
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL64@erase@3
$LN63@erase@3:
	mov	DWORD PTR __First$[esp+4], eax
$LN65@erase@3:
	push	edx
	lea	eax, DWORD PTR $T227156[esp+12]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase
	mov	ecx, DWORD PTR __First$[esp+4]
	cmp	ecx, DWORD PTR __Last$[esp+4]
	jne	SHORT $LL2@erase@3
$LN1@erase@3:

; 944  : 			return (_Make_iter(_First));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 945  : 			}
; 946  : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase
_TEXT	ENDS
PUBLIC	?Reset@CvCityManager@@SAXXZ			; CvCityManager::Reset
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcitymanager.cpp
;	COMDAT ?Reset@CvCityManager@@SAXXZ
_TEXT	SEGMENT
?Reset@CvCityManager@@SAXXZ PROC			; CvCityManager::Reset, COMDAT

; 22   : 	ms_kCityMap.clear();

	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, OFFSET _ms_kCityMap
	call	?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Erase
	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR _ms_kCityMap+8, 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR [eax+8], eax

; 23   : }

	ret	0
?Reset@CvCityManager@@SAXXZ ENDP			; CvCityManager::Reset
_TEXT	ENDS
PUBLIC	?Shutdown@CvCityManager@@SAXXZ			; CvCityManager::Shutdown
; Function compile flags: /Ogtpy
;	COMDAT ?Shutdown@CvCityManager@@SAXXZ
_TEXT	SEGMENT
?Shutdown@CvCityManager@@SAXXZ PROC			; CvCityManager::Shutdown, COMDAT

; 28   : 	ms_kCityMap.clear();

	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, OFFSET _ms_kCityMap
	call	?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Erase
	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR _ms_kCityMap+8, 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR [eax+8], eax

; 29   : }

	ret	0
?Shutdown@CvCityManager@@SAXXZ ENDP			; CvCityManager::Shutdown
_TEXT	ENDS
PUBLIC	?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z	; CvCityManager::OnCityCreated
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z$0
__ehfuncinfo$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcitymanager.cpp
xdata$x	ENDS
;	COMDAT ?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z
_TEXT	SEGMENT
_kResult$ = -40						; size = 8
$T227586 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_pkAddCity$ = 8						; size = 4
?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z PROC	; CvCityManager::OnCityCreated, COMDAT

; 63   : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 64   : 	// First add it to all the other city lists
; 65   : 	for (CityMap::iterator itr = ms_kCityMap.begin(); itr != ms_kCityMap.end(); ++itr)

	mov	ecx, DWORD PTR _ms_kCityMap+4
	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR [ecx]
	push	edi
	cmp	esi, ecx
	je	SHORT $LN200@OnCityCrea
	npad	8
$LL28@OnCityCrea:

; 66   : 	{
; 67   : 		CvCity* pkCity = (*itr).first;

	mov	eax, DWORD PTR [esi+12]

; 68   : 		if ((*itr).first != pkAddCity)		// It should not be in there, but check anyhow

	mov	ebp, DWORD PTR _pkAddCity$[esp+52]
	cmp	eax, ebp
	je	SHORT $LN7@OnCityCrea

; 69   : 		{
; 70   : 			CityList &kCityList = (*itr).second;
; 71   : 
; 72   : 			AddToSortedList(kCityList, pkCity->getX(), pkCity->getY(), pkAddCity);

	mov	ecx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	push	ebp
	push	ecx
	lea	ebx, DWORD PTR [esi+16]
	push	eax
	call	?AddToSortedList@@YAXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@HHPAVCvCity@@@Z ; AddToSortedList
	mov	ecx, DWORD PTR _ms_kCityMap+4
	add	esp, 12					; 0000000cH
$LN7@OnCityCrea:

; 64   : 	// First add it to all the other city lists
; 65   : 	for (CityMap::iterator itr = ms_kCityMap.begin(); itr != ms_kCityMap.end(); ++itr)

	cmp	BYTE PTR [esi+33], 0
	jne	SHORT $LN196@OnCityCrea
	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN190@OnCityCrea
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN196@OnCityCrea
	npad	2
$LL43@OnCityCrea:
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL43@OnCityCrea
	jmp	SHORT $LN196@OnCityCrea
$LN190@OnCityCrea:
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN26@OnCityCrea
$LL27@OnCityCrea:
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN26@OnCityCrea
	mov	esi, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL27@OnCityCrea
$LN26@OnCityCrea:
	mov	esi, eax
$LN196@OnCityCrea:
	cmp	esi, ecx
	jne	SHORT $LL28@OnCityCrea
	jmp	SHORT $LN6@OnCityCrea
$LN200@OnCityCrea:
	mov	ebp, DWORD PTR _pkAddCity$[esp+52]
$LN6@OnCityCrea:

; 73   : 		}
; 74   : 	}
; 75   : 
; 76   : 	// Then make a list for it
; 77   : 	std::pair<CityMap::iterator, bool> kResult = ms_kCityMap.insert(CityMap::value_type(pkAddCity, ms_kEmptyList));

	push	OFFSET _ms_kEmptyList
	lea	ecx, DWORD PTR $T227586[esp+64]
	mov	DWORD PTR $T227586[esp+60], ebp
	call	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
	lea	eax, DWORD PTR $T227586[esp+56]
	push	eax
	lea	ecx, DWORD PTR _kResult$[esp+60]
	push	ecx
	mov	ecx, OFFSET _ms_kCityMap
	mov	DWORD PTR __$EHRec$[esp+72], 0
	call	?insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::insert
	mov	eax, DWORD PTR $T227586[esp+64]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	test	eax, eax
	je	SHORT $LN104@OnCityCrea
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN104@OnCityCrea:

; 78   : 
; 79   : 	CityList& kCityList = (*kResult.first).second;

	mov	ebx, DWORD PTR _kResult$[esp+56]
	add	ebx, 16					; 00000010H

; 80   : 	kCityList.reserve(256);		// Reserving an arbitrary number of cities.  Large games can probably have more than this, but this is a good middle ground.

	push	256					; 00000100H
	mov	ecx, ebx
	call	?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::reserve

; 81   : 
; 82   : 	// Instead of adding all the cities, then sorting the list, this will add them to their correctly sorted position one at a time.
; 83   : 	// This might be a tad slower, but city creation is not happening all the time and if we did the sort, the list would have to store the distance
; 84   : 	int iFromX = pkAddCity->getX();
; 85   : 	int iFromY = pkAddCity->getY();
; 86   : 	for (CityMap::iterator itr = ms_kCityMap.begin(); itr != ms_kCityMap.end(); ++itr)

	mov	ecx, DWORD PTR _ms_kCityMap+4
	mov	esi, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ebp+96]
	mov	ebp, DWORD PTR [ebp+108]
	cmp	esi, ecx
	je	SHORT $LN2@OnCityCrea
	npad	3
$LL136@OnCityCrea:

; 87   : 	{
; 88   : 		CvCity* pkCity = (*itr).first;
; 89   : 		if ((*itr).first != pkAddCity)

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR _pkAddCity$[esp+52]
	je	SHORT $LN3@OnCityCrea

; 90   : 		{
; 91   : 			AddToSortedList(kCityList, iFromX, iFromY, pkCity);

	push	eax
	push	ebp
	push	edi
	call	?AddToSortedList@@YAXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@HHPAVCvCity@@@Z ; AddToSortedList
	mov	ecx, DWORD PTR _ms_kCityMap+4
	add	esp, 12					; 0000000cH
$LN3@OnCityCrea:

; 81   : 
; 82   : 	// Instead of adding all the cities, then sorting the list, this will add them to their correctly sorted position one at a time.
; 83   : 	// This might be a tad slower, but city creation is not happening all the time and if we did the sort, the list would have to store the distance
; 84   : 	int iFromX = pkAddCity->getX();
; 85   : 	int iFromY = pkAddCity->getY();
; 86   : 	for (CityMap::iterator itr = ms_kCityMap.begin(); itr != ms_kCityMap.end(); ++itr)

	cmp	BYTE PTR [esi+33], 0
	jne	SHORT $LN199@OnCityCrea
	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN193@OnCityCrea
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN199@OnCityCrea
$LL151@OnCityCrea:
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL151@OnCityCrea
	jmp	SHORT $LN199@OnCityCrea
$LN193@OnCityCrea:
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN134@OnCityCrea
$LL135@OnCityCrea:
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN134@OnCityCrea
	mov	esi, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LL135@OnCityCrea
$LN134@OnCityCrea:
	mov	esi, eax
$LN199@OnCityCrea:
	cmp	esi, ecx
	jne	SHORT $LL136@OnCityCrea
$LN2@OnCityCrea:

; 92   : 		}
; 93   : 	}
; 94   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z$0:
	lea	ecx, DWORD PTR $T227586[ebp]
	jmp	??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z ENDP	; CvCityManager::OnCityCreated
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T228179 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T228179[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1427 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::~_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T228313 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::~_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 540  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T228313[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 541  : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::~_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
_TEXT	ENDS
PUBLIC	??1?$map@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@@std@@QAE@XZ ; std::map<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >::~map<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$map@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T228469 = -4						; size = 4
??1?$map@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@@std@@QAE@XZ PROC ; std::map<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >::~map<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T228469[esp+16]
	push	eax
	mov	ecx, esi
	call	?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	esi
	pop	ecx
	ret	0
??1?$map@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >::~map<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >
_TEXT	ENDS
PUBLIC	??0?$map@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@@std@@QAE@XZ ; std::map<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >::map<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$map@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@@std@@QAE@XZ PROC ; std::map<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >::map<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >, COMDAT
; _this$ = ecx

; 103  : 		{	// construct empty map from defaults

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 104  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$map@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >::map<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > > >
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcitymanager.cpp
;	COMDAT ??__Ems_kCityMap@@YAXXZ
text$yc	SEGMENT
??__Ems_kCityMap@@YAXXZ PROC				; `dynamic initializer for 'ms_kCityMap'', COMDAT

; 15   : static CityMap ms_kCityMap;

	mov	ecx, OFFSET _ms_kCityMap
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode
	mov	DWORD PTR _ms_kCityMap+4, eax
	mov	BYTE PTR [eax+33], 1
	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR [eax+8], eax
	push	OFFSET ??__Fms_kCityMap@@YAXXZ		; `dynamic atexit destructor for 'ms_kCityMap''
	mov	DWORD PTR _ms_kCityMap+8, 0
	call	_atexit
	pop	ecx
	ret	0
??__Ems_kCityMap@@YAXXZ ENDP				; `dynamic initializer for 'ms_kCityMap''
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT ??__Ems_kEmptyList@@YAXXZ
text$yc	SEGMENT
??__Ems_kEmptyList@@YAXXZ PROC				; `dynamic initializer for 'ms_kEmptyList'', COMDAT

; 17   : static CvCityManager::CityList ms_kEmptyList;

	push	OFFSET ??__Fms_kEmptyList@@YAXXZ	; `dynamic atexit destructor for 'ms_kEmptyList''
	call	_atexit
	pop	ecx
	ret	0
??__Ems_kEmptyList@@YAXXZ ENDP				; `dynamic initializer for 'ms_kEmptyList''
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT ??__Fms_kEmptyList@@YAXXZ
text$yd	SEGMENT
??__Fms_kEmptyList@@YAXXZ PROC				; `dynamic atexit destructor for 'ms_kEmptyList'', COMDAT
	mov	eax, DWORD PTR _ms_kEmptyList+4
	test	eax, eax
	je	SHORT $LN8@dynamic
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@dynamic:
	mov	DWORD PTR _ms_kEmptyList+4, 0
	mov	DWORD PTR _ms_kEmptyList+8, 0
	mov	DWORD PTR _ms_kEmptyList+12, 0
	ret	0
??__Fms_kEmptyList@@YAXXZ ENDP				; `dynamic atexit destructor for 'ms_kEmptyList''
; Function compile flags: /Ogtpy
text$yd	ENDS
;	COMDAT ??__Fms_kCityMap@@YAXXZ
text$yd	SEGMENT
$T229276 = -4						; size = 4
??__Fms_kCityMap@@YAXXZ PROC				; `dynamic atexit destructor for 'ms_kCityMap'', COMDAT
	push	ecx
	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T229276[esp+12]
	push	eax
	mov	ecx, OFFSET _ms_kCityMap
	call	?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase
	mov	ecx, DWORD PTR _ms_kCityMap+4
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	xor	eax, eax
	mov	DWORD PTR _ms_kCityMap+4, eax
	mov	DWORD PTR _ms_kCityMap+8, eax
	add	esp, 8
	ret	0
??__Fms_kCityMap@@YAXXZ ENDP				; `dynamic atexit destructor for 'ms_kCityMap''
text$yd	ENDS
_BSS	SEGMENT
_ms_kEmptyList DB 010H DUP (?)
_ms_kCityMap DB	0cH DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_ms_kCityMap$initializer$ DD FLAT:??__Ems_kCityMap@@YAXXZ
_ms_kEmptyList$initializer$ DD FLAT:??__Ems_kEmptyList@@YAXXZ
CRT$XCU	ENDS
END
