; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	s:\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvHomelandAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?m_CurrentBestHighPriorityMoveUnit@@3PAVCvUnit@@A ; m_CurrentBestHighPriorityMoveUnit
PUBLIC	?m_iCurrentBestHighPriorityMoveUnitTurns@@3HA	; m_iCurrentBestHighPriorityMoveUnitTurns
PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
_BSS	SEGMENT
?m_CurrentBestHighPriorityMoveUnit@@3PAVCvUnit@@A DD 01H DUP (?) ; m_CurrentBestHighPriorityMoveUnit
?m_iCurrentBestHighPriorityMoveUnitTurns@@3HA DD 01H DUP (?) ; m_iCurrentBestHighPriorityMoveUnitTurns
_BSS	ENDS
CONST	SEGMENT
$SG224977 DB	'FLAVOR_DEFENSE', 00H
	ORG $+1
$SG224983 DB	'FLAVOR_OFFENSE', 00H
	ORG $+1
$SG224990 DB	'FLAVOR_EXPANSION', 00H
	ORG $+3
$SG224995 DB	'FLAVOR_RECON', 00H
	ORG $+3
$SG225002 DB	'FLAVOR_GOLD', 00H
$SG225007 DB	'FLAVOR_SCIENCE', 00H
	ORG $+1
$SG225012 DB	'FLAVOR_WONDER', 00H
	ORG $+2
$SG225017 DB	'FLAVOR_MILITARY_TRAINING', 00H
	ORG $+3
$SG225022 DB	'FLAVOR_CULTURE', 00H
	ORG $+1
$SG225600 DB	'Moving to garrison, X: %d, Y: %d, Priority: %d', 00H
	ORG $+1
$SG225624 DB	'%s healing at, X: %d, Y: %d', 00H
$SG225675 DB	'Moving to mobile reserve muster pt, X: %d, Y: %d', 00H
	ORG $+3
$SG225690 DB	'Moving to sentry point, X: %d, Y: %d, Priority: %d', 00H
	ORG $+1
$SG225759 DB	'Harvesting naval resource at, X: %d, Y: %d', 00H
	ORG $+1
$SG225763 DB	'Moving toward naval resource at, X: %d, Y: %d', 00H
	ORG $+6
$SG225785 DB	'%s (%d) patrolling to, X: %d, Y: %d, Current X: %d, Curr'
	DB	'ent Y: %d', 00H
	ORG $+2
$SG225844 DB	'FLAVOR_MILITARY_TRAINING', 00H
	ORG $+3
$SG225862 DB	'Upgrading unit from type %s to type %s, X: %d, Y: %d', 00H
	ORG $+3
$SG225877 DB	'FLAVOR_MILITARY_TRAINING', 00H
	ORG $+7
$SG225884 DB	'Need gold for %s upgrade, GOLD: Available = %d, Needed ='
	DB	' %d, Priority = %d', 00H
	ORG $+5
$SG225902 DB	'Moving %s for upgrade at %s, GOLD: Available = %d, Neede'
	DB	'd = %d, Priority = %d, Dist = %d', 00H
	ORG $+3
$SG225916 DB	'Moving to goody hut (non-explorer), X: %d, Y: %d', 00H
	ORG $+3
$SG226727 DB	'Remaining in place for future airlift - %s, X: %d, Y: %d'
	DB	00H
	ORG $+3
$SG226892 DB	'Moving to airlift origin plot, X: %d, Y: %d', 00H
$SG226912 DB	'Unassigned %s at, X: %d, Y: %d', 00H
	ORG $+1
$SG226925 DB	'Founded city at, X: %d, Y: %d', 00H
	ORG $+2
$SG227161 DB	'UnitGetSpecialExploreTarget', 00H
$SG227168 DB	'UnitID: %d used Sell Exotic Goods, X: %d, Y: %d', 00H
$SG227176 DB	'UnitID: %d has goody target, X: %d, Y: %d', 00H
	ORG $+2
$SG227189 DB	'UnitID: %d Moving to goody hut, X: %d, Y: %d, from X: %d'
	DB	' Y: %d', 00H
	ORG $+1
$SG227193 DB	'UnitID: %d No end turn plot to goody from, X: %d, Y: %d', 00H
$SG227197 DB	'UnitID: %d Can''t find path to goody from, X: %d, Y: %d', 00H
	ORG $+1
$SG227296 DB	'UnitID: %d Explored to nearby target, To X: %d, Y: %d, F'
	DB	'rom X: %d, Y: %d', 00H
	ORG $+7
$SG227298 DB	'UnitID: %d Explored to distant target, To X: %d, Y: %d, '
	DB	'From X: %d, Y: %d', 00H
	ORG $+2
$SG227303 DB	'UnitID: %d Explorer (human) found no target, X: %d, Y: %'
	DB	'd', 00H
	ORG $+2
$SG227308 DB	'UnitID: %d Explorer (AI) found no target, X: %d, Y: %d', 00H
	ORG $+1
$SG227318 DB	'UnitID: %d Disbanding explorer, X: %d, Y: %d', 00H
	ORG $+3
$SG227323 DB	'UnitID: %d Sea explorer (AI) found no target, X: %d, Y: '
	DB	'%d', 00H
	ORG $+1
$SG227343 DB	'BuilderTaskingLog.csv', 00H
	ORG $+2
$SG227348 DB	',', 00H
	ORG $+2
$SG227349 DB	'%d,', 00H
$SG227350 DB	'%d,', 00H
$SG227351 DB	'1st Safety,', 00H
$SG227357 DB	'BuilderTaskingLog.csv', 00H
	ORG $+2
$SG227362 DB	',', 00H
	ORG $+2
$SG227363 DB	'%d,', 00H
$SG227364 DB	'%d,', 00H
$SG227365 DB	'2nd Safety,', 00H
$SG227444 DB	'Moving %s to safety, X: %d, Y: %d', 00H
	ORG $+2
$SG227513 DB	'Great writer can''t find a Great Work slot. Running to s'
	DB	'afety', 00H
	ORG $+3
$SG227518 DB	'Creating Great Work at, X: %d, Y: %d', 00H
	ORG $+3
$SG227538 DB	'Moving and creating Great Work at, X: %d, Y: %d', 00H
$SG227542 DB	'Moving Great Writer toward Great Work city at, X: %d, Y:'
	DB	' %d', 00H
$SG227546 DB	'Could not find a target for Great Writer at, X: %d, Y: %'
	DB	'd', 00H
	ORG $+2
$SG227570 DB	'Great artist can''t find a Great Work slot. Running to s'
	DB	'afety', 00H
	ORG $+3
$SG227575 DB	'Creating Great Work at, X: %d, Y: %d', 00H
	ORG $+3
$SG227595 DB	'Moving and creating Great Work at, X: %d, Y: %d', 00H
$SG227599 DB	'Moving Great Artist toward Great Work city at, X: %d, Y:'
	DB	' %d', 00H
$SG227603 DB	'Could not find a target for Great Artist at, X: %d, Y: %'
	DB	'd', 00H
	ORG $+2
$SG227627 DB	'Great musician can''t find a Great Work slot. Running to'
	DB	' safety', 00H
	ORG $+1
$SG227632 DB	'Creating Great Work at, X: %d, Y: %d', 00H
	ORG $+3
$SG227652 DB	'Moving and creating Great Work at, X: %d, Y: %d', 00H
$SG227656 DB	'Moving Great Musician toward Great Work city at, X: %d, '
	DB	'Y: %d', 00H
	ORG $+2
$SG227660 DB	'Could not find a target for Great Musician at, X: %d, Y:'
	DB	' %d', 00H
$SG227681 DB	'Great scientist discovered free tech at, X: %d, Y: %d', 00H
	ORG $+6
$SG227710 DB	'Great builder can''t find a good wonder to build. Runnin'
	DB	'g to safety', 00H
	ORG $+5
$SG227723 DB	'Great Engineer hurrying wonder chosen by city specializa'
	DB	'tion AI at, X: %d, Y: %d', 00H
	ORG $+7
$SG227728 DB	'Moving Great Engineer to city specialization wonder city'
	DB	' at, X: %d, Y: %d', 00H
	ORG $+2
$SG227736 DB	'Great Engineer hurrying free wonder at, X: %d, Y: %d', 00H
	ORG $+7
$SG227740 DB	'Great Engineer not needed to hurry 1-turn wonder at, X: '
	DB	'%d, Y: %d', 00H
	ORG $+2
$SG227745 DB	'Moving Great Engineer for free wonder to city at, X: %d,'
	DB	' Y: %d', 00H
	ORG $+1
$SG227785 DB	'Great Prophet founding a religion, X: %d, Y: %d', 00H
$SG227789 DB	'Great Prophet enhancing a religion, X: %d, Y: %d', 00H
	ORG $+3
$SG227812 DB	'Moving Great Prophet to nearest city without civilian, X'
	DB	': %d, Y: %d', 00H
$SG227816 DB	'No place to move Great Prophet at, X: %d, Y: %d', 00H
$SG227825 DB	'Spreading religion, X: %d, Y: %d', 00H
	ORG $+3
$SG227831 DB	'Move to spread religion, X: %d, Y: %d', 00H
	ORG $+2
$SG227836 DB	'Moving to plot adjacent to conversion city, X: %d, Y: %d'
	DB	', Currently at, X: %d, Y: %d', 00H
	ORG $+3
$SG227879 DB	'Great General culture bombed/citadel''d at, X: %d, Y: %d'
	DB	00H
$SG227883 DB	'Great general moving to culture bomb/citadel at, X: %d, '
	DB	'Y: %d', 00H
	ORG $+2
$SG227892 DB	'Great General remaining as garrison for %s, X: %d, Y: %d'
	DB	00H
	ORG $+3
$SG227919 DB	'Moving Great General to city garrison, X: %d, Y: %d', 00H
$SG227923 DB	'No place to move Great General at, X: %d, Y: %d', 00H
$SG228197 DB	'Great Admiral still in most favored city of %s, X: %d, Y'
	DB	': %d', 00H
	ORG $+3
$SG228203 DB	'Transferring Great Admiral to city of %s, X: %d, Y: %d', 00H
	ORG $+1
$SG228208 DB	'Moving Great Admiral normally to city of %s, X: %d, Y: %'
	DB	'd', 00H
	ORG $+2
$SG228212 DB	'No place to move Great Admiral at, X: %d, Y: %d', 00H
$SG228230 DB	'Spreading religion, X: %d, Y: %d', 00H
	ORG $+3
$SG228236 DB	'Move to spread religion, X: %d, Y: %d', 00H
	ORG $+2
$SG228241 DB	'Moving to plot adjacent to conversion city, X: %d, Y: %d'
	DB	', Currently at, X: %d, Y: %d', 00H
	ORG $+3
$SG228259 DB	'Removing heresy, X: %d, Y: %d', 00H
	ORG $+2
$SG228265 DB	'Move to remove heresy, X: %d, Y: %d', 00H
$SG228323 DB	'Moving %s to spaceship and adding it directly in', 00H
	ORG $+3
$SG228270 DB	'Moving to plot adjacent to heresy removal city, X: %d, Y'
	DB	': %d, Currently at, X: %d, Y: %d', 00H
	ORG $+3
$SG228293 DB	'Moving %s to spaceship - now at, X: %d, Y: %d', 00H
	ORG $+2
$SG228316 DB	'Adding %s to spaceship, X: %d, Y: %d', 00H
	ORG $+3
$SG228345 DB	'Moving %s to capital - now at, X: %d, Y: %d', 00H
$SG228390 DB	'Rebasing %s to city garrison, X: %d, Y: %d', 00H
	ORG $+1
$SG228392 DB	'Rebasing %s onto %s, X: %d, Y: %d', 00H
	ORG $+2
$SG228397 DB	'No better place to move %s at, X: %d, Y: %d', 00H
$SG228516 DB	'Establishing trade route, X: %d, Y: %d, production', 00H
	ORG $+1
$SG228450 DB	'%s (%d) tried to move to safety but is at the best spot,'
	DB	' X: %d, Y: %d', 00H
	ORG $+2
$SG228456 DB	'%s (%d) tried to move to safety but cannot hold in curre'
	DB	'nt location, X: %d, Y: %d', 00H
	ORG $+2
$SG228461 DB	'%s (%d) moving to safety, X: %d, Y: %d', 00H
	ORG $+5
$SG228467 DB	'%s (%d) tried to move to a safe point but couldn''t find'
	DB	' a good place to go', 00H
	ORG $+5
$SG228495 DB	'Disbanding unit because we want different domains for ou'
	DB	'r trade units', 00H
	ORG $+2
$SG228502 DB	'Changing trade route home city, X: %d, Y: %d', 00H
	ORG $+3
$SG228512 DB	'Establishing trade route, X: %d, Y: %d, food', 00H
	ORG $+3
$SG228514 DB	'Establishing trade route, X: %d, Y: %d, gold', 00H
	ORG $+3
$SG228520 DB	'Trade unit idling', 00H
	ORG $+2
$SG228536 DB	'BUILD_ARCHAEOLOGY_DIG', 00H
	ORG $+2
$SG228540 DB	'Archaeologist moving to site at, X: %d, Y: %d', 00H
	ORG $+2
$SG228544 DB	'Archaeologist creating dig at, X: %d, Y: %d', 00H
$SG228728 DB	'AI Patrol', 00H
	ORG $+2
$SG228732 DB	'Adjacent Patrol Plot Score, %i, %i, %i', 00H
	ORG $+1
$SG228737 DB	'Adjacent Patrol Plot !GeneratePath(), , %i, %i', 00H
	ORG $+1
$SG228741 DB	'Adjacent Patrol Plot !isVisibleEnemyUnit(), , %i, %i', 00H
	ORG $+3
$SG228745 DB	'Adjacent Patrol Plot not valid, , %i, %i', 00H
	ORG $+3
$SG228749 DB	'Adjacent Patrol Plot not found', 00H
	ORG $+1
$SG228753 DB	'Patrol Target FOUND, %i, %i, %i', 00H
$SG228757 DB	'Patrol Target NOT FOUND', 00H
$SG228899 DB	'%03d, ', 00H
	ORG $+1
$SG228901 DB	', ', 00H
	ORG $+1
$SG228912 DB	'PlayerHomelandAIPatrolLog.csv', 00H
	ORG $+2
$SG228917 DB	',', 00H
	ORG $+2
$SG228918 DB	'%d,', 00H
$SG228919 DB	'%s (%d),', 00H
	ORG $+3
$SG228946 DB	'BuilderTaskingLog.csv', 00H
	ORG $+2
$SG228951 DB	',', 00H
	ORG $+2
$SG228952 DB	'%d,', 00H
$SG228953 DB	'%d,', 00H
$SG228959 DB	'On resource,', 00H
	ORG $+3
$SG228961 DB	'On plot,', 00H
	ORG $+3
$SG228963 DB	'Repairing,', 00H
	ORG $+1
$SG228965 DB	'Building route,', 00H
$SG228967 DB	'Removing resource for production,', 00H
	ORG $+2
$SG228969 DB	'Removing road,', 00H
	ORG $+1
$SG228973 DB	'Repairing improvement', 00H
	ORG $+2
$SG228975 DB	'Repairing route', 00H
$SG228978 DB	'Building route,', 00H
$SG228982 DB	'Building improvement,', 00H
	ORG $+2
$SG228985 DB	'Removing feature for production,', 00H
	ORG $+3
$SG228987 DB	'Removing road,', 00H
	ORG $+1
$SG228989 DB	'Moving to location,', 00H
$SG229001 DB	'BuilderTaskingLog.csv', 00H
	ORG $+2
$SG229003 DB	'builder has no directive', 00H
	ORG $+3
$SG229023 DB	'%s blasted culture with unit at, X: %d, Y: %d', 00H
	ORG $+2
$SG229033 DB	'%s started golden age with unit at, X: %d, Y: %d', 00H
	ORG $+3
$SG229061 DB	'UnitID: %d Moving to script explore target, X: %d, Y: %d'
	DB	', from X: %d Y: %d', 00H
	ORG $+1
$SG229071 DB	'.csv', 00H
	ORG $+3
$SG229072 DB	'PlayerHomelandAILog_', 00H
	ORG $+3
$SG229074 DB	'PlayerHomelandAILog.csv', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	?GetReconState@CvEconomicAI@@QBE?AW4ReconState@@XZ ; CvEconomicAI::GetReconState
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.h
;	COMDAT ?GetReconState@CvEconomicAI@@QBE?AW4ReconState@@XZ
_TEXT	SEGMENT
?GetReconState@CvEconomicAI@@QBE?AW4ReconState@@XZ PROC	; CvEconomicAI::GetReconState, COMDAT
; _this$ = ecx

; 216  : 		return m_eReconState;

	mov	eax, DWORD PTR [ecx+28]

; 217  : 	};

	ret	0
?GetReconState@CvEconomicAI@@QBE?AW4ReconState@@XZ ENDP	; CvEconomicAI::GetReconState
_TEXT	ENDS
PUBLIC	?IncrementExplorersDisbanded@CvEconomicAI@@QAEXXZ ; CvEconomicAI::IncrementExplorersDisbanded
; Function compile flags: /Ogtpy
;	COMDAT ?IncrementExplorersDisbanded@CvEconomicAI@@QAEXXZ
_TEXT	SEGMENT
?IncrementExplorersDisbanded@CvEconomicAI@@QAEXXZ PROC	; CvEconomicAI::IncrementExplorersDisbanded, COMDAT
; _this$ = ecx

; 224  : 		m_iExplorersDisbanded++;

	inc	DWORD PTR [ecx+36]

; 225  : 	};

	ret	0
?IncrementExplorersDisbanded@CvEconomicAI@@QAEXXZ ENDP	; CvEconomicAI::IncrementExplorersDisbanded
_TEXT	ENDS
PUBLIC	??0CvHomelandUnit@@QAE@XZ			; CvHomelandUnit::CvHomelandUnit
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
;	COMDAT ??0CvHomelandUnit@@QAE@XZ
_TEXT	SEGMENT
??0CvHomelandUnit@@QAE@XZ PROC				; CvHomelandUnit::CvHomelandUnit, COMDAT
; _this$ = ecx

; 28   : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 29   : }

	ret	0
??0CvHomelandUnit@@QAE@XZ ENDP				; CvHomelandUnit::CvHomelandUnit
_TEXT	ENDS
PUBLIC	?Uninit@CvHomelandAI@@QAEXXZ			; CvHomelandAI::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvHomelandAI@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvHomelandAI@@QAEXXZ PROC			; CvHomelandAI::Uninit, COMDAT
; _this$ = ecx

; 72   : }

	ret	0
?Uninit@CvHomelandAI@@QAEXXZ ENDP			; CvHomelandAI::Uninit
_TEXT	ENDS
PUBLIC	?Reset@CvHomelandAI@@QAEXXZ			; CvHomelandAI::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvHomelandAI@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvHomelandAI@@QAEXXZ PROC			; CvHomelandAI::Reset, COMDAT
; _this$ = ecx

; 77   : 	m_MovePriorityTurn = -1;
; 78   : 	m_CurrentBestMoveUnit = NULL;

	xor	eax, eax
	mov	DWORD PTR [ecx+2396], eax

; 79   : 	m_CurrentBestMoveHighPriorityUnit = NULL;

	mov	DWORD PTR [ecx+2404], eax

; 80   : 	m_iCurrentBestMoveUnitTurns = MAX_INT;

	mov	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR [ecx+2392], -1
	mov	DWORD PTR [ecx+2400], eax

; 81   : 	m_iCurrentBestMoveHighPriorityUnitTurns = MAX_INT;

	mov	DWORD PTR [ecx+2408], eax

; 82   : }

	ret	0
?Reset@CvHomelandAI@@QAEXXZ ENDP			; CvHomelandAI::Reset
_TEXT	ENDS
PUBLIC	?DoTurn@CvHomelandAI@@QAEXXZ			; CvHomelandAI::DoTurn
; Function compile flags: /Ogtpy
;	COMDAT ?DoTurn@CvHomelandAI@@QAEXXZ
_TEXT	SEGMENT
?DoTurn@CvHomelandAI@@QAEXXZ PROC			; CvHomelandAI::DoTurn, COMDAT
; _this$ = ecx

; 144  : }

	ret	0
?DoTurn@CvHomelandAI@@QAEXXZ ENDP			; CvHomelandAI::DoTurn
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?SortUnitDistance@@YA_NABU?$pair@HPAVCvPlot@@@std@@0@Z
_TEXT	SEGMENT
_kEntry1$ = 8						; size = 4
_kEntry2$ = 12						; size = 4
?SortUnitDistance@@YA_NABU?$pair@HPAVCvPlot@@@std@@0@Z PROC ; SortUnitDistance, COMDAT

; 175  : 	return kEntry1.first < kEntry2.first;

	mov	eax, DWORD PTR _kEntry1$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _kEntry2$[esp-4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	setl	al

; 176  : }

	ret	0
?SortUnitDistance@@YA_NABU?$pair@HPAVCvPlot@@@std@@0@Z ENDP ; SortUnitDistance
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File s:\msvs2008\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File s:\msvs2008\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	edi
	mov	edi, DWORD PTR ___n$[esp]
	sub	edi, 1
	js	SHORT $LN1@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR ___s$[esp+8]
	push	esi
	mov	esi, DWORD PTR ___t$[esp+12]
	npad	7
$LL2@vector:
	mov	ecx, esi
	call	ebx
	add	esi, ebp
	sub	edi, 1
	jns	SHORT $LL2@vector
	pop	esi
	pop	ebp
	pop	ebx
$LN1@vector:
	pop	edi
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ; FObjectHandle<CvUnit>::pointer
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC ; FObjectHandle<CvUnit>::pointer, COMDAT
; _this$ = ecx

; 78   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 79   : 	}

	ret	0
?pointer@?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP ; FObjectHandle<CvUnit>::pointer
_TEXT	ENDS
PUBLIC	??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator->, COMDAT
; _this$ = ecx

; 88   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 89   : 	}

	ret	0
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator->
_TEXT	ENDS
PUBLIC	??D?$FObjectHandle@VCvUnit@@@@QAEAAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$FObjectHandle@VCvUnit@@@@QAEAAVCvUnit@@XZ
_TEXT	SEGMENT
??D?$FObjectHandle@VCvUnit@@@@QAEAAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator*, COMDAT
; _this$ = ecx

; 98   : 		return *m_target;

	mov	eax, DWORD PTR [ecx]

; 99   : 	}

	ret	0
??D?$FObjectHandle@VCvUnit@@@@QAEAAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator*
_TEXT	ENDS
PUBLIC	??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ		; FObjectHandle<CvUnit>::operator bool
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ
_TEXT	SEGMENT
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ PROC		; FObjectHandle<CvUnit>::operator bool, COMDAT
; _this$ = ecx

; 108  : 		return m_target != 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 109  : 	}

	ret	0
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ ENDP		; FObjectHandle<CvUnit>::operator bool
_TEXT	ENDS
PUBLIC	??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ		; FObjectHandle<CvUnit>::operator!
; Function compile flags: /Ogtpy
;	COMDAT ??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ
_TEXT	SEGMENT
??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ PROC		; FObjectHandle<CvUnit>::operator!, COMDAT
; _this$ = ecx

; 113  : 		return m_target == 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	sete	al

; 114  : 	}

	ret	0
??7?$FObjectHandle@VCvUnit@@@@QBE_NXZ ENDP		; FObjectHandle<CvUnit>::operator!
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 215  : 	{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+4], 0

; 216  : 		OBJECT_HANDLE_STACK;
; 217  : 	}

	ret	0
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?empty@?$list@HV?$allocator@H@std@@@std@@QBE_NXZ ; std::list<int,std::allocator<int> >::empty
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ?empty@?$list@HV?$allocator@H@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$list@HV?$allocator@H@std@@@std@@QBE_NXZ PROC	; std::list<int,std::allocator<int> >::empty, COMDAT
; _this$ = ecx

; 630  : 		return (_Mysize == 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+8], eax
	sete	al

; 631  : 		}

	ret	0
?empty@?$list@HV?$allocator@H@std@@@std@@QBE_NXZ ENDP	; std::list<int,std::allocator<int> >::empty
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvHomelandUnit@@$00@@QAEAAVCvHomelandUnit@@I@Z ; BaseVector<CvHomelandUnit,1>::operator[]
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@VCvHomelandUnit@@$00@@QAEAAVCvHomelandUnit@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvHomelandUnit@@$00@@QAEAAVCvHomelandUnit@@I@Z PROC ; BaseVector<CvHomelandUnit,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvHomelandUnit@@$00@@QAEAAVCvHomelandUnit@@I@Z ENDP ; BaseVector<CvHomelandUnit,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvHomelandUnit@@$00@@QBEIXZ	; BaseVector<CvHomelandUnit,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@VCvHomelandUnit@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvHomelandUnit@@$00@@QBEIXZ PROC	; BaseVector<CvHomelandUnit,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvHomelandUnit@@$00@@QBEIXZ ENDP	; BaseVector<CvHomelandUnit,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvHomelandUnit@@$00@@QAEPAVCvHomelandUnit@@XZ ; BaseVector<CvHomelandUnit,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@VCvHomelandUnit@@$00@@QAEPAVCvHomelandUnit@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvHomelandUnit@@$00@@QAEPAVCvHomelandUnit@@XZ PROC ; BaseVector<CvHomelandUnit,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@VCvHomelandUnit@@$00@@QAEPAVCvHomelandUnit@@XZ ENDP ; BaseVector<CvHomelandUnit,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvHomelandUnit@@$00@@QAEPAVCvHomelandUnit@@XZ ; BaseVector<CvHomelandUnit,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvHomelandUnit@@$00@@QAEPAVCvHomelandUnit@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvHomelandUnit@@$00@@QAEPAVCvHomelandUnit@@XZ PROC ; BaseVector<CvHomelandUnit,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx]

; 198  :     };

	ret	0
?end@?$BaseVector@VCvHomelandUnit@@$00@@QAEPAVCvHomelandUnit@@XZ ENDP ; BaseVector<CvHomelandUnit,1>::end
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvHomelandMove@@$00@@QAEPAVCvHomelandMove@@XZ ; BaseVector<CvHomelandMove,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@VCvHomelandMove@@$00@@QAEPAVCvHomelandMove@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvHomelandMove@@$00@@QAEPAVCvHomelandMove@@XZ PROC ; BaseVector<CvHomelandMove,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@VCvHomelandMove@@$00@@QAEPAVCvHomelandMove@@XZ ENDP ; BaseVector<CvHomelandMove,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvHomelandMove@@$00@@QAEPAVCvHomelandMove@@XZ ; BaseVector<CvHomelandMove,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvHomelandMove@@$00@@QAEPAVCvHomelandMove@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvHomelandMove@@$00@@QAEPAVCvHomelandMove@@XZ PROC ; BaseVector<CvHomelandMove,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@VCvHomelandMove@@$00@@QAEPAVCvHomelandMove@@XZ ENDP ; BaseVector<CvHomelandMove,1>::end
_TEXT	ENDS
PUBLIC	?size@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEIXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?size@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEIXZ PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::size
_TEXT	ENDS
PUBLIC	?empty@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE_NXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::empty
; Function compile flags: /Ogtpy
;	COMDAT ?empty@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE_NXZ PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::empty, COMDAT
; _this$ = ecx

; 736  : 		return (size() == 0);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	neg	eax
	sbb	eax, eax
	inc	eax

; 737  : 		}

	ret	0
?empty@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::empty
_TEXT	ENDS
PUBLIC	??A?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAVCvHomelandTarget@@I@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAVCvHomelandTarget@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAVCvHomelandTarget@@I@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 786  : 		}

	ret	4
??A?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAVCvHomelandTarget@@I@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@H$0A@@@QAEAAHI@Z		; BaseVector<int,0>::operator[]
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@H$0A@@@QAEAAHI@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@H$0A@@@QAEAAHI@Z PROC			; BaseVector<int,0>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@H$0A@@@QAEAAHI@Z ENDP			; BaseVector<int,0>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@H$0A@@@QBEIXZ		; BaseVector<int,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@H$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@H$0A@@@QBEIXZ PROC			; BaseVector<int,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@H$0A@@@QBEIXZ ENDP			; BaseVector<int,0>::size
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QBEIXZ ; BaseVector<std::pair<int,CvPlot *>,0>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QBEIXZ PROC ; BaseVector<std::pair<int,CvPlot *>,0>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QBEIXZ ENDP ; BaseVector<std::pair<int,CvPlot *>,0>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAEPAU?$pair@HPAVCvPlot@@@std@@XZ ; BaseVector<std::pair<int,CvPlot *>,0>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAEPAU?$pair@HPAVCvPlot@@@std@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAEPAU?$pair@HPAVCvPlot@@@std@@XZ PROC ; BaseVector<std::pair<int,CvPlot *>,0>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAEPAU?$pair@HPAVCvPlot@@@std@@XZ ENDP ; BaseVector<std::pair<int,CvPlot *>,0>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAEPAU?$pair@HPAVCvPlot@@@std@@XZ ; BaseVector<std::pair<int,CvPlot *>,0>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAEPAU?$pair@HPAVCvPlot@@@std@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAEPAU?$pair@HPAVCvPlot@@@std@@XZ PROC ; BaseVector<std::pair<int,CvPlot *>,0>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAEPAU?$pair@HPAVCvPlot@@@std@@XZ ENDP ; BaseVector<std::pair<int,CvPlot *>,0>::end
_TEXT	ENDS
PUBLIC	??0?$pair@HPAVCvPlot@@@std@@QAE@ABHABQAVCvPlot@@@Z ; std::pair<int,CvPlot *>::pair<int,CvPlot *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??0?$pair@HPAVCvPlot@@@std@@QAE@ABHABQAVCvPlot@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@HPAVCvPlot@@@std@@QAE@ABHABQAVCvPlot@@@Z PROC	; std::pair<int,CvPlot *>::pair<int,CvPlot *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@HPAVCvPlot@@@std@@QAE@ABHABQAVCvPlot@@@Z ENDP	; std::pair<int,CvPlot *>::pair<int,CvPlot *>
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::size
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEABQAVCvCity@@XZ ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEABQAVCvCity@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEABQAVCvCity@@XZ PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEABQAVCvCity@@XZ ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@XZ ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@XZ PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEABQAVCvPlot@@XZ ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator*
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	?_Nextnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z ; std::list<int,std::allocator<int> >::_Nextnode
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ?_Nextnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z PROC ; std::list<int,std::allocator<int> >::_Nextnode, COMDAT

; 115  : 		return ((_Nodepref)(*_Pnode)._Next);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 116  : 		}

	ret	0
?_Nextnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z ENDP ; std::list<int,std::allocator<int> >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Prevnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z ; std::list<int,std::allocator<int> >::_Prevnode
; Function compile flags: /Ogtpy
;	COMDAT ?_Prevnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z PROC ; std::list<int,std::allocator<int> >::_Prevnode, COMDAT

; 120  : 		return ((_Nodepref)(*_Pnode)._Prev);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 121  : 		}

	ret	0
?_Prevnode@?$list@HV?$allocator@H@std@@@std@@KAAAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@@Z ENDP ; std::list<int,std::allocator<int> >::_Prevnode
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::deallocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEPAVCvHomelandUnit@@I@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@ DB 's:\lekmod_d'
	DB	'll\fireplace\include\fireworks\FFastVector.h', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEPAVCvHomelandUnit@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEPAVCvHomelandUnit@@I@Z PROC ; FStaticVector<CvHomelandUnit,64,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 64					; 00000040H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	mov	eax, edi
	shl	eax, 4
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 64			; 00000040H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEPAVCvHomelandUnit@@I@Z ENDP ; FStaticVector<CvHomelandUnit,64,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvHomelandUnit@@$00@@QAE@XZ	; BaseVector<CvHomelandUnit,1>::~BaseVector<CvHomelandUnit,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvHomelandUnit@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvHomelandUnit@@$00@@QAE@XZ PROC	; BaseVector<CvHomelandUnit,1>::~BaseVector<CvHomelandUnit,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvHomelandUnit@@$00@@QAE@XZ ENDP	; BaseVector<CvHomelandUnit,1>::~BaseVector<CvHomelandUnit,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvHomelandUnit@@$00@@IAE@XZ	; BaseVector<CvHomelandUnit,1>::BaseVector<CvHomelandUnit,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvHomelandUnit@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvHomelandUnit@@$00@@IAE@XZ PROC	; BaseVector<CvHomelandUnit,1>::BaseVector<CvHomelandUnit,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvHomelandUnit@@$00@@IAE@XZ ENDP	; BaseVector<CvHomelandUnit,1>::BaseVector<CvHomelandUnit,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvHomelandUnit@@$00@@IAEXPAVCvHomelandUnit@@I@Z ; BaseVector<CvHomelandUnit,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvHomelandUnit@@$00@@IAEXPAVCvHomelandUnit@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvHomelandUnit@@$00@@IAEXPAVCvHomelandUnit@@I@Z PROC ; BaseVector<CvHomelandUnit,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvHomelandUnit@@$00@@IAEXPAVCvHomelandUnit@@I@Z ENDP ; BaseVector<CvHomelandUnit,1>::Destroy
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@VCvHomelandUnit@@$00@@IAEXABV1@@Z ; BaseVector<CvHomelandUnit,1>::Copy
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?Copy@?$BaseVector@VCvHomelandUnit@@$00@@IAEXABV1@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@VCvHomelandUnit@@$00@@IAEXABV1@@Z PROC ; BaseVector<CvHomelandUnit,1>::Copy, COMDAT
; _this$ = ecx

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _RHS$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 231  : 		if( bPODType ){
; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	shl	edx, 4
	push	edx
	push	eax
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 233  : 		}else{
; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){
; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );
; 236  : 			}
; 237  : 		}
; 238  : 	};

	ret	4
?Copy@?$BaseVector@VCvHomelandUnit@@$00@@IAEXABV1@@Z ENDP ; BaseVector<CvHomelandUnit,1>::Copy
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEPAVCvHomelandMove@@I@Z ; FStaticVector<CvHomelandMove,35,1,297,0>::Alloc
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEPAVCvHomelandMove@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEPAVCvHomelandMove@@I@Z PROC ; FStaticVector<CvHomelandMove,35,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 35					; 00000023H
	jbe	SHORT $LN2@Alloc@2

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@2:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 35			; 00000023H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEPAVCvHomelandMove@@I@Z ENDP ; FStaticVector<CvHomelandMove,35,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvHomelandMove@@$00@@QAE@XZ	; BaseVector<CvHomelandMove,1>::~BaseVector<CvHomelandMove,1>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@VCvHomelandMove@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvHomelandMove@@$00@@QAE@XZ PROC	; BaseVector<CvHomelandMove,1>::~BaseVector<CvHomelandMove,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvHomelandMove@@$00@@QAE@XZ ENDP	; BaseVector<CvHomelandMove,1>::~BaseVector<CvHomelandMove,1>
_TEXT	ENDS
PUBLIC	?GetCString@CvString@@QBEPBDXZ			; CvString::GetCString
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ?GetCString@CvString@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@CvString@@QBEPBDXZ PROC			; CvString::GetCString, COMDAT
; _this$ = ecx

; 42   : 	const char* GetCString() const 	{ return c_str(); }

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCString@CvString@@QBEPBDXZ ENDP			; CvString::GetCString
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvHomelandMove@@$00@@IAE@XZ	; BaseVector<CvHomelandMove,1>::BaseVector<CvHomelandMove,1>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$BaseVector@VCvHomelandMove@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvHomelandMove@@$00@@IAE@XZ PROC	; BaseVector<CvHomelandMove,1>::BaseVector<CvHomelandMove,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvHomelandMove@@$00@@IAE@XZ ENDP	; BaseVector<CvHomelandMove,1>::BaseVector<CvHomelandMove,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvHomelandMove@@$00@@IAEXPAVCvHomelandMove@@I@Z ; BaseVector<CvHomelandMove,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvHomelandMove@@$00@@IAEXPAVCvHomelandMove@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvHomelandMove@@$00@@IAEXPAVCvHomelandMove@@I@Z PROC ; BaseVector<CvHomelandMove,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvHomelandMove@@$00@@IAEXPAVCvHomelandMove@@I@Z ENDP ; BaseVector<CvHomelandMove,1>::Destroy
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEIXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::capacity
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?capacity@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEIXZ PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvHomelandTarget> >::~_Container_base_aux_alloc_empty<std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvHomelandTarget> >::~_Container_base_aux_alloc_empty<std::allocator<CvHomelandTarget> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvHomelandTarget> >::~_Container_base_aux_alloc_empty<std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvHomelandTarget@@@std@@QAE@XZ	; std::allocator<CvHomelandTarget>::allocator<CvHomelandTarget>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvHomelandTarget@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VCvHomelandTarget@@@std@@QAE@XZ PROC	; std::allocator<CvHomelandTarget>::allocator<CvHomelandTarget>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VCvHomelandTarget@@@std@@QAE@XZ ENDP	; std::allocator<CvHomelandTarget>::allocator<CvHomelandTarget>
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VCvHomelandTarget@@@std@@QAEXPAVCvHomelandTarget@@I@Z ; std::allocator<CvHomelandTarget>::deallocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@VCvHomelandTarget@@@std@@QAEXPAVCvHomelandTarget@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCvHomelandTarget@@@std@@QAEXPAVCvHomelandTarget@@I@Z PROC ; std::allocator<CvHomelandTarget>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VCvHomelandTarget@@@std@@QAEXPAVCvHomelandTarget@@I@Z ENDP ; std::allocator<CvHomelandTarget>::deallocate
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEPAUTradeConnection@@I@Z ; FStaticVector<TradeConnection,168,0,297,0>::Alloc
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEPAUTradeConnection@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEPAUTradeConnection@@I@Z PROC ; FStaticVector<TradeConnection,168,0,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 168				; 000000a8H
	jbe	SHORT $LN2@Alloc@3

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	mov	eax, edi
	imul	eax, 444				; 000001bcH
	push	798					; 0000031eH
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@3:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 168			; 000000a8H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEPAUTradeConnection@@I@Z ENDP ; FStaticVector<TradeConnection,168,0,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ	; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ PROC	; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ ENDP	; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UTradeConnection@@$0A@@@IAE@XZ	; BaseVector<TradeConnection,0>::BaseVector<TradeConnection,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UTradeConnection@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UTradeConnection@@$0A@@@IAE@XZ PROC	; BaseVector<TradeConnection,0>::BaseVector<TradeConnection,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UTradeConnection@@$0A@@@IAE@XZ ENDP	; BaseVector<TradeConnection,0>::BaseVector<TradeConnection,0>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::capacity
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@2
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::size
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPlot@@@std@@QAE@XZ		; std::allocator<CvPlot *>::allocator<CvPlot *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPlot@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvPlot@@@std@@QAE@XZ PROC		; std::allocator<CvPlot *>::allocator<CvPlot *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvPlot@@@std@@QAE@XZ ENDP		; std::allocator<CvPlot *>::allocator<CvPlot *>
_TEXT	ENDS
PUBLIC	??1?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAE@XZ ; BaseVector<std::pair<int,CvPlot *>,0>::~BaseVector<std::pair<int,CvPlot *>,0>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAE@XZ PROC ; BaseVector<std::pair<int,CvPlot *>,0>::~BaseVector<std::pair<int,CvPlot *>,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@QAE@XZ ENDP ; BaseVector<std::pair<int,CvPlot *>,0>::~BaseVector<std::pair<int,CvPlot *>,0>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@IAE@XZ ; BaseVector<std::pair<int,CvPlot *>,0>::BaseVector<std::pair<int,CvPlot *>,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@IAE@XZ PROC ; BaseVector<std::pair<int,CvPlot *>,0>::BaseVector<std::pair<int,CvPlot *>,0>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@IAE@XZ ENDP ; BaseVector<std::pair<int,CvPlot *>,0>::BaseVector<std::pair<int,CvPlot *>,0>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEABVCvHomelandTarget@@XZ ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEABVCvHomelandTarget@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEABVCvHomelandTarget@@XZ PROC ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEABVCvHomelandTarget@@XZ ENDP ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 20			; 00000014H

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Const_iterator<0>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Const_iterator<0>, COMDAT
; _this$ = ecx

; 163  : 			{	// construct with null node pointer

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 164  : 			}

	ret	0
??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Const_iterator<0>
_TEXT	ENDS
PUBLIC	??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator++, COMDAT
; _this$ = ecx

; 235  : 			{	// preincrement

	mov	eax, ecx

; 236  : 
; 237  :  #if _HAS_ITERATOR_DEBUGGING
; 238  : 			if (this->_Mycont == 0
; 239  : 				|| _Ptr == 0
; 240  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 241  : 				{
; 242  : 				_DEBUG_ERROR("list iterator not incrementable");
; 243  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 244  : 				}
; 245  :  #else
; 246  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());
; 247  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 248  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 249  : 
; 250  : 			_Ptr = _Nextnode(_Ptr);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 251  : 			return (*this);
; 252  : 			}

	ret	0
??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator++
_TEXT	ENDS
PUBLIC	??8?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator==, COMDAT
; _this$ = ecx

; 291  : 
; 292  :  #if _HAS_ITERATOR_DEBUGGING
; 293  : 			_Compat(_Right);
; 294  :  #else
; 295  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 296  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 297  : 
; 298  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 299  : 			}

	ret	4
??8?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator==
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::capacity
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@3
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@3:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::~_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvCity@@@std@@QAE@XZ		; std::allocator<CvCity *>::allocator<CvCity *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvCity@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvCity@@@std@@QAE@XZ PROC		; std::allocator<CvCity *>::allocator<CvCity *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvCity@@@std@@QAE@XZ ENDP		; std::allocator<CvCity *>::allocator<CvCity *>
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator++
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator==
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator==
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@XZ ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@XZ PROC ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@XZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@XZ ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@XZ PROC ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@XZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ ; CvWeightedVector<CvPlot *,100,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ PROC ; CvWeightedVector<CvPlot *,100,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ ENDP ; CvWeightedVector<CvPlot *,100,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@XZ ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@XZ PROC ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@XZ ENDP ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@XZ ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@XZ PROC ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@XZ ENDP ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ ; CvWeightedVector<CvCity *,64,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ PROC ; CvWeightedVector<CvCity *,64,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ ENDP ; CvWeightedVector<CvCity *,64,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?_Myval@?$list@HV?$allocator@H@std@@@std@@KAAAHPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ; std::list<int,std::allocator<int> >::_Myval
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ?_Myval@?$list@HV?$allocator@H@std@@@std@@KAAAHPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@HV?$allocator@H@std@@@std@@KAAAHPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z PROC ; std::list<int,std::allocator<int> >::_Myval, COMDAT

; 125  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 126  : 		}

	ret	0
?_Myval@?$list@HV?$allocator@H@std@@@std@@KAAAHPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ENDP ; std::list<int,std::allocator<int> >::_Myval
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T238251 = -80						; size = 28
$T238250 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T238251[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T238250[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T238251[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T238250[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T238250[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T238250[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T238250[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T238251[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T238250[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE@V?$allocator@VCvHomelandTarget@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvHomelandTarget> >::_Container_base_aux_alloc_empty<std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE@V?$allocator@VCvHomelandTarget@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE@V?$allocator@VCvHomelandTarget@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvHomelandTarget> >::_Container_base_aux_alloc_empty<std::allocator<CvHomelandTarget> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE@V?$allocator@VCvHomelandTarget@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvHomelandTarget> >::_Container_base_aux_alloc_empty<std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvHomelandTarget@@@std@@QAE@ABV01@@Z ; std::allocator<CvHomelandTarget>::allocator<CvHomelandTarget>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvHomelandTarget@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VCvHomelandTarget@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvHomelandTarget>::allocator<CvHomelandTarget>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@VCvHomelandTarget@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvHomelandTarget>::allocator<CvHomelandTarget>
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T238294 = -80						; size = 28
$T238293 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T238294[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T238293[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T238294[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T238293[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T238293[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T238293[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T238293[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T238294[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T238293[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >::_Container_base_aux_alloc_empty<std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z	; std::allocator<CvPlot *>::allocator<CvPlot *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvPlot *>::allocator<CvPlot *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvPlot@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvPlot *>::allocator<CvPlot *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvPlot@@@std@@QAEXPAPAVCvPlot@@I@Z ; std::allocator<CvPlot *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvPlot@@@std@@QAEXPAPAVCvPlot@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvPlot@@@std@@QAEXPAPAVCvPlot@@I@Z PROC ; std::allocator<CvPlot *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvPlot@@@std@@QAEXPAPAVCvPlot@@I@Z ENDP ; std::allocator<CvPlot *>::deallocate
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@IAEXPAU?$pair@HPAVCvPlot@@@std@@I@Z ; BaseVector<std::pair<int,CvPlot *>,0>::Destroy
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@IAEXPAU?$pair@HPAVCvPlot@@@std@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@IAEXPAU?$pair@HPAVCvPlot@@@std@@I@Z PROC ; BaseVector<std::pair<int,CvPlot *>,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@IAEXPAU?$pair@HPAVCvPlot@@@std@@I@Z ENDP ; BaseVector<std::pair<int,CvPlot *>,0>::Destroy
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@PAVCvHomelandTarget@@@Z ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@PAVCvHomelandTarget@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@PAVCvHomelandTarget@@@Z PROC ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@PAVCvHomelandTarget@@@Z ENDP ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Const_iterator<0>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Const_iterator<0>, COMDAT
; _this$ = ecx

; 184  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 185  : 			}

	ret	4
??0?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Const_iterator<0>
_TEXT	ENDS
PUBLIC	??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator++, COMDAT
; _this$ = ecx

; 256  : 			_Myt_iter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 257  : 			++*this;

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 258  : 			return (_Tmp);
; 259  : 			}

	ret	8
??E?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator++
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@3@XZ ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@3@XZ PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Mynode, COMDAT
; _this$ = ecx

; 308  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 309  : 			}

	ret	0
?_Mynode@?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@3@XZ ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::_Mynode
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T238357 = -80						; size = 28
$T238356 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T238357[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T238356[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T238357[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T238356[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T238356[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T238356[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T238356[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@3:
$LN12@Xlen@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T238357[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T238356[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >::_Container_base_aux_alloc_empty<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z	; std::allocator<CvCity *>::allocator<CvCity *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvCity *>::allocator<CvCity *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvCity@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvCity *>::allocator<CvCity *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z ; std::allocator<CvCity *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z PROC ; std::allocator<CvCity *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvCity@@@std@@QAEXPAPAVCvCity@@I@Z ENDP ; std::allocator<CvCity *>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator-
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::Alloc
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 100				; 00000064H
	jbe	SHORT $LN2@Alloc@4

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@4:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 100			; 00000064H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@ABU01@@Z ; CvWeightedVector<CvPlot *,100,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<CvPlot *,100,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<CvPlot *,100,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::Alloc
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 64					; 00000040H
	jbe	SHORT $LN2@Alloc@5

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@5:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 64			; 00000040H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@ABU01@@Z ; CvWeightedVector<CvCity *,64,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<CvCity *,64,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<CvCity *,64,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@SAPAXIIII@Z ; BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator::AllocAligned
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@SAPAXIIII@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_nAlign$ = 12						; size = 4
_nAllocPool$ = 16					; size = 4
_nAllocSubID$ = 20					; size = 4
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@SAPAXIIII@Z PROC ; BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator::AllocAligned, COMDAT

; 85   : 			return FMALLOCALIGNED( nBytes, nAlign, nAllocPool, nAllocSubID );

	mov	DWORD PTR _nAllocSubID$[esp-4], 85	; 00000055H
	mov	DWORD PTR _nAllocPool$[esp-4], OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	jmp	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@SAPAXIIII@Z ENDP ; BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator::AllocAligned
_TEXT	ENDS
PUBLIC	?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@SAXPAX@Z ; BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator::FreeAligned
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@SAXPAX@Z
_TEXT	SEGMENT
_pBlock$ = 8						; size = 4
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@SAXPAX@Z PROC ; BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator::FreeAligned, COMDAT

; 90   : 			FFREEALIGNED( pBlock );

	jmp	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@SAXPAX@Z ENDP ; BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator::FreeAligned
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VCvHomelandTarget@@@std@@QBEIXZ ; std::allocator<CvHomelandTarget>::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@VCvHomelandTarget@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCvHomelandTarget@@@std@@QBEIXZ PROC ; std::allocator<CvHomelandTarget>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 214748364				; 0cccccccH

; 167  : 		}

	ret	0
?max_size@?$allocator@VCvHomelandTarget@@@std@@QBEIXZ ENDP ; std::allocator<CvHomelandTarget>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ	; std::allocator<CvPlot *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ PROC	; std::allocator<CvPlot *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvPlot@@@std@@QBEIXZ ENDP	; std::allocator<CvPlot *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ	; std::allocator<CvCity *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ PROC	; std::allocator<CvCity *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvCity@@@std@@QBEIXZ ENDP	; std::allocator<CvCity *>::max_size
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ ; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ PROC	; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ ENDP	; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator+=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z ; BaseVector<TradeConnectionPlot,0>::Destroy
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z PROC ; BaseVector<TradeConnectionPlot,0>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z ENDP ; BaseVector<TradeConnectionPlot,0>::Destroy
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z ; std::_Destroy<std::_List_nod<int,std::allocator<int> >::_Node>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z PROC ; std::_Destroy<std::_List_nod<int,std::allocator<int> >::_Node>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<int,std::allocator<int> >::_Node>
_TEXT	ENDS
PUBLIC	??$?0H@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::allocator<std::_List_nod<int,std::allocator<int> >::_Node *><int>
; Function compile flags: /Ogtpy
;	COMDAT ??$?0H@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0H@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::allocator<std::_List_nod<int,std::allocator<int> >::_Node *><int>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0H@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::allocator<std::_List_nod<int,std::allocator<int> >::_Node *><int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<int,std::allocator<int> >::_Node>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File s:\msvs2008\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T238485 = -12						; size = 12
$T238489 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_List_nod<int,std::allocator<int> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T238489[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T238485[esp+16]
	mov	DWORD PTR $T238489[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T238485[esp+16]
	push	ecx
	mov	DWORD PTR $T238485[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<int,std::allocator<int> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<int,std::allocator<int> >::_Node *,std::_List_nod<int,std::allocator<int> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_List_nod<int,std::allocator<int> >::_Node *,std::_List_nod<int,std::allocator<int> >::_Node *>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<int,std::allocator<int> >::_Node *,std::_List_nod<int,std::allocator<int> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z ; std::_Destroy<std::_List_nod<int,std::allocator<int> >::_Node *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z PROC ; std::_Destroy<std::_List_nod<int,std::allocator<int> >::_Node *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<int,std::allocator<int> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Allocate@VCvHomelandTarget@@@std@@YAPAVCvHomelandTarget@@IPAV1@@Z ; std::_Allocate<CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@VCvHomelandTarget@@@std@@YAPAVCvHomelandTarget@@IPAV1@@Z
_TEXT	SEGMENT
$T238507 = -12						; size = 12
$T238511 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvHomelandTarget@@@std@@YAPAVCvHomelandTarget@@IPAV1@@Z PROC ; std::_Allocate<CvHomelandTarget>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*4]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T238511[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T238507[esp+16]
	mov	DWORD PTR $T238511[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T238507[esp+16]
	push	ecx
	mov	DWORD PTR $T238507[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@VCvHomelandTarget@@@std@@YAPAVCvHomelandTarget@@IPAV1@@Z ENDP ; std::_Allocate<CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ; std::_Allocate<CvPlot *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z
_TEXT	SEGMENT
$T238517 = -12						; size = 12
$T238521 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z PROC ; std::_Allocate<CvPlot *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T238521[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T238517[esp+16]
	mov	DWORD PTR $T238521[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T238517[esp+16]
	push	ecx
	mov	DWORD PTR $T238517[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ENDP ; std::_Allocate<CvPlot *>
_TEXT	ENDS
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jb	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z
_TEXT	SEGMENT
$T238533 = -12						; size = 12
$T238537 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z PROC ; std::_Allocate<CvCity *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T238537[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T238533[esp+16]
	mov	DWORD PTR $T238537[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T238533[esp+16]
	push	ecx
	mov	DWORD PTR $T238533[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@4:
$LN8@Allocate@4:
	int	3
??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ENDP ; std::_Allocate<CvCity *>
_TEXT	ENDS
PUBLIC	??$_Construct@HH@std@@YAXPAHABH@Z		; std::_Construct<int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@HH@std@@YAXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@HH@std@@YAXPAHABH@Z PROC			; std::_Construct<int,int>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@HH@std@@YAXPAHABH@Z ENDP			; std::_Construct<int,int>
_TEXT	ENDS
PUBLIC	??$?0H@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocator<std::_List_nod<int,std::allocator<int> >::_Node><int>
; Function compile flags: /Ogtpy
;	COMDAT ??$?0H@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0H@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocator<std::_List_nod<int,std::allocator<int> >::_Node><int>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	mov	eax, ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	4
??$?0H@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocator<std::_List_nod<int,std::allocator<int> >::_Node><int>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAVCvHomelandMove@@@std@@YAPAHPAVCvHomelandMove@@@Z ; std::_Dist_type<CvHomelandMove *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Dist_type@PAVCvHomelandMove@@@std@@YAPAHPAVCvHomelandMove@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAVCvHomelandMove@@@std@@YAPAHPAVCvHomelandMove@@@Z PROC ; std::_Dist_type<CvHomelandMove *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAVCvHomelandMove@@@std@@YAPAHPAVCvHomelandMove@@@Z ENDP ; std::_Dist_type<CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAVCvHomelandMove@@@std@@YAPAVCvHomelandMove@@PAV1@@Z ; std::_Val_type<CvHomelandMove *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAVCvHomelandMove@@@std@@YAPAVCvHomelandMove@@PAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAVCvHomelandMove@@@std@@YAPAVCvHomelandMove@@PAV1@@Z PROC ; std::_Val_type<CvHomelandMove *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAVCvHomelandMove@@@std@@YAPAVCvHomelandMove@@PAV1@@Z ENDP ; std::_Val_type<CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$_Dist_type@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAPAHV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Val_type@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAPAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z ; std::_Val_type<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAPAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAPAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z PROC ; std::_Val_type<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAPAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z ENDP ; std::_Val_type<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAVCvHomelandUnit@@@std@@YAPAHPAVCvHomelandUnit@@@Z ; std::_Dist_type<CvHomelandUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@PAVCvHomelandUnit@@@std@@YAPAHPAVCvHomelandUnit@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAVCvHomelandUnit@@@std@@YAPAHPAVCvHomelandUnit@@@Z PROC ; std::_Dist_type<CvHomelandUnit *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAVCvHomelandUnit@@@std@@YAPAHPAVCvHomelandUnit@@@Z ENDP ; std::_Dist_type<CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAVCvHomelandUnit@@@std@@YAPAVCvHomelandUnit@@PAV1@@Z ; std::_Val_type<CvHomelandUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAVCvHomelandUnit@@@std@@YAPAVCvHomelandUnit@@PAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAVCvHomelandUnit@@@std@@YAPAVCvHomelandUnit@@PAV1@@Z PROC ; std::_Val_type<CvHomelandUnit *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAVCvHomelandUnit@@@std@@YAPAVCvHomelandUnit@@PAV1@@Z ENDP ; std::_Val_type<CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvHomelandTarget@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@0@Z ; std::_Iter_random<CvHomelandTarget *,CvHomelandTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvHomelandTarget@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvHomelandTarget@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@0@Z PROC ; std::_Iter_random<CvHomelandTarget *,CvHomelandTarget *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvHomelandTarget@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@0@Z ENDP ; std::_Iter_random<CvHomelandTarget *,CvHomelandTarget *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvHomelandTarget@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandTarget@@0@Z ; std::_Ptr_cat<CvHomelandTarget *,CvHomelandTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvHomelandTarget@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandTarget@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvHomelandTarget@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandTarget@@0@Z PROC ; std::_Ptr_cat<CvHomelandTarget *,CvHomelandTarget *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvHomelandTarget@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandTarget@@0@Z ENDP ; std::_Ptr_cat<CvHomelandTarget *,CvHomelandTarget *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt
	push	esi
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	add	ecx, 20					; 00000014H
	add	eax, 20					; 00000014H
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt
	pop	esi
$LN1@Copy_opt:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::operator->
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
;	COMDAT ??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::operator->, COMDAT
; _this$ = ecx

; 40   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 41   : }

	ret	0
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::operator->
_TEXT	ENDS
PUBLIC	?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::get, COMDAT
; _this$ = ecx

; 45   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 46   : }

	ret	0
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::get
_TEXT	ENDS
PUBLIC	?GetID@CvBaseInfo@@QBEHXZ			; CvBaseInfo::GetID
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetID@CvBaseInfo@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvBaseInfo@@QBEHXZ PROC				; CvBaseInfo::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvBaseInfo@@QBEHXZ ENDP				; CvBaseInfo::GetID
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvPlot@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlot@@0@Z ; std::_Ptr_cat<CvPlot * *,CvPlot * *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvPlot@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlot@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvPlot@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlot@@0@Z PROC ; std::_Ptr_cat<CvPlot * *,CvPlot * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvPlot@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPlot@@0@Z ENDP ; std::_Ptr_cat<CvPlot * *,CvPlot * *>
_TEXT	ENDS
PUBLIC	?GetDescription@CvBaseInfo@@QBEPBDXZ		; CvBaseInfo::GetDescription
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetDescription@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetDescription@CvBaseInfo@@QBEPBDXZ PROC		; CvBaseInfo::GetDescription, COMDAT
; _this$ = ecx

; 64   : 		return m_strDescription.c_str();

	add	ecx, 36					; 00000024H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetDescription@CvBaseInfo@@QBEPBDXZ ENDP		; CvBaseInfo::GetDescription
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z ; std::_Ptr_cat<CvCity * *,CvCity * *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z PROC ; std::_Ptr_cat<CvCity * *,CvCity * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvCity@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvCity@@0@Z ENDP ; std::_Ptr_cat<CvCity * *,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVCvHomelandTarget@@V1@@std@@YAXPAVCvHomelandTarget@@0ABV1@@Z ; std::_Fill<CvHomelandTarget *,CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAVCvHomelandTarget@@V1@@std@@YAXPAVCvHomelandTarget@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVCvHomelandTarget@@V1@@std@@YAXPAVCvHomelandTarget@@0ABV1@@Z PROC ; std::_Fill<CvHomelandTarget *,CvHomelandTarget>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	add	eax, 20					; 00000014H
	cmp	eax, edx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAVCvHomelandTarget@@V1@@std@@YAXPAVCvHomelandTarget@@0ABV1@@Z ENDP ; std::_Fill<CvHomelandTarget *,CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAVCvHomelandTarget@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvHomelandTarget@@@Z ; std::_Move_cat<CvHomelandTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAVCvHomelandTarget@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvHomelandTarget@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVCvHomelandTarget@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvHomelandTarget@@@Z PROC ; std::_Move_cat<CvHomelandTarget *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAVCvHomelandTarget@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvHomelandTarget@@@Z ENDP ; std::_Move_cat<CvHomelandTarget *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPlot *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ; std::_Fill<CvPlot * *,CvPlot *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z PROC ; std::_Fill<CvPlot * *,CvPlot *>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@2
	pop	esi
$LN1@Fill@2:

; 3160 : 	}

	ret	0
??$_Fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ENDP ; std::_Fill<CvPlot * *,CvPlot *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvPlot@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@0@Z ; std::_Iter_random<CvPlot * *,CvPlot * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvPlot@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvPlot@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@0@Z PROC ; std::_Iter_random<CvPlot * *,CvPlot * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvPlot@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@0@Z ENDP ; std::_Iter_random<CvPlot * *,CvPlot * *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAPAVCvPlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvPlot@@@Z ; std::_Move_cat<CvPlot * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAPAVCvPlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvPlot@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVCvPlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvPlot@@@Z PROC ; std::_Move_cat<CvPlot * *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAPAVCvPlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvPlot@@@Z ENDP ; std::_Move_cat<CvPlot * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvCity *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::_Fill<CvCity * *,CvCity *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z PROC ; std::_Fill<CvCity * *,CvCity *>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@3:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@3
	pop	esi
$LN1@Fill@3:

; 3160 : 	}

	ret	0
??$_Fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ENDP ; std::_Fill<CvCity * *,CvCity *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z ; std::_Iter_random<CvCity * *,CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z PROC ; std::_Iter_random<CvCity * *,CvCity * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvCity@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@0@Z ENDP ; std::_Iter_random<CvCity * *,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z ; std::_Move_cat<CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z PROC ; std::_Move_cat<CvCity * *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAPAVCvCity@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCvCity@@@Z ENDP ; std::_Move_cat<CvCity * *>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@H@Z ; std::_Temp_iterator<CvHomelandMove>::_Temp_iterator<CvHomelandMove>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@H@Z PROC	; std::_Temp_iterator<CvHomelandMove>::_Temp_iterator<CvHomelandMove>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@H@Z ENDP	; std::_Temp_iterator<CvHomelandMove>::_Temp_iterator<CvHomelandMove>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@H@Z ; std::_Temp_iterator<CvHomelandTarget>::_Temp_iterator<CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@H@Z PROC ; std::_Temp_iterator<CvHomelandTarget>::_Temp_iterator<CvHomelandTarget>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@H@Z ENDP ; std::_Temp_iterator<CvHomelandTarget>::_Temp_iterator<CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@H@Z ; std::_Temp_iterator<CvHomelandUnit>::_Temp_iterator<CvHomelandUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@H@Z PROC	; std::_Temp_iterator<CvHomelandUnit>::_Temp_iterator<CvHomelandUnit>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@H@Z ENDP	; std::_Temp_iterator<CvHomelandUnit>::_Temp_iterator<CvHomelandUnit>
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getNumFlavorTypes@CvGlobals@@QAEHXZ		; CvGlobals::getNumFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getNumFlavorTypes@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumFlavorTypes@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumFlavorTypes, COMDAT
; _this$ = ecx

; 804  : 		return m_iNumFlavorTypes;

	mov	eax, DWORD PTR [ecx+1764]

; 805  : 	}

	ret	0
?getNumFlavorTypes@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumFlavorTypes
_TEXT	ENDS
PUBLIC	?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z ; CvGlobals::getFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z PROC ; CvGlobals::getFlavorTypes, COMDAT
; _this$ = ecx

; 812  : 		CvAssert(e > -1); /*CvAssert(e < GC.getNumFlavorTypes())*/;
; 813  : 		return m_paszFlavorTypes[e];

	mov	eax, DWORD PTR _e$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+1760]
	lea	eax, DWORD PTR [eax+edx*4]

; 814  : 	}

	ret	4
?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z ENDP ; CvGlobals::getFlavorTypes
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-20]
	sub	ecx, 20					; 00000014H
	sub	eax, 20					; 00000014H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@2

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@2:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@3

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@3:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvHomelandTarget@@V1@@std@@YAXPAVCvHomelandTarget@@ABV1@@Z ; std::_Construct<CvHomelandTarget,CvHomelandTarget>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Construct@VCvHomelandTarget@@V1@@std@@YAXPAVCvHomelandTarget@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvHomelandTarget@@V1@@std@@YAXPAVCvHomelandTarget@@ABV1@@Z PROC ; std::_Construct<CvHomelandTarget,CvHomelandTarget>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx
$LN3@Construct@3:

; 53   : 	}

	ret	0
??$_Construct@VCvHomelandTarget@@V1@@std@@YAXPAVCvHomelandTarget@@ABV1@@Z ENDP ; std::_Construct<CvHomelandTarget,CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvHomelandTarget@@@std@@YAXPAVCvHomelandTarget@@@Z ; std::_Destroy<CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvHomelandTarget@@@std@@YAXPAVCvHomelandTarget@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvHomelandTarget@@@std@@YAXPAVCvHomelandTarget@@@Z PROC ; std::_Destroy<CvHomelandTarget>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvHomelandTarget@@@std@@YAXPAVCvHomelandTarget@@@Z ENDP ; std::_Destroy<CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@@Z ; std::_Destroy<CvHomelandMove>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@@Z PROC ; std::_Destroy<CvHomelandMove>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@@Z ENDP ; std::_Destroy<CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@VCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@@Z ; std::return_temporary_buffer<CvHomelandMove>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$return_temporary_buffer@VCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@VCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@@Z PROC ; std::return_temporary_buffer<CvHomelandMove>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@VCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@@Z ENDP ; std::return_temporary_buffer<CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@VCvHomelandTarget@@@std@@YAXPAVCvHomelandTarget@@@Z ; std::return_temporary_buffer<CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$return_temporary_buffer@VCvHomelandTarget@@@std@@YAXPAVCvHomelandTarget@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@VCvHomelandTarget@@@std@@YAXPAVCvHomelandTarget@@@Z PROC ; std::return_temporary_buffer<CvHomelandTarget>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@VCvHomelandTarget@@@std@@YAXPAVCvHomelandTarget@@@Z ENDP ; std::return_temporary_buffer<CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@@Z ; std::_Destroy<CvHomelandUnit>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy@VCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@@Z PROC ; std::_Destroy<CvHomelandUnit>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@@Z ENDP ; std::_Destroy<CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@VCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@@Z ; std::return_temporary_buffer<CvHomelandUnit>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$return_temporary_buffer@VCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@VCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@@Z PROC ; std::return_temporary_buffer<CvHomelandUnit>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@VCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@@Z ENDP ; std::return_temporary_buffer<CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QBE_NABU01@@Z ; CvWeightedVector<CvPlot *,100,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??MWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<CvPlot *,100,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<CvPlot *,100,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QBE_NABU01@@Z ; CvWeightedVector<CvCity *,64,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<CvCity *,64,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<CvCity *,64,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	?getAI_GOLD_PRIORITY_UPGRADE_BASE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GOLD_PRIORITY_UPGRADE_BASE
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getAI_GOLD_PRIORITY_UPGRADE_BASE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GOLD_PRIORITY_UPGRADE_BASE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GOLD_PRIORITY_UPGRADE_BASE, COMDAT
; _this$ = ecx

; 1141 : 		return m_iAI_GOLD_PRIORITY_UPGRADE_BASE;

	mov	eax, DWORD PTR [ecx+2076]

; 1142 : 	}

	ret	0
?getAI_GOLD_PRIORITY_UPGRADE_BASE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GOLD_PRIORITY_UPGRADE_BASE
_TEXT	ENDS
PUBLIC	??0?$pair@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@QAE@ABQAU?$pair@HPAVCvPlot@@@1@0@Z ; std::pair<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>::pair<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??0?$pair@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@QAE@ABQAU?$pair@HPAVCvPlot@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@QAE@ABQAU?$pair@HPAVCvPlot@@@1@0@Z PROC ; std::pair<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>::pair<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@QAE@ABQAU?$pair@HPAVCvPlot@@@1@0@Z ENDP ; std::pair<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>::pair<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>
_TEXT	ENDS
PUBLIC	?getAI_GOLD_PRIORITY_UPGRADE_PER_FLAVOR_POINT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_GOLD_PRIORITY_UPGRADE_PER_FLAVOR_POINT
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getAI_GOLD_PRIORITY_UPGRADE_PER_FLAVOR_POINT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_GOLD_PRIORITY_UPGRADE_PER_FLAVOR_POINT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_GOLD_PRIORITY_UPGRADE_PER_FLAVOR_POINT, COMDAT
; _this$ = ecx

; 1145 : 		return m_iAI_GOLD_PRIORITY_UPGRADE_PER_FLAVOR_POINT;

	mov	eax, DWORD PTR [ecx+2080]

; 1146 : 	}

	ret	0
?getAI_GOLD_PRIORITY_UPGRADE_PER_FLAVOR_POINT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_GOLD_PRIORITY_UPGRADE_PER_FLAVOR_POINT
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::pair<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>::pair<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z PROC ; std::pair<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>::pair<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ENDP ; std::pair<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>::pair<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::pair<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>::pair<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z PROC ; std::pair<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>::pair<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ENDP ; std::pair<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>::pair<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAU?$pair@HPAVCvPlot@@@std@@@std@@YAPAHPAU?$pair@HPAVCvPlot@@@0@@Z ; std::_Dist_type<std::pair<int,CvPlot *> *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Dist_type@PAU?$pair@HPAVCvPlot@@@std@@@std@@YAPAHPAU?$pair@HPAVCvPlot@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAU?$pair@HPAVCvPlot@@@std@@@std@@YAPAHPAU?$pair@HPAVCvPlot@@@0@@Z PROC ; std::_Dist_type<std::pair<int,CvPlot *> *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAU?$pair@HPAVCvPlot@@@std@@@std@@YAPAHPAU?$pair@HPAVCvPlot@@@0@@Z ENDP ; std::_Dist_type<std::pair<int,CvPlot *> *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAU?$pair@HPAVCvPlot@@@std@@@std@@YAPAU?$pair@HPAVCvPlot@@@0@PAU10@@Z ; std::_Val_type<std::pair<int,CvPlot *> *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAU?$pair@HPAVCvPlot@@@std@@@std@@YAPAU?$pair@HPAVCvPlot@@@0@PAU10@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAU?$pair@HPAVCvPlot@@@std@@@std@@YAPAU?$pair@HPAVCvPlot@@@0@PAU10@@Z PROC ; std::_Val_type<std::pair<int,CvPlot *> *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAU?$pair@HPAVCvPlot@@@std@@@std@@YAPAU?$pair@HPAVCvPlot@@@0@PAU10@@Z ENDP ; std::_Val_type<std::pair<int,CvPlot *> *>
_TEXT	ENDS
PUBLIC	?getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL@CvGlobals@@QAEHXZ ; CvGlobals::getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL, COMDAT
; _this$ = ecx

; 1253 : 		return m_iAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL;

	mov	eax, DWORD PTR [ecx+2188]

; 1254 : 	}

	ret	0
?getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAVCvHomelandMove@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandMove@@@Z ; std::_Iter_cat<CvHomelandMove *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAVCvHomelandMove@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandMove@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAVCvHomelandMove@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandMove@@@Z PROC ; std::_Iter_cat<CvHomelandMove *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAVCvHomelandMove@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandMove@@@Z ENDP ; std::_Iter_cat<CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$_Distance2@PAVCvHomelandMove@@H@std@@YAXPAVCvHomelandMove@@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<CvHomelandMove *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Distance2@PAVCvHomelandMove@@H@std@@YAXPAVCvHomelandMove@@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PAVCvHomelandMove@@H@std@@YAXPAVCvHomelandMove@@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<CvHomelandMove *,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 3
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@PAVCvHomelandMove@@H@std@@YAXPAVCvHomelandMove@@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<CvHomelandMove *,int>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAVCvHomelandUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandUnit@@@Z ; std::_Iter_cat<CvHomelandUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAVCvHomelandUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandUnit@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAVCvHomelandUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandUnit@@@Z PROC ; std::_Iter_cat<CvHomelandUnit *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAVCvHomelandUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandUnit@@@Z ENDP ; std::_Iter_cat<CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	??$_Distance2@PAVCvHomelandUnit@@H@std@@YAXPAVCvHomelandUnit@@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<CvHomelandUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Distance2@PAVCvHomelandUnit@@H@std@@YAXPAVCvHomelandUnit@@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PAVCvHomelandUnit@@H@std@@YAXPAVCvHomelandUnit@@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<CvHomelandUnit *,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 4
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@PAVCvHomelandUnit@@H@std@@YAXPAVCvHomelandUnit@@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<CvHomelandUnit *,int>
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_RANDOMNESS@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_RANDOMNESS
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_RANDOMNESS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_RANDOMNESS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_RANDOMNESS, COMDAT
; _this$ = ecx

; 1625 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_RANDOMNESS;

	mov	eax, DWORD PTR [ecx+2560]

; 1626 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_RANDOMNESS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_RANDOMNESS
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MAX_UPGRADE_MOVE_TURNS@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MAX_UPGRADE_MOVE_TURNS
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MAX_UPGRADE_MOVE_TURNS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MAX_UPGRADE_MOVE_TURNS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MAX_UPGRADE_MOVE_TURNS, COMDAT
; _this$ = ecx

; 1629 : 		return m_iAI_HOMELAND_MAX_UPGRADE_MOVE_TURNS;

	mov	eax, DWORD PTR [ecx+2564]

; 1630 : 	}

	ret	0
?getAI_HOMELAND_MAX_UPGRADE_MOVE_TURNS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MAX_UPGRADE_MOVE_TURNS
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MAX_DEFENSIVE_MOVE_TURNS@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MAX_DEFENSIVE_MOVE_TURNS
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MAX_DEFENSIVE_MOVE_TURNS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MAX_DEFENSIVE_MOVE_TURNS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MAX_DEFENSIVE_MOVE_TURNS, COMDAT
; _this$ = ecx

; 1633 : 		return m_iAI_HOMELAND_MAX_DEFENSIVE_MOVE_TURNS;

	mov	eax, DWORD PTR [ecx+2568]

; 1634 : 	}

	ret	0
?getAI_HOMELAND_MAX_DEFENSIVE_MOVE_TURNS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MAX_DEFENSIVE_MOVE_TURNS
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE, COMDAT
; _this$ = ecx

; 1637 : 		return m_iAI_HOMELAND_ESTIMATE_TURNS_DISTANCE;

	mov	eax, DWORD PTR [ecx+2572]

; 1638 : 	}

	ret	0
?getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_SETTLE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_SETTLE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_SETTLE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_SETTLE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_SETTLE, COMDAT
; _this$ = ecx

; 1641 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_SETTLE;

	mov	eax, DWORD PTR [ecx+2576]

; 1642 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_SETTLE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_SETTLE
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_HEAL@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_HEAL
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_HEAL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_HEAL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_HEAL, COMDAT
; _this$ = ecx

; 1645 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_HEAL;

	mov	eax, DWORD PTR [ecx+2580]

; 1646 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_HEAL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_HEAL
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_TO_SAFETY@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_TO_SAFETY
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_TO_SAFETY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_TO_SAFETY@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_TO_SAFETY, COMDAT
; _this$ = ecx

; 1649 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_TO_SAFETY;

	mov	eax, DWORD PTR [ecx+2584]

; 1650 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_TO_SAFETY@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_TO_SAFETY
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_WORKER@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_WORKER
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_WORKER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_WORKER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_WORKER, COMDAT
; _this$ = ecx

; 1653 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_WORKER;

	mov	eax, DWORD PTR [ecx+2588]

; 1654 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_WORKER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_WORKER
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_WORKER_SEA@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_WORKER_SEA
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_WORKER_SEA@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_WORKER_SEA@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_WORKER_SEA, COMDAT
; _this$ = ecx

; 1657 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_WORKER_SEA;

	mov	eax, DWORD PTR [ecx+2592]

; 1658 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_WORKER_SEA@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_WORKER_SEA
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_EXPLORE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_EXPLORE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_EXPLORE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_EXPLORE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_EXPLORE, COMDAT
; _this$ = ecx

; 1661 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_EXPLORE;

	mov	eax, DWORD PTR [ecx+2596]

; 1662 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_EXPLORE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_EXPLORE
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_EXPLORE_SEA@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_EXPLORE_SEA
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_EXPLORE_SEA@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_EXPLORE_SEA@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_EXPLORE_SEA, COMDAT
; _this$ = ecx

; 1665 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_EXPLORE_SEA;

	mov	eax, DWORD PTR [ecx+2600]

; 1666 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_EXPLORE_SEA@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_EXPLORE_SEA
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_SENTRY@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_SENTRY
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_SENTRY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_SENTRY@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_SENTRY, COMDAT
; _this$ = ecx

; 1669 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_SENTRY;

	mov	eax, DWORD PTR [ecx+2604]

; 1670 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_SENTRY@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_SENTRY
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_MOBILE_RESERVE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_MOBILE_RESERVE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_MOBILE_RESERVE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_MOBILE_RESERVE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_MOBILE_RESERVE, COMDAT
; _this$ = ecx

; 1673 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_MOBILE_RESERVE;

	mov	eax, DWORD PTR [ecx+2608]

; 1674 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_MOBILE_RESERVE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_MOBILE_RESERVE
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_GARRISON@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_GARRISON
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_GARRISON@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_GARRISON@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_GARRISON, COMDAT
; _this$ = ecx

; 1677 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_GARRISON;

	mov	eax, DWORD PTR [ecx+2612]

; 1678 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_GARRISON@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_GARRISON
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_PATROL@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_PATROL
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_PATROL@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_PATROL@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_PATROL, COMDAT
; _this$ = ecx

; 1681 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_PATROL;

	mov	eax, DWORD PTR [ecx+2616]

; 1682 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_PATROL@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_PATROL
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_UPGRADE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_UPGRADE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_UPGRADE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_UPGRADE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_UPGRADE, COMDAT
; _this$ = ecx

; 1685 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_UPGRADE;

	mov	eax, DWORD PTR [ecx+2620]

; 1686 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_UPGRADE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_UPGRADE
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_ANCIENT_RUINS@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ANCIENT_RUINS
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_ANCIENT_RUINS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_ANCIENT_RUINS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ANCIENT_RUINS, COMDAT
; _this$ = ecx

; 1689 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_ANCIENT_RUINS;

	mov	eax, DWORD PTR [ecx+2624]

; 1690 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_ANCIENT_RUINS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ANCIENT_RUINS
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_GARRISON_CITY_STATE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_GARRISON_CITY_STATE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_GARRISON_CITY_STATE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_GARRISON_CITY_STATE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_GARRISON_CITY_STATE, COMDAT
; _this$ = ecx

; 1693 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_GARRISON_CITY_STATE;

	mov	eax, DWORD PTR [ecx+2628]

; 1694 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_GARRISON_CITY_STATE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_GARRISON_CITY_STATE
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_WRITER@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_WRITER
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_WRITER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_WRITER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_WRITER, COMDAT
; _this$ = ecx

; 1697 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_WRITER;

	mov	eax, DWORD PTR [ecx+2632]

; 1698 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_WRITER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_WRITER
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_ARTIST@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ARTIST
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_ARTIST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_ARTIST@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ARTIST, COMDAT
; _this$ = ecx

; 1701 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_ARTIST;

	mov	eax, DWORD PTR [ecx+2636]

; 1702 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_ARTIST@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ARTIST
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_MUSICIAN@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_MUSICIAN
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_MUSICIAN@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_MUSICIAN@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_MUSICIAN, COMDAT
; _this$ = ecx

; 1705 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_MUSICIAN;

	mov	eax, DWORD PTR [ecx+2640]

; 1706 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_MUSICIAN@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_MUSICIAN
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_SCIENTIST_FREE_TECH@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_SCIENTIST_FREE_TECH
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_SCIENTIST_FREE_TECH@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_SCIENTIST_FREE_TECH@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_SCIENTIST_FREE_TECH, COMDAT
; _this$ = ecx

; 1709 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_SCIENTIST_FREE_TECH;

	mov	eax, DWORD PTR [ecx+2644]

; 1710 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_SCIENTIST_FREE_TECH@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_SCIENTIST_FREE_TECH
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_ENGINEER_HURRY@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ENGINEER_HURRY
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_ENGINEER_HURRY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_ENGINEER_HURRY@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ENGINEER_HURRY, COMDAT
; _this$ = ecx

; 1713 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_ENGINEER_HURRY;

	mov	eax, DWORD PTR [ecx+2648]

; 1714 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_ENGINEER_HURRY@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ENGINEER_HURRY
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_GENERAL_GARRISON@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_GENERAL_GARRISON
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_GENERAL_GARRISON@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_GENERAL_GARRISON@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_GENERAL_GARRISON, COMDAT
; _this$ = ecx

; 1717 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_GENERAL_GARRISON;

	mov	eax, DWORD PTR [ecx+2652]

; 1718 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_GENERAL_GARRISON@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_GENERAL_GARRISON
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_ADMIRAL_GARRISON@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ADMIRAL_GARRISON
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_ADMIRAL_GARRISON@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_ADMIRAL_GARRISON@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ADMIRAL_GARRISON, COMDAT
; _this$ = ecx

; 1721 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_ADMIRAL_GARRISON;

	mov	eax, DWORD PTR [ecx+2656]

; 1722 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_ADMIRAL_GARRISON@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ADMIRAL_GARRISON
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_PROPHET_RELIGION@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_PROPHET_RELIGION
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_PROPHET_RELIGION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_PROPHET_RELIGION@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_PROPHET_RELIGION, COMDAT
; _this$ = ecx

; 1725 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_PROPHET_RELIGION;

	mov	eax, DWORD PTR [ecx+2660]

; 1726 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_PROPHET_RELIGION@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_PROPHET_RELIGION
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_MISSIONARY@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_MISSIONARY
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_MISSIONARY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_MISSIONARY@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_MISSIONARY, COMDAT
; _this$ = ecx

; 1729 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_MISSIONARY;

	mov	eax, DWORD PTR [ecx+2664]

; 1730 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_MISSIONARY@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_MISSIONARY
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_INQUISITOR@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_INQUISITOR
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_INQUISITOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_INQUISITOR@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_INQUISITOR, COMDAT
; _this$ = ecx

; 1733 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_INQUISITOR;

	mov	eax, DWORD PTR [ecx+2668]

; 1734 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_INQUISITOR@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_INQUISITOR
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_SPACESHIP_PART@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_SPACESHIP_PART
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_SPACESHIP_PART@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_SPACESHIP_PART@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_SPACESHIP_PART, COMDAT
; _this$ = ecx

; 1737 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_SPACESHIP_PART;

	mov	eax, DWORD PTR [ecx+2672]

; 1738 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_SPACESHIP_PART@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_SPACESHIP_PART
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_ADD_SPACESHIP_PART@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ADD_SPACESHIP_PART
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_ADD_SPACESHIP_PART@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_ADD_SPACESHIP_PART@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ADD_SPACESHIP_PART, COMDAT
; _this$ = ecx

; 1741 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_ADD_SPACESHIP_PART;

	mov	eax, DWORD PTR [ecx+2676]

; 1742 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_ADD_SPACESHIP_PART@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ADD_SPACESHIP_PART
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_AIRCRAFT_TO_THE_FRONT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_AIRCRAFT_TO_THE_FRONT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_AIRCRAFT_TO_THE_FRONT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_AIRCRAFT_TO_THE_FRONT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_AIRCRAFT_TO_THE_FRONT, COMDAT
; _this$ = ecx

; 1745 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_AIRCRAFT_TO_THE_FRONT;

	mov	eax, DWORD PTR [ecx+2680]

; 1746 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_AIRCRAFT_TO_THE_FRONT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_AIRCRAFT_TO_THE_FRONT
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_TREASURE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_TREASURE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_TREASURE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_TREASURE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_TREASURE, COMDAT
; _this$ = ecx

; 1749 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_TREASURE;

	mov	eax, DWORD PTR [ecx+2684]

; 1750 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_TREASURE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_TREASURE
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_TRADE_UNIT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_TRADE_UNIT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_TRADE_UNIT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_TRADE_UNIT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_TRADE_UNIT, COMDAT
; _this$ = ecx

; 1753 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_TRADE_UNIT;

	mov	eax, DWORD PTR [ecx+2688]

; 1754 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_TRADE_UNIT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_TRADE_UNIT
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_ARCHAEOLOGIST@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ARCHAEOLOGIST
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_ARCHAEOLOGIST@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_ARCHAEOLOGIST@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ARCHAEOLOGIST, COMDAT
; _this$ = ecx

; 1757 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_ARCHAEOLOGIST;

	mov	eax, DWORD PTR [ecx+2692]

; 1758 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_ARCHAEOLOGIST@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_ARCHAEOLOGIST
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_MOVE_PRIORITY_AIRLIFT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_AIRLIFT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_MOVE_PRIORITY_AIRLIFT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_MOVE_PRIORITY_AIRLIFT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_AIRLIFT, COMDAT
; _this$ = ecx

; 1761 : 		return m_iAI_HOMELAND_MOVE_PRIORITY_AIRLIFT;

	mov	eax, DWORD PTR [ecx+2696]

; 1762 : 	}

	ret	0
?getAI_HOMELAND_MOVE_PRIORITY_AIRLIFT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_MOVE_PRIORITY_AIRLIFT
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z ; std::_Dist_type<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@Z ; std::_Dist_type<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAPAVCvPlot@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@@Z ; std::_Iter_cat<CvPlot * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAPAVCvPlot@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVCvPlot@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@@Z PROC ; std::_Iter_cat<CvPlot * *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAPAVCvPlot@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPlot@@@Z ENDP ; std::_Iter_cat<CvPlot * *>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z ; std::_Iter_cat<CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z PROC ; std::_Iter_cat<CvCity * *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAPAVCvCity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvCity@@@Z ENDP ; std::_Iter_cat<CvCity * *>
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@1@@Z ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator-
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@1@@Z PROC ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator-, COMDAT
; _this$ = ecx

; 398  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 399  : 		}

	ret	4
??G?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@1@@Z ENDP ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator-
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<CvHomelandMove>::_Init
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ?_Init@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<CvHomelandMove>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<CvHomelandMove>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@VCvHomelandMove@@@std@@QBEPAVCvHomelandMove@@XZ ; std::_Temp_iterator<CvHomelandMove>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@VCvHomelandMove@@@std@@QBEPAVCvHomelandMove@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@VCvHomelandMove@@@std@@QBEPAVCvHomelandMove@@XZ PROC ; std::_Temp_iterator<CvHomelandMove>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@VCvHomelandMove@@@std@@QBEPAVCvHomelandMove@@XZ ENDP ; std::_Temp_iterator<CvHomelandMove>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@VCvHomelandMove@@@std@@QBEPAVCvHomelandMove@@XZ ; std::_Temp_iterator<CvHomelandMove>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@VCvHomelandMove@@@std@@QBEPAVCvHomelandMove@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@VCvHomelandMove@@@std@@QBEPAVCvHomelandMove@@XZ PROC ; std::_Temp_iterator<CvHomelandMove>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@VCvHomelandMove@@@std@@QBEPAVCvHomelandMove@@XZ ENDP ; std::_Temp_iterator<CvHomelandMove>::_Last
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<CvHomelandTarget>::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<CvHomelandTarget>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<CvHomelandTarget>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@VCvHomelandTarget@@@std@@QBEPAVCvHomelandTarget@@XZ ; std::_Temp_iterator<CvHomelandTarget>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@VCvHomelandTarget@@@std@@QBEPAVCvHomelandTarget@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@VCvHomelandTarget@@@std@@QBEPAVCvHomelandTarget@@XZ PROC ; std::_Temp_iterator<CvHomelandTarget>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@VCvHomelandTarget@@@std@@QBEPAVCvHomelandTarget@@XZ ENDP ; std::_Temp_iterator<CvHomelandTarget>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@VCvHomelandTarget@@@std@@QBEPAVCvHomelandTarget@@XZ ; std::_Temp_iterator<CvHomelandTarget>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@VCvHomelandTarget@@@std@@QBEPAVCvHomelandTarget@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@VCvHomelandTarget@@@std@@QBEPAVCvHomelandTarget@@XZ PROC ; std::_Temp_iterator<CvHomelandTarget>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@VCvHomelandTarget@@@std@@QBEPAVCvHomelandTarget@@XZ ENDP ; std::_Temp_iterator<CvHomelandTarget>::_Last
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<CvHomelandUnit>::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<CvHomelandUnit>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<CvHomelandUnit>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@VCvHomelandUnit@@@std@@QBEPAVCvHomelandUnit@@XZ ; std::_Temp_iterator<CvHomelandUnit>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@VCvHomelandUnit@@@std@@QBEPAVCvHomelandUnit@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@VCvHomelandUnit@@@std@@QBEPAVCvHomelandUnit@@XZ PROC ; std::_Temp_iterator<CvHomelandUnit>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@VCvHomelandUnit@@@std@@QBEPAVCvHomelandUnit@@XZ ENDP ; std::_Temp_iterator<CvHomelandUnit>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@VCvHomelandUnit@@@std@@QBEPAVCvHomelandUnit@@XZ ; std::_Temp_iterator<CvHomelandUnit>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@VCvHomelandUnit@@@std@@QBEPAVCvHomelandUnit@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@VCvHomelandUnit@@@std@@QBEPAVCvHomelandUnit@@XZ PROC ; std::_Temp_iterator<CvHomelandUnit>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@VCvHomelandUnit@@@std@@QBEPAVCvHomelandUnit@@XZ ENDP ; std::_Temp_iterator<CvHomelandUnit>::_Last
_TEXT	ENDS
PUBLIC	??0?$pair@PAVCvHomelandMove@@H@std@@QAE@ABQAVCvHomelandMove@@ABH@Z ; std::pair<CvHomelandMove *,int>::pair<CvHomelandMove *,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??0?$pair@PAVCvHomelandMove@@H@std@@QAE@ABQAVCvHomelandMove@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAVCvHomelandMove@@H@std@@QAE@ABQAVCvHomelandMove@@ABH@Z PROC ; std::pair<CvHomelandMove *,int>::pair<CvHomelandMove *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAVCvHomelandMove@@H@std@@QAE@ABQAVCvHomelandMove@@ABH@Z ENDP ; std::pair<CvHomelandMove *,int>::pair<CvHomelandMove *,int>
_TEXT	ENDS
PUBLIC	??0?$pair@PAVCvHomelandTarget@@H@std@@QAE@ABQAVCvHomelandTarget@@ABH@Z ; std::pair<CvHomelandTarget *,int>::pair<CvHomelandTarget *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@PAVCvHomelandTarget@@H@std@@QAE@ABQAVCvHomelandTarget@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAVCvHomelandTarget@@H@std@@QAE@ABQAVCvHomelandTarget@@ABH@Z PROC ; std::pair<CvHomelandTarget *,int>::pair<CvHomelandTarget *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAVCvHomelandTarget@@H@std@@QAE@ABQAVCvHomelandTarget@@ABH@Z ENDP ; std::pair<CvHomelandTarget *,int>::pair<CvHomelandTarget *,int>
_TEXT	ENDS
PUBLIC	??0?$pair@PAVCvHomelandUnit@@H@std@@QAE@ABQAVCvHomelandUnit@@ABH@Z ; std::pair<CvHomelandUnit *,int>::pair<CvHomelandUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$pair@PAVCvHomelandUnit@@H@std@@QAE@ABQAVCvHomelandUnit@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAVCvHomelandUnit@@H@std@@QAE@ABQAVCvHomelandUnit@@ABH@Z PROC ; std::pair<CvHomelandUnit *,int>::pair<CvHomelandUnit *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAVCvHomelandUnit@@H@std@@QAE@ABQAVCvHomelandUnit@@ABH@Z ENDP ; std::pair<CvHomelandUnit *,int>::pair<CvHomelandUnit *,int>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<CvHomelandMove>::operator=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<CvHomelandMove>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<CvHomelandMove>::operator=
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<CvHomelandTarget>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<CvHomelandTarget>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<CvHomelandTarget>::operator=
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<CvHomelandUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<CvHomelandUnit>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<CvHomelandUnit>::operator=
_TEXT	ENDS
PUBLIC	??$_Advance@PAVCvHomelandMove@@H@std@@YAXAAPAVCvHomelandMove@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CvHomelandMove *,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Advance@PAVCvHomelandMove@@H@std@@YAXAAPAVCvHomelandMove@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAVCvHomelandMove@@H@std@@YAXAAPAVCvHomelandMove@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CvHomelandMove *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAVCvHomelandMove@@H@std@@YAXAAPAVCvHomelandMove@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CvHomelandMove *,int>
_TEXT	ENDS
PUBLIC	??$_Advance@PAVCvHomelandUnit@@H@std@@YAXAAPAVCvHomelandUnit@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CvHomelandUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Advance@PAVCvHomelandUnit@@H@std@@YAXAAPAVCvHomelandUnit@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAVCvHomelandUnit@@H@std@@YAXAAPAVCvHomelandUnit@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CvHomelandUnit *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR __Where$[esp-4]
	shl	ecx, 4
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAVCvHomelandUnit@@H@std@@YAXAAPAVCvHomelandUnit@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CvHomelandUnit *,int>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::swap<CvWeightedVector<CvPlot *,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z PROC ; std::swap<CvWeightedVector<CvPlot *,100,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ENDP ; std::swap<CvWeightedVector<CvPlot *,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::swap<CvWeightedVector<CvCity *,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z PROC ; std::swap<CvWeightedVector<CvCity *,64,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@2:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ENDP ; std::swap<CvWeightedVector<CvCity *,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCvPlot@@IPAV1@@std@@YAXPAPAVCvPlot@@IABQAV1@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVCvPlot@@IPAV1@@std@@YAXPAPAVCvPlot@@IABQAV1@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVCvPlot@@IPAV1@@std@@YAXPAPAVCvPlot@@IABQAV1@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAPAVCvPlot@@IPAV1@@std@@YAXPAPAVCvPlot@@IABQAV1@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<CvCity * *,unsigned int,CvCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<CvCity * *,unsigned int,CvCity *>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n@2:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@2
	pop	esi
$LN1@Fill_n@2:

; 3199 : 	}

	ret	0
??$_Fill_n@PAPAVCvCity@@IPAV1@@std@@YAXPAPAVCvCity@@IABQAV1@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<CvCity * *,unsigned int,CvCity *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop@2:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??F?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator--
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??F?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator--, COMDAT
; _this$ = ecx

; 137  : 		{	// predecrement

	mov	eax, ecx

; 138  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 139  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr > ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 140  : 
; 141  :  #if _HAS_ITERATOR_DEBUGGING
; 142  : 		if (this->_Mycont == 0
; 143  : 			|| _Myptr == ((_Myvec *)this->_Mycont)->_Myfirst)
; 144  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 145  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 146  : 
; 147  : 		--_Myptr;

	add	DWORD PTR [eax], -20			; ffffffecH

; 148  : 		return (*this);
; 149  : 		}

	ret	0
??F?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator--
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z ; std::_Push_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
__Pred$ = 28						; size = 4
??$_Push_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z PROC ; std::_Push_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 2013 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

	push	ebp

; 2014 : 	for (_Diff _Idx = (_Hole - 1) / 2;
; 2015 : 		_Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val);
; 2016 : 		_Idx = (_Hole - 1) / 2)

	mov	ebp, DWORD PTR __First$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Hole$[esp+8]
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	cmp	DWORD PTR __Top$[esp+8], edi
	jge	SHORT $LN1@Push_heap
	push	ebx
	npad	4
$LL3@Push_heap:
	lea	eax, DWORD PTR __Val$[esp+12]
	push	eax
	lea	ebx, DWORD PTR [ebp+esi*8]
	push	ebx
	call	DWORD PTR __Pred$[esp+20]
	add	esp, 8
	test	al, al
	je	SHORT $LN8@Push_heap

; 2017 : 		{	// move _Hole up to parent
; 2018 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [ebp+edi*8], ecx
	mov	edx, DWORD PTR [ebx+4]
	lea	eax, DWORD PTR [esi-1]
	mov	DWORD PTR [ebp+edi*8+4], edx
	cdq
	sub	eax, edx

; 2019 : 		_Hole = _Idx;

	mov	edi, esi
	sar	eax, 1
	cmp	DWORD PTR __Top$[esp+12], edi
	mov	esi, eax
	jl	SHORT $LL3@Push_heap
$LN8@Push_heap:
	pop	ebx
$LN1@Push_heap:

; 2020 : 		}
; 2021 : 
; 2022 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	mov	ecx, DWORD PTR __Val$[esp+12]
	mov	DWORD PTR [ebp+edi*8], eax
	mov	DWORD PTR [ebp+edi*8+4], ecx
	pop	edi
	pop	esi
	pop	ebp

; 2023 : 	}

	ret	0
??$_Push_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z ENDP ; std::_Push_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@HPAVCvPlot@@@0@0@Z ; std::_Iter_random<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@HPAVCvPlot@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@HPAVCvPlot@@@0@0@Z PROC ; std::_Iter_random<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@HPAVCvPlot@@@0@0@Z ENDP ; std::_Iter_random<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@HPAVCvPlot@@@0@0@Z ; std::_Ptr_cat<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@HPAVCvPlot@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@HPAVCvPlot@@@0@0@Z PROC ; std::_Ptr_cat<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@HPAVCvPlot@@@0@0@Z ENDP ; std::_Ptr_cat<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAU?$pair@HPAVCvPlot@@@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@HPAVCvPlot@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAU?$pair@HPAVCvPlot@@@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@HPAVCvPlot@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAU?$pair@HPAVCvPlot@@@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@HPAVCvPlot@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@4
	push	esi
$LL2@Copy_backw@4:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@4
	pop	esi
$LN1@Copy_backw@4:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAU?$pair@HPAVCvPlot@@@std@@PAU12@Urandom_access_iterator_tag@2@@std@@YAPAU?$pair@HPAVCvPlot@@@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$swap@VCvHomelandMove@@@std@@YAXAAVCvHomelandMove@@0@Z ; std::swap<CvHomelandMove>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$swap@VCvHomelandMove@@@std@@YAXAAVCvHomelandMove@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvHomelandMove@@@std@@YAXAAVCvHomelandMove@@0@Z PROC ; std::swap<CvHomelandMove>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@3

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@3:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@VCvHomelandMove@@@std@@YAXAAVCvHomelandMove@@0@Z ENDP ; std::swap<CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandMove@@ABV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Iter_random<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandMove@@ABV?$_Temp_iterator@VCvHomelandMove@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandMove@@ABV?$_Temp_iterator@VCvHomelandMove@@@0@@Z PROC ; std::_Iter_random<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandMove@@ABV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ENDP ; std::_Iter_random<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandMove@@AAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Ptr_cat<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandMove@@AAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandMove@@AAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z PROC ; std::_Ptr_cat<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandMove@@AAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ENDP ; std::_Ptr_cat<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvHomelandMove@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandMove@@00@Z ; std::_Iter_random<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvHomelandMove@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandMove@@00@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvHomelandMove@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandMove@@00@Z PROC ; std::_Iter_random<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvHomelandMove@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandMove@@00@Z ENDP ; std::_Iter_random<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$swap@VCvHomelandTarget@@@std@@YAXAAVCvHomelandTarget@@0@Z ; std::swap<CvHomelandTarget>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$swap@VCvHomelandTarget@@@std@@YAXAAVCvHomelandTarget@@0@Z
_TEXT	SEGMENT
__Tmp$235610 = -20					; size = 20
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvHomelandTarget@@@std@@YAXAAVCvHomelandTarget@@0@Z PROC ; std::swap<CvHomelandTarget>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	eax, ecx
	je	SHORT $LN1@swap@4

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR [eax+12]
	push	ebp
	mov	ebp, DWORD PTR [eax+16]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$235610[esp+48], ebp

; 21   : 
; 22   : 		_Left = _Right;

	mov	ebp, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp
	mov	ebp, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ebp

; 23   : 		_Right = _Tmp;

	mov	eax, DWORD PTR __Tmp$235610[esp+52]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+12], ebx
	pop	ebp
	mov	DWORD PTR [ecx+16], eax
	pop	ebx
$LN1@swap@4:

; 24   : 		}
; 25   : 	}

	add	esp, 20					; 00000014H
	ret	0
??$swap@VCvHomelandTarget@@@std@@YAXAAVCvHomelandTarget@@0@Z ENDP ; std::swap<CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@ABV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Iter_random<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@ABV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@ABV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z PROC ; std::_Iter_random<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@ABV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@AAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Ptr_cat<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@AAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@AAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@AAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@1@Z ; std::_Iter_random<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@1@Z PROC ; std::_Iter_random<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@1@Z ENDP ; std::_Iter_random<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$swap@VCvHomelandUnit@@@std@@YAXAAVCvHomelandUnit@@0@Z ; std::swap<CvHomelandUnit>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$swap@VCvHomelandUnit@@@std@@YAXAAVCvHomelandUnit@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvHomelandUnit@@@std@@YAXAAVCvHomelandUnit@@0@Z PROC ; std::swap<CvHomelandUnit>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@5

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR [eax+12]
	push	ebp

; 21   : 
; 22   : 		_Left = _Right;

	mov	ebp, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+12], ebx
	pop	ebx
$LN1@swap@5:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@VCvHomelandUnit@@@std@@YAXAAVCvHomelandUnit@@0@Z ENDP ; std::swap<CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandUnit@@ABV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Iter_random<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandUnit@@ABV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandUnit@@ABV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z PROC ; std::_Iter_random<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandUnit@@ABV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ENDP ; std::_Iter_random<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandUnit@@AAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Ptr_cat<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandUnit@@AAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandUnit@@AAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z PROC ; std::_Ptr_cat<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandUnit@@AAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ENDP ; std::_Ptr_cat<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvHomelandUnit@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandUnit@@00@Z ; std::_Iter_random<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvHomelandUnit@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandUnit@@00@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvHomelandUnit@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandUnit@@00@Z PROC ; std::_Iter_random<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvHomelandUnit@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandUnit@@00@Z ENDP ; std::_Iter_random<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap@2
	npad	1
$LL3@Push_heap@2:
	cmp	DWORD PTR [esi+eax*8+4], ebx
	jle	SHORT $LN1@Push_heap@2

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	edx, DWORD PTR [esi+eax*8+4]
	mov	DWORD PTR [esi+ecx*8+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap@2
$LN1@Push_heap@2:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [esi+ecx*8+4], ebx
	mov	DWORD PTR [esi+ecx*8], eax
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::_Iter_random<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@5
	push	esi
$LL2@Copy_backw@5:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@5
	pop	esi
$LN1@Copy_backw@5:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap@3
	npad	1
$LL3@Push_heap@3:
	cmp	DWORD PTR [esi+eax*8+4], ebx
	jle	SHORT $LN1@Push_heap@3

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	edx, DWORD PTR [esi+eax*8+4]
	mov	DWORD PTR [esi+ecx*8+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap@3
$LN1@Push_heap@3:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [esi+ecx*8+4], ebx
	mov	DWORD PTR [esi+ecx*8], eax
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::_Iter_random<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@6
	push	esi
$LL2@Copy_backw@6:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@6
	pop	esi
$LN1@Copy_backw@6:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvHomelandMove>::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??D?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvHomelandMove>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvHomelandMove>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvHomelandMove>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvHomelandMove>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvHomelandMove>::operator++
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABVCvHomelandTarget@@@Z ; std::_Temp_iterator<CvHomelandTarget>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABVCvHomelandTarget@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABVCvHomelandTarget@@@Z PROC ; std::_Temp_iterator<CvHomelandTarget>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	jae	SHORT $LN2@operator@2
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], esi
	mov	esi, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], esi
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], edx
	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 20			; 00000014H
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator@2:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	test	ecx, ecx
	je	SHORT $LN7@operator@2
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], esi
	mov	esi, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], esi
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], edx
$LN7@operator@2:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 20			; 00000014H
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABVCvHomelandTarget@@@Z ENDP ; std::_Temp_iterator<CvHomelandTarget>::operator=
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvHomelandTarget>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvHomelandTarget>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvHomelandTarget>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvHomelandTarget>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvHomelandTarget>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvHomelandTarget>::operator++
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvHomelandUnit>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvHomelandUnit>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvHomelandUnit>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvHomelandUnit>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvHomelandUnit>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvHomelandUnit>::operator++
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvHomelandMove@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandMove@@0@Z ; std::_Iter_random<CvHomelandMove *,CvHomelandMove *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvHomelandMove@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandMove@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvHomelandMove@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandMove@@0@Z PROC ; std::_Iter_random<CvHomelandMove *,CvHomelandMove *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvHomelandMove@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandMove@@0@Z ENDP ; std::_Iter_random<CvHomelandMove *,CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvHomelandMove@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandMove@@0@Z ; std::_Ptr_cat<CvHomelandMove *,CvHomelandMove *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvHomelandMove@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandMove@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvHomelandMove@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandMove@@0@Z PROC ; std::_Ptr_cat<CvHomelandMove *,CvHomelandMove *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvHomelandMove@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandMove@@0@Z ENDP ; std::_Ptr_cat<CvHomelandMove *,CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvHomelandMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvHomelandMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvHomelandMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@7
	push	esi
$LL2@Copy_backw@7:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@7
	pop	esi
$LN1@Copy_backw@7:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvHomelandMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvHomelandMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvHomelandMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvHomelandMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@2
	push	esi
$LL3@Copy_opt@2:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@2
	pop	esi
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvHomelandMove@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z ; std::_Iter_random<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z ; std::_Ptr_cat<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z ; std::_Iter_random<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z PROC ; std::_Iter_random<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z ENDP ; std::_Iter_random<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandTarget@@AAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z ; std::_Ptr_cat<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandTarget@@AAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandTarget@@AAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z PROC ; std::_Ptr_cat<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandTarget@@AAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z ENDP ; std::_Ptr_cat<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvHomelandUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandUnit@@0@Z ; std::_Iter_random<CvHomelandUnit *,CvHomelandUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvHomelandUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandUnit@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvHomelandUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandUnit@@0@Z PROC ; std::_Iter_random<CvHomelandUnit *,CvHomelandUnit *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvHomelandUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandUnit@@0@Z ENDP ; std::_Iter_random<CvHomelandUnit *,CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvHomelandUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandUnit@@0@Z ; std::_Ptr_cat<CvHomelandUnit *,CvHomelandUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvHomelandUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandUnit@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvHomelandUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandUnit@@0@Z PROC ; std::_Ptr_cat<CvHomelandUnit *,CvHomelandUnit *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvHomelandUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvHomelandUnit@@0@Z ENDP ; std::_Ptr_cat<CvHomelandUnit *,CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvHomelandUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvHomelandUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvHomelandUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@8
	push	esi
$LL2@Copy_backw@8:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@8
	pop	esi
$LN1@Copy_backw@8:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvHomelandUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvHomelandUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvHomelandUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvHomelandUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@3
	push	esi
$LL3@Copy_opt@3:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@3
	pop	esi
$LN1@Copy_opt@3:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvHomelandUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$swap@H@std@@YAXAAH0@Z			; std::swap<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$swap@H@std@@YAXAAH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@H@std@@YAXAAH0@Z PROC				; std::swap<int>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@6

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@6:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@H@std@@YAXAAH0@Z ENDP				; std::swap<int>
_TEXT	ENDS
PUBLIC	??$swap@PAVCvPlot@@@std@@YAXAAPAVCvPlot@@0@Z	; std::swap<CvPlot *>
; Function compile flags: /Ogtpy
;	COMDAT ??$swap@PAVCvPlot@@@std@@YAXAAPAVCvPlot@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAVCvPlot@@@std@@YAXAAPAVCvPlot@@0@Z PROC	; std::swap<CvPlot *>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@7

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@7:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@PAVCvPlot@@@std@@YAXAAPAVCvPlot@@0@Z ENDP	; std::swap<CvPlot *>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@ABV1@@Z ; std::_Construct<CvHomelandMove,CvHomelandMove>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Construct@VCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@ABV1@@Z PROC ; std::_Construct<CvHomelandMove,CvHomelandMove>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@4
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct@4:

; 53   : 	}

	ret	0
??$_Construct@VCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@ABV1@@Z ENDP ; std::_Construct<CvHomelandMove,CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@ABV1@@Z ; std::_Construct<CvHomelandUnit,CvHomelandUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Construct@VCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@ABV1@@Z PROC ; std::_Construct<CvHomelandUnit,CvHomelandUnit>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@5
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN3@Construct@5:

; 53   : 	}

	ret	0
??$_Construct@VCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@ABV1@@Z ENDP ; std::_Construct<CvHomelandUnit,CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandMove@@0ABV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Iter_random<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandMove@@0ABV?$_Temp_iterator@VCvHomelandMove@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandMove@@0ABV?$_Temp_iterator@VCvHomelandMove@@@0@@Z PROC ; std::_Iter_random<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandMove@@0ABV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ENDP ; std::_Iter_random<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00PAH0@Z ; std::_Rotate<CvHomelandMove *,int,CvHomelandMove>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Rotate@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00PAH0@Z
_TEXT	SEGMENT
__Holeval$236605 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00PAH0@Z PROC ; std::_Rotate<CvHomelandMove *,int,CvHomelandMove>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	sub	esp, 8
	push	ebx

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	ebx, DWORD PTR __Mid$[esp+8]
	push	ebp

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ebp, DWORD PTR __Last$[esp+12]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+20]
	sub	ebx, edi
	mov	ecx, ebp
	sub	ecx, edi
	sar	ebx, 3
	sar	ecx, 3
	mov	eax, ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	esi, ebx
	test	ebx, ebx
	je	SHORT $LN7@Rotate
$LL8@Rotate:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	cdq
	idiv	esi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, esi
	mov	esi, edx
	test	edx, edx
	jne	SHORT $LL8@Rotate
$LN7@Rotate:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	eax, ecx
	jge	SHORT $LN3@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	test	eax, eax
	jle	SHORT $LN3@Rotate
	lea	edi, DWORD PTR [edi+eax*8]
	npad	3
$LL5@Rotate:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;
; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR __Holeval$236605[esp+24], ecx

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	lea	ecx, DWORD PTR [edi+ebx*8]
	mov	esi, edi
	mov	DWORD PTR __Holeval$236605[esp+28], edx
	cmp	ecx, ebp
	jne	SHORT $LN11@Rotate
	mov	ecx, DWORD PTR __First$[esp+20]
$LN11@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, edi
	je	SHORT $LN1@Rotate
	npad	2
$LL2@Rotate:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [esi], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], edx

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edx, ebp
	sub	edx, ecx
	sar	edx, 3
	cmp	ebx, edx
	mov	esi, ecx
	jge	SHORT $LN13@Rotate
	lea	edx, DWORD PTR [ebx*8]
	add	ecx, edx
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	mov	ecx, ebx
	sub	ecx, edx
	mov	edx, DWORD PTR __First$[esp+20]
	lea	ecx, DWORD PTR [edx+ecx*8]
$LN14@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, edi
	jne	SHORT $LL2@Rotate
$LN1@Rotate:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	ecx, DWORD PTR __Holeval$236605[esp+24]
	mov	edx, DWORD PTR __Holeval$236605[esp+28]
	dec	eax
	sub	edi, 8
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], edx
	test	eax, eax
	jg	SHORT $LL5@Rotate
$LN3@Rotate:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1706 : 			}
; 1707 : 	}

	add	esp, 8
	ret	0
??$_Rotate@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00PAH0@Z ENDP ; std::_Rotate<CvHomelandMove *,int,CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0ABV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Iter_random<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0ABV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0ABV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z PROC ; std::_Iter_random<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@std@@YA?AUforward_iterator_tag@0@ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0ABV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ENDP ; std::_Iter_random<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAVCvHomelandTarget@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@@Z ; std::_Iter_cat<CvHomelandTarget *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAVCvHomelandTarget@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAVCvHomelandTarget@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@@Z PROC ; std::_Iter_cat<CvHomelandTarget *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAVCvHomelandTarget@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@@Z ENDP ; std::_Iter_cat<CvHomelandTarget *>
_TEXT	ENDS
PUBLIC	??$_Advance@PAVCvHomelandTarget@@H@std@@YAXAAPAVCvHomelandTarget@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CvHomelandTarget *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Advance@PAVCvHomelandTarget@@H@std@@YAXAAPAVCvHomelandTarget@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAVCvHomelandTarget@@H@std@@YAXAAPAVCvHomelandTarget@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CvHomelandTarget *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAVCvHomelandTarget@@H@std@@YAXAAPAVCvHomelandTarget@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CvHomelandTarget *,int>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@0ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z ; std::_Iter_random<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@0ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@0ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z PROC ; std::_Iter_random<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvHomelandTarget@@0ABV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@@Z ENDP ; std::_Iter_random<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandUnit@@0ABV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Iter_random<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandUnit@@0ABV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandUnit@@0ABV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z PROC ; std::_Iter_random<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvHomelandUnit@@0ABV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ENDP ; std::_Iter_random<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00PAH0@Z ; std::_Rotate<CvHomelandUnit *,int,CvHomelandUnit>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Rotate@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00PAH0@Z
_TEXT	SEGMENT
__Holeval$236713 = -16					; size = 16
__First$ = 8						; size = 4
tv172 = 12						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00PAH0@Z PROC ; std::_Rotate<CvHomelandUnit *,int,CvHomelandUnit>, COMDAT

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;
; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, DWORD PTR __Mid$[esp+16]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+24]
	sub	ebx, edi
	sub	ecx, edi
	sar	ebx, 4
	sar	ecx, 4
	mov	eax, ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	esi, ebx
	test	ebx, ebx
	je	SHORT $LN7@Rotate@2
$LL8@Rotate@2:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	cdq
	idiv	esi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, esi
	mov	esi, edx
	test	edx, edx
	jne	SHORT $LL8@Rotate@2
$LN7@Rotate@2:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	eax, ecx
	jge	$LN3@Rotate@2

; 1692 : 		for (; 0 < _Count; --_Count)

	test	eax, eax
	jle	$LN3@Rotate@2
	mov	ecx, ebx
	mov	esi, eax
	shl	ecx, 4
	shl	esi, 4
	push	ebp
	mov	DWORD PTR tv172[esp+28], ecx
	add	esi, edi
	jmp	SHORT $LN5@Rotate@2
$LL21@Rotate@2:
	mov	ecx, DWORD PTR tv172[esp+28]
$LN5@Rotate@2:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;
; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	mov	edi, DWORD PTR [esi+4]
	mov	ebp, DWORD PTR [esi]
	mov	DWORD PTR __Holeval$236713[esp+36], edi
	mov	edi, DWORD PTR [esi+8]
	mov	DWORD PTR __Holeval$236713[esp+40], edi
	mov	edi, DWORD PTR [esi+12]

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	add	ecx, esi
	mov	edx, esi
	mov	DWORD PTR __Holeval$236713[esp+44], edi
	cmp	ecx, DWORD PTR __Last$[esp+28]
	jne	SHORT $LN11@Rotate@2
	mov	ecx, DWORD PTR __First$[esp+28]
$LN11@Rotate@2:

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, esi
	je	SHORT $LN1@Rotate@2
	npad	1
$LL2@Rotate@2:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], edi
	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], edi
	mov	edi, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], edi

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edi, DWORD PTR __Last$[esp+28]
	sub	edi, ecx
	sar	edi, 4
	cmp	ebx, edi
	mov	edx, ecx
	jge	SHORT $LN13@Rotate@2
	add	ecx, DWORD PTR tv172[esp+28]
	jmp	SHORT $LN14@Rotate@2
$LN13@Rotate@2:
	mov	ecx, ebx
	sub	ecx, edi
	shl	ecx, 4
	add	ecx, DWORD PTR __First$[esp+28]
$LN14@Rotate@2:

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, esi
	jne	SHORT $LL2@Rotate@2
$LN1@Rotate@2:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	ecx, DWORD PTR __Holeval$236713[esp+36]
	mov	DWORD PTR [edx], ebp
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR __Holeval$236713[esp+40]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR __Holeval$236713[esp+44]
	dec	eax
	sub	esi, 16					; 00000010H
	mov	DWORD PTR [edx+12], ecx
	test	eax, eax
	jg	$LL21@Rotate@2
	pop	ebp
$LN3@Rotate@2:
	pop	edi
	pop	esi
	pop	ebx

; 1706 : 			}
; 1707 : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Rotate@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00PAH0@Z ENDP ; std::_Rotate<CvHomelandUnit *,int,CvHomelandUnit>
_TEXT	ENDS
PUBLIC	?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ		; CvGlobals::getMOVE_DENOMINATOR
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMOVE_DENOMINATOR, COMDAT
; _this$ = ecx

; 5312 : 		return m_iMOVE_DENOMINATOR;

	mov	eax, DWORD PTR [ecx+6236]

; 5313 : 	}

	ret	0
?getMOVE_DENOMINATOR@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMOVE_DENOMINATOR
_TEXT	ENDS
PUBLIC	?getMAX_CITY_DEFENSE_DAMAGE@CvGlobals@@QAEHXZ	; CvGlobals::getMAX_CITY_DEFENSE_DAMAGE
; Function compile flags: /Ogtpy
;	COMDAT ?getMAX_CITY_DEFENSE_DAMAGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMAX_CITY_DEFENSE_DAMAGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getMAX_CITY_DEFENSE_DAMAGE, COMDAT
; _this$ = ecx

; 5816 : 		return m_iMAX_CITY_DEFENSE_DAMAGE;

	mov	eax, DWORD PTR [ecx+6740]

; 5817 : 	}

	ret	0
?getMAX_CITY_DEFENSE_DAMAGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getMAX_CITY_DEFENSE_DAMAGE
_TEXT	ENDS
PUBLIC	?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ		; CvGlobals::getMAX_HIT_POINTS
; Function compile flags: /Ogtpy
;	COMDAT ?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMAX_HIT_POINTS, COMDAT
; _this$ = ecx

; 6497 : 		return m_iMAX_HIT_POINTS;

	mov	eax, DWORD PTR [ecx+7368]

; 6498 : 	}

	ret	0
?getMAX_HIT_POINTS@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMAX_HIT_POINTS
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION@CvGlobals@@QAEMXZ ; CvGlobals::getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION, COMDAT
; _this$ = ecx

; 7112 : 		return m_fAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION;

	fld	DWORD PTR [ecx+8100]

; 7113 : 	}

	ret	0
?getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION
_TEXT	ENDS
PUBLIC	?getARTIFACT_RESOURCE@CvGlobals@@QAEHXZ		; CvGlobals::getARTIFACT_RESOURCE
; Function compile flags: /Ogtpy
;	COMDAT ?getARTIFACT_RESOURCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getARTIFACT_RESOURCE@CvGlobals@@QAEHXZ PROC		; CvGlobals::getARTIFACT_RESOURCE, COMDAT
; _this$ = ecx

; 7191 : 		return m_iARTIFACT_RESOURCE;

	mov	eax, DWORD PTR [ecx+8408]

; 7192 : 	}

	ret	0
?getARTIFACT_RESOURCE@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getARTIFACT_RESOURCE
_TEXT	ENDS
PUBLIC	?getHIDDEN_ARTIFACT_RESOURCE@CvGlobals@@QAEHXZ	; CvGlobals::getHIDDEN_ARTIFACT_RESOURCE
; Function compile flags: /Ogtpy
;	COMDAT ?getHIDDEN_ARTIFACT_RESOURCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getHIDDEN_ARTIFACT_RESOURCE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getHIDDEN_ARTIFACT_RESOURCE, COMDAT
; _this$ = ecx

; 7195 : 		return m_iHIDDEN_ARTIFACT_RESOURCE;

	mov	eax, DWORD PTR [ecx+8412]

; 7196 : 	}

	ret	0
?getHIDDEN_ARTIFACT_RESOURCE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getHIDDEN_ARTIFACT_RESOURCE
_TEXT	ENDS
PUBLIC	?getSPACE_RACE_TRIGGER_PROJECT@CvGlobals@@QAEHXZ ; CvGlobals::getSPACE_RACE_TRIGGER_PROJECT
; Function compile flags: /Ogtpy
;	COMDAT ?getSPACE_RACE_TRIGGER_PROJECT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getSPACE_RACE_TRIGGER_PROJECT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getSPACE_RACE_TRIGGER_PROJECT, COMDAT
; _this$ = ecx

; 7207 : 		return m_iSPACE_RACE_TRIGGER_PROJECT;

	mov	eax, DWORD PTR [ecx+8424]

; 7208 : 	}

	ret	0
?getSPACE_RACE_TRIGGER_PROJECT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getSPACE_RACE_TRIGGER_PROJECT
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?isHills@CvPlot@@QBE_NXZ			; CvPlot::isHills
; Function compile flags: /Ogtpy
;	COMDAT ?isHills@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isHills@CvPlot@@QBE_NXZ PROC				; CvPlot::isHills, COMDAT
; _this$ = ecx

; 413  : 		return (PlotTypes)m_ePlotType == PLOT_HILLS;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 1
	sete	al

; 414  : 	};

	ret	0
?isHills@CvPlot@@QBE_NXZ ENDP				; CvPlot::isHills
_TEXT	ENDS
PUBLIC	?isMountain@CvPlot@@QBE_NXZ			; CvPlot::isMountain
; Function compile flags: /Ogtpy
;	COMDAT ?isMountain@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isMountain@CvPlot@@QBE_NXZ PROC			; CvPlot::isMountain, COMDAT
; _this$ = ecx

; 422  : 		return (PlotTypes)m_ePlotType == PLOT_MOUNTAIN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], al
	sete	al

; 423  : 	};

	ret	0
?isMountain@CvPlot@@QBE_NXZ ENDP			; CvPlot::isMountain
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::getVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::getVisibilityCount, COMDAT
; _this$ = ecx

; 588  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 589  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 590  : 
; 591  : 		return m_aiVisibilityCount[eTeam];

	mov	eax, DWORD PTR [ecx+156]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 592  : 	}

	ret	4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::getVisibilityCount
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z		; CvMap::plotByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z PROC		; CvMap::plotByIndex, COMDAT
; _this$ = ecx

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	mov	eax, DWORD PTR _iIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@plotByInde
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN3@plotByInde
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 264  : 	}

	ret	4
$LN3@plotByInde:

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	xor	eax, eax

; 264  : 	}

	ret	4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z ENDP		; CvMap::plotByIndex
_TEXT	ENDS
PUBLIC	?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z	; CvMap::plotByIndexUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z PROC	; CvMap::plotByIndexUnchecked, COMDAT
; _this$ = ecx

; 268  : 		return &m_pMapPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 269  : 	}

	ret	4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z ENDP	; CvMap::plotByIndexUnchecked
_TEXT	ENDS
PUBLIC	?GetDominanceFlag@CvTacticalDominanceZone@@QBE?AW4eTacticalDominanceFlags@@XZ ; CvTacticalDominanceZone::GetDominanceFlag
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
;	COMDAT ?GetDominanceFlag@CvTacticalDominanceZone@@QBE?AW4eTacticalDominanceFlags@@XZ
_TEXT	SEGMENT
?GetDominanceFlag@CvTacticalDominanceZone@@QBE?AW4eTacticalDominanceFlags@@XZ PROC ; CvTacticalDominanceZone::GetDominanceFlag, COMDAT
; _this$ = ecx

; 412  : 		return m_eDominanceFlag;

	mov	eax, DWORD PTR [ecx+8]

; 413  : 	};

	ret	0
?GetDominanceFlag@CvTacticalDominanceZone@@QBE?AW4eTacticalDominanceFlags@@XZ ENDP ; CvTacticalDominanceZone::GetDominanceFlag
_TEXT	ENDS
PUBLIC	??0CvHomelandMove@@QAE@XZ			; CvHomelandMove::CvHomelandMove
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.h
;	COMDAT ??0CvHomelandMove@@QAE@XZ
_TEXT	SEGMENT
??0CvHomelandMove@@QAE@XZ PROC				; CvHomelandMove::CvHomelandMove, COMDAT
; _this$ = ecx

; 32   : 	CvHomelandMove()

	mov	eax, ecx

; 33   : 	{
; 34   : 		m_eMoveType = AI_HOMELAND_MOVE_NONE;

	mov	DWORD PTR [eax], -1

; 35   : 		m_iPriority = 0;

	mov	DWORD PTR [eax+4], 0

; 36   : 	}

	ret	0
??0CvHomelandMove@@QAE@XZ ENDP				; CvHomelandMove::CvHomelandMove
_TEXT	ENDS
PUBLIC	??MCvHomelandMove@@QBE_NABV0@@Z			; CvHomelandMove::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MCvHomelandMove@@QBE_NABV0@@Z
_TEXT	SEGMENT
_move$ = 8						; size = 4
??MCvHomelandMove@@QBE_NABV0@@Z PROC			; CvHomelandMove::operator<, COMDAT
; _this$ = ecx

; 40   : 		return (m_iPriority > move.m_iPriority);

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _move$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 41   : 	}

	ret	4
??MCvHomelandMove@@QBE_NABV0@@Z ENDP			; CvHomelandMove::operator<
_TEXT	ENDS
PUBLIC	?SetID@CvHomelandUnit@@QAEXH@Z			; CvHomelandUnit::SetID
; Function compile flags: /Ogtpy
;	COMDAT ?SetID@CvHomelandUnit@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?SetID@CvHomelandUnit@@QAEXH@Z PROC			; CvHomelandUnit::SetID, COMDAT
; _this$ = ecx

; 61   : 		m_iID = iID;

	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx], eax

; 62   : 	};

	ret	4
?SetID@CvHomelandUnit@@QAEXH@Z ENDP			; CvHomelandUnit::SetID
_TEXT	ENDS
PUBLIC	?GetID@CvHomelandUnit@@QBEHXZ			; CvHomelandUnit::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvHomelandUnit@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvHomelandUnit@@QBEHXZ PROC			; CvHomelandUnit::GetID, COMDAT
; _this$ = ecx

; 65   : 		return m_iID;

	mov	eax, DWORD PTR [ecx]

; 66   : 	};

	ret	0
?GetID@CvHomelandUnit@@QBEHXZ ENDP			; CvHomelandUnit::GetID
_TEXT	ENDS
PUBLIC	?SetMovesToTarget@CvHomelandUnit@@QAEXH@Z	; CvHomelandUnit::SetMovesToTarget
; Function compile flags: /Ogtpy
;	COMDAT ?SetMovesToTarget@CvHomelandUnit@@QAEXH@Z
_TEXT	SEGMENT
_iMoves$ = 8						; size = 4
?SetMovesToTarget@CvHomelandUnit@@QAEXH@Z PROC		; CvHomelandUnit::SetMovesToTarget, COMDAT
; _this$ = ecx

; 69   : 		m_iMovesToTarget = iMoves;

	mov	eax, DWORD PTR _iMoves$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 70   : 	};

	ret	4
?SetMovesToTarget@CvHomelandUnit@@QAEXH@Z ENDP		; CvHomelandUnit::SetMovesToTarget
_TEXT	ENDS
PUBLIC	?GetMovesToTarget@CvHomelandUnit@@QBEHXZ	; CvHomelandUnit::GetMovesToTarget
; Function compile flags: /Ogtpy
;	COMDAT ?GetMovesToTarget@CvHomelandUnit@@QBEHXZ
_TEXT	SEGMENT
?GetMovesToTarget@CvHomelandUnit@@QBEHXZ PROC		; CvHomelandUnit::GetMovesToTarget, COMDAT
; _this$ = ecx

; 73   : 		return m_iMovesToTarget;

	mov	eax, DWORD PTR [ecx+8]

; 74   : 	};

	ret	0
?GetMovesToTarget@CvHomelandUnit@@QBEHXZ ENDP		; CvHomelandUnit::GetMovesToTarget
_TEXT	ENDS
PUBLIC	?SetTarget@CvHomelandUnit@@QAEXPAVCvPlot@@@Z	; CvHomelandUnit::SetTarget
; Function compile flags: /Ogtpy
;	COMDAT ?SetTarget@CvHomelandUnit@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?SetTarget@CvHomelandUnit@@QAEXPAVCvPlot@@@Z PROC	; CvHomelandUnit::SetTarget, COMDAT
; _this$ = ecx

; 77   : 		m_pTarget = pPlot;

	mov	eax, DWORD PTR _pPlot$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 78   : 	};

	ret	4
?SetTarget@CvHomelandUnit@@QAEXPAVCvPlot@@@Z ENDP	; CvHomelandUnit::SetTarget
_TEXT	ENDS
PUBLIC	?GetTarget@CvHomelandUnit@@QBEPAVCvPlot@@XZ	; CvHomelandUnit::GetTarget
; Function compile flags: /Ogtpy
;	COMDAT ?GetTarget@CvHomelandUnit@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
?GetTarget@CvHomelandUnit@@QBEPAVCvPlot@@XZ PROC	; CvHomelandUnit::GetTarget, COMDAT
; _this$ = ecx

; 81   : 		return m_pTarget;

	mov	eax, DWORD PTR [ecx+12]

; 82   : 	};

	ret	0
?GetTarget@CvHomelandUnit@@QBEPAVCvPlot@@XZ ENDP	; CvHomelandUnit::GetTarget
_TEXT	ENDS
PUBLIC	?GetAuxIntData@CvHomelandUnit@@QAEHXZ		; CvHomelandUnit::GetAuxIntData
; Function compile flags: /Ogtpy
;	COMDAT ?GetAuxIntData@CvHomelandUnit@@QAEHXZ
_TEXT	SEGMENT
?GetAuxIntData@CvHomelandUnit@@QAEHXZ PROC		; CvHomelandUnit::GetAuxIntData, COMDAT
; _this$ = ecx

; 88   : 		return m_iAuxData;

	mov	eax, DWORD PTR [ecx+4]

; 89   : 	}

	ret	0
?GetAuxIntData@CvHomelandUnit@@QAEHXZ ENDP		; CvHomelandUnit::GetAuxIntData
_TEXT	ENDS
PUBLIC	?SetAuxIntData@CvHomelandUnit@@QAEXH@Z		; CvHomelandUnit::SetAuxIntData
; Function compile flags: /Ogtpy
;	COMDAT ?SetAuxIntData@CvHomelandUnit@@QAEXH@Z
_TEXT	SEGMENT
_iAuxData$ = 8						; size = 4
?SetAuxIntData@CvHomelandUnit@@QAEXH@Z PROC		; CvHomelandUnit::SetAuxIntData, COMDAT
; _this$ = ecx

; 92   : 		m_iAuxData = iAuxData;

	mov	eax, DWORD PTR _iAuxData$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 93   : 	}

	ret	4
?SetAuxIntData@CvHomelandUnit@@QAEXH@Z ENDP		; CvHomelandUnit::SetAuxIntData
_TEXT	ENDS
PUBLIC	??0CvHomelandTarget@@QAE@XZ			; CvHomelandTarget::CvHomelandTarget
; Function compile flags: /Ogtpy
;	COMDAT ??0CvHomelandTarget@@QAE@XZ
_TEXT	SEGMENT
??0CvHomelandTarget@@QAE@XZ PROC			; CvHomelandTarget::CvHomelandTarget, COMDAT
; _this$ = ecx

; 121  : 	{

	mov	eax, ecx
	or	ecx, -1
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], 1
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 122  : 	};

	ret	0
??0CvHomelandTarget@@QAE@XZ ENDP			; CvHomelandTarget::CvHomelandTarget
_TEXT	ENDS
PUBLIC	??MCvHomelandTarget@@QBE_NABV0@@Z		; CvHomelandTarget::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MCvHomelandTarget@@QBE_NABV0@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??MCvHomelandTarget@@QBE_NABV0@@Z PROC			; CvHomelandTarget::operator<, COMDAT
; _this$ = ecx

; 126  : 		return (m_iAuxData > target.m_iAuxData);

	mov	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _target$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+16]
	setg	cl
	mov	al, cl

; 127  : 	}

	ret	4
??MCvHomelandTarget@@QBE_NABV0@@Z ENDP			; CvHomelandTarget::operator<
_TEXT	ENDS
PUBLIC	?SetTargetType@CvHomelandTarget@@QAEXW4AIHomelandTargetType@@@Z ; CvHomelandTarget::SetTargetType
; Function compile flags: /Ogtpy
;	COMDAT ?SetTargetType@CvHomelandTarget@@QAEXW4AIHomelandTargetType@@@Z
_TEXT	SEGMENT
_eTargetType$ = 8					; size = 4
?SetTargetType@CvHomelandTarget@@QAEXW4AIHomelandTargetType@@@Z PROC ; CvHomelandTarget::SetTargetType, COMDAT
; _this$ = ecx

; 134  : 		m_eTargetType = eTargetType;

	mov	eax, DWORD PTR _eTargetType$[esp-4]
	mov	DWORD PTR [ecx], eax

; 135  : 	}

	ret	4
?SetTargetType@CvHomelandTarget@@QAEXW4AIHomelandTargetType@@@Z ENDP ; CvHomelandTarget::SetTargetType
_TEXT	ENDS
PUBLIC	?GetTargetX@CvHomelandTarget@@QAEHXZ		; CvHomelandTarget::GetTargetX
; Function compile flags: /Ogtpy
;	COMDAT ?GetTargetX@CvHomelandTarget@@QAEHXZ
_TEXT	SEGMENT
?GetTargetX@CvHomelandTarget@@QAEHXZ PROC		; CvHomelandTarget::GetTargetX, COMDAT
; _this$ = ecx

; 138  : 		return m_iTargetX;

	mov	eax, DWORD PTR [ecx+4]

; 139  : 	}

	ret	0
?GetTargetX@CvHomelandTarget@@QAEHXZ ENDP		; CvHomelandTarget::GetTargetX
_TEXT	ENDS
PUBLIC	?SetTargetX@CvHomelandTarget@@QAEXH@Z		; CvHomelandTarget::SetTargetX
; Function compile flags: /Ogtpy
;	COMDAT ?SetTargetX@CvHomelandTarget@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetTargetX@CvHomelandTarget@@QAEXH@Z PROC		; CvHomelandTarget::SetTargetX, COMDAT
; _this$ = ecx

; 142  : 		m_iTargetX = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 143  : 	}

	ret	4
?SetTargetX@CvHomelandTarget@@QAEXH@Z ENDP		; CvHomelandTarget::SetTargetX
_TEXT	ENDS
PUBLIC	?GetTargetY@CvHomelandTarget@@QAEHXZ		; CvHomelandTarget::GetTargetY
; Function compile flags: /Ogtpy
;	COMDAT ?GetTargetY@CvHomelandTarget@@QAEHXZ
_TEXT	SEGMENT
?GetTargetY@CvHomelandTarget@@QAEHXZ PROC		; CvHomelandTarget::GetTargetY, COMDAT
; _this$ = ecx

; 146  : 		return m_iTargetY;

	mov	eax, DWORD PTR [ecx+8]

; 147  : 	}

	ret	0
?GetTargetY@CvHomelandTarget@@QAEHXZ ENDP		; CvHomelandTarget::GetTargetY
_TEXT	ENDS
PUBLIC	?SetTargetY@CvHomelandTarget@@QAEXH@Z		; CvHomelandTarget::SetTargetY
; Function compile flags: /Ogtpy
;	COMDAT ?SetTargetY@CvHomelandTarget@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetTargetY@CvHomelandTarget@@QAEXH@Z PROC		; CvHomelandTarget::SetTargetY, COMDAT
; _this$ = ecx

; 150  : 		m_iTargetY = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 151  : 	}

	ret	4
?SetTargetY@CvHomelandTarget@@QAEXH@Z ENDP		; CvHomelandTarget::SetTargetY
_TEXT	ENDS
PUBLIC	?SetAuxData@CvHomelandTarget@@QAEXPAX@Z		; CvHomelandTarget::SetAuxData
; Function compile flags: /Ogtpy
;	COMDAT ?SetAuxData@CvHomelandTarget@@QAEXPAX@Z
_TEXT	SEGMENT
_pAuxData$ = 8						; size = 4
?SetAuxData@CvHomelandTarget@@QAEXPAX@Z PROC		; CvHomelandTarget::SetAuxData, COMDAT
; _this$ = ecx

; 161  : 		m_pAuxData = pAuxData;

	mov	eax, DWORD PTR _pAuxData$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 162  : 	}

	ret	4
?SetAuxData@CvHomelandTarget@@QAEXPAX@Z ENDP		; CvHomelandTarget::SetAuxData
_TEXT	ENDS
PUBLIC	?GetAuxIntData@CvHomelandTarget@@QAEHXZ		; CvHomelandTarget::GetAuxIntData
; Function compile flags: /Ogtpy
;	COMDAT ?GetAuxIntData@CvHomelandTarget@@QAEHXZ
_TEXT	SEGMENT
?GetAuxIntData@CvHomelandTarget@@QAEHXZ PROC		; CvHomelandTarget::GetAuxIntData, COMDAT
; _this$ = ecx

; 170  : 		return m_iAuxData;

	mov	eax, DWORD PTR [ecx+16]

; 171  : 	}

	ret	0
?GetAuxIntData@CvHomelandTarget@@QAEHXZ ENDP		; CvHomelandTarget::GetAuxIntData
_TEXT	ENDS
PUBLIC	?SetAuxIntData@CvHomelandTarget@@QAEXH@Z	; CvHomelandTarget::SetAuxIntData
; Function compile flags: /Ogtpy
;	COMDAT ?SetAuxIntData@CvHomelandTarget@@QAEXH@Z
_TEXT	SEGMENT
_iAuxData$ = 8						; size = 4
?SetAuxIntData@CvHomelandTarget@@QAEXH@Z PROC		; CvHomelandTarget::SetAuxIntData, COMDAT
; _this$ = ecx

; 174  : 		m_iAuxData = iAuxData;

	mov	eax, DWORD PTR _iAuxData$[esp-4]
	mov	DWORD PTR [ecx+16], eax

; 175  : 	}

	ret	4
?SetAuxIntData@CvHomelandTarget@@QAEXH@Z ENDP		; CvHomelandTarget::SetAuxIntData
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ	; CvAStar::GetLastNode
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvastar.h
;	COMDAT ?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ
_TEXT	SEGMENT
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ PROC	; CvAStar::GetLastNode, COMDAT
; _this$ = ecx

; 98   : 		return m_pBest;

	mov	eax, DWORD PTR [ecx+96]

; 99   : 	}

	ret	0
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ ENDP	; CvAStar::GetLastNode
_TEXT	ENDS
PUBLIC	??0BuilderDirective@@QAE@XZ			; BuilderDirective::BuilderDirective
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.h
;	COMDAT ??0BuilderDirective@@QAE@XZ
_TEXT	SEGMENT
??0BuilderDirective@@QAE@XZ PROC			; BuilderDirective::BuilderDirective, COMDAT
; _this$ = ecx

; 46   : 	{

	mov	eax, ecx
	or	ecx, -1
	mov	edx, ecx
	mov	DWORD PTR [eax], 6
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	WORD PTR [eax+12], dx
	mov	WORD PTR [eax+14], dx
	mov	WORD PTR [eax+16], cx

; 47   : 	}

	ret	0
??0BuilderDirective@@QAE@XZ ENDP			; BuilderDirective::BuilderDirective
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ	; FAutoVariable<bool,CvUnit>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ PROC		; FAutoVariable<bool,CvUnit>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ ENDP		; FAutoVariable<bool,CvUnit>::operator bool const &
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?Init@CvHomelandAI@@QAEXPAVCvPlayer@@@Z		; CvHomelandAI::Init
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
;	COMDAT ?Init@CvHomelandAI@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?Init@CvHomelandAI@@QAEXPAVCvPlayer@@@Z PROC		; CvHomelandAI::Init, COMDAT
; _this$ = ecx

; 57   : 	// Store off the pointer to the objects we need elsewhere in the game engine
; 58   : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _pPlayer$[esp-4]
	mov	DWORD PTR [ecx], eax

; 59   : 
; 60   : 	Reset();

	xor	eax, eax
	mov	DWORD PTR [ecx+2396], eax
	mov	DWORD PTR [ecx+2404], eax
	mov	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR [ecx+2392], -1
	mov	DWORD PTR [ecx+2400], eax
	mov	DWORD PTR [ecx+2408], eax

; 61   : 
; 62   : 	// Initialize AI constants from XML
; 63   : 	m_iRandomRange = GC.getAI_HOMELAND_MOVE_PRIORITY_RANDOMNESS();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2560
	mov	DWORD PTR [ecx+2524], edx

; 64   : 	m_iDefensiveMoveTurns = GC.getAI_HOMELAND_MAX_DEFENSIVE_MOVE_TURNS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2568
	mov	DWORD PTR [ecx+2528], eax

; 65   : 	m_iUpgradeMoveTurns = GC.getAI_HOMELAND_MAX_UPGRADE_MOVE_TURNS();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2564
	mov	DWORD PTR [ecx+2532], edx

; 66   : 	m_fFlavorDampening = GC.getAI_TACTICAL_FLAVOR_DAMPENING_FOR_MOVE_PRIORITIZATION();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8100
	fstp	QWORD PTR [ecx+2536]

; 67   : }

	ret	4
?Init@CvHomelandAI@@QAEXPAVCvPlayer@@@Z ENDP		; CvHomelandAI::Init
_TEXT	ENDS
PUBLIC	?Read@CvHomelandAI@@QAEXAAVFDataStream@@@Z	; CvHomelandAI::Read
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvHomelandAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvHomelandAI@@QAEXAAVFDataStream@@@Z PROC		; CvHomelandAI::Read, COMDAT
; _this$ = ecx

; 86   : {

	push	esi
	push	edi

; 87   : 	// Version number to maintain backwards compatibility
; 88   : 	uint uiVersion;
; 89   : 	kStream >> uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+4]
	lea	eax, DWORD PTR _uiVersion$[esp+4]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 90   : 
; 91   : 	kStream >> m_MovePriorityTurn;

	add	esi, 2392				; 00000958H
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi
	pop	esi

; 92   : }

	ret	4
?Read@CvHomelandAI@@QAEXAAVFDataStream@@@Z ENDP		; CvHomelandAI::Read
_TEXT	ENDS
PUBLIC	?Write@CvHomelandAI@@QAEXAAVFDataStream@@@Z	; CvHomelandAI::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvHomelandAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvHomelandAI@@QAEXAAVFDataStream@@@Z PROC	; CvHomelandAI::Write, COMDAT
; _this$ = ecx

; 96   : {

	push	ecx
	push	esi
	push	edi

; 97   : 	// Current version number
; 98   : 	uint uiVersion = 1;
; 99   : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+16], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 100  : 
; 101  : 	kStream << m_MovePriorityTurn;

	add	esi, 2392				; 00000958H
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi
	pop	esi

; 102  : }

	pop	ecx
	ret	4
?Write@CvHomelandAI@@QAEXAAVFDataStream@@@Z ENDP	; CvHomelandAI::Write
_TEXT	ENDS
PUBLIC	?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z ; CvHomelandAI::GetLogFileName
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z$2
__ehfuncinfo$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z
_TEXT	SEGMENT
$T239673 = -72						; size = 4
$T239671 = -68						; size = 28
$T239670 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_playerName$ = 12					; size = 4
?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z PROC ; CvHomelandAI::GetLogFileName, COMDAT
; _this$ = ecx

; 6202 : {

	push	-1
	push	__ehhandler$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T239673[esp+80], ebx

; 6203 : 	CvString strLogName;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+76]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6213 : 	}
; 6214 : 
; 6215 : 	return strLogName;

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	mov	DWORD PTR $T239673[esp+80], 1
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	test	al, al
	je	SHORT $LN2@GetLogFile
	mov	eax, DWORD PTR _playerName$[esp+76]
	push	eax
	lea	ecx, DWORD PTR $T239670[esp+84]
	push	OFFSET $SG229072
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG229071
	push	eax
	lea	edx, DWORD PTR $T239671[esp+100]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+112], 1
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+88], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T239671[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T239670[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	pop	ebx

; 6216 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	8
$LN2@GetLogFile:

; 6204 : 
; 6205 : 	// Open the log file
; 6206 : 	if(GC.getPlayerAndCityAILogSplit())
; 6207 : 	{
; 6208 : 		strLogName = "PlayerHomelandAILog_" + playerName + ".csv";
; 6209 : 	}
; 6210 : 	else
; 6211 : 	{
; 6212 : 		strLogName = "PlayerHomelandAILog.csv";

	push	OFFSET $SG229074
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 6216 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z$0:
	mov	eax, DWORD PTR $T239673[ebp]
	and	eax, 1
	je	$LN6@GetLogFile
	and	DWORD PTR $T239673[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLogFile:
	ret	0
__unwindfunclet$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z$1:
	lea	ecx, DWORD PTR $T239670[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z$2:
	lea	ecx, DWORD PTR $T239671[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z ENDP ; CvHomelandAI::GetLogFileName
PUBLIC	?CvHomelandUnitAuxIntSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z ; HomelandAIHelpers::CvHomelandUnitAuxIntSort
; Function compile flags: /Ogtpy
;	COMDAT ?CvHomelandUnitAuxIntSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z
_TEXT	SEGMENT
_obj1$ = 8						; size = 16
_obj2$ = 24						; size = 16
?CvHomelandUnitAuxIntSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z PROC ; HomelandAIHelpers::CvHomelandUnitAuxIntSort, COMDAT

; 6242 : 	return obj1.GetAuxIntData() < obj2.GetAuxIntData();

	mov	ecx, DWORD PTR _obj1$[esp]
	xor	eax, eax
	cmp	ecx, DWORD PTR _obj2$[esp]
	setl	al

; 6243 : }

	ret	0
?CvHomelandUnitAuxIntSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z ENDP ; HomelandAIHelpers::CvHomelandUnitAuxIntSort
_TEXT	ENDS
PUBLIC	?CvHomelandUnitAuxIntReverseSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z ; HomelandAIHelpers::CvHomelandUnitAuxIntReverseSort
; Function compile flags: /Ogtpy
;	COMDAT ?CvHomelandUnitAuxIntReverseSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z
_TEXT	SEGMENT
_obj1$ = 8						; size = 16
_obj2$ = 24						; size = 16
?CvHomelandUnitAuxIntReverseSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z PROC ; HomelandAIHelpers::CvHomelandUnitAuxIntReverseSort, COMDAT

; 6247 : 	return obj1.GetAuxIntData() > obj2.GetAuxIntData();

	mov	ecx, DWORD PTR _obj1$[esp]
	xor	eax, eax
	cmp	ecx, DWORD PTR _obj2$[esp]
	setg	al

; 6248 : }

	ret	0
?CvHomelandUnitAuxIntReverseSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z ENDP ; HomelandAIHelpers::CvHomelandUnitAuxIntReverseSort
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z PROC	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 156  : 	{

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx
	mov	BYTE PTR [esi+4], 0

; 157  : 		OBJECT_HANDLE_STACK;
; 158  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@2

; 159  : 		{
; 160  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@2:

; 161  : 		}
; 162  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ENDP	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z PROC ; FObjectHandle<CvUnit>::operator=, COMDAT
; _this$ = ecx

; 165  : 	{

	push	esi
	mov	esi, ecx

; 166  : 		OBJECT_HANDLE_STACK;
; 167  : 		if(m_target)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@operator@3

; 168  : 		{
; 169  : 			m_target->getDestructionNotification().removeTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@operator@3:

; 170  : 		}
; 171  : 		m_target = target;

	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx

; 172  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN9@operator@3

; 173  : 		{
; 174  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@operator@3:

; 175  : 		}
; 176  : 		return *this;

	mov	eax, esi
	pop	esi

; 177  : 	}

	ret	4
??4?$FObjectHandle@VCvUnit@@@@QAEAAV0@PAVCvUnit@@@Z ENDP ; FObjectHandle<CvUnit>::operator=
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 222  : 	{

	mov	eax, DWORD PTR _source$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	mov	dl, BYTE PTR [eax+4]
	mov	BYTE PTR [esi+4], dl

; 223  : 		OBJECT_HANDLE_STACK;
; 224  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@3

; 225  : 		{
; 226  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@3:

; 227  : 		}
; 228  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::FStaticVector<CvHomelandUnit,64,1,297,0>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvHomelandUnit,64,1,297,0>::FStaticVector<CvHomelandUnit,64,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvHomelandUnit,64,1,297,0>::FStaticVector<CvHomelandUnit,64,1,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@VCvHomelandUnit@@$00@@QAEXXZ ; BaseVector<CvHomelandUnit,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@VCvHomelandUnit@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvHomelandUnit@@$00@@QAEXXZ PROC	; BaseVector<CvHomelandUnit,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvHomelandUnit@@$00@@QAEXXZ ENDP	; BaseVector<CvHomelandUnit,1>::clear
_TEXT	ENDS
PUBLIC	?empty@?$BaseVector@VCvHomelandUnit@@$00@@QBE_NXZ ; BaseVector<CvHomelandUnit,1>::empty
; Function compile flags: /Ogtpy
;	COMDAT ?empty@?$BaseVector@VCvHomelandUnit@@$00@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$BaseVector@VCvHomelandUnit@@$00@@QBE_NXZ PROC	; BaseVector<CvHomelandUnit,1>::empty, COMDAT
; _this$ = ecx

; 166  : 		return size() == 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx+4], eax
	sete	al

; 167  : 	};

	ret	0
?empty@?$BaseVector@VCvHomelandUnit@@$00@@QBE_NXZ ENDP	; BaseVector<CvHomelandUnit,1>::empty
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandMove,35,1,297,0>::FStaticVector<CvHomelandMove,35,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvHomelandMove,35,1,297,0>::FStaticVector<CvHomelandMove,35,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 35			; 00000023H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvHomelandMove,35,1,297,0>::FStaticVector<CvHomelandMove,35,1,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@VCvHomelandMove@@$00@@QAEXXZ ; BaseVector<CvHomelandMove,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@VCvHomelandMove@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvHomelandMove@@$00@@QAEXXZ PROC	; BaseVector<CvHomelandMove,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvHomelandMove@@$00@@QAEXXZ ENDP	; BaseVector<CvHomelandMove,1>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::FStaticVector<TradeConnection,168,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnection,168,0,297,0>::FStaticVector<TradeConnection,168,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 168			; 000000a8H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnection,168,0,297,0>::FStaticVector<TradeConnection,168,0,297,0>
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >, COMDAT
; _this$ = ecx

; 314  : 	_Vector_iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 315  : 		{	// construct with null vector pointer
; 316  : 		}

	ret	0
??0?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEAAVCvHomelandTarget@@XZ ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEAAVCvHomelandTarget@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEAAVCvHomelandTarget@@XZ PROC ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEAAVCvHomelandTarget@@XZ ENDP ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator*
_TEXT	ENDS
PUBLIC	??C?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEPAVCvHomelandTarget@@XZ ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEPAVCvHomelandTarget@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEPAVCvHomelandTarget@@XZ PROC ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator->, COMDAT
; _this$ = ecx

; 344  : 		return (&**this);

	mov	eax, DWORD PTR [ecx]

; 345  : 		}

	ret	0
??C?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEPAVCvHomelandTarget@@XZ ENDP ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 20			; 00000014H

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator++
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator++, COMDAT
; _this$ = ecx

; 355  : 		_Myt _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 356  : 		++*this;

	add	edx, 20					; 00000014H
	mov	DWORD PTR [ecx], edx

; 357  : 		return (_Tmp);
; 358  : 		}

	ret	8
??E?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ ; std::list<int,std::allocator<int> >::_Iterator<0>::_Iterator<0>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ PROC ; std::list<int,std::allocator<int> >::_Iterator<0>::_Iterator<0>, COMDAT
; _this$ = ecx

; 348  : 		_Iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 349  : 			{	// construct with null node
; 350  : 			}

	ret	0
??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::list<int,std::allocator<int> >::_Iterator<0>::_Iterator<0>
_TEXT	ENDS
PUBLIC	??E?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ; std::list<int,std::allocator<int> >::_Iterator<0>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ PROC ; std::list<int,std::allocator<int> >::_Iterator<0>::operator++, COMDAT
; _this$ = ecx

; 403  : 			{	// preincrement

	mov	eax, ecx

; 404  : 			++(*(_Mybase_iter *)this);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 405  : 			return (*this);
; 406  : 			}

	ret	0
??E?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAEAAV012@XZ ENDP ; std::list<int,std::allocator<int> >::_Iterator<0>::operator++
_TEXT	ENDS
PUBLIC	??9?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator!=, COMDAT
; _this$ = ecx

; 303  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 304  : 			}

	ret	4
??9?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator!=
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator++
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator++, COMDAT
; _this$ = ecx

; 131  : 		_Myt _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 132  : 		++*this;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 133  : 		return (_Tmp);
; 134  : 		}

	ret	8
??E?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >::operator!=
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++, COMDAT
; _this$ = ecx

; 131  : 		_Myt _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 132  : 		++*this;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 133  : 		return (_Tmp);
; 134  : 		}

	ret	8
??E?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPlot *,std::allocator<CvPlot *> >::operator!=
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QBEABQAVCvPlot@@I@Z ; CvWeightedVector<CvPlot *,100,1>::GetElement
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QBEABQAVCvPlot@@I@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QBEABQAVCvPlot@@I@Z PROC ; CvWeightedVector<CvPlot *,100,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QBEABQAVCvPlot@@I@Z ENDP ; CvWeightedVector<CvPlot *,100,1>::GetElement
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEHXZ ; CvWeightedVector<CvPlot *,100,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEHXZ PROC ; CvWeightedVector<CvPlot *,100,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEHXZ ENDP ; CvWeightedVector<CvPlot *,100,1>::size
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QBEABQAVCvCity@@I@Z ; CvWeightedVector<CvCity *,64,1>::GetElement
; Function compile flags: /Ogtpy
;	COMDAT ?GetElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QBEABQAVCvCity@@I@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QBEABQAVCvCity@@I@Z PROC ; CvWeightedVector<CvCity *,64,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QBEABQAVCvCity@@I@Z ENDP ; CvWeightedVector<CvCity *,64,1>::GetElement
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEHXZ ; CvWeightedVector<CvCity *,64,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEHXZ PROC ; CvWeightedVector<CvCity *,64,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEHXZ ENDP ; CvWeightedVector<CvCity *,64,1>::size
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::~_Vector_val<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::~_Vector_val<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::~_Vector_val<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??1?$_List_nod@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_List_nod<int,std::allocator<int> >::~_List_nod<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_List_nod@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_nod@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_List_nod<int,std::allocator<int> >::~_List_nod<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_List_nod@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_List_nod<int,std::allocator<int> >::~_List_nod<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::destroy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z PROC ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXPAVCvHomelandUnit@@I@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::Free
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXPAVCvHomelandUnit@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXPAVCvHomelandUnit@@I@Z PROC ; FStaticVector<CvHomelandUnit,64,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXPAVCvHomelandUnit@@I@Z ENDP ; FStaticVector<CvHomelandUnit,64,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEXPAVCvHomelandMove@@I@Z ; FStaticVector<CvHomelandMove,35,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEXPAVCvHomelandMove@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEXPAVCvHomelandMove@@I@Z PROC ; FStaticVector<CvHomelandMove,35,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@2:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEXPAVCvHomelandMove@@I@Z ENDP ; FStaticVector<CvHomelandMove,35,1,297,0>::Free
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE@V?$allocator@VCvHomelandTarget@@@1@@Z ; std::_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE@V?$allocator@VCvHomelandTarget@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE@V?$allocator@VCvHomelandTarget@@@1@@Z PROC ; std::_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE@V?$allocator@VCvHomelandTarget@@@1@@Z ENDP ; std::_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Vector_val<CvHomelandTarget,std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::_Vector_val<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z PROC ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::_Vector_val<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE@V?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::_Vector_val<CvPlot *,std::allocator<CvPlot *> >::_Vector_val<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	?Alloc@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEPAU?$pair@HPAVCvPlot@@@std@@I@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::Alloc
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEPAU?$pair@HPAVCvPlot@@@std@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEPAU?$pair@HPAVCvPlot@@@std@@I@Z PROC ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 503  : 	T* Alloc( unsigned int uiSize ){

	push	esi

; 504  : 		if( uiSize > 0 ){

	mov	esi, DWORD PTR _uiSize$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jbe	SHORT $LN1@Alloc@6

; 505  :             
; 506  :             T* pRet = (T*)FAST_VEC_ALLOC::AllocAligned( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	85					; 00000055H
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	lea	eax, DWORD PTR [esi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 507  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi

; 511  : 	};

	ret	4
$LN1@Alloc@6:
	pop	edi

; 508  : 			return pRet;
; 509  : 		}
; 510  : 		return NULL;

	xor	eax, eax
	pop	esi

; 511  : 	};

	ret	4
?Alloc@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEPAU?$pair@HPAVCvPlot@@@std@@I@Z ENDP ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXPAU?$pair@HPAVCvPlot@@@std@@I@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXPAU?$pair@HPAVCvPlot@@@std@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXPAU?$pair@HPAVCvPlot@@@std@@I@Z PROC ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::Free, COMDAT
; _this$ = ecx

; 516  : 		if( !bPODType) 
; 517  :             Destroy(pVal, uiNumElements);
; 518  : 
; 519  : 		FAST_VEC_ALLOC::FreeAligned( (void*)pVal );

	mov	eax, DWORD PTR _pVal$[esp-4]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 520  : 	};

	ret	8
?Free@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXPAU?$pair@HPAVCvPlot@@@std@@I@Z ENDP ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::Free
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@PAVCvHomelandTarget@@@Z ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@PAVCvHomelandTarget@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@PAVCvHomelandTarget@@@Z PROC ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@PAVCvHomelandTarget@@@Z ENDP ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ; std::list<int,std::allocator<int> >::_Iterator<0>::_Iterator<0>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z PROC ; std::list<int,std::allocator<int> >::_Iterator<0>::_Iterator<0>, COMDAT
; _this$ = ecx

; 367  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 368  : 			}

	ret	4
??0?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QAE@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ENDP ; std::list<int,std::allocator<int> >::_Iterator<0>::_Iterator<0>
_TEXT	ENDS
PUBLIC	??D?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEABHXZ PROC ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator*, COMDAT
; _this$ = ecx

; 212  : 
; 213  :  #if _HAS_ITERATOR_DEBUGGING
; 214  : 			if (this->_Mycont == 0
; 215  : 				|| _Ptr == 0
; 216  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 217  : 				{
; 218  : 				_DEBUG_ERROR("list iterator not dereferencable");
; 219  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 220  : 				}
; 221  :  #else
; 222  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());
; 223  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 224  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 225  : 
; 226  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 227  : 			}

	ret	0
??D?$_Const_iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::list<int,std::allocator<int> >::_Const_iterator<0>::operator*
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::_Vector_val<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z PROC ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::_Vector_val<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE@V?$allocator@PAVCvCity@@@1@@Z ENDP ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::_Vector_val<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_iterator<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z PROC ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_iterator<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@PAPAVCvCity@@@Z ENDP ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::_Vector_iterator<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z PROC ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@PAPAVCvPlot@@@Z ENDP ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 100			; 00000064H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAEXXZ ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAEXXZ PROC ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$00@@QAEXXZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,1>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>
_TEXT	ENDS
PUBLIC	?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ; std::list<int,std::allocator<int> >::_Make_iter
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z PROC ; std::list<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 580  : 		return (iterator(_Where._Ptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 581  : 		}

	ret	8
?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ENDP ; std::list<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z PROC ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@YAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<int,std::allocator<int> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::construct
; Function compile flags: /Ogtpy
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z PROC ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@PAU_Node@?$_List_nod@HV?$allocator@H@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<int,std::allocator<int> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEIXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?max_size@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEIXZ PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 214748364				; 0cccccccH

; 732  : 		}

	ret	0
?max_size@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VCvHomelandTarget@@@std@@QAEPAVCvHomelandTarget@@I@Z ; std::allocator<CvHomelandTarget>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VCvHomelandTarget@@@std@@QAEPAVCvHomelandTarget@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VCvHomelandTarget@@@std@@QAEPAVCvHomelandTarget@@I@Z PROC ; std::allocator<CvHomelandTarget>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@VCvHomelandTarget@@@std@@YAPAVCvHomelandTarget@@IPAV1@@Z ; std::_Allocate<CvHomelandTarget>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@VCvHomelandTarget@@@std@@QAEPAVCvHomelandTarget@@I@Z ENDP ; std::allocator<CvHomelandTarget>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvPlot@@@std@@QAEPAPAVCvPlot@@I@Z ; std::allocator<CvPlot *>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvPlot@@@std@@QAEPAPAVCvPlot@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvPlot@@@std@@QAEPAPAVCvPlot@@I@Z PROC ; std::allocator<CvPlot *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ; std::_Allocate<CvPlot *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvPlot@@@std@@QAEPAPAVCvPlot@@I@Z ENDP ; std::allocator<CvPlot *>::allocate
_TEXT	ENDS
PUBLIC	?SetSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::SetSize
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?SetSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
_pTemp$ = 8						; size = 4
_uiFit$ = 8						; size = 4
?SetSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z PROC ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::SetSize, COMDAT
; _this$ = ecx

; 468  : 	void SetSize(unsigned int uiFit){

	push	ebx

; 469  : 
; 470  : 		unsigned int nOld = m_uiCurrSize;
; 471  : 
; 472  : 		m_uiCurrSize = MIN( m_uiCurrSize, uiFit );

	mov	ebx, DWORD PTR _uiFit$[esp]
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	ebp, DWORD PTR [edi+4]
	lea	esi, DWORD PTR [edi+4]
	lea	eax, DWORD PTR _uiFit$[esp+12]
	cmp	ebx, ebp
	jb	SHORT $LN17@SetSize
	mov	eax, esi
$LN17@SetSize:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax

; 473  : 
; 474  : 		T* pTemp = NULL;

	xor	eax, eax
	mov	DWORD PTR _pTemp$[esp+12], eax

; 475  : 		if( uiFit > 0 ){

	cmp	ebx, eax
	jbe	SHORT $LN9@SetSize

; 476  : 			pTemp = Alloc(uiFit);

	push	85					; 00000055H
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	lea	ecx, DWORD PTR [ebx*8]
	push	4
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [edi+8], ebx
	mov	DWORD PTR _pTemp$[esp+12], eax

; 477  : 			if (pTemp)

	test	eax, eax
	je	SHORT $LN8@SetSize

; 478  : 			{
; 479  : 				if( bPODType ){
; 480  : 					memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 481  : 				}else{
; 482  : 					for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	ecx, ecx
	cmp	DWORD PTR [esi], ecx
	jbe	SHORT $LN3@SetSize
$LL40@SetSize:

; 483  : 						new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	eax, eax
	je	SHORT $LN4@SetSize
	mov	edx, DWORD PTR [edi]
	mov	ebp, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR [eax], ebp
	mov	edx, DWORD PTR [edx+ecx*8+4]
	mov	DWORD PTR [eax+4], edx
$LN4@SetSize:
	inc	ecx
	add	eax, 8
	cmp	ecx, DWORD PTR [esi]
	jb	SHORT $LL40@SetSize
$LN3@SetSize:

; 484  : 				}
; 485  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [edi+8], ebx

; 491  : 				return;
; 492  : 			}
; 493  : 		}
; 494  : 		else

	jmp	SHORT $LN1@SetSize
$LN8@SetSize:
	pop	edi

; 486  : 			}
; 487  : 			else
; 488  : 			{
; 489  : 				FAssertMsg2(0, "Failed to set array size from %u to %u", nOld, uiFit);
; 490  : 				m_uiCurrSize = nOld;

	mov	DWORD PTR [esi], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 500  : 	};

	ret	4
$LN9@SetSize:

; 495  : 		{
; 496  : 			m_uiCurrMaxSize = 0;

	mov	DWORD PTR [edi+8], eax
$LN1@SetSize:

; 497  : 		}
; 498  : 		Free(m_pData, nOld);

	mov	eax, DWORD PTR [edi]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking

; 499  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _pTemp$[esp+16]
	add	esp, 4
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 500  : 	};

	ret	4
?SetSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::SetSize
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z ; std::allocator<CvCity *>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z PROC ; std::allocator<CvCity *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvCity@@@std@@QAEPAPAVCvCity@@I@Z ENDP ; std::allocator<CvCity *>::allocate
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::Free
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@3

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@3:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z PROC ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@4

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@4:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::Free
_TEXT	ENDS
PUBLIC	?construct@?$allocator@H@std@@QAEXPAHABH@Z	; std::allocator<int>::construct
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?construct@?$allocator@H@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@H@std@@QAEXPAHABH@Z PROC		; std::allocator<int>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN5@construct@2:

; 156  : 		}

	ret	8
?construct@?$allocator@H@std@@QAEXPAHABH@Z ENDP		; std::allocator<int>::construct
_TEXT	ENDS
PUBLIC	?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ; std::list<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::list<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 625  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 626  : 		}

	ret	0
?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::list<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_List_nod@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_List_nod<int,std::allocator<int> >::_List_nod<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_List_nod@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_List_nod<int,std::allocator<int> >::_List_nod<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct allocator from _Al

	mov	eax, ecx

; 48   : 		}

	ret	4
??0?$_List_nod@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_List_nod<int,std::allocator<int> >::_List_nod<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator+=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+=
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::Free
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@5

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@5:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::Free
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvHomelandTarget@@PAV1@@stdext@@YAPAVCvHomelandTarget@@PAV1@00@Z ; stdext::unchecked_copy<CvHomelandTarget *,CvHomelandTarget *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvHomelandTarget@@PAV1@@stdext@@YAPAVCvHomelandTarget@@PAV1@00@Z
_TEXT	SEGMENT
$T240366 = -4						; size = 1
__Cat$240371 = -4					; size = 1
$T240368 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvHomelandTarget@@PAV1@@stdext@@YAPAVCvHomelandTarget@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvHomelandTarget *,CvHomelandTarget *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	BYTE PTR $T240366[esp+4], 0
	mov	eax, DWORD PTR $T240366[esp+4]
	mov	ecx, DWORD PTR __Cat$240371[esp+4]
	mov	edx, DWORD PTR $T240368[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>

; 3607 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_copy@PAVCvHomelandTarget@@PAV1@@stdext@@YAPAVCvHomelandTarget@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvHomelandTarget *,CvHomelandTarget *>
_TEXT	ENDS
PUBLIC	??$fill@PAVCvHomelandTarget@@V1@@std@@YAXPAVCvHomelandTarget@@0ABV1@@Z ; std::fill<CvHomelandTarget *,CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAVCvHomelandTarget@@V1@@std@@YAXPAVCvHomelandTarget@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCvHomelandTarget@@V1@@std@@YAXPAVCvHomelandTarget@@0ABV1@@Z PROC ; std::fill<CvHomelandTarget *,CvHomelandTarget>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	jmp	??$_Fill@PAVCvHomelandTarget@@V1@@std@@YAXPAVCvHomelandTarget@@0ABV1@@Z ; std::_Fill<CvHomelandTarget *,CvHomelandTarget>
??$fill@PAVCvHomelandTarget@@V1@@std@@YAXPAVCvHomelandTarget@@0ABV1@@Z ENDP ; std::fill<CvHomelandTarget *,CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@@Z ; std::_Destroy_range<std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPlot *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@0AAV?$allocator@PAVCvPlot@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ; std::fill<CvPlot * *,CvPlot *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z PROC ; std::fill<CvPlot * *,CvPlot *>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ENDP ; std::fill<CvPlot * *,CvPlot *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z ; std::_Destroy_range<std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvCity *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@0AAV?$allocator@PAVCvCity@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::fill<CvCity * *,CvCity *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z PROC ; std::fill<CvCity * *,CvCity *>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@2
	pop	esi
$LN3@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ENDP ; std::fill<CvCity * *,CvCity *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T240430 = -4						; size = 1
__Cat$240434 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __First_dest_cat$[esp]
	mov	BYTE PTR $T240430[esp+4], 0
	mov	eax, DWORD PTR $T240430[esp+4]
	mov	ecx, DWORD PTR __Cat$240434[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>

; 2755 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Move_backward_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAPAVCvPlot@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvPlot * *,CvPlot * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@2:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAPAVCvCity@@PAPAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvCity * *,CvCity * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCvHomelandTarget@@@std@@QAEXPAVCvHomelandTarget@@ABV3@@Z ; std::allocator<CvHomelandTarget>::construct
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?construct@?$allocator@VCvHomelandTarget@@@std@@QAEXPAVCvHomelandTarget@@ABV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCvHomelandTarget@@@std@@QAEXPAVCvHomelandTarget@@ABV3@@Z PROC ; std::allocator<CvHomelandTarget>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct@3
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx
$LN5@construct@3:

; 156  : 		}

	ret	8
?construct@?$allocator@VCvHomelandTarget@@@std@@QAEXPAVCvHomelandTarget@@ABV3@@Z ENDP ; std::allocator<CvHomelandTarget>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VCvHomelandTarget@@@std@@QAEXPAVCvHomelandTarget@@@Z ; std::allocator<CvHomelandTarget>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@VCvHomelandTarget@@@std@@QAEXPAVCvHomelandTarget@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCvHomelandTarget@@@std@@QAEXPAVCvHomelandTarget@@@Z PROC ; std::allocator<CvHomelandTarget>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@VCvHomelandTarget@@@std@@QAEXPAVCvHomelandTarget@@@Z ENDP ; std::allocator<CvHomelandTarget>::destroy
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandMove>::~_Temp_iterator<CvHomelandMove>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ PROC	; std::_Temp_iterator<CvHomelandMove>::~_Temp_iterator<CvHomelandMove>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ ENDP	; std::_Temp_iterator<CvHomelandMove>::~_Temp_iterator<CvHomelandMove>
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandTarget>::~_Temp_iterator<CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ PROC ; std::_Temp_iterator<CvHomelandTarget>::~_Temp_iterator<CvHomelandTarget>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera@2

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera@2:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<CvHomelandTarget>::~_Temp_iterator<CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ PROC	; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera@3

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera@3:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ENDP	; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
_TEXT	ENDS
PUBLIC	?isEmbarked@CvUnit@@QBE_NXZ			; CvUnit::isEmbarked
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?isEmbarked@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?isEmbarked@CvUnit@@QBE_NXZ PROC			; CvUnit::isEmbarked, COMDAT
; _this$ = ecx

; 257  : 		return m_bEmbarked;

	mov	al, BYTE PTR [ecx+1652]

; 258  : 	}

	ret	0
?isEmbarked@CvUnit@@QBE_NXZ ENDP			; CvUnit::isEmbarked
_TEXT	ENDS
PUBLIC	?GetID@CvUnit@@QBEHXZ				; CvUnit::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvUnit@@QBEHXZ PROC				; CvUnit::GetID, COMDAT
; _this$ = ecx

; 662  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+100]

; 663  : 	}

	ret	0
?GetID@CvUnit@@QBEHXZ ENDP				; CvUnit::GetID
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	??$_Distance@PAVCvHomelandMove@@H@std@@YAXPAVCvHomelandMove@@0AAH@Z ; std::_Distance<CvHomelandMove *,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Distance@PAVCvHomelandMove@@H@std@@YAXPAVCvHomelandMove@@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@PAVCvHomelandMove@@H@std@@YAXPAVCvHomelandMove@@0AAH@Z PROC ; std::_Distance<CvHomelandMove *,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 3
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@PAVCvHomelandMove@@H@std@@YAXPAVCvHomelandMove@@0AAH@Z ENDP ; std::_Distance<CvHomelandMove *,int>
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
PUBLIC	?IsCombatUnit@CvUnit@@QBE_NXZ			; CvUnit::IsCombatUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsCombatUnit@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?IsCombatUnit@CvUnit@@QBE_NXZ PROC			; CvUnit::IsCombatUnit, COMDAT
; _this$ = ecx

; 1243 : 		return (m_iBaseCombat > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+1044], eax
	setg	al

; 1244 : 	}

	ret	0
?IsCombatUnit@CvUnit@@QBE_NXZ ENDP			; CvUnit::IsCombatUnit
_TEXT	ENDS
PUBLIC	??$_Distance@PAVCvHomelandUnit@@H@std@@YAXPAVCvHomelandUnit@@0AAH@Z ; std::_Distance<CvHomelandUnit *,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Distance@PAVCvHomelandUnit@@H@std@@YAXPAVCvHomelandUnit@@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@PAVCvHomelandUnit@@H@std@@YAXPAVCvHomelandUnit@@0AAH@Z PROC ; std::_Distance<CvHomelandUnit *,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 4
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@PAVCvHomelandUnit@@H@std@@YAXPAVCvHomelandUnit@@0AAH@Z ENDP ; std::_Distance<CvHomelandUnit *,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@3
	push	esi
$LL6@Uninit_cop@3:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@3
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], esi
$LN5@Uninit_cop@3:
	add	ecx, 20					; 00000014H
	add	eax, 20					; 00000014H
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@3
	pop	esi
$LN4@Uninit_cop@3:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??$advance@PAVCvHomelandMove@@H@std@@YAXAAPAVCvHomelandMove@@H@Z ; std::advance<CvHomelandMove *,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$advance@PAVCvHomelandMove@@H@std@@YAXAAPAVCvHomelandMove@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAVCvHomelandMove@@H@std@@YAXAAPAVCvHomelandMove@@H@Z PROC ; std::advance<CvHomelandMove *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAVCvHomelandMove@@H@std@@YAXAAPAVCvHomelandMove@@H@Z ENDP ; std::advance<CvHomelandMove *,int>
_TEXT	ENDS
PUBLIC	??$_Distance2@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Distance2@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
_TEXT	ENDS
PUBLIC	??$advance@PAVCvHomelandUnit@@H@std@@YAXAAPAVCvHomelandUnit@@H@Z ; std::advance<CvHomelandUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$advance@PAVCvHomelandUnit@@H@std@@YAXAAPAVCvHomelandUnit@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAVCvHomelandUnit@@H@std@@YAXAAPAVCvHomelandUnit@@H@Z PROC ; std::advance<CvHomelandUnit *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR __Where$[esp-4]
	shl	ecx, 4
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAVCvHomelandUnit@@H@std@@YAXAAPAVCvHomelandUnit@@H@Z ENDP ; std::advance<CvHomelandUnit *,int>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::iter_swap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::iter_swap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap@2
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap@2:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCvPlot@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAVCvPlot@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVCvPlot@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@3
	pop	esi
$LN3@Fill_n@3:

; 3243 : 	}

	ret	0
??$_Fill_n@PAPAVCvPlot@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<CvPlot * *,unsigned int,CvPlot *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<CvCity * *,unsigned int,CvCity *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<CvCity * *,unsigned int,CvCity *,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@4
	pop	esi
$LN3@Fill_n@4:

; 3243 : 	}

	ret	0
??$_Fill_n@PAPAVCvCity@@IPAV1@Urandom_access_iterator_tag@std@@@std@@YAXPAPAVCvCity@@IABQAV1@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<CvCity * *,unsigned int,CvCity *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvHomelandMove@@@std@@YA?AU?$pair@PAVCvHomelandMove@@H@0@H@Z ; std::get_temporary_buffer<CvHomelandMove>
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Ogtpy
;	COMDAT ??$get_temporary_buffer@VCvHomelandMove@@@std@@YA?AU?$pair@PAVCvHomelandMove@@H@0@H@Z
_TEXT	SEGMENT
$T240770 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T240774 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvHomelandMove@@@std@@YA?AU?$pair@PAVCvHomelandMove@@H@0@H@Z PROC ; std::get_temporary_buffer<CvHomelandMove>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor
	npad	12
$LL4@get_tempor:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	lea	edx, DWORD PTR [esi*8]
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor
$LN15@get_tempor:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 8
	jae	SHORT $LN5@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T240774[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T240770[esp+20]
	mov	DWORD PTR $T240774[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T240770[esp+20]
	push	ecx
	mov	DWORD PTR $T240770[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor:
$LN17@get_tempor:
	int	3
??$get_temporary_buffer@VCvHomelandMove@@@std@@YA?AU?$pair@PAVCvHomelandMove@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvHomelandTarget@@@std@@YA?AU?$pair@PAVCvHomelandTarget@@H@0@H@Z ; std::get_temporary_buffer<CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$get_temporary_buffer@VCvHomelandTarget@@@std@@YA?AU?$pair@PAVCvHomelandTarget@@H@0@H@Z
_TEXT	SEGMENT
$T240786 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T240790 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvHomelandTarget@@@std@@YA?AU?$pair@PAVCvHomelandTarget@@H@0@H@Z PROC ; std::get_temporary_buffer<CvHomelandTarget>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor@2

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor@2:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor@2
$LL4@get_tempor@2:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	lea	edx, DWORD PTR [esi+esi*4]
	add	edx, edx
	add	edx, edx
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor@2
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor@2
$LN15@get_tempor@2:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor@2:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN5@get_tempor@2

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T240790[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T240786[esp+20]
	mov	DWORD PTR $T240790[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T240786[esp+20]
	push	ecx
	mov	DWORD PTR $T240786[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor@2:
$LN17@get_tempor@2:
	int	3
??$get_temporary_buffer@VCvHomelandTarget@@@std@@YA?AU?$pair@PAVCvHomelandTarget@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvHomelandUnit@@@std@@YA?AU?$pair@PAVCvHomelandUnit@@H@0@H@Z ; std::get_temporary_buffer<CvHomelandUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$get_temporary_buffer@VCvHomelandUnit@@@std@@YA?AU?$pair@PAVCvHomelandUnit@@H@0@H@Z
_TEXT	SEGMENT
$T240802 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T240806 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvHomelandUnit@@@std@@YA?AU?$pair@PAVCvHomelandUnit@@H@0@H@Z PROC ; std::get_temporary_buffer<CvHomelandUnit>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor@3

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor@3:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor@3
$LL4@get_tempor@3:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	mov	edx, esi
	shl	edx, 4
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor@3
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor@3
$LN15@get_tempor@3:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor@3:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN5@get_tempor@3

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T240806[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T240802[esp+20]
	mov	DWORD PTR $T240806[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T240802[esp+20]
	push	ecx
	mov	DWORD PTR $T240802[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor@3:
$LN17@get_tempor@3:
	int	3
??$get_temporary_buffer@VCvHomelandUnit@@@std@@YA?AU?$pair@PAVCvHomelandUnit@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CvHomelandMove>::_Temp_iterator<CvHomelandMove>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<CvHomelandMove>::_Temp_iterator<CvHomelandMove>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<CvHomelandMove>::_Temp_iterator<CvHomelandMove>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CvHomelandTarget>::_Temp_iterator<CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<CvHomelandTarget>::_Temp_iterator<CvHomelandTarget>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<CvHomelandTarget>::_Temp_iterator<CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CvHomelandUnit>::_Temp_iterator<CvHomelandUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<CvHomelandUnit>::_Temp_iterator<CvHomelandUnit>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<CvHomelandUnit>::_Temp_iterator<CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z ; std::_Adjust_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Adjust_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Top$ = 12						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
__Pred$ = 28						; size = 4
??$_Adjust_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z PROC ; std::_Adjust_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 2108 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

	push	ebx

; 2109 : 	_Diff _Top = _Hole;

	mov	ebx, DWORD PTR __Hole$[esp]
	push	ebp

; 2110 : 	_Diff _Idx = 2 * _Hole + 2;
; 2111 : 
; 2112 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ebp, DWORD PTR __Bottom$[esp+4]
	push	esi
	lea	esi, DWORD PTR [ebx+ebx+2]
	cmp	esi, ebp
	push	edi
	mov	edi, DWORD PTR __First$[esp+12]
	mov	DWORD PTR __Top$[esp+12], ebx
	jge	SHORT $LN10@Adjust_hea
	npad	4
$LL5@Adjust_hea:

; 2113 : 		{	// move _Hole down to larger child
; 2114 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

	lea	eax, DWORD PTR [edi+esi*8]
	lea	ecx, DWORD PTR [eax-8]
	push	ecx
	push	eax
	call	DWORD PTR __Pred$[esp+20]
	add	esp, 8
	test	al, al
	je	SHORT $LN2@Adjust_hea

; 2115 : 			--_Idx;

	dec	esi
$LN2@Adjust_hea:

; 2116 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	edx, DWORD PTR [edi+esi*8]
	mov	DWORD PTR [edi+ebx*8], edx
	mov	eax, DWORD PTR [edi+esi*8+4]
	mov	DWORD PTR [edi+ebx*8+4], eax
	mov	ebx, esi
	lea	esi, DWORD PTR [esi+esi+2]
	cmp	esi, ebp
	jl	SHORT $LL5@Adjust_hea
$LN10@Adjust_hea:

; 2117 : 		}
; 2118 : 
; 2119 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2120 : 		{	// only child at bottom, move _Hole down to it
; 2121 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	ecx, DWORD PTR [edi+ebp*8-8]
	mov	DWORD PTR [edi+ebx*8], ecx
	mov	edx, DWORD PTR [edi+ebp*8-4]
	mov	DWORD PTR [edi+ebx*8+4], edx

; 2122 : 		_Hole = _Bottom - 1;

	lea	ebx, DWORD PTR [ebp-1]
$LN1@Adjust_hea:

; 2123 : 		}
; 2124 : 	std::_Push_heap(_First, _Hole, _Top, _Val, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+12]
	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, DWORD PTR __Val$[esp+12]
	push	eax
	mov	eax, DWORD PTR __Top$[esp+16]
	push	ecx
	push	edx
	push	eax
	push	ebx
	push	edi
	call	??$_Push_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z ; std::_Push_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2125 : 	}

	ret	0
??$_Adjust_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z ENDP ; std::_Adjust_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@stdext@@YAPAU?$pair@HPAVCvPlot@@@std@@PAU12@00@Z ; stdext::unchecked_copy_backward<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@stdext@@YAPAU?$pair@HPAVCvPlot@@@std@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@stdext@@YAPAU?$pair@HPAVCvPlot@@@std@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@3
	push	esi
$LL8@unchecked_@3:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@3
	pop	esi
$LN7@unchecked_@3:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@stdext@@YAPAU?$pair@HPAVCvPlot@@@std@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAVCvHomelandMove@@PAV1@@std@@YAXPAVCvHomelandMove@@0@Z ; std::iter_swap<CvHomelandMove *,CvHomelandMove *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$iter_swap@PAVCvHomelandMove@@PAV1@@std@@YAXPAVCvHomelandMove@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAVCvHomelandMove@@PAV1@@std@@YAXPAVCvHomelandMove@@0@Z PROC ; std::iter_swap<CvHomelandMove *,CvHomelandMove *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap@3
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap@3:

; 595  : 	}

	ret	0
??$iter_swap@PAVCvHomelandMove@@PAV1@@std@@YAXPAVCvHomelandMove@@0@Z ENDP ; std::iter_swap<CvHomelandMove *,CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$_Advance@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Advance@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
_TEXT	ENDS
PUBLIC	??$iter_swap@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z ; std::iter_swap<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$iter_swap@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z PROC ; std::iter_swap<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR __Left$[esp-4]
	push	eax
	push	ecx
	call	??$swap@VCvHomelandTarget@@@std@@YAXAAVCvHomelandTarget@@0@Z ; std::swap<CvHomelandTarget>
	add	esp, 8

; 595  : 	}

	ret	0
??$iter_swap@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z ENDP ; std::iter_swap<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$iter_swap@PAVCvHomelandUnit@@PAV1@@std@@YAXPAVCvHomelandUnit@@0@Z ; std::iter_swap<CvHomelandUnit *,CvHomelandUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$iter_swap@PAVCvHomelandUnit@@PAV1@@std@@YAXPAVCvHomelandUnit@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAVCvHomelandUnit@@PAV1@@std@@YAXPAVCvHomelandUnit@@0@Z PROC ; std::iter_swap<CvHomelandUnit *,CvHomelandUnit *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap@4
	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR [eax+12]
	push	ebp
	mov	ebp, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+12], ebx
	pop	ebx
$LN3@iter_swap@4:

; 595  : 	}

	ret	0
??$iter_swap@PAVCvHomelandUnit@@PAV1@@std@@YAXPAVCvHomelandUnit@@0@Z ENDP ; std::iter_swap<CvHomelandUnit *,CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	jle	SHORT $LN10@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN10@Med3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN19@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3
	mov	edi, DWORD PTR [edx]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	pop	ebx
$LN19@Med3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN28@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN28@Med3:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	edx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	eax, esi
	push	edi
	mov	edi, edx
	jge	SHORT $LN14@Adjust_hea@2
	npad	7
$LL5@Adjust_hea@2:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [ecx+eax*8+4]
	cmp	ebx, DWORD PTR [ecx+eax*8-4]
	jle	SHORT $LN2@Adjust_hea@2

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea@2:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [ecx+edx*8+4], ebx
	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea@2
$LN14@Adjust_hea@2:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea@2

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	edx, DWORD PTR [esi-1]
$LN1@Adjust_hea@2:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	push	edi
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+24]
	push	edx
	push	ecx
	mov	DWORD PTR [eax+4], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@4
	push	esi
$LL8@unchecked_@4:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@4
	pop	esi
$LN7@unchecked_@4:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	jle	SHORT $LN10@Med3@2

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3@2
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN10@Med3@2:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN19@Med3@2

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3@2
	mov	edi, DWORD PTR [edx]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	pop	ebx
$LN19@Med3@2:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN28@Med3@2

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3@2
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN28@Med3@2:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	edx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	eax, esi
	push	edi
	mov	edi, edx
	jge	SHORT $LN14@Adjust_hea@3
	npad	7
$LL5@Adjust_hea@3:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [ecx+eax*8+4]
	cmp	ebx, DWORD PTR [ecx+eax*8-4]
	jle	SHORT $LN2@Adjust_hea@3

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea@3:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [ecx+edx*8+4], ebx
	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea@3
$LN14@Adjust_hea@3:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea@3

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	edx, DWORD PTR [esi-1]
$LN1@Adjust_hea@3:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	push	edi
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+24]
	push	edx
	push	ecx
	mov	DWORD PTR [eax+4], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@5
	push	esi
$LL8@unchecked_@5:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@5
	pop	esi
$LN7@unchecked_@5:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??F?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator--
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??F?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator--, COMDAT
; _this$ = ecx

; 361  : 		{	// predecrement

	mov	eax, ecx

; 362  : 		--(*(_Mybase *)this);

	add	DWORD PTR [eax], -20			; ffffffecH

; 363  : 		return (*this);
; 364  : 		}

	ret	0
??F?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator--
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAVCvHomelandMove@@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvHomelandMove *,CvHomelandMove *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAVCvHomelandMove@@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAVCvHomelandMove@@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@00@Z PROC ; stdext::unchecked_copy_backward<CvHomelandMove *,CvHomelandMove *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@6
	push	esi
$LL8@unchecked_@6:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@6
	pop	esi
$LN7@unchecked_@6:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAVCvHomelandMove@@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@00@Z ENDP ; stdext::unchecked_copy_backward<CvHomelandMove *,CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@PAVCvHomelandMove@@PAV1@PAV1@@std@@YAPAVCvHomelandMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Merge_backward@PAVCvHomelandMove@@PAV1@PAV1@@std@@YAPAVCvHomelandMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Merge_backward@PAVCvHomelandMove@@PAV1@PAV1@@std@@YAPAVCvHomelandMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>, COMDAT

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	ecx, DWORD PTR __Last1$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	edx, DWORD PTR __Last2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __First1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __First2$[esp+8]
	cmp	esi, ecx
	je	SHORT $LN37@Merge_back
	npad	5
$LL8@Merge_back:

; 2714 : 		else if (_First2 == _Last2)

	cmp	edi, edx
	je	SHORT $LN38@Merge_back

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	ebx, DWORD PTR [edx-4]
	sub	edx, 8
	sub	ecx, 8

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	sub	eax, 8
	cmp	ebx, DWORD PTR [ecx+4]
	jle	SHORT $LN2@Merge_back
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	add	edx, 8

; 2718 : 		else

	jmp	SHORT $LN42@Merge_back
$LN2@Merge_back:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [edx+4]
	add	ecx, 8
$LN42@Merge_back:
	mov	DWORD PTR [eax+4], ebx
	cmp	esi, ecx
	jne	SHORT $LL8@Merge_back
$LN37@Merge_back:

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	ecx, edx
	cmp	edi, edx
	je	SHORT $LN7@Merge_back
	npad	8
$LL18@Merge_back:
	mov	edx, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	cmp	ecx, edi
	jne	SHORT $LL18@Merge_back
	pop	edi
	pop	esi
	pop	ebx

; 2720 : 	}

	ret	0
$LN38@Merge_back:

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	cmp	esi, ecx
	je	SHORT $LN7@Merge_back
	npad	3
$LL28@Merge_back:
	mov	edx, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	cmp	ecx, esi
	jne	SHORT $LL28@Merge_back
$LN7@Merge_back:
	pop	edi
	pop	esi
	pop	ebx

; 2720 : 	}

	ret	0
??$_Merge_backward@PAVCvHomelandMove@@PAV1@PAV1@@std@@YAPAVCvHomelandMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$_Lower_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvHomelandMove *,CvHomelandMove,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Lower_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Lower_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z PROC ; std::_Lower_bound<CvHomelandMove *,CvHomelandMove,int>, COMDAT

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;
; 2255 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	sar	ecx, 3

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN22@Lower_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	npad	6
$LL4@Lower_boun:

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2260 : 		_FwdIt _Mid = _First;
; 2261 : 		std::advance(_Mid, _Count2);
; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	cmp	DWORD PTR [esi+eax*8+4], edi
	jle	SHORT $LN2@Lower_boun

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	sub	edx, eax
	lea	esi, DWORD PTR [esi+eax*8+8]
	add	ecx, edx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2267 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Lower_boun:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Lower_boun
	pop	edi
$LN22@Lower_boun:

; 2268 : 		}
; 2269 : 	return (_First);

	mov	eax, esi
	pop	esi

; 2270 : 	}

	ret	0
??$_Lower_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z ENDP ; std::_Lower_bound<CvHomelandMove *,CvHomelandMove,int>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvHomelandMove *,CvHomelandMove,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Upper_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z PROC ; std::_Upper_bound<CvHomelandMove *,CvHomelandMove,int>, COMDAT

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;
; 2327 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	sar	ecx, 3

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN22@Upper_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	npad	6
$LL4@Upper_boun:

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2331 : 		_FwdIt _Mid = _First;
; 2332 : 		std::advance(_Mid, _Count2);
; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	cmp	edi, DWORD PTR [esi+eax*8+4]
	jg	SHORT $LN2@Upper_boun

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	sub	edx, eax
	lea	esi, DWORD PTR [esi+eax*8+8]
	add	ecx, edx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2338 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Upper_boun:

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Upper_boun
	pop	edi
$LN22@Upper_boun:

; 2339 : 		}
; 2340 : 	return (_First);

	mov	eax, esi
	pop	esi

; 2341 : 	}

	ret	0
??$_Upper_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z ENDP ; std::_Upper_bound<CvHomelandMove *,CvHomelandMove,int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvHomelandMove@@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@00@Z ; stdext::unchecked_copy<CvHomelandMove *,CvHomelandMove *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvHomelandMove@@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvHomelandMove@@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvHomelandMove *,CvHomelandMove *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@7
	push	esi
$LL9@unchecked_@7:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@7
	pop	esi
$LN7@unchecked_@7:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCvHomelandMove@@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvHomelandMove *,CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T241377 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp]
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T241377[esp+12], edi
	cmp	eax, DWORD PTR __Last$[esp+8]
	je	SHORT $LN1@Copy_opt@4
$LL13@Copy_opt@4:

; 2472 : 		*_Dest = *_First;

	push	eax
	lea	ecx, DWORD PTR __Dest$[esp+12]
	call	??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABVCvHomelandTarget@@@Z ; std::_Temp_iterator<CvHomelandTarget>::operator=
	mov	eax, DWORD PTR __First$[esp+8]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __First$[esp+8], eax
	cmp	eax, DWORD PTR __Last$[esp+8]
	jne	SHORT $LL13@Copy_opt@4
$LN1@Copy_opt@4:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	eax, DWORD PTR __Dest$[esp+24]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	cmp	eax, edi
	je	SHORT $LN43@Copy_opt@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN43@Copy_opt@4:
	pop	edi
	mov	eax, esi
	pop	esi

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvHomelandUnit *,CvHomelandUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z PROC ; stdext::unchecked_copy_backward<CvHomelandUnit *,CvHomelandUnit *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@8
	push	esi
$LL8@unchecked_@8:
	mov	esi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@8
	pop	esi
$LN7@unchecked_@8:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z ENDP ; stdext::unchecked_copy_backward<CvHomelandUnit *,CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 4
___formal$ = 32						; size = 1
??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 2839 : 	{	// merge backwards to _Dest, using _Pred

	push	ebx

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

	mov	ebx, DWORD PTR __Dest$[esp]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+8]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+12]
	cmp	DWORD PTR __First1$[esp+12], esi
	je	$LN13@Merge_back@2
	mov	ebp, DWORD PTR __Pred$[esp+12]
	npad	2
$LL8@Merge_back@2:

; 2843 : 		else if (_First2 == _Last2)

	cmp	DWORD PTR __First2$[esp+12], edi
	je	$LN14@Merge_back@2

; 2845 : 		else if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))

	mov	ecx, DWORD PTR [esi-16]
	mov	edx, DWORD PTR [esi-12]
	sub	esi, 16					; 00000010H
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edi-16]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [edi-12]
	sub	edi, 16					; 00000010H
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	call	ebp
	add	esp, 32					; 00000020H

; 2846 : 			*--_Dest = *_Last1, ++_Last2;

	sub	ebx, 16					; 00000010H
	test	al, al
	je	SHORT $LN2@Merge_back@2
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebx], eax
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ebx+4], ecx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx+8], edx
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ebx+12], eax
	add	edi, 16					; 00000010H

; 2847 : 		else

	jmp	SHORT $LN1@Merge_back@2
$LN2@Merge_back@2:

; 2848 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ebx], ecx
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [ebx+4], edx
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [ebx+8], eax
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [ebx+12], ecx
	add	esi, 16					; 00000010H
$LN1@Merge_back@2:

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

	cmp	DWORD PTR __First1$[esp+12], esi
	jne	$LL8@Merge_back@2
$LN13@Merge_back@2:

; 2842 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __First2$[esp+12]
	push	ebx
	push	edi
	push	edx

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	call	??$unchecked_copy_backward@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvHomelandUnit *,CvHomelandUnit *>
	add	esp, 12					; 0000000cH

; 2849 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
$LN14@Merge_back@2:

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	eax, DWORD PTR __First1$[esp+12]
	push	ebx
	push	esi
	push	eax
	call	??$unchecked_copy_backward@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvHomelandUnit *,CvHomelandUnit *>
	add	esp, 12					; 0000000cH

; 2849 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$_Lower_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Lower_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Lower_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z PROC ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 2289 : 	_DEBUG_POINTER(_Pred);
; 2290 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2291 : 	_Diff _Count = 0;
; 2292 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+4]
	sub	ebp, ecx
	sar	ebp, 4
	push	esi
	push	edi

; 2293 : 	for (; 0 < _Count; )

	test	ebp, ebp
	jle	SHORT $LN20@Lower_boun@2
	mov	ebx, DWORD PTR __Val$[esp+12]
	jmp	SHORT $LN4@Lower_boun@2
	npad	5
$LL21@Lower_boun@2:
	mov	ecx, DWORD PTR __First$[esp+12]
$LN4@Lower_boun@2:

; 2294 : 		{	// divide and conquer, find half that contains answer
; 2295 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ebp
	cdq
	sub	eax, edx

; 2296 : 		_FwdIt _Mid = _First;
; 2297 : 		std::advance(_Mid, _Count2);
; 2298 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2299 : 
; 2300 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))

	mov	edx, DWORD PTR [ebx+4]
	mov	edi, eax
	sar	edi, 1
	mov	esi, edi
	shl	esi, 4
	add	esi, ecx
	mov	ecx, DWORD PTR [ebx]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [esi+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[esp+44]
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN2@Lower_boun@2

; 2301 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	eax, -1
	add	esi, 16					; 00000010H
	sub	eax, edi
	mov	DWORD PTR __First$[esp+12], esi
	add	ebp, eax

; 2302 : 		else

	jmp	SHORT $LN1@Lower_boun@2
$LN2@Lower_boun@2:

; 2303 : 			_Count = _Count2;

	mov	ebp, edi
$LN1@Lower_boun@2:

; 2293 : 	for (; 0 < _Count; )

	test	ebp, ebp
	jg	SHORT $LL21@Lower_boun@2

; 2304 : 		}
; 2305 : 	return (_First);

	mov	eax, DWORD PTR __First$[esp+12]

; 2306 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
$LN20@Lower_boun@2:
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx
	ret	0
??$_Lower_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ENDP ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Upper_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z PROC ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 2360 : 	_DEBUG_POINTER(_Pred);
; 2361 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2362 : 	_Diff _Count = 0;
; 2363 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+4]
	sub	ebp, ecx
	sar	ebp, 4
	push	esi
	push	edi

; 2364 : 	for (; 0 < _Count; )

	test	ebp, ebp
	jle	$LN20@Upper_boun@2
	mov	ebx, DWORD PTR __Val$[esp+12]
	jmp	SHORT $LN4@Upper_boun@2
	npad	1
$LL21@Upper_boun@2:
	mov	ecx, DWORD PTR __First$[esp+12]
$LN4@Upper_boun@2:

; 2365 : 		{	// divide and conquer, find half that contains answer
; 2366 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ebp
	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1

; 2367 : 		_FwdIt _Mid = _First;
; 2368 : 		std::advance(_Mid, _Count2);

	mov	esi, edi
	shl	esi, 4

; 2369 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2370 : 
; 2371 : 		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))

	mov	edx, DWORD PTR [esi+ecx+4]
	add	esi, ecx
	mov	ecx, DWORD PTR [esi]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ebx+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[esp+44]
	add	esp, 32					; 00000020H
	test	al, al
	jne	SHORT $LN2@Upper_boun@2

; 2372 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	eax, -1
	add	esi, 16					; 00000010H
	sub	eax, edi
	mov	DWORD PTR __First$[esp+12], esi
	add	ebp, eax

; 2373 : 		else

	jmp	SHORT $LN1@Upper_boun@2
$LN2@Upper_boun@2:

; 2374 : 			_Count = _Count2;

	mov	ebp, edi
$LN1@Upper_boun@2:

; 2364 : 	for (; 0 < _Count; )

	test	ebp, ebp
	jg	SHORT $LL21@Upper_boun@2

; 2375 : 		}
; 2376 : 	return (_First);

	mov	eax, DWORD PTR __First$[esp+12]

; 2377 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
$LN20@Upper_boun@2:
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx
	ret	0
??$_Upper_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ENDP ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z ; stdext::unchecked_copy<CvHomelandUnit *,CvHomelandUnit *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvHomelandUnit *,CvHomelandUnit *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@9
	push	esi
$LL9@unchecked_@9:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@9
	pop	esi
$LN7@unchecked_@9:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvHomelandUnit *,CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	??$_Swap_adl@H@std@@YAXAAH0@Z			; std::_Swap_adl<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$_Swap_adl@H@std@@YAXAAH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@H@std@@YAXAAH0@Z PROC			; std::_Swap_adl<int>, COMDAT

; 31   : 	swap(_Left, _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@Swap_adl
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@Swap_adl:

; 32   : 	}

	ret	0
??$_Swap_adl@H@std@@YAXAAH0@Z ENDP			; std::_Swap_adl<int>
_TEXT	ENDS
PUBLIC	??$_Swap_adl@PAVCvPlot@@@std@@YAXAAPAVCvPlot@@0@Z ; std::_Swap_adl<CvPlot *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Swap_adl@PAVCvPlot@@@std@@YAXAAPAVCvPlot@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@PAVCvPlot@@@std@@YAXAAPAVCvPlot@@0@Z PROC	; std::_Swap_adl<CvPlot *>, COMDAT

; 31   : 	swap(_Left, _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@Swap_adl@2
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@Swap_adl@2:

; 32   : 	}

	ret	0
??$_Swap_adl@PAVCvPlot@@@std@@YAXAAPAVCvPlot@@0@Z ENDP	; std::_Swap_adl<CvPlot *>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@ABVCvHomelandMove@@@Z ; std::_Temp_iterator<CvHomelandMove>::operator=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@ABVCvHomelandMove@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@ABVCvHomelandMove@@@Z PROC ; std::_Temp_iterator<CvHomelandMove>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	jae	SHORT $LN2@operator@4
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 8
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator@4:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	test	ecx, ecx
	je	SHORT $LN7@operator@4
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edx
$LN7@operator@4:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 8
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@VCvHomelandMove@@@std@@QAEAAV01@ABVCvHomelandMove@@@Z ENDP ; std::_Temp_iterator<CvHomelandMove>::operator=
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z ; std::_Temp_iterator<CvHomelandUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z PROC ; std::_Temp_iterator<CvHomelandUnit>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	jae	SHORT $LN2@operator@5
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], esi
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], edx
	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 16			; 00000010H
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator@5:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	test	ecx, ecx
	je	SHORT $LN7@operator@5
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], esi
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], edx
$LN7@operator@5:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 16			; 00000010H
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z ENDP ; std::_Temp_iterator<CvHomelandUnit>::operator=
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00U10@P6A_NABU10@2@ZPAH@Z ; std::_Pop_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00U10@P6A_NABU10@2@ZPAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
__Pred$ = 28						; size = 4
___formal$ = 32						; size = 4
??$_Pop_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00U10@P6A_NABU10@2@ZPAH@Z PROC ; std::_Pop_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 2134 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2135 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2136 : 		_Val, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp-4]
	mov	edx, DWORD PTR __Val$[esp]
	push	ecx
	mov	ecx, DWORD PTR __Val$[esp]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+4]
	push	ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	0
	push	eax
	call	??$_Adjust_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z ; std::_Adjust_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 24					; 00000018H

; 2137 : 	}

	ret	0
??$_Pop_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00U10@P6A_NABU10@2@ZPAH@Z ENDP ; std::_Pop_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<CvHomelandMove *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Rotate@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<CvHomelandMove *>, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00PAH0@Z ; std::_Rotate<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	je	SHORT $LN27@Copy_backw@9
	npad	6
$LL2@Copy_backw@9:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp-4]
	sub	eax, 20					; 00000014H
	mov	DWORD PTR __Last$[esp-4], eax
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR __Dest$[esp-4], ecx
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	jne	SHORT $LL2@Copy_backw@9

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2678 : 	}

	ret	0
$LN27@Copy_backw@9:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$advance@PAVCvHomelandTarget@@H@std@@YAXAAPAVCvHomelandTarget@@H@Z ; std::advance<CvHomelandTarget *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$advance@PAVCvHomelandTarget@@H@std@@YAXAAPAVCvHomelandTarget@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAVCvHomelandTarget@@H@std@@YAXAAPAVCvHomelandTarget@@H@Z PROC ; std::advance<CvHomelandTarget *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAVCvHomelandTarget@@H@std@@YAXAAPAVCvHomelandTarget@@H@Z ENDP ; std::advance<CvHomelandTarget *,int>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	cmp	eax, DWORD PTR __Last$[esp-4]
	je	SHORT $LN28@Copy_opt@5
	mov	ecx, 20					; 00000014H
	push	esi
$LL12@Copy_opt@5:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi], edx
	mov	edx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR __First$[esp]
	add	DWORD PTR __Dest$[esp], ecx
	add	eax, ecx
	mov	DWORD PTR __First$[esp], eax
	cmp	eax, DWORD PTR __Last$[esp]
	jne	SHORT $LL12@Copy_opt@5

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	ecx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 2474 : 	}

	ret	0
$LN28@Copy_opt@5:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2474 : 	}

	ret	0
??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	edx, eax
	je	SHORT $LN15@Copy_backw@10
	push	esi
	npad	3
$LL2@Copy_backw@10:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	esi, DWORD PTR [eax-20]
	sub	eax, 20					; 00000014H
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR __Dest$[esp], ecx
	mov	DWORD PTR [ecx], esi
	mov	ecx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	esi, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [esi+16], ecx
	cmp	eax, edx
	jne	SHORT $LL2@Copy_backw@10

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	DWORD PTR [eax], edx
	pop	esi

; 2678 : 	}

	ret	0
$LN15@Copy_backw@10:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN16@Copy_opt@6
	push	esi
	mov	edx, 20					; 00000014H
	push	edi
$LL3@Copy_opt@6:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi], esi
	mov	esi, DWORD PTR [eax+4]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+4], esi
	mov	esi, DWORD PTR [eax+8]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+8], esi
	mov	esi, DWORD PTR [eax+12]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+12], esi
	mov	esi, DWORD PTR [eax+16]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+16], esi
	add	DWORD PTR __Dest$[esp+4], edx
	add	eax, edx
	cmp	eax, ecx
	jne	SHORT $LL3@Copy_opt@6

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 2474 : 	}

	ret	0
$LN16@Copy_opt@6:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<CvHomelandUnit *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Rotate@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<CvHomelandUnit *>, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00PAH0@Z ; std::_Rotate<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, eax
	sar	ecx, 3
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, eax
	sar	ecx, 3
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayerID$ = 8						; size = 4
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlayer::getTeam, COMDAT

; 1173 : 		return CvPreGame::teamType(ePlayerID);

	mov	eax, DWORD PTR _ePlayerID$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1174 : 	}

	ret	0

; 1173 : 		return CvPreGame::teamType(ePlayerID);

$LN3@getTeam:
	or	eax, -1

; 1174 : 	}

	ret	0
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam@2:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z		; CvPlot::isVisible
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isVisible, COMDAT
; _this$ = ecx

; 210  : 		if(eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@isVisible

; 211  : 			return false;

	xor	al, al

; 214  : 	}

	ret	4
$LN1@isVisible:

; 212  : 
; 213  : 		return ((getVisibilityCount(eTeam) > 0));

	mov	ecx, DWORD PTR [ecx+156]
	xor	edx, edx
	cmp	WORD PTR [ecx+eax*2], dx
	setg	dl
	mov	al, dl

; 214  : 	}

	ret	4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isVisible
_TEXT	ENDS
PUBLIC	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ		; CvPlot::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ PROC		; CvPlot::getTeam, COMDAT
; _this$ = ecx

; 232  : 		PlayerTypes playerID = getOwner();

	movsx	eax, BYTE PTR [ecx+4]

; 233  : 		if(playerID != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN2@getTeam@3

; 234  : 		{
; 235  : 			return CvPlayer::getTeam(playerID);

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@getTeam@3
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 240  : 		}
; 241  : 	}

	ret	0
$LN2@getTeam@3:

; 236  : 		}
; 237  : 		else
; 238  : 		{
; 239  : 			return NO_TEAM;

	or	eax, -1

; 240  : 		}
; 241  : 	}

	ret	0
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlot::getTeam
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	??MCvHomelandUnit@@QBE_NABV0@@Z			; CvHomelandUnit::operator<
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.h
;	COMDAT ??MCvHomelandUnit@@QBE_NABV0@@Z
_TEXT	SEGMENT
_unit$ = 8						; size = 4
??MCvHomelandUnit@@QBE_NABV0@@Z PROC			; CvHomelandUnit::operator<, COMDAT
; _this$ = ecx

; 55   : 		return (GetMovesToTarget() < unit.GetMovesToTarget());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _unit$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+8]
	setl	cl
	mov	al, cl

; 56   : 	}

	ret	4
??MCvHomelandUnit@@QBE_NABV0@@Z ENDP			; CvHomelandUnit::operator<
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 194  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
$LN2@plotDirect:

; 197  : 	}
; 198  : 	else
; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Ogtpy
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN5@plotXY
	mov	eax, ecx
	jmp	SHORT $LN55@plotXY
$LN5@plotXY:
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
$LN55@plotXY:
	push	esi

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	esi, DWORD PTR _iX$[esp]
	sar	eax, 1
	sub	esi, eax

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iDY$[esp]
	add	esi, DWORD PTR _iDX$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+eax]

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	test	edi, edi
	jl	SHORT $LN9@plotXY
	mov	eax, edi
	jmp	SHORT $LN56@plotXY
$LN9@plotXY:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN56@plotXY:
	sar	eax, 1
	add	esi, eax

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN13@plotXY
	cmp	edi, -2147483647			; 80000001H
	je	$LN13@plotXY
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN23@plotXY
	test	esi, esi
	jge	SHORT $LN25@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN23@plotXY
$LN25@plotXY:
	cmp	esi, ecx
	jl	SHORT $LN23@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN23@plotXY:
	cmp	BYTE PTR [ebp+4057], 0
	push	ebx
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN52@plotXY
	test	edi, edi
	jge	SHORT $LN35@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@plotXY
$LN35@plotXY:
	cmp	edi, ebx
	jl	SHORT $LN52@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN37@plotXY
$LN52@plotXY:
	mov	edx, edi
$LN37@plotXY:
	test	esi, esi
	jl	SHORT $LN17@plotXY
	cmp	esi, ecx
	jge	SHORT $LN17@plotXY
	test	edx, edx
	jl	SHORT $LN17@plotXY
	cmp	edx, ebx
	jge	SHORT $LN17@plotXY
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebx
	pop	ebp
	pop	edi
	mov	eax, ecx
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN17@plotXY:
	pop	ebx
	pop	ebp
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN13@plotXY:
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
; Function compile flags: /Ogtpy
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iDX$[esp-4]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	test	esi, esi
	setge	cl
	cmp	eax, ecx

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	mov	ecx, edx
	jne	SHORT $LN3@plotXYWith
	test	edx, edx
	jge	SHORT $LN7@plotXYWith
	neg	ecx
$LN7@plotXYWith:

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN9@plotXYWith
	neg	eax
$LN9@plotXYWith:

; 245  : 		hexRange = iAbsDX + iAbsDY;

	add	eax, ecx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN14@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	edx, edx
	jge	SHORT $LN11@plotXYWith
	neg	ecx
$LN11@plotXYWith:

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN13@plotXYWith
	neg	eax
$LN13@plotXYWith:

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	ecx, eax
	jl	SHORT $LN14@plotXYWith
	mov	eax, ecx
$LN14@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	cmp	eax, DWORD PTR _iRange$[esp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	pop	esi

; 261  : }

	ret	0
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	eax, DWORD PTR _iX$[esp]
	push	esi
	push	edx
	mov	edx, DWORD PTR _iY$[esp+8]
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	pop	esi

; 261  : }

	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
_TEXT	ENDS
PUBLIC	?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z ; CvHomelandAI::GetClosestUnitByTurnsToTarget
EXTRN	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:PROC ; TurnsToReachTarget
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z$0
__ehfuncinfo$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z
_TEXT	SEGMENT
_pBestUnit$ = -36					; size = 4
_iFailedPaths$ = -32					; size = 4
_this$ = -28						; size = 4
$T242406 = -24						; size = 4
_pLoopUnit$228775 = -20					; size = 8
__$EHRec$ = -12						; size = 12
_kMoveUnits$ = 8					; size = 4
_pTarget$ = 12						; size = 4
_iMaxTurns$ = 16					; size = 4
_ppClosestUnit$ = 20					; size = 4
_piClosestTurns$ = 24					; size = 4
?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z PROC ; CvHomelandAI::GetClosestUnitByTurnsToTarget, COMDAT
; _this$ = ecx

; 5603 : {

	push	-1
	push	__ehhandler$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H

; 5604 : 	CvUnit* pBestUnit = NULL;
; 5605 : 	int iMinTurns = MAX_INT;
; 5606 : 	MoveUnitsArray::iterator it;
; 5607 : 
; 5608 : 	int iFailedPaths = 0;
; 5609 : 	// If we see this many failed pathing attempts, we assume no unit can get to the target
; 5610 : 	const int MAX_FAILED_PATHS = 2;
; 5611 : 	// If the last failed pathing attempt was this far (raw distance) from the target, we assume no one can reach the target, even if we have not reached MAX_FAILED_PATHS
; 5612 : 	const int EARLY_OUT_FAILED_PATH_DISTANCE = 12;
; 5613 : 
; 5614 : 	// Now go through and figure out the actual number of turns, and as a result, even if it can get there at all.
; 5615 : 	// We will try and do as few as possible by stopping if we find a unit that can make it in one turn.
; 5616 : 	for(it = kMoveUnits.begin(); it != kMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _kMoveUnits$[esp+32]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	shl	eax, 4
	xor	ebp, ebp
	add	eax, edi
	mov	DWORD PTR _this$[esp+52], ecx
	mov	DWORD PTR _pBestUnit$[esp+52], ebp
	mov	ebx, 2147483647				; 7fffffffH
	mov	DWORD PTR _iFailedPaths$[esp+52], ebp
	cmp	edi, eax
	je	$LN71@GetClosest
	jmp	SHORT $LN13@GetClosest
$LL84@GetClosest:
	xor	ebp, ebp
$LN13@GetClosest:

; 5617 : 	{
; 5618 : 		UnitHandle pLoopUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _this$[esp+52]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pLoopUnit$228775[esp+52], esi
	mov	BYTE PTR _pLoopUnit$228775[esp+56], 0
	cmp	esi, ebp
	je	SHORT $LN27@GetClosest
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN27@GetClosest:
	mov	DWORD PTR __$EHRec$[esp+60], ebp

; 5619 : 		if (pLoopUnit)

	cmp	esi, ebp
	je	$LN1@GetClosest

; 5620 : 		{
; 5621 : 			int iDistance = it->GetMovesToTarget();	// Raw distance

	mov	ebp, DWORD PTR [edi+8]

; 5622 : 			if (iDistance == MAX_INT)
; 5623 : 				continue;

	mov	ecx, esi
	cmp	ebp, 2147483647				; 7fffffffH
	jne	SHORT $LN9@GetClosest
	mov	DWORD PTR __$EHRec$[esp+60], -1
	jmp	$LN86@GetClosest
$LN9@GetClosest:

; 5624 : 			int iMoves = TurnsToReachTarget(pLoopUnit.pointer(), pTarget);

	mov	edx, DWORD PTR _pTarget$[esp+48]
	push	0
	push	0
	push	0
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T242406[esp+76], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 5625 : 			it->SetMovesToTarget(iMoves);

	mov	DWORD PTR [edi+8], eax

; 5626 : 			// Did we make it at all?
; 5627 : 			if (iMoves != MAX_INT)

	cmp	eax, 2147483647				; 7fffffffH
	je	SHORT $LN8@GetClosest

; 5628 : 			{
; 5629 : 				// Reasonably close?
; 5630 : 				if (iDistance == 0 || (iMoves <= iDistance && iMoves <= iMaxTurns && iMoves < iMinTurns))

	test	ebp, ebp
	je	SHORT $LN6@GetClosest
	cmp	eax, ebp
	jg	SHORT $LN7@GetClosest
	cmp	eax, DWORD PTR _iMaxTurns$[esp+48]
	jg	SHORT $LN7@GetClosest
	cmp	eax, ebx
	jge	SHORT $LN5@GetClosest
$LN6@GetClosest:

; 5631 : 				{
; 5632 : 					pBestUnit = pLoopUnit.pointer();

	mov	DWORD PTR _pBestUnit$[esp+52], esi

; 5633 : 					iMinTurns = iMoves;

	mov	ebx, eax
$LN82@GetClosest:

; 5653 : 					break;

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN71@GetClosest:

; 5657 : 
; 5658 : 	*ppClosestUnit = pBestUnit;

	mov	eax, DWORD PTR _pBestUnit$[esp+52]
	mov	edx, DWORD PTR _ppClosestUnit$[esp+48]

; 5659 : 	*piClosestTurns = iMinTurns;

	mov	ecx, DWORD PTR _piClosestTurns$[esp+48]
	mov	DWORD PTR [edx], eax

; 5660 : 	return pBestUnit != NULL;
; 5661 : }

	pop	edi
	xor	edx, edx
	mov	DWORD PTR [ecx], ebx
	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	test	eax, eax
	pop	esi
	setne	dl
	pop	ebp
	mov	al, dl
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 36					; 00000024H
	ret	20					; 00000014H
$LN7@GetClosest:

; 5634 : 					break;
; 5635 : 				}
; 5636 : 
; 5637 : 				if (iMoves < iMinTurns)

	cmp	eax, ebx
	jge	SHORT $LN5@GetClosest

; 5638 : 				{
; 5639 : 					pBestUnit = pLoopUnit.pointer();

	mov	DWORD PTR _pBestUnit$[esp+52], esi

; 5640 : 					iMinTurns = iMoves;

	mov	ebx, eax
$LN5@GetClosest:

; 5641 : 				}
; 5642 : 
; 5643 : 				// Were we far away?  If so, this is probably the best we are going to do
; 5644 : 				if (iDistance >= GC.getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE())

	cmp	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2572

; 5646 : 			}
; 5647 : 			else

	jmp	SHORT $LN88@GetClosest
$LN8@GetClosest:

; 5648 : 			{
; 5649 : 				++iFailedPaths;

	mov	eax, DWORD PTR _iFailedPaths$[esp+52]
	inc	eax

; 5650 : 				if (iFailedPaths >= MAX_FAILED_PATHS)

	cmp	eax, 2
	mov	DWORD PTR _iFailedPaths$[esp+52], eax
	jge	SHORT $LN82@GetClosest

; 5651 : 					break;
; 5652 : 				if (iDistance >= EARLY_OUT_FAILED_PATH_DISTANCE)

	cmp	ebp, 12					; 0000000cH
$LN88@GetClosest:
	jge	SHORT $LN82@GetClosest
$LN1@GetClosest:

; 5654 : 			}
; 5655 : 		}
; 5656 : 	}

	mov	DWORD PTR __$EHRec$[esp+60], -1
	test	esi, esi
	je	SHORT $LN12@GetClosest
	mov	ecx, esi
$LN86@GetClosest:
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN12@GetClosest:

; 5604 : 	CvUnit* pBestUnit = NULL;
; 5605 : 	int iMinTurns = MAX_INT;
; 5606 : 	MoveUnitsArray::iterator it;
; 5607 : 
; 5608 : 	int iFailedPaths = 0;
; 5609 : 	// If we see this many failed pathing attempts, we assume no unit can get to the target
; 5610 : 	const int MAX_FAILED_PATHS = 2;
; 5611 : 	// If the last failed pathing attempt was this far (raw distance) from the target, we assume no one can reach the target, even if we have not reached MAX_FAILED_PATHS
; 5612 : 	const int EARLY_OUT_FAILED_PATH_DISTANCE = 12;
; 5613 : 
; 5614 : 	// Now go through and figure out the actual number of turns, and as a result, even if it can get there at all.
; 5615 : 	// We will try and do as few as possible by stopping if we find a unit that can make it in one turn.
; 5616 : 	for(it = kMoveUnits.begin(); it != kMoveUnits.end(); ++it)

	mov	eax, DWORD PTR _kMoveUnits$[esp+48]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	add	ecx, DWORD PTR [eax]
	add	edi, 16					; 00000010H
	cmp	edi, ecx
	jne	$LL84@GetClosest

; 5645 : 					break;

	jmp	SHORT $LN71@GetClosest
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$228775[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z ENDP ; CvHomelandAI::GetClosestUnitByTurnsToTarget
PUBLIC	?MoveToEmptySpaceNearTarget@CvHomelandAI@@AAE_NPAVCvUnit@@PAVCvPlot@@_N@Z ; CvHomelandAI::MoveToEmptySpaceNearTarget
EXTRN	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z:PROC ; CvUnit::PushMission
EXTRN	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_MOVE_TO
EXTRN	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z:PROC ; CvUnit::GeneratePath
EXTRN	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z:PROC ; CvPlot::getBestDefender
; Function compile flags: /Ogtpy
;	COMDAT ?MoveToEmptySpaceNearTarget@CvHomelandAI@@AAE_NPAVCvUnit@@PAVCvPlot@@_N@Z
_TEXT	SEGMENT
$T242536 = -16						; size = 8
$T242538 = -8						; size = 8
_pUnit$ = 8						; size = 4
_pTarget$ = 12						; size = 4
_bLand$ = 16						; size = 1
?MoveToEmptySpaceNearTarget@CvHomelandAI@@AAE_NPAVCvUnit@@PAVCvPlot@@_N@Z PROC ; CvHomelandAI::MoveToEmptySpaceNearTarget, COMDAT
; _this$ = ecx

; 5741 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 5742 : 	CvPlot* pLoopPlot;
; 5743 : 
; 5744 : 	// Look at spaces adjacent to target
; 5745 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	xor	ebp, ebp
	npad	5
$LL48@MoveToEmpt:

; 5746 : 	{
; 5747 : 		pLoopPlot = plotDirection(pTarget->getX(), pTarget->getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR _pTarget$[esp+28]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	ebp
	push	ecx
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 5748 : 		if(pLoopPlot != NULL && pLoopPlot->isWater() != bLand)

	test	esi, esi
	je	$LN6@MoveToEmpt
	cmp	BYTE PTR [esi+5], 3
	sete	al
	cmp	al, BYTE PTR _bLand$[esp+28]
	je	$LN6@MoveToEmpt

; 5749 : 		{
; 5750 : 			// Must be currently empty of friendly combat units
; 5751 : 			if(!pLoopPlot->getBestDefender(m_pPlayer->GetID()))

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+44]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	edx
	lea	eax, DWORD PTR $T242536[esp+60]
	push	eax
	mov	ecx, esi
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	cmp	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T242536[esp+32]
	sete	bl
	test	ecx, ecx
	je	SHORT $LN27@MoveToEmpt
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN27@MoveToEmpt:
	test	bl, bl
	je	SHORT $LN6@MoveToEmpt

; 5752 : 			{
; 5753 : 				// Enemies too
; 5754 : 				if(!pLoopPlot->getBestDefender(NO_PLAYER, m_pPlayer->GetID()))

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+44]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	edx
	push	-1
	lea	eax, DWORD PTR $T242538[esp+60]
	push	eax
	mov	ecx, esi
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	cmp	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T242538[esp+32]
	sete	bl
	test	ecx, ecx
	je	SHORT $LN38@MoveToEmpt
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN38@MoveToEmpt:
	test	bl, bl
	je	SHORT $LN6@MoveToEmpt

; 5755 : 				{
; 5756 : 					// Find a path to this space
; 5757 : 					if(pUnit->GeneratePath(pLoopPlot))

	mov	ebx, DWORD PTR _pUnit$[esp+28]
	push	0
	push	0
	push	0
	push	esi
	mov	ecx, ebx
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	test	al, al
	jne	SHORT $LN45@MoveToEmpt
$LN6@MoveToEmpt:

; 5742 : 	CvPlot* pLoopPlot;
; 5743 : 
; 5744 : 	// Look at spaces adjacent to target
; 5745 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	inc	ebp
	cmp	ebp, 6
	jl	$LL48@MoveToEmpt
	pop	edi
	pop	esi
	pop	ebp

; 5762 : 					}
; 5763 : 				}
; 5764 : 			}
; 5765 : 		}
; 5766 : 	}
; 5767 : 	return false;

	xor	al, al
	pop	ebx

; 5768 : }

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN45@MoveToEmpt:

; 5758 : 					{
; 5759 : 						// Go ahead with mission
; 5760 : 						pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pLoopPlot->getX(), pLoopPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, ebx
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission
	pop	edi
	pop	esi
	pop	ebp

; 5761 : 						return true;

	mov	al, 1
	pop	ebx

; 5768 : }

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
?MoveToEmptySpaceNearTarget@CvHomelandAI@@AAE_NPAVCvUnit@@PAVCvPlot@@_N@Z ENDP ; CvHomelandAI::MoveToEmptySpaceNearTarget
_TEXT	ENDS
PUBLIC	?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z ; CvHomelandAI::ChooseBestFreeWonderCity
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z:PROC ; CvCity::canConstruct
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z$0
__ehfuncinfo$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_iLoop$ = -20						; size = 4
$T242610 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_eWonder$ = 8						; size = 4
_pEngineer$ = 12					; size = 8
?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvHomelandAI::ChooseBestFreeWonderCity, COMDAT
; _this$ = ecx

; 5772 : {

	push	-1
	push	__ehhandler$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 5773 : 	CvCity* pBestCity = NULL;
; 5774 : 	CvCity* pLoopCity;
; 5775 : 	int iLoop;
; 5776 : 	int iBestTurns = MAX_INT;
; 5777 : 	int iTurns;
; 5778 : 
; 5779 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [ebp]
	xor	ebx, ebx
	push	ebx
	lea	eax, DWORD PTR _iLoop$[esp+40]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+52], ebx
	mov	edi, 2147483647				; 7fffffffH
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN3@ChooseBest
$LN5@ChooseBest:

; 5780 : 	{
; 5781 : 		if(pLoopCity->canConstruct(eWonder))

	mov	ecx, DWORD PTR _eWonder$[esp+32]
	push	0
	push	0
	push	0
	push	0
	push	ecx
	mov	ecx, esi
	call	?canConstruct@CvCity@@QBE_NW4BuildingTypes@@_N11PAVCvString@@@Z ; CvCity::canConstruct
	test	al, al
	je	SHORT $LN4@ChooseBest

; 5782 : 		{
; 5783 : 			iTurns = TurnsToReachTarget(pEngineer, pLoopCity->plot(), true /*bReusePaths*/);

	push	0
	push	0
	push	1
	mov	ecx, esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	edx, DWORD PTR _pEngineer$[esp+44]
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	cl, BYTE PTR _pEngineer$[esp+60]
	mov	BYTE PTR [eax+4], cl
	mov	eax, edx
	mov	DWORD PTR $T242610[esp+60], esp
	test	eax, eax
	je	SHORT $LN13@ChooseBest
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN13@ChooseBest:
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 5784 : 			if(iTurns < iBestTurns)

	cmp	eax, edi
	jge	SHORT $LN4@ChooseBest

; 5785 : 			{
; 5786 : 				pBestCity = pLoopCity;

	mov	ebx, esi

; 5787 : 				iBestTurns = iTurns;

	mov	edi, eax
$LN4@ChooseBest:
	mov	ecx, DWORD PTR [ebp]
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+40]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN5@ChooseBest
$LN3@ChooseBest:

; 5788 : 			}
; 5789 : 		}
; 5790 : 	}
; 5791 : 
; 5792 : 	return pBestCity;

	mov	ecx, DWORD PTR _pEngineer$[esp+32]
	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	ecx, ecx
	je	SHORT $LN22@ChooseBest
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN22@ChooseBest:

; 5793 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ebx
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 20					; 00000014H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pEngineer$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ChooseBestFreeWonderCity@CvHomelandAI@@AAEPAVCvCity@@W4BuildingTypes@@V?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvHomelandAI::ChooseBestFreeWonderCity
PUBLIC	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$7
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z
_TEXT	SEGMENT
_strPlayerName$228896 = -208				; size = 28
_strBaseString$228893 = -180				; size = 28
_strOutBuf$228892 = -152				; size = 28
$T242648 = -124						; size = 28
$T242647 = -124						; size = 28
$T242646 = -96						; size = 28
_szTemp2$228895 = -68					; size = 28
_strTemp$228894 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_strMsg$ = 8						; size = 4
?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z PROC ; CvHomelandAI::LogHomelandMessage, COMDAT
; _this$ = ecx

; 5845 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 196				; 000000c4H
	push	edi
	mov	edi, ecx

; 5846 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogHomelan
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogHomelan
	push	ebx
	push	esi

; 5847 : 	{
; 5848 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$228892[esp+220]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5849 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$228893[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5850 : 		CvString strTemp, szTemp2;

	lea	ecx, DWORD PTR _strTemp$228894[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szTemp2$228895[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5851 : 		CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$228896[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5852 : 		FILogFile* pLog;
; 5853 : 
; 5854 : 		strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	bl, 4
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$228896[esp+220]
	test	eax, eax
	je	SHORT $LN28@LogHomelan
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN27@LogHomelan
$LN28@LogHomelan:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN27@LogHomelan:

; 5855 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	esi, eax
	lea	eax, DWORD PTR _strPlayerName$228896[esp+220]
	push	eax
	lea	ecx, DWORD PTR $T242646[esp+224]
	push	ecx
	mov	ecx, edi
	call	?GetLogFileName@CvHomelandAI@@ABE?AVCvString@@AAV2@@Z ; CvHomelandAI::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax
	lea	ecx, DWORD PTR $T242646[esp+220]
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5856 : 
; 5857 : 		// Get the leading info for this line
; 5858 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$228893[esp+224]
	push	OFFSET $SG228899
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 5859 : 		strBaseString += strPlayerName + ", ";

	push	OFFSET $SG228901
	lea	edx, DWORD PTR _strPlayerName$228896[esp+236]
	push	edx
	lea	eax, DWORD PTR $T242647[esp+240]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$228893[esp+224]
	mov	BYTE PTR __$EHRec$[esp+232], 6
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T242647[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5860 : 		strOutBuf = strBaseString + strMsg;

	mov	ecx, DWORD PTR _strMsg$[esp+216]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$228893[esp+224]
	push	edx
	lea	eax, DWORD PTR $T242648[esp+228]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+228], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$228892[esp+224]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T242648[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5861 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$228892[esp+220]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 5862 : 	}

	lea	ecx, DWORD PTR _strPlayerName$228896[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szTemp2$228895[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$228894[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+228], 0
	lea	ecx, DWORD PTR _strBaseString$228893[esp+220]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$228892[esp+220]
	mov	DWORD PTR __$EHRec$[esp+228], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
	pop	ebx
$LN1@LogHomelan:

; 5863 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+212]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 208				; 000000d0H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$228892[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$228893[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$228894[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$3:
	lea	ecx, DWORD PTR _szTemp2$228895[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$4:
	lea	ecx, DWORD PTR _strPlayerName$228896[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$5:
	lea	ecx, DWORD PTR $T242646[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$6:
	lea	ecx, DWORD PTR $T242647[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z$7:
	lea	ecx, DWORD PTR $T242648[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ENDP ; CvHomelandAI::LogHomelandMessage
PUBLIC	?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z ; CvHomelandAI::LogPatrolMessage
EXTRN	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ:PROC	; CvUnit::getUnitInfo
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$3
__ehfuncinfo$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_strLog$ = -124						; size = 28
_strTemp$ = -96						; size = 28
_strPlayerName$ = -68					; size = 28
_strFileName$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
_strMsg$ = 8						; size = 4
_pPatrolUnit$ = 12					; size = 4
?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z PROC ; CvHomelandAI::LogPatrolMessage, COMDAT
; _this$ = ecx

; 5866 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 112				; 00000070H
	push	ebp

; 5867 : 	if(!pPatrolUnit || !(GC.getLogging() && GC.getAILogging()))

	mov	ebp, DWORD PTR _pPatrolUnit$[esp+124]
	push	edi
	mov	edi, ecx
	test	ebp, ebp
	je	$LN1@LogPatrolM
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogPatrolM
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogPatrolM
	push	esi

; 5868 : 	{
; 5869 : 		return;
; 5870 : 	}
; 5871 : 
; 5872 : 	// Open the log file
; 5873 : 	CvString strFileName = "PlayerHomelandAIPatrolLog.csv";

	push	OFFSET $SG228912
	lea	ecx, DWORD PTR _strFileName$[esp+140]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[esp+144], 0

; 5874 : 	FILogFile* pLog;
; 5875 : 	pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strFileName$[esp+136]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 5876 : 
; 5877 : 	CvString strLog, strTemp;

	lea	ecx, DWORD PTR _strLog$[esp+136]
	mov	esi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$[esp+136]
	mov	BYTE PTR __$EHRec$[esp+144], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5878 : 
; 5879 : 	CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$[esp+136]
	mov	BYTE PTR __$EHRec$[esp+144], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5880 : 	strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	BYTE PTR __$EHRec$[esp+144], 3
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$[esp+136]
	test	eax, eax
	je	SHORT $LN27@LogPatrolM
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN26@LogPatrolM
$LN27@LogPatrolM:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN26@LogPatrolM:

; 5881 : 	strLog += strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$[esp+136]
	push	ecx
	lea	ecx, DWORD PTR _strLog$[esp+140]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 5882 : 	strLog += ",";

	push	OFFSET $SG228917
	lea	ecx, DWORD PTR _strLog$[esp+140]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 5883 : 
; 5884 : 	strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	lea	edx, DWORD PTR _strTemp$[esp+140]
	push	OFFSET $SG228918
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 5885 : 	strLog += strTemp;

	lea	eax, DWORD PTR _strTemp$[esp+136]
	push	eax
	lea	ecx, DWORD PTR _strLog$[esp+140]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 5886 : 
; 5887 : 	strTemp.Format("%s (%d),", pPatrolUnit->getUnitInfo().GetDescription(), pPatrolUnit->GetID());

	mov	edi, DWORD PTR [ebp+100]
	mov	ecx, ebp
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	push	edi
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$[esp+144]
	push	OFFSET $SG228919
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5888 : 	strLog += strTemp;

	lea	edx, DWORD PTR _strTemp$[esp+136]
	push	edx
	lea	ecx, DWORD PTR _strLog$[esp+140]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 5889 : 
; 5890 : 	strLog += strMsg;

	mov	eax, DWORD PTR _strMsg$[esp+132]
	push	eax
	lea	ecx, DWORD PTR _strLog$[esp+140]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 5891 : 	pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$[esp+136]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 5892 : }

	lea	ecx, DWORD PTR _strPlayerName$[esp+136]
	mov	BYTE PTR __$EHRec$[esp+144], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$[esp+136]
	mov	BYTE PTR __$EHRec$[esp+144], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLog$[esp+136]
	mov	BYTE PTR __$EHRec$[esp+144], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strFileName$[esp+136]
	mov	DWORD PTR __$EHRec$[esp+144], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	esi
$LN1@LogPatrolM:
	mov	ecx, DWORD PTR __$EHRec$[esp+132]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 124				; 0000007cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _strFileName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$1:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z$3:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z ENDP ; CvHomelandAI::LogPatrolMessage
PUBLIC	?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z ; CvHomelandAI::IsValidExplorerEndTurnPlot
EXTRN	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z:PROC	; CvUnit::canMoveInto
EXTRN	?CanEverEmbark@CvUnit@@QBE_NXZ:PROC		; CvUnit::CanEverEmbark
EXTRN	?area@CvPlot@@QBEPAVCvArea@@XZ:PROC		; CvPlot::area
EXTRN	?area@CvUnit@@QBEPAVCvArea@@XZ:PROC		; CvUnit::area
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
EXTRN	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z:PROC		; CvUnit::atPlot
; Function compile flags: /Ogtpy
;	COMDAT ?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z PROC ; CvHomelandAI::IsValidExplorerEndTurnPlot, COMDAT
; _this$ = ecx

; 6135 : {

	push	esi

; 6136 : 	if(pUnit->atPlot(*pPlot))

	mov	esi, DWORD PTR _pPlot$[esp]
	push	edi
	mov	edi, DWORD PTR _pUnit$[esp+4]
	push	esi
	mov	ecx, edi
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	test	al, al
	je	SHORT $LN8@IsValidExp
	pop	edi

; 6137 : 	{
; 6138 : 		return false;

	xor	al, al
	pop	esi

; 6167 : 	{
; 6168 : 		return false;
; 6169 : 	}
; 6170 : 
; 6171 : 	return true;
; 6172 : }

	ret	8
$LN8@IsValidExp:
	push	ebx

; 6139 : 	}
; 6140 : 
; 6141 : 	if(!pPlot->isRevealed(pUnit->getTeam()))

	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	ebx, ecx
	mov	ecx, eax
	sub	ecx, ebx
	mov	eax, 1
	shl	eax, cl
	test	eax, DWORD PTR [esi+edx*4+8]

; 6142 : 	{
; 6143 : 		return false;

	je	SHORT $LN3@IsValidExp
	push	ebp

; 6144 : 	}
; 6145 : 
; 6146 : 	DomainTypes eDomain = pUnit->getDomainType();

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 6147 : 
; 6148 : 	if(pPlot->area() != pUnit->area())

	mov	ecx, edi
	mov	ebx, eax
	call	?area@CvUnit@@QBEPAVCvArea@@XZ		; CvUnit::area
	mov	ecx, esi
	mov	ebp, eax
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	eax, ebp
	pop	ebp
	je	SHORT $LN4@IsValidExp

; 6149 : 	{
; 6150 : 		if(!pUnit->CanEverEmbark())

	mov	ecx, edi
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	test	al, al
	jne	SHORT $LN4@IsValidExp

; 6151 : 		{
; 6152 : 			if(!(eDomain == DOMAIN_SEA && pPlot->isWater()))

	test	ebx, ebx
	jne	SHORT $LN3@IsValidExp
	cmp	BYTE PTR [esi+5], 3

; 6153 : 			{
; 6154 : 				return false;

	jne	SHORT $LN3@IsValidExp
$LN4@IsValidExp:

; 6155 : 			}
; 6156 : 		}
; 6157 : 	}
; 6158 : 
; 6159 : 	// don't let the auto-explore end it's turn in a city
; 6160 : 	CvCity* pCity = pPlot->getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN2@IsValidExp
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN2@IsValidExp
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 6161 : 	if(pCity && pCity->getOwner() != pUnit->getOwner())

	test	eax, eax
	je	SHORT $LN2@IsValidExp
	mov	edx, DWORD PTR [eax+84]
	cmp	edx, DWORD PTR [edi+40]
	je	SHORT $LN2@IsValidExp
$LN3@IsValidExp:
	pop	ebx
	pop	edi

; 6162 : 	{
; 6163 : 		return false;

	xor	al, al
	pop	esi

; 6167 : 	{
; 6168 : 		return false;
; 6169 : 	}
; 6170 : 
; 6171 : 	return true;
; 6172 : }

	ret	8
$LN2@IsValidExp:

; 6164 : 	}
; 6165 : 
; 6166 : 	if(!pUnit->canMoveInto(*pPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE))

	push	128					; 00000080H
	push	esi
	mov	ecx, edi
	call	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveInto
	pop	ebx
	test	al, al
	pop	edi
	setne	al
	pop	esi

; 6167 : 	{
; 6168 : 		return false;
; 6169 : 	}
; 6170 : 
; 6171 : 	return true;
; 6172 : }

	ret	8
?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z ENDP ; CvHomelandAI::IsValidExplorerEndTurnPlot
_TEXT	ENDS
PUBLIC	?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ClearCurrentMoveUnits
; Function compile flags: /Ogtpy
;	COMDAT ?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ClearCurrentMoveUnits, COMDAT
; _this$ = ecx

; 6221 : 	m_CurrentMoveUnits.clear();

	xor	eax, eax
	mov	DWORD PTR [ecx+20], eax

; 6222 : 	m_CurrentBestMoveUnit = NULL;

	mov	DWORD PTR [ecx+2396], eax

; 6223 : 	m_iCurrentBestMoveUnitTurns = MAX_INT;

	mov	DWORD PTR [ecx+2400], 2147483647	; 7fffffffH

; 6224 : }

	ret	0
?ClearCurrentMoveUnits@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ClearCurrentMoveUnits
_TEXT	ENDS
PUBLIC	?ClearCurrentMoveHighPriorityUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ClearCurrentMoveHighPriorityUnits
; Function compile flags: /Ogtpy
;	COMDAT ?ClearCurrentMoveHighPriorityUnits@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
?ClearCurrentMoveHighPriorityUnits@CvHomelandAI@@AAEXXZ PROC ; CvHomelandAI::ClearCurrentMoveHighPriorityUnits, COMDAT
; _this$ = ecx

; 6229 : 	m_CurrentMoveHighPriorityUnits.clear();

	xor	eax, eax
	mov	DWORD PTR [ecx+1060], eax

; 6230 : 	m_CurrentBestMoveHighPriorityUnit = NULL;

	mov	DWORD PTR [ecx+2404], eax

; 6231 : 	m_iCurrentBestMoveHighPriorityUnitTurns = MAX_INT;

	mov	DWORD PTR [ecx+2408], 2147483647	; 7fffffffH

; 6232 : }

	ret	0
?ClearCurrentMoveHighPriorityUnits@CvHomelandAI@@AAEXXZ ENDP ; CvHomelandAI::ClearCurrentMoveHighPriorityUnits
_TEXT	ENDS
PUBLIC	?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ; std::list<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ PROC ; std::list<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 560  : 		return (iterator(_Nextnode(_Myhead)));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 561  : 		}

	ret	4
?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ENDP ; std::list<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ; std::list<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ PROC ; std::list<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 570  : 		return (iterator(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 571  : 		}

	ret	4
?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@XZ ENDP ; std::list<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ	; std::list<int,std::allocator<int> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::list<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 825  : 		{	// erase all

	push	esi
	mov	esi, ecx

; 826  : 
; 827  :  #if _HAS_ITERATOR_DEBUGGING
; 828  : 		this->_Orphan_ptr(*this, 0);
; 829  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 830  : 
; 831  : 		_Nodeptr _Pnext;
; 832  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx]

; 833  : 		_Nextnode(_Myhead) = _Myhead;

	mov	DWORD PTR [ecx], ecx

; 834  : 		_Prevnode(_Myhead) = _Myhead;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ecx

; 835  : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0

; 836  : 
; 837  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN1@clear
	push	edi
	npad	3
$LL3@clear:

; 838  : 			{	// delete an element
; 839  : 			_Pnext = _Nextnode(_Pnode);

	mov	edi, DWORD PTR [eax]

; 840  : 			this->_Alnod.destroy(_Pnode);
; 841  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, edi
	cmp	edi, DWORD PTR [esi+4]
	jne	SHORT $LL3@clear
	pop	edi
$LN1@clear:
	pop	esi

; 842  : 			}
; 843  : 		}

	ret	0
?clear@?$list@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::list<int,std::allocator<int> >::clear
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
_TEXT	ENDS
PUBLIC	??4?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z
_TEXT	SEGMENT
_RHS$ = 8						; size = 4
??4?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z PROC ; FStaticVector<CvHomelandUnit,64,1,297,0>::operator=, COMDAT
; _this$ = ecx

; 620  : 	void operator = (const THIS_TYPE& RHS){

	push	ebp

; 621  : 		if( m_uiCurrMaxSize <= RHS.m_uiCurrSize){

	mov	ebp, DWORD PTR _RHS$[esp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [ebp+4]
	ja	SHORT $LN2@operator@6

; 622  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	ebx
	lea	ebx, DWORD PTR [esi+12]
	push	edi
	cmp	eax, ebx
	je	SHORT $LN5@operator@6
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN5@operator@6:

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	edi, DWORD PTR [ebp+8]
	cmp	edi, 64					; 00000040H
	jbe	SHORT $LN16@operator@6
	push	798					; 0000031eH
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	mov	ecx, edi
	shl	ecx, 4
	push	4
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN15@operator@6
$LN16@operator@6:
	mov	eax, ebx
	mov	DWORD PTR [esi+8], 64			; 00000040H
$LN15@operator@6:
	pop	edi
	mov	DWORD PTR [esi], eax
	pop	ebx
$LN2@operator@6:

; 624  : 		}else{
; 625  : 			Destroy(m_pData, m_uiCurrSize);
; 626  : 		}
; 627  : 		Copy(RHS);

	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [esi+4], edx
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [esi]
	shl	eax, 4
	push	eax
	push	ecx
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebp

; 628  : 	};

	ret	4
??4?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ENDP ; FStaticVector<CvHomelandUnit,64,1,297,0>::operator=
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandMove,35,1,297,0>::~FStaticVector<CvHomelandMove,35,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvHomelandMove,35,1,297,0>::~FStaticVector<CvHomelandMove,35,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@2:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvHomelandMove,35,1,297,0>::~FStaticVector<CvHomelandMove,35,1,297,0>
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::begin
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?begin@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@XZ PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@XZ ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@XZ PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@XZ ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::end
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::end
_TEXT	ENDS
PUBLIC	??0?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@I@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@I@Z PROC ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	esi
	xor	eax, eax
	push	edi

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	mov	edi, DWORD PTR _uiStartingMaxSize$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	jbe	SHORT $LN5@FFastVecto
	push	85					; 00000055H
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
$LN5@FFastVecto:
	mov	DWORD PTR [esi], eax
	pop	edi

; 315  : 	};

	mov	eax, esi
	pop	esi
	ret	4
??0?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@I@Z ENDP ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::~FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ PROC ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::~FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	ecx, DWORD PTR [ecx]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 318  : 	};

	ret	0
??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ ENDP ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::~FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??D?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::list<int,std::allocator<int> >::_Iterator<0>::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ??D?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??D?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC ; std::list<int,std::allocator<int> >::_Iterator<0>::operator*, COMDAT
; _this$ = ecx

; 394  : 			return ((reference)**(_Mybase_iter *)this);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 395  : 			}

	ret	0
??D?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::list<int,std::allocator<int> >::_Iterator<0>::operator*
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::begin
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::end
_TEXT	ENDS
PUBLIC	?clear@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ ; CvWeightedVector<CvPlot *,100,1>::clear
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?clear@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ PROC ; CvWeightedVector<CvPlot *,100,1>::clear, COMDAT
; _this$ = ecx

; 116  : 		m_pItems.clear();

	mov	DWORD PTR [ecx+4], 0

; 117  : 	};

	ret	0
?clear@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ ENDP ; CvWeightedVector<CvPlot *,100,1>::clear
_TEXT	ENDS
PUBLIC	??1?$_List_ptr@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_List_ptr<int,std::allocator<int> >::~_List_ptr<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_List_ptr@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_ptr@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_List_ptr<int,std::allocator<int> >::~_List_ptr<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_List_ptr@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_List_ptr<int,std::allocator<int> >::~_List_ptr<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ; std::list<int,std::allocator<int> >::erase
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z PROC ; std::list<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 787  : 
; 788  :  #if _HAS_ITERATOR_DEBUGGING
; 789  : 		if (_Where._Mycont != this || _Where._Ptr == _Myhead)
; 790  : 			_DEBUG_ERROR("list erase iterator outside range");
; 791  : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 792  : 		_Orphan_ptr(*this, _Pnode);
; 793  : 
; 794  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 795  : 		_Nodeptr _Pnode = (_Where++)._Mynode();

	mov	eax, DWORD PTR __Where$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Where$[esp], ecx

; 796  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 797  : 
; 798  : 		if (_Pnode != _Myhead)

	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN32@erase

; 799  : 			{	// not list head, safe to erase
; 800  : 			_Nextnode(_Prevnode(_Pnode)) = _Nextnode(_Pnode);

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 801  : 			_Prevnode(_Nextnode(_Pnode)) = _Prevnode(_Pnode);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]

; 802  : 			this->_Alnod.destroy(_Pnode);
; 803  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	eax
	mov	DWORD PTR [ecx+4], edx
	call	??3@YAXPAX@Z				; operator delete

; 804  : 			--_Mysize;
; 805  : 			}
; 806  : 		return (_Make_iter(_Where));

	mov	ecx, DWORD PTR __Where$[esp+4]
	add	esp, 4
	dec	DWORD PTR [esi+8]
$LN32@erase:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], ecx
	pop	esi

; 807  : 		}

	ret	8
?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_Iterator@$0A@@12@V?$_Const_iterator@$0A@@12@@Z ENDP ; std::list<int,std::allocator<int> >::erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Buynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::_Buynode, COMDAT
; _this$ = ecx

; 1172 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1173 : 		int _Linkcnt = 0;
; 1174 : 
; 1175 : 		_TRY_BEGIN
; 1176 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

	test	eax, eax
	je	SHORT $LN26@Buynode
	mov	DWORD PTR [eax], eax
$LN26@Buynode:

; 1177 : 		++_Linkcnt;
; 1178 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN36@Buynode
	mov	DWORD PTR [ecx], eax
$LN36@Buynode:

; 1179 : 		_CATCH_ALL
; 1180 : 		if (0 < _Linkcnt)
; 1181 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1182 : 		this->_Alnod.deallocate(_Pnode, 1);
; 1183 : 		_RERAISE;
; 1184 : 		_CATCH_END
; 1185 : 		return (_Pnode);
; 1186 : 		}

	ret	0
?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@HV?$allocator@H@std@@@std@@IAEXXZ	; std::list<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$list@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::list<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1212 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1213 : 		clear();

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ecx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ecx
	mov	DWORD PTR [esi+8], 0
	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN3@Tidy
	push	edi
	npad	3
$LL5@Tidy:
	mov	edi, DWORD PTR [eax]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, edi
	cmp	edi, DWORD PTR [esi+4]
	jne	SHORT $LL5@Tidy
	pop	edi
$LN3@Tidy:

; 1214 : 		this->_Alptr.destroy(&_Nextnode(_Myhead));
; 1215 : 		this->_Alptr.destroy(&_Prevnode(_Myhead));
; 1216 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1217 : 		_Myhead = 0;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 1218 : 		}

	ret	0
?_Tidy@?$list@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::list<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 64					; 00000040H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	mov	eax, ebp
	shl	eax, 4
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 64			; 00000040H
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	shl	ecx, 4
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+1036], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandMove,35,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvHomelandMove,35,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@2
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@2
	npad	6
$LL8@GrowSize@2:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@2

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@2

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@2
$LN31@GrowSize@2:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@2:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 35					; 00000023H
	jbe	SHORT $LN15@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@2
$LN15@GrowSize@2:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 35			; 00000023H
$LN14@GrowSize@2:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+292], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvHomelandMove,35,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Make_iter
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE_NI@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 214748364				; 0cccccccH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@VCvHomelandTarget@@@std@@YAPAVCvHomelandTarget@@IPAV1@@Z ; std::_Allocate<CvHomelandTarget>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*4]
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Buy
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ; std::_Allocate<CvPlot *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Buy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z PROC ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR [esi+8]
	push	edi
	mov	ebp, eax

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	test	eax, eax
	jne	SHORT $LN34@GrowSize@3
	mov	DWORD PTR [esi+8], 1
$LN34@GrowSize@3:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+12]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN9@GrowSize@3
	npad	1
$LL10@GrowSize@3:

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN37@GrowSize@3

; 433  : 				break;
; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL10@GrowSize@3

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN9@GrowSize@3
$LN37@GrowSize@3:

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN9@GrowSize@3:

; 438  : 		}
; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	jbe	SHORT $LN7@GrowSize@3
	push	85					; 00000055H
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi

; 441  : 		if (pTemp)

	test	ebx, ebx
	je	SHORT $LN7@GrowSize@3

; 442  : 		{
; 443  : 			if( bPODType ){
; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);
; 445  : 			}else{
; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jbe	SHORT $LN2@GrowSize@3
	mov	ecx, ebx
$LL4@GrowSize@3:

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	test	ecx, ecx
	je	SHORT $LN3@GrowSize@3
	mov	edx, DWORD PTR [esi]
	mov	edi, DWORD PTR [edx+eax*8]
	mov	DWORD PTR [ecx], edi
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR [ecx+4], edx
$LN3@GrowSize@3:
	inc	eax
	add	ecx, 8
	cmp	eax, DWORD PTR [esi+4]
	jb	SHORT $LL4@GrowSize@3
$LN2@GrowSize@3:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	pop	edi

; 450  : 			m_pData = pTemp;

	mov	DWORD PTR [esi], ebx
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
$LN7@GrowSize@3:
	pop	edi

; 451  : 		}
; 452  : 		else
; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	DWORD PTR [esi+8], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
?GrowSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSizeToFit@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::GrowSizeToFit
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSizeToFit@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSizeToFit@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z PROC ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::GrowSizeToFit, COMDAT
; _this$ = ecx

; 462  : 		if( uiFit <= m_uiCurrMaxSize )

	mov	eax, DWORD PTR _uiFit$[esp-4]
	cmp	eax, DWORD PTR [ecx+8]
	jbe	SHORT $LN2@GrowSizeTo

; 463  : 			return;
; 464  : 
; 465  : 		SetSize(uiFit);

	mov	DWORD PTR _uiFit$[esp-4], eax
	jmp	?SetSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::SetSize
$LN2@GrowSizeTo:

; 466  : 	};

	ret	4
?GrowSizeToFit@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::GrowSizeToFit
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@3
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
$LN16@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@3:
?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@3:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@4
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@4:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z ; std::list<int,std::allocator<int> >::_Buynode
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z PROC ; std::list<int,std::allocator<int> >::_Buynode, COMDAT
; _this$ = ecx

; 1191 : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1192 : 		int _Linkcnt = 0;
; 1193 : 
; 1194 : 		_TRY_BEGIN
; 1195 : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Next);

	test	eax, eax
	je	SHORT $LN27@Buynode@2
	mov	ecx, DWORD PTR __Next$[esp-4]
	mov	DWORD PTR [eax], ecx
$LN27@Buynode@2:

; 1196 : 		++_Linkcnt;
; 1197 : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Prev);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN37@Buynode@2
	mov	edx, DWORD PTR __Prev$[esp-4]
	mov	DWORD PTR [ecx], edx
$LN37@Buynode@2:

; 1198 : 		++_Linkcnt;
; 1199 : 		this->_Alval.construct(&_Myval(_Pnode), _Val);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN47@Buynode@2
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx
$LN47@Buynode@2:

; 1200 : 		_CATCH_ALL
; 1201 : 		if (1 < _Linkcnt)
; 1202 : 			this->_Alptr.destroy(&_Prevnode(_Pnode));
; 1203 : 		if (0 < _Linkcnt)
; 1204 : 			this->_Alptr.destroy(&_Nextnode(_Pnode));
; 1205 : 		this->_Alnod.deallocate(_Pnode, 1);
; 1206 : 		_RERAISE;
; 1207 : 		_CATCH_END
; 1208 : 		return (_Pnode);
; 1209 : 		}

	ret	12					; 0000000cH
?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z ENDP ; std::list<int,std::allocator<int> >::_Buynode
_TEXT	ENDS
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::list<int,std::allocator<int> >::_Incsize
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
; File s:\msvs2008\vc\include\stdexcept
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
xdata$x	ENDS
;	COMDAT ?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T243865 = -80						; size = 28
$T243864 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z PROC ; std::list<int,std::allocator<int> >::_Incsize, COMDAT
; _this$ = ecx

; 1239 : 		{	// alter element count, with checking

	mov	eax, DWORD PTR fs:0

; 1240 : 		if (max_size() - _Mysize < _Count)

	mov	edx, DWORD PTR __Count$[esp-4]
	push	-1
	push	__ehhandler$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	sub	esp, 68					; 00000044H
	push	esi
	mov	esi, 1073741823				; 3fffffffH
	sub	esi, eax
	cmp	esi, edx
	pop	esi
	jae	SHORT $LN1@Incsize

; 1241 : 			_THROW(length_error, "list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T243865[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T243864[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T243865[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T243864[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T243864[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T243864[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T243864[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN20@Incsize:
$LN1@Incsize:

; 1242 : 		_Mysize += _Count;

	add	eax, edx
	mov	DWORD PTR [ecx+8], eax

; 1243 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	4
$LN19@Incsize:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z$0:
	lea	ecx, DWORD PTR $T243865[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z$2:
	lea	ecx, DWORD PTR $T243864[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z ENDP ; std::list<int,std::allocator<int> >::_Incsize
PUBLIC	??0?$_List_ptr@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_List_ptr<int,std::allocator<int> >::_List_ptr<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_List_ptr@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_ptr@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_List_ptr<int,std::allocator<int> >::_List_ptr<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 67   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 68   : 		}

	ret	4
??0?$_List_ptr@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_List_ptr<int,std::allocator<int> >::_List_ptr<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXPAPAVCvPlot@@0@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Destroy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXPAPAVCvPlot@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXPAPAVCvPlot@@0@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXPAPAVCvPlot@@0@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Destroy
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator+
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXPAPAVCvCity@@0@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Destroy
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >::operator+
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvPlot *,std::allocator<CvPlot *> >::operator+
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSize
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize@4
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize@4:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@4
	npad	6
$LL8@GrowSize@4:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize@4

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@4

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@4
$LN34@GrowSize@4:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@4:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 100				; 00000064H
	jbe	SHORT $LN16@GrowSize@4
	push	798					; 0000031eH
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize@4
$LN16@GrowSize@4:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 100			; 00000064H
$LN15@GrowSize@4:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize@4
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize@4:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+812], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSizeToFit
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSizeToFit, COMDAT
; _this$ = ecx

; 776  : 	{

	push	esi
	push	edi

; 777  : 		if( uiFit <= m_uiCurrMaxSize )

	mov	edi, DWORD PTR _uiFit$[esp+4]
	mov	esi, ecx
	cmp	edi, DWORD PTR [esi+8]
	jbe	SHORT $LN7@GrowSizeTo@2
	push	ebx

; 778  : 			return;
; 779  : 
; 780  : 		m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edi

; 781  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	cmp	edi, 100				; 00000064H
	jbe	SHORT $LN13@GrowSizeTo@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebx, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN12@GrowSizeTo@2
$LN13@GrowSizeTo@2:
	lea	ebx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 100			; 00000064H
$LN12@GrowSizeTo@2:

; 782  : 		if( bPODType ){
; 783  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	ebx
	call	_memcpy

; 784  : 		}else{
; 785  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 786  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 787  : 		}
; 788  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	add	esp, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN20@GrowSizeTo@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN20@GrowSizeTo@2:

; 789  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], ebx

; 790  : 
; 791  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+812], 1
	pop	ebx
$LN7@GrowSizeTo@2:
	pop	edi
	pop	esi

; 792  : 	};

	ret	4
?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSizeToFit
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN33@GrowSize@5
	mov	DWORD PTR [esi+8], 1
$LN33@GrowSize@5:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@5
	npad	6
$LL8@GrowSize@5:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize@5

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@5

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@5
$LN34@GrowSize@5:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@5:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 64					; 00000040H
	jbe	SHORT $LN16@GrowSize@5
	push	798					; 0000031eH
	push	OFFSET ??_C@_0DI@OIPOBLCO@s?3?2lekmod_dll?2fireplace?2include?2@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize@5
$LN16@GrowSize@5:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 64			; 00000040H
$LN15@GrowSize@5:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize@5:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+524], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@5
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@5:

; 619  : 	};

	ret	0
??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvHomelandTarget@@PAV1@@stdext@@YAPAVCvHomelandTarget@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvHomelandTarget *,CvHomelandTarget *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAVCvHomelandTarget@@PAV1@@stdext@@YAPAVCvHomelandTarget@@PAV1@00@Z
_TEXT	SEGMENT
$T244168 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$244171 = 16					; size = 1
$T244150 = 16						; size = 1
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvHomelandTarget@@PAV1@@stdext@@YAPAVCvHomelandTarget@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvHomelandTarget *,CvHomelandTarget *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$244171[esp]
	mov	edx, DWORD PTR $T244150[esp]
	mov	BYTE PTR $T244168[esp+4], 0
	mov	eax, DWORD PTR $T244168[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_backward_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>

; 3697 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_move_backward@PAVCvHomelandTarget@@PAV1@@stdext@@YAPAVCvHomelandTarget@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvHomelandTarget *,CvHomelandTarget *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@2:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
_TEXT	ENDS
PUBLIC	??$_Find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z ; std::_Find<std::list<int,std::allocator<int> >::_Iterator<0>,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$_Find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z PROC ; std::_Find<std::list<int,std::allocator<int> >::_Iterator<0>,int>, COMDAT

; 38   : 	_DEBUG_RANGE(_First, _Last);
; 39   : 	for (; _First != _Last; ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN27@Find
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL9@Find:

; 40   : 		if (*_First == _Val)

	cmp	DWORD PTR [ecx+8], edx
	je	SHORT $LN27@Find
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR __First$[esp-4], ecx
	cmp	ecx, eax
	jne	SHORT $LL9@Find
$LN27@Find:

; 41   : 			break;
; 42   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 43   : 	}

	ret	0
??$_Find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z ENDP ; std::_Find<std::list<int,std::allocator<int> >::_Iterator<0>,int>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@std@@@Z
_TEXT	SEGMENT
$T244320 = -4						; size = 1
__Cat$244324 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244320[esp+4], 0
	mov	eax, DWORD PTR $T244320[esp+4]
	mov	ecx, DWORD PTR __Cat$244324[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@0AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@0AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@0AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvHomelandTarget> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@0AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvHomelandTarget *,unsigned int,CvHomelandTarget,std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvHomelandTarget *,unsigned int,CvHomelandTarget,std::allocator<CvHomelandTarget> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], esi
	mov	esi, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], esi
$LN5@Uninit_fil:
	dec	ecx
	add	eax, 20					; 00000014H
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvHomelandTarget *,unsigned int,CvHomelandTarget,std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??$_Distance@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0AAH@Z ; std::_Distance<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Distance@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0AAH@Z PROC ; std::_Distance<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0AAH@Z ENDP ; std::_Distance<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvPlot * *,unsigned int,CvPlot *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z PROC ; stdext::unchecked_fill_n<CvPlot * *,unsigned int,CvPlot *>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@10
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@10:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@10
	pop	esi
$LN7@unchecked_@10:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAPAVCvPlot@@IPAV1@@stdext@@YAXPAPAVCvPlot@@IABQAV1@@Z ENDP ; stdext::unchecked_fill_n<CvPlot * *,unsigned int,CvPlot *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z PROC ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@11
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@11:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@11
	pop	esi
$LN7@unchecked_@11:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ENDP ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_move@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T244473 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$244476 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$244476[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T244473[esp+4], 0
	mov	eax, DWORD PTR $T244473[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvCity * *,CvCity * *,std::allocator<CvCity *>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvCity * *,CvCity * *,std::allocator<CvCity *>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@U_Undefined_move_tag@3@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvCity * *,CvCity * *,std::allocator<CvCity *>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandMove>::_Maxlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$232675 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvHomelandMove>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$232675[esp+16]
	push	eax
	call	??$get_temporary_buffer@VCvHomelandMove@@@std@@YA?AU?$pair@PAVCvHomelandMove@@H@0@H@Z ; std::get_temporary_buffer<CvHomelandMove>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$232675[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$232675[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvHomelandMove>::_Maxlen
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$232724 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen@2
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen@2

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$232724[esp+16]
	push	eax
	call	??$get_temporary_buffer@VCvHomelandTarget@@@std@@YA?AU?$pair@PAVCvHomelandTarget@@H@0@H@Z ; std::get_temporary_buffer<CvHomelandTarget>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$232724[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$232724[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen@2:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen@2:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$232773 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen@3
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen@3

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$232773[esp+16]
	push	eax
	call	??$get_temporary_buffer@VCvHomelandUnit@@@std@@YA?AU?$pair@PAVCvHomelandUnit@@H@0@H@Z ; std::get_temporary_buffer<CvHomelandUnit>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$232773[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$232773[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen@3:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen@3:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@ZPAH0@Z ; std::_Make_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Make_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@ZPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Make_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@ZPAH0@Z PROC ; std::_Make_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 2190 : 	{	// make nontrivial [_First, _Last) into a heap, using _Pred

	push	ebx

; 2191 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	ebp
	mov	ebp, DWORD PTR __First$[esp+4]
	sub	ebx, ebp
	sar	ebx, 3

; 2192 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	push	esi
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap
	push	edi
	lea	edi, DWORD PTR [ebp+esi*8]
$LL2@Make_heap:

; 2193 : 		{	// reheap top half, bottom to top
; 2194 : 		--_Hole;
; 2195 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2196 : 			_Ty(*(_First + _Hole)), _Pred);

	mov	eax, DWORD PTR __Pred$[esp+12]
	mov	ecx, DWORD PTR [edi-4]
	mov	edx, DWORD PTR [edi-8]
	push	eax
	sub	edi, 8
	push	ecx
	push	edx
	push	ebx
	dec	esi
	push	esi
	push	ebp
	call	??$_Adjust_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z ; std::_Adjust_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 24					; 00000018H
	test	esi, esi
	jg	SHORT $LL2@Make_heap
	pop	edi
$LN1@Make_heap:
	pop	esi
	pop	ebp
	pop	ebx

; 2197 : 		}
; 2198 : 	}

	ret	0
??$_Make_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@ZPAH0@Z ENDP ; std::_Make_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@ZU12@@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z0@Z ; std::_Insertion_sort1<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &),std::pair<int,CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@ZU12@@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z0@Z
_TEXT	SEGMENT
tv242 = -12						; size = 4
__Val$232861 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@ZU12@@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z0@Z PROC ; std::_Insertion_sort1<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &),std::pair<int,CvPlot *> >, COMDAT

; 3123 : 	{	// insertion sort [_First, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 3124 : 	if (_First != _Last)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, DWORD PTR __First$[ebp]
	push	edi
	cmp	esi, eax
	je	$LN6@Insertion_

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	ebx, DWORD PTR [esi+8]
	cmp	ebx, eax
	je	$LN6@Insertion_
	lea	eax, DWORD PTR [ebx-8]
	mov	DWORD PTR tv242[esp+24], eax
	npad	4
$LL7@Insertion_:

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;
; 3128 : 			_Ty _Val = *_Next;

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ebx+4]

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	lea	eax, DWORD PTR __Val$232861[esp+24]
	push	esi
	push	eax
	mov	edi, ebx
	mov	DWORD PTR __Val$232861[esp+32], ecx
	mov	DWORD PTR __Val$232861[esp+36], edx
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	test	al, al
	je	SHORT $LN5@Insertion_

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, ebx
	cmp	esi, ebx
	je	SHORT $LN17@Insertion_
$LL18@Insertion_:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], edx
	cmp	eax, esi
	jne	SHORT $LL18@Insertion_
$LN17@Insertion_:

; 3133 : 				*_First = _Val;

	mov	eax, DWORD PTR __Val$232861[esp+24]
	mov	ecx, DWORD PTR __Val$232861[esp+28]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ecx

; 3134 : 				}
; 3135 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;
; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	mov	esi, DWORD PTR tv242[esp+24]
	mov	edx, esi
	push	edx
	lea	eax, DWORD PTR __Val$232861[esp+28]
	push	eax
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	test	al, al
	je	SHORT $LN1@Insertion_
	npad	3
$LL3@Insertion_:

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [edi], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], edx
	mov	edi, esi
	sub	esi, 8
	lea	eax, DWORD PTR __Val$232861[esp+24]
	push	esi
	push	eax
	call	DWORD PTR __Pred$[ebp]
	add	esp, 8
	test	al, al
	jne	SHORT $LL3@Insertion_
$LN1@Insertion_:

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, DWORD PTR __Val$232861[esp+24]
	mov	edx, DWORD PTR __Val$232861[esp+28]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edi], ecx
	mov	DWORD PTR [edi+4], edx
$LN4@Insertion_:
	add	DWORD PTR tv242[esp+24], 8
	add	ebx, 8
	cmp	ebx, DWORD PTR __Last$[ebp]
	jne	$LL7@Insertion_
$LN6@Insertion_:

; 3142 : 				}
; 3143 : 			}
; 3144 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@ZU12@@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z0@Z ENDP ; std::_Insertion_sort1<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &),std::pair<int,CvPlot *> >
_TEXT	ENDS
PUBLIC	??$advance@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@H@Z ; std::advance<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$advance@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@H@Z PROC ; std::advance<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXAAV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@H@Z ENDP ; std::advance<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Median<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z PROC ; std::_Median<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	ebx, edi
	sar	ebx, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap@2
	npad	3
$LL2@Make_heap@2:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [edi+esi*8-8]
	sub	esp, 8
	mov	eax, esp
	dec	esi
	push	ebx
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+esi*8+4]
	push	esi
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap@2
$LN1@Make_heap@2:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_@2

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_@2
	push	ebx
	push	esi
$LL7@Insertion_@2:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_@2

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN21@Insertion_@2
	npad	7
$LL22@Insertion_@2:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_@2
$LN21@Insertion_@2:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@2
$LN5@Insertion_@2:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_@2
$LL3@Insertion_@2:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_@2

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_@2:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_@2:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_@2
	pop	esi
	pop	ebx
$LN6@Insertion_@2:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Median<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z PROC ; std::_Median<CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median@2

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median@2:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	ebx, edi
	sar	ebx, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap@3
	npad	3
$LL2@Make_heap@3:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [edi+esi*8-8]
	sub	esp, 8
	mov	eax, esp
	dec	esi
	push	ebx
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+esi*8+4]
	push	esi
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap@3
$LN1@Make_heap@3:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_@3

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_@3
	push	ebx
	push	esi
$LL7@Insertion_@3:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_@3

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN21@Insertion_@3
	npad	7
$LL22@Insertion_@3:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_@3
$LN21@Insertion_@3:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@3
$LN5@Insertion_@3:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_@3
$LL3@Insertion_@3:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_@3

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_@3:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_@3:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_@3
	pop	esi
	pop	ebx
$LN6@Insertion_@3:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAVCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@00@Z ; std::_Insertion_sort1<CvHomelandMove *,CvHomelandMove>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAVCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAVCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@00@Z PROC ; std::_Insertion_sort1<CvHomelandMove *,CvHomelandMove>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_@4

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_@4
	push	ebx
	push	esi
$LL7@Insertion_@4:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_@4

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN19@Insertion_@4
	npad	7
$LL20@Insertion_@4:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL20@Insertion_@4
$LN19@Insertion_@4:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@4
$LN5@Insertion_@4:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_@4
$LL3@Insertion_@4:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_@4

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_@4:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_@4:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_@4
	pop	esi
	pop	ebx
$LN6@Insertion_@4:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAVCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@00@Z ENDP ; std::_Insertion_sort1<CvHomelandMove *,CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@PAVCvHomelandMove@@PAV1@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@0000@Z ; stdext::_Unchecked_merge_backward<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@PAVCvHomelandMove@@PAV1@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@0000@Z
_TEXT	SEGMENT
$T244835 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$_Unchecked_merge_backward@PAVCvHomelandMove@@PAV1@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@0000@Z PROC ; stdext::_Unchecked_merge_backward<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>, COMDAT

; 5202 : 	{

	push	ecx

; 5203 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	edx, DWORD PTR __Last2$[esp]
	mov	BYTE PTR $T244835[esp+4], 0
	mov	eax, DWORD PTR $T244835[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Merge_backward@PAVCvHomelandMove@@PAV1@PAV1@@std@@YAPAVCvHomelandMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>

; 5204 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_merge_backward@PAVCvHomelandMove@@PAV1@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@0000@Z ENDP ; stdext::_Unchecked_merge_backward<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$lower_bound@PAVCvHomelandMove@@V1@@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@@Z ; std::lower_bound<CvHomelandMove *,CvHomelandMove>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@PAVCvHomelandMove@@V1@@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$lower_bound@PAVCvHomelandMove@@V1@@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@@Z PROC ; std::lower_bound<CvHomelandMove *,CvHomelandMove>, COMDAT

; 2276 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Lower_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvHomelandMove *,CvHomelandMove,int>
	add	esp, 16					; 00000010H

; 2277 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2278 : 	return _First;
; 2279 : 	}

	ret	0
??$lower_bound@PAVCvHomelandMove@@V1@@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@@Z ENDP ; std::lower_bound<CvHomelandMove *,CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$upper_bound@PAVCvHomelandMove@@V1@@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@@Z ; std::upper_bound<CvHomelandMove *,CvHomelandMove>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@PAVCvHomelandMove@@V1@@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$upper_bound@PAVCvHomelandMove@@V1@@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@@Z PROC ; std::upper_bound<CvHomelandMove *,CvHomelandMove>, COMDAT

; 2347 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Upper_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvHomelandMove *,CvHomelandMove,int>
	add	esp, 16					; 00000010H

; 2348 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2349 : 	return _First;
; 2350 : 	}

	ret	0
??$upper_bound@PAVCvHomelandMove@@V1@@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@@Z ENDP ; std::upper_bound<CvHomelandMove *,CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z
_TEXT	SEGMENT
$T244851 = -4						; size = 1
$T244858 = -4						; size = 4
$T244854 = -4						; size = 4
__Cat$244862 = 8					; size = 1
$T244853 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T244858[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$244862[esp+4]
	mov	edx, DWORD PTR $T244853[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T244851[esp+12], bl
	mov	eax, DWORD PTR $T244851[esp+12]
	push	eax
	push	ecx
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+40]
	mov	eax, DWORD PTR __First$[esp+40]
	mov	DWORD PTR $T244854[esp+44], esp
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_@12
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_@12:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAVCvHomelandUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z0@Z ; std::_Insertion_sort1<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),CvHomelandUnit>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@PAVCvHomelandUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z0@Z
_TEXT	SEGMENT
__Val$234538 = -16					; size = 16
tv242 = 8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Insertion_sort1@PAVCvHomelandUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z0@Z PROC ; std::_Insertion_sort1<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),CvHomelandUnit>, COMDAT

; 3124 : 	if (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __First$[esp+20]
	push	esi
	push	edi
	cmp	ebp, eax
	je	$LN6@Insertion_@5

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	ebx, DWORD PTR [ebp+16]
	cmp	ebx, eax
	je	$LN6@Insertion_@5
	lea	eax, DWORD PTR [ebx-16]
	mov	DWORD PTR tv242[esp+28], eax
	npad	7
$LL7@Insertion_@5:

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;
; 3128 : 			_Ty _Val = *_Next;

	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx]
	mov	DWORD PTR __Val$234538[esp+36], ecx

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR __Val$234538[esp+40], edx
	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR __Val$234538[esp+44], eax
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [ebp+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ebp+12]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ebx+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+8], ecx
	mov	edi, ebx
	mov	DWORD PTR __Val$234538[esp+64], esi
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[esp+60]
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN5@Insertion_@5

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, ebx
	cmp	ebp, ebx
	je	SHORT $LN17@Insertion_@5
$LL18@Insertion_@5:
	mov	ecx, DWORD PTR [eax-16]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+20], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+28], edx
	cmp	eax, ebp
	jne	SHORT $LL18@Insertion_@5
$LN17@Insertion_@5:

; 3133 : 				*_First = _Val;

	mov	eax, DWORD PTR __Val$234538[esp+36]
	mov	ecx, DWORD PTR __Val$234538[esp+40]
	mov	edx, DWORD PTR __Val$234538[esp+44]
	mov	DWORD PTR [ebp], esi
	mov	DWORD PTR [ebp+4], eax
	mov	DWORD PTR [ebp+8], ecx
	mov	DWORD PTR [ebp+12], edx

; 3134 : 				}
; 3135 : 			else

	jmp	$LN4@Insertion_@5
$LN5@Insertion_@5:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;
; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	mov	esi, DWORD PTR tv242[esp+28]
	mov	ecx, esi
	mov	edx, DWORD PTR [ecx]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR __Val$234538[esp+48]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR __Val$234538[esp+52]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Val$234538[esp+72]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR __Val$234538[esp+76]
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], ecx
	call	DWORD PTR __Pred$[esp+60]
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN1@Insertion_@5
	npad	3
$LL3@Insertion_@5:

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edi], edx
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], eax
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], ecx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], edx
	mov	ecx, DWORD PTR [esi-16]
	mov	edx, DWORD PTR [esi-12]
	mov	edi, esi
	sub	esi, 16					; 00000010H
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Val$234538[esp+48]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR __Val$234538[esp+52]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Val$234538[esp+72]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$234538[esp+76]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[esp+60]
	add	esp, 32					; 00000020H
	test	al, al
	jne	SHORT $LL3@Insertion_@5
$LN1@Insertion_@5:

; 3141 : 				*_Next1 = _Val;	// insert element in hole

	mov	eax, DWORD PTR __Val$234538[esp+32]
	mov	ecx, DWORD PTR __Val$234538[esp+36]
	mov	edx, DWORD PTR __Val$234538[esp+40]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR __Val$234538[esp+44]
	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR [edi+8], edx
	mov	DWORD PTR [edi+12], eax
$LN4@Insertion_@5:
	add	DWORD PTR tv242[esp+28], 16		; 00000010H
	add	ebx, 16					; 00000010H
	cmp	ebx, DWORD PTR __Last$[esp+28]
	jne	$LL7@Insertion_@5
$LN6@Insertion_@5:

; 3142 : 				}
; 3143 : 			}
; 3144 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
??$_Insertion_sort1@PAVCvHomelandUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z0@Z ENDP ; std::_Insertion_sort1<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@Z@Z ; stdext::_Unchecked_merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@Z@Z
_TEXT	SEGMENT
$T244949 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 4
??$_Unchecked_merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@Z@Z PROC ; stdext::_Unchecked_merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 5227 : 	{

	push	ecx

; 5228 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	mov	BYTE PTR $T244949[esp+4], 0
	mov	eax, DWORD PTR $T244949[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>

; 5229 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$_Unchecked_merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@Z@Z ENDP ; stdext::_Unchecked_merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$lower_bound@PAVCvHomelandUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z ; std::lower_bound<CvHomelandUnit *,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@PAVCvHomelandUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$lower_bound@PAVCvHomelandUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z PROC ; std::lower_bound<CvHomelandUnit *,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 2314 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	push	edx
	push	eax
	call	??$_Lower_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 20					; 00000014H

; 2315 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2316 : 	return _First;
; 2317 : 	}

	ret	0
??$lower_bound@PAVCvHomelandUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z ENDP ; std::lower_bound<CvHomelandUnit *,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$upper_bound@PAVCvHomelandUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z ; std::upper_bound<CvHomelandUnit *,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@PAVCvHomelandUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$upper_bound@PAVCvHomelandUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z PROC ; std::upper_bound<CvHomelandUnit *,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 2385 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	push	0
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	push	edx
	push	eax
	call	??$_Upper_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 20					; 00000014H

; 2386 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Pred, _Dist_type(_First)));
; 2387 : 	return _First;
; 2388 : 	}

	ret	0
??$upper_bound@PAVCvHomelandUnit@@V1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@Z@Z ENDP ; std::upper_bound<CvHomelandUnit *,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAVCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@00@Z ; std::_Insertion_sort1<CvHomelandUnit *,CvHomelandUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAVCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@00@Z
_TEXT	SEGMENT
__Val$234818 = -16					; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAVCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@00@Z PROC ; std::_Insertion_sort1<CvHomelandUnit *,CvHomelandUnit>, COMDAT

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 16					; 00000010H
	push	edi
	mov	edi, DWORD PTR __First$[esp+16]
	cmp	edi, eax
	je	$LN6@Insertion_@6

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+16]
	cmp	edx, eax
	je	$LN6@Insertion_@6
	push	ebx
	push	ebp
	push	esi
$LL7@Insertion_@6:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+8]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+8]
	mov	ebp, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+12]
	mov	ebx, DWORD PTR [edx]
	mov	eax, edx
	mov	DWORD PTR __Val$234818[esp+36], ebp
	mov	DWORD PTR __Val$234818[esp+44], ecx
	jge	SHORT $LN5@Insertion_@6

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	cmp	edi, edx
	je	SHORT $LN23@Insertion_@6
$LL24@Insertion_@6:
	mov	ecx, DWORD PTR [eax-16]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+20], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+24], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+28], ecx
	cmp	eax, edi
	jne	SHORT $LL24@Insertion_@6
$LN23@Insertion_@6:

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __Val$234818[esp+44]
	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], ebp
	mov	DWORD PTR [edi+8], esi
	mov	DWORD PTR [edi+12], eax

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@6
$LN5@Insertion_@6:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-8]
	lea	ecx, DWORD PTR [edx-16]
	jge	SHORT $LN1@Insertion_@6
$LL3@Insertion_@6:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp
	mov	eax, ecx
	sub	ecx, 16					; 00000010H
	cmp	esi, DWORD PTR [ecx+8]
	jl	SHORT $LL3@Insertion_@6

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Val$234818[esp+36]
$LN1@Insertion_@6:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, DWORD PTR __Val$234818[esp+44]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], ecx
$LN4@Insertion_@6:
	add	edx, 16					; 00000010H
	cmp	edx, DWORD PTR __Last$[esp+28]
	jne	$LL7@Insertion_@6
	pop	esi
	pop	ebp
	pop	ebx
$LN6@Insertion_@6:
	pop	edi

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Insertion_sort1@PAVCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@00@Z ENDP ; std::_Insertion_sort1<CvHomelandUnit *,CvHomelandUnit>
_TEXT	ENDS
PUBLIC	?swap@?$pair@HPAVCvPlot@@@std@@QAEXAAU12@@Z	; std::pair<int,CvPlot *>::swap
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ?swap@?$pair@HPAVCvPlot@@@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?swap@?$pair@HPAVCvPlot@@@std@@QAEXAAU12@@Z PROC	; std::pair<int,CvPlot *>::swap, COMDAT
; _this$ = ecx

; 62   : 		if (this != &_Right)

	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN11@swap@8

; 63   : 			{	// different, worth swapping
; 64   : 			_STD _Swap_adl(first, _Right.first);

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx

; 65   : 			_STD _Swap_adl(second, _Right.second);

	add	eax, 4
	add	ecx, 4
	cmp	ecx, eax
	je	SHORT $LN15@swap@8
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
$LN15@swap@8:
	pop	esi
$LN11@swap@8:

; 66   : 			}
; 67   : 		}

	ret	4
?swap@?$pair@HPAVCvPlot@@@std@@QAEXAAU12@@Z ENDP	; std::pair<int,CvPlot *>::swap
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAU?$pair@HPAVCvPlot@@@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z0@Z ; std::_Pop_heap_0<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Pop_heap_0@PAU?$pair@HPAVCvPlot@@@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Pop_heap_0@PAU?$pair@HPAVCvPlot@@@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z0@Z PROC ; std::_Pop_heap_0<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 2144 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2145 : 		_Ty(*(_Last - 1)), _Pred, _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [eax-8]
	push	esi
	mov	esi, DWORD PTR [eax-4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax-8], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edi
	mov	edi, DWORD PTR __Pred$[esp+4]
	push	edi
	sub	eax, ecx
	push	esi
	push	edx
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	call	??$_Adjust_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z ; std::_Adjust_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 2146 : 	}

	ret	0
??$_Pop_heap_0@PAU?$pair@HPAVCvPlot@@@std@@U12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z0@Z ENDP ; std::_Pop_heap_0<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T245085 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+12]
	xor	ebx, ebx
	mov	DWORD PTR $T245085[esp+16], ebx
	cmp	ecx, edi
	je	SHORT $LN1@Copy_opt@7
	lea	esi, DWORD PTR [ebx+8]
	npad	7
$LL3@Copy_opt@7:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __Dest$[esp+28]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN14@Copy_opt@7
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR __Dest$[esp+28]
	add	DWORD PTR [eax+4], esi
	jmp	SHORT $LN2@Copy_opt@7
$LN14@Copy_opt@7:
	cmp	eax, ebx
	je	SHORT $LN19@Copy_opt@7
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Dest$[esp+28]
$LN19@Copy_opt@7:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN2@Copy_opt@7:
	add	ecx, esi
	cmp	ecx, edi
	jne	SHORT $LL3@Copy_opt@7
$LN1@Copy_opt@7:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	cmp	eax, ebx
	je	SHORT $LN41@Copy_opt@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Copy_opt@7:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvHomelandMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Merge@PAVCvHomelandMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge@PAVCvHomelandMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>, COMDAT

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+8]
	cmp	eax, esi
	je	SHORT $LN16@Merge
	npad	5
$LL5@Merge:
	cmp	ecx, edi
	je	SHORT $LN3@Merge

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	ebx, DWORD PTR [ecx+4]
	cmp	ebx, DWORD PTR [eax+4]
	jle	SHORT $LN2@Merge

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [ecx+4]
	add	ecx, 8

; 2516 : 		else

	jmp	SHORT $LN40@Merge
$LN2@Merge:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	add	eax, 8
$LN40@Merge:
	mov	DWORD PTR [edx+4], ebx
	add	edx, 8
	cmp	eax, esi
	jne	SHORT $LL5@Merge
$LN3@Merge:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	eax, esi
	je	SHORT $LN16@Merge
$LL18@Merge:
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	add	eax, 8
	add	edx, 8
	cmp	eax, esi
	jne	SHORT $LL18@Merge
$LN16@Merge:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	eax, edx
	cmp	ecx, edi
	je	SHORT $LN27@Merge
	npad	6
$LL29@Merge:
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edi
	jne	SHORT $LL29@Merge
$LN27@Merge:
	pop	edi
	pop	esi
	pop	ebx

; 2521 : 	}

	ret	0
??$_Merge@PAVCvHomelandMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$rotate@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@00@Z ; std::rotate<CvHomelandMove *>
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@00@Z PROC ; std::rotate<CvHomelandMove *>, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN6@rotate
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN6@rotate

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00PAH0@Z ; std::_Rotate<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 20					; 00000014H
$LN6@rotate:

; 1721 : 	}

	ret	0
??$rotate@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@00@Z ENDP ; std::rotate<CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T245276 = -4						; size = 1
__Cat$245282 = 8					; size = 1
$T245278 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$245282[esp]
	mov	edx, DWORD PTR $T245278[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T245276[esp+8], 0
	mov	eax, DWORD PTR $T245276[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy_backward<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Lower_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Lower_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Lower_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z PROC ; std::_Lower_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>, COMDAT

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;
; 2255 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN38@Lower_boun@3
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+16]
$LL4@Lower_boun@3:

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2260 : 		_FwdIt _Mid = _First;
; 2261 : 		std::advance(_Mid, _Count2);

	lea	edx, DWORD PTR [eax+eax*4]

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	cmp	DWORD PTR [esi+edx*4+16], edi
	lea	edx, DWORD PTR [esi+edx*4]
	jle	SHORT $LN2@Lower_boun@3

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	esi, DWORD PTR [edx+20]
	or	edx, -1
	sub	edx, eax
	mov	DWORD PTR __First$[esp+4], esi
	add	ecx, edx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun@3
$LN2@Lower_boun@3:

; 2267 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Lower_boun@3:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Lower_boun@3
	pop	edi
$LN38@Lower_boun@3:

; 2268 : 		}
; 2269 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], esi
	pop	esi

; 2270 : 	}

	ret	0
??$_Lower_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z ENDP ; std::_Lower_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Upper_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z PROC ; std::_Upper_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>, COMDAT

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;
; 2327 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN38@Upper_boun@3
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+16]
$LL4@Upper_boun@3:

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2331 : 		_FwdIt _Mid = _First;
; 2332 : 		std::advance(_Mid, _Count2);

	lea	edx, DWORD PTR [eax+eax*4]

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	cmp	edi, DWORD PTR [esi+edx*4+16]
	lea	edx, DWORD PTR [esi+edx*4]
	jg	SHORT $LN2@Upper_boun@3

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	esi, DWORD PTR [edx+20]
	or	edx, -1
	sub	edx, eax
	mov	DWORD PTR __First$[esp+4], esi
	add	ecx, edx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun@3
$LN2@Upper_boun@3:

; 2338 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Upper_boun@3:

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Upper_boun@3
	pop	edi
$LN38@Upper_boun@3:

; 2339 : 		}
; 2340 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], esi
	pop	esi

; 2341 : 	}

	ret	0
??$_Upper_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z ENDP ; std::_Upper_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T245476 = -4						; size = 1
__Cat$245482 = 8					; size = 1
$T245478 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$245482[esp]
	mov	edx, DWORD PTR $T245478[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T245476[esp+8], 0
	mov	eax, DWORD PTR $T245476[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3607 : 	}

	pop	ecx
	ret	0
??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@0V12@@Z ; stdext::unchecked_copy_backward<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy_backward@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@0V12@@Z
_TEXT	SEGMENT
$T245490 = -4						; size = 1
__Cat$245496 = 8					; size = 1
$T245492 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@0V12@@Z PROC ; stdext::unchecked_copy_backward<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$245496[esp]
	mov	edx, DWORD PTR $T245492[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T245490[esp+8], 0
	mov	eax, DWORD PTR $T245490[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@0V12@@Z ENDP ; stdext::unchecked_copy_backward<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@0V12@@Z ; stdext::unchecked_copy<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_copy@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@0V12@@Z
_TEXT	SEGMENT
$T245504 = -4						; size = 1
__Cat$245510 = 8					; size = 1
$T245506 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@0V12@@Z PROC ; stdext::unchecked_copy<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$245510[esp]
	mov	edx, DWORD PTR $T245506[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T245504[esp+8], 0
	mov	eax, DWORD PTR $T245504[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3607 : 	}

	pop	ecx
	ret	0
??$unchecked_copy@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@0V12@@Z ENDP ; stdext::unchecked_copy<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T245520 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+12]
	xor	ebx, ebx
	mov	DWORD PTR $T245520[esp+16], ebx
	cmp	ecx, edi
	je	SHORT $LN1@Copy_opt@8
	lea	esi, DWORD PTR [ebx+16]
	npad	7
$LL3@Copy_opt@8:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __Dest$[esp+28]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN14@Copy_opt@8
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __Dest$[esp+28]
	add	DWORD PTR [eax+4], esi
	jmp	SHORT $LN2@Copy_opt@8
$LN14@Copy_opt@8:
	cmp	eax, ebx
	je	SHORT $LN19@Copy_opt@8
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR __Dest$[esp+28]
$LN19@Copy_opt@8:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN2@Copy_opt@8:
	add	ecx, esi
	cmp	ecx, edi
	jne	SHORT $LL3@Copy_opt@8
$LN1@Copy_opt@8:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	cmp	eax, ebx
	je	SHORT $LN41@Copy_opt@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Copy_opt@8:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 4
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::random_access_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	ebx

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ebx, DWORD PTR __Dest$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Last1$[esp+4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp+8]
	push	edi
	mov	edi, DWORD PTR __First2$[esp+12]
	cmp	esi, ebp
	je	$LN38@Merge@2
	npad	4
$LL5@Merge@2:
	mov	edx, DWORD PTR __Last2$[esp+12]
	cmp	edi, edx
	je	$LN3@Merge@2

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [edi+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[esp+44]
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN2@Merge@2

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ebx+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [ebx+8], edx
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [ebx+12], eax
	add	edi, 16					; 00000010H

; 2600 : 		else

	jmp	SHORT $LN4@Merge@2
$LN2@Merge@2:

; 2601 : 			*_Dest = *_First1, ++_First1;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [ebx+4], edx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx+8], eax
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [ebx+12], ecx
	add	esi, 16					; 00000010H
$LN4@Merge@2:
	add	ebx, 16					; 00000010H
	cmp	esi, ebp
	jne	$LL5@Merge@2
$LN38@Merge@2:

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	edx, DWORD PTR __Last2$[esp+12]
$LN3@Merge@2:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	eax, esi
	cmp	esi, ebp
	je	SHORT $LN14@Merge@2
$LL16@Merge@2:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ebx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ebx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [ebx+12], ecx
	add	eax, 16					; 00000010H
	add	ebx, 16					; 00000010H
	cmp	eax, ebp
	jne	SHORT $LL16@Merge@2
$LN14@Merge@2:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	eax, ebx
	mov	ecx, edi
	cmp	edi, edx
	je	SHORT $LN25@Merge@2
	npad	2
$LL27@Merge@2:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL27@Merge@2
$LN25@Merge@2:

; 2605 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$rotate@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@00@Z ; std::rotate<CvHomelandUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@00@Z PROC ; std::rotate<CvHomelandUnit *>, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN6@rotate@2
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN6@rotate@2

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00PAH0@Z ; std::_Rotate<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 20					; 00000014H
$LN6@rotate@2:

; 1721 : 	}

	ret	0
??$rotate@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@00@Z ENDP ; std::rotate<CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>, COMDAT

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	edx, DWORD PTR __First1$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+8]
	cmp	edx, esi
	je	SHORT $LN20@Merge@3
	npad	5
$LL5@Merge@3:
	cmp	ecx, edi
	je	SHORT $LN3@Merge@3

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	ebx, DWORD PTR [ecx+8]
	cmp	ebx, DWORD PTR [edx+8]
	jge	SHORT $LN2@Merge@3

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [ecx+12]
	add	ecx, 16					; 00000010H

; 2516 : 		else

	jmp	SHORT $LN44@Merge@3
$LN2@Merge@3:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [edx+12]
	add	edx, 16					; 00000010H
$LN44@Merge@3:
	mov	DWORD PTR [eax+12], ebx
	add	eax, 16					; 00000010H
	cmp	edx, esi
	jne	SHORT $LL5@Merge@3
$LN3@Merge@3:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	edx, esi
	je	SHORT $LN20@Merge@3
$LL22@Merge@3:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ebx
	add	edx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	edx, esi
	jne	SHORT $LL22@Merge@3
$LN20@Merge@3:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	cmp	ecx, edi
	je	SHORT $LN31@Merge@3
	npad	4
$LL33@Merge@3:
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edi
	jne	SHORT $LL33@Merge@3
$LN31@Merge@3:
	pop	edi
	pop	esi
	pop	ebx

; 2521 : 	}

	ret	0
??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@@std@@YAPAVCvHomelandUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@@std@@YAPAVCvHomelandUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@@std@@YAPAVCvHomelandUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>, COMDAT

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	ecx, DWORD PTR __Last1$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	edx, DWORD PTR __Last2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __First1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __First2$[esp+8]
	cmp	esi, ecx
	je	SHORT $LN19@Merge_back@3
	npad	5
$LL8@Merge_back@3:

; 2714 : 		else if (_First2 == _Last2)

	cmp	edi, edx
	je	SHORT $LN20@Merge_back@3

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	ebx, DWORD PTR [edx-8]
	sub	edx, 16					; 00000010H
	sub	ecx, 16					; 00000010H

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	sub	eax, 16					; 00000010H
	cmp	ebx, DWORD PTR [ecx+8]
	jge	SHORT $LN2@Merge_back@3
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [ecx+12]
	add	edx, 16					; 00000010H

; 2718 : 		else

	jmp	SHORT $LN22@Merge_back@3
$LN2@Merge_back@3:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [edx+12]
	add	ecx, 16					; 00000010H
$LN22@Merge_back@3:
	mov	DWORD PTR [eax+12], ebx
	cmp	esi, ecx
	jne	SHORT $LL8@Merge_back@3
$LN19@Merge_back@3:

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	push	eax
	push	edx
	push	edi

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	call	??$unchecked_copy_backward@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvHomelandUnit *,CvHomelandUnit *>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2720 : 	}

	ret	0
$LN20@Merge_back@3:

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	push	eax
	push	ecx
	push	esi
	call	??$unchecked_copy_backward@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvHomelandUnit *,CvHomelandUnit *>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2720 : 	}

	ret	0
??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@@std@@YAPAVCvHomelandUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	??$_Lower_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Lower_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Lower_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z PROC ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int>, COMDAT

; 2252 : 	{	// find first element not before _Val, using operator<

	push	esi

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;
; 2255 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	sub	esi, edi
	sar	esi, 4

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	esi, esi
	jle	SHORT $LN26@Lower_boun@4
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ebx
	mov	ebx, DWORD PTR [eax+8]
	npad	5
$LL4@Lower_boun@4:

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1

; 2260 : 		_FwdIt _Mid = _First;
; 2261 : 		std::advance(_Mid, _Count2);

	mov	ecx, eax
	shl	ecx, 4
	add	ecx, edi

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	cmp	DWORD PTR [ecx+8], ebx
	jge	SHORT $LN2@Lower_boun@4

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	edi, DWORD PTR [ecx+16]
	or	ecx, -1
	sub	ecx, eax
	add	esi, ecx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun@4
$LN2@Lower_boun@4:

; 2267 : 			_Count = _Count2;

	mov	esi, eax
$LN1@Lower_boun@4:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	esi, esi
	jg	SHORT $LL4@Lower_boun@4
	pop	ebx
$LN26@Lower_boun@4:

; 2268 : 		}
; 2269 : 	return (_First);

	mov	eax, edi
	pop	edi
	pop	esi

; 2270 : 	}

	ret	0
??$_Lower_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z ENDP ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Upper_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z PROC ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int>, COMDAT

; 2324 : 	{	// find first element that _Val is before, using operator<

	push	esi

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;
; 2327 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	sub	esi, edi
	sar	esi, 4

; 2328 : 	for (; 0 < _Count; )

	test	esi, esi
	jle	SHORT $LN26@Upper_boun@4
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ebx
	mov	ebx, DWORD PTR [eax+8]
	npad	5
$LL4@Upper_boun@4:

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1

; 2331 : 		_FwdIt _Mid = _First;
; 2332 : 		std::advance(_Mid, _Count2);

	mov	ecx, eax
	shl	ecx, 4
	add	ecx, edi

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	cmp	ebx, DWORD PTR [ecx+8]
	jl	SHORT $LN2@Upper_boun@4

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	edi, DWORD PTR [ecx+16]
	or	ecx, -1
	sub	ecx, eax
	add	esi, ecx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun@4
$LN2@Upper_boun@4:

; 2338 : 			_Count = _Count2;

	mov	esi, eax
$LN1@Upper_boun@4:

; 2328 : 	for (; 0 < _Count; )

	test	esi, esi
	jg	SHORT $LL4@Upper_boun@4
	pop	ebx
$LN26@Upper_boun@4:

; 2339 : 		}
; 2340 : 	return (_First);

	mov	eax, edi
	pop	edi
	pop	esi

; 2341 : 	}

	ret	0
??$_Upper_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z ENDP ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax-8]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 8
	mov	edx, esp
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax-8]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 8
	mov	edx, esp
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T246006 = -24						; size = 4
$T246000 = -24						; size = 4
$T245998 = -24						; size = 4
$T245999 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	sub	esp, 24					; 00000018H

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp+20]
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T246006[esp+32], edi
	cmp	eax, DWORD PTR __Last1$[esp+28]
	je	SHORT $LN3@Merge@4
	mov	ecx, DWORD PTR __First2$[esp+28]
	npad	7
$LL4@Merge@4:
	cmp	ecx, DWORD PTR __Last2$[esp+28]
	je	SHORT $LN3@Merge@4

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR [eax+16]
	jle	SHORT $LN2@Merge@4

; 2515 : 			*_Dest = *_First2, ++_First2;

	push	ecx
	lea	ecx, DWORD PTR __Dest$[esp+32]
	call	??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABVCvHomelandTarget@@@Z ; std::_Temp_iterator<CvHomelandTarget>::operator=
	mov	ecx, DWORD PTR __First2$[esp+28]

; 2516 : 		else

	mov	eax, DWORD PTR __First1$[esp+28]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __First2$[esp+28], ecx
	jmp	SHORT $LN52@Merge@4
$LN2@Merge@4:

; 2517 : 			*_Dest = *_First1, ++_First1;

	push	eax
	lea	ecx, DWORD PTR __Dest$[esp+32]
	call	??4?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEAAV01@ABVCvHomelandTarget@@@Z ; std::_Temp_iterator<CvHomelandTarget>::operator=
	mov	eax, DWORD PTR __First1$[esp+28]
	mov	ecx, DWORD PTR __First2$[esp+28]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __First1$[esp+28], eax
$LN52@Merge@4:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	eax, DWORD PTR __Last1$[esp+28]
	jne	SHORT $LL4@Merge@4
$LN3@Merge@4:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last1$[esp+48]
	mov	eax, DWORD PTR __First1$[esp+48]
	mov	DWORD PTR $T245998[esp+52], esp
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T245999[esp+60]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T245999[esp+64]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[esp+44], edx
	cmp	eax, edi
	je	SHORT $LN68@Merge@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN68@Merge@4:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+28]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+64]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last2$[esp+48]
	mov	eax, DWORD PTR __First2$[esp+48]
	mov	DWORD PTR $T246000[esp+52], esp
	push	edx
	push	eax
	push	esi
	call	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	mov	eax, DWORD PTR __Dest$[esp+60]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN89@Merge@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN89@Merge@4:

; 2521 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T246153 = 12						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
$T246220 = 20						; size = 1
$T246195 = 20						; size = 1
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Cat$246225 = 28					; size = 1
$T246222 = 28						; size = 1
__Cat$246200 = 28					; size = 1
$T246197 = 28						; size = 1
__Dest$ = 28						; size = 4
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>, COMDAT

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __Last1$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __First2$[esp+8]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+12]
	cmp	eax, edx
	je	SHORT $LN3@Merge@5
	npad	4
$LL10@Merge@5:
	cmp	esi, edi
	je	SHORT $LN3@Merge@5

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	ebx, DWORD PTR [esi+16]
	cmp	ebx, DWORD PTR [eax+16]
	jle	SHORT $LN2@Merge@5

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], ebx
	mov	ecx, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+4], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+8], ecx
	mov	ecx, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+12], ecx
	mov	ecx, DWORD PTR [esi+16]
	add	esi, 20					; 00000014H

; 2516 : 		else

	jmp	SHORT $LN37@Merge@5
$LN2@Merge@5:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebx
	mov	ecx, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	add	eax, 20					; 00000014H
$LN37@Merge@5:
	mov	ebx, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [ebx+16], ecx
	mov	ecx, DWORD PTR __Dest$[esp+12]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __Dest$[esp+12], ecx
	cmp	eax, edx
	jne	SHORT $LL10@Merge@5
$LN3@Merge@5:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	xor	bl, bl
	mov	BYTE PTR $T246195[esp+12], bl
	mov	ebp, DWORD PTR $T246195[esp+12]
	push	ebp
	mov	ebp, DWORD PTR __Cat$246200[esp+16]
	push	ebp
	mov	ebp, DWORD PTR $T246197[esp+20]
	push	ebp
	push	ecx
	push	edx
	push	eax
	lea	edx, DWORD PTR $T246153[esp+36]
	push	edx
	call	??$_Copy_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Cat$246225[esp+40]
	mov	edx, DWORD PTR $T246222[esp+40]
	mov	BYTE PTR $T246220[esp+40], bl
	mov	eax, DWORD PTR $T246220[esp+40]
	push	eax
	mov	eax, DWORD PTR $T246153[esp+44]
	push	ecx
	push	edx
	push	eax
	push	edi
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+64]
	push	esi
	call	??$_Copy_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 2521 : 	}

	ret	0
??$_Merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00PAHPAVCvHomelandTarget@@@Z ; std::_Rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00PAHPAVCvHomelandTarget@@@Z
_TEXT	SEGMENT
tv364 = -40						; size = 4
tv431 = -36						; size = 4
$T246240 = -32						; size = 4
$T246244 = -28						; size = 4
$T246245 = -24						; size = 4
__Holeval$236668 = -20					; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00PAHPAVCvHomelandTarget@@@Z PROC ; std::_Rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>, COMDAT

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	ecx, DWORD PTR __Mid$[esp-4]
	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __First$[esp+48]
	sub	ecx, esi
	mov	eax, 1717986919				; 66666667H
	imul	ecx

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp+48]
	sar	edx, 3
	mov	ebx, edx
	sub	ecx, esi
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	push	edi
	mov	ebp, ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	edi, ebx
	test	ebx, ebx
	je	SHORT $LN7@Rotate@3
$LL8@Rotate@3:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, ebp
	cdq
	idiv	edi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	ebp, edi
	mov	edi, edx
	test	edx, edx
	jne	SHORT $LL8@Rotate@3
$LN7@Rotate@3:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	ebp, ecx
	jge	$LN3@Rotate@3

; 1692 : 		for (; 0 < _Count; --_Count)

	test	ebp, ebp
	jle	$LN3@Rotate@3
	lea	eax, DWORD PTR [ebx+ebx*4]
	add	eax, eax
	lea	edx, DWORD PTR [ebp+ebp*4]
	add	eax, eax
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR tv364[esp+56], eax
	mov	DWORD PTR tv431[esp+56], edx
	jmp	SHORT $LN5@Rotate@3
	npad	9
$LL93@Rotate@3:
	mov	esi, DWORD PTR __First$[esp+52]
	mov	eax, DWORD PTR tv364[esp+56]
$LN5@Rotate@3:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;

	lea	edi, DWORD PTR [edx+esi]

; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR __Holeval$236668[esp+56], esi
	mov	esi, DWORD PTR [edi+4]
	mov	DWORD PTR __Holeval$236668[esp+60], esi
	mov	esi, DWORD PTR [edi+8]
	mov	DWORD PTR __Holeval$236668[esp+64], esi
	mov	esi, DWORD PTR [edi+12]
	mov	DWORD PTR __Holeval$236668[esp+68], esi
	mov	esi, DWORD PTR [edi+16]

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	add	eax, edi
	mov	ecx, edi
	mov	DWORD PTR __Holeval$236668[esp+72], esi
	cmp	eax, DWORD PTR __Last$[esp+52]
	jne	SHORT $LN11@Rotate@3
	lea	eax, DWORD PTR __First$[esp+52]
	jmp	SHORT $LN12@Rotate@3
$LN11@Rotate@3:
	mov	DWORD PTR $T246240[esp+56], eax
	lea	eax, DWORD PTR $T246240[esp+56]
$LN12@Rotate@3:
	mov	esi, DWORD PTR [eax]

; 1698 : 			while (_Next1 != _Hole)

	cmp	esi, edi
	je	SHORT $LN1@Rotate@3
	npad	5
$LL2@Rotate@3:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], eax
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+16], eax

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edx, DWORD PTR __Last$[esp+52]
	sub	edx, esi
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebx, eax
	mov	ecx, esi
	jge	SHORT $LN13@Rotate@3
	mov	edx, DWORD PTR tv364[esp+56]
	add	edx, esi
	mov	DWORD PTR $T246244[esp+56], edx
	lea	eax, DWORD PTR $T246244[esp+56]
	jmp	SHORT $LN14@Rotate@3
$LN13@Rotate@3:
	mov	edx, ebx
	sub	edx, eax
	lea	eax, DWORD PTR [edx+edx*4]
	mov	edx, DWORD PTR __First$[esp+52]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T246245[esp+56], eax
	lea	eax, DWORD PTR $T246245[esp+56]
$LN14@Rotate@3:
	mov	esi, DWORD PTR [eax]
	cmp	esi, edi
	jne	SHORT $LL2@Rotate@3

; 1698 : 			while (_Next1 != _Hole)

	mov	edx, DWORD PTR tv431[esp+56]
$LN1@Rotate@3:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	eax, DWORD PTR __Holeval$236668[esp+56]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Holeval$236668[esp+60]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Holeval$236668[esp+64]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __Holeval$236668[esp+68]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR __Holeval$236668[esp+72]
	dec	ebp
	sub	edx, 20					; 00000014H
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR tv431[esp+56], edx
	test	ebp, ebp
	jg	$LL93@Rotate@3
$LN3@Rotate@3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1706 : 			}
; 1707 : 	}

	add	esp, 40					; 00000028H
	ret	0
??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00PAHPAVCvHomelandTarget@@@Z ENDP ; std::_Rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
_TEXT	ENDS
PUBLIC	?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ReviewUnassignedUnits
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
EXTRN	?SetTurnProcessed@CvUnit@@QAEX_N@Z:PROC		; CvUnit::SetTurnProcessed
EXTRN	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SKIP
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ$2
__ehfuncinfo$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_pUnit$226906 = -76					; size = 8
_strTemp$226908 = -68					; size = 28
_strLogString$226911 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ReviewUnassignedUnits, COMDAT
; _this$ = ecx

; 2221 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebp
	push	edi
	mov	edi, ecx

; 2222 : 	// Loop through all remaining units
; 2223 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [edi+8]
	mov	ebp, DWORD PTR [eax]
	cmp	ebp, eax
	je	$LN3@ReviewUnas
	push	ebx
	push	esi
	mov	ebx, 1
$LL21@ReviewUnas:

; 2224 : 	{
; 2225 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$226906[esp+92], esi
	mov	BYTE PTR _pUnit$226906[esp+96], 0
	test	esi, esi
	je	SHORT $LN44@ReviewUnas
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN44@ReviewUnas:
	mov	DWORD PTR __$EHRec$[esp+100], 0

; 2226 : 		if(pUnit)

	test	esi, esi
	je	$LN2@ReviewUnas

; 2227 : 		{
; 2228 : 			pUnit->PushMission(CvTypes::getMISSION_SKIP());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2229 : 			pUnit->SetTurnProcessed(true);

	push	ebx
	mov	ecx, esi
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed

; 2230 : 
; 2231 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226908[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2232 : 			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pUnit->getUnitType());

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+100], bl
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 2233 : 			if(pkUnitInfo)

	test	eax, eax
	je	SHORT $LN1@ReviewUnas

; 2234 : 			{
; 2235 : 				strTemp = pkUnitInfo->GetDescription();

	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$226908[esp+92]
	test	eax, eax
	je	SHORT $LN60@ReviewUnas
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN59@ReviewUnas
$LN60@ReviewUnas:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN59@ReviewUnas:

; 2236 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226911[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2237 : 				strLogString.Format("Unassigned %s at, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$226908[esp+100]
	mov	BYTE PTR __$EHRec$[esp+108], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$226911[esp+104]
	push	OFFSET $SG226912
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2238 : 				LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$226911[esp+92]
	push	edx
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2239 : 			}

	lea	ecx, DWORD PTR _strLogString$226911[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ReviewUnas:

; 2240 : 		}

	lea	ecx, DWORD PTR _strTemp$226908[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ReviewUnas:

; 2241 : 	}

	mov	DWORD PTR __$EHRec$[esp+100], -1
	test	esi, esi
	je	SHORT $LN4@ReviewUnas
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@ReviewUnas:
	mov	ebp, DWORD PTR [ebp]
	cmp	ebp, DWORD PTR [edi+8]
	jne	$LL21@ReviewUnas
	pop	esi
	pop	ebx
$LN3@ReviewUnas:

; 2242 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 76					; 0000004cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226906[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strTemp$226908[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$226911[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ReviewUnassignedUnits
PUBLIC	?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z ; CvHomelandAI::FindPatrolTarget
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z:PROC ; CvPlot::isVisibleEnemyUnit
EXTRN	?PlotValid@CvUnit@@QBE_NPAVCvPlot@@@Z:PROC	; CvUnit::PlotValid
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$6
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_iBestValue$ = -80					; size = 4
_iI$ = -76						; size = 4
_pBestPlot$ = -72					; size = 4
_strLogString$228752 = -68				; size = 28
_strLogString$228748 = -68				; size = 28
_strLogString$228744 = -68				; size = 28
_strLogString$228740 = -68				; size = 28
_strLogString$228736 = -68				; size = 28
_strLogString$228731 = -68				; size = 28
_strLogString$228756 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z PROC ; CvHomelandAI::FindPatrolTarget, COMDAT
; _this$ = ecx

; 5403 : {

	push	-1
	push	__ehhandler$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	ebp
	push	esi

; 5404 : 	CvPlot* pAdjacentPlot;
; 5405 : 	CvPlot* pBestPlot;
; 5406 : 	int iValue;
; 5407 : 	int iBestValue;
; 5408 : 	int iI;
; 5409 : 
; 5410 : 	iBestValue = 0;

	xor	edx, edx
	push	edi

; 5411 : 	pBestPlot = NULL;
; 5412 : 
; 5413 : #ifdef AUI_HOMELAND_FIND_PATROL_TARGET_DESIRES_BORDER_AND_ROUTE_AND_CIVILIAN_GUARD
; 5414 : 	int iValueBonus;
; 5415 : 	if (pUnit->IsCombatUnit())
; 5416 : 	{
; 5417 : 		pBestPlot = pUnit->plot();
; 5418 : 		const IDInfo* pUnitNode = pBestPlot->headUnitNode();
; 5419 : 		const UnitHandle pLoopUnit;
; 5420 : 
; 5421 : 		while (pUnitNode != NULL)
; 5422 : 		{
; 5423 : 			pLoopUnit = GetPlayerUnit(*pUnitNode);
; 5424 : 			if (pLoopUnit && !pLoopUnit->IsCombatUnit())
; 5425 : 			{
; 5426 : 				if (!pLoopUnit->canMove())
; 5427 : 					return pBestPlot;
; 5428 : 				else
; 5429 : 				{
; 5430 : 					iBestValue = 20001;
; 5431 : 					break;
; 5432 : 				}
; 5433 : 			}
; 5434 : 			pUnitNode = pBestPlot->nextUnitNode(pUnitNode);
; 5435 : 		}
; 5436 : 	}
; 5437 : #endif
; 5438 : 
; 5439 : #if defined(AUI_HOMELAND_TWEAKED_FIND_PATROL_TARGET_CIVILIAN_NO_DANGER)
; 5440 : 	int iMyDanger = m_pPlayer->GetPlotDanger(*(pUnit->plot()));
; 5441 : #endif
; 5442 : 
; 5443 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	edi, DWORD PTR _pUnit$[esp+88]
	mov	ebp, ecx
	mov	DWORD PTR _iBestValue$[esp+92], edx
	mov	DWORD PTR _pBestPlot$[esp+92], edx
	mov	DWORD PTR _iI$[esp+92], edx
	push	ebx
$LL114@FindPatrol:

; 5444 : 	{
; 5445 : 		pAdjacentPlot = plotDirection(pUnit->getX(), pUnit->getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	push	edx
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 5446 : 
; 5447 : 		if(pAdjacentPlot != NULL)

	test	esi, esi
	je	$LN19@FindPatrol

; 5448 : 		{
; 5449 : 			if(pUnit->PlotValid(pAdjacentPlot))

	push	esi
	mov	ecx, edi
	call	?PlotValid@CvUnit@@QBE_NPAVCvPlot@@@Z	; CvUnit::PlotValid
	test	al, al
	je	$LN18@FindPatrol

; 5450 : 			{
; 5451 : 				if(!(pAdjacentPlot->isVisibleEnemyUnit(pUnit)))

	push	edi
	mov	ecx, esi
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	test	al, al
	jne	$LN17@FindPatrol

; 5452 : 				{
; 5453 : 					if(pUnit->GeneratePath(pAdjacentPlot, 0, true))

	push	0
	push	1
	push	0
	push	esi
	mov	ecx, edi
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	test	al, al
	je	$LN16@FindPatrol

; 5454 : 					{
; 5455 : #ifdef AUI_HOMELAND_FIND_PATROL_TARGET_DESIRES_BORDER_AND_ROUTE_AND_CIVILIAN_GUARD
; 5456 : 						iValueBonus = 0;
; 5457 : #endif
; 5458 : 						iValue = (1 + GC.getGame().getJonRandNum(10000, "AI Patrol"));

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG228728
	push	10000					; 00002710H
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 5459 : 
; 5460 : 						// Prefer wandering in our own territory
; 5461 : 						if(pAdjacentPlot->getOwner() == pUnit->getOwner())

	movsx	ecx, BYTE PTR [esi+4]
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+40]
	inc	ebx
	cmp	ecx, eax
	jne	SHORT $LN15@FindPatrol

; 5462 : 						{
; 5463 : #ifdef AUI_HOMELAND_FIND_PATROL_TARGET_DESIRES_BORDER_AND_ROUTE_AND_CIVILIAN_GUARD
; 5464 : 							iValueBonus = 5000;
; 5465 : #ifdef AUI_HOMELAND_FIND_PATROL_MOVES_CIVILIANS_PATROL_TO_SAFETY
; 5466 : 							if (pAdjacentPlot->isAdjacentPlayer(NO_PLAYER) || pAdjacentPlot->IsAdjacentOwnedByOtherTeam(m_pPlayer->getTeam()) || pAdjacentPlot->isValidRoute(pUnit))
; 5467 : #else
; 5468 : 							if ((pUnit->IsCombatUnit() && (pAdjacentPlot->isAdjacentPlayer(NO_PLAYER) || pAdjacentPlot->IsAdjacentOwnedByOtherTeam(m_pPlayer->getTeam()))) ||
; 5469 : 								(pAdjacentPlot->isValidRoute(pUnit) && (!pAdjacentPlot->isCity() || !pUnit->IsCombatUnit())))
; 5470 : #endif
; 5471 : 							{
; 5472 : 								iValueBonus += 5000;
; 5473 : 							}
; 5474 : #else
; 5475 : 							iValue += 10000;

	add	ebx, 10000				; 00002710H
$LN15@FindPatrol:

; 5476 : #endif
; 5477 : 						}
; 5478 : 
; 5479 : #if defined(AUI_HOMELAND_TWEAKED_FIND_PATROL_TARGET_CIVILIAN_NO_DANGER)
; 5480 : 						if (!pUnit->IsCombatUnit())
; 5481 : 						{
; 5482 : 							int iDanger = m_pPlayer->GetPlotDanger(*pAdjacentPlot);
; 5483 : 							if (iDanger > 0)
; 5484 : 							{
; 5485 : 								if (iMyDanger > 0)
; 5486 : 								{
; 5487 : 									iValue -= iDanger;
; 5488 : #ifdef AUI_HOMELAND_FIND_PATROL_TARGET_DESIRES_BORDER_AND_ROUTE_AND_CIVILIAN_GUARD
; 5489 : 									iValueBonus = 0;
; 5490 : #else
; 5491 : 									// Almost nullifies the value bonus from being in our own territory
; 5492 : 									if (pAdjacentPlot->getOwner() == pUnit->getOwner())
; 5493 : 									{
; 5494 : 										iValue -= 9999;
; 5495 : 									}
; 5496 : #endif
; 5497 : 								}
; 5498 : 								else
; 5499 : 								{
; 5500 : 									iValue = -1;
; 5501 : 								}
; 5502 : 							}
; 5503 : 						}
; 5504 : 						else
; 5505 : 						{
; 5506 : 							const IDInfo* pUnitNode = pAdjacentPlot->headUnitNode();
; 5507 : 							const UnitHandle pLoopUnit;
; 5508 : 
; 5509 : 							while (pUnitNode != NULL)
; 5510 : 							{
; 5511 : 								pLoopUnit = GetPlayerUnit(*pUnitNode);
; 5512 : 								if (pLoopUnit && !pLoopUnit->IsCombatUnit())
; 5513 : 								{
; 5514 : 									if (!pLoopUnit->canMove())
; 5515 : 										iValueBonus += 100000;
; 5516 : 									else
; 5517 : 										iValueBonus += 10000;
; 5518 : 									break;
; 5519 : 								}
; 5520 : 								pUnitNode = pAdjacentPlot->nextUnitNode(pUnitNode);
; 5521 : 							}
; 5522 : 						}
; 5523 : #endif
; 5524 : #ifdef AUI_HOMELAND_FIND_PATROL_TARGET_DESIRES_BORDER_AND_ROUTE_AND_CIVILIAN_GUARD
; 5525 : 						iValue += iValueBonus;
; 5526 : #endif
; 5527 : 
; 5528 : 						if(GC.getLogging() && GC.getAILogging()){

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN14@FindPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN14@FindPatrol

; 5529 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228731[esp+96]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5530 : 							strLogString.Format("Adjacent Patrol Plot Score, %i, %i, %i", iValue, pAdjacentPlot->getX(), pAdjacentPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	edx
	push	eax
	push	ebx
	lea	ecx, DWORD PTR _strLogString$228731[esp+108]
	push	OFFSET $SG228732
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+124], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 5531 : 							LogPatrolMessage(strLogString, pUnit);

	push	edi
	lea	edx, DWORD PTR _strLogString$228731[esp+100]
	push	edx
	mov	ecx, ebp
	call	?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z ; CvHomelandAI::LogPatrolMessage

; 5532 : 						}

	lea	ecx, DWORD PTR _strLogString$228731[esp+96]
	mov	DWORD PTR __$EHRec$[esp+104], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN14@FindPatrol:

; 5533 : 
; 5534 : 						if(iValue > iBestValue)

	cmp	ebx, DWORD PTR _iBestValue$[esp+96]
	jle	$LN21@FindPatrol

; 5535 : 						{
; 5536 : 							iBestValue = iValue;

	mov	DWORD PTR _iBestValue$[esp+96], ebx

; 5537 : 							pBestPlot = pAdjacentPlot;

	mov	DWORD PTR _pBestPlot$[esp+96], esi

; 5538 : 						}
; 5539 : 					}
; 5540 : 					else

	jmp	$LN21@FindPatrol
$LN16@FindPatrol:

; 5541 : 					{
; 5542 : 						if(GC.getLogging() && GC.getAILogging()){

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN21@FindPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN21@FindPatrol

; 5543 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228736[esp+96]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5544 : 							strLogString.Format("Adjacent Patrol Plot !GeneratePath(), , %i, %i", pAdjacentPlot->getX(), pAdjacentPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLogString$228736[esp+104]
	push	OFFSET $SG228737
	push	edx
	mov	DWORD PTR __$EHRec$[esp+120], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5545 : 							LogPatrolMessage(strLogString, pUnit);

	push	edi
	lea	eax, DWORD PTR _strLogString$228736[esp+100]
	push	eax

; 5546 : 						}
; 5547 : 					}
; 5548 : 				}
; 5549 : 				else

	jmp	$LN116@FindPatrol
$LN17@FindPatrol:

; 5550 : 				{
; 5551 : 					if(GC.getLogging() && GC.getAILogging()){

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN21@FindPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN21@FindPatrol

; 5552 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228740[esp+96]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5553 : 						strLogString.Format("Adjacent Patrol Plot !isVisibleEnemyUnit(), , %i, %i", pAdjacentPlot->getX(), pAdjacentPlot->getY());

	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strLogString$228740[esp+104]
	push	OFFSET $SG228741
	push	eax
	mov	DWORD PTR __$EHRec$[esp+120], 2
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5554 : 						LogPatrolMessage(strLogString, pUnit);
; 5555 : 					}
; 5556 : 				}
; 5557 : 			}
; 5558 : 			else

	jmp	$LN117@FindPatrol
$LN18@FindPatrol:

; 5559 : 			{
; 5560 : 				if(GC.getLogging() && GC.getAILogging()){

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN21@FindPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN21@FindPatrol

; 5561 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228744[esp+96]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5562 : 					strLogString.Format("Adjacent Patrol Plot not valid, , %i, %i", pAdjacentPlot->getX(), pAdjacentPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strLogString$228744[esp+104]
	push	OFFSET $SG228745
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+120], 3
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5563 : 					LogPatrolMessage(strLogString, pUnit);

	push	edi
	lea	edx, DWORD PTR _strLogString$228744[esp+100]
	push	edx

; 5564 : 				}
; 5565 : 			}
; 5566 : 		}
; 5567 : 		else

	jmp	SHORT $LN116@FindPatrol
$LN19@FindPatrol:

; 5568 : 		{
; 5569 : 			if(GC.getLogging() && GC.getAILogging()){

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN21@FindPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN21@FindPatrol

; 5570 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228748[esp+96]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5571 : 				strLogString.Format("Adjacent Patrol Plot not found");

	lea	eax, DWORD PTR _strLogString$228748[esp+96]
	push	OFFSET $SG228749
	push	eax
	mov	DWORD PTR __$EHRec$[esp+112], 4
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8
$LN117@FindPatrol:

; 5572 : 				LogPatrolMessage(strLogString, pUnit);

	push	edi
	lea	ecx, DWORD PTR _strLogString$228748[esp+100]
	push	ecx
$LN116@FindPatrol:
	mov	ecx, ebp
	call	?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z ; CvHomelandAI::LogPatrolMessage

; 5573 : 			}

	lea	ecx, DWORD PTR _strLogString$228748[esp+96]
	mov	DWORD PTR __$EHRec$[esp+104], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN21@FindPatrol:
	mov	edx, DWORD PTR _iI$[esp+96]
	inc	edx
	cmp	edx, 6
	mov	DWORD PTR _iI$[esp+96], edx
	jl	$LL114@FindPatrol

; 5574 : 		}
; 5575 : 	}
; 5576 : 
; 5577 : 	if(pBestPlot != NULL)

	mov	esi, DWORD PTR _pBestPlot$[esp+96]
	pop	ebx

; 5578 : 	{
; 5579 : 		if(GC.getLogging() && GC.getAILogging()){

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	test	esi, esi
	je	SHORT $LN4@FindPatrol
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN3@FindPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN3@FindPatrol

; 5580 : 			CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228752[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5581 : 			strLogString.Format("Patrol Target FOUND, %i, %i, %i", iBestValue, pBestPlot->getX(), pBestPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	mov	ecx, DWORD PTR _iBestValue$[esp+92]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLogString$228752[esp+104]
	push	OFFSET $SG228753
	push	edx
	mov	DWORD PTR __$EHRec$[esp+120], 5
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 5582 : 			LogPatrolMessage(strLogString, pUnit);

	push	edi
	lea	eax, DWORD PTR _strLogString$228752[esp+96]
	push	eax
	mov	ecx, ebp
	call	?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z ; CvHomelandAI::LogPatrolMessage

; 5583 : 		}

	lea	ecx, DWORD PTR _strLogString$228752[esp+92]
	mov	DWORD PTR __$EHRec$[esp+100], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@FindPatrol:
	pop	edi

; 5584 : 
; 5585 : 		CvAssert(!pUnit->atPlot(*pBestPlot));
; 5586 : 		return pBestPlot;

	mov	eax, esi
	pop	esi
	pop	ebp

; 5595 : 	}
; 5596 : 
; 5597 : 	return NULL;
; 5598 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	4
$LN4@FindPatrol:

; 5587 : 	}
; 5588 : 	else
; 5589 : 	{
; 5590 : 		if(GC.getLogging() && GC.getAILogging()){

	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@FindPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@FindPatrol

; 5591 : 			CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228756[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5592 : 			strLogString.Format("Patrol Target NOT FOUND");

	lea	ecx, DWORD PTR _strLogString$228756[esp+92]
	push	OFFSET $SG228757
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+108], 6
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 5593 : 			LogPatrolMessage(strLogString, pUnit);

	push	edi
	lea	edx, DWORD PTR _strLogString$228756[esp+96]
	push	edx
	mov	ecx, ebp
	call	?LogPatrolMessage@CvHomelandAI@@QAEXAAVCvString@@PAVCvUnit@@@Z ; CvHomelandAI::LogPatrolMessage

; 5594 : 		}

	lea	ecx, DWORD PTR _strLogString$228756[esp+92]
	mov	DWORD PTR __$EHRec$[esp+100], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@FindPatrol:

; 5595 : 	}
; 5596 : 
; 5597 : 	return NULL;
; 5598 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _strLogString$228731[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$1:
	lea	ecx, DWORD PTR _strLogString$228736[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$2:
	lea	ecx, DWORD PTR _strLogString$228740[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$3:
	lea	ecx, DWORD PTR _strLogString$228744[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$4:
	lea	ecx, DWORD PTR _strLogString$228748[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$5:
	lea	ecx, DWORD PTR _strLogString$228752[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z$6:
	lea	ecx, DWORD PTR _strLogString$228756[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z ENDP ; CvHomelandAI::FindPatrolTarget
PUBLIC	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val_arg$ = 8						; size = 4
?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::list<int,std::allocator<int> >::remove, COMDAT
; _this$ = ecx

; 928  : 		/* Dinkumware makes a copy of _Val_arg in case it's removed along the way, i.e.
; 929  : 		 * when the user pass an element of the list as _Val_arg.
; 930  : 		 *
; 931  : 		 * We believe that the signature of std::list::remove should be changed
; 932  : 		 * from remove(const _Ty&) to remove(_Ty) to explicitly indicate that a copy is involved.
; 933  : 		 */
; 934  : 		const _Ty _Val = _Val_arg;	// in case it's removed along the way

	mov	eax, DWORD PTR __Val_arg$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR [eax]
	push	esi
	mov	esi, ecx

; 935  : 		iterator _Last = end();

	mov	ebx, DWORD PTR [esi+4]

; 936  : 		for (iterator _First = begin(); _First != _Last; )

	mov	eax, DWORD PTR [ebx]
	cmp	eax, ebx
	je	SHORT $LN3@remove
	push	edi
$LL4@remove:

; 937  : 			if (*_First == _Val)

	cmp	DWORD PTR [eax+8], ebp
	jne	SHORT $LN2@remove

; 938  : 				_First = erase(_First);

	mov	edi, DWORD PTR [eax]
	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN31@remove
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], edi
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	push	eax
	mov	DWORD PTR [edx+4], ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	dec	DWORD PTR [esi+8]
$LN31@remove:
	mov	eax, edi

; 939  : 			else

	jmp	SHORT $LN64@remove
$LN2@remove:

; 940  : 				++_First;

	mov	eax, DWORD PTR [eax]
$LN64@remove:

; 936  : 		for (iterator _First = begin(); _First != _Last; )

	cmp	eax, ebx
	jne	SHORT $LL4@remove
	pop	edi
$LN3@remove:
	pop	esi
	pop	ebp
	pop	ebx

; 941  : 		}

	ret	4
?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::list<int,std::allocator<int> >::remove
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z PROC ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ENDP ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAEIABVCvHomelandMove@@@Z ; FStaticVector<CvHomelandMove,35,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAEIABVCvHomelandMove@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAEIABVCvHomelandMove@@@Z PROC ; FStaticVector<CvHomelandMove,35,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+292], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandMove,35,1,297,0>::GrowSize
$LN1@push_back@2:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@2
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAEIABVCvHomelandMove@@@Z ENDP ; FStaticVector<CvHomelandMove,35,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::vector<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::vector<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::vector<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	?reserve@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAEXI@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::reserve
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?reserve@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAEXI@Z
_TEXT	SEGMENT
_uiResSize$ = 8						; size = 4
?reserve@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAEXI@Z PROC ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::reserve, COMDAT
; _this$ = ecx

; 334  : 		GrowSizeToFit(uiResSize);

	mov	eax, DWORD PTR _uiResSize$[esp-4]
	cmp	eax, DWORD PTR [ecx+8]
	jbe	SHORT $LN4@reserve
	mov	DWORD PTR _uiResSize$[esp-4], eax
	jmp	?SetSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::SetSize
$LN4@reserve:

; 335  : 	};

	ret	4
?reserve@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAEXI@Z ENDP ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::reserve
_TEXT	ENDS
PUBLIC	?push_back@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAEIABU?$pair@HPAVCvPlot@@@std@@@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAEIABU?$pair@HPAVCvPlot@@@std@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAEIABU?$pair@HPAVCvPlot@@@std@@@Z PROC ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	esi
	mov	esi, ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@3

; 378  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::GrowSize
$LN1@push_back@3:

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@3
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@3:

; 380  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 381  : 	};

	ret	4
?push_back@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAEIABU?$pair@HPAVCvPlot@@@std@@@Z ENDP ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::push_back
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ ; CvWeightedVector<CvPlot *,100,1>::CvWeightedVector<CvPlot *,100,1>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ PROC	; CvWeightedVector<CvPlot *,100,1>::CvWeightedVector<CvPlot *,100,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 100			; 00000064H
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ ENDP	; CvWeightedVector<CvPlot *,100,1>::CvWeightedVector<CvPlot *,100,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ ; CvWeightedVector<CvPlot *,100,1>::~CvWeightedVector<CvPlot *,100,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ PROC	; CvWeightedVector<CvPlot *,100,1>::~CvWeightedVector<CvPlot *,100,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted:
	ret	0
??1?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ ENDP	; CvWeightedVector<CvPlot *,100,1>::~CvWeightedVector<CvPlot *,100,1>
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ ; CvWeightedVector<CvCity *,64,1>::CvWeightedVector<CvCity *,64,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ PROC	; CvWeightedVector<CvCity *,64,1>::CvWeightedVector<CvCity *,64,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 64			; 00000040H
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ ENDP	; CvWeightedVector<CvCity *,64,1>::CvWeightedVector<CvCity *,64,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ ; CvWeightedVector<CvCity *,64,1>::~CvWeightedVector<CvCity *,64,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ PROC	; CvWeightedVector<CvCity *,64,1>::~CvWeightedVector<CvCity *,64,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted@2:
	ret	0
??1?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ ENDP	; CvWeightedVector<CvCity *,64,1>::~CvWeightedVector<CvCity *,64,1>
_TEXT	ENDS
PUBLIC	??1?$_List_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_List_val<int,std::allocator<int> >::~_List_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_List_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_List_val<int,std::allocator<int> >::~_List_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_List_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_List_val<int,std::allocator<int> >::~_List_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Insert@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABH@Z ; std::list<int,std::allocator<int> >::_Insert
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ?_Insert@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABH@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABH@Z PROC ; std::list<int,std::allocator<int> >::_Insert, COMDAT
; _this$ = ecx

; 711  : 
; 712  :  #if _HAS_ITERATOR_DEBUGGING
; 713  : 		if (_Where._Mycont != this)
; 714  : 			_DEBUG_ERROR("list insert iterator outside range");
; 715  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 716  : 
; 717  : 		_Nodeptr _Pnode = _Where._Mynode();
; 718  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

	mov	eax, DWORD PTR __Where$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR __Val$[esp+8]
	lea	ebx, DWORD PTR [eax+4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, edi
	call	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z ; std::list<int,std::allocator<int> >::_Buynode

; 719  : 		_Incsize(1);

	push	1
	mov	ecx, edi
	mov	esi, eax
	call	?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::list<int,std::allocator<int> >::_Incsize

; 720  : 		_Prevnode(_Pnode) = _Newnode;

	mov	DWORD PTR [ebx], esi

; 721  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx

; 722  : 		}

	ret	8
?_Insert@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_Const_iterator@$0A@@12@ABH@Z ENDP ; std::list<int,std::allocator<int> >::_Insert
_TEXT	ENDS
PUBLIC	??0?$_List_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ; std::_List_val<int,std::allocator<int> >::_List_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_List_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z PROC ; std::_List_val<int,std::allocator<int> >::_List_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 85   : 		{	// construct base, and allocator from _Al

	mov	eax, ecx

; 86   : 		}

	ret	4
??0?$_List_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ENDP ; std::_List_val<int,std::allocator<int> >::_List_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Tidy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
_TEXT	ENDS
PUBLIC	?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::reserve
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEXI@Z
_TEXT	SEGMENT
_uiResSize$ = 8						; size = 4
?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::reserve, COMDAT
; _this$ = ecx

; 658  : 		GrowSizeToFit(uiResSize);

	jmp	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSizeToFit
?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::reserve
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+812], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@4

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSize
$LN1@push_back@4:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@4
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@4:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@Z ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@Z PROC ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+524], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@5

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN1@push_back@5:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@5
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@5:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??1TradeConnection@@QAE@XZ			; TradeConnection::~TradeConnection
; Function compile flags: /Ogtpy
;	COMDAT ??1TradeConnection@@QAE@XZ
_TEXT	SEGMENT
??1TradeConnection@@QAE@XZ PROC				; TradeConnection::~TradeConnection, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR [ecx+44]
	add	ecx, 56					; 00000038H
	cmp	eax, ecx
	je	SHORT $LN6@TradeConne
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@TradeConne:
	ret	0
??1TradeConnection@@QAE@XZ ENDP				; TradeConnection::~TradeConnection
_TEXT	ENDS
PUBLIC	??$find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z ; std::find<std::list<int,std::allocator<int> >::_Iterator<0>,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z PROC ; std::find<std::list<int,std::allocator<int> >::_Iterator<0>,int>, COMDAT

; 74   : 	_ASSIGN_FROM_BASE(_First,

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	ecx, eax
	je	SHORT $LN29@find
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
$LL11@find:
	cmp	DWORD PTR [ecx+8], edx
	je	SHORT $LN29@find
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, eax
	jne	SHORT $LL11@find
$LN29@find:

; 75   : 		_Find(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val));
; 76   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 77   : 	}

	ret	0
??$find@V?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@std@@H@std@@YA?AV?$_Iterator@$0A@@?$list@HV?$allocator@H@std@@@0@V120@0ABH@Z ENDP ; std::find<std::list<int,std::allocator<int> >::_Iterator<0>,int>
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAVCvHomelandTarget@@@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV2@00@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Ucopy<CvHomelandTarget *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??$_Ucopy@PAVCvHomelandTarget@@@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV2@00@Z
_TEXT	SEGMENT
$T247657 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$247660 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@PAVCvHomelandTarget@@@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV2@00@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Ucopy<CvHomelandTarget *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$247660[esp]
	mov	BYTE PTR $T247657[esp+4], 0
	mov	eax, DWORD PTR $T247657[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@PAVCvHomelandTarget@@@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV2@00@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Ucopy<CvHomelandTarget *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@0AAV?$allocator@VCvHomelandTarget@@@0@@Z ; std::_Destroy_range<std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@0AAV?$allocator@VCvHomelandTarget@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@0AAV?$allocator@VCvHomelandTarget@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvHomelandTarget> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@0AAV?$allocator@VCvHomelandTarget@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvHomelandTarget *,unsigned int,CvHomelandTarget,std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@std@@@Z
_TEXT	SEGMENT
$T247675 = -4						; size = 1
__Cat$247679 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvHomelandTarget *,unsigned int,CvHomelandTarget,std::allocator<CvHomelandTarget> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T247675[esp+4], 0
	mov	eax, DWORD PTR $T247675[esp+4]
	mov	ecx, DWORD PTR __Cat$247679[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvHomelandTarget *,unsigned int,CvHomelandTarget,std::allocator<CvHomelandTarget> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvHomelandTarget *,unsigned int,CvHomelandTarget,std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@2
	pop	esi
$LN9@Uninit_fil@2:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@std@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@3
	pop	esi
$LN9@Uninit_fil@3:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@std@@@Z
_TEXT	SEGMENT
$T247811 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$247814 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$247814[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T247811[esp+4], 0
	mov	eax, DWORD PTR $T247811[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@stdext@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAPAVCvPlot@@PAPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAPAPAVCvPlot@@PAPAV1@00AAV?$allocator@PAVCvPlot@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvPlot * *,CvPlot * *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvCity * *,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@4
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@4:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$make_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ; std::make_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$make_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$make_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z PROC ; std::make_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 2204 : 	_DEBUG_RANGE(_First, _Last);
; 2205 : 	_DEBUG_POINTER(_Pred);
; 2206 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap

; 2207 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Pred,
; 2208 : 			_Dist_type(_First), _Val_type(_First));

	mov	edx, DWORD PTR __Pred$[esp-4]
	push	0
	push	0
	push	edx
	push	eax
	push	ecx
	call	??$_Make_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@ZPAH0@Z ; std::_Make_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 20					; 00000014H
$LN1@make_heap:

; 2209 : 	}

	ret	0
??$make_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ENDP ; std::make_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ; std::_Insertion_sort<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Insertion_sort@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z PROC ; std::_Insertion_sort<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 3150 : 	std::_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@ZU12@@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z0@Z ; std::_Insertion_sort1<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &),std::pair<int,CvPlot *> >
	add	esp, 16					; 00000010H

; 3151 : 	}

	ret	0
??$_Insertion_sort@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ENDP ; std::_Insertion_sort<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__Tmp$248056 = -24					; size = 8
__Tmp$247985 = -16					; size = 8
__Tmp$248011 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 3
	cdq
	push	esi
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ebx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-8]
	push	eax
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Median<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+8]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_
$LL27@Unguarded_:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN99@Unguarded_
	jg	SHORT $LN99@Unguarded_

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_
$LN99@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL25@Unguarded_:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_
	jg	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+36]
	jae	SHORT $LN103@Unguarded_
	npad	6
$LL21@Unguarded_:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	jl	SHORT $LN20@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 8
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_
	mov	ebp, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$247985[esp+44], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	edx, DWORD PTR __Tmp$247985[esp+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
$LN20@Unguarded_:
	add	eax, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jb	SHORT $LL21@Unguarded_
$LN103@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+36]
	jbe	SHORT $LN115@Unguarded_
	lea	edx, DWORD PTR [ebx-8]
$LL14@Unguarded_:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jl	SHORT $LN13@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$248011[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$248011[esp+44]
	mov	DWORD PTR [edx+4], edi
$LN13@Unguarded_:
	sub	ebx, 8
	sub	edx, 8
	cmp	DWORD PTR __First$[esp+36], ebx
	jb	SHORT $LL14@Unguarded_
$LN111@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+36]
$LN115@Unguarded_:
	jne	SHORT $LN6@Unguarded_
	cmp	eax, DWORD PTR __Last$[esp+36]
	je	$LN105@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi
$LN64@Unguarded_:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	edi, ecx
	add	esi, 8
	add	ecx, 8
	add	eax, 8
	cmp	edi, edx
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$248056[esp+40], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$248056[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$248056[esp+40]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$248056[esp+44]
	mov	DWORD PTR [edx+4], edi
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN3@Unguarded_
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN78@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
$LN78@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebx
	je	SHORT $LN92@Unguarded_
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [ebx+4], edi
$LN92@Unguarded_:
	add	eax, 8

; 3076 : 		}

	jmp	$LL23@Unguarded_
$LN105@Unguarded_:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::make_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z PROC ; std::make_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap@2

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap@2:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__Tmp$248265 = -24					; size = 8
__Tmp$248194 = -16					; size = 8
__Tmp$248220 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 3
	cdq
	push	esi
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ebx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-8]
	push	eax
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Median<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+8]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_@2
$LL27@Unguarded_@2:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN99@Unguarded_@2
	jg	SHORT $LN99@Unguarded_@2

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_@2
$LN99@Unguarded_@2:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_@2
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL25@Unguarded_@2:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_@2
	jg	SHORT $LN24@Unguarded_@2

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_@2
$LN24@Unguarded_@2:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_@2:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+36]
	jae	SHORT $LN103@Unguarded_@2
	npad	6
$LL21@Unguarded_@2:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	jl	SHORT $LN20@Unguarded_@2

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_@2

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 8
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_@2
	mov	ebp, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$248194[esp+44], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	edx, DWORD PTR __Tmp$248194[esp+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
$LN20@Unguarded_@2:
	add	eax, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jb	SHORT $LL21@Unguarded_@2
$LN103@Unguarded_@2:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+36]
	jbe	SHORT $LN115@Unguarded_@2
	lea	edx, DWORD PTR [ebx-8]
$LL14@Unguarded_@2:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jl	SHORT $LN13@Unguarded_@2

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_@2

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_@2
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$248220[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$248220[esp+44]
	mov	DWORD PTR [edx+4], edi
$LN13@Unguarded_@2:
	sub	ebx, 8
	sub	edx, 8
	cmp	DWORD PTR __First$[esp+36], ebx
	jb	SHORT $LL14@Unguarded_@2
$LN111@Unguarded_@2:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+36]
$LN115@Unguarded_@2:
	jne	SHORT $LN6@Unguarded_@2
	cmp	eax, DWORD PTR __Last$[esp+36]
	je	$LN105@Unguarded_@2

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_@2

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_@2
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi
$LN64@Unguarded_@2:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	edi, ecx
	add	esi, 8
	add	ecx, 8
	add	eax, 8
	cmp	edi, edx
	je	$LL23@Unguarded_@2
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$248265[esp+40], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$248265[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$248265[esp+40]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$248265[esp+44]
	mov	DWORD PTR [edx+4], edi
	jmp	$LL23@Unguarded_@2
$LN6@Unguarded_@2:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN3@Unguarded_@2
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN78@Unguarded_@2

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
$LN78@Unguarded_@2:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_@2
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_@2
$LN3@Unguarded_@2:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebx
	je	SHORT $LN92@Unguarded_@2
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [ebx+4], edi
$LN92@Unguarded_@2:
	add	eax, 8

; 3076 : 		}

	jmp	$LL23@Unguarded_@2
$LN105@Unguarded_@2:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::make_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z PROC ; std::make_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap@3

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap@3:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@0@Z ; std::_Insertion_sort<CvHomelandMove *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@0@Z PROC ; std::_Insertion_sort<CvHomelandMove *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@00@Z ; std::_Insertion_sort1<CvHomelandMove *,CvHomelandMove>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@0@Z ENDP ; std::_Insertion_sort<CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAVCvHomelandUnit@@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z@Z ; std::_Insertion_sort<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAVCvHomelandUnit@@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Insertion_sort@PAVCvHomelandUnit@@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z@Z PROC ; std::_Insertion_sort<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 3150 : 	std::_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@PAVCvHomelandUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z0@Z ; std::_Insertion_sort1<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),CvHomelandUnit>
	add	esp, 16					; 00000010H

; 3151 : 	}

	ret	0
??$_Insertion_sort@PAVCvHomelandUnit@@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z@Z ENDP ; std::_Insertion_sort<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@0@Z ; std::_Insertion_sort<CvHomelandUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@0@Z PROC ; std::_Insertion_sort<CvHomelandUnit *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@00@Z ; std::_Insertion_sort1<CvHomelandUnit *,CvHomelandUnit>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@0@Z ENDP ; std::_Insertion_sort<CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	??$swap@HPAVCvPlot@@@std@@YAXAAU?$pair@HPAVCvPlot@@@0@0@Z ; std::swap<int,CvPlot *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\utility
;	COMDAT ??$swap@HPAVCvPlot@@@std@@YAXAAU?$pair@HPAVCvPlot@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@HPAVCvPlot@@@std@@YAXAAU?$pair@HPAVCvPlot@@@0@0@Z PROC ; std::swap<int,CvPlot *>, COMDAT

; 78   : 	_Left.swap(_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN13@swap@9
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ecx], edx
	add	ecx, 4
	add	eax, 4
	cmp	eax, ecx
	je	SHORT $LN17@swap@9
	mov	esi, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ecx], edx
$LN17@swap@9:
	pop	esi
$LN13@swap@9:

; 79   : 	}

	ret	0
??$swap@HPAVCvPlot@@@std@@YAXAAU?$pair@HPAVCvPlot@@@0@0@Z ENDP ; std::swap<int,CvPlot *>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ; std::pop_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$pop_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$pop_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z PROC ; std::pop_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 2152 : 	_DEBUG_RANGE(_First, _Last);
; 2153 : 	_DEBUG_POINTER(_Pred);
; 2154 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2155 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	push	esi
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	jle	SHORT $LN10@pop_heap

; 2156 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Pred, _Val_type(_First));

	mov	esi, DWORD PTR [eax-8]
	push	ebx
	mov	ebx, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], ebx
	mov	eax, DWORD PTR __Pred$[esp+8]
	push	eax
	push	edi
	add	edx, -8					; fffffff8H
	push	esi
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	call	??$_Adjust_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z ; std::_Adjust_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 24					; 00000018H
	pop	edi
	pop	ebx
$LN10@pop_heap:
	pop	esi

; 2157 : 	}

	ret	0
??$pop_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ENDP ; std::pop_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z
_TEXT	SEGMENT
$T248452 = -4						; size = 1
$T248459 = -4						; size = 4
$T248455 = -4						; size = 4
__Cat$248464 = 8					; size = 1
$T248454 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z PROC ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T248459[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$248464[esp+4]
	mov	edx, DWORD PTR $T248454[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T248452[esp+12], bl
	mov	eax, DWORD PTR $T248452[esp+12]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR $T248455[esp+44], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+40]
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_@13
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_@13:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ENDP ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvHomelandMove@@PAV1@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@0000@Z ; stdext::unchecked_merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$unchecked_merge@PAVCvHomelandMove@@PAV1@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@0000@Z
_TEXT	SEGMENT
$T248503 = -4						; size = 1
$T248504 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$unchecked_merge@PAVCvHomelandMove@@PAV1@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@0000@Z PROC ; stdext::unchecked_merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Dest$[esp]
	mov	BYTE PTR $T248503[esp+4], 0
	mov	eax, DWORD PTR $T248503[esp+4]
	mov	ecx, DWORD PTR $T248504[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Merge@PAVCvHomelandMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>

; 5117 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$unchecked_merge@PAVCvHomelandMove@@PAV1@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@0000@Z ENDP ; stdext::unchecked_merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAVCvHomelandMove@@HV1@@std@@YAPAVCvHomelandMove@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_rotate<CvHomelandMove *,int,CvHomelandMove>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@PAVCvHomelandMove@@HV1@@std@@YAPAVCvHomelandMove@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z
_TEXT	SEGMENT
$T248515 = -20						; size = 20
$T248513 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T248514 = 20						; size = 4
$T248512 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAVCvHomelandMove@@HV1@@std@@YAPAVCvHomelandMove@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z PROC ; std::_Buffered_rotate<CvHomelandMove *,int,CvHomelandMove>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebx, DWORD PTR __Count2$[esp+20]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Tempbuf$[esp+28]
	push	edi
	mov	edi, DWORD PTR __Count1$[esp+32]
	cmp	edi, ebx
	jg	$LN4@Buffered_r
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandMove>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR __Mid$[esp+32]
	mov	ebp, DWORD PTR __First$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T248512[esp+52], esp
	push	ebx
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T248513[esp+60]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	mov	eax, DWORD PTR $T248513[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN25@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edx, DWORD PTR __Last$[esp+32]
	mov	eax, ebx
	cmp	ebx, edx
	je	SHORT $LN33@Buffered_r
	mov	ecx, ebp
	sub	ecx, ebx
$LL35@Buffered_r:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx+eax], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+eax+4], edi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL35@Buffered_r
$LN33@Buffered_r:

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi]
	push	edx
	push	eax
	push	esi
	call	??$unchecked_copy_backward@PAVCvHomelandMove@@PAV1@@stdext@@YAPAVCvHomelandMove@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvHomelandMove *,CvHomelandMove *>
	add	esp, 12					; 0000000cH

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandMove>::_Maxlen
	cmp	ebx, eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebp, DWORD PTR __Last$[esp+32]
	mov	ebx, DWORD PTR __Mid$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T248514[esp+52], esp
	push	ebp
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T248515[esp+60]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	mov	eax, DWORD PTR $T248515[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN56@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	edi, DWORD PTR __First$[esp+32]
	mov	eax, ebx
	cmp	edi, ebx
	je	SHORT $LN64@Buffered_r
	mov	ecx, ebp
	sub	ecx, ebx
	npad	5
$LL65@Buffered_r:
	mov	edx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [ecx+eax], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+eax+4], edx
	cmp	eax, edi
	jne	SHORT $LL65@Buffered_r
$LN64@Buffered_r:

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	mov	eax, edi
	cmp	ecx, edx
	je	SHORT $LN1@Buffered_r
$LL80@Buffered_r:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL80@Buffered_r

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	esi, DWORD PTR __First$[esp+32]
	mov	eax, DWORD PTR __Mid$[esp+32]
	cmp	esi, eax
	je	SHORT $LN88@Buffered_r
	mov	ecx, DWORD PTR __Last$[esp+32]
	cmp	eax, ecx
	je	SHORT $LN88@Buffered_r
	xor	edi, edi
	push	edi
	push	edi
	push	ecx
	push	eax
	push	esi
	call	??$_Rotate@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00PAH0@Z ; std::_Rotate<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 20					; 00000014H
$LN88@Buffered_r:

; 2700 : 		std::advance(_First, _Count2);

	lea	eax, DWORD PTR [esi+ebx*8]
$LN1@Buffered_r:

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@PAVCvHomelandMove@@HV1@@std@@YAPAVCvHomelandMove@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ENDP ; std::_Buffered_rotate<CvHomelandMove *,int,CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAVCvHomelandTarget@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAVCvHomelandTarget@@@Z
_TEXT	SEGMENT
$T248847 = -28						; size = 1
$T248782 = -24						; size = 4
__Val$234207 = -20					; size = 20
__Cat$248852 = 8					; size = 1
$T248849 = 8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAVCvHomelandTarget@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>, COMDAT

; 2968 : 	if (_First != _Last)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 28					; 0000001cH
	cmp	ecx, eax
	je	$LN6@Insertion_@7
	push	esi

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	esi, DWORD PTR [ecx+20]
	cmp	esi, eax
	je	$LN73@Insertion_@7
	push	ebx
	push	ebp
	push	edi
	jmp	SHORT $LN7@Insertion_@7
$LL72@Insertion_@7:
	mov	ecx, DWORD PTR __First$[esp+40]
$LN7@Insertion_@7:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR [esi+8]
	mov	edi, DWORD PTR [esi+16]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	edi, DWORD PTR [ecx+16]
	mov	ebp, DWORD PTR [esi]
	mov	ebx, DWORD PTR [esi+4]
	mov	DWORD PTR __Val$234207[esp+52], edx
	mov	edx, DWORD PTR [esi+12]
	mov	eax, esi
	mov	DWORD PTR __Val$234207[esp+56], edx
	jle	SHORT $LN5@Insertion_@7

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	BYTE PTR $T248847[esp+44], 0
	mov	edx, DWORD PTR $T248847[esp+44]
	push	edx
	mov	edx, DWORD PTR __Cat$248852[esp+44]
	push	edx
	mov	edx, DWORD PTR $T248849[esp+48]
	push	edx
	lea	eax, DWORD PTR [esi+20]
	push	eax
	push	esi
	push	ecx
	lea	eax, DWORD PTR $T248782[esp+68]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>

; 2977 : 				*_First = _Val;

	mov	ecx, DWORD PTR __First$[esp+68]
	mov	DWORD PTR [ecx], ebp
	mov	edx, DWORD PTR __First$[esp+68]
	mov	ecx, DWORD PTR __Val$234207[esp+80]
	mov	DWORD PTR [edx+4], ebx
	mov	eax, DWORD PTR __First$[esp+68]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __First$[esp+68]
	mov	eax, DWORD PTR __Val$234207[esp+84]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR __First$[esp+68]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR [ecx+16], edi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@7
$LN5@Insertion_@7:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	edi, DWORD PTR [esi-4]
	lea	ecx, DWORD PTR [esi-20]
	jle	SHORT $LN1@Insertion_@7
$LL3@Insertion_@7:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, ecx
	sub	ecx, 20					; 00000014H
	cmp	edi, DWORD PTR [ecx+16]
	jg	SHORT $LL3@Insertion_@7
$LN1@Insertion_@7:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, DWORD PTR __Val$234207[esp+52]
	mov	edx, DWORD PTR __Val$234207[esp+56]
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], edi
$LN4@Insertion_@7:
	add	esi, 20					; 00000014H
	cmp	esi, DWORD PTR __Last$[esp+40]
	jne	$LL72@Insertion_@7
	pop	edi
	pop	ebp
	pop	ebx
$LN73@Insertion_@7:
	pop	esi
$LN6@Insertion_@7:

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAVCvHomelandTarget@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$lower_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@@Z ; std::lower_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@@Z
_TEXT	SEGMENT
$T248920 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$lower_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@@Z PROC ; std::lower_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>, COMDAT

; 2275 : 	{	// find first element not before _Val, using operator<

	push	ecx

; 2276 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T248920[esp+20]
	push	eax
	call	??$_Lower_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>

; 2277 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2278 : 	return _First;

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
	mov	DWORD PTR [eax], ecx

; 2279 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$lower_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@@Z ENDP ; std::lower_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$upper_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@@Z ; std::upper_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@@Z
_TEXT	SEGMENT
$T248927 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$upper_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@@Z PROC ; std::upper_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>, COMDAT

; 2346 : 	{	// find first element that _Val is before, using operator<

	push	ecx

; 2347 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T248927[esp+20]
	push	eax
	call	??$_Upper_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>

; 2348 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2349 : 	return _First;

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+20]
	mov	DWORD PTR [eax], ecx

; 2350 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$upper_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@@Z ENDP ; std::upper_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z
_TEXT	SEGMENT
$T248934 = -4						; size = 1
$T248941 = -4						; size = 4
$T248937 = -4						; size = 4
__Cat$248946 = 8					; size = 1
$T248936 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z PROC ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T248941[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$248946[esp+4]
	mov	edx, DWORD PTR $T248936[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T248934[esp+12], bl
	mov	eax, DWORD PTR $T248934[esp+12]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR $T248937[esp+44], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+40]
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_@14
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_@14:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ENDP ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@Z@Z ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$unchecked_merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@Z@Z
_TEXT	SEGMENT
$T248985 = -4						; size = 1
$T248986 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
__Pred$ = 28						; size = 4
??$unchecked_merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@Z@Z PROC ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ecx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Pred$[esp]
	mov	BYTE PTR $T248985[esp+4], 0
	mov	eax, DWORD PTR $T248985[esp+4]
	mov	ecx, DWORD PTR $T248986[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last2$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First2$[esp+12]
	push	eax
	mov	eax, DWORD PTR __Last1$[esp+16]
	push	ecx
	mov	ecx, DWORD PTR __First1$[esp+20]
	push	edx
	push	eax
	push	ecx
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::random_access_iterator_tag>

; 5160 : 	}

	add	esp, 36					; 00000024H
	ret	0
??$unchecked_merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@Z@Z ENDP ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAVCvHomelandUnit@@HV1@@std@@YAPAVCvHomelandUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_rotate<CvHomelandUnit *,int,CvHomelandUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@PAVCvHomelandUnit@@HV1@@std@@YAPAVCvHomelandUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z
_TEXT	SEGMENT
$T248997 = -20						; size = 20
$T248995 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T248996 = 20						; size = 4
$T248994 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAVCvHomelandUnit@@HV1@@std@@YAPAVCvHomelandUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z PROC ; std::_Buffered_rotate<CvHomelandUnit *,int,CvHomelandUnit>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebx, DWORD PTR __Count2$[esp+20]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Tempbuf$[esp+28]
	push	edi
	mov	edi, DWORD PTR __Count1$[esp+32]
	cmp	edi, ebx
	jg	SHORT $LN4@Buffered_r@2
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	edi, eax
	jg	SHORT $LN4@Buffered_r@2

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR __Mid$[esp+32]
	mov	ebp, DWORD PTR __First$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T248994[esp+52], esp
	push	ebx
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T248995[esp+60]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	mov	eax, DWORD PTR $T248995[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN25@Buffered_r@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r@2:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edi, DWORD PTR __Last$[esp+32]
	push	ebp
	push	edi
	push	ebx
	call	??$unchecked_copy@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z ; stdext::unchecked_copy<CvHomelandUnit *,CvHomelandUnit *>

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi]
	push	edi
	push	eax
	push	esi
	call	??$unchecked_copy_backward@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvHomelandUnit *,CvHomelandUnit *>
	add	esp, 24					; 00000018H

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r@2:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	ebx, eax
	jg	SHORT $LN2@Buffered_r@2

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR __Last$[esp+32]
	mov	ebp, DWORD PTR __Mid$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T248996[esp+52], esp
	push	ebx
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T248997[esp+60]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	mov	eax, DWORD PTR $T248997[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN45@Buffered_r@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN45@Buffered_r@2:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	edi, DWORD PTR __First$[esp+32]
	push	ebx
	push	ebp
	push	edi
	call	??$unchecked_copy_backward@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvHomelandUnit *,CvHomelandUnit *>

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi]
	push	edi
	push	eax
	push	esi
	call	??$unchecked_copy@PAVCvHomelandUnit@@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@00@Z ; stdext::unchecked_copy<CvHomelandUnit *,CvHomelandUnit *>
	add	esp, 24					; 00000018H

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r@2:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	esi, DWORD PTR __First$[esp+32]
	mov	eax, DWORD PTR __Mid$[esp+32]
	cmp	esi, eax
	je	SHORT $LN56@Buffered_r@2
	mov	ecx, DWORD PTR __Last$[esp+32]
	cmp	eax, ecx
	je	SHORT $LN56@Buffered_r@2
	xor	edi, edi
	push	edi
	push	edi
	push	ecx
	push	eax
	push	esi
	call	??$_Rotate@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00PAH0@Z ; std::_Rotate<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 20					; 00000014H
$LN56@Buffered_r@2:

; 2700 : 		std::advance(_First, _Count2);

	mov	eax, ebx

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	shl	eax, 4
	add	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@PAVCvHomelandUnit@@HV1@@std@@YAPAVCvHomelandUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ENDP ; std::_Buffered_rotate<CvHomelandUnit *,int,CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvHomelandUnit@@PAV1@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@0000@Z ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvHomelandUnit@@PAV1@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@0000@Z
_TEXT	SEGMENT
$T249139 = -4						; size = 1
$T249140 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$unchecked_merge@PAVCvHomelandUnit@@PAV1@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@0000@Z PROC ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Dest$[esp]
	mov	BYTE PTR $T249139[esp+4], 0
	mov	eax, DWORD PTR $T249139[esp+4]
	mov	ecx, DWORD PTR $T249140[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>

; 5117 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$unchecked_merge@PAVCvHomelandUnit@@PAV1@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@0000@Z ENDP ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@0000@Z ; stdext::_Unchecked_merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@0000@Z
_TEXT	SEGMENT
$T249148 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$_Unchecked_merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@0000@Z PROC ; stdext::_Unchecked_merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>, COMDAT

; 5202 : 	{

	push	ecx

; 5203 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	edx, DWORD PTR __Last2$[esp]
	mov	BYTE PTR $T249148[esp+4], 0
	mov	eax, DWORD PTR $T249148[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@@std@@YAPAVCvHomelandUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>

; 5204 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@@stdext@@YAPAVCvHomelandUnit@@PAV1@0000@Z ENDP ; stdext::_Unchecked_merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	??$lower_bound@PAVCvHomelandUnit@@V1@@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@@Z ; std::lower_bound<CvHomelandUnit *,CvHomelandUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@PAVCvHomelandUnit@@V1@@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$lower_bound@PAVCvHomelandUnit@@V1@@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@@Z PROC ; std::lower_bound<CvHomelandUnit *,CvHomelandUnit>, COMDAT

; 2276 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Lower_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int>
	add	esp, 16					; 00000010H

; 2277 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2278 : 	return _First;
; 2279 : 	}

	ret	0
??$lower_bound@PAVCvHomelandUnit@@V1@@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@@Z ENDP ; std::lower_bound<CvHomelandUnit *,CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??$upper_bound@PAVCvHomelandUnit@@V1@@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@@Z ; std::upper_bound<CvHomelandUnit *,CvHomelandUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@PAVCvHomelandUnit@@V1@@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$upper_bound@PAVCvHomelandUnit@@V1@@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@@Z PROC ; std::upper_bound<CvHomelandUnit *,CvHomelandUnit>, COMDAT

; 2347 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Upper_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int>
	add	esp, 16					; 00000010H

; 2348 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2349 : 	return _First;
; 2350 : 	}

	ret	0
??$upper_bound@PAVCvHomelandUnit@@V1@@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@@Z ENDP ; std::upper_bound<CvHomelandUnit *,CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::pop_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	edx, eax
	push	esi
	sub	edx, ecx
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	push	edi
	jle	SHORT $LN12@pop_heap@2

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	ebx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	DWORD PTR [eax-4], ebx
	mov	eax, esp
	add	edx, -8					; fffffff8H
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN12@pop_heap@2:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::pop_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	edx, eax
	push	esi
	sub	edx, ecx
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	push	edi
	jle	SHORT $LN12@pop_heap@3

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	ebx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	DWORD PTR [eax-4], ebx
	mov	eax, esp
	add	edx, -8					; fffffff8H
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN12@pop_heap@3:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvHomelandMove@@PAV1@H@std@@YAXPAVCvHomelandMove@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandMove *,CvHomelandMove *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvHomelandMove@@PAV1@H@std@@YAXPAVCvHomelandMove@@00HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
$T249286 = 20						; size = 1
__Chunk$ = 20						; size = 4
$T249362 = 24						; size = 1
$T249363 = 24						; size = 1
$T249287 = 24						; size = 1
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvHomelandMove@@PAV1@H@std@@YAXPAVCvHomelandMove@@00HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvHomelandMove *,CvHomelandMove *,int>, COMDAT

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+8]
	lea	ebp, DWORD PTR [edi+edi]
	cmp	ebp, edx
	jg	SHORT $LN3@Chunked_me
	push	ebx
	npad	5
$LL50@Chunked_me:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	BYTE PTR $T249286[esp+12], 0
	mov	ebx, DWORD PTR $T249286[esp+12]
	push	ebx
	mov	ebx, DWORD PTR $T249287[esp+16]
	push	ebx
	lea	edx, DWORD PTR [ecx+edi*8]
	push	eax
	lea	esi, DWORD PTR [edx+edi*8]
	push	esi
	push	edx
	push	edx
	push	ecx
	call	??$_Merge@PAVCvHomelandMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>
	mov	edx, DWORD PTR __Count$[esp+40]
	sub	edx, ebp
	add	esp, 28					; 0000001cH
	cmp	edx, ebp

; 3297 : 		_First = _Mid2;

	mov	ecx, esi
	mov	DWORD PTR __Count$[esp+12], edx
	jge	SHORT $LL50@Chunked_me
	pop	ebx
$LN3@Chunked_me:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	cmp	edx, edi
	jg	SHORT $LN2@Chunked_me

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	edx, DWORD PTR __Last$[esp+8]
	cmp	ecx, edx
	je	SHORT $LN41@Chunked_me
	sub	eax, ecx
$LL32@Chunked_me:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax+ecx], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+ecx+4], esi
	add	ecx, 8
	cmp	ecx, edx
	jne	SHORT $LL32@Chunked_me
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	ret	0
$LN2@Chunked_me:

; 3302 : 	else
; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);
; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	BYTE PTR $T249362[esp+8], 0
	mov	edx, DWORD PTR $T249362[esp+8]
	push	edx
	mov	edx, DWORD PTR $T249363[esp+12]
	push	edx
	push	eax
	mov	eax, DWORD PTR __Last$[esp+20]
	push	eax
	lea	edi, DWORD PTR [ecx+edi*8]
	push	edi
	push	edi
	push	ecx
	call	??$_Merge@PAVCvHomelandMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
$LN41@Chunked_me:
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	ret	0
??$_Chunked_merge@PAVCvHomelandMove@@PAV1@H@std@@YAXPAVCvHomelandMove@@00HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvHomelandMove *,CvHomelandMove *,int>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T249480 = 12						; size = 1
$T249455 = 12						; size = 1
$T249381 = 12						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Cat$249485 = 28					; size = 1
$T249482 = 28						; size = 1
__Cat$249460 = 28					; size = 1
$T249457 = 28						; size = 1
__Dest$ = 28						; size = 4
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>, COMDAT

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last1$[esp]
	push	edi
	cmp	eax, esi
	je	$LN3@Merge@6
	mov	ecx, DWORD PTR __First2$[esp+4]
	npad	6
$LL10@Merge@6:
	cmp	ecx, DWORD PTR __Last2$[esp+4]
	je	$LN3@Merge@6

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	edi, DWORD PTR [ecx+16]
	cmp	edi, DWORD PTR [eax+16]
	jle	SHORT $LN2@Merge@6

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], edi
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	edi, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edi+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [edx+16], ecx
	mov	ecx, DWORD PTR __First2$[esp+4]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __First2$[esp+4], ecx

; 2516 : 		else

	jmp	SHORT $LN4@Merge@6
$LN2@Merge@6:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	mov	DWORD PTR [ecx+16], edx
	mov	ecx, DWORD PTR __First2$[esp+4]
	add	eax, 20					; 00000014H
$LN4@Merge@6:
	mov	edx, DWORD PTR __Dest$[esp+4]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __Dest$[esp+4], edx
	cmp	eax, esi
	jne	$LL10@Merge@6
$LN3@Merge@6:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	BYTE PTR $T249455[esp+4], 0
	mov	ecx, DWORD PTR $T249455[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Cat$249460[esp+8]
	push	ecx
	mov	ecx, DWORD PTR $T249457[esp+12]
	push	ecx
	push	edx
	push	esi
	push	eax
	lea	edx, DWORD PTR $T249381[esp+28]
	push	edx
	call	??$_Copy_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	mov	eax, DWORD PTR $T249381[esp+32]

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+32]
	mov	DWORD PTR __Dest$[esp+32], eax
	mov	edx, DWORD PTR __Cat$249485[esp+32]
	mov	BYTE PTR $T249480[esp+32], 0
	mov	ecx, DWORD PTR $T249480[esp+32]
	push	ecx
	mov	ecx, DWORD PTR $T249482[esp+36]
	push	edx
	mov	edx, DWORD PTR __Last2$[esp+40]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __First2$[esp+48]
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	pop	edi
	mov	eax, esi
	pop	esi

; 2521 : 	}

	ret	0
??$_Merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@V12@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0PAVCvHomelandTarget@@10U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@V12@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0PAVCvHomelandTarget@@10U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T249539 = -4						; size = 1
$T249515 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Cat$249544 = 16					; size = 1
$T249541 = 16						; size = 1
__Cat$249520 = 16					; size = 1
$T249517 = 16						; size = 1
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
___formal$ = 32						; size = 1
??$_Merge_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@V12@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0PAVCvHomelandTarget@@10U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 2710 : 	{	// merge backwards to _Dest, using operator<

	push	ecx

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	edx, DWORD PTR __First1$[esp]
	mov	ecx, DWORD PTR __Last1$[esp]
	mov	eax, DWORD PTR __Last2$[esp]
	push	esi
	mov	esi, DWORD PTR __First2$[esp+4]
	push	edi
	cmp	edx, ecx
	je	$LN61@Merge_back@4
	npad	5
$LL8@Merge_back@4:

; 2714 : 		else if (_First2 == _Last2)

	cmp	esi, eax
	je	$LN62@Merge_back@4

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	edx, DWORD PTR [eax-4]
	sub	eax, 20					; 00000014H
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR __Last1$[esp+8], ecx
	cmp	edx, DWORD PTR [ecx+16]
	jle	SHORT $LN2@Merge_back@4

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	mov	edx, DWORD PTR __Dest$[esp+8]
	sub	edx, 20					; 00000014H
	mov	DWORD PTR __Dest$[esp+8], edx
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], edi
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edi+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edi+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	edi, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edi+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+16], ecx

; 2718 : 		else

	mov	ecx, DWORD PTR __Last1$[esp+8]
	add	eax, 20					; 00000014H
	jmp	SHORT $LN57@Merge_back@4
$LN2@Merge_back@4:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ecx, DWORD PTR __Dest$[esp+8]
	mov	edx, DWORD PTR [eax]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR __Dest$[esp+8], ecx
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [edx+16], ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __Last1$[esp+8], ecx
$LN57@Merge_back@4:
	mov	edx, DWORD PTR __First1$[esp+8]
	cmp	edx, ecx
	jne	$LL8@Merge_back@4
$LN61@Merge_back@4:

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Cat$249520[esp+8]
	mov	BYTE PTR $T249515[esp+12], 0
	mov	ecx, DWORD PTR $T249515[esp+12]
	push	ecx
	mov	ecx, DWORD PTR $T249517[esp+12]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+16]
	push	ecx
	push	edx
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+32]
	push	esi
	call	??$_Copy_backward_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi

; 2720 : 	}

	pop	ecx
	ret	0
$LN62@Merge_back@4:

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T249539[esp+12], 0
	mov	eax, DWORD PTR $T249539[esp+12]
	push	eax
	mov	eax, DWORD PTR __Cat$249544[esp+12]
	push	eax
	mov	eax, DWORD PTR $T249541[esp+16]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+20]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	pop	edi
	mov	eax, esi
	pop	esi

; 2720 : 	}

	pop	ecx
	ret	0
??$_Merge_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@V12@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0PAVCvHomelandTarget@@10U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T249672 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
$T249748 = 24						; size = 1
$T249749 = 24						; size = 1
$T249673 = 24						; size = 1
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 4
___formal$ = 32						; size = 1
??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ecx

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	edx, DWORD PTR __Count$[esp]
	mov	eax, DWORD PTR __Dest$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Chunk$[esp+4]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp+ebp]
	cmp	edi, edx
	jg	SHORT $LN3@Chunked_me@2
	shl	ebp, 4
	push	ebx
$LL50@Chunked_me@2:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);
; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	BYTE PTR $T249672[esp+20], 0
	mov	ebx, DWORD PTR $T249672[esp+20]
	push	ebx
	mov	ebx, DWORD PTR $T249673[esp+20]
	push	ebx
	mov	ebx, DWORD PTR __Pred$[esp+24]
	push	ebx
	lea	edx, DWORD PTR [ecx+ebp]
	push	eax
	lea	esi, DWORD PTR [edx+ebp]
	push	esi
	push	edx
	push	edx
	push	ecx
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::random_access_iterator_tag>
	mov	edx, DWORD PTR __Count$[esp+48]
	sub	edx, edi
	add	esp, 32					; 00000020H
	cmp	edx, edi

; 3443 : 		_First = _Mid2;

	mov	ecx, esi
	mov	DWORD PTR __Count$[esp+16], edx
	jge	SHORT $LL50@Chunked_me@2
	mov	ebp, DWORD PTR __Chunk$[esp+16]
	pop	ebx
$LN3@Chunked_me@2:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	cmp	edx, ebp
	jg	SHORT $LN2@Chunked_me@2

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	edx, DWORD PTR __Last$[esp+12]
	cmp	ecx, edx
	je	SHORT $LN41@Chunked_me@2
	sub	eax, ecx
	npad	6
$LL32@Chunked_me@2:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax+ecx], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+ecx+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+ecx+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+ecx+12], esi
	add	ecx, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL32@Chunked_me@2
	pop	edi
	pop	esi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	pop	ecx
	ret	0
$LN2@Chunked_me@2:

; 3448 : 	else
; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);
; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	BYTE PTR $T249748[esp+12], 0
	mov	edx, DWORD PTR $T249748[esp+12]
	push	edx
	mov	edx, DWORD PTR $T249749[esp+16]
	push	edx
	mov	edx, DWORD PTR __Pred$[esp+20]
	push	edx
	push	eax
	mov	eax, DWORD PTR __Last$[esp+28]
	push	eax
	shl	ebp, 4
	add	ebp, ecx
	push	ebp
	push	ebp
	push	ecx
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@ZUrandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
$LN41@Chunked_me@2:
	pop	edi
	pop	esi
	pop	ebp

; 3454 : 		}
; 3455 : 	}

	pop	ecx
	ret	0
??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@H@std@@YAXPAVCvHomelandUnit@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@H@std@@YAXPAVCvHomelandUnit@@00HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T249809 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
$T249884 = 24						; size = 1
$T249885 = 24						; size = 1
$T249810 = 24						; size = 1
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@H@std@@YAXPAVCvHomelandUnit@@00HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ecx

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	edx, DWORD PTR __Count$[esp]
	mov	eax, DWORD PTR __Dest$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Chunk$[esp+4]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp+ebp]
	cmp	edi, edx
	jg	SHORT $LN3@Chunked_me@3
	shl	ebp, 4
	push	ebx
$LL50@Chunked_me@3:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	BYTE PTR $T249809[esp+20], 0
	mov	ebx, DWORD PTR $T249809[esp+20]
	push	ebx
	mov	ebx, DWORD PTR $T249810[esp+20]
	push	ebx
	lea	edx, DWORD PTR [ecx+ebp]
	push	eax
	lea	esi, DWORD PTR [edx+ebp]
	push	esi
	push	edx
	push	edx
	push	ecx
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>
	mov	edx, DWORD PTR __Count$[esp+44]
	sub	edx, edi
	add	esp, 28					; 0000001cH
	cmp	edx, edi

; 3297 : 		_First = _Mid2;

	mov	ecx, esi
	mov	DWORD PTR __Count$[esp+16], edx
	jge	SHORT $LL50@Chunked_me@3
	mov	ebp, DWORD PTR __Chunk$[esp+16]
	pop	ebx
$LN3@Chunked_me@3:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	cmp	edx, ebp
	jg	SHORT $LN2@Chunked_me@3

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	edx, DWORD PTR __Last$[esp+12]
	cmp	ecx, edx
	je	SHORT $LN41@Chunked_me@3
	sub	eax, ecx
$LL32@Chunked_me@3:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax+ecx], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+ecx+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+ecx+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+ecx+12], esi
	add	ecx, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL32@Chunked_me@3
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	pop	ecx
	ret	0
$LN2@Chunked_me@3:

; 3302 : 	else
; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);
; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	BYTE PTR $T249884[esp+12], 0
	mov	edx, DWORD PTR $T249884[esp+12]
	push	edx
	mov	edx, DWORD PTR $T249885[esp+16]
	push	edx
	push	eax
	mov	eax, DWORD PTR __Last$[esp+24]
	push	eax
	shl	ebp, 4
	add	ebp, ecx
	push	ebp
	push	ebp
	push	ecx
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
$LN41@Chunked_me@3:
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	pop	ecx
	ret	0
??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@H@std@@YAXPAVCvHomelandUnit@@00HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z
_TEXT	SEGMENT
$T249903 = -4						; size = 1
$T249909 = -4						; size = 4
$T249905 = -4						; size = 4
$T249904 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z PROC ; stdext::unchecked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T249909[esp+8], ebx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T249904[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T249903[esp+12], bl
	mov	eax, DWORD PTR $T249903[esp+12]
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+36]
	mov	ecx, DWORD PTR __First2$[esp+36]
	mov	edx, DWORD PTR __Last1$[esp+36]
	mov	DWORD PTR $T249905[esp+40], esp
	push	eax
	mov	eax, DWORD PTR __First1$[esp+40]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@0@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+56]
	add	esp, 48					; 00000030H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@15
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@15:
	mov	eax, esi

; 5117 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z ENDP ; stdext::unchecked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@000V12@@Z ; stdext::unchecked_merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@000V12@@Z
_TEXT	SEGMENT
$T249949 = -4						; size = 1
$T249950 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
??$unchecked_merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@000V12@@Z PROC ; stdext::unchecked_merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T249950[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T249949[esp+8], 0
	mov	eax, DWORD PTR $T249949[esp+8]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+16]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
	mov	eax, esi
	pop	esi

; 5117 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@000V12@@Z ENDP ; stdext::unchecked_merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00PAHPAVCvHomelandTarget@@@Z ; std::_Rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T249975 = -24						; size = 4
$T249968 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
$T249969 = 12						; size = 4
$T249967 = 12						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	sub	esp, 24					; 00000018H

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ecx, DWORD PTR __First1$[esp+20]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Last1$[esp+28]
	push	esi
	mov	esi, DWORD PTR __First2$[esp+32]
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR $T249975[esp+40], ebx
	cmp	ecx, ebp
	je	$LN3@Merge@7
	lea	edi, DWORD PTR [ebx+8]
$LL4@Merge@7:
	cmp	esi, DWORD PTR __Last2$[esp+36]
	je	$LN3@Merge@7

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR [esi+4]

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __Dest$[esp+52]
	cmp	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	jle	SHORT $LN2@Merge@7
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN21@Merge@7
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	DWORD PTR [eax+4], edi
	add	esi, edi

; 2516 : 		else

	jmp	SHORT $LN1@Merge@7

; 2515 : 			*_Dest = *_First2, ++_First2;

$LN21@Merge@7:
	cmp	eax, ebx
	je	SHORT $LN26@Merge@7
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Dest$[esp+52]
$LN26@Merge@7:
	add	DWORD PTR [edx+4], edi
	mov	eax, DWORD PTR __Dest$[esp+52]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
	add	esi, edi

; 2516 : 		else

	jmp	SHORT $LN1@Merge@7
$LN2@Merge@7:

; 2517 : 			*_Dest = *_First1, ++_First1;

	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN33@Merge@7
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	DWORD PTR [eax+4], edi
	jmp	SHORT $LN32@Merge@7
$LN33@Merge@7:
	cmp	eax, ebx
	je	SHORT $LN38@Merge@7
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Dest$[esp+52]
$LN38@Merge@7:
	add	DWORD PTR [edx+4], edi
	mov	eax, DWORD PTR __Dest$[esp+52]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN32@Merge@7:
	add	ecx, edi
$LN1@Merge@7:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	ecx, ebp
	jne	$LL4@Merge@7
$LN3@Merge@7:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR $T249967[esp+56], esp
	push	ebp
	mov	DWORD PTR [eax+16], edx
	push	ecx
	lea	eax, DWORD PTR $T249968[esp+68]
	push	eax
	call	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T249968[esp+72]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[esp+52], ecx
	cmp	eax, ebx
	je	SHORT $LN56@Merge@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@Merge@7:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+56]
	mov	DWORD PTR $T249969[esp+56], esp
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+64]
	push	esi
	call	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	mov	eax, DWORD PTR __Dest$[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN77@Merge@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN77@Merge@7:

; 2521 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::forward_iterator_tag>
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T250125 = -36						; size = 4
$T250118 = -32						; size = 20
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T250117 = 12						; size = 4
__First1$ = 12						; size = 4
$T250119 = 16						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 4
___formal$ = 52						; size = 1
___formal$ = 56						; size = 1
??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::forward_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	-1
	push	__ehhandler$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	xor	ebx, ebx
	push	edi
	mov	DWORD PTR $T250125[esp+52], ebx
	mov	esi, DWORD PTR __First1$[esp+48]
	mov	edi, DWORD PTR __First2$[esp+48]
	mov	DWORD PTR __$EHRec$[esp+60], ebx
	cmp	esi, DWORD PTR __Last1$[esp+48]
	je	SHORT $LN58@Merge@8
	mov	ebp, DWORD PTR __Pred$[esp+48]
$LL4@Merge@8:
	cmp	edi, DWORD PTR __Last2$[esp+48]
	je	SHORT $LN58@Merge@8

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [edi+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	call	ebp
	add	esp, 32					; 00000020H

; 2599 : 			*_Dest = *_First2, ++_First2;

	lea	ecx, DWORD PTR __Dest$[esp+48]
	test	al, al
	je	SHORT $LN2@Merge@8
	push	edi
	call	??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z ; std::_Temp_iterator<CvHomelandUnit>::operator=
	add	edi, 16					; 00000010H

; 2600 : 		else

	jmp	SHORT $LN1@Merge@8
$LN2@Merge@8:

; 2601 : 			*_Dest = *_First1, ++_First1;

	push	esi
	call	??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z ; std::_Temp_iterator<CvHomelandUnit>::operator=
	add	esi, 16					; 00000010H
$LN1@Merge@8:

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	esi, DWORD PTR __Last1$[esp+48]
	jne	SHORT $LL4@Merge@8
$LN58@Merge@8:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	edx, DWORD PTR __Last1$[esp+48]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+84]
	mov	DWORD PTR $T250117[esp+68], esp
	push	edx
	mov	DWORD PTR [eax+16], ecx
	lea	eax, DWORD PTR $T250118[esp+76]
	push	esi
	push	eax
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T250118[esp+84]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[esp+64], ecx
	cmp	eax, ebx
	je	SHORT $LN34@Merge@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@Merge@8:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+48]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+84]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+68]
	mov	DWORD PTR $T250119[esp+68], esp
	push	eax
	push	edi
	push	esi
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	mov	eax, DWORD PTR __Dest$[esp+80]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN55@Merge@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN55@Merge@8:

; 2605 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp-4]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::forward_iterator_tag>
PUBLIC	??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T250222 = -24						; size = 4
$T250215 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
$T250216 = 12						; size = 4
$T250214 = 12						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ebp, DWORD PTR __Last1$[esp+28]
	push	esi
	mov	esi, DWORD PTR __First1$[esp+32]
	xor	ebx, ebx
	push	edi
	mov	edi, DWORD PTR __First2$[esp+36]
	mov	DWORD PTR $T250222[esp+40], ebx
	cmp	esi, ebp
	je	SHORT $LN3@Merge@9
	npad	3
$LL4@Merge@9:
	cmp	edi, DWORD PTR __Last2$[esp+36]
	je	SHORT $LN3@Merge@9

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR [edi+8]
	cmp	eax, DWORD PTR [esi+8]

; 2515 : 			*_Dest = *_First2, ++_First2;

	lea	ecx, DWORD PTR __Dest$[esp+36]
	jge	SHORT $LN2@Merge@9
	push	edi
	call	??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z ; std::_Temp_iterator<CvHomelandUnit>::operator=
	add	edi, 16					; 00000010H

; 2516 : 		else

	jmp	SHORT $LN1@Merge@9
$LN2@Merge@9:

; 2517 : 			*_Dest = *_First1, ++_First1;

	push	esi
	call	??4?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEAAV01@ABVCvHomelandUnit@@@Z ; std::_Temp_iterator<CvHomelandUnit>::operator=
	add	esi, 16					; 00000010H
$LN1@Merge@9:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	esi, ebp
	jne	SHORT $LL4@Merge@9
$LN3@Merge@9:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T250214[esp+56], esp
	push	ebp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+76]
	lea	edx, DWORD PTR $T250215[esp+64]
	push	esi
	push	edx
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[esp+84], eax
	mov	eax, DWORD PTR $T250215[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN40@Merge@9
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN40@Merge@9:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Last2$[esp+36]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+36]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T250216[esp+56], esp
	push	edx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+76]
	push	edi
	push	esi
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	mov	eax, DWORD PTR __Dest$[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN61@Merge@9
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN61@Merge@9:

; 2521 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z ; CvHomelandAI::FindUnitsForThisMove
EXTRN	?getExtraVisibilityRange@CvUnit@@QBEHXZ:PROC	; CvUnit::getExtraVisibilityRange
EXTRN	?noDefensiveBonus@CvUnit@@QBE_NXZ:PROC		; CvUnit::noDefensiveBonus
EXTRN	?getExtraCombatPercent@CvUnit@@QBEHXZ:PROC	; CvUnit::getExtraCombatPercent
EXTRN	?getAttackModifier@CvUnit@@QBEHXZ:PROC		; CvUnit::getAttackModifier
EXTRN	?getDefenseModifier@CvUnit@@QBEHXZ:PROC		; CvUnit::getDefenseModifier
EXTRN	?IsCanAttack@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanAttack
EXTRN	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetUnitAIType
EXTRN	?isRanged@CvUnit@@QBE_NXZ:PROC			; CvUnit::isRanged
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?isHuman@CvUnit@@QBE_NXZ:PROC			; CvUnit::isHuman
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z$1
__ehfuncinfo$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z
_TEXT	SEGMENT
_rtnValue$ = -1081					; size = 1
_it$228642 = -1080					; size = 4
_unit$228678 = -1076					; size = 16
_pLoopUnit$228648 = -1060				; size = 8
_tempList$228683 = -1052				; size = 1040
__$EHRec$ = -12						; size = 12
_eMove$ = 8						; size = 4
_bFirstTime$ = 12					; size = 1
?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z PROC ; CvHomelandAI::FindUnitsForThisMove, COMDAT
; _this$ = ecx

; 5237 : {

	push	-1
	push	__ehhandler$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1072				; 00000430H
	push	ebx
	push	ebp

; 5238 : 	bool rtnValue = false;

	xor	dl, dl
	push	esi
	push	edi
	mov	ebp, ecx
	mov	BYTE PTR _rtnValue$[esp+1100], dl

; 5239 : 
; 5240 : 	if(bFirstTime)

	cmp	BYTE PTR _bFirstTime$[esp+1096], dl
	je	$LN40@FindUnitsF

; 5241 : 	{
; 5242 : 		ClearCurrentMoveUnits();

	xor	edi, edi
	mov	DWORD PTR [ebp+20], edi
	mov	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR [ebp+2400], eax
	mov	DWORD PTR [ebp+2396], edi

; 5243 : 		ClearCurrentMoveHighPriorityUnits();

	mov	DWORD PTR [ebp+1060], edi
	mov	DWORD PTR [ebp+2408], eax

; 5244 : 
; 5245 : 		// Loop through all units available to homeland AI this turn
; 5246 : 		for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebp+2404], edi
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _it$228642[esp+1100], ecx
	cmp	ecx, eax
	je	$LN354@FindUnitsF
	npad	3
$LL356@FindUnitsF:

; 5247 : 		{
; 5248 : 			UnitHandle pLoopUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR _it$228642[esp+1100]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pLoopUnit$228648[esp+1100], esi
	mov	BYTE PTR _pLoopUnit$228648[esp+1104], 0
	cmp	esi, edi
	je	SHORT $LN98@FindUnitsF
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN98@FindUnitsF:
	mov	DWORD PTR __$EHRec$[esp+1108], edi

; 5249 : 			if(pLoopUnit && !pLoopUnit->isHuman())

	cmp	esi, edi
	je	$LN355@FindUnitsF
	mov	ecx, esi
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	jne	$LN355@FindUnitsF

; 5250 : 			{
; 5251 : 				// Civilians aren't useful for any of these moves
; 5252 : 				if(!pLoopUnit->IsCombatUnit())

	cmp	DWORD PTR [esi+1044], edi

; 5253 : 				{
; 5254 : 					continue;

	mov	ecx, esi
	jg	SHORT $LN35@FindUnitsF
	mov	DWORD PTR __$EHRec$[esp+1108], -1
	jmp	$LN359@FindUnitsF
$LN35@FindUnitsF:

; 5255 : 				}
; 5256 : 
; 5257 : #ifndef AUI_HOMELAND_ALWAYS_MOVE_SCOUTS
; 5258 : 				// Scouts aren't useful unless recon is entirely shut off
; 5259 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_EXPLORE && m_pPlayer->GetEconomicAI()->GetReconState() != RECON_STATE_ENOUGH)

	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN34@FindUnitsF
	mov	ecx, DWORD PTR [ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	cmp	DWORD PTR [eax+28], edi
	je	SHORT $LN34@FindUnitsF

; 5260 : 				{
; 5261 : 					continue;

	mov	DWORD PTR __$EHRec$[esp+1108], -1
	jmp	$LN360@FindUnitsF
$LN34@FindUnitsF:

; 5262 : 				}
; 5263 : #endif
; 5264 : 
; 5265 : 				bool bSuitableUnit = false;
; 5266 : 				bool bHighPriority = false;
; 5267 : 
; 5268 : 				switch(eMove)

	mov	eax, DWORD PTR _eMove$[esp+1096]
	add	eax, -4					; fffffffcH
	xor	bl, bl
	cmp	eax, 10					; 0000000aH
	ja	$LN355@FindUnitsF
	movzx	edx, BYTE PTR $LN352@FindUnitsF[eax]
	jmp	DWORD PTR $LN365@FindUnitsF[edx*4]
$LN31@FindUnitsF:

; 5269 : 				{
; 5270 : 				case AI_HOMELAND_MOVE_GARRISON:
; 5271 : 				case AI_HOMELAND_MOVE_GARRISON_CITY_STATE:
; 5272 : 					// Want to put ranged units in cities to give them a ranged attack
; 5273 : 					if(pLoopUnit->isRanged() && !pLoopUnit->getUnitInfo().GetUnitAIType(UNITAI_CITY_BOMBARD))

	mov	ecx, esi
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	test	al, al
	je	SHORT $LN30@FindUnitsF
	push	4
	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	test	al, al
	jne	SHORT $LN30@FindUnitsF

; 5274 : 					{
; 5275 : 						bSuitableUnit = true;
; 5276 : 						bHighPriority = true;

	mov	bl, 1
	jmp	$LN351@FindUnitsF
$LN30@FindUnitsF:

; 5277 : 					}
; 5278 : 
; 5279 : 					// Don't use non-combatants
; 5280 : 					else if(pLoopUnit->IsCanAttack())

	mov	ecx, esi
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	test	al, al
	je	$LN355@FindUnitsF

; 5281 : 					{
; 5282 : 						// Don't put units with a combat strength boosted from promotions in cities, these boosts are ignored
; 5283 : 						if(pLoopUnit->getDefenseModifier() == 0 &&
; 5284 : 						        pLoopUnit->getAttackModifier() == 0 &&
; 5285 : 						        pLoopUnit->getExtraCombatPercent() == 0)

	mov	ecx, esi
	call	?getDefenseModifier@CvUnit@@QBEHXZ	; CvUnit::getDefenseModifier
	test	eax, eax
	jne	$LN355@FindUnitsF
	mov	ecx, esi
	call	?getAttackModifier@CvUnit@@QBEHXZ	; CvUnit::getAttackModifier
	test	eax, eax
	jne	$LN355@FindUnitsF
	mov	ecx, esi
	call	?getExtraCombatPercent@CvUnit@@QBEHXZ	; CvUnit::getExtraCombatPercent
	test	eax, eax
	jne	$LN355@FindUnitsF

; 5286 : 						{
; 5287 : 							bSuitableUnit = true;
; 5288 : 						}
; 5289 : 					}
; 5290 : 					break;

	jmp	SHORT $LN351@FindUnitsF
$LN26@FindUnitsF:

; 5291 : 
; 5292 : 				case AI_HOMELAND_MOVE_SENTRY:
; 5293 : 					// No ranged units as sentries
; 5294 : 					if(!pLoopUnit->isRanged() && !pLoopUnit->noDefensiveBonus())

	mov	ecx, esi
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	test	al, al
	jne	SHORT $LN25@FindUnitsF
	mov	ecx, esi
	call	?noDefensiveBonus@CvUnit@@QBE_NXZ	; CvUnit::noDefensiveBonus
	test	al, al
	jne	SHORT $LN25@FindUnitsF

; 5295 : 					{
; 5296 : 						bSuitableUnit = true;
; 5297 : 
; 5298 : 						// Units with extra sight are especially valuable
; 5299 : 						if(pLoopUnit->getExtraVisibilityRange() > 0)

	mov	ecx, esi
	call	?getExtraVisibilityRange@CvUnit@@QBEHXZ	; CvUnit::getExtraVisibilityRange
	test	eax, eax
	jle	SHORT $LN351@FindUnitsF

; 5300 : 						{
; 5301 : 							bHighPriority = true;

	mov	bl, 1

; 5302 : 						}
; 5303 : 					}

	jmp	SHORT $LN351@FindUnitsF
$LN25@FindUnitsF:

; 5304 : 					else if(pLoopUnit->noDefensiveBonus() && pLoopUnit->getExtraVisibilityRange() > 0)

	mov	ecx, esi
	call	?noDefensiveBonus@CvUnit@@QBE_NXZ	; CvUnit::noDefensiveBonus
	test	al, al
	je	SHORT $LN355@FindUnitsF
	mov	ecx, esi
	call	?getExtraVisibilityRange@CvUnit@@QBEHXZ	; CvUnit::getExtraVisibilityRange
	test	eax, eax
	jle	SHORT $LN355@FindUnitsF

; 5305 : 					{
; 5306 : 						bSuitableUnit = true;
; 5307 : 						bHighPriority = true;

	mov	bl, 1

; 5308 : 					}
; 5309 : 					break;

	jmp	SHORT $LN351@FindUnitsF
$LN21@FindUnitsF:

; 5310 : 
; 5311 : 				case AI_HOMELAND_MOVE_MOBILE_RESERVE:
; 5312 : 					// Ranged units are excellent in the mobile reserve as are fast movers
; 5313 : 					if(pLoopUnit->isRanged() || pLoopUnit->getUnitInfo().GetUnitAIType(UNITAI_FAST_ATTACK))

	mov	ecx, esi
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	test	al, al
	jne	SHORT $LN19@FindUnitsF
$LN16@FindUnitsF:
	push	5
	mov	ecx, esi
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	test	al, al

; 5317 : 					}
; 5318 : 					else if(pLoopUnit->IsCanAttack())
; 5319 : 					{
; 5320 : 						bSuitableUnit = true;

	je	SHORT $LN15@FindUnitsF
$LN19@FindUnitsF:

; 5314 : 					{
; 5315 : 						bSuitableUnit = true;
; 5316 : 						bHighPriority = true;

	mov	bl, 1

; 5321 : 					}
; 5322 : 					break;

	jmp	SHORT $LN351@FindUnitsF
$LN15@FindUnitsF:

; 5323 : 
; 5324 : 				case AI_HOMELAND_MOVE_ANCIENT_RUINS:
; 5325 : 					// Fast movers are top priority
; 5326 : 					if(pLoopUnit->getUnitInfo().GetUnitAIType(UNITAI_FAST_ATTACK))
; 5327 : 					{
; 5328 : 						bSuitableUnit = true;
; 5329 : 						bHighPriority = true;
; 5330 : 					}
; 5331 : 					else if(pLoopUnit->IsCanAttack())

	mov	ecx, esi
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	test	al, al
	je	SHORT $LN355@FindUnitsF
$LN351@FindUnitsF:

; 5332 : 					{
; 5333 : 						bSuitableUnit = true;
; 5334 : 					}
; 5335 : 					break;
; 5336 : #ifdef AUI_HOMELAND_PLOT_WORKER_MOVES_ALSO_PLOTS_WORKER_DEFENSE
; 5337 : 				case AI_HOMELAND_MOVE_UNASSIGNED:
; 5338 : 					// Override for just selecting combat units
; 5339 : 					bSuitableUnit = pLoopUnit->IsCombatUnit();
; 5340 : 					break;
; 5341 : #endif
; 5342 : 				}
; 5343 : 
; 5344 : 				// If unit was suitable, add it to the proper list
; 5345 : 				if(bSuitableUnit)
; 5346 : 				{
; 5347 : 					CvHomelandUnit unit;
; 5348 : 					unit.SetID(pLoopUnit->GetID());

	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR _unit$228678[esp+1104], edi
	mov	DWORD PTR _unit$228678[esp+1108], edi
	mov	DWORD PTR _unit$228678[esp+1112], edi
	mov	DWORD PTR _unit$228678[esp+1100], eax

; 5349 : 
; 5350 : 					if(bHighPriority)

	test	bl, bl
	je	SHORT $LN11@FindUnitsF

; 5351 : 					{
; 5352 : 						m_CurrentMoveHighPriorityUnits.push_back(unit);

	lea	ecx, DWORD PTR _unit$228678[esp+1100]
	push	ecx
	lea	ecx, DWORD PTR [ebp+1056]

; 5353 : 					}
; 5354 : 					else

	jmp	SHORT $LN362@FindUnitsF
$LN11@FindUnitsF:

; 5355 : 					{
; 5356 : 						m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$228678[esp+1100]
	push	edx
	lea	ecx, DWORD PTR [ebp+16]
$LN362@FindUnitsF:
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back

; 5357 : 					}
; 5358 : 					rtnValue = true;

	mov	BYTE PTR _rtnValue$[esp+1100], 1
$LN355@FindUnitsF:

; 5359 : 				}
; 5360 : 			}
; 5361 : 		}

	mov	DWORD PTR __$EHRec$[esp+1108], -1
	cmp	esi, edi
	je	SHORT $LN38@FindUnitsF
$LN360@FindUnitsF:
	mov	ecx, esi
$LN359@FindUnitsF:
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN38@FindUnitsF:

; 5244 : 
; 5245 : 		// Loop through all units available to homeland AI this turn
; 5246 : 		for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR _it$228642[esp+1100]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _it$228642[esp+1100], eax
	cmp	eax, DWORD PTR [ebp+8]
	jne	$LL356@FindUnitsF
$LN353@FindUnitsF:

; 5397 : 
; 5398 : 	return rtnValue;

	mov	al, BYTE PTR _rtnValue$[esp+1100]

; 5362 : 	}
; 5363 : 
; 5364 : 	// Second time through, just make sure all units are still in list of current units to process
; 5365 : 	else

	jmp	$LN327@FindUnitsF
$LN40@FindUnitsF:

; 5366 : 	{
; 5367 : 		FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL > tempList;

	xor	ebx, ebx
	lea	ecx, DWORD PTR _tempList$228683[esp+1112]
	mov	DWORD PTR _tempList$228683[esp+1104], ebx
	mov	DWORD PTR _tempList$228683[esp+1108], 64 ; 00000040H
	mov	DWORD PTR _tempList$228683[esp+1100], ecx

; 5368 : 		FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 5369 : 		std::list<int>::iterator it2;
; 5370 : 
; 5371 : 		// Normal priority units
; 5372 : 		tempList = m_CurrentMoveUnits;

	lea	esi, DWORD PTR [ebp+16]
	push	esi
	lea	ecx, DWORD PTR _tempList$228683[esp+1104]
	mov	DWORD PTR __$EHRec$[esp+1112], 1
	call	??4?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::operator=

; 5373 : 		ClearCurrentMoveUnits();
; 5374 : 		for(it = tempList.begin(); it != tempList.end(); ++it)

	mov	edx, DWORD PTR _tempList$228683[esp+1104]
	mov	edi, DWORD PTR _tempList$228683[esp+1100]
	shl	edx, 4
	add	edx, edi
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [ebp+2396], ebx
	mov	DWORD PTR [ebp+2400], 2147483647	; 7fffffffH
	cmp	edi, edx
	je	SHORT $LN6@FindUnitsF
$LL8@FindUnitsF:

; 5375 : 		{
; 5376 : 			it2 = find(m_CurrentTurnUnits.begin(), m_CurrentTurnUnits.end(), (int)it->GetID());

	mov	ecx, DWORD PTR [ebp+8]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edi]
	cmp	eax, ecx
	je	SHORT $LN7@FindUnitsF
	npad	2
$LL223@FindUnitsF:
	cmp	DWORD PTR [eax+8], edx
	je	SHORT $LN344@FindUnitsF
	mov	eax, DWORD PTR [eax]
	cmp	eax, ecx
	jne	SHORT $LL223@FindUnitsF
$LN344@FindUnitsF:

; 5377 : 			if(it2 != m_CurrentTurnUnits.end())

	cmp	eax, ecx
	je	SHORT $LN7@FindUnitsF

; 5378 : 			{
; 5379 : 				m_CurrentMoveUnits.push_back(*it);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN247@FindUnitsF
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN247@FindUnitsF:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN250@FindUnitsF
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+12], edx
$LN250@FindUnitsF:
	inc	DWORD PTR [esi+4]

; 5380 : 				rtnValue = true;

	mov	BYTE PTR _rtnValue$[esp+1100], 1
$LN7@FindUnitsF:
	mov	eax, DWORD PTR _tempList$228683[esp+1104]
	shl	eax, 4
	add	eax, DWORD PTR _tempList$228683[esp+1100]
	add	edi, 16					; 00000010H
	cmp	edi, eax
	jne	SHORT $LL8@FindUnitsF
$LN6@FindUnitsF:

; 5381 : 			}
; 5382 : 		}
; 5383 : 
; 5384 : 		// High priority units
; 5385 : 		tempList = m_CurrentMoveHighPriorityUnits;

	lea	esi, DWORD PTR [ebp+1056]
	push	esi
	lea	ecx, DWORD PTR _tempList$228683[esp+1104]
	call	??4?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::operator=

; 5386 : 		ClearCurrentMoveHighPriorityUnits();
; 5387 : 		for(it = tempList.begin(); it != tempList.end(); ++it)

	mov	ecx, DWORD PTR _tempList$228683[esp+1104]
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [ebp+2404], ebx
	mov	ebx, DWORD PTR _tempList$228683[esp+1100]
	shl	ecx, 4
	add	ecx, ebx
	mov	DWORD PTR [ebp+2408], 2147483647	; 7fffffffH
	mov	edi, ebx
	cmp	ebx, ecx
	je	SHORT $LN2@FindUnitsF
$LL4@FindUnitsF:

; 5388 : 		{
; 5389 : 			it2 = find(m_CurrentTurnUnits.begin(), m_CurrentTurnUnits.end(), (int)it->GetID());

	mov	ecx, DWORD PTR [ebp+8]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edi]
	cmp	eax, ecx
	je	SHORT $LN3@FindUnitsF
$LL294@FindUnitsF:
	cmp	DWORD PTR [eax+8], edx
	je	SHORT $LN345@FindUnitsF
	mov	eax, DWORD PTR [eax]
	cmp	eax, ecx
	jne	SHORT $LL294@FindUnitsF
$LN345@FindUnitsF:

; 5390 : 			if(it2 != m_CurrentTurnUnits.end())

	cmp	eax, ecx
	je	SHORT $LN3@FindUnitsF

; 5391 : 			{
; 5392 : 				m_CurrentMoveHighPriorityUnits.push_back(*it);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN318@FindUnitsF
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
	mov	ebx, DWORD PTR _tempList$228683[esp+1100]
$LN318@FindUnitsF:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN321@FindUnitsF
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ebx, DWORD PTR _tempList$228683[esp+1100]
$LN321@FindUnitsF:
	inc	DWORD PTR [esi+4]

; 5393 : 				rtnValue = true;

	mov	BYTE PTR _rtnValue$[esp+1100], 1
$LN3@FindUnitsF:
	mov	edx, DWORD PTR _tempList$228683[esp+1104]
	shl	edx, 4
	add	edi, 16					; 00000010H
	add	edx, ebx
	cmp	edi, edx
	jne	SHORT $LL4@FindUnitsF
$LN2@FindUnitsF:

; 5394 : 			}
; 5395 : 		}
; 5396 : 	}

	lea	eax, DWORD PTR _tempList$228683[esp+1112]
	mov	DWORD PTR __$EHRec$[esp+1108], -1
	cmp	ebx, eax
	je	$LN353@FindUnitsF
	push	ebx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking

; 5397 : 
; 5398 : 	return rtnValue;

	mov	al, BYTE PTR _rtnValue$[esp+1104]
	add	esp, 4
	jmp	SHORT $LN327@FindUnitsF
$LN354@FindUnitsF:
	mov	al, dl

; 5394 : 			}
; 5395 : 		}
; 5396 : 	}

$LN327@FindUnitsF:

; 5399 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+1100]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 1084				; 0000043cH
	ret	8
	npad	2
$LN365@FindUnitsF:
	DD	$LN31@FindUnitsF
	DD	$LN21@FindUnitsF
	DD	$LN26@FindUnitsF
	DD	$LN16@FindUnitsF
	DD	$LN355@FindUnitsF
$LN352@FindUnitsF:
	DB	0
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$228648[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z$1:
	lea	ecx, DWORD PTR _tempList$228683[ebp]
	jmp	??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
__ehhandler$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z ENDP ; CvHomelandAI::FindUnitsForThisMove
PUBLIC	?UnitProcessed@CvHomelandAI@@AAEXH@Z		; CvHomelandAI::UnitProcessed
; Function compile flags: /Ogtpy
;	COMDAT ?UnitProcessed@CvHomelandAI@@AAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?UnitProcessed@CvHomelandAI@@AAEXH@Z PROC		; CvHomelandAI::UnitProcessed, COMDAT
; _this$ = ecx

; 5896 : {

	push	esi
	mov	esi, ecx

; 5897 : 	CvUnit* pUnit;
; 5898 : 
; 5899 : 	m_CurrentTurnUnits.remove(iID);

	lea	eax, DWORD PTR _iID$[esp]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove

; 5900 : 	pUnit = m_pPlayer->getUnit(iID);

	mov	ecx, DWORD PTR _iID$[esp]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	pop	esi

; 5901 : 
; 5902 : 	CvAssert(pUnit);
; 5903 : 	if(!pUnit) return;

	test	eax, eax
	je	SHORT $LN2@UnitProces

; 5904 : 
; 5905 : 	pUnit->SetTurnProcessed(true);

	mov	DWORD PTR _iID$[esp-4], 1
	mov	ecx, eax
	jmp	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN2@UnitProces:

; 5906 : }

	ret	4
?UnitProcessed@CvHomelandAI@@AAEXH@Z ENDP		; CvHomelandAI::UnitProcessed
_TEXT	ENDS
PUBLIC	?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteWorkerMove
EXTRN	?finishMoves@CvUnit@@QAEXXZ:PROC		; CvUnit::finishMoves
EXTRN	?ReadyToMove@CvUnit@@QBE_NXZ:PROC		; CvUnit::ReadyToMove
EXTRN	?GetLengthMissionQueue@CvUnit@@QBEHXZ:PROC	; CvUnit::GetLengthMissionQueue
EXTRN	?GetHeadMissionData@CvUnit@@QAEPBUMissionData@@XZ:PROC ; CvUnit::GetHeadMissionData
EXTRN	?IsImprovementPillaged@CvPlot@@QBE_NXZ:PROC	; CvPlot::IsImprovementPillaged
EXTRN	?GetBuilderAILogging@CvGlobals@@QAE_NXZ:PROC	; CvGlobals::GetBuilderAILogging
EXTRN	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_BUILD
EXTRN	?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z:PROC ; CvBuilderTaskingAI::EvaluateBuilder
EXTRN	?GetBuilderTaskingAI@CvPlayer@@QBEPAVCvBuilderTaskingAI@@XZ:PROC ; CvPlayer::GetBuilderTaskingAI
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$4
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
_TEXT	SEGMENT
_eMission$228941 = -180					; size = 4
_this$ = -180						; size = 4
_pPlot$228940 = -176					; size = 4
_aDirective$ = -172					; size = 20
_strLog$228948 = -152					; size = 28
_strTemp$228949 = -124					; size = 28
_strPlayerName$228950 = -96				; size = 28
_strFileName$228945 = -68				; size = 28
_strFileName$229000 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z PROC ; CvHomelandAI::ExecuteWorkerMove, COMDAT
; _this$ = ecx

; 5909 : {

	push	-1
	push	__ehhandler$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 168				; 000000a8H
	push	ebx
	push	ebp

; 5910 : 	const UINT ciDirectiveSize = 1;
; 5911 : 	BuilderDirective aDirective[ ciDirectiveSize ];
; 5912 : 
; 5913 : 	// evaluator
; 5914 : 	bool bHasDirective = m_pPlayer->GetBuilderTaskingAI()->EvaluateBuilder(pUnit, aDirective, ciDirectiveSize);

	mov	ebp, DWORD PTR _pUnit$[esp+184]
	push	esi
	push	edi
	or	ebx, -1
	push	0
	push	0
	mov	eax, ebx
	mov	edi, ecx
	mov	WORD PTR _aDirective$[esp+216], ax
	push	1
	lea	eax, DWORD PTR _aDirective$[esp+208]
	mov	ecx, ebx
	push	eax
	mov	WORD PTR _aDirective$[esp+226], cx
	mov	ecx, DWORD PTR [edi]
	mov	edx, ebx
	push	ebp
	mov	DWORD PTR _this$[esp+216], edi
	mov	DWORD PTR _aDirective$[esp+216], 6
	mov	DWORD PTR _aDirective$[esp+220], ebx
	mov	DWORD PTR _aDirective$[esp+224], ebx
	mov	WORD PTR _aDirective$[esp+232], dx
	call	?GetBuilderTaskingAI@CvPlayer@@QBEPAVCvBuilderTaskingAI@@XZ ; CvPlayer::GetBuilderTaskingAI
	mov	ecx, eax
	call	?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z ; CvBuilderTaskingAI::EvaluateBuilder

; 5915 : 	if(bHasDirective)

	test	al, al
	je	$LN36@ExecuteWor

; 5916 : 	{
; 5917 : 		switch(aDirective[0].m_eDirective)

	mov	eax, DWORD PTR _aDirective$[esp+196]
	test	eax, eax
	jl	$LN1@ExecuteWor
	cmp	eax, 5
	jg	$LN1@ExecuteWor

; 5918 : 		{
; 5919 : 		case BuilderDirective::BUILD_IMPROVEMENT_ON_RESOURCE:
; 5920 : 		case BuilderDirective::BUILD_IMPROVEMENT:
; 5921 : 		case BuilderDirective::REPAIR:
; 5922 : 		case BuilderDirective::BUILD_ROUTE:
; 5923 : 		case BuilderDirective::CHOP:
; 5924 : 		case BuilderDirective::REMOVE_ROAD:
; 5925 : 		{
; 5926 : 			CvPlot* pPlot = GC.getMap().plot(aDirective[0].m_sX, aDirective[0].m_sY);

	movsx	esi, WORD PTR _aDirective$[esp+208]
	movsx	eax, WORD PTR _aDirective$[esp+210]
	cmp	esi, -2147483647			; 80000001H
	je	$LN52@ExecuteWor
	cmp	eax, -2147483647			; 80000001H
	je	$LN52@ExecuteWor
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	al, al
	je	SHORT $LN62@ExecuteWor
	test	esi, esi
	jge	SHORT $LN64@ExecuteWor
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN62@ExecuteWor
$LN64@ExecuteWor:
	cmp	esi, ecx
	jl	SHORT $LN62@ExecuteWor
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN62@ExecuteWor:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN151@ExecuteWor
	movsx	eax, WORD PTR _aDirective$[esp+210]
	test	eax, eax
	jge	SHORT $LN74@ExecuteWor
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN76@ExecuteWor
$LN74@ExecuteWor:
	cmp	eax, edi
	jl	SHORT $LN151@ExecuteWor
	cdq
	idiv	edi
	jmp	SHORT $LN76@ExecuteWor
$LN151@ExecuteWor:
	movsx	edx, WORD PTR _aDirective$[esp+210]
$LN76@ExecuteWor:
	test	esi, esi
	jl	SHORT $LN56@ExecuteWor
	cmp	esi, ecx
	jge	SHORT $LN56@ExecuteWor
	test	edx, edx
	jl	SHORT $LN56@ExecuteWor
	cmp	edx, edi
	jge	SHORT $LN56@ExecuteWor
	mov	edi, DWORD PTR _this$[esp+196]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	DWORD PTR _pPlot$228940[esp+196], ecx
	jmp	SHORT $LN54@ExecuteWor
$LN56@ExecuteWor:
	mov	edi, DWORD PTR _this$[esp+196]
$LN52@ExecuteWor:
	mov	DWORD PTR _pPlot$228940[esp+196], 0
$LN54@ExecuteWor:

; 5927 : 			MissionTypes eMission = NO_MISSION;
; 5928 : 			if(pUnit->getX() == aDirective[0].m_sX && pUnit->getY() == aDirective[0].m_sY)

	movsx	eax, WORD PTR _aDirective$[esp+208]
	cmp	DWORD PTR [ebp+76], eax
	jne	SHORT $LN32@ExecuteWor
	movsx	eax, WORD PTR _aDirective$[esp+210]
	cmp	DWORD PTR [ebp+88], eax
	jne	SHORT $LN32@ExecuteWor

; 5929 : 			{
; 5930 : 				eMission = CvTypes::getMISSION_BUILD();

	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD

; 5931 : 			}
; 5932 : 			else

	jmp	SHORT $LN153@ExecuteWor
$LN32@ExecuteWor:

; 5933 : 			{
; 5934 : #ifdef AUI_HOMELAND_FIX_EXECUTE_WORKER_MOVE_MOVE_AND_BUILD
; 5935 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), aDirective[0].m_sX, aDirective[0].m_sY, 0, false, false, MISSIONAI_BUILD, pPlot);
; 5936 : 				if (pUnit->canMove())
; 5937 : 				{
; 5938 : 					eMission = CvTypes::getMISSION_BUILD();
; 5939 : 				}
; 5940 : 				else
; 5941 : 				{
; 5942 : 					eMission = CvTypes::getMISSION_MOVE_TO();
; 5943 : 					pUnit->finishMoves();
; 5944 : 					UnitProcessed(pUnit->GetID());
; 5945 : 				}
; 5946 : #else
; 5947 : 				eMission = CvTypes::getMISSION_MOVE_TO();

	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
$LN153@ExecuteWor:

; 5948 : #endif
; 5949 : 			}
; 5950 : 
; 5951 : 			if(GC.getLogging() && GC.GetBuilderAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _eMission$228941[esp+196], eax
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN30@ExecuteWor
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuilderAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::GetBuilderAILogging
	test	al, al
	je	$LN30@ExecuteWor

; 5952 : 			{
; 5953 : 				// Open the log file
; 5954 : 				CvString strFileName = "BuilderTaskingLog.csv";

	push	OFFSET $SG228946
	lea	ecx, DWORD PTR _strFileName$228945[esp+200]
	call	??0CvString@@QAE@PBD@Z			; CvString::CvString
	mov	DWORD PTR __$EHRec$[esp+204], 0

; 5955 : 				FILogFile* pLog;
; 5956 : 				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strFileName$228945[esp+196]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 5957 : 
; 5958 : 				// write in data
; 5959 : 				CvString strLog;

	lea	ecx, DWORD PTR _strLog$228948[esp+196]
	mov	esi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5960 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228949[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ebx, 2

; 5961 : 
; 5962 : 				CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$228950[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5963 : 				strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	BYTE PTR __$EHRec$[esp+204], 3
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	lea	ecx, DWORD PTR _strPlayerName$228950[esp+200]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 5964 : 				strLog += strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$228950[esp+196]
	push	ecx
	lea	ecx, DWORD PTR _strLog$228948[esp+200]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 5965 : 				strLog += ",";

	push	OFFSET $SG228951
	lea	ecx, DWORD PTR _strLog$228948[esp+200]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 5966 : 
; 5967 : 				strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	lea	edx, DWORD PTR _strTemp$228949[esp+200]
	push	OFFSET $SG228952
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 5968 : 				strLog += strTemp;

	lea	eax, DWORD PTR _strTemp$228949[esp+196]
	push	eax
	lea	ecx, DWORD PTR _strLog$228948[esp+200]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 5969 : 
; 5970 : 				strTemp.Format("%d,", pUnit->GetID()); // unit id

	mov	eax, DWORD PTR [ebp+100]
	push	eax
	lea	ecx, DWORD PTR _strTemp$228949[esp+200]
	push	OFFSET $SG228953
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 5971 : 				strLog += strTemp;

	lea	edx, DWORD PTR _strTemp$228949[esp+196]
	push	edx
	lea	ecx, DWORD PTR _strLog$228948[esp+200]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 5972 : 
; 5973 : 				switch(aDirective[0].m_eDirective)

	mov	eax, DWORD PTR _aDirective$[esp+196]
	cmp	eax, 5
	ja	SHORT $LN28@ExecuteWor
	jmp	DWORD PTR $LN158@ExecuteWor[eax*4]
$LN27@ExecuteWor:

; 5974 : 				{
; 5975 : 				case BuilderDirective::BUILD_IMPROVEMENT_ON_RESOURCE:
; 5976 : 					strLog += "On resource,";

	push	OFFSET $SG228959

; 5977 : 					break;

	jmp	SHORT $LN154@ExecuteWor
$LN26@ExecuteWor:

; 5978 : 				case BuilderDirective::BUILD_IMPROVEMENT:
; 5979 : 					strLog += "On plot,";

	push	OFFSET $SG228961

; 5980 : 					break;

	jmp	SHORT $LN154@ExecuteWor
$LN25@ExecuteWor:

; 5981 : 				case BuilderDirective::REPAIR:
; 5982 : 					strLog += "Repairing,";

	push	OFFSET $SG228963

; 5983 : 					break;

	jmp	SHORT $LN154@ExecuteWor
$LN24@ExecuteWor:

; 5984 : 				case BuilderDirective::BUILD_ROUTE:
; 5985 : 					strLog += "Building route,";

	push	OFFSET $SG228965

; 5986 : 					break;

	jmp	SHORT $LN154@ExecuteWor
$LN23@ExecuteWor:

; 5987 : 				case BuilderDirective::CHOP:
; 5988 : 					strLog += "Removing resource for production,";

	push	OFFSET $SG228967

; 5989 : 					break;

	jmp	SHORT $LN154@ExecuteWor
$LN22@ExecuteWor:

; 5990 : 				case BuilderDirective::REMOVE_ROAD:
; 5991 : 					strLog += "Removing road,";

	push	OFFSET $SG228969
$LN154@ExecuteWor:
	lea	ecx, DWORD PTR _strLog$228948[esp+200]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN28@ExecuteWor:

; 5992 : 					break;
; 5993 : 				}
; 5994 : 
; 5995 : 				if(eMission == CvTypes::getMISSION_BUILD())

	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	cmp	DWORD PTR _eMission$228941[esp+196], eax
	jne	SHORT $LN21@ExecuteWor

; 5996 : 				{
; 5997 : 					if(aDirective[0].m_eDirective == BuilderDirective::REPAIR)

	mov	eax, DWORD PTR _aDirective$[esp+196]
	cmp	eax, 3
	jne	SHORT $LN20@ExecuteWor

; 5998 : 					{
; 5999 : 						if(pPlot->IsImprovementPillaged())

	mov	ecx, DWORD PTR _pPlot$228940[esp+196]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged

; 6000 : 						{
; 6001 : 							strLog += "Repairing improvement";

	lea	ecx, DWORD PTR _strLog$228948[esp+196]
	test	al, al
	je	SHORT $LN19@ExecuteWor
	push	OFFSET $SG228973

; 6002 : 						}
; 6003 : 						else

	jmp	SHORT $LN155@ExecuteWor
$LN19@ExecuteWor:

; 6004 : 						{
; 6005 : 							strLog += "Repairing route";

	push	OFFSET $SG228975

; 6006 : 						}

	jmp	SHORT $LN155@ExecuteWor
$LN20@ExecuteWor:

; 6007 : 					}
; 6008 : 					else if(aDirective[0].m_eDirective == BuilderDirective::BUILD_ROUTE)

	cmp	eax, ebx
	jne	SHORT $LN16@ExecuteWor

; 6009 : 					{
; 6010 : 						strLog += "Building route,";

	push	OFFSET $SG228978
	jmp	SHORT $LN156@ExecuteWor
$LN16@ExecuteWor:

; 6011 : 					}
; 6012 : 					else if(aDirective[0].m_eDirective == BuilderDirective::BUILD_IMPROVEMENT || aDirective[0].m_eDirective == BuilderDirective::BUILD_IMPROVEMENT_ON_RESOURCE)

	cmp	eax, 1
	je	SHORT $LN13@ExecuteWor
	test	eax, eax
	je	SHORT $LN13@ExecuteWor

; 6015 : 					}
; 6016 : 					else if(aDirective[0].m_eDirective == BuilderDirective::CHOP)
; 6017 : 					{
; 6018 : 						strLog += "Removing feature for production,";

	lea	ecx, DWORD PTR _strLog$228948[esp+196]
	cmp	eax, 4
	jne	SHORT $LN11@ExecuteWor
	push	OFFSET $SG228985

; 6019 : 					}
; 6020 : 					else

	jmp	SHORT $LN155@ExecuteWor
$LN11@ExecuteWor:

; 6021 : 					{
; 6022 : 						strLog += "Removing road,";

	push	OFFSET $SG228987
	jmp	SHORT $LN155@ExecuteWor
$LN13@ExecuteWor:

; 6013 : 					{
; 6014 : 						strLog += "Building improvement,";

	push	OFFSET $SG228982

; 6023 : 					}
; 6024 : 				}
; 6025 : 				else

	jmp	SHORT $LN156@ExecuteWor
$LN21@ExecuteWor:

; 6026 : 				{
; 6027 : 					strLog += "Moving to location,";

	push	OFFSET $SG228989
$LN156@ExecuteWor:
	lea	ecx, DWORD PTR _strLog$228948[esp+200]
$LN155@ExecuteWor:
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 6028 : 				}
; 6029 : 
; 6030 : 				pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$228948[esp+196]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	esi
	call	edx
	add	esp, 8

; 6031 : 			}

	lea	ecx, DWORD PTR _strPlayerName$228950[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$228949[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLog$228948[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strFileName$228945[esp+196]
	mov	DWORD PTR __$EHRec$[esp+204], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN30@ExecuteWor:

; 6032 : 
; 6033 : 			if(eMission == CvTypes::getMISSION_BUILD())

	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	mov	esi, DWORD PTR _eMission$228941[esp+196]
	cmp	esi, eax
	jne	SHORT $LN8@ExecuteWor

; 6034 : 			{
; 6035 : 				// check to see if we already have this mission as the unit's head mission
; 6036 : 				bool bPushMission = true;
; 6037 : 				const MissionData* pkMissionData = pUnit->GetHeadMissionData();

	mov	ecx, ebp
	call	?GetHeadMissionData@CvUnit@@QAEPBUMissionData@@XZ ; CvUnit::GetHeadMissionData

; 6038 : 				if(pkMissionData != NULL)

	test	eax, eax
	je	SHORT $LN150@ExecuteWor

; 6039 : 				{
; 6040 : 					if(pkMissionData->eMissionType == eMission && pkMissionData->iData1 == aDirective[0].m_eBuild)

	cmp	DWORD PTR [eax], esi
	jne	SHORT $LN150@ExecuteWor
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR _aDirective$[esp+200]

; 6041 : 					{
; 6042 : 						bPushMission = false;
; 6043 : 					}
; 6044 : 				}
; 6045 : 
; 6046 : 				if(bPushMission)

	je	SHORT $LN5@ExecuteWor
$LN150@ExecuteWor:

; 6047 : 				{
; 6048 : 					pUnit->PushMission(CvTypes::getMISSION_BUILD(), aDirective[0].m_eBuild, -1, 0, (pUnit->GetLengthMissionQueue() > 0), false, MISSIONAI_BUILD, pPlot);

	mov	ecx, DWORD PTR _pPlot$228940[esp+196]
	push	0
	push	ecx
	push	18					; 00000012H
	push	0
	mov	ecx, ebp
	call	?GetLengthMissionQueue@CvUnit@@QBEHXZ	; CvUnit::GetLengthMissionQueue
	mov	ecx, DWORD PTR _aDirective$[esp+216]
	test	eax, eax
	setg	dl
	movzx	eax, dl
	push	eax
	push	0
	push	-1
	push	ecx
	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	push	eax
	mov	ecx, ebp
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission
$LN5@ExecuteWor:

; 6049 : 				}
; 6050 : 
; 6051 : 				CvAssertMsg(!pUnit->ReadyToMove(), "Worker did not do their mission this turn. Could cause game to hang.");
; 6052 : 				if(pUnit->ReadyToMove())

	mov	ecx, ebp
	call	?ReadyToMove@CvUnit@@QBE_NXZ		; CvUnit::ReadyToMove
	test	al, al
	je	SHORT $LN4@ExecuteWor

; 6053 : 				{
; 6054 : 					pUnit->finishMoves();

	mov	ecx, ebp
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN4@ExecuteWor:

; 6055 : 				}
; 6056 : 				UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR [ebp+100]
	push	edx

; 6063 : 				UnitProcessed(pUnit->GetID());

	mov	ecx, edi
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 6064 : 			}
; 6065 : #endif
; 6066 : 
; 6067 : 			return true;

	mov	al, 1
	jmp	$LN37@ExecuteWor
$LN8@ExecuteWor:

; 6057 : 			}
; 6058 : #ifndef AUI_HOMELAND_FIX_EXECUTE_WORKER_MOVE_MOVE_AND_BUILD
; 6059 : 			else
; 6060 : 			{
; 6061 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), aDirective[0].m_sX, aDirective[0].m_sY, 0, false, false, MISSIONAI_BUILD, pPlot);

	mov	eax, DWORD PTR _pPlot$228940[esp+196]
	movsx	ecx, WORD PTR _aDirective$[esp+210]
	movsx	edx, WORD PTR _aDirective$[esp+208]
	push	0
	push	eax
	push	18					; 00000012H
	push	0
	push	0
	push	0
	push	ecx
	push	edx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, ebp
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6062 : 				pUnit->finishMoves();

	mov	ecx, ebp
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6063 : 				UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR [ebp+100]
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 6064 : 			}
; 6065 : #endif
; 6066 : 
; 6067 : 			return true;

	mov	al, 1
	jmp	$LN37@ExecuteWor
$LN36@ExecuteWor:

; 6068 : 		}
; 6069 : 		break;
; 6070 : 		}
; 6071 : 	}
; 6072 : 	else
; 6073 : 	{
; 6074 : 		if(GC.getLogging() && GC.GetBuilderAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@ExecuteWor
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuilderAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::GetBuilderAILogging
	test	al, al
	je	SHORT $LN1@ExecuteWor

; 6075 : 		{
; 6076 : 			CvString strFileName = "BuilderTaskingLog.csv";

	push	OFFSET $SG229001
	lea	ecx, DWORD PTR _strFileName$229000[esp+200]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[esp+204], 4

; 6077 : 			FILogFile* pLog;
; 6078 : 			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strFileName$229000[esp+196]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 6079 : 			pLog->Msg("builder has no directive");

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	OFFSET $SG229003
	push	eax
	call	edx
	add	esp, 8

; 6080 : 		}

	lea	ecx, DWORD PTR _strFileName$229000[esp+196]
	mov	DWORD PTR __$EHRec$[esp+204], ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteWor:

; 6081 : 	}
; 6082 : 
; 6083 : 	return false;

	xor	al, al
$LN37@ExecuteWor:

; 6084 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+196]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 180				; 000000b4H
	ret	4
	npad	2
$LN158@ExecuteWor:
	DD	$LN27@ExecuteWor
	DD	$LN26@ExecuteWor
	DD	$LN24@ExecuteWor
	DD	$LN25@ExecuteWor
	DD	$LN23@ExecuteWor
	DD	$LN22@ExecuteWor
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _strFileName$228945[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$1:
	lea	ecx, DWORD PTR _strLog$228948[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$228949[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$3:
	lea	ecx, DWORD PTR _strPlayerName$228950[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$4:
	lea	ecx, DWORD PTR _strFileName$229000[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ENDP ; CvHomelandAI::ExecuteWorkerMove
PUBLIC	?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z ; CvHomelandAI::ExecuteSpecialExploreMove
EXTRN	?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ:PROC ; CvTwoLayerPathFinder::GetPathEndTurnPlot
EXTRN	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z:PROC ; CvTwoLayerPathFinder::GenerateUnitPath
EXTRN	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::getPathFinder
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$0
__ehfuncinfo$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_strLogString$229060 = -40				; size = 28
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
$T251479 = 12						; size = 4
_pTargetPlot$ = 12					; size = 4
?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z PROC ; CvHomelandAI::ExecuteSpecialExploreMove, COMDAT
; _this$ = ecx

; 6176 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 6177 : 	bool bCanFindPath = GC.getPathFinder().GenerateUnitPath(pUnit, pUnit->getX(), pUnit->getY(), pTargetPlot->getX(), pTargetPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);

	mov	eax, DWORD PTR _pTargetPlot$[esp+8]
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	mov	esi, DWORD PTR _pUnit$[esp+44]
	mov	edx, DWORD PTR [esi+88]
	push	edi
	mov	edi, DWORD PTR [esi+76]
	push	1
	mov	ebx, ecx
	movsx	ecx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	138					; 0000008aH
	push	ecx
	push	eax
	push	edx
	push	edi
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	ecx, eax
	call	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath

; 6178 : 	if(bCanFindPath)

	test	al, al
	je	$LN2@ExecuteSpe

; 6179 : 	{
; 6180 : 		CvPlot* pPlot = GC.getPathFinder().GetPathEndTurnPlot();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	ecx, eax
	call	?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ ; CvTwoLayerPathFinder::GetPathEndTurnPlot
	mov	edi, eax

; 6181 : 		if(pPlot)

	test	edi, edi
	je	$LN2@ExecuteSpe

; 6182 : 		{
; 6183 : 			CvAssert(!pUnit->atPlot(*pPlot));
; 6184 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@ExecuteSpe
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@ExecuteSpe

; 6185 : 			{
; 6186 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$229060[esp+52]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6187 : 				strLogString.Format("UnitID: %d Moving to script explore target, X: %d, Y: %d, from X: %d Y: %d", pUnit->GetID(), pPlot->getX(), pPlot->getY(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [esi+100]
	push	eax
	movsx	eax, WORD PTR [edi+2]
	push	ecx
	movsx	ecx, WORD PTR [edi]
	push	eax
	push	ecx
	push	edx
	lea	edx, DWORD PTR _strLogString$229060[esp+72]
	push	OFFSET $SG229061
	push	edx
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 6188 : 				LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$229060[esp+52]
	push	eax
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 6189 : 			}

	lea	ecx, DWORD PTR _strLogString$229060[esp+52]
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteSpe:

; 6190 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pPlot->getX(), pPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER, false, false, MISSIONAI_EXPLORE, pPlot);

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	0
	push	edi
	push	14					; 0000000eH
	push	0
	push	0
	push	138					; 0000008aH
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6191 : 			pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 6192 : 			UnitProcessed(pUnit->GetID());

	mov	esi, DWORD PTR [esi+100]
	lea	ecx, DWORD PTR $T251479[esp+48]
	push	ecx
	lea	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR $T251479[esp+52], esi
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [ebx]
	push	esi
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN50@ExecuteSpe
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN50@ExecuteSpe:
	pop	edi
	pop	esi

; 6193 : 
; 6194 : 			return true;

	mov	al, 1
	pop	ebx

; 6195 : 		}
; 6196 : 	}
; 6197 : 	return false;
; 6198 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
$LN2@ExecuteSpe:
	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	pop	esi
	xor	al, al
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _strLogString$229060[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteSpecialExploreMove@CvHomelandAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z ENDP ; CvHomelandAI::ExecuteSpecialExploreMove
PUBLIC	??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ	; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\list
;	COMDAT ??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 436  : 		{	// construct empty list

	push	esi
	mov	esi, ecx
	call	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], 0

; 437  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$list@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ	; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 521  : 		_Tidy();

	jmp	?_Tidy@?$list@HV?$allocator@H@std@@@std@@IAEXXZ ; std::list<int,std::allocator<int> >::_Tidy
??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?push_back@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::list<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 670  : 		_Insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [edi+4]
	push	eax
	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z ; std::list<int,std::allocator<int> >::_Buynode
	push	1
	mov	ecx, esi
	mov	ebx, eax
	call	?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::list<int,std::allocator<int> >::_Incsize
	mov	DWORD PTR [edi+4], ebx
	mov	edx, DWORD PTR [ebx+4]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx], ebx
	pop	ebx

; 671  : 		}

	ret	4
?push_back@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::list<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@3:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEIABQAVCvPlot@@H@Z ; CvWeightedVector<CvPlot *,100,1>::push_back
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEIABQAVCvPlot@@H@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEIABQAVCvPlot@@H@Z PROC ; CvWeightedVector<CvPlot *,100,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+812], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@6
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSize
$LN5@push_back@6:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@6
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@6:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEIABQAVCvPlot@@H@Z ENDP ; CvWeightedVector<CvPlot *,100,1>::push_back
_TEXT	ENDS
PUBLIC	?reserve@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXI@Z ; CvWeightedVector<CvPlot *,100,1>::reserve
; Function compile flags: /Ogtpy
;	COMDAT ?reserve@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?reserve@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXI@Z PROC ; CvWeightedVector<CvPlot *,100,1>::reserve, COMDAT
; _this$ = ecx

; 128  : 		m_pItems.reserve(uiNewSize);

	jmp	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSizeToFit
?reserve@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXI@Z ENDP ; CvWeightedVector<CvPlot *,100,1>::reserve
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEIABQAVCvCity@@H@Z ; CvWeightedVector<CvCity *,64,1>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEIABQAVCvCity@@H@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEIABQAVCvCity@@H@Z PROC ; CvWeightedVector<CvCity *,64,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+524], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@7
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN5@push_back@7:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@7
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@7:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEIABQAVCvCity@@H@Z ENDP ; CvWeightedVector<CvCity *,64,1>::push_back
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXPAVCvHomelandTarget@@0@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Destroy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXPAVCvHomelandTarget@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXPAVCvHomelandTarget@@0@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXPAVCvHomelandTarget@@0@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV3@IABV3@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV3@IABV3@@Z
_TEXT	SEGMENT
$T251749 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$251752 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV3@IABV3@@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$251752[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T251749[esp+12], 0
	mov	eax, DWORD PTR $T251749[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvHomelandTarget *,unsigned int,CvHomelandTarget,std::allocator<CvHomelandTarget> >

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi+esi*4]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV3@IABV3@@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Ufill
_TEXT	ENDS
PUBLIC	??_GTradeConnection@@QAEPAXI@Z			; TradeConnection::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GTradeConnection@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GTradeConnection@@QAEPAXI@Z PROC			; TradeConnection::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [esi+56]
	cmp	eax, ecx
	je	SHORT $LN9@scalar@4
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN9@scalar@4:
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN23@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN23@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GTradeConnection@@QAEPAXI@Z ENDP			; TradeConnection::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@16
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@16:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@16
	pop	esi
$LN13@unchecked_@16:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAPAVCvPlot@@IPAV1@V?$allocator@PAVCvPlot@@@std@@@stdext@@YAXPAPAVCvPlot@@IABQAV1@AAV?$allocator@PAVCvPlot@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvPlot * *,unsigned int,CvPlot *,std::allocator<CvPlot *> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@17
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@17:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@17
	pop	esi
$LN13@unchecked_@17:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAPAVCvCity@@IPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAXPAPAVCvCity@@IABQAV1@AAV?$allocator@PAVCvCity@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvCity * *,unsigned int,CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAVCvHomelandTarget@@@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV2@00@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Umove<CvHomelandTarget *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??$_Umove@PAVCvHomelandTarget@@@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV2@00@Z
_TEXT	SEGMENT
$T252021 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$252024 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAVCvHomelandTarget@@@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV2@00@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Umove<CvHomelandTarget *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$252024[esp]
	mov	BYTE PTR $T252021[esp+4], 0
	mov	eax, DWORD PTR $T252021[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAVCvHomelandTarget@@@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV2@00@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Umove<CvHomelandTarget *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>
_TEXT	ENDS
PUBLIC	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0@Z ; std::iter_swap<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$iter_swap@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0@Z PROC ; std::iter_swap<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN15@iter_swap@5
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ecx], edx
	add	ecx, 4
	add	eax, 4
	cmp	eax, ecx
	je	SHORT $LN19@iter_swap@5
	mov	esi, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ecx], edx
$LN19@iter_swap@5:
	pop	esi
$LN15@iter_swap@5:

; 595  : 	}

	ret	0
??$iter_swap@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0@Z ENDP ; std::iter_swap<std::pair<int,CvPlot *> *,std::pair<int,CvPlot *> *>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ; std::_Sort_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$_Sort_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z PROC ; std::_Sort_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 2232 : 	{	// order heap by repeatedly popping, using _Pred

	push	esi

; 2233 : 	for (; 1 < _Last - _First; --_Last)

	mov	esi, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	sub	esi, edi
	mov	eax, esi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap
	push	ebx
	mov	ebx, DWORD PTR __Pred$[esp+8]
$LN20@Sort_heap:

; 2234 : 		std::pop_heap(_First, _Last, _Pred);

	mov	ecx, DWORD PTR [edi+esi-4]
	mov	eax, DWORD PTR [edi+esi-8]
	mov	edx, DWORD PTR [edi]
	push	ebx
	push	ecx
	push	eax
	lea	eax, DWORD PTR [esi-8]
	sar	eax, 3
	push	eax
	mov	DWORD PTR [edi+esi-8], edx
	mov	edx, DWORD PTR [edi+4]
	push	0
	push	edi
	mov	DWORD PTR [edi+esi-4], edx
	call	??$_Adjust_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@HHU10@P6A_NABU10@2@Z@Z ; std::_Adjust_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	sub	esi, 8
	mov	eax, esi
	sar	eax, 3
	add	esp, 24					; 00000018H
	cmp	eax, 1
	jg	SHORT $LN20@Sort_heap
	pop	ebx
$LN1@Sort_heap:
	pop	edi
	pop	esi

; 2235 : 	}

	ret	0
??$_Sort_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ENDP ; std::_Sort_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_merge<CvHomelandMove *,int,CvHomelandMove>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z
_TEXT	SEGMENT
__Firstn$232996 = -32					; size = 4
__Lastn$232997 = -28					; size = 4
__Midn$233016 = -24					; size = 4
$T252298 = -20						; size = 20
$T252296 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
tv368 = 20						; size = 4
$T252416 = 20						; size = 1
$T252365 = 20						; size = 1
$T252366 = 20						; size = 1
$T252297 = 20						; size = 4
$T252295 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z PROC ; std::_Buffered_merge<CvHomelandMove *,int,CvHomelandMove>, COMDAT

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[esp-4]
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, DWORD PTR __First$[esp+32]
	push	ebp
	mov	ebp, DWORD PTR __Mid$[esp+36]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+44]
	add	eax, edi
	cmp	eax, 2
	je	$LN106@Buffered_m
	jmp	SHORT $LN101@Buffered_m
$LL113@Buffered_m:
	mov	edi, DWORD PTR __Count2$[esp+44]
$LN101@Buffered_m:

; 2764 : 		}
; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	DWORD PTR __Count1$[esp+44], edi
	mov	esi, DWORD PTR __Tempbuf$[esp+44]
	jg	SHORT $LN6@Buffered_m
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandMove>::_Maxlen
	cmp	DWORD PTR __Count1$[esp+44], eax
	jle	$LN107@Buffered_m
$LN6@Buffered_m:

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandMove>::_Maxlen
	cmp	edi, eax
	jle	$LN108@Buffered_m

; 2775 : 		}
; 2776 : 	else
; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	mov	eax, DWORD PTR __Count1$[esp+44]
	cmp	edi, eax

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2784 : 			_Firstn = _First;
; 2785 : 			std::advance(_Firstn, _Count1n);
; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	push	0
	jge	SHORT $LN2@Buffered_m
	mov	ecx, DWORD PTR __Last$[esp+48]
	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	lea	eax, DWORD PTR [ebx+edi*8]
	push	eax
	push	ecx
	push	ebp
	mov	DWORD PTR __Firstn$232996[esp+64], eax
	call	??$_Lower_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvHomelandMove *,CvHomelandMove,int>

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	esi, eax
	sub	esi, ebp
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Lastn$232997[esp+48], eax
	sar	esi, 3

; 2788 : 			}
; 2789 : 		else

	jmp	SHORT $LN99@Buffered_m
$LN2@Buffered_m:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	eax, edi
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1

; 2792 : 			_Lastn = _Mid;
; 2793 : 			std::advance(_Lastn, _Count2n);

	lea	eax, DWORD PTR [ebp+esi*8]

; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	push	eax
	push	ebp
	push	ebx
	mov	DWORD PTR __Lastn$232997[esp+64], eax
	call	??$_Upper_bound@PAVCvHomelandMove@@V1@H@std@@YAPAVCvHomelandMove@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvHomelandMove *,CvHomelandMove,int>

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edi, eax
	sub	edi, ebx
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Firstn$232996[esp+48], eax
	mov	eax, DWORD PTR __Lastn$232997[esp+48]
	sar	edi, 3
$LN99@Buffered_m:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	edx, DWORD PTR __Tempbuf$[esp+44]
	mov	ecx, DWORD PTR __Count1$[esp+44]
	push	edx
	push	esi
	sub	ecx, edi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Firstn$232996[esp+64]
	push	ebp
	push	eax
	mov	DWORD PTR tv368[esp+68], ecx
	call	??$_Buffered_rotate@PAVCvHomelandMove@@HV1@@std@@YAPAVCvHomelandMove@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_rotate<CvHomelandMove *,int,CvHomelandMove>

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	ecx, DWORD PTR __Tempbuf$[esp+68]
	mov	edx, DWORD PTR __Firstn$232996[esp+72]
	push	ecx
	push	esi
	push	edi
	push	eax
	push	edx
	push	ebx
	mov	DWORD PTR __Midn$233016[esp+96], eax
	call	??$_Buffered_merge@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_merge<CvHomelandMove *,int,CvHomelandMove>

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	eax, DWORD PTR __Count2$[esp+92]
	mov	ecx, DWORD PTR tv368[esp+92]
	mov	ebp, DWORD PTR __Lastn$232997[esp+96]
	mov	ebx, DWORD PTR __Midn$233016[esp+96]
	sub	eax, esi
	mov	DWORD PTR __Count1$[esp+92], ecx
	add	ecx, eax
	add	esp, 48					; 00000030H
	mov	DWORD PTR __Count2$[esp+44], eax
	cmp	ecx, 2
	jne	$LL113@Buffered_m
$LN106@Buffered_m:

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR [ebp+4]
	cmp	eax, DWORD PTR [ebx+4]
	jle	$LN3@Buffered_m

; 2763 : 			std::iter_swap(_First, _Mid);

	cmp	ebx, ebp
	je	$LN3@Buffered_m
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], edx
	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [ebx+4], edx
	mov	DWORD PTR [ebp], eax
	mov	DWORD PTR [ebp+4], ecx

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
$LN107@Buffered_m:

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T252295[esp+64], esp
	push	ebp
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T252296[esp+72]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	mov	eax, DWORD PTR $T252296[esp+80]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN37@Buffered_m
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN37@Buffered_m:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	eax, DWORD PTR __Last$[esp+44]
	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T252365[esp+44], 0
	mov	ecx, DWORD PTR $T252365[esp+44]
	mov	edx, DWORD PTR $T252366[esp+44]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	mov	edx, DWORD PTR [esi]
	push	ebx
	push	eax
	push	ebp
	push	ecx
	push	edx
	call	??$_Merge@PAVCvHomelandMove@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandMove@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
$LN108@Buffered_m:

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR __Last$[esp+44]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T252297[esp+64], esp
	push	edi
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T252298[esp+72]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	mov	eax, DWORD PTR $T252298[esp+80]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN61@Buffered_m
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN61@Buffered_m:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR $T252416[esp+44], 0
	mov	ecx, DWORD PTR $T252416[esp+44]
	push	ecx
	push	edi
	push	edx
	push	eax
	push	ebp
	push	ebx
	call	??$_Merge_backward@PAVCvHomelandMove@@PAV1@PAV1@@std@@YAPAVCvHomelandMove@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvHomelandMove *,CvHomelandMove *,CvHomelandMove *>
	add	esp, 24					; 00000018H
$LN3@Buffered_m:

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
??$_Buffered_merge@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ENDP ; std::_Buffered_merge<CvHomelandMove *,int,CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z ; std::_Insertion_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z PROC ; std::_Insertion_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAVCvHomelandTarget@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z ENDP ; std::_Insertion_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
__Midn$233343 = -24					; size = 4
$T252532 = -20						; size = 20
$T252530 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
tv336 = 20						; size = 4
__Count1$ = 20						; size = 4
$T252619 = 24						; size = 1
$T252531 = 24						; size = 4
$T252529 = 24						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
__Pred$ = 32						; size = 4
??$_Buffered_merge@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z PROC ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 2889 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred

	sub	esp, 24					; 00000018H
	push	ebx

; 2890 : 	if (_Count1 + _Count2 == 2)

	mov	ebx, DWORD PTR __Count1$[esp+24]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+36]
	lea	eax, DWORD PTR [ebx+edi]
	cmp	eax, 2
	je	$LN101@Buffered_m@2
	jmp	SHORT $LN90@Buffered_m@2
	npad	3
$LL102@Buffered_m@2:
	mov	edi, DWORD PTR __Count2$[esp+36]
	mov	ebx, DWORD PTR __Count1$[esp+36]
$LN90@Buffered_m@2:

; 2894 : 		}
; 2895 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	ebx, edi
	mov	esi, DWORD PTR __Tempbuf$[esp+36]
	jg	SHORT $LN6@Buffered_m@2
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	ebx, eax
	jle	$LN96@Buffered_m@2
$LN6@Buffered_m@2:

; 2900 : 		}
; 2901 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	edi, eax
	jle	$LN97@Buffered_m@2

; 2906 : 		}
; 2907 : 	else
; 2908 : 		{	// buffer too small, divide and conquer
; 2909 : 		_BidIt _Firstn, _Lastn;
; 2910 : 		_Diff _Count1n, _Count2n;
; 2911 : 		if (_Count2 < _Count1)

	cmp	edi, ebx

; 2912 : 			{	// left larger, cut it in half and partition right to match
; 2913 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2914 : 			_Firstn = _First;
; 2915 : 			std::advance(_Firstn, _Count1n);
; 2916 : 			_Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+36]
	push	0
	push	ecx
	jge	SHORT $LN2@Buffered_m@2
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __Last$[esp+44]
	mov	edi, eax
	mov	eax, DWORD PTR __Mid$[esp+44]
	sar	edi, 1
	mov	ebp, edi
	shl	ebp, 4
	add	ebp, DWORD PTR __First$[esp+44]
	push	ebp
	push	edx
	push	eax
	call	??$_Lower_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	mov	ebx, eax

; 2917 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	esi, ebx
	sub	esi, DWORD PTR __Mid$[esp+56]
	add	esp, 20					; 00000014H
	sar	esi, 4

; 2918 : 			}
; 2919 : 		else

	jmp	SHORT $LN88@Buffered_m@2
$LN2@Buffered_m@2:

; 2920 : 			{	// right larger, cut it in half and partition left to match
; 2921 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	eax, edi
	cdq
	sub	eax, edx

; 2922 : 			_Lastn = _Mid;
; 2923 : 			std::advance(_Lastn, _Count2n);
; 2924 : 			_Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);

	mov	edx, DWORD PTR __First$[esp+44]
	mov	esi, eax
	mov	eax, DWORD PTR __Mid$[esp+44]
	sar	esi, 1
	mov	ebx, esi
	shl	ebx, 4
	add	ebx, eax
	push	ebx
	push	eax
	push	edx
	call	??$_Upper_bound@PAVCvHomelandUnit@@V1@HP6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@P6A_NV1@2@ZPAH@Z ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	mov	ebp, eax

; 2925 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edi, ebp
	sub	edi, DWORD PTR __First$[esp+56]
	add	esp, 20					; 00000014H
	sar	edi, 4
$LN88@Buffered_m@2:

; 2926 : 			}
; 2927 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2928 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Tempbuf$[esp+36]
	mov	eax, DWORD PTR __Count1$[esp+36]
	mov	edx, DWORD PTR __Mid$[esp+36]
	push	ecx
	push	esi
	sub	eax, edi
	push	eax
	push	ebx
	push	edx
	push	ebp
	mov	DWORD PTR tv336[esp+60], eax
	call	??$_Buffered_rotate@PAVCvHomelandUnit@@HV1@@std@@YAPAVCvHomelandUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_rotate<CvHomelandUnit *,int,CvHomelandUnit>

; 2929 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2930 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part

	mov	ecx, DWORD PTR __Pred$[esp+60]
	mov	edx, DWORD PTR __Tempbuf$[esp+60]
	push	ecx
	push	edx
	push	esi
	push	edi
	push	eax
	mov	DWORD PTR __Midn$233343[esp+84], eax
	mov	eax, DWORD PTR __First$[esp+80]
	push	ebp
	push	eax
	call	??$_Buffered_merge@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>

; 2931 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2932 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);

	mov	eax, DWORD PTR __Count2$[esp+88]
	mov	ecx, DWORD PTR tv336[esp+88]
	mov	edx, DWORD PTR __Midn$233343[esp+92]
	sub	eax, esi
	mov	DWORD PTR __Count1$[esp+88], ecx
	add	ecx, eax
	add	esp, 52					; 00000034H
	mov	DWORD PTR __Count2$[esp+36], eax
	mov	DWORD PTR __Mid$[esp+36], ebx
	mov	DWORD PTR __First$[esp+36], edx
	cmp	ecx, 2
	jne	$LL102@Buffered_m@2
$LN101@Buffered_m@2:

; 2891 : 		{	// order two one-element partitions
; 2892 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	edi, DWORD PTR __First$[esp+36]
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR __Mid$[esp+36]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [esi+4]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	call	DWORD PTR __Pred$[esp+68]
	add	esp, 32					; 00000020H
	test	al, al
	je	$LN3@Buffered_m@2

; 2893 : 			std::iter_swap(_First, _Mid);

	push	esi
	push	edi
	call	??$iter_swap@PAVCvHomelandUnit@@PAV1@@std@@YAXPAVCvHomelandUnit@@0@Z ; std::iter_swap<CvHomelandUnit *,CvHomelandUnit *>
	add	esp, 8

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN96@Buffered_m@2:

; 2896 : 		{	// buffer left partition, then merge
; 2897 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR __Mid$[esp+36]
	mov	ebx, DWORD PTR __First$[esp+36]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebp, ebp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T252529[esp+56], esp
	push	edi
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T252530[esp+64]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	mov	eax, DWORD PTR $T252530[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebp
	je	SHORT $LN30@Buffered_m@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN30@Buffered_m@2:

; 2898 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2899 : 			_Mid, _Last, _First, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+36]
	mov	edx, DWORD PTR __Last$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ebx
	push	edx
	push	edi
	push	eax
	push	ecx
	call	??$unchecked_merge@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@stdext@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@Z@Z ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 24					; 00000018H

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN97@Buffered_m@2:

; 2902 : 		{	// buffer right partition, then merge
; 2903 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [eax]
	mov	ebx, DWORD PTR __Last$[esp+36]
	mov	edi, DWORD PTR __Mid$[esp+36]
	mov	DWORD PTR [eax+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T252531[esp+56], esp
	xor	ebp, ebp
	push	ebx
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	mov	ecx, DWORD PTR [esi+16]
	lea	edx, DWORD PTR $T252532[esp+64]
	push	edi
	push	edx
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	mov	eax, DWORD PTR $T252532[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebp
	je	SHORT $LN50@Buffered_m@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN50@Buffered_m@2:

; 2904 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
; 2905 : 			_Last, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+4]
	mov	BYTE PTR $T252619[esp+36], 0
	mov	eax, DWORD PTR $T252619[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+44]
	push	ebx
	push	edx
	push	eax
	push	edi
	push	ecx
	call	??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@P6A_NV1@0@Z@std@@YAPAVCvHomelandUnit@@PAV1@0000P6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 28					; 0000001cH
$LN3@Buffered_m@2:

; 2933 : 		}
; 2934 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Buffered_merge@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ENDP ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z
_TEXT	SEGMENT
__Midn$233449 = -24					; size = 4
$T252730 = -20						; size = 20
$T252728 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
tv368 = 20						; size = 4
__Count1$ = 20						; size = 4
$T252849 = 24						; size = 1
$T252798 = 24						; size = 1
$T252799 = 24						; size = 1
$T252729 = 24						; size = 4
$T252727 = 24						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z PROC ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit>, COMDAT

; 2759 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	ebx, DWORD PTR __Count1$[esp+24]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+36]
	lea	eax, DWORD PTR [ebx+edi]
	cmp	eax, 2
	je	$LN111@Buffered_m@3
	jmp	SHORT $LN100@Buffered_m@3
	npad	3
$LL112@Buffered_m@3:
	mov	edi, DWORD PTR __Count2$[esp+36]
	mov	ebx, DWORD PTR __Count1$[esp+36]
$LN100@Buffered_m@3:

; 2764 : 		}
; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	ebx, edi
	mov	esi, DWORD PTR __Tempbuf$[esp+36]
	jg	SHORT $LN6@Buffered_m@3
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	ebx, eax
	jle	$LN106@Buffered_m@3
$LN6@Buffered_m@3:

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	edi, eax
	jle	$LN107@Buffered_m@3

; 2775 : 		}
; 2776 : 	else
; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	cmp	edi, ebx

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2784 : 			_Firstn = _First;
; 2785 : 			std::advance(_Firstn, _Count1n);
; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	push	0
	jge	SHORT $LN2@Buffered_m@3
	mov	ecx, DWORD PTR __Last$[esp+40]
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __Mid$[esp+40]
	mov	edi, eax
	sar	edi, 1
	mov	ebp, edi
	shl	ebp, 4
	add	ebp, DWORD PTR __First$[esp+40]
	push	ebp
	push	ecx
	push	edx
	call	??$_Lower_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvHomelandUnit *,CvHomelandUnit,int>
	mov	ebx, eax

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	esi, ebx
	sub	esi, DWORD PTR __Mid$[esp+52]
	add	esp, 16					; 00000010H
	sar	esi, 4

; 2788 : 			}
; 2789 : 		else

	jmp	SHORT $LN98@Buffered_m@3
$LN2@Buffered_m@3:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	eax, edi
	cdq
	sub	eax, edx
	mov	esi, eax

; 2792 : 			_Lastn = _Mid;
; 2793 : 			std::advance(_Lastn, _Count2n);

	mov	eax, DWORD PTR __Mid$[esp+40]
	sar	esi, 1
	mov	ebx, esi
	shl	ebx, 4
	add	ebx, eax

; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	push	ebx
	push	eax
	mov	eax, DWORD PTR __First$[esp+48]
	push	eax
	call	??$_Upper_bound@PAVCvHomelandUnit@@V1@H@std@@YAPAVCvHomelandUnit@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvHomelandUnit *,CvHomelandUnit,int>
	mov	ebp, eax

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edi, ebp
	sub	edi, DWORD PTR __First$[esp+52]
	add	esp, 16					; 00000010H
	sar	edi, 4
$LN98@Buffered_m@3:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Tempbuf$[esp+36]
	mov	eax, DWORD PTR __Count1$[esp+36]
	mov	edx, DWORD PTR __Mid$[esp+36]
	push	ecx
	push	esi
	sub	eax, edi
	push	eax
	push	ebx
	push	edx
	push	ebp
	mov	DWORD PTR tv368[esp+60], eax
	call	??$_Buffered_rotate@PAVCvHomelandUnit@@HV1@@std@@YAPAVCvHomelandUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_rotate<CvHomelandUnit *,int,CvHomelandUnit>

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	ecx, DWORD PTR __Tempbuf$[esp+60]
	mov	edx, DWORD PTR __First$[esp+60]
	push	ecx
	push	esi
	push	edi
	push	eax
	push	ebp
	push	edx
	mov	DWORD PTR __Midn$233449[esp+88], eax
	call	??$_Buffered_merge@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit>

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	eax, DWORD PTR __Count2$[esp+84]
	mov	ecx, DWORD PTR tv368[esp+84]
	mov	edx, DWORD PTR __Midn$233449[esp+88]
	sub	eax, esi
	mov	DWORD PTR __Count1$[esp+84], ecx
	add	ecx, eax
	add	esp, 48					; 00000030H
	mov	DWORD PTR __Count2$[esp+36], eax
	mov	DWORD PTR __Mid$[esp+36], ebx
	mov	DWORD PTR __First$[esp+36], edx
	cmp	ecx, 2
	jne	$LL112@Buffered_m@3
$LN111@Buffered_m@3:

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp+36]
	mov	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR __First$[esp+36]
	cmp	edx, DWORD PTR [ecx+8]
	jge	$LN3@Buffered_m@3

; 2763 : 			std::iter_swap(_First, _Mid);

	push	eax
	push	ecx
	call	??$iter_swap@PAVCvHomelandUnit@@PAV1@@std@@YAXPAVCvHomelandUnit@@0@Z ; std::iter_swap<CvHomelandUnit *,CvHomelandUnit *>
	add	esp, 8

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN106@Buffered_m@3:

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR __Mid$[esp+36]
	mov	ebx, DWORD PTR __First$[esp+36]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebp, ebp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T252727[esp+56], esp
	push	edi
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T252728[esp+64]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	mov	eax, DWORD PTR $T252728[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebp
	je	SHORT $LN36@Buffered_m@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN36@Buffered_m@3:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	eax, DWORD PTR __Last$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T252798[esp+36], 0
	mov	ecx, DWORD PTR $T252798[esp+36]
	mov	edx, DWORD PTR $T252799[esp+36]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	mov	edx, DWORD PTR [esi]
	push	ebx
	push	eax
	push	edi
	push	ecx
	push	edx
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN107@Buffered_m@3:

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR __Last$[esp+36]
	mov	edi, DWORD PTR __Mid$[esp+36]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebp, ebp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T252729[esp+56], esp
	push	ebx
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T252730[esp+64]
	push	edi
	push	eax
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	mov	eax, DWORD PTR $T252730[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebp
	je	SHORT $LN60@Buffered_m@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN60@Buffered_m@3:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR $T252849[esp+36], 0
	mov	ecx, DWORD PTR $T252849[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+40]
	push	ebx
	push	edx
	push	eax
	push	edi
	push	ecx
	call	??$_Merge_backward@PAVCvHomelandUnit@@PAV1@PAV1@@std@@YAPAVCvHomelandUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvHomelandUnit *,CvHomelandUnit *,CvHomelandUnit *>
	add	esp, 24					; 00000018H
$LN3@Buffered_m@3:

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Buffered_merge@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ENDP ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap@2
	mov	ebx, 8
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	lea	esi, DWORD PTR [ecx-8]
	jle	SHORT $LN2@Sort_heap@2
$LN24@Sort_heap@2:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	sub	esp, 8
	mov	DWORD PTR [esi+4], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [ebx+esi-8]
	sar	ecx, 3
	push	ecx
	push	0
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN2@Sort_heap@2:
	sub	esi, 8
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 3
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap@2
$LN1@Sort_heap@2:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap@3
	mov	ebx, 8
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	lea	esi, DWORD PTR [ecx-8]
	jle	SHORT $LN2@Sort_heap@3
$LN24@Sort_heap@3:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	sub	esp, 8
	mov	DWORD PTR [esi+4], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [ebx+esi-8]
	sar	ecx, 3
	push	ecx
	push	0
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN2@Sort_heap@3:
	sub	esi, 8
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 3
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap@3
$LN1@Sort_heap@3:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z PROC ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 3156 : 	{	// sort median of three elements to middle

	push	ebx
	push	ebp

; 3157 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	ebp, DWORD PTR __Pred$[esp+4]
	push	esi
	mov	esi, DWORD PTR __Mid$[esp+8]
	push	edi
	mov	edi, DWORD PTR __First$[esp+12]
	push	edi
	push	esi
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN20@Med3@3

; 3158 : 		std::iter_swap(_Mid, _First);

	cmp	esi, edi
	je	SHORT $LN20@Med3@3
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [edi], eax
	lea	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN20@Med3@3
	mov	ebx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [eax], edx
$LN20@Med3@3:

; 3159 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

	mov	ebx, DWORD PTR __Last$[esp+12]
	push	esi
	push	ebx
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN37@Med3@3

; 3160 : 		std::iter_swap(_Last, _Mid);

	cmp	ebx, esi
	je	SHORT $LN37@Med3@3
	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [esi], eax
	lea	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [ebx+4]
	cmp	ecx, eax
	je	SHORT $LN37@Med3@3
	mov	ebx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [eax], edx
$LN37@Med3@3:

; 3161 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	push	edi
	push	esi
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN54@Med3@3

; 3162 : 		std::iter_swap(_Mid, _First);

	cmp	esi, edi
	je	SHORT $LN54@Med3@3
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [edi], eax
	lea	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN54@Med3@3
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
$LN54@Med3@3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3163 : 	}

	ret	0
??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ENDP ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvHomelandMove@@PAV1@H@stdext@@YAXPAVCvHomelandMove@@00HH@Z ; stdext::_Unchecked_chunked_merge<CvHomelandMove *,CvHomelandMove *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvHomelandMove@@PAV1@H@stdext@@YAXPAVCvHomelandMove@@00HH@Z
_TEXT	SEGMENT
$T253325 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
??$_Unchecked_chunked_merge@PAVCvHomelandMove@@PAV1@H@stdext@@YAXPAVCvHomelandMove@@00HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvHomelandMove *,CvHomelandMove *,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	mov	BYTE PTR $T253325[esp+4], 0
	mov	eax, DWORD PTR $T253325[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvHomelandMove@@PAV1@H@std@@YAXPAVCvHomelandMove@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandMove *,CvHomelandMove *,int>

; 5254 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_chunked_merge@PAVCvHomelandMove@@PAV1@H@stdext@@YAXPAVCvHomelandMove@@00HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvHomelandMove *,CvHomelandMove *,int>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@0V12@11@Z ; stdext::unchecked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@0V12@11@Z
_TEXT	SEGMENT
$T253329 = -4						; size = 1
$T253330 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
??$unchecked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@0V12@11@Z PROC ; stdext::unchecked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T253330[esp]
	mov	edx, DWORD PTR __Dest$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T253329[esp+8], 0
	mov	eax, DWORD PTR $T253329[esp+8]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+12]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+16]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+20]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@11Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
	mov	eax, esi
	pop	esi

; 5117 : 	}

	pop	ecx
	ret	0
??$unchecked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@0V12@11@Z ENDP ; stdext::unchecked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@0PAVCvHomelandTarget@@10@Z ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@0PAVCvHomelandTarget@@10@Z
_TEXT	SEGMENT
$T253338 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
??$_Unchecked_merge_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@0PAVCvHomelandTarget@@10@Z PROC ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 5202 : 	{

	push	ecx

; 5203 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	edx, DWORD PTR __Last2$[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T253338[esp+8], 0
	mov	eax, DWORD PTR $T253338[esp+8]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Merge_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@V12@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0PAVCvHomelandTarget@@10U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 5204 : 	}

	pop	ecx
	ret	0
??$_Unchecked_merge_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@V12@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@0PAVCvHomelandTarget@@10@Z ENDP ; stdext::_Unchecked_merge_backward<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@PAV1@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@00HHP6A_NV1@1@Z@Z ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@PAV1@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@00HHP6A_NV1@1@Z@Z
_TEXT	SEGMENT
$T253342 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 4
??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@PAV1@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@00HHP6A_NV1@1@Z@Z PROC ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 5285 : 	{

	push	ecx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp]
	mov	edx, DWORD PTR __Count$[esp]
	mov	BYTE PTR $T253342[esp+4], 0
	mov	eax, DWORD PTR $T253342[esp+4]
	push	eax
	mov	eax, DWORD PTR __Chunk$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>

; 5287 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@PAV1@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@00HHP6A_NV1@1@Z@Z ENDP ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@PAV1@H@stdext@@YAXPAVCvHomelandUnit@@00HH@Z ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@PAV1@H@stdext@@YAXPAVCvHomelandUnit@@00HH@Z
_TEXT	SEGMENT
$T253346 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@PAV1@H@stdext@@YAXPAVCvHomelandUnit@@00HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	mov	BYTE PTR $T253346[esp+4], 0
	mov	eax, DWORD PTR $T253346[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@H@std@@YAXPAVCvHomelandUnit@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int>

; 5254 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@PAV1@H@stdext@@YAXPAVCvHomelandUnit@@00HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T253350 = -24						; size = 4
$T253355 = -20						; size = 20
$T253353 = -20						; size = 20
$T253351 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T253352 = 40						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	esi, DWORD PTR __First$[esp+32]
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+36]
	lea	ebp, DWORD PTR [edi+edi]
	xor	ebx, ebx
	cmp	ebp, DWORD PTR __Count$[esp+36]
	jg	SHORT $LN3@Chunked_me@4
	lea	edi, DWORD PTR [edi+edi*4]
	add	edi, edi
	add	edi, edi
$LL5@Chunked_me@4:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [edi+esi]
	mov	DWORD PTR $T253350[esp+60], esp
	lea	esi, DWORD PTR [edi+ecx]
	push	esi
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+76]
	push	ecx
	push	ecx
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __First$[esp+68]
	push	eax
	lea	ecx, DWORD PTR $T253351[esp+76]
	push	ecx
	call	??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T253351[esp+80]
	add	esp, 40					; 00000028H
	mov	DWORD PTR __Dest$[esp+52], edx
	cmp	eax, ebx
	je	SHORT $LN49@Chunked_me@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@Chunked_me@4:
	mov	eax, DWORD PTR __Count$[esp+36]
	sub	eax, ebp
	cmp	eax, ebp

; 3297 : 		_First = _Mid2;

	mov	DWORD PTR __First$[esp+36], esi
	mov	DWORD PTR __Count$[esp+36], eax
	jge	SHORT $LL5@Chunked_me@4

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	edi, DWORD PTR __Chunk$[esp+36]
$LN3@Chunked_me@4:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)
; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	cmp	DWORD PTR __Count$[esp+56], edi
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR $T253352[esp+56], esp
	jg	SHORT $LN2@Chunked_me@4
	mov	ecx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+56]
	mov	eax, DWORD PTR __First$[esp+56]
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T253353[esp+68]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	add	esp, 32					; 00000020H

; 3302 : 	else

	jmp	SHORT $LN111@Chunked_me@4
$LN2@Chunked_me@4:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);

	lea	edx, DWORD PTR [edi+edi*4]
	lea	ecx, DWORD PTR [esi+edx*4]

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	edx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+68]
	push	ecx
	lea	edx, DWORD PTR $T253355[esp+76]
	push	edx
	call	??$unchecked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@000V12@@Z ; stdext::unchecked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	add	esp, 40					; 00000028H
$LN111@Chunked_me@4:
	mov	eax, DWORD PTR $T253355[esp+40]
	cmp	eax, ebx
	je	SHORT $LN87@Chunked_me@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN87@Chunked_me@4:

; 3308 : 		}
; 3309 : 	}

	mov	eax, DWORD PTR __Dest$[esp+36]
	cmp	eax, ebx
	je	SHORT $LN97@Chunked_me@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN97@Chunked_me@4:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXPAVCvHomelandTarget@@0V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXPAVCvHomelandTarget@@0V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T253630 = -8						; size = 1
$T253585 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
$T253691 = 24						; size = 1
$T253692 = 24						; size = 1
$T253655 = 24						; size = 1
__Cat$253660 = 24					; size = 1
$T253657 = 24						; size = 1
$T253631 = 24						; size = 1
$T253587 = 24						; size = 4
$T253586 = 24						; size = 4
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXPAVCvHomelandTarget@@0V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>, COMDAT

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebp
	mov	ebp, DWORD PTR __Chunk$[esp+8]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp+ebp]
	cmp	edi, eax
	jg	SHORT $LN3@Chunked_me@5
	lea	ebp, DWORD PTR [ebp+ebp*4]
	add	ebp, ebp
	add	ebp, ebp
	push	ebx
	npad	9
$LL43@Chunked_me@5:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	BYTE PTR $T253630[esp+24], 0
	mov	ebx, DWORD PTR $T253630[esp+24]
	push	ebx
	mov	ebx, DWORD PTR $T253631[esp+24]
	push	ebx
	lea	eax, DWORD PTR [ecx+ebp]
	push	edx
	lea	esi, DWORD PTR [eax+ebp]
	push	esi
	push	eax
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T253585[esp+52]
	push	eax
	call	??$_Merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	mov	eax, DWORD PTR __Count$[esp+52]
	mov	edx, DWORD PTR $T253585[esp+56]
	sub	eax, edi
	add	esp, 32					; 00000020H
	cmp	eax, edi

; 3297 : 		_First = _Mid2;

	mov	ecx, esi
	mov	DWORD PTR __Count$[esp+20], eax
	jge	SHORT $LL43@Chunked_me@5
	mov	ebp, DWORD PTR __Chunk$[esp+20]
	pop	ebx
$LN3@Chunked_me@5:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	cmp	eax, ebp

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	BYTE PTR $T253655[esp+16], 0
	jg	SHORT $LN2@Chunked_me@5
	mov	eax, DWORD PTR $T253655[esp+16]
	push	eax
	mov	eax, DWORD PTR __Cat$253660[esp+20]
	push	eax
	mov	eax, DWORD PTR $T253657[esp+24]
	push	eax
	push	edx
	mov	edx, DWORD PTR __Last$[esp+32]
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T253586[esp+40]
	push	eax
	call	??$_Copy_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	add	esp, 8
	ret	0
$LN2@Chunked_me@5:

; 3302 : 	else
; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);
; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	esi, DWORD PTR $T253691[esp+16]
	push	esi
	mov	esi, DWORD PTR $T253692[esp+20]
	push	esi
	push	edx
	mov	edx, DWORD PTR __Last$[esp+28]
	push	edx
	lea	eax, DWORD PTR [ebp+ebp*4]
	lea	eax, DWORD PTR [ecx+eax*4]
	push	eax
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T253587[esp+44]
	push	eax
	call	??$_Merge@PAVCvHomelandTarget@@PAV1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@000V10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandTarget *,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	add	esp, 8
	ret	0
??$_Chunked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXPAVCvHomelandTarget@@0V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
_TEXT	ENDS
PUBLIC	??$rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00@Z ; std::rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00@Z PROC ; std::rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN14@rotate@3
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN14@rotate@3

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00PAHPAVCvHomelandTarget@@@Z ; std::_Rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 20					; 00000014H
$LN14@rotate@3:

; 1721 : 	}

	ret	0
??$rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00@Z ENDP ; std::rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z ; stdext::unchecked_merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z
_TEXT	SEGMENT
$T253749 = -4						; size = 1
$T253755 = -4						; size = 4
$T253751 = -4						; size = 4
$T253750 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z PROC ; stdext::unchecked_merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T253755[esp+8], ebx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T253750[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T253749[esp+12], bl
	mov	eax, DWORD PTR $T253749[esp+12]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+36]
	mov	edx, DWORD PTR __Last1$[esp+36]
	mov	DWORD PTR $T253751[esp+40], esp
	push	eax
	mov	eax, DWORD PTR __First1$[esp+40]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@0@PAVCvHomelandMove@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+56]
	add	esp, 48					; 00000030H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@18
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@18:
	mov	eax, esi

; 5117 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z ENDP ; stdext::unchecked_merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z$0
__ehfuncinfo$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z
_TEXT	SEGMENT
$T253795 = -16						; size = 1
$T253801 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
$T253796 = 48						; size = 1
$T253797 = 48						; size = 4
__Pred$ = 48						; size = 4
??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z PROC ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	-1
	push	__ehhandler$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T253801[esp+24], ebx

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T253796[esp+20]
	mov	edx, DWORD PTR __Pred$[esp+20]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+20]
	mov	BYTE PTR $T253795[esp+24], bl
	mov	eax, DWORD PTR $T253795[esp+24]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last2$[esp+32]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+68]
	mov	DWORD PTR $T253797[esp+52], esp
	push	edx
	mov	edx, DWORD PTR __First1$[esp+56]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First2$[esp+56]
	mov	ecx, DWORD PTR __Last1$[esp+56]
	push	eax
	push	ecx
	push	edx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+84], ebx
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@ZUforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@P6A_NV2@2@ZUforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+72]
	add	esp, 52					; 00000034H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@19
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@19:

; 5160 : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp-4]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z:
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z ENDP ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
PUBLIC	??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z
_TEXT	SEGMENT
$T253847 = -4						; size = 1
$T253853 = -4						; size = 4
$T253849 = -4						; size = 4
$T253848 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z PROC ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T253853[esp+8], ebx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T253848[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T253847[esp+12], bl
	mov	eax, DWORD PTR $T253847[esp+12]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+36]
	mov	edx, DWORD PTR __Last1$[esp+36]
	mov	DWORD PTR $T253849[esp+40], esp
	push	eax
	mov	eax, DWORD PTR __First1$[esp+40]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@0@PAVCvHomelandUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+56]
	add	esp, 48					; 00000030H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@20
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@20:
	mov	eax, esi

; 5117 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z ENDP ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
_TEXT	ENDS
PUBLIC	?RecruitUnits@CvHomelandAI@@QAEXXZ		; CvHomelandAI::RecruitUnits
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?canMove@CvUnit@@QBE_NXZ:PROC			; CvUnit::canMove
EXTRN	?isDelayedDeath@CvUnit@@QBE_NXZ:PROC		; CvUnit::isDelayedDeath
EXTRN	?TurnProcessed@CvUnit@@QBE_NXZ:PROC		; CvUnit::TurnProcessed
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
;	COMDAT ?RecruitUnits@CvHomelandAI@@QAEXXZ
_TEXT	SEGMENT
$T253893 = -8						; size = 4
_iLoop$ = -4						; size = 4
?RecruitUnits@CvHomelandAI@@QAEXXZ PROC			; CvHomelandAI::RecruitUnits, COMDAT
; _this$ = ecx

; 106  : {

	sub	esp, 8
	push	ebp
	mov	ebp, ecx

; 107  : 	CvUnit* pLoopUnit;
; 108  : 	int iLoop;
; 109  : 
; 110  : 	m_CurrentTurnUnits.clear();

	mov	ecx, DWORD PTR [ebp+8]
	mov	eax, DWORD PTR [ecx]
	push	esi
	lea	esi, DWORD PTR [ebp+4]
	mov	DWORD PTR [ecx], ecx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ecx
	push	edi
	mov	DWORD PTR [esi+8], 0
	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN7@RecruitUni
$LL9@RecruitUni:
	mov	edi, DWORD PTR [eax]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, edi
	cmp	edi, DWORD PTR [esi+4]
	jne	SHORT $LL9@RecruitUni
$LN7@RecruitUni:

; 111  : 
; 112  : 	// Loop through our units
; 113  : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	mov	ecx, DWORD PTR [ebp]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+24]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN2@RecruitUni
	push	ebx
	npad	4
$LL4@RecruitUni:

; 114  : 	{
; 115  : 		// Never want immobile/dead units or ones that have already moved
; 116  : 		if(!pLoopUnit->TurnProcessed() && !pLoopUnit->isDelayedDeath() && pLoopUnit->AI_getUnitAIType() != UNITAI_UNKNOWN && pLoopUnit->canMove())

	mov	ecx, edi
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	SHORT $LN3@RecruitUni
	mov	ecx, edi
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	test	al, al
	jne	SHORT $LN3@RecruitUni
	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	test	eax, eax
	je	SHORT $LN3@RecruitUni
	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	SHORT $LN3@RecruitUni

; 117  : 		{
; 118  : 			m_CurrentTurnUnits.push_back(pLoopUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]
	mov	edi, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR $T253893[esp+24]
	push	edx
	push	eax
	mov	DWORD PTR $T253893[esp+32], ecx
	push	edi
	mov	ecx, esi
	call	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z ; std::list<int,std::allocator<int> >::_Buynode
	push	1
	mov	ecx, esi
	mov	ebx, eax
	call	?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::list<int,std::allocator<int> >::_Incsize
	mov	DWORD PTR [edi+4], ebx
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [ecx], ebx
$LN3@RecruitUni:
	mov	ecx, DWORD PTR [ebp]
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+28]
	push	edx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL4@RecruitUni
	pop	ebx
$LN2@RecruitUni:
	pop	edi
	pop	esi
	pop	ebp

; 119  : 		}
; 120  : 	}
; 121  : }

	add	esp, 8
	ret	0
?RecruitUnits@CvHomelandAI@@QAEXXZ ENDP			; CvHomelandAI::RecruitUnits
_TEXT	ENDS
PUBLIC	?FindAutomatedUnits@CvHomelandAI@@QAEXXZ	; CvHomelandAI::FindAutomatedUnits
EXTRN	?IsAutomated@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsAutomated
; Function compile flags: /Ogtpy
;	COMDAT ?FindAutomatedUnits@CvHomelandAI@@QAEXXZ
_TEXT	SEGMENT
$T254022 = -8						; size = 4
_iLoop$ = -4						; size = 4
?FindAutomatedUnits@CvHomelandAI@@QAEXXZ PROC		; CvHomelandAI::FindAutomatedUnits, COMDAT
; _this$ = ecx

; 125  : {

	sub	esp, 8
	push	ebp
	mov	ebp, ecx

; 126  : 	CvUnit* pLoopUnit;
; 127  : 	int iLoop;
; 128  : 
; 129  : 	m_CurrentTurnUnits.clear();

	mov	ecx, DWORD PTR [ebp+8]
	mov	eax, DWORD PTR [ecx]
	push	esi
	lea	esi, DWORD PTR [ebp+4]
	mov	DWORD PTR [ecx], ecx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ecx
	push	edi
	mov	DWORD PTR [esi+8], 0
	cmp	eax, DWORD PTR [esi+4]
	je	SHORT $LN7@FindAutoma
$LL9@FindAutoma:
	mov	edi, DWORD PTR [eax]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, edi
	cmp	edi, DWORD PTR [esi+4]
	jne	SHORT $LL9@FindAutoma
$LN7@FindAutoma:

; 130  : 
; 131  : 	// Loop through our units
; 132  : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	mov	ecx, DWORD PTR [ebp]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+24]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN2@FindAutoma
	push	ebx
	npad	4
$LL4@FindAutoma:

; 133  : 	{
; 134  : 		if(pLoopUnit->IsAutomated() && !pLoopUnit->TurnProcessed() && pLoopUnit->AI_getUnitAIType() != UNITAI_UNKNOWN && pLoopUnit->canMove())

	mov	ecx, edi
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	test	al, al
	je	SHORT $LN3@FindAutoma
	mov	ecx, edi
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	SHORT $LN3@FindAutoma
	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	test	eax, eax
	je	SHORT $LN3@FindAutoma
	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	SHORT $LN3@FindAutoma

; 135  : 		{
; 136  : 			m_CurrentTurnUnits.push_back(pLoopUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]
	mov	edi, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR $T254022[esp+24]
	push	edx
	push	eax
	mov	DWORD PTR $T254022[esp+32], ecx
	push	edi
	mov	ecx, esi
	call	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@PAU342@0ABH@Z ; std::list<int,std::allocator<int> >::_Buynode
	push	1
	mov	ecx, esi
	mov	ebx, eax
	call	?_Incsize@?$list@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::list<int,std::allocator<int> >::_Incsize
	mov	DWORD PTR [edi+4], ebx
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [ecx], ebx
$LN3@FindAutoma:
	mov	ecx, DWORD PTR [ebp]
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+28]
	push	edx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL4@FindAutoma
	pop	ebx
$LN2@FindAutoma:
	pop	edi
	pop	esi
	pop	ebp

; 137  : 		}
; 138  : 	}
; 139  : }

	add	esp, 8
	ret	0
?FindAutomatedUnits@CvHomelandAI@@QAEXXZ ENDP		; CvHomelandAI::FindAutomatedUnits
_TEXT	ENDS
PUBLIC	?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotWorkerSeaMoves
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?UnitPathTo@CvUnit@@QAEHHHHH_N@Z:PROC		; CvUnit::UnitPathTo
EXTRN	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z:PROC ; CvUnit::canBuild
EXTRN	?GetAutomateType@CvUnit@@QBE?AW4AutomateTypes@@XZ:PROC ; CvUnit::GetAutomateType
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$4
__ehfuncinfo$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
$T254545 = -101						; size = 1
_bResult$225750 = -101					; size = 1
tv1250 = -100						; size = 4
_iTargetY$225748 = -100					; size = 4
tv1211 = -96						; size = 4
_iI$225736 = -96					; size = 4
_it$225717 = -96					; size = 4
tv1253 = -92						; size = 4
_iTargetX$225747 = -92					; size = 4
$T254152 = -92						; size = 4
_iTargetMoves$225735 = -88				; size = 4
$T254685 = -84						; size = 4
$T254669 = -84						; size = 4
_iTargetIndex$225734 = -84				; size = 4
_moveUnitIt$ = -80					; size = 4
_pUnit$225733 = -76					; size = 8
_pUnit$225723 = -76					; size = 8
_strLogString$225758 = -68				; size = 28
_unit$225727 = -68					; size = 16
_strLogString$225762 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotWorkerSeaMoves, COMDAT
; _this$ = ecx

; 1264 : {

	push	-1
	push	__ehhandler$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1265 : 	ClearCurrentMoveUnits();

	xor	ebp, ebp
	mov	DWORD PTR [esi+20], ebp

; 1266 : 	// Loop through all recruited units
; 1267 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+2396], ebp
	mov	DWORD PTR [esi+2400], 2147483647	; 7fffffffH
	mov	ebx, DWORD PTR [eax]
	push	edi
	mov	DWORD PTR _it$225717[esp+120], ebx
	cmp	ebx, eax
	je	$LN22@PlotWorker
	jmp	SHORT $LN52@PlotWorker
$LL315@PlotWorker:
	mov	ebx, DWORD PTR _it$225717[esp+120]
$LN52@PlotWorker:

; 1268 : 	{
; 1269 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$225723[esp+120], edi
	mov	BYTE PTR _pUnit$225723[esp+124], 0
	cmp	edi, ebp
	je	SHORT $LN75@PlotWorker
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN75@PlotWorker:
	mov	DWORD PTR __$EHRec$[esp+128], ebp

; 1270 : 		if(pUnit)

	cmp	edi, ebp
	je	SHORT $LN98@PlotWorker

; 1271 : 		{
; 1272 : 			if(pUnit->AI_getUnitAIType() == UNITAI_WORKER_SEA  ||
; 1273 : #ifdef AUI_WARNING_FIXES
; 1274 : 				(pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_SEA && pUnit->GetAutomateType() == AUTOMATE_BUILD))
; 1275 : #else
; 1276 : 			   pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_SEA && pUnit->GetAutomateType() == AUTOMATE_BUILD)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 17					; 00000011H
	je	SHORT $LN19@PlotWorker
	mov	ecx, edi
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	test	al, al
	je	SHORT $LN98@PlotWorker
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN98@PlotWorker
	mov	ecx, edi
	call	?GetAutomateType@CvUnit@@QBE?AW4AutomateTypes@@XZ ; CvUnit::GetAutomateType
	test	eax, eax
	jne	SHORT $LN98@PlotWorker
$LN19@PlotWorker:

; 1277 : #endif
; 1278 : 			{
; 1279 : 				CvHomelandUnit unit;
; 1280 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 1281 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+24]
	lea	ebp, DWORD PTR [esi+16]
	xor	ebx, ebx
	mov	DWORD PTR _unit$225727[esp+120], ecx
	mov	BYTE PTR [ebp+1036], bl
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN97@PlotWorker
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN97@PlotWorker:
	mov	eax, DWORD PTR [ebp+4]
	shl	eax, 4
	add	eax, DWORD PTR [ebp]
	je	SHORT $LN100@PlotWorker
	mov	edx, DWORD PTR _unit$225727[esp+120]
	mov	DWORD PTR [eax], edx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
$LN100@PlotWorker:
	inc	DWORD PTR [ebp+4]
	mov	ebx, DWORD PTR _it$225717[esp+120]
	xor	ebp, ebp
$LN98@PlotWorker:

; 1282 : 			}
; 1283 : 		}
; 1284 : 	}

	mov	DWORD PTR __$EHRec$[esp+128], -1
	cmp	edi, ebp
	je	SHORT $LN23@PlotWorker
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN23@PlotWorker:
	mov	ebx, DWORD PTR [ebx]
	mov	DWORD PTR _it$225717[esp+120], ebx
	cmp	ebx, DWORD PTR [esi+8]
	jne	$LL315@PlotWorker
$LN22@PlotWorker:

; 1285 : 
; 1286 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator moveUnitIt;
; 1287 : 	for(moveUnitIt = m_CurrentMoveUnits.begin(); moveUnitIt != m_CurrentMoveUnits.end(); ++moveUnitIt)

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+20]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _moveUnitIt$[esp+120], eax
	cmp	eax, ecx
	je	$LN16@PlotWorker
$LL18@PlotWorker:

; 1288 : 	{
; 1289 : 		UnitHandle pUnit = m_pPlayer->getUnit(moveUnitIt->GetID());

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebp, eax
	xor	edi, edi
	mov	DWORD PTR _pUnit$225733[esp+120], ebp
	mov	BYTE PTR _pUnit$225733[esp+124], 0
	cmp	ebp, edi
	je	SHORT $LN118@PlotWorker
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN118@PlotWorker:

; 1290 : 		int iTargetIndex = -1;
; 1291 : 		int iTargetMoves = MAX_INT;
; 1292 : 
; 1293 : 		// See how many moves of this type we can execute
; 1294 : 		for (unsigned int iI = 0; iI < m_TargetedNavalResources.size(); iI++)

	mov	ecx, DWORD PTR [esi+2468]
	sub	ecx, DWORD PTR [esi+2464]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __$EHRec$[esp+128], 1
	mov	DWORD PTR _iTargetIndex$225734[esp+120], -1
	mov	DWORD PTR _iTargetMoves$225735[esp+120], 2147483647 ; 7fffffffH
	mov	DWORD PTR _iI$225736[esp+120], edi
	je	$LN1@PlotWorker

; 1288 : 	{
; 1289 : 		UnitHandle pUnit = m_pPlayer->getUnit(moveUnitIt->GetID());

	mov	DWORD PTR tv1250[esp+120], edi
$LN15@PlotWorker:

; 1295 : 		{
; 1296 : 			// See what units we have who can reach target this turn
; 1297 : 			CvPlot* pTarget = GC.getMap().plot(m_TargetedNavalResources[iI].GetTargetX(), m_TargetedNavalResources[iI].GetTargetY());

	mov	ecx, DWORD PTR [esi+2464]
	mov	edx, DWORD PTR tv1250[esp+120]
	mov	eax, DWORD PTR [ecx+edx+4]
	mov	ebx, DWORD PTR [ecx+edx+8]
	add	ecx, edx
	mov	DWORD PTR tv1253[esp+120], ecx
	cmp	eax, -2147483647			; 80000001H
	je	$LN132@PlotWorker
	cmp	ebx, -2147483647			; 80000001H
	je	$LN132@PlotWorker
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN142@PlotWorker
	test	eax, eax
	jge	SHORT $LN144@PlotWorker
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN146@PlotWorker
$LN144@PlotWorker:
	cmp	eax, ecx
	jl	SHORT $LN142@PlotWorker
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN146@PlotWorker
$LN142@PlotWorker:
	mov	edi, eax
$LN146@PlotWorker:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebp, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN152@PlotWorker
	test	ebx, ebx
	jge	SHORT $LN154@PlotWorker
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN156@PlotWorker
$LN154@PlotWorker:
	cmp	ebx, ebp
	jl	SHORT $LN152@PlotWorker
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN156@PlotWorker
$LN152@PlotWorker:
	mov	edx, ebx
$LN156@PlotWorker:
	test	edi, edi
	jl	SHORT $LN136@PlotWorker
	cmp	edi, ecx
	jge	SHORT $LN136@PlotWorker
	test	edx, edx
	jl	SHORT $LN136@PlotWorker
	cmp	edx, ebp
	jge	SHORT $LN136@PlotWorker
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	mov	ebp, DWORD PTR _pUnit$225733[esp+120]
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	mov	edi, ecx
	mov	ecx, DWORD PTR tv1253[esp+120]
	jmp	SHORT $LN134@PlotWorker
$LN136@PlotWorker:
	mov	ebp, DWORD PTR _pUnit$225733[esp+120]
	mov	ecx, DWORD PTR tv1253[esp+120]
$LN132@PlotWorker:
	xor	edi, edi
$LN134@PlotWorker:

; 1298 : 
; 1299 : 			if (!pUnit->canBuild(pTarget, (BuildTypes)m_TargetedNavalResources[iI].GetAuxIntData()))

	mov	eax, DWORD PTR [ecx+16]
	push	1
	push	0
	push	eax
	push	edi
	mov	ecx, ebp
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	test	al, al
	je	SHORT $LN14@PlotWorker

; 1300 : 			{
; 1301 : 				continue;
; 1302 : 			}
; 1303 : 
; 1304 : 			int iMoves = TurnsToReachTarget(pUnit.pointer(), pTarget);

	push	0
	push	0
	push	0
	push	edi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T254152[esp+144], esp
	mov	DWORD PTR [eax], ebp
	mov	BYTE PTR [eax+4], 0
	test	ebp, ebp
	je	SHORT $LN181@PlotWorker
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN181@PlotWorker:
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 1305 : 			if (iMoves < iTargetMoves)

	cmp	eax, DWORD PTR _iTargetMoves$225735[esp+120]
	jge	SHORT $LN14@PlotWorker

; 1306 : 			{
; 1307 : 				iTargetMoves = iMoves;
; 1308 : 				iTargetIndex = iI;

	mov	ecx, DWORD PTR _iI$225736[esp+120]
	mov	DWORD PTR _iTargetMoves$225735[esp+120], eax
	mov	DWORD PTR _iTargetIndex$225734[esp+120], ecx
$LN14@PlotWorker:
	mov	ecx, DWORD PTR [esi+2468]
	sub	ecx, DWORD PTR [esi+2464]
	mov	edi, DWORD PTR _iI$225736[esp+120]
	add	DWORD PTR tv1250[esp+120], 20		; 00000014H
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	edi
	add	eax, edx
	mov	DWORD PTR _iI$225736[esp+120], edi
	cmp	edi, eax
	jb	$LN15@PlotWorker

; 1309 : 			}
; 1310 : 		}
; 1311 : 
; 1312 : 		if (iTargetIndex != -1)

	mov	eax, DWORD PTR _iTargetIndex$225734[esp+120]
	cmp	eax, -1
	je	$LN1@PlotWorker

; 1313 : 		{
; 1314 : 			// Queue best one up to capture it
; 1315 : 			int iTargetX = m_TargetedNavalResources[iTargetIndex].GetTargetX();

	mov	ecx, DWORD PTR [esi+2464]
	lea	ebp, DWORD PTR [eax+eax*4]
	add	ebp, ebp
	add	ebp, ebp
	mov	ebx, DWORD PTR [ecx+ebp+4]
	lea	eax, DWORD PTR [ecx+ebp]

; 1316 : 			int iTargetY = m_TargetedNavalResources[iTargetIndex].GetTargetY();

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _iTargetX$225747[esp+120], ebx
	mov	DWORD PTR _iTargetY$225748[esp+120], eax

; 1317 : 			CvPlot* pTarget = GC.getMap().plot(iTargetX, iTargetY);

	cmp	ebx, -2147483647			; 80000001H
	je	$LN193@PlotWorker
	cmp	eax, -2147483647			; 80000001H
	je	$LN193@PlotWorker
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN203@PlotWorker
	test	ebx, ebx
	jge	SHORT $LN205@PlotWorker
	mov	eax, ebx
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _iTargetY$225748[esp+120]
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN207@PlotWorker
$LN205@PlotWorker:
	cmp	ebx, ecx
	jl	SHORT $LN203@PlotWorker
	mov	eax, ebx
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _iTargetY$225748[esp+120]
	mov	edi, edx
	jmp	SHORT $LN207@PlotWorker
$LN203@PlotWorker:
	mov	edi, ebx
$LN207@PlotWorker:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [edx+4057]
	mov	BYTE PTR $T254545[esp+120], dl
	cmp	BYTE PTR $T254545[esp+120], 0
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	edx, DWORD PTR [edx+4024]
	mov	DWORD PTR tv1211[esp+120], edx
	je	SHORT $LN213@PlotWorker
	test	eax, eax
	jge	SHORT $LN215@PlotWorker
	mov	ebx, DWORD PTR tv1211[esp+120]
	cdq
	idiv	ebx
	mov	eax, DWORD PTR _iTargetY$225748[esp+120]
	add	edx, ebx
	mov	ebx, DWORD PTR _iTargetX$225747[esp+120]
	jmp	SHORT $LN217@PlotWorker
$LN215@PlotWorker:
	cmp	eax, edx
	jl	SHORT $LN213@PlotWorker
	mov	ebx, DWORD PTR _iTargetX$225747[esp+120]
	cdq
	idiv	DWORD PTR tv1211[esp+120]
	mov	eax, DWORD PTR _iTargetY$225748[esp+120]
	jmp	SHORT $LN217@PlotWorker
$LN213@PlotWorker:
	mov	edx, eax
$LN217@PlotWorker:
	test	edi, edi
	jl	SHORT $LN193@PlotWorker
	cmp	edi, ecx
	jge	SHORT $LN193@PlotWorker
	test	edx, edx
	jl	SHORT $LN193@PlotWorker
	cmp	edx, DWORD PTR tv1211[esp+120]
	jge	SHORT $LN314@PlotWorker
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	mov	eax, DWORD PTR _iTargetY$225748[esp+120]
	mov	edi, ecx
	jmp	SHORT $LN195@PlotWorker
$LN314@PlotWorker:
	mov	eax, DWORD PTR _iTargetY$225748[esp+120]
$LN193@PlotWorker:
	xor	edi, edi
$LN195@PlotWorker:

; 1318 : 
; 1319 : 			bool bResult = false;
; 1320 : 			if(pUnit->UnitPathTo(iTargetX, iTargetY, 0) > 0)

	push	0
	push	-1
	push	0
	push	eax
	push	ebx
	mov	ebx, DWORD PTR _pUnit$225733[esp+140]
	mov	ecx, ebx
	mov	BYTE PTR _bResult$225750[esp+140], 0
	call	?UnitPathTo@CvUnit@@QAEHHHHH_N@Z	; CvUnit::UnitPathTo
	test	eax, eax
	jle	$LN9@PlotWorker

; 1321 : 			{
; 1322 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), iTargetX, iTargetY);

	mov	ecx, DWORD PTR _iTargetY$225748[esp+120]
	mov	edx, DWORD PTR _iTargetX$225747[esp+120]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	ecx
	push	edx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, ebx
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 1323 : 				if(pUnit->plot() == pTarget)

	mov	ecx, ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, edi
	jne	SHORT $LN8@PlotWorker

; 1324 : 				{
; 1325 : 					pUnit->PushMission(CvTypes::getMISSION_BUILD(), m_TargetedNavalResources[iTargetIndex].GetAuxIntData(), -1, 0, (pUnit->GetLengthMissionQueue() > 0), false, MISSIONAI_BUILD, pTarget);

	mov	eax, DWORD PTR [esi+2464]
	mov	ebx, DWORD PTR [eax+ebp+16]
	push	0
	push	edi
	mov	edi, DWORD PTR _pUnit$225733[esp+128]
	push	18					; 00000012H
	add	eax, ebp
	push	0
	mov	ecx, edi
	call	?GetLengthMissionQueue@CvUnit@@QBEHXZ	; CvUnit::GetLengthMissionQueue
	test	eax, eax
	setg	al
	movzx	ecx, al
	push	ecx
	push	0
	push	-1
	push	ebx
	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 1326 : 					bResult = true;

	mov	bl, 1

; 1327 : 				}
; 1328 : 				else

	jmp	SHORT $LN7@PlotWorker
$LN8@PlotWorker:

; 1329 : 				{
; 1330 : 					pUnit->finishMoves();

	mov	ecx, ebx
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
	mov	bl, BYTE PTR _bResult$225750[esp+120]
$LN7@PlotWorker:

; 1331 : 				}
; 1332 : 
; 1333 : 				// Delete this unit from those we have to move
; 1334 : 				UnitProcessed(m_CurrentMoveUnits.begin()->GetID());

	mov	eax, DWORD PTR [esi+16]
	mov	edi, DWORD PTR [eax]
	lea	edx, DWORD PTR $T254669[esp+120]
	push	edx
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR $T254669[esp+124], edi
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN5@PlotWorker
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN5@PlotWorker:

; 1341 : 					bResult = true;
; 1342 : 				}
; 1343 : 			}
; 1344 : 		
; 1345 : 			if (bResult)

	test	bl, bl
	je	$LN4@PlotWorker
$LN305@PlotWorker:

; 1346 : 			{
; 1347 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN310@PlotWorker
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN310@PlotWorker

; 1348 : 				{
; 1349 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225758[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1350 : 					strLogString.Format("Harvesting naval resource at, X: %d, Y: %d", m_TargetedNavalResources[iTargetIndex].GetTargetX(), m_TargetedNavalResources[iTargetIndex].GetTargetY());

	mov	ecx, DWORD PTR [esi+2464]
	lea	eax, DWORD PTR [ecx+ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	push	ecx
	push	eax
	lea	edx, DWORD PTR _strLogString$225758[esp+128]
	push	OFFSET $SG225759
	push	edx
	mov	BYTE PTR __$EHRec$[esp+144], 2
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1351 : 					LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$225758[esp+120]
	push	eax
	mov	ecx, esi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1352 : 				}

	lea	ecx, DWORD PTR _strLogString$225758[esp+120]

; 1353 : 			}
; 1354 : 			else

	jmp	$LN317@PlotWorker
$LN9@PlotWorker:

; 1335 : 			}
; 1336 : 			else
; 1337 : 			{
; 1338 : 				if(pUnit->plot() == pTarget)

	mov	ecx, ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, edi
	jne	SHORT $LN4@PlotWorker

; 1339 : 				{
; 1340 : 					pUnit->PushMission(CvTypes::getMISSION_BUILD(), m_TargetedNavalResources[iTargetIndex].GetAuxIntData(), -1, 0, (pUnit->GetLengthMissionQueue() > 0), false, MISSIONAI_BUILD, pTarget);

	mov	eax, DWORD PTR [esi+2464]
	push	0
	push	edi
	add	eax, ebp
	mov	eax, DWORD PTR [eax+16]
	push	18					; 00000012H
	push	0
	mov	ecx, ebx
	mov	DWORD PTR $T254685[esp+136], eax
	call	?GetLengthMissionQueue@CvUnit@@QBEHXZ	; CvUnit::GetLengthMissionQueue
	test	eax, eax
	mov	eax, DWORD PTR $T254685[esp+136]
	setg	cl
	movzx	edx, cl
	push	edx
	push	0
	push	-1
	push	eax
	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	push	eax
	mov	ecx, ebx
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 1341 : 					bResult = true;
; 1342 : 				}
; 1343 : 			}
; 1344 : 		
; 1345 : 			if (bResult)

	jmp	$LN305@PlotWorker
$LN4@PlotWorker:

; 1355 : 			{
; 1356 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN310@PlotWorker
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN310@PlotWorker

; 1357 : 				{
; 1358 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225762[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1359 : 					strLogString.Format("Moving toward naval resource at, X: %d, Y: %d", m_TargetedNavalResources[iTargetIndex].GetTargetX(), m_TargetedNavalResources[iTargetIndex].GetTargetY());

	mov	ecx, DWORD PTR [esi+2464]
	lea	eax, DWORD PTR [ecx+ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	push	ecx
	push	eax
	lea	edx, DWORD PTR _strLogString$225762[esp+128]
	push	OFFSET $SG225763
	push	edx
	mov	BYTE PTR __$EHRec$[esp+144], 3
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1360 : 					LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$225762[esp+120]
	push	eax
	mov	ecx, esi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1361 : 				}

	lea	ecx, DWORD PTR _strLogString$225762[esp+120]
$LN317@PlotWorker:
	mov	BYTE PTR __$EHRec$[esp+128], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN310@PlotWorker:

; 1353 : 			}
; 1354 : 			else

	mov	ebp, DWORD PTR _pUnit$225733[esp+120]
$LN1@PlotWorker:

; 1362 : 			}
; 1363 : 		}
; 1364 : 	}

	mov	DWORD PTR __$EHRec$[esp+128], -1
	test	ebp, ebp
	je	SHORT $LN17@PlotWorker
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN17@PlotWorker:
	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR _moveUnitIt$[esp+120]
	shl	ecx, 4
	add	ecx, DWORD PTR [esi+16]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _moveUnitIt$[esp+120], eax
	cmp	eax, ecx
	jne	$LL18@PlotWorker
$LN16@PlotWorker:

; 1365 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+120]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 104				; 00000068H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225723[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pUnit$225733[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$225758[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$225762[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotWorkerSeaMoves
PUBLIC	?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteFirstTurnSettlerMoves
EXTRN	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_FOUND
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ$1
__ehfuncinfo$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$ = -56						; size = 4
$T254819 = -52						; size = 4
_pUnit$226921 = -48					; size = 8
_strLogString$226924 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ExecuteFirstTurnSettlerMoves, COMDAT
; _this$ = ecx

; 2246 : {

	push	-1
	push	__ehhandler$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	push	ebp
	push	edi
	mov	edi, ecx

; 2247 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 2248 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	ebp, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [edi+20]
	shl	eax, 4
	add	eax, ebp
	mov	DWORD PTR _it$[esp+64], ebp
	cmp	ebp, eax
	je	$LN3@ExecuteFir
	push	ebx
	push	esi
	xor	ebx, ebx
$LL5@ExecuteFir:

; 2249 : 	{
; 2250 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$226921[esp+72], esi
	mov	BYTE PTR _pUnit$226921[esp+76], bl
	cmp	esi, ebx
	je	SHORT $LN19@ExecuteFir
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN19@ExecuteFir:
	mov	DWORD PTR __$EHRec$[esp+80], ebx

; 2251 : 		if(pUnit)

	cmp	esi, ebx
	je	$LN1@ExecuteFir

; 2252 : 		{
; 2253 : 			pUnit->PushMission(CvTypes::getMISSION_FOUND());

	push	ebx
	push	ebx
	push	-1
	push	ebx
	push	ebx
	push	ebx
	push	-1
	push	-1
	call	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FOUND
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2254 : 			UnitProcessed(pUnit->GetID());

	mov	ebp, DWORD PTR [esi+100]
	lea	ecx, DWORD PTR $T254819[esp+72]
	push	ecx
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T254819[esp+76], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	cmp	eax, ebx
	je	SHORT $LN32@ExecuteFir
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN32@ExecuteFir:

; 2255 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN59@ExecuteFir
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN59@ExecuteFir

; 2256 : 			{
; 2257 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226924[esp+72]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2258 : 				strLogString.Format("Founded city at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLogString$226924[esp+80]
	push	OFFSET $SG226925
	push	edx
	mov	BYTE PTR __$EHRec$[esp+96], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2259 : 				LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$226924[esp+72]
	push	eax
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2260 : 			}

	lea	ecx, DWORD PTR _strLogString$226924[esp+72]
	mov	BYTE PTR __$EHRec$[esp+80], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN59@ExecuteFir:
	mov	ebp, DWORD PTR _it$[esp+72]
$LN1@ExecuteFir:

; 2261 : 		}
; 2262 : 	}

	mov	DWORD PTR __$EHRec$[esp+80], -1
	cmp	esi, ebx
	je	SHORT $LN4@ExecuteFir
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@ExecuteFir:
	mov	ecx, DWORD PTR [edi+20]
	shl	ecx, 4
	add	ecx, DWORD PTR [edi+16]
	add	ebp, 16					; 00000010H
	mov	DWORD PTR _it$[esp+72], ebp
	cmp	ebp, ecx
	jne	$LL5@ExecuteFir
	pop	esi
	pop	ebx
$LN3@ExecuteFir:

; 2263 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 56					; 00000038H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226921[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$226924[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ExecuteFirstTurnSettlerMoves
PUBLIC	?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z ; CvHomelandAI::ExecuteWorkerSeaMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z$0
__ehfuncinfo$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_pUnit$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_target$ = 8						; size = 20
$T254952 = 28						; size = 4
_pTarget$ = 28						; size = 4
?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z PROC ; CvHomelandAI::ExecuteWorkerSeaMoves, COMDAT
; _this$ = ecx

; 2869 : {

	push	-1
	push	__ehhandler$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	ebp
	mov	ebp, ecx

; 2870 : 	bool bRtnValue = false;
; 2871 : 
; 2872 : 	// Move first one to target
; 2873 : 	UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits.begin()->GetID());

	mov	eax, DWORD PTR [ebp+16]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebp]
	push	esi
	push	eax
	xor	bl, bl
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$[esp+32], esi
	mov	BYTE PTR _pUnit$[esp+36], bl
	test	esi, esi
	je	SHORT $LN15@ExecuteWor@2
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN15@ExecuteWor@2:
	mov	DWORD PTR __$EHRec$[esp+40], 0

; 2874 : 	if(pUnit)

	test	esi, esi
	je	$LN54@ExecuteWor@2
	push	edi

; 2875 : 	{
; 2876 : 		if(pUnit->UnitPathTo(pTarget->getX(), pTarget->getY(), 0) > 0)

	mov	edi, DWORD PTR _pTarget$[esp+32]
	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	0
	push	-1
	push	0
	push	eax
	push	ecx
	mov	ecx, esi
	call	?UnitPathTo@CvUnit@@QAEHHHHH_N@Z	; CvUnit::UnitPathTo
	test	eax, eax
	jle	$LN57@ExecuteWor@2

; 2877 : 		{
; 2878 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2879 : 			if(pUnit->plot() == pTarget)

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 2880 : 			{
; 2881 : 				pUnit->PushMission(CvTypes::getMISSION_BUILD(), (int)target.GetAuxIntData(), -1, 0, (pUnit->GetLengthMissionQueue() > 0), false, MISSIONAI_BUILD, pTarget);

	mov	ecx, esi
	cmp	eax, edi
	jne	SHORT $LN2@ExecuteWor@2
	mov	ebx, DWORD PTR _target$[esp+48]
	push	0
	push	edi
	push	18					; 00000012H
	push	0
	call	?GetLengthMissionQueue@CvUnit@@QBEHXZ	; CvUnit::GetLengthMissionQueue
	test	eax, eax
	setg	al
	movzx	ecx, al
	push	ecx
	push	0
	push	-1
	push	ebx
	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2882 : 				bRtnValue = true;

	mov	bl, 1

; 2883 : 			}
; 2884 : 			else

	jmp	SHORT $LN1@ExecuteWor@2
$LN2@ExecuteWor@2:

; 2885 : 			{
; 2886 : 				pUnit->finishMoves();

	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN1@ExecuteWor@2:

; 2887 : 			}
; 2888 : 
; 2889 : 			// Delete this unit from those we have to move
; 2890 : 			UnitProcessed(m_CurrentMoveUnits.begin()->GetID());

	mov	eax, DWORD PTR [ebp+16]
	mov	edi, DWORD PTR [eax]
	lea	edx, DWORD PTR $T254952[esp+32]
	push	edx
	lea	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR $T254952[esp+36], edi
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [ebp]
	push	edi
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN57@ExecuteWor@2
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN57@ExecuteWor@2:
	pop	edi
$LN54@ExecuteWor@2:

; 2891 : 		}
; 2892 : 	}
; 2893 : 	return bRtnValue;

	mov	DWORD PTR __$EHRec$[esp+40], -1
	test	esi, esi
	je	SHORT $LN53@ExecuteWor@2
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@ExecuteWor@2:

; 2894 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteWorkerSeaMoves@CvHomelandAI@@AAE_NVCvHomelandTarget@@PAVCvPlot@@@Z ENDP ; CvHomelandAI::ExecuteWorkerSeaMoves
PUBLIC	?ExecuteHeals@CvHomelandAI@@AAEXXZ		; CvHomelandAI::ExecuteHeals
EXTRN	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z:PROC	; CvUnit::SetFortifiedThisTurn
EXTRN	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_FORTIFY
EXTRN	?isFortifyable@CvUnit@@QBE_N_N@Z:PROC		; CvUnit::isFortifyable
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteHeals@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteHeals@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?ExecuteHeals@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteHeals@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteHeals@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
$T255024 = -24						; size = 4
_pUnit$227388 = -20					; size = 8
__$EHRec$ = -12						; size = 12
?ExecuteHeals@CvHomelandAI@@AAEXXZ PROC			; CvHomelandAI::ExecuteHeals, COMDAT
; _this$ = ecx

; 2898 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ExecuteHeals@CvHomelandAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	edi
	mov	edi, ecx

; 2899 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 2900 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR [edi+20]
	mov	ebx, DWORD PTR [edi+16]
	shl	eax, 4
	add	eax, ebx
	cmp	ebx, eax
	je	$LN4@ExecuteHea
	push	ebp
	push	esi
$LL6@ExecuteHea:

; 2901 : 	{
; 2902 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$227388[esp+40], esi
	mov	BYTE PTR _pUnit$227388[esp+44], 0
	test	esi, esi
	je	SHORT $LN19@ExecuteHea
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN19@ExecuteHea:
	mov	DWORD PTR __$EHRec$[esp+48], 0

; 2903 : 		if(pUnit)

	test	esi, esi
	je	SHORT $LN43@ExecuteHea

; 2904 : 		{
; 2905 : 			if(pUnit->isFortifyable())

	push	0
	mov	ecx, esi
	call	?isFortifyable@CvUnit@@QBE_N_N@Z	; CvUnit::isFortifyable

; 2906 : 			{
; 2907 : 				pUnit->PushMission(CvTypes::getMISSION_FORTIFY());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	test	al, al
	je	SHORT $LN2@ExecuteHea
	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2908 : 				pUnit->SetFortifiedThisTurn(true);

	push	1
	mov	ecx, esi
	call	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z	; CvUnit::SetFortifiedThisTurn

; 2909 : 			}
; 2910 : 			else

	jmp	SHORT $LN1@ExecuteHea
$LN2@ExecuteHea:

; 2911 : 			{
; 2912 : 				pUnit->PushMission(CvTypes::getMISSION_SKIP());

	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission
$LN1@ExecuteHea:

; 2913 : 			}
; 2914 : 			UnitProcessed(it->GetID());

	mov	ebp, DWORD PTR [ebx]
	lea	ecx, DWORD PTR $T255024[esp+40]
	push	ecx
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T255024[esp+44], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN43@ExecuteHea
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN43@ExecuteHea:

; 2915 : 		}
; 2916 : 	}

	mov	DWORD PTR __$EHRec$[esp+48], -1
	test	esi, esi
	je	SHORT $LN5@ExecuteHea
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@ExecuteHea:
	mov	edx, DWORD PTR [edi+20]
	shl	edx, 4
	add	edx, DWORD PTR [edi+16]
	add	ebx, 16					; 00000010H
	cmp	ebx, edx
	jne	$LL6@ExecuteHea
	pop	esi
	pop	ebp
$LN4@ExecuteHea:

; 2917 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteHeals@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227388[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteHeals@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteHeals@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteHeals@CvHomelandAI@@AAEXXZ ENDP			; CvHomelandAI::ExecuteHeals
PUBLIC	?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecutePatrolMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
$T255106 = -24						; size = 4
_pUnit$227453 = -20					; size = 8
__$EHRec$ = -12						; size = 12
?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecutePatrolMoves, COMDAT
; _this$ = ecx

; 3093 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	edi
	mov	edi, ecx

; 3094 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3095 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR [edi+20]
	mov	ebx, DWORD PTR [edi+16]
	shl	eax, 4
	add	eax, ebx
	cmp	ebx, eax
	je	$LN2@ExecutePat
	push	ebp
	push	esi
$LL4@ExecutePat:

; 3096 : 	{
; 3097 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$227453[esp+40], esi
	mov	BYTE PTR _pUnit$227453[esp+44], 0
	test	esi, esi
	je	SHORT $LN17@ExecutePat
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN17@ExecutePat:

; 3098 : 		CvPlot* pTarget = it->GetTarget();

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR __$EHRec$[esp+48], 0

; 3099 : 		if(pUnit && pTarget)

	test	esi, esi
	je	SHORT $LN47@ExecutePat
	test	eax, eax
	je	SHORT $LN47@ExecutePat

; 3100 : 		{
; 3101 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	movsx	ecx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	ecx
	push	eax
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3102 : 			pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3103 : 			UnitProcessed(pUnit->GetID());

	mov	ebp, DWORD PTR [esi+100]
	lea	ecx, DWORD PTR $T255106[esp+40]
	push	ecx
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T255106[esp+44], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN47@ExecutePat
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN47@ExecutePat:

; 3104 : 		}
; 3105 : 	}

	mov	DWORD PTR __$EHRec$[esp+48], -1
	test	esi, esi
	je	SHORT $LN3@ExecutePat
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN3@ExecutePat:
	mov	edx, DWORD PTR [edi+20]
	shl	edx, 4
	add	edx, DWORD PTR [edi+16]
	add	ebx, 16					; 00000010H
	cmp	ebx, edx
	jne	$LL4@ExecutePat
	pop	esi
	pop	ebp
$LN2@ExecutePat:

; 3106 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227453[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecutePatrolMoves
PUBLIC	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget
EXTRN	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canFortify
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z$2
__ehfuncinfo$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pUnit$227484 = -20					; size = 8
_pUnit$227473 = -20					; size = 8
__$EHRec$ = -12						; size = 12
$T255418 = 8						; size = 4
$T255366 = 8						; size = 4
$T255295 = 8						; size = 4
$T255243 = 8						; size = 4
$T255165 = 8						; size = 4
$T255129 = 8						; size = 4
$T255128 = 8						; size = 4
_pTarget$ = 8						; size = 4
?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z PROC ; CvHomelandAI::ExecuteMoveToTarget, COMDAT
; _this$ = ecx

; 3111 : {

	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 3112 : 	AI_PERF_FORMAT("Homeland-ExecuteMove-perf.csv", ("ExecuteMoveToTarget, %d, %d, Turn %03d, %s", pTarget->getX(), pTarget->getY(), GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 3113 : 
; 3114 : 	// Do we have a pre-calcuated 'best' unit?
; 3115 : 	CvUnit *pBestUnit = NULL;
; 3116 : 	if (m_CurrentBestMoveHighPriorityUnit)

	mov	edi, DWORD PTR [esi+2404]
	test	edi, edi
	je	SHORT $LN24@ExecuteMov

; 3117 : 	{
; 3118 : 		// Don't move high priority unit if regular priority unit is closer
; 3119 : 		if (m_CurrentBestMoveUnit && m_iCurrentBestMoveUnitTurns < m_iCurrentBestMoveHighPriorityUnitTurns)

	mov	eax, DWORD PTR [esi+2396]
	test	eax, eax
	je	SHORT $LN21@ExecuteMov
	mov	ecx, DWORD PTR [esi+2400]
	cmp	ecx, DWORD PTR [esi+2408]
	jge	SHORT $LN21@ExecuteMov

; 3120 : 			pBestUnit = m_CurrentBestMoveUnit;

	mov	edi, eax

; 3121 : 		else

	jmp	SHORT $LN21@ExecuteMov
$LN24@ExecuteMov:

; 3122 : 			pBestUnit = m_CurrentBestMoveHighPriorityUnit;
; 3123 : 	}
; 3124 : 	else
; 3125 : 		pBestUnit = m_CurrentBestMoveUnit;

	mov	edi, DWORD PTR [esi+2396]
$LN21@ExecuteMov:

; 3126 : 
; 3127 : 	if (pBestUnit)

	test	edi, edi
	je	$LN18@ExecuteMov

; 3128 : 	{
; 3129 : 		if(pBestUnit->plot() == pTarget && pBestUnit->canFortify(pBestUnit->plot()))

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ebx, DWORD PTR _pTarget$[esp+32]
	cmp	eax, ebx
	jne	SHORT $LN19@ExecuteMov
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canFortify
	test	al, al
	je	SHORT $LN19@ExecuteMov

; 3130 : 		{
; 3131 : 			pBestUnit->PushMission(CvTypes::getMISSION_FORTIFY());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3132 : 			pBestUnit->SetFortifiedThisTurn(true);

	push	1
	mov	ecx, edi
	call	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z	; CvUnit::SetFortifiedThisTurn

; 3133 : 			UnitProcessed(pBestUnit->GetID());

	mov	edx, DWORD PTR [edi+100]
	push	edx
	mov	ecx, esi
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3202 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
$LN19@ExecuteMov:

; 3134 : 			return;
; 3135 : 		}
; 3136 : 		else
; 3137 : 		{
; 3138 : 			// Best units have already had a full path check to the target, so just add the move
; 3139 : 			pBestUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	movsx	eax, WORD PTR [ebx+2]
	movsx	ecx, WORD PTR [ebx]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3140 : 			pBestUnit->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3141 : 			UnitProcessed(pBestUnit->GetID());

	mov	edi, DWORD PTR [edi+100]
	lea	eax, DWORD PTR $T255165[esp+32]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR $T255165[esp+36], edi
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	$LN182@ExecuteMov
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed

; 3202 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
$LN18@ExecuteMov:

; 3142 : 			return;
; 3143 : 		}
; 3144 : 	}
; 3145 : 
; 3146 : 	MoveUnitsArray::iterator it;
; 3147 : 
; 3148 : 	// Start with high priority list
; 3149 : 	for(it = m_CurrentMoveHighPriorityUnits.begin(); it != m_CurrentMoveHighPriorityUnits.end(); ++it)

	mov	ecx, DWORD PTR [esi+1060]
	mov	ebp, DWORD PTR [esi+1056]
	mov	ebx, DWORD PTR _pTarget$[esp+32]
	shl	ecx, 4
	add	ecx, ebp
	cmp	ebp, ecx
	je	$LN15@ExecuteMov
$LL17@ExecuteMov:

; 3150 : 	{
; 3151 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$227473[esp+36], edi
	mov	BYTE PTR _pUnit$227473[esp+40], 0
	test	edi, edi
	je	SHORT $LN55@ExecuteMov
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN55@ExecuteMov:

; 3152 : 
; 3153 : 		// Don't move high priority unit if regular priority unit is closer
; 3154 : 		if(m_CurrentMoveUnits.size() > 0 && m_CurrentMoveUnits.begin()->GetMovesToTarget() < it->GetMovesToTarget())

	cmp	DWORD PTR [esi+20], 0
	mov	DWORD PTR __$EHRec$[esp+44], 0
	jbe	SHORT $LN14@ExecuteMov
	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, DWORD PTR [ebp+8]
	jl	$LN191@ExecuteMov
$LN14@ExecuteMov:

; 3157 : 		}
; 3158 : 
; 3159 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN10@ExecuteMov

; 3160 : 		{
; 3161 : 			if(pUnit->plot() == pTarget && pUnit->canFortify(pUnit->plot()))

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebx
	jne	SHORT $LN12@ExecuteMov
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canFortify
	test	al, al
	jne	$LN192@ExecuteMov
$LN12@ExecuteMov:

; 3167 : 			}
; 3168 : 
; 3169 : 			else if(it->GetMovesToTarget() < GC.getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE() || TurnsToReachTarget(pUnit, pTarget) != MAX_INT)

	mov	eax, DWORD PTR [ebp+8]
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2572
	jl	$LN9@ExecuteMov
	push	0
	push	0
	push	0
	push	ebx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T255128[esp+56], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	cmp	eax, 2147483647				; 7fffffffH
	jne	$LN9@ExecuteMov
$LN10@ExecuteMov:

; 3175 : 			}
; 3176 : 		}
; 3177 : 	}

	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	edi, edi
	je	SHORT $LN16@ExecuteMov
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN16@ExecuteMov:
	mov	edx, DWORD PTR [esi+1060]
	shl	edx, 4
	add	edx, DWORD PTR [esi+1056]
	add	ebp, 16					; 00000010H
	cmp	ebp, edx
	jne	$LL17@ExecuteMov
$LN15@ExecuteMov:

; 3178 : 
; 3179 : 	// Then regular priority
; 3180 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	edx, DWORD PTR [esi+20]
	mov	ebp, DWORD PTR [esi+16]
	shl	edx, 4
	add	edx, ebp
	cmp	ebp, edx
	je	$LN182@ExecuteMov
$LL8@ExecuteMov:

; 3181 : 	{
; 3182 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$227484[esp+36], edi
	mov	BYTE PTR _pUnit$227484[esp+40], 0
	test	edi, edi
	je	SHORT $LN133@ExecuteMov
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN133@ExecuteMov:
	mov	DWORD PTR __$EHRec$[esp+44], 1

; 3183 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN2@ExecuteMov

; 3184 : 		{
; 3185 : 			if(pUnit->plot() == pTarget && pUnit->canFortify(pUnit->plot()))

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebx
	jne	SHORT $LN4@ExecuteMov
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canFortify@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canFortify
	test	al, al
	jne	$LN193@ExecuteMov
$LN4@ExecuteMov:

; 3191 : 			}
; 3192 : 
; 3193 : 			else if(it->GetMovesToTarget() < GC.getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE() || TurnsToReachTarget(pUnit, pTarget) != MAX_INT)

	mov	eax, DWORD PTR [ebp+8]
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2572
	jl	$LN1@ExecuteMov
	push	0
	push	0
	push	0
	push	ebx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T255129[esp+56], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	cmp	eax, 2147483647				; 7fffffffH
	jne	$LN1@ExecuteMov
$LN2@ExecuteMov:

; 3199 : 			}
; 3200 : 		}
; 3201 : 	}

	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	edi, edi
	je	SHORT $LN7@ExecuteMov
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN7@ExecuteMov:
	mov	eax, DWORD PTR [esi+20]
	shl	eax, 4
	add	eax, DWORD PTR [esi+16]
	add	ebp, 16					; 00000010H
	cmp	ebp, eax
	jne	$LL8@ExecuteMov

; 3202 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
$LN191@ExecuteMov:

; 3155 : 		{
; 3156 : 			break;

	mov	DWORD PTR __$EHRec$[esp+44], -1
	test	edi, edi
	je	$LN15@ExecuteMov
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	jmp	$LN15@ExecuteMov
$LN192@ExecuteMov:

; 3162 : 			{
; 3163 : 				pUnit->PushMission(CvTypes::getMISSION_FORTIFY());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3164 : 				pUnit->SetFortifiedThisTurn(true);

	push	1
	mov	ecx, edi
	call	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z	; CvUnit::SetFortifiedThisTurn

; 3165 : 				UnitProcessed(it->GetID());

	lea	eax, DWORD PTR $T255243[esp+32]
	push	eax

; 3166 : 				return;

	jmp	$LN199@ExecuteMov
$LN9@ExecuteMov:

; 3170 : 			{
; 3171 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	movsx	eax, WORD PTR [ebx+2]
	movsx	ecx, WORD PTR [ebx]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3172 : 				pUnit->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3173 : 				UnitProcessed(it->GetID());

	lea	ecx, DWORD PTR $T255295[esp+32]
	push	ecx

; 3174 : 				return;

	jmp	SHORT $LN199@ExecuteMov
$LN193@ExecuteMov:

; 3186 : 			{
; 3187 : 				pUnit->PushMission(CvTypes::getMISSION_FORTIFY());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_FORTIFY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FORTIFY
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3188 : 				pUnit->SetFortifiedThisTurn(true);

	push	1
	mov	ecx, edi
	call	?SetFortifiedThisTurn@CvUnit@@QAEX_N@Z	; CvUnit::SetFortifiedThisTurn

; 3189 : 				UnitProcessed(it->GetID());

	lea	ecx, DWORD PTR $T255366[esp+32]
	push	ecx

; 3190 : 				return;

	jmp	SHORT $LN199@ExecuteMov
$LN1@ExecuteMov:

; 3194 : 			{
; 3195 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	movsx	eax, WORD PTR [ebx+2]
	movsx	ecx, WORD PTR [ebx]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3196 : 				pUnit->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3197 : 				UnitProcessed(it->GetID());

	lea	edx, DWORD PTR $T255418[esp+32]
	push	edx
$LN199@ExecuteMov:
	mov	ebp, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR $T255418[esp+36], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [esi]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN177@ExecuteMov
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN177@ExecuteMov:

; 3198 : 				return;

	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+44], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN182@ExecuteMov:

; 3202 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$227473[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z$2:
	lea	ecx, DWORD PTR _pUnit$227484[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ENDP ; CvHomelandAI::ExecuteMoveToTarget
PUBLIC	?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteMissionaryMoves
EXTRN	?getMISSION_SPREAD_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SPREAD_RELIGION
EXTRN	?ChooseMissionaryTargetPlot@CvReligionAI@@QAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@PAH@Z:PROC ; CvReligionAI::ChooseMissionaryTargetPlot
EXTRN	?GetReligionAI@CvPlayer@@QBEPAVCvReligionAI@@XZ:PROC ; CvPlayer::GetReligionAI
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$4
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$ = -88						; size = 4
_iTargetTurns$228223 = -84				; size = 4
$T255456 = -80						; size = 4
_pUnit$228221 = -76					; size = 8
_strLogString$228235 = -68				; size = 28
_strLogString$228229 = -68				; size = 28
_strLogString$228240 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ExecuteMissionaryMoves, COMDAT
; _this$ = ecx

; 4393 : {

	push	-1
	push	__ehhandler$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	ebp
	mov	ebp, ecx

; 4394 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4395 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR [ebp+20]
	push	esi
	mov	esi, DWORD PTR [ebp+16]
	shl	eax, 4
	add	eax, esi
	push	edi
	mov	DWORD PTR _it$[esp+104], esi
	cmp	esi, eax
	je	$LN12@ExecuteMis
	xor	ebx, ebx
$LL14@ExecuteMis:

; 4396 : 	{
; 4397 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$228221[esp+104], edi
	mov	BYTE PTR _pUnit$228221[esp+108], bl
	cmp	edi, ebx
	je	SHORT $LN31@ExecuteMis
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN31@ExecuteMis:
	mov	DWORD PTR __$EHRec$[esp+112], ebx

; 4398 : 		if(!pUnit)

	cmp	edi, ebx
	jne	SHORT $LN11@ExecuteMis

; 4399 : 		{
; 4400 : 			continue;

	mov	DWORD PTR __$EHRec$[esp+112], -1
	jmp	$LN13@ExecuteMis
$LN11@ExecuteMis:

; 4401 : 		}
; 4402 : 
; 4403 : 		int iTargetTurns;
; 4404 : 		CvPlot* pTarget = m_pPlayer->GetReligionAI()->ChooseMissionaryTargetPlot(pUnit, &iTargetTurns);

	lea	ecx, DWORD PTR _iTargetTurns$228223[esp+104]
	push	ecx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T255456[esp+116], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], bl
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, DWORD PTR [ebp]
	mov	BYTE PTR __$EHRec$[esp+124], 1
	call	?GetReligionAI@CvPlayer@@QBEPAVCvReligionAI@@XZ ; CvPlayer::GetReligionAI
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+124], bl
	call	?ChooseMissionaryTargetPlot@CvReligionAI@@QAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@PAH@Z ; CvReligionAI::ChooseMissionaryTargetPlot
	mov	esi, eax

; 4405 : 		if(pTarget)

	cmp	esi, ebx
	je	$LN1@ExecuteMis

; 4406 : 		{
; 4407 : 			if(pUnit->plot() == pTarget)

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, esi
	jne	SHORT $LN9@ExecuteMis

; 4408 : 			{
; 4409 : 				pUnit->PushMission(CvTypes::getMISSION_SPREAD_RELIGION());

	push	ebx
	push	ebx
	push	-1
	push	ebx
	push	ebx
	push	ebx
	push	-1
	push	-1
	call	?getMISSION_SPREAD_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPREAD_RELIGION
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4410 : 
; 4411 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteMis
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteMis

; 4412 : 				{
; 4413 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228229[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4414 : 					strLogString.Format("Spreading religion, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strLogString$228229[esp+112]
	push	OFFSET $SG228230
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+128], 2
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4415 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$228229[esp+104]
	push	edx
	mov	ecx, ebp
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4416 : 				}

	lea	ecx, DWORD PTR _strLogString$228229[esp+104]

; 4417 : 			}

	jmp	$LN113@ExecuteMis
$LN9@ExecuteMis:

; 4418 : 			else if(iTargetTurns < 1)

	cmp	DWORD PTR _iTargetTurns$228223[esp+104], 1
	jge	$LN6@ExecuteMis

; 4419 : 			{
; 4420 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	ebx
	push	ebx
	push	-1
	push	ebx
	push	ebx
	push	ebx
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4421 : 
; 4422 : 				if(pUnit->plot() == pTarget && pUnit->canMove())

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, esi
	jne	$LN1@ExecuteMis
	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN1@ExecuteMis

; 4423 : 				{
; 4424 : 					pUnit->PushMission(CvTypes::getMISSION_SPREAD_RELIGION());

	push	ebx
	push	ebx
	push	-1
	push	ebx
	push	ebx
	push	ebx
	push	-1
	push	-1
	call	?getMISSION_SPREAD_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPREAD_RELIGION
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4425 : 
; 4426 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteMis
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteMis

; 4427 : 					{
; 4428 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228235[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4429 : 						strLogString.Format("Move to spread religion, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLogString$228235[esp+112]
	push	OFFSET $SG228236
	push	edx
	mov	BYTE PTR __$EHRec$[esp+128], 3
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4430 : 						LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$228235[esp+104]
	push	eax
	mov	ecx, ebp
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4431 : 					}

	lea	ecx, DWORD PTR _strLogString$228235[esp+104]

; 4432 : 				}
; 4433 : 				else
; 4434 : 				{
; 4435 : 					CvAssertMsg(false, "Internal error with Missionary AI move, contact Ed.");
; 4436 : 				}
; 4437 : 			}
; 4438 : 			else

	jmp	$LN113@ExecuteMis
$LN6@ExecuteMis:

; 4439 : 			{
; 4440 : 				m_CurrentBestMoveHighPriorityUnit = NULL;
; 4441 : 				m_CurrentBestMoveUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[esp+104]
	mov	DWORD PTR [ebp+2404], ebx
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 4442 : 				ExecuteMoveToTarget(pTarget);

	push	esi
	mov	ecx, ebp
	mov	DWORD PTR [ebp+2396], eax
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 4443 : 
; 4444 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@ExecuteMis
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@ExecuteMis

; 4445 : 				{
; 4446 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228240[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4447 : 					strLogString.Format("Moving to plot adjacent to conversion city, X: %d, Y: %d, Currently at, X: %d, Y: %d", pTarget->getX(), pTarget->getY(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	movsx	edx, WORD PTR [esi+2]
	push	eax
	movsx	eax, WORD PTR [esi]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strLogString$228240[esp+120]
	push	OFFSET $SG228241
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+136], 4
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 4448 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$228240[esp+104]
	push	edx
	mov	ecx, ebp
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4449 : 				}

	lea	ecx, DWORD PTR _strLogString$228240[esp+104]
$LN113@ExecuteMis:
	mov	BYTE PTR __$EHRec$[esp+112], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteMis:

; 4450 : 			}
; 4451 : 		}
; 4452 : 	}

	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	esi, DWORD PTR _it$[esp+104]
$LN13@ExecuteMis:
	mov	eax, DWORD PTR [ebp+20]
	shl	eax, 4
	add	eax, DWORD PTR [ebp+16]
	add	esi, 16					; 00000010H
	mov	DWORD PTR _it$[esp+104], esi
	cmp	esi, eax
	jne	$LL14@ExecuteMis
$LN12@ExecuteMis:

; 4453 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 88					; 00000058H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$228221[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$1:
	mov	ecx, DWORD PTR $T255456[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$228229[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$228235[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$228240[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ExecuteMissionaryMoves
PUBLIC	?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteInquisitorMoves
EXTRN	?getMISSION_REMOVE_HERESY@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_REMOVE_HERESY
EXTRN	?ChooseInquisitorTargetPlot@CvReligionAI@@QAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@PAH@Z:PROC ; CvReligionAI::ChooseInquisitorTargetPlot
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$4
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$ = -88						; size = 4
_iTargetTurns$228252 = -84				; size = 4
$T255628 = -80						; size = 4
_pUnit$228250 = -76					; size = 8
_strLogString$228264 = -68				; size = 28
_strLogString$228258 = -68				; size = 28
_strLogString$228269 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ExecuteInquisitorMoves, COMDAT
; _this$ = ecx

; 4457 : {

	push	-1
	push	__ehhandler$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	ebp
	mov	ebp, ecx

; 4458 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4459 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR [ebp+20]
	push	esi
	mov	esi, DWORD PTR [ebp+16]
	shl	eax, 4
	add	eax, esi
	push	edi
	mov	DWORD PTR _it$[esp+104], esi
	cmp	esi, eax
	je	$LN12@ExecuteInq
	xor	ebx, ebx
$LL14@ExecuteInq:

; 4460 : 	{
; 4461 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$228250[esp+104], edi
	mov	BYTE PTR _pUnit$228250[esp+108], bl
	cmp	edi, ebx
	je	SHORT $LN31@ExecuteInq
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN31@ExecuteInq:
	mov	DWORD PTR __$EHRec$[esp+112], ebx

; 4462 : 		if(!pUnit)

	cmp	edi, ebx
	jne	SHORT $LN11@ExecuteInq

; 4463 : 		{
; 4464 : 			continue;

	mov	DWORD PTR __$EHRec$[esp+112], -1
	jmp	$LN13@ExecuteInq
$LN11@ExecuteInq:

; 4465 : 		}
; 4466 : 
; 4467 : 		int iTargetTurns;
; 4468 : 		CvPlot* pTarget = m_pPlayer->GetReligionAI()->ChooseInquisitorTargetPlot(pUnit, &iTargetTurns);

	lea	ecx, DWORD PTR _iTargetTurns$228252[esp+104]
	push	ecx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T255628[esp+116], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], bl
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, DWORD PTR [ebp]
	mov	BYTE PTR __$EHRec$[esp+124], 1
	call	?GetReligionAI@CvPlayer@@QBEPAVCvReligionAI@@XZ ; CvPlayer::GetReligionAI
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+124], bl
	call	?ChooseInquisitorTargetPlot@CvReligionAI@@QAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@PAH@Z ; CvReligionAI::ChooseInquisitorTargetPlot
	mov	esi, eax

; 4469 : 		if(pTarget)

	cmp	esi, ebx
	je	$LN1@ExecuteInq

; 4470 : 		{
; 4471 : 			if(pUnit->plot() == pTarget)

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, esi
	jne	SHORT $LN9@ExecuteInq

; 4472 : 			{
; 4473 : 				pUnit->PushMission(CvTypes::getMISSION_REMOVE_HERESY());

	push	ebx
	push	ebx
	push	-1
	push	ebx
	push	ebx
	push	ebx
	push	-1
	push	-1
	call	?getMISSION_REMOVE_HERESY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_REMOVE_HERESY
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4474 : 
; 4475 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteInq
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteInq

; 4476 : 				{
; 4477 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228258[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4478 : 					strLogString.Format("Removing heresy, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strLogString$228258[esp+112]
	push	OFFSET $SG228259
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+128], 2
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4479 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$228258[esp+104]
	push	edx
	mov	ecx, ebp
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4480 : 				}

	lea	ecx, DWORD PTR _strLogString$228258[esp+104]

; 4481 : 			}

	jmp	$LN113@ExecuteInq
$LN9@ExecuteInq:

; 4482 : 			else if(iTargetTurns < 1)

	cmp	DWORD PTR _iTargetTurns$228252[esp+104], 1
	jge	$LN6@ExecuteInq

; 4483 : 			{
; 4484 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	ebx
	push	ebx
	push	-1
	push	ebx
	push	ebx
	push	ebx
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4485 : 
; 4486 : 				if(pUnit->plot() == pTarget && pUnit->canMove())

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, esi
	jne	$LN1@ExecuteInq
	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN1@ExecuteInq

; 4487 : 				{
; 4488 : 					pUnit->PushMission(CvTypes::getMISSION_REMOVE_HERESY());

	push	ebx
	push	ebx
	push	-1
	push	ebx
	push	ebx
	push	ebx
	push	-1
	push	-1
	call	?getMISSION_REMOVE_HERESY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_REMOVE_HERESY
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4489 : 
; 4490 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteInq
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteInq

; 4491 : 					{
; 4492 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228264[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4493 : 						strLogString.Format("Move to remove heresy, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLogString$228264[esp+112]
	push	OFFSET $SG228265
	push	edx
	mov	BYTE PTR __$EHRec$[esp+128], 3
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4494 : 						LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$228264[esp+104]
	push	eax
	mov	ecx, ebp
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4495 : 					}

	lea	ecx, DWORD PTR _strLogString$228264[esp+104]

; 4496 : 				}
; 4497 : 				else
; 4498 : 				{
; 4499 : 					CvAssertMsg(false, "Internal error with Inquisitor AI move, contact Ed.");
; 4500 : 				}
; 4501 : 			}
; 4502 : 			else

	jmp	$LN113@ExecuteInq
$LN6@ExecuteInq:

; 4503 : 			{
; 4504 : 				m_CurrentBestMoveHighPriorityUnit = NULL;
; 4505 : 				m_CurrentBestMoveUnit = m_pPlayer->getUnit(it->GetID());

	mov	ecx, DWORD PTR _it$[esp+104]
	mov	DWORD PTR [ebp+2404], ebx
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 4506 : 				ExecuteMoveToTarget(pTarget);

	push	esi
	mov	ecx, ebp
	mov	DWORD PTR [ebp+2396], eax
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 4507 : 
; 4508 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@ExecuteInq
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@ExecuteInq

; 4509 : 				{
; 4510 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228269[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4511 : 					strLogString.Format("Moving to plot adjacent to heresy removal city, X: %d, Y: %d, Currently at, X: %d, Y: %d", pTarget->getX(), pTarget->getY(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	movsx	edx, WORD PTR [esi+2]
	push	eax
	movsx	eax, WORD PTR [esi]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strLogString$228269[esp+120]
	push	OFFSET $SG228270
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+136], 4
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 4512 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$228269[esp+104]
	push	edx
	mov	ecx, ebp
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4513 : 				}

	lea	ecx, DWORD PTR _strLogString$228269[esp+104]
$LN113@ExecuteInq:
	mov	BYTE PTR __$EHRec$[esp+112], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteInq:

; 4514 : 			}
; 4515 : 		}
; 4516 : 	}

	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	esi, DWORD PTR _it$[esp+104]
$LN13@ExecuteInq:
	mov	eax, DWORD PTR [ebp+20]
	shl	eax, 4
	add	eax, DWORD PTR [ebp+16]
	add	esi, 16					; 00000010H
	mov	DWORD PTR _it$[esp+104], esi
	cmp	esi, eax
	jne	$LL14@ExecuteInq
$LN12@ExecuteInq:

; 4517 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 88					; 00000058H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$228250[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$1:
	mov	ecx, DWORD PTR $T255628[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$228258[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$228264[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$228269[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ExecuteInquisitorMoves
PUBLIC	?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteSSPartMoves
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ$2
__ehfuncinfo$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_iLoopCity$ = -88					; size = 4
_it$228283 = -84					; size = 4
$T255882 = -80						; size = 4
_pUnit$228287 = -76					; size = 8
_strTemp$228292 = -68					; size = 28
_strLogString$228291 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteSSPartMoves, COMDAT
; _this$ = ecx

; 4521 : {

	push	-1
	push	__ehhandler$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	edi
	mov	edi, ecx

; 4522 : 	CvCity* pLoopCity;
; 4523 : 	CvCity* pCapitalCity = NULL;
; 4524 : 	int iLoopCity = 0;
; 4525 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	mov	ecx, DWORD PTR [edi]
	push	0
	lea	eax, DWORD PTR _iLoopCity$[esp+100]
	push	eax
	mov	DWORD PTR _iLoopCity$[esp+104], 0
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebx, eax
	test	ebx, ebx
	je	$LN4@ExecuteSSP
	npad	4
$LL11@ExecuteSSP:

; 4526 : 	{
; 4527 : 		if(pLoopCity->isCapital())

	mov	ecx, ebx
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	jne	SHORT $LN99@ExecuteSSP
	push	0
	lea	ecx, DWORD PTR _iLoopCity$[esp+100]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebx, eax
	test	ebx, ebx
	jne	SHORT $LL11@ExecuteSSP
	pop	edi
	pop	ebx

; 4561 : 	}
; 4562 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	0
$LN99@ExecuteSSP:

; 4528 : 		{
; 4529 : 			pCapitalCity = pLoopCity;
; 4530 : 			break;
; 4531 : 		}
; 4532 : 	}
; 4533 : 
; 4534 : 	if(pCapitalCity != NULL)

	test	ebx, ebx
	je	$LN4@ExecuteSSP

; 4535 : 	{
; 4536 : 		FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4537 : 		for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	edx, DWORD PTR [edi+20]
	push	ebp
	mov	ebp, DWORD PTR [edi+16]
	shl	edx, 4
	add	edx, ebp
	mov	DWORD PTR _it$228283[esp+100], ebp
	cmp	ebp, edx
	je	$LN103@ExecuteSSP
	push	esi
$LL6@ExecuteSSP:

; 4538 : 		{
; 4539 : 			UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$228287[esp+104], esi
	mov	BYTE PTR _pUnit$228287[esp+108], 0
	test	esi, esi
	je	SHORT $LN26@ExecuteSSP
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN26@ExecuteSSP:
	mov	DWORD PTR __$EHRec$[esp+112], 0

; 4540 : 			if(!pUnit)

	test	esi, esi
	jne	SHORT $LN3@ExecuteSSP

; 4541 : 			{
; 4542 : 				continue;

	mov	DWORD PTR __$EHRec$[esp+112], -1
	jmp	$LN5@ExecuteSSP
$LN3@ExecuteSSP:

; 4543 : 			}
; 4544 : 
; 4545 : 			if(pUnit->plot() != pCapitalCity->plot())

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, ebx
	mov	ebp, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	cmp	ebp, eax
	je	$LN1@ExecuteSSP

; 4546 : 			{
; 4547 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pCapitalCity->getX(), pCapitalCity->getY());

	mov	eax, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+96]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4548 : 				pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4549 : 				UnitProcessed(pUnit->GetID());

	mov	ebp, DWORD PTR [esi+100]
	lea	eax, DWORD PTR $T255882[esp+104]
	push	eax
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T255882[esp+108], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN56@ExecuteSSP
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN56@ExecuteSSP:

; 4550 : 
; 4551 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteSSP
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteSSP

; 4552 : 				{
; 4553 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228291[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4554 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228292[esp+104]
	mov	BYTE PTR __$EHRec$[esp+112], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4555 : 					strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+112], 2
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$228292[esp+104]
	test	eax, eax
	je	SHORT $LN69@ExecuteSSP
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN68@ExecuteSSP
$LN69@ExecuteSSP:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN68@ExecuteSSP:

; 4556 : 					strLogString.Format("Moving %s to spaceship - now at, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$228292[esp+112]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$228291[esp+116]
	push	OFFSET $SG228293
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4557 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$228291[esp+104]
	push	edx
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4558 : 				}

	lea	ecx, DWORD PTR _strTemp$228292[esp+104]
	mov	BYTE PTR __$EHRec$[esp+112], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$228291[esp+104]
	mov	BYTE PTR __$EHRec$[esp+112], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteSSP:

; 4559 : 			}
; 4560 : 		}

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ebp, DWORD PTR _it$228283[esp+104]
$LN5@ExecuteSSP:
	mov	eax, DWORD PTR [edi+20]
	shl	eax, 4
	add	eax, DWORD PTR [edi+16]
	add	ebp, 16					; 00000010H
	mov	DWORD PTR _it$228283[esp+104], ebp
	cmp	ebp, eax
	jne	$LL6@ExecuteSSP
	pop	esi
$LN103@ExecuteSSP:
	pop	ebp
$LN4@ExecuteSSP:

; 4561 : 	}
; 4562 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$228287[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$228291[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$228292[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteSSPartMoves
PUBLIC	?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ		; CvHomelandAI::ExecuteSSPartAdds
EXTRN	?getMISSION_SPACESHIP@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SPACESHIP
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$5
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
$T256148 = -144						; size = 4
$T256091 = -144						; size = 4
$T255967 = -144						; size = 4
_it$228306 = -140					; size = 4
_iLoopCity$ = -136					; size = 4
_pUnit$228310 = -132					; size = 8
_strTemp$228322 = -124					; size = 28
_strTemp$228315 = -96					; size = 28
_strLogString$228314 = -68				; size = 28
_strLogString$228321 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteSSPartAdds, COMDAT
; _this$ = ecx

; 4566 : {

	push	-1
	push	__ehhandler$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 4567 : 	CvCity* pLoopCity;
; 4568 : 	CvCity* pCapitalCity = NULL;
; 4569 : 	int iLoopCity = 0;
; 4570 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	mov	ecx, DWORD PTR [edi]
	push	0
	lea	eax, DWORD PTR _iLoopCity$[esp+164]
	push	eax
	mov	DWORD PTR _iLoopCity$[esp+168], 0
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebx, eax
	test	ebx, ebx
	je	$LN7@ExecuteSSP@2
$LL14@ExecuteSSP@2:

; 4571 : 	{
; 4572 : 		if(pLoopCity->isCapital())

	mov	ecx, ebx
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	jne	SHORT $LN157@ExecuteSSP@2
	push	0
	lea	ecx, DWORD PTR _iLoopCity$[esp+164]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebx, eax
	test	ebx, ebx
	jne	SHORT $LL14@ExecuteSSP@2
	jmp	$LN7@ExecuteSSP@2
$LN157@ExecuteSSP@2:

; 4573 : 		{
; 4574 : 			pCapitalCity = pLoopCity;
; 4575 : 			break;
; 4576 : 		}
; 4577 : 	}
; 4578 : 
; 4579 : 	if(pCapitalCity != NULL)

	test	ebx, ebx
	je	$LN7@ExecuteSSP@2

; 4580 : 	{
; 4581 : 		FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4582 : 		for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	ebp, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+20]
	shl	edx, 4
	add	edx, ebp
	mov	DWORD PTR _it$228306[esp+160], ebp
	cmp	ebp, edx
	je	$LN7@ExecuteSSP@2
$LL9@ExecuteSSP@2:

; 4583 : 		{
; 4584 : 			UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$228310[esp+160], esi
	mov	BYTE PTR _pUnit$228310[esp+164], 0
	test	esi, esi
	je	SHORT $LN32@ExecuteSSP@2
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN32@ExecuteSSP@2:
	mov	DWORD PTR __$EHRec$[esp+168], 0

; 4585 : 			if(!pUnit)

	test	esi, esi
	jne	SHORT $LN6@ExecuteSSP@2

; 4586 : 			{
; 4587 : 				continue;

	mov	DWORD PTR __$EHRec$[esp+168], -1
	jmp	$LN8@ExecuteSSP@2
$LN6@ExecuteSSP@2:

; 4588 : 			}
; 4589 : 
; 4590 : 			if(pUnit->plot() == pCapitalCity->plot())

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, ebx
	mov	ebp, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	cmp	ebp, eax
	jne	$LN5@ExecuteSSP@2

; 4591 : 			{
; 4592 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN4@ExecuteSSP@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN4@ExecuteSSP@2

; 4593 : 				{
; 4594 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228314[esp+160]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4595 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228315[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4596 : 					strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+168], 2
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$228315[esp+160]
	test	eax, eax
	je	SHORT $LN54@ExecuteSSP@2
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN53@ExecuteSSP@2
$LN54@ExecuteSSP@2:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN53@ExecuteSSP@2:

; 4597 : 					strLogString.Format("Adding %s to spaceship, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$228315[esp+168]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$228314[esp+172]
	push	OFFSET $SG228316
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4598 : 					LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$228314[esp+160]
	push	ecx
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4599 : 				}

	lea	ecx, DWORD PTR _strTemp$228315[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$228314[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@ExecuteSSP@2:

; 4600 : 
; 4601 : 				pUnit->PushMission(CvTypes::getMISSION_SPACESHIP());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SPACESHIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPACESHIP
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4602 : 				UnitProcessed(pUnit->GetID());

	mov	ebp, DWORD PTR [esi+100]
	lea	edx, DWORD PTR $T256091[esp+160]
	push	edx
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T256091[esp+164], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	$LN1@ExecuteSSP@2
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
	jmp	$LN1@ExecuteSSP@2
$LN5@ExecuteSSP@2:

; 4603 : 			}
; 4604 : 
; 4605 : 			else if (TurnsToReachTarget(pUnit, pCapitalCity->plot()) == 0)

	push	0
	push	0
	push	0
	mov	ecx, ebx
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T255967[esp+184], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	$LN1@ExecuteSSP@2

; 4606 : 			{
; 4607 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pCapitalCity->getX(), pCapitalCity->getY());

	mov	eax, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+96]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4608 : 				pUnit->PushMission(CvTypes::getMISSION_SPACESHIP());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SPACESHIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPACESHIP
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4609 : 				pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4610 : 				UnitProcessed(pUnit->GetID());

	mov	ebp, DWORD PTR [esi+100]
	lea	eax, DWORD PTR $T256148[esp+160]
	push	eax
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T256148[esp+164], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN114@ExecuteSSP@2
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN114@ExecuteSSP@2:

; 4611 : 
; 4612 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteSSP@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteSSP@2

; 4613 : 				{
; 4614 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228321[esp+160]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4615 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228322[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4616 : 					strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+168], 4
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$228322[esp+160]
	test	eax, eax
	je	SHORT $LN127@ExecuteSSP@2
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN126@ExecuteSSP@2
$LN127@ExecuteSSP@2:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN126@ExecuteSSP@2:

; 4617 : 					strLogString.Format("Moving %s to spaceship and adding it directly in", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$228322[esp+168]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$228321[esp+172]
	push	OFFSET $SG228323
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4618 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$228321[esp+160]
	push	edx
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4619 : 				}

	lea	ecx, DWORD PTR _strTemp$228322[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$228321[esp+160]
	mov	BYTE PTR __$EHRec$[esp+168], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteSSP@2:

; 4620 : 			}
; 4621 : 		}

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+168], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ebp, DWORD PTR _it$228306[esp+160]
$LN8@ExecuteSSP@2:
	mov	eax, DWORD PTR [edi+20]
	shl	eax, 4
	add	eax, DWORD PTR [edi+16]
	add	ebp, 16					; 00000010H
	mov	DWORD PTR _it$228306[esp+160], ebp
	cmp	ebp, eax
	jne	$LL9@ExecuteSSP@2
$LN7@ExecuteSSP@2:

; 4622 : 	}
; 4623 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+160]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 144				; 00000090H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$228310[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$228314[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$228315[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$228321[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strTemp$228322[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteSSPartAdds
PUBLIC	?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteTreasureMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ$2
__ehfuncinfo$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_iLoopCity$ = -88					; size = 4
_it$228336 = -84					; size = 4
$T256310 = -80						; size = 4
_pUnit$228340 = -76					; size = 8
_strTemp$228344 = -68					; size = 28
_strLogString$228343 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteTreasureMoves, COMDAT
; _this$ = ecx

; 4627 : {

	push	-1
	push	__ehhandler$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	edi
	mov	edi, ecx

; 4628 : 	CvCity* pLoopCity;
; 4629 : 	CvCity* pCapitalCity = NULL;
; 4630 : 	int iLoopCity = 0;
; 4631 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	mov	ecx, DWORD PTR [edi]
	push	0
	lea	eax, DWORD PTR _iLoopCity$[esp+100]
	push	eax
	mov	DWORD PTR _iLoopCity$[esp+104], 0
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebx, eax
	test	ebx, ebx
	je	$LN3@ExecuteTre
	npad	4
$LL10@ExecuteTre:

; 4632 : 	{
; 4633 : 		if(pLoopCity->isCapital())

	mov	ecx, ebx
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	jne	SHORT $LN96@ExecuteTre
	push	0
	lea	ecx, DWORD PTR _iLoopCity$[esp+100]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebx, eax
	test	ebx, ebx
	jne	SHORT $LL10@ExecuteTre
	pop	edi
	pop	ebx

; 4664 : 	}
; 4665 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	0
$LN96@ExecuteTre:

; 4634 : 		{
; 4635 : 			pCapitalCity = pLoopCity;
; 4636 : 			break;
; 4637 : 		}
; 4638 : 	}
; 4639 : 
; 4640 : 	if(pCapitalCity != NULL)

	test	ebx, ebx
	je	$LN3@ExecuteTre

; 4641 : 	{
; 4642 : 		FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4643 : 		for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	edx, DWORD PTR [edi+20]
	push	ebp
	mov	ebp, DWORD PTR [edi+16]
	shl	edx, 4
	add	edx, ebp
	mov	DWORD PTR _it$228336[esp+100], ebp
	cmp	ebp, edx
	je	$LN100@ExecuteTre
	push	esi
$LL5@ExecuteTre:

; 4644 : 		{
; 4645 : 			UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$228340[esp+104], esi
	mov	BYTE PTR _pUnit$228340[esp+108], 0
	test	esi, esi
	je	SHORT $LN25@ExecuteTre
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN25@ExecuteTre:
	mov	DWORD PTR __$EHRec$[esp+112], 0

; 4646 : 			if(!pUnit)

	test	esi, esi
	jne	SHORT $LN2@ExecuteTre

; 4647 : 			{
; 4648 : 				continue;

	mov	DWORD PTR __$EHRec$[esp+112], -1
	jmp	$LN4@ExecuteTre
$LN2@ExecuteTre:

; 4649 : 			}
; 4650 : 
; 4651 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pCapitalCity->getX(), pCapitalCity->getY());

	mov	eax, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+96]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4652 : 			pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4653 : 			UnitProcessed(pUnit->GetID());

	mov	ebp, DWORD PTR [esi+100]
	lea	eax, DWORD PTR $T256310[esp+104]
	push	eax
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T256310[esp+108], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN53@ExecuteTre
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN53@ExecuteTre:

; 4654 : 
; 4655 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteTre
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteTre

; 4656 : 			{
; 4657 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228343[esp+104]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4658 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228344[esp+104]
	mov	BYTE PTR __$EHRec$[esp+112], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4659 : 				strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+112], 2
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$228344[esp+104]
	test	eax, eax
	je	SHORT $LN66@ExecuteTre
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN65@ExecuteTre
$LN66@ExecuteTre:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN65@ExecuteTre:

; 4660 : 				strLogString.Format("Moving %s to capital - now at, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$228344[esp+112]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$228343[esp+116]
	push	OFFSET $SG228345
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4661 : 				LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$228343[esp+104]
	push	edx
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4662 : 			}

	lea	ecx, DWORD PTR _strTemp$228344[esp+104]
	mov	BYTE PTR __$EHRec$[esp+112], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$228343[esp+104]
	mov	BYTE PTR __$EHRec$[esp+112], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteTre:

; 4663 : 		}

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ebp, DWORD PTR _it$228336[esp+104]
$LN4@ExecuteTre:
	mov	eax, DWORD PTR [edi+20]
	shl	eax, 4
	add	eax, DWORD PTR [edi+16]
	add	ebp, 16					; 00000010H
	mov	DWORD PTR _it$228336[esp+104], ebp
	cmp	ebp, eax
	jne	$LL5@ExecuteTre
	pop	esi
$LN100@ExecuteTre:
	pop	ebp
$LN3@ExecuteTre:

; 4664 : 	}
; 4665 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	pop	edi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$228340[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$228343[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$228344[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteTreasureMoves
PUBLIC	?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteAircraftMoves
EXTRN	?getMISSION_REBASE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_REBASE
EXTRN	?IsRazing@CvCity@@QBE_NXZ:PROC			; CvCity::IsRazing
EXTRN	?getDamage@CvCity@@QBEHXZ:PROC			; CvCity::getDamage
EXTRN	?GetMaxHitPoints@CvCity@@QBEHXZ:PROC		; CvCity::GetMaxHitPoints
EXTRN	?getArmyID@CvUnit@@QBEHXZ:PROC			; CvUnit::getArmyID
EXTRN	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z:PROC	; CvPlayer::GetPlotDanger
EXTRN	?canLoadUnit@CvUnit@@QBE_NABV1@ABVCvPlot@@@Z:PROC ; CvUnit::canLoadUnit
EXTRN	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z:PROC	; CvUnit::canRebaseAt
EXTRN	?getDamage@CvUnit@@QBEHXZ:PROC			; CvUnit::getDamage
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$5
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_pBestPlot$228358 = -196				; size = 4
_this$ = -192						; size = 4
$T256608 = -188						; size = 4
$T256502 = -188						; size = 4
$T256441 = -188						; size = 4
_iMostDangerous$228359 = -184				; size = 4
_pTransportUnit$228357 = -180				; size = 4
_pUnitPlot$228356 = -176				; size = 4
_it$ = -172						; size = 4
_iLoopCity$228373 = -168				; size = 4
_iLoopUnit$228360 = -164				; size = 4
_pUnit$228354 = -160					; size = 8
_strTemp$228386 = -152					; size = 28
_strLogString$228385 = -124				; size = 28
_strTemp$228395 = -96					; size = 28
_strTemp2$228387 = -68					; size = 28
_strLogString$228396 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteAircraftMoves, COMDAT
; _this$ = ecx

; 4669 : {

	push	-1
	push	__ehhandler$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 184				; 000000b8H
	push	ebp
	mov	ebp, ecx

; 4670 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4671 : 
; 4672 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR [ebp+20]
	push	esi
	mov	esi, DWORD PTR [ebp+16]
	shl	eax, 4
	add	eax, esi
	mov	DWORD PTR _this$[esp+204], ebp
	mov	DWORD PTR _it$[esp+204], esi
	cmp	esi, eax
	je	$LN24@ExecuteAir
	push	ebx
	push	edi
	npad	4
$LL26@ExecuteAir:

; 4673 : 	{
; 4674 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebx, eax
	xor	edi, edi
	mov	DWORD PTR _pUnit$228354[esp+212], ebx
	mov	BYTE PTR _pUnit$228354[esp+216], 0
	cmp	ebx, edi
	je	SHORT $LN44@ExecuteAir
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN44@ExecuteAir:
	mov	DWORD PTR __$EHRec$[esp+220], edi

; 4675 : 		if(!pUnit)

	cmp	ebx, edi
	jne	SHORT $LN23@ExecuteAir

; 4676 : 		{
; 4677 : 			continue;

	mov	DWORD PTR __$EHRec$[esp+220], -1
	jmp	$LN25@ExecuteAir
$LN23@ExecuteAir:

; 4678 : 		}
; 4679 : 
; 4680 : 		CvPlot* pUnitPlot = pUnit->plot();

	mov	ecx, ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 4681 : 		CvUnit* pTransportUnit = NULL;
; 4682 : 		CvPlot* pBestPlot = NULL;
; 4683 : 		int iMostDangerous = 0;
; 4684 : 
; 4685 : 		// first look for open carrier slots
; 4686 : 		int iLoopUnit = 0;
; 4687 : 		for(CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	push	edi
	lea	ecx, DWORD PTR _iLoopUnit$228360[esp+216]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR _pUnitPlot$228356[esp+220], eax
	mov	DWORD PTR _pTransportUnit$228357[esp+220], edi
	mov	DWORD PTR _pBestPlot$228358[esp+220], edi
	mov	DWORD PTR _iMostDangerous$228359[esp+220], edi
	mov	DWORD PTR _iLoopUnit$228360[esp+220], edi
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	cmp	esi, edi
	je	$LN20@ExecuteAir
$LL22@ExecuteAir:

; 4688 : 		{
; 4689 : 			CvPlot* pLoopUnitPlot = pLoopUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 4690 : 
; 4691 : 			if(pLoopUnit->getDamage() > (GC.getMAX_HIT_POINTS() / 5))  // this might not be a good place to land

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	ecx, esi
	mov	edi, eax
	mov	DWORD PTR $T256441[esp+212], edx
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	DWORD PTR $T256441[esp+212]
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ecx, eax
	jg	SHORT $LN21@ExecuteAir

; 4692 : 			{
; 4693 : 				continue;
; 4694 : 			}
; 4695 : 
; 4696 : 			if(pBestPlot != pUnitPlot && !pUnit->canRebaseAt(pUnitPlot, pLoopUnitPlot->getX(),pLoopUnitPlot->getY()))

	mov	edx, DWORD PTR _pUnitPlot$228356[esp+212]
	cmp	DWORD PTR _pBestPlot$228358[esp+212], edx
	je	SHORT $LN18@ExecuteAir
	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	eax
	push	ecx
	push	edx
	mov	ecx, ebx
	call	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z ; CvUnit::canRebaseAt
	test	al, al
	je	SHORT $LN21@ExecuteAir
$LN18@ExecuteAir:

; 4697 : 			{
; 4698 : 				continue;
; 4699 : 			}
; 4700 : 
; 4701 : 			if(!pUnit->canLoadUnit(*pLoopUnit, *pLoopUnitPlot))

	push	edi
	push	esi
	mov	ecx, ebx
	call	?canLoadUnit@CvUnit@@QBE_NABV1@ABVCvPlot@@@Z ; CvUnit::canLoadUnit
	test	al, al
	je	SHORT $LN21@ExecuteAir

; 4702 : 			{
; 4703 : 				continue;
; 4704 : 			}
; 4705 : 
; 4706 : 			int iPlotDanger = m_pPlayer->GetPlotDanger(*pLoopUnitPlot);

	mov	ecx, DWORD PTR [ebp]
	push	edi
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger

; 4707 : 			if (pLoopUnit->getArmyID() != FFreeList::INVALID_INDEX)

	mov	ecx, esi
	mov	ebp, eax
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN16@ExecuteAir

; 4708 : 			{
; 4709 : 				iPlotDanger += 5000;

	add	ebp, 5000				; 00001388H
$LN16@ExecuteAir:

; 4710 : 			}
; 4711 : 			if(iPlotDanger >= iMostDangerous)

	cmp	ebp, DWORD PTR _iMostDangerous$228359[esp+212]
	jl	SHORT $LN198@ExecuteAir

; 4712 : 			{
; 4713 : 				iMostDangerous = iPlotDanger;

	mov	DWORD PTR _iMostDangerous$228359[esp+212], ebp

; 4714 : 				pBestPlot = pLoopUnitPlot;

	mov	DWORD PTR _pBestPlot$228358[esp+212], edi

; 4715 : 				pTransportUnit = pLoopUnit;

	mov	DWORD PTR _pTransportUnit$228357[esp+212], esi
$LN198@ExecuteAir:
	mov	ebp, DWORD PTR _this$[esp+212]
$LN21@ExecuteAir:

; 4681 : 		CvUnit* pTransportUnit = NULL;
; 4682 : 		CvPlot* pBestPlot = NULL;
; 4683 : 		int iMostDangerous = 0;
; 4684 : 
; 4685 : 		// first look for open carrier slots
; 4686 : 		int iLoopUnit = 0;
; 4687 : 		for(CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	push	0
	lea	ecx, DWORD PTR _iLoopUnit$228360[esp+216]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	$LL22@ExecuteAir
	xor	edi, edi
$LN20@ExecuteAir:

; 4716 : 			}
; 4717 : 
; 4718 : 		}
; 4719 : 
; 4720 : 		CvCity* pLoopCity;
; 4721 : 		int iLoopCity = 0;
; 4722 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	mov	ecx, DWORD PTR [ebp]
	push	edi
	lea	edx, DWORD PTR _iLoopCity$228373[esp+216]
	push	edx
	mov	DWORD PTR _iLoopCity$228373[esp+220], edi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	edi, eax
	test	edi, edi
	je	$LN12@ExecuteAir
	npad	7
$LL14@ExecuteAir:

; 4723 : 		{
; 4724 : 			CvPlot* pTarget = pLoopCity->plot();

	mov	ecx, edi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 4725 : 
; 4726 : 			if(pLoopCity->getDamage() > (pLoopCity->GetMaxHitPoints() / 5))

	mov	ecx, edi
	mov	ebp, eax
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	mov	ecx, edi
	add	esi, edx
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	cmp	eax, esi
	jg	SHORT $LN13@ExecuteAir

; 4727 : 			{
; 4728 : 				continue;
; 4729 : 			}
; 4730 : 
; 4731 : 			if(pBestPlot != pUnitPlot && !pUnit->canRebaseAt(pUnitPlot,pTarget->getX(),pTarget->getY()))

	mov	edx, DWORD PTR _pUnitPlot$228356[esp+212]
	cmp	DWORD PTR _pBestPlot$228358[esp+212], edx
	je	SHORT $LN10@ExecuteAir
	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	eax
	push	ecx
	push	edx
	mov	ecx, ebx
	call	?canRebaseAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z ; CvUnit::canRebaseAt
	test	al, al
	je	SHORT $LN13@ExecuteAir
$LN10@ExecuteAir:

; 4732 : 			{
; 4733 : 				continue;
; 4734 : 			}
; 4735 : 
; 4736 : 			if (pLoopCity->IsRazing())

	mov	ecx, edi
	call	?IsRazing@CvCity@@QBE_NXZ		; CvCity::IsRazing
	test	al, al
	jne	SHORT $LN13@ExecuteAir

; 4737 : 			{
; 4738 : 				continue;
; 4739 : 			}
; 4740 : 
; 4741 : 			int iPlotDanger = m_pPlayer->GetPlotDanger(*pTarget);

	mov	eax, DWORD PTR _this$[esp+212]
	mov	ecx, DWORD PTR [eax]
	push	ebp
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger

; 4742 : 			if(iPlotDanger >= iMostDangerous)

	cmp	eax, DWORD PTR _iMostDangerous$228359[esp+212]
	jl	SHORT $LN13@ExecuteAir

; 4743 : 			{
; 4744 : 				iMostDangerous = iPlotDanger;

	mov	DWORD PTR _iMostDangerous$228359[esp+212], eax

; 4745 : 				pBestPlot = pTarget;

	mov	DWORD PTR _pBestPlot$228358[esp+212], ebp

; 4746 : 				pTransportUnit = NULL;

	mov	DWORD PTR _pTransportUnit$228357[esp+212], 0
$LN13@ExecuteAir:
	mov	edx, DWORD PTR _this$[esp+212]
	push	0
	lea	ecx, DWORD PTR _iLoopCity$228373[esp+216]
	push	ecx
	mov	ecx, DWORD PTR [edx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, eax
	test	edi, edi
	jne	$LL14@ExecuteAir

; 4716 : 			}
; 4717 : 
; 4718 : 		}
; 4719 : 
; 4720 : 		CvCity* pLoopCity;
; 4721 : 		int iLoopCity = 0;
; 4722 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	mov	ebp, DWORD PTR _this$[esp+212]
$LN12@ExecuteAir:

; 4747 : 			}
; 4748 : 		}
; 4749 : 
; 4750 : 		if(pBestPlot && pBestPlot != pUnitPlot)

	mov	esi, DWORD PTR _pBestPlot$228358[esp+212]
	test	esi, esi
	je	$LN7@ExecuteAir
	cmp	esi, DWORD PTR _pUnitPlot$228356[esp+212]
	je	$LN7@ExecuteAir

; 4751 : 		{
; 4752 : 			pUnit->PushMission(CvTypes::getMISSION_REBASE(), pBestPlot->getX(), pBestPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_REBASE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_REBASE
	push	eax
	mov	ecx, ebx
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4753 : 			pUnit->finishMoves();

	mov	ecx, ebx
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4754 : 			UnitProcessed(pUnit->GetID());

	mov	edi, DWORD PTR [ebx+100]
	lea	eax, DWORD PTR $T256502[esp+212]
	push	eax
	lea	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR $T256502[esp+216], edi
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [ebp]
	push	edi
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN86@ExecuteAir
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN86@ExecuteAir:

; 4755 : 
; 4756 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN197@ExecuteAir
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN197@ExecuteAir

; 4757 : 			{
; 4758 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228385[esp+212]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4759 : 				CvString strTemp, strTemp2;

	lea	ecx, DWORD PTR _strTemp$228386[esp+212]
	mov	BYTE PTR __$EHRec$[esp+220], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp2$228387[esp+212]
	mov	BYTE PTR __$EHRec$[esp+220], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4760 : #ifdef AUI_WARNING_FIXES
; 4761 : 				strTemp = pUnit->getUnitInfo().GetDescription();
; 4762 : 				if (pTransportUnit)
; 4763 : 				{
; 4764 : 					strTemp2 = pTransportUnit->getUnitInfo().GetDescription();
; 4765 : #else
; 4766 : 				strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+220], 3
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$228386[esp+212]
	test	eax, eax
	je	SHORT $LN102@ExecuteAir
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN101@ExecuteAir
$LN102@ExecuteAir:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN101@ExecuteAir:

; 4767 : 				if (pTransportUnit)

	mov	ecx, DWORD PTR _pTransportUnit$228357[esp+212]
	test	ecx, ecx
	je	SHORT $LN107@ExecuteAir

; 4768 : 				{
; 4769 : 					strTemp2 = GC.getUnitInfo(pTransportUnit->getUnitType())->GetDescription();

	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp2$228387[esp+212]
	test	eax, eax
	je	SHORT $LN108@ExecuteAir
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN107@ExecuteAir
$LN108@ExecuteAir:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN107@ExecuteAir:

; 4770 : #endif
; 4771 : 				}
; 4772 : 
; 4773 : 				if (pBestPlot->getPlotCity())

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	SHORT $LN4@ExecuteAir
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN4@ExecuteAir
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN4@ExecuteAir

; 4774 : 				{
; 4775 : 					strLogString.Format("Rebasing %s to city garrison, X: %d, Y: %d", strTemp.GetCString(), pBestPlot->getX(), pBestPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$228386[esp+220]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$228385[esp+224]
	push	OFFSET $SG228390
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4776 : 				}
; 4777 : 				else

	jmp	SHORT $LN3@ExecuteAir
$LN4@ExecuteAir:

; 4778 : 				{
; 4779 : 					strLogString.Format("Rebasing %s onto %s, X: %d, Y: %d", strTemp.GetCString(), strTemp2.GetCString(), pBestPlot->getX(), pBestPlot->getY());

	movsx	edi, WORD PTR [esi+2]
	movsx	esi, WORD PTR [esi]
	lea	ecx, DWORD PTR _strTemp2$228387[esp+212]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	edi
	push	esi
	push	eax
	lea	ecx, DWORD PTR _strTemp$228386[esp+224]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$228385[esp+228]
	push	OFFSET $SG228392
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H
$LN3@ExecuteAir:

; 4780 : 				}
; 4781 : 				LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$228385[esp+212]
	push	ecx
	mov	ecx, ebp
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4782 : 			}

	lea	ecx, DWORD PTR _strTemp2$228387[esp+212]
	mov	BYTE PTR __$EHRec$[esp+220], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$228386[esp+212]
	mov	BYTE PTR __$EHRec$[esp+220], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$228385[esp+212]

; 4783 : 		}
; 4784 : 		else

	jmp	$LN200@ExecuteAir
$LN7@ExecuteAir:

; 4785 : 		{
; 4786 : 			pUnit->finishMoves();

	mov	ecx, ebx
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4787 : 			UnitProcessed(pUnit->GetID());

	mov	esi, DWORD PTR [ebx+100]
	lea	edx, DWORD PTR $T256608[esp+212]
	push	edx
	lea	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR $T256608[esp+216], esi
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [ebp]
	push	esi
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN148@ExecuteAir
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN148@ExecuteAir:

; 4788 : 
; 4789 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN197@ExecuteAir
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN197@ExecuteAir

; 4790 : 			{
; 4791 : #ifdef AUI_WARNING_FIXES
; 4792 : 				CvString strTemp = pUnit->getUnitInfo().GetDescription();
; 4793 : #else
; 4794 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228395[esp+212]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4795 : 				strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+220], 4
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$228395[esp+212]
	test	eax, eax
	je	SHORT $LN158@ExecuteAir
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN157@ExecuteAir
$LN158@ExecuteAir:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN157@ExecuteAir:

; 4796 : #endif
; 4797 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228396[esp+212]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4798 : 				strLogString.Format("No better place to move %s at, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [ebx+88]
	mov	ecx, DWORD PTR [ebx+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$228395[esp+220]
	mov	BYTE PTR __$EHRec$[esp+228], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$228396[esp+224]
	push	OFFSET $SG228397
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4799 : 				LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$228396[esp+212]
	push	ecx
	mov	ecx, ebp
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4800 : 			}

	lea	ecx, DWORD PTR _strLogString$228396[esp+212]
	mov	BYTE PTR __$EHRec$[esp+220], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$228395[esp+212]
$LN200@ExecuteAir:
	mov	BYTE PTR __$EHRec$[esp+220], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN197@ExecuteAir:

; 4801 : 		}
; 4802 : 	}

	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+220], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	esi, DWORD PTR _it$[esp+212]
$LN25@ExecuteAir:
	mov	edx, DWORD PTR [ebp+20]
	shl	edx, 4
	add	edx, DWORD PTR [ebp+16]
	add	esi, 16					; 00000010H
	mov	DWORD PTR _it$[esp+212], esi
	cmp	esi, edx
	jne	$LL26@ExecuteAir
	pop	edi
	pop	ebx
$LN24@ExecuteAir:

; 4803 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+204]
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 196				; 000000c4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$228354[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$228385[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$228386[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strTemp2$228387[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strTemp$228395[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$228396[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteAircraftMoves
PUBLIC	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@4:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@@Z
_TEXT	SEGMENT
$T256725 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Cat$256729 = 12					; size = 1
$T256727 = 12						; size = 1
__Where$ = 12						; size = 4
?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase, COMDAT
; _this$ = ecx

; 1017 : 		{	// erase element at where

	push	ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	edx, DWORD PTR $T256727[esp]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR __Cat$256729[esp+4]
	mov	BYTE PTR $T256725[esp+8], 0
	mov	eax, DWORD PTR $T256725[esp+8]
	push	eax
	mov	eax, DWORD PTR __Where$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR [esi+8]
	push	edx
	push	eax
	push	ecx
	add	eax, 20					; 00000014H
	push	eax
	call	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);
; 1021 : 		--_Mylast;
; 1022 : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	edx, DWORD PTR __Where$[esp+28]
	add	esp, 24					; 00000018H
	add	DWORD PTR [esi+8], -20			; ffffffecH
	mov	DWORD PTR [eax], edx
	pop	esi

; 1023 : 		}

	pop	ecx
	ret	8
?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z
_TEXT	SEGMENT
$T256807 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Cat$256811 = 12					; size = 1
$T256809 = 12						; size = 1
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[esp-4]

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [edi], eax
	cmp	eax, edx
	je	SHORT $LN26@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ecx, DWORD PTR [esi+8]
	push	ebx
	mov	BYTE PTR $T256807[esp+8], 0
	mov	ebx, DWORD PTR $T256807[esp+8]
	push	ebx
	mov	ebx, DWORD PTR __Cat$256811[esp+12]
	push	ebx
	mov	ebx, DWORD PTR $T256809[esp+16]
	push	ebx
	push	eax
	push	ecx
	push	edx
	call	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+8], eax
	pop	ebx
$LN26@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, edi
	pop	edi
	pop	esi

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::erase
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill@2
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill@2:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill@2
	pop	ebx
$LN22@Ufill@2:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Insert_n
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$0
__unwindtable$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$5
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z
_TEXT	SEGMENT
__Tmp$230010 = -40					; size = 20
__Tmp$230000 = -40					; size = 20
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$257232 = 8					; size = 1
__Cat$257159 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$229985 = 12					; size = 4
__Count$ = 12						; size = 4
tv525 = 16						; size = 4
tv515 = 16						; size = 4
$T257229 = 16						; size = 1
$T257156 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	eax, eax
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	edx, DWORD PTR [esi+12]
	sub	edx, eax
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN85@Insert_n

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	edx, ebx
	sub	edx, DWORD PTR [esi+4]
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, 214748364				; 0cccccccH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@KAXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Xlen
$LN91@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 214748364				; 0cccccccH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@VCvHomelandTarget@@@std@@YAPAVCvHomelandTarget@@IPAV1@@Z ; std::_Allocate<CvHomelandTarget>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	edx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[ebp]
	sar	edx, 3
	mov	ebx, edx
	add	esp, 8
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	push	eax
	lea	edx, DWORD PTR [ebx+ebx*4]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	edi
	mov	DWORD PTR __Newvec$229985[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV3@IABV3@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$257159[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T257156[ebp], 0
	mov	ecx, DWORD PTR $T257156[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$229985[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Newvec$229985[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	add	ebx, edi
	lea	ecx, DWORD PTR [ebx+ebx*4]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	BYTE PTR $T257229[ebp], 0
	mov	edx, DWORD PTR $T257229[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$257232[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAVCvHomelandTarget@@PAV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvHomelandTarget *,CvHomelandTarget *,std::allocator<CvHomelandTarget> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN81@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR __Newvec$229985[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [edi+edi*4]
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$229985[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN92@Insert_n:
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	edx, ebx
	sub	edx, ecx
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	jae	$LN3@Insert_n
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$230000[ebp], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$230000[ebp+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$230000[ebp+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR __Tmp$230000[ebp+16], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [edi+edi*4]
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv515[ebp], eax
	add	eax, ecx
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$230000[ebp+12], edx
	call	??$_Umove@PAVCvHomelandTarget@@@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV2@00@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Umove<CvHomelandTarget *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ebx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR __Tmp$230000[ebp]
	push	ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR __Where$[ebp]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV3@IABV3@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$230000[ebp]
	push	ecx
	sub	esi, eax
	push	esi
	push	edx
	call	??$_Fill@PAVCvHomelandTarget@@V1@@std@@YAXPAVCvHomelandTarget@@0ABV1@@Z ; std::_Fill<CvHomelandTarget *,CvHomelandTarget>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$230010[ebp], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$230010[ebp+4], edx
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+16]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [edi+edi*4]
	mov	DWORD PTR __Tmp$230010[ebp+16], eax
	add	edi, edi
	push	ebx
	add	edi, edi
	mov	eax, ebx
	sub	eax, edi
	push	ebx
	mov	DWORD PTR __Tmp$230010[ebp+8], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$230010[ebp+12], edx
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAVCvHomelandTarget@@@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV2@00@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Umove<CvHomelandTarget *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv525[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ebx
	push	ecx
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAVCvHomelandTarget@@PAV1@@stdext@@YAPAVCvHomelandTarget@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvHomelandTarget *,CvHomelandTarget *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$230010[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	edi, eax
	push	edi
	push	eax
	call	??$_Fill@PAVCvHomelandTarget@@V1@@std@@YAXPAVCvHomelandTarget@@0ABV1@@Z ; std::_Fill<CvHomelandTarget *,CvHomelandTarget>
	add	esp, 24					; 00000018H
$LN85@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN90@Insert_n:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Insert_n
PUBLIC	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z PROC ; BaseVector<TradeConnection,0>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	edi

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	edi, DWORD PTR _uiNumElements$[esp]
	test	edi, edi
	jbe	SHORT $LN1@Destroy
	push	esi
	mov	esi, DWORD PTR _pVal$[esp+4]
	add	esi, 44					; 0000002cH
$LL3@Destroy:

; 223  : 				pVal[i].~T();

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN15@Destroy
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN15@Destroy:
	add	esi, 444				; 000001bcH
	sub	edi, 1
	jne	SHORT $LL3@Destroy
	pop	esi
$LN1@Destroy:
	pop	edi

; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ENDP ; BaseVector<TradeConnection,0>::Destroy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$230086 = 16					; size = 4
__Tmp$230076 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@2
$LN29@Insert_n@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n@2
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@KAXXZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Xlen
$LN64@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@PAVCvPlot@@@std@@YAPAPAVCvPlot@@IPAPAV1@@Z ; std::_Allocate<CvPlot *>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$230076[esp+16], edx
	jae	SHORT $LN3@Insert_n@2
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$230076[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV3@IABQAV3@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$230076[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ; std::fill<CvPlot * *,CvPlot *>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAPAVCvPlot@@@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEPAPAVCvPlot@@PAPAV2@00@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Umove<CvPlot * *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAPAVCvPlot@@PAPAV1@@stdext@@YAPAPAVCvPlot@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvPlot * *,CvPlot * *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$230086[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAPAVCvPlot@@PAV1@@std@@YAXPAPAVCvPlot@@0ABQAV1@@Z ; std::fill<CvPlot * *,CvPlot *>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n@2:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n@2:
?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$230205 = 16					; size = 4
__Tmp$230195 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n@3
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@3
$LN29@Insert_n@3:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n@3:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n@3
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
$LN64@Insert_n@3:
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n@3:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n@3:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$230195[esp+16], edx
	jae	SHORT $LN3@Insert_n@3
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$230195[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$230195[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::fill<CvCity * *,CvCity *>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n@3:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAPAVCvCity@@@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV2@00@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Umove<CvCity * *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$230205[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAPAVCvCity@@PAV1@@std@@YAXPAPAVCvCity@@0ABQAV1@@Z ; std::fill<CvCity * *,CvCity *>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n@3:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n@3:
?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
_TEXT	ENDS
PUBLIC	??$sort_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ; std::sort_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$sort_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$sort_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z PROC ; std::sort_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 2241 : 	_DEBUG_RANGE(_First, _Last);
; 2242 : 	_DEBUG_POINTER(_Pred);
; 2243 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2244 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Pred);

	jmp	??$_Sort_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ; std::_Sort_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
??$sort_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ENDP ; std::sort_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::sort_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::sort_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Median@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Median<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Median@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Median@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z PROC ; std::_Median<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 3169 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median@3

; 3170 : 		{	// median of nine
; 3171 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	push	ebp

; 3172 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);

	mov	ebp, DWORD PTR __Pred$[esp+8]
	and	edx, 7
	add	eax, edx
	push	edi
	sar	eax, 3
	mov	edi, eax
	shl	edi, 4
	push	ebp
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+28], eax
	call	??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>

; 3173 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	eax, DWORD PTR __Mid$[esp+28]
	push	ebp
	lea	ecx, DWORD PTR [ebx+eax]
	push	ecx
	push	eax
	sub	eax, ebx
	push	eax
	call	??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>

; 3174 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

	push	ebp
	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+60], eax
	call	??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>

; 3175 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);

	mov	edx, DWORD PTR tv203[esp+60]
	mov	eax, DWORD PTR __Mid$[esp+60]
	mov	ecx, DWORD PTR tv200[esp+60]
	push	ebp
	push	edx
	push	eax
	push	ecx
	call	??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 64					; 00000040H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3179 : 	}

	ret	0
$LN2@Median@3:

; 3176 : 		}
; 3177 : 	else
; 3178 : 		std::_Med3(_First, _Mid, _Last, _Pred);

	mov	edx, DWORD PTR __Pred$[esp]
	mov	eax, DWORD PTR __Mid$[esp]
	push	edx
	push	esi
	push	eax
	push	ecx
	call	??$_Med3@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Med3<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 16					; 00000010H
	pop	esi

; 3179 : 	}

	ret	0
??$_Median@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ENDP ; std::_Median<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z
_TEXT	SEGMENT
$T257548 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T257549 = 40						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z PROC ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T257548[esp+8], bl
	mov	eax, DWORD PTR $T257548[esp+8]
	push	eax
	push	ecx
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR __Last$[esp+36]
	mov	eax, DWORD PTR __First$[esp+36]
	mov	DWORD PTR $T257549[esp+36], esp
	push	edx
	push	eax
	call	??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>

; 5254 : 	}

	mov	eax, DWORD PTR __Dest$[esp+44]
	add	esp, 40					; 00000028H
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_@5:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@stdext@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@0V?$_Temp_iterator@VCvHomelandTarget@@@2@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@stdext@@YAXPAVCvHomelandTarget@@0V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@stdext@@YAXPAVCvHomelandTarget@@0V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HH@Z
_TEXT	SEGMENT
$T257585 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
??$_Unchecked_chunked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@stdext@@YAXPAVCvHomelandTarget@@0V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	mov	BYTE PTR $T257585[esp+4], 0
	mov	eax, DWORD PTR $T257585[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXPAVCvHomelandTarget@@0V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>

; 5254 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_chunked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@stdext@@YAXPAVCvHomelandTarget@@0V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z
_TEXT	SEGMENT
$T257593 = -20						; size = 20
$T257590 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Mid$ = 16						; size = 4
__Last$ = 20						; size = 4
$T257766 = 24						; size = 1
__Cat$257771 = 24					; size = 1
$T257768 = 24						; size = 1
$T257732 = 24						; size = 1
__Cat$257737 = 24					; size = 1
$T257734 = 24						; size = 1
$T257677 = 24						; size = 1
__Cat$257682 = 24					; size = 1
$T257679 = 24						; size = 1
$T257644 = 24						; size = 1
__Cat$257649 = 24					; size = 1
$T257646 = 24						; size = 1
$T257594 = 24						; size = 4
$T257592 = 24						; size = 4
$T257591 = 24						; size = 4
$T257589 = 24						; size = 4
__Count1$ = 24						; size = 4
__Count2$ = 28						; size = 4
__Tempbuf$ = 32						; size = 4
??$_Buffered_rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z PROC ; std::_Buffered_rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebx, DWORD PTR __Count1$[esp+20]
	push	esi
	mov	esi, DWORD PTR __Tempbuf$[esp+24]
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+28]
	cmp	ebx, edi
	jg	$LN4@Buffered_r@3
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen
	cmp	ebx, eax
	jg	$LN4@Buffered_r@3

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Mid$[esp+48]
	mov	ecx, DWORD PTR __First$[esp+48]
	mov	DWORD PTR $T257589[esp+48], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T257590[esp+60]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	mov	eax, DWORD PTR $T257590[esp+64]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN25@Buffered_r@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r@3:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	BYTE PTR $T257644[esp+28], bl
	mov	eax, DWORD PTR $T257644[esp+28]
	mov	ecx, DWORD PTR __Cat$257649[esp+28]
	mov	edx, DWORD PTR $T257646[esp+28]
	push	eax
	mov	eax, DWORD PTR __First$[esp+32]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+36]
	push	edx
	mov	edx, DWORD PTR __Mid$[esp+40]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T257591[esp+52]
	push	eax
	call	??$_Copy_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T257677[esp+56], bl
	mov	ecx, DWORD PTR $T257677[esp+56]
	mov	edx, DWORD PTR __Cat$257682[esp+56]
	mov	eax, DWORD PTR $T257679[esp+56]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+60]
	push	edx
	mov	edx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+68]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_backward_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	mov	eax, esi

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r@3:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen
	cmp	edi, eax
	jg	$LN2@Buffered_r@3

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+48]
	mov	ecx, DWORD PTR __Mid$[esp+48]
	mov	DWORD PTR $T257592[esp+48], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T257593[esp+60]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	mov	eax, DWORD PTR $T257593[esp+64]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN57@Buffered_r@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Buffered_r@3:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	BYTE PTR $T257732[esp+28], bl
	mov	eax, DWORD PTR $T257732[esp+28]
	mov	ecx, DWORD PTR __Cat$257737[esp+28]
	mov	edx, DWORD PTR $T257734[esp+28]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+32]
	push	ecx
	mov	ecx, DWORD PTR __Mid$[esp+36]
	push	edx
	mov	edx, DWORD PTR __First$[esp+40]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T257594[esp+52]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T257766[esp+56], bl
	mov	ecx, DWORD PTR $T257766[esp+56]
	mov	edx, DWORD PTR __Cat$257771[esp+56]
	mov	eax, DWORD PTR $T257768[esp+56]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+60]
	push	edx
	mov	edx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+68]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@PAVCvHomelandTarget@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::random_access_iterator_tag>
	add	esp, 56					; 00000038H
	mov	eax, esi

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r@3:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	eax, DWORD PTR __First$[esp+28]
	mov	ecx, DWORD PTR __Mid$[esp+28]
	cmp	eax, ecx
	je	SHORT $LN88@Buffered_r@3
	mov	edx, DWORD PTR __Last$[esp+28]
	cmp	ecx, edx
	je	SHORT $LN88@Buffered_r@3
	xor	ebx, ebx
	push	ebx
	push	ebx
	push	edx
	push	ecx
	push	eax
	call	??$_Rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00PAHPAVCvHomelandTarget@@@Z ; std::_Rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	mov	eax, DWORD PTR __First$[esp+48]
	add	esp, 20					; 00000014H
$LN88@Buffered_r@3:

; 2700 : 		std::advance(_First, _Count2);

	lea	ecx, DWORD PTR [edi+edi*4]

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	pop	esi
	mov	DWORD PTR [eax], edx
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ENDP ; std::_Buffered_rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T257885 = -20						; size = 20
$T257883 = -20						; size = 20
$T257881 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
$T257880 = 36						; size = 4
__Chunk$ = 36						; size = 4
$T257882 = 40						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>, COMDAT

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+32]
	lea	eax, DWORD PTR [edi+edi]
	xor	ebx, ebx
	cmp	eax, ecx
	jg	SHORT $LN3@Chunked_me@6
	npad	4
$LL5@Chunked_me@6:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [edx+edi*8]
	mov	DWORD PTR $T257880[esp+52], esp
	lea	esi, DWORD PTR [ecx+edi*8]
	push	esi
	push	ecx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ebp, DWORD PTR __Dest$[esp+76]
	push	ecx
	mov	DWORD PTR [eax+16], ebp
	push	edx
	lea	eax, DWORD PTR $T257881[esp+72]
	push	eax
	call	??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z ; stdext::unchecked_merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T257881[esp+76]
	add	esp, 40					; 00000028H
	mov	DWORD PTR __Dest$[esp+48], ecx
	cmp	eax, ebx
	je	SHORT $LN41@Chunked_me@6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Chunked_me@6:
	mov	ecx, DWORD PTR __Count$[esp+32]
	lea	eax, DWORD PTR [edi+edi]
	sub	ecx, eax
	cmp	ecx, eax

; 3297 : 		_First = _Mid2;

	mov	edx, esi
	mov	DWORD PTR __Count$[esp+32], ecx
	jge	SHORT $LL5@Chunked_me@6
$LN3@Chunked_me@6:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)
; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	cmp	ecx, edi
	mov	eax, esp
	mov	DWORD PTR $T257882[esp+52], esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	jg	SHORT $LN2@Chunked_me@6
	mov	ecx, DWORD PTR __Dest$[esp+68]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+52]
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T257883[esp+64]
	push	ecx
	call	??$unchecked_copy@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@0V12@@Z ; stdext::unchecked_copy<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	add	esp, 32					; 00000020H

; 3302 : 	else

	jmp	SHORT $LN99@Chunked_me@6
$LN2@Chunked_me@6:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);
; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	esi, DWORD PTR __Dest$[esp+68]
	mov	DWORD PTR [eax+16], esi
	mov	eax, DWORD PTR __Last$[esp+52]
	push	eax
	lea	ecx, DWORD PTR [edx+edi*8]
	push	ecx
	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T257885[esp+72]
	push	ecx
	call	??$unchecked_merge@PAVCvHomelandMove@@PAV1@V?$_Temp_iterator@VCvHomelandMove@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandMove@@@std@@PAVCvHomelandMove@@000V12@@Z ; stdext::unchecked_merge<CvHomelandMove *,CvHomelandMove *,std::_Temp_iterator<CvHomelandMove> >
	add	esp, 40					; 00000028H
$LN99@Chunked_me@6:
	mov	eax, DWORD PTR $T257885[esp+36]
	cmp	eax, ebx
	je	SHORT $LN75@Chunked_me@6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN75@Chunked_me@6:

; 3308 : 		}
; 3309 : 	}

	mov	eax, DWORD PTR __Dest$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN85@Chunked_me@6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN85@Chunked_me@6:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T258067 = -36						; size = 4
$T258072 = -32						; size = 20
$T258070 = -32						; size = 20
$T258068 = -32						; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T258071 = 40						; size = 4
$T258069 = 40						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 4
___formal$ = 48						; size = 1
??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	-1
	push	__ehhandler$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[esp+48]
	mov	esi, DWORD PTR __Count$[esp+48]
	mov	edx, DWORD PTR __First$[esp+48]
	xor	edi, edi
	lea	ecx, DWORD PTR [eax+eax]
	cmp	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+60], edi
	jg	SHORT $LN3@Chunked_me@7
	mov	ebx, eax
	shl	ebx, 4
$LN5@Chunked_me@7:

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;
; 3438 : 		std::advance(_Mid1, _Chunk);
; 3439 : 		_BidIt _Mid2 = _Mid1;
; 3440 : 		std::advance(_Mid2, _Chunk);
; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+48]
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [ebx+edx]
	mov	DWORD PTR $T258067[esp+76], esp
	lea	esi, DWORD PTR [ebx+ecx]
	push	esi
	push	ecx
	push	ecx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ebp, DWORD PTR __Dest$[esp+100]
	push	edx
	lea	ecx, DWORD PTR $T258068[esp+92]
	push	ecx
	mov	DWORD PTR [eax+16], ebp
	call	??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T258068[esp+96]
	add	esp, 44					; 0000002cH
	mov	DWORD PTR __Dest$[esp+64], edx
	cmp	eax, edi
	je	SHORT $LN41@Chunked_me@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Chunked_me@7:
	mov	eax, DWORD PTR __Chunk$[esp+48]

; 3443 : 		_First = _Mid2;

	mov	edx, esi
	mov	esi, DWORD PTR __Count$[esp+48]
	lea	ecx, DWORD PTR [eax+eax]
	sub	esi, ecx
	cmp	esi, ecx
	mov	DWORD PTR __Count$[esp+48], esi
	jge	SHORT $LN5@Chunked_me@7
$LN3@Chunked_me@7:

; 3444 : 		}
; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	cmp	esi, eax
	jg	SHORT $LN2@Chunked_me@7

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+84]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+68]
	mov	DWORD PTR $T258069[esp+68], esp
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T258070[esp+80]
	push	ecx
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 32					; 00000020H

; 3448 : 	else

	jmp	SHORT $LN101@Chunked_me@7
$LN2@Chunked_me@7:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;
; 3451 : 		std::advance(_Mid1, _Chunk);

	shl	eax, 4
	add	eax, edx
	mov	ecx, eax

; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+48]
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	esi, DWORD PTR __Dest$[esp+88]
	mov	DWORD PTR $T258071[esp+72], esp
	mov	DWORD PTR [eax+16], esi
	mov	eax, DWORD PTR __Last$[esp+72]
	push	eax
	push	ecx
	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T258072[esp+92]
	push	ecx
	call	??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@P6A_NV1@0@Z@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@P6A_NV3@2@Z@Z ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 44					; 0000002cH
$LN101@Chunked_me@7:
	mov	eax, DWORD PTR $T258072[esp+52]
	cmp	eax, edi
	je	SHORT $LN75@Chunked_me@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN75@Chunked_me@7:

; 3454 : 		}
; 3455 : 	}

	mov	eax, DWORD PTR __Dest$[esp+48]
	cmp	eax, edi
	je	SHORT $LN85@Chunked_me@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN85@Chunked_me@7:
	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp-4]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
PUBLIC	??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T258261 = -24						; size = 4
$T258266 = -20						; size = 20
$T258264 = -20						; size = 20
$T258262 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T258263 = 40						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>, COMDAT

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Count$[esp+32]
	lea	ecx, DWORD PTR [eax+eax]
	xor	ebx, ebx
	cmp	ecx, esi
	push	edi
	jg	SHORT $LN3@Chunked_me@8
	mov	edi, eax
	shl	edi, 4
$LL5@Chunked_me@8:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR $T258261[esp+60], esp
	lea	esi, DWORD PTR [edi+ecx]
	push	esi
	push	ecx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ebp, DWORD PTR __Dest$[esp+80]
	push	ecx
	mov	DWORD PTR [eax+16], ebp
	push	edx
	lea	eax, DWORD PTR $T258262[esp+76]
	push	eax
	call	??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T258262[esp+80]
	add	esp, 40					; 00000028H
	mov	DWORD PTR __Dest$[esp+52], ecx
	cmp	eax, ebx
	je	SHORT $LN41@Chunked_me@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Chunked_me@8:
	mov	eax, DWORD PTR __Chunk$[esp+36]

; 3297 : 		_First = _Mid2;

	mov	edx, esi
	mov	esi, DWORD PTR __Count$[esp+36]
	lea	ecx, DWORD PTR [eax+eax]
	sub	esi, ecx
	cmp	esi, ecx
	mov	DWORD PTR __Count$[esp+36], esi
	jge	SHORT $LL5@Chunked_me@8
$LN3@Chunked_me@8:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)
; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	cmp	esi, eax
	mov	DWORD PTR $T258263[esp+56], esp
	jg	SHORT $LN2@Chunked_me@8
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T258264[esp+68]
	push	ecx
	call	??$unchecked_copy@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@0V12@@Z ; stdext::unchecked_copy<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 32					; 00000020H

; 3302 : 	else

	jmp	SHORT $LN99@Chunked_me@8
$LN2@Chunked_me@8:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);

	shl	eax, 4
	add	eax, edx
	mov	ecx, eax

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	esi, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], esi
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	push	ecx
	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T258266[esp+76]
	push	ecx
	call	??$unchecked_merge@PAVCvHomelandUnit@@PAV1@V?$_Temp_iterator@VCvHomelandUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandUnit@@@std@@PAVCvHomelandUnit@@000V12@@Z ; stdext::unchecked_merge<CvHomelandUnit *,CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit> >
	add	esp, 40					; 00000028H
$LN99@Chunked_me@8:
	mov	eax, DWORD PTR $T258266[esp+40]
	cmp	eax, ebx
	je	SHORT $LN75@Chunked_me@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN75@Chunked_me@8:

; 3308 : 		}
; 3309 : 	}

	mov	eax, DWORD PTR __Dest$[esp+36]
	cmp	eax, ebx
	je	SHORT $LN85@Chunked_me@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN85@Chunked_me@8:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>
_TEXT	ENDS
PUBLIC	??0CvHomelandAI@@QAE@XZ				; CvHomelandAI::CvHomelandAI
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\exception
xdata$x	SEGMENT
__ehfuncinfo$??0CvHomelandAI@@QAE@XZ DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$??0CvHomelandAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvHomelandAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CvHomelandAI@@QAE@XZ$9
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ??0CvHomelandAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvHomelandAI@@QAE@XZ PROC				; CvHomelandAI::CvHomelandAI, COMDAT
; _this$ = ecx

; 37   : {

	push	-1
	push	__ehhandler$??0CvHomelandAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	lea	edi, DWORD PTR [esi+4]
	mov	ecx, edi
	call	?_Buynode@?$list@HV?$allocator@H@std@@@std@@IAEPAU_Node@?$_List_nod@HV?$allocator@H@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Buynode
	mov	DWORD PTR [edi+4], eax
	xor	eax, eax
	mov	DWORD PTR [edi+8], eax
	lea	ecx, DWORD PTR [esi+28]
	mov	edx, 64					; 00000040H
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], edx
	mov	DWORD PTR [esi+16], ecx
	lea	ecx, DWORD PTR [esi+1068]
	mov	DWORD PTR [esi+1060], eax
	mov	DWORD PTR [esi+1064], edx
	mov	DWORD PTR [esi+1056], ecx
	lea	ecx, DWORD PTR [esi+2108]
	mov	DWORD PTR [esi+2100], eax
	mov	DWORD PTR [esi+2104], 35		; 00000023H
	mov	DWORD PTR [esi+2096], ecx
	mov	DWORD PTR [esi+2416], eax
	mov	DWORD PTR [esi+2420], eax
	mov	DWORD PTR [esi+2424], eax
	mov	DWORD PTR [esi+2432], eax
	mov	DWORD PTR [esi+2436], eax
	mov	DWORD PTR [esi+2440], eax
	mov	DWORD PTR [esi+2448], eax
	mov	DWORD PTR [esi+2452], eax
	mov	DWORD PTR [esi+2456], eax
	mov	DWORD PTR [esi+2464], eax
	mov	DWORD PTR [esi+2468], eax
	mov	DWORD PTR [esi+2472], eax
	mov	DWORD PTR [esi+2480], eax
	mov	DWORD PTR [esi+2484], eax
	mov	DWORD PTR [esi+2488], eax
	mov	DWORD PTR [esi+2496], eax
	mov	DWORD PTR [esi+2500], eax
	mov	DWORD PTR [esi+2504], eax

; 38   : #ifdef AUI_WARNING_FIXES
; 39   : 	m_pPlayer = NULL;
; 40   : 	Reset();
; 41   : 	m_iRandomRange = 0;
; 42   : 	m_iDefensiveMoveTurns = 0;
; 43   : 	m_iUpgradeMoveTurns = 0;
; 44   : 	m_fFlavorDampening = 0;
; 45   : #endif
; 46   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+2512], eax
	mov	DWORD PTR [esi+2516], eax
	mov	DWORD PTR [esi+2520], eax
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ ; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1056				; 00000420H
	jmp	??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2096				; 00000830H
	jmp	??1?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandMove,35,1,297,0>::~FStaticVector<CvHomelandMove,35,1,297,0>
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2412				; 0000096cH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2428				; 0000097cH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2444				; 0000098cH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2460				; 0000099cH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2476				; 000009acH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__unwindfunclet$??0CvHomelandAI@@QAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2492				; 000009bcH
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__ehhandler$??0CvHomelandAI@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvHomelandAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvHomelandAI@@QAE@XZ ENDP				; CvHomelandAI::CvHomelandAI
PUBLIC	??1CvHomelandAI@@QAE@XZ				; CvHomelandAI::~CvHomelandAI
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\list
xdata$x	SEGMENT
__unwindtable$??1CvHomelandAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvHomelandAI@@QAE@XZ$2
__ehfuncinfo$??1CvHomelandAI@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1CvHomelandAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ??1CvHomelandAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvHomelandAI@@QAE@XZ PROC				; CvHomelandAI::~CvHomelandAI, COMDAT
; _this$ = ecx

; 50   : {

	push	-1
	push	__ehhandler$??1CvHomelandAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi

; 51   : 	Uninit();
; 52   : }

	mov	eax, DWORD PTR [esi+2512]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+32], 2
	cmp	eax, ebx
	je	SHORT $LN21@CvHomeland
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@CvHomeland:
	mov	DWORD PTR [esi+2512], ebx
	mov	DWORD PTR [esi+2516], ebx
	mov	DWORD PTR [esi+2520], ebx
	mov	eax, DWORD PTR [esi+2496]
	cmp	eax, ebx
	je	SHORT $LN28@CvHomeland
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN28@CvHomeland:
	mov	DWORD PTR [esi+2496], ebx
	mov	DWORD PTR [esi+2500], ebx
	mov	DWORD PTR [esi+2504], ebx
	mov	eax, DWORD PTR [esi+2480]
	cmp	eax, ebx
	je	SHORT $LN35@CvHomeland
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN35@CvHomeland:
	mov	DWORD PTR [esi+2480], ebx
	mov	DWORD PTR [esi+2484], ebx
	mov	DWORD PTR [esi+2488], ebx
	mov	eax, DWORD PTR [esi+2464]
	cmp	eax, ebx
	je	SHORT $LN42@CvHomeland
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN42@CvHomeland:
	mov	DWORD PTR [esi+2464], ebx
	mov	DWORD PTR [esi+2468], ebx
	mov	DWORD PTR [esi+2472], ebx
	mov	eax, DWORD PTR [esi+2448]
	cmp	eax, ebx
	je	SHORT $LN49@CvHomeland
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN49@CvHomeland:
	mov	DWORD PTR [esi+2448], ebx
	mov	DWORD PTR [esi+2452], ebx
	mov	DWORD PTR [esi+2456], ebx
	mov	eax, DWORD PTR [esi+2432]
	cmp	eax, ebx
	je	SHORT $LN56@CvHomeland
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@CvHomeland:
	mov	DWORD PTR [esi+2432], ebx
	mov	DWORD PTR [esi+2436], ebx
	mov	DWORD PTR [esi+2440], ebx
	mov	eax, DWORD PTR [esi+2416]
	cmp	eax, ebx
	je	SHORT $LN63@CvHomeland
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN63@CvHomeland:
	mov	DWORD PTR [esi+2416], ebx
	mov	DWORD PTR [esi+2420], ebx
	mov	DWORD PTR [esi+2424], ebx
	mov	eax, DWORD PTR [esi+2096]
	lea	ecx, DWORD PTR [esi+2108]
	cmp	eax, ecx
	je	SHORT $LN67@CvHomeland
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN67@CvHomeland:
	mov	eax, DWORD PTR [esi+1056]
	lea	edx, DWORD PTR [esi+1068]
	mov	BYTE PTR __$EHRec$[esp+32], 1
	cmp	eax, edx
	je	SHORT $LN81@CvHomeland
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN81@CvHomeland:
	mov	eax, DWORD PTR [esi+16]
	lea	ecx, DWORD PTR [esi+28]
	mov	BYTE PTR __$EHRec$[esp+32], bl
	cmp	eax, ecx
	je	SHORT $LN95@CvHomeland
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN95@CvHomeland:
	lea	ecx, DWORD PTR [esi+4]
	call	?_Tidy@?$list@HV?$allocator@H@std@@@std@@IAEXXZ ; std::list<int,std::allocator<int> >::_Tidy
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ ; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
__unwindfunclet$??1CvHomelandAI@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1056				; 00000420H
	jmp	??1?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvHomelandUnit,64,1,297,0>::~FStaticVector<CvHomelandUnit,64,1,297,0>
__ehhandler$??1CvHomelandAI@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvHomelandAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvHomelandAI@@QAE@XZ ENDP				; CvHomelandAI::~CvHomelandAI
PUBLIC	?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotFirstTurnSettlerMoves
EXTRN	?isFound@CvUnit@@QBE_NXZ:PROC			; CvUnit::isFound
EXTRN	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canFound
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_pUnit$225576 = -36					; size = 8
_unit$225580 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::PlotFirstTurnSettlerMoves, COMDAT
; _this$ = ecx

; 917  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp

; 918  : 	ClearCurrentMoveUnits();

	xor	ebx, ebx
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi+20], ebx

; 919  : 
; 920  : 	// Loop through all recruited units
; 921  : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+2396], ebx
	mov	DWORD PTR [edi+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	cmp	ebp, eax
	je	$LN6@PlotFirstT
	push	esi
$LL32@PlotFirstT:

; 922  : 	{
; 923  : 		bool bGoingToSettle = false;
; 924  : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$225576[esp+52], esi
	mov	BYTE PTR _pUnit$225576[esp+56], bl
	cmp	esi, ebx
	je	SHORT $LN55@PlotFirstT
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN55@PlotFirstT:
	mov	DWORD PTR __$EHRec$[esp+60], ebx

; 925  : 		if(pUnit && !pUnit->isHuman())

	cmp	esi, ebx
	je	SHORT $LN96@PlotFirstT
	mov	ecx, esi
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	jne	SHORT $LN96@PlotFirstT

; 926  : 		{
; 927  : 			if(m_pPlayer->getNumCities() == 0 && m_CurrentMoveUnits.size() == 0)

	mov	ecx, DWORD PTR [edi]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	test	eax, eax
	jne	SHORT $LN96@PlotFirstT
	cmp	DWORD PTR [edi+20], ebx
	jne	SHORT $LN96@PlotFirstT

; 928  : 			{
; 929  : 				if(pUnit->canFound(pUnit->plot()))

	push	ebx
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canFound
	test	al, al
	je	SHORT $LN96@PlotFirstT

; 930  : 				{
; 931  : 					CvHomelandUnit unit;
; 932  : 					unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [esi+100]

; 933  : 					m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225580[esp+52]
	mov	DWORD PTR _unit$225580[esp+52], ecx
	push	edx
	lea	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR _unit$225580[esp+60], ebx
	mov	DWORD PTR _unit$225580[esp+64], ebx
	mov	DWORD PTR _unit$225580[esp+68], ebx
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back

; 934  : 					bGoingToSettle = true;
; 935  : 				}
; 936  : 			}
; 937  : 		}
; 938  : 
; 939  : 		// If we find a settler that isn't in an operation, let's keep him in place
; 940  : 		if(!bGoingToSettle && pUnit->isFound() && pUnit->getArmyID() == FFreeList::INVALID_INDEX)

	jmp	SHORT $LN97@PlotFirstT
$LN96@PlotFirstT:
	mov	ecx, esi
	call	?isFound@CvUnit@@QBE_NXZ		; CvUnit::isFound
	test	al, al
	je	SHORT $LN97@PlotFirstT
	mov	ecx, esi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	SHORT $LN97@PlotFirstT

; 941  : 		{
; 942  : 			pUnit->PushMission(CvTypes::getMISSION_SKIP());

	push	ebx
	push	ebx
	push	eax
	push	ebx
	push	ebx
	push	ebx
	push	eax
	push	eax
	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 943  : 			pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN97@PlotFirstT:

; 944  : 		}
; 945  : 	}

	mov	DWORD PTR __$EHRec$[esp+60], -1
	cmp	esi, ebx
	je	SHORT $LN7@PlotFirstT
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN7@PlotFirstT:
	mov	ebp, DWORD PTR [ebp]
	cmp	ebp, DWORD PTR [edi+8]
	jne	$LL32@PlotFirstT
	pop	esi
$LN6@PlotFirstT:

; 946  : 
; 947  : 	if(!m_CurrentMoveUnits.empty())

	cmp	DWORD PTR [edi+20], ebx
	je	SHORT $LN1@PlotFirstT

; 948  : 	{
; 949  : 		ExecuteFirstTurnSettlerMoves();

	mov	ecx, edi
	call	?ExecuteFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteFirstTurnSettlerMoves
$LN1@PlotFirstT:

; 950  : 	}
; 951  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 36					; 00000024H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225576[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::PlotFirstTurnSettlerMoves
PUBLIC	?PlotHealMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotHealMoves
EXTRN	?IsUnderEnemyRangedAttack@CvUnit@@QBE_NXZ:PROC	; CvUnit::IsUnderEnemyRangedAttack
EXTRN	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsFriendlyTerritory
EXTRN	?GetMaxHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetMaxHitPoints
EXTRN	?GetCurrHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetCurrHitPoints
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotHealMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotHealMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotHealMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotHealMoves@CvHomelandAI@@AAEXXZ$2
__ehfuncinfo$?PlotHealMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?PlotHealMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotHealMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$225608 = -96					; size = 4
_pUnit$225614 = -92					; size = 8
_unit$225620 = -84					; size = 16
_strTemp$225623 = -68					; size = 28
_strLogString$225622 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?PlotHealMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotHealMoves, COMDAT
; _this$ = ecx

; 998  : {

	push	-1
	push	__ehhandler$?PlotHealMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	ebp

; 999  : 	ClearCurrentMoveUnits();

	xor	ebx, ebx
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi+20], ebx

; 1000 : 
; 1001 : 	// Loop through all recruited units
; 1002 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+2396], ebx
	mov	DWORD PTR [edi+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _it$225608[esp+108], ebp
	cmp	ebp, eax
	je	$LN8@PlotHealMo
	push	esi
$LL36@PlotHealMo:

; 1003 : 	{
; 1004 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$225614[esp+112], esi
	mov	BYTE PTR _pUnit$225614[esp+116], bl
	cmp	esi, ebx
	je	SHORT $LN59@PlotHealMo
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN59@PlotHealMo:
	mov	DWORD PTR __$EHRec$[esp+120], ebx

; 1005 : 		if(pUnit && !pUnit->isHuman())

	cmp	esi, ebx
	je	$LN2@PlotHealMo
	mov	ecx, esi
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	jne	$LN2@PlotHealMo

; 1006 : 		{
; 1007 : 			// Am I under 100% health and not at sea or already in a city?
; 1008 : #ifdef AUI_HOMELAND_TWEAKED_HEAL_MOVES
; 1009 : 			if (pUnit->healRate(pUnit->plot()) <= 0 || pUnit->isAlwaysHeal() || pUnit->isEmbarked())
; 1010 : 				continue;
; 1011 : 			if (((m_pPlayer->GetPlotDanger(*(pUnit->plot())) <= 0 && pUnit->GetCurrHitPoints() < pUnit->GetMaxHitPoints()) ||
; 1012 : 				(m_pPlayer->GetPlotDanger(*(pUnit->plot())) > 0 && pUnit->GetCurrHitPoints() + pUnit->healRate(pUnit->plot()) < pUnit->GetMaxHitPoints())))
; 1013 : #else
; 1014 : 			if(pUnit->GetCurrHitPoints() < pUnit->GetMaxHitPoints() && !pUnit->isEmbarked() && !pUnit->plot()->isCity())

	mov	ecx, esi
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	mov	ecx, esi
	mov	ebp, eax
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	cmp	ebp, eax
	jge	$LN142@PlotHealMo
	cmp	BYTE PTR [esi+1652], bl
	jne	$LN142@PlotHealMo
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, DWORD PTR [eax+104]
	cmp	ecx, ebx
	jl	SHORT $LN141@PlotHealMo
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN141@PlotHealMo
	mov	edx, DWORD PTR [eax+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	cmp	al, bl
	jne	$LN142@PlotHealMo
$LN141@PlotHealMo:

; 1015 : #endif
; 1016 : 			{
; 1017 : 				// If I'm a naval unit I need to be in friendly territory
; 1018 : 				if(pUnit->getDomainType() != DOMAIN_SEA || pUnit->plot()->IsFriendlyTerritory(m_pPlayer->GetID()))

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN4@PlotHealMo
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	test	al, al
	je	$LN142@PlotHealMo
$LN4@PlotHealMo:

; 1019 : 				{
; 1020 : 					if (!pUnit->IsUnderEnemyRangedAttack())

	mov	ecx, esi
	call	?IsUnderEnemyRangedAttack@CvUnit@@QBE_NXZ ; CvUnit::IsUnderEnemyRangedAttack
	test	al, al
	jne	$LN142@PlotHealMo

; 1021 : 					{
; 1022 : 						CvHomelandUnit unit;
; 1023 : 						unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [esi+100]

; 1024 : 						m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$225620[esp+112]
	mov	DWORD PTR _unit$225620[esp+112], ecx
	push	edx
	lea	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR _unit$225620[esp+120], ebx
	mov	DWORD PTR _unit$225620[esp+124], ebx
	mov	DWORD PTR _unit$225620[esp+128], ebx
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back

; 1025 : 
; 1026 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN142@PlotHealMo
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN142@PlotHealMo

; 1027 : 						{
; 1028 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225622[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1029 : 							CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$225623[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1030 : 
; 1031 : 							strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+120], 2
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$225623[esp+116]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1032 : 							strLogString.Format("%s healing at, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$225623[esp+120]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$225622[esp+124]
	push	OFFSET $SG225624
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1033 : 							LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$225622[esp+112]
	push	ecx
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1034 : 						}

	lea	ecx, DWORD PTR _strTemp$225623[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$225622[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN142@PlotHealMo:
	mov	ebp, DWORD PTR _it$225608[esp+112]
$LN2@PlotHealMo:

; 1035 : 					}
; 1036 : 				}
; 1037 : 			}
; 1038 : 		}
; 1039 : 	}

	mov	DWORD PTR __$EHRec$[esp+120], -1
	cmp	esi, ebx
	je	SHORT $LN9@PlotHealMo
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@PlotHealMo:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$225608[esp+112], ebp
	cmp	ebp, DWORD PTR [edi+8]
	jne	$LL36@PlotHealMo
	pop	esi
$LN8@PlotHealMo:

; 1040 : 
; 1041 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [edi+20], ebx
	jbe	SHORT $LN1@PlotHealMo

; 1042 : 	{
; 1043 : 		ExecuteHeals();

	mov	ecx, edi
	call	?ExecuteHeals@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteHeals
$LN1@PlotHealMo:

; 1044 : 	}
; 1045 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 96					; 00000060H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotHealMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225614[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotHealMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$225622[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotHealMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$225623[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotHealMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotHealMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotHealMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotHealMoves
PUBLIC	?PlotPatrolMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotPatrolMoves
EXTRN	?isTrade@CvUnit@@QBE_NXZ:PROC			; CvUnit::isTrade
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ$2
__ehfuncinfo$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotPatrolMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$225771 = -96					; size = 4
_pUnit$225777 = -92					; size = 8
_unit$225781 = -84					; size = 16
_strTemp$225784 = -68					; size = 28
_strLogString$225783 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?PlotPatrolMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotPatrolMoves, COMDAT
; _this$ = ecx

; 1369 : {

	push	-1
	push	__ehhandler$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 84					; 00000054H
	push	ebx

; 1370 : 	ClearCurrentMoveUnits();

	xor	ebx, ebx
	push	ebp
	mov	ebp, ecx
	mov	DWORD PTR [ebp+20], ebx

; 1371 : 
; 1372 : 	// Loop through all remaining units
; 1373 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebp+2396], ebx
	mov	DWORD PTR [ebp+2400], 2147483647	; 7fffffffH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _it$225771[esp+104], ecx
	cmp	ecx, eax
	je	$LN5@PlotPatrol
	push	esi
	push	edi
$LL129@PlotPatrol:

; 1374 : 	{
; 1375 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR _it$225771[esp+112]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$225777[esp+112], esi
	mov	BYTE PTR _pUnit$225777[esp+116], bl
	cmp	esi, ebx
	je	SHORT $LN56@PlotPatrol
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN56@PlotPatrol:
	mov	DWORD PTR __$EHRec$[esp+120], ebx

; 1376 : 		if(pUnit && !pUnit->isHuman() && pUnit->getDomainType() != DOMAIN_AIR && !pUnit->isTrade())

	cmp	esi, ebx
	je	$LN130@PlotPatrol
	mov	ecx, esi
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	jne	$LN130@PlotPatrol
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	$LN130@PlotPatrol
	mov	ecx, esi
	call	?isTrade@CvUnit@@QBE_NXZ		; CvUnit::isTrade
	test	al, al
	jne	$LN130@PlotPatrol

; 1377 : 		{
; 1378 : #ifdef AUI_HOMELAND_FIND_PATROL_MOVES_CIVILIANS_PATROL_TO_SAFETY
; 1379 : 			if (!pUnit->IsCombatUnit())
; 1380 : 			{
; 1381 : 				MoveCivilianToSafety(pUnit.pointer());
; 1382 : 				continue;
; 1383 : 			}
; 1384 : #endif
; 1385 : 			CvPlot* pTarget = FindPatrolTarget(pUnit.pointer());

	push	esi
	mov	ecx, ebp
	call	?FindPatrolTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z ; CvHomelandAI::FindPatrolTarget
	mov	edi, eax

; 1386 : 			if(pTarget)

	cmp	edi, ebx
	je	$LN130@PlotPatrol

; 1387 : 			{
; 1388 : 				CvHomelandUnit unit;
; 1389 : 				unit.SetID(pUnit->GetID());

	mov	edx, DWORD PTR [esi+100]

; 1390 : 				unit.SetTarget(pTarget);
; 1391 : 				m_CurrentMoveUnits.push_back(unit);

	lea	eax, DWORD PTR _unit$225781[esp+112]
	push	eax
	lea	ecx, DWORD PTR [ebp+16]
	mov	DWORD PTR _unit$225781[esp+120], ebx
	mov	DWORD PTR _unit$225781[esp+124], ebx
	mov	DWORD PTR _unit$225781[esp+116], edx
	mov	DWORD PTR _unit$225781[esp+128], edi
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back

; 1392 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN130@PlotPatrol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN130@PlotPatrol

; 1393 : 				{
; 1394 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225783[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1395 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$225784[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1396 : 
; 1397 : 					strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+120], 2
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strTemp$225784[esp+116]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1398 : 					strLogString.Format("%s (%d) patrolling to, X: %d, Y: %d, Current X: %d, Current Y: %d", strTemp.GetCString(), pUnit->GetID(), pTarget->getX(), pTarget->getY(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	movsx	edx, WORD PTR [edi+2]
	movsx	edi, WORD PTR [edi]
	mov	ebx, DWORD PTR [esi+100]
	push	eax
	push	ecx
	push	edx
	push	edi
	push	ebx
	lea	ecx, DWORD PTR _strTemp$225784[esp+132]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$225783[esp+136]
	push	OFFSET $SG225785
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 32					; 00000020H

; 1399 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$225783[esp+112]
	push	edx
	mov	ecx, ebp
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1400 : 				}

	lea	ecx, DWORD PTR _strTemp$225784[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ebx, ebx
	lea	ecx, DWORD PTR _strLogString$225783[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN130@PlotPatrol:

; 1401 : 			}
; 1402 : 		}
; 1403 : 	}

	mov	DWORD PTR __$EHRec$[esp+120], -1
	cmp	esi, ebx
	je	SHORT $LN6@PlotPatrol
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@PlotPatrol:
	mov	eax, DWORD PTR _it$225771[esp+112]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _it$225771[esp+112], eax
	cmp	eax, DWORD PTR [ebp+8]
	jne	$LL129@PlotPatrol
	pop	edi
	pop	esi
$LN5@PlotPatrol:

; 1404 : 
; 1405 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebp+20], ebx
	jbe	SHORT $LN1@PlotPatrol

; 1406 : 	{
; 1407 : 		ExecutePatrolMoves();

	mov	ecx, ebp
	call	?ExecutePatrolMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecutePatrolMoves
$LN1@PlotPatrol:

; 1408 : 	}
; 1409 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 96					; 00000060H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225777[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$225783[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$225784[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotPatrolMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotPatrolMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotPatrolMoves
PUBLIC	?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotMissionaryMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$226050 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$226056 = -36					; size = 8
_unit$226059 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotMissionaryMoves, COMDAT
; _this$ = ecx

; 1866 : {

	push	-1
	push	__ehhandler$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 1867 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 1868 : 
; 1869 : 	// Loop through all recruited units
; 1870 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$226050[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotMissio
	push	edi
	jmp	SHORT $LN30@PlotMissio
	npad	3
$LL85@PlotMissio:
	mov	ebp, DWORD PTR _it$226050[esp+60]
$LN30@PlotMissio:

; 1871 : 	{
; 1872 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$226056[esp+60], edi
	mov	BYTE PTR _pUnit$226056[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotMissio
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotMissio:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 1873 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotMissio

; 1874 : 		{
; 1875 : 			if(pUnit->AI_getUnitAIType() == UNITAI_MISSIONARY)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN86@PlotMissio

; 1876 : 			{
; 1877 : 				CvHomelandUnit unit;
; 1878 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 1879 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$226059[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotMissio
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotMissio:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotMissio
	mov	edx, DWORD PTR _unit$226059[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotMissio:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$226050[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotMissio:

; 1880 : 			}
; 1881 : 		}
; 1882 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotMissio
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotMissio:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$226050[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotMissio
	pop	edi
$LN4@PlotMissio:

; 1883 : 
; 1884 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotMissio

; 1885 : 	{
; 1886 : 		ExecuteMissionaryMoves();

	mov	ecx, ebx
	call	?ExecuteMissionaryMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteMissionaryMoves
$LN1@PlotMissio:

; 1887 : 	}
; 1888 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226056[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotMissionaryMoves
PUBLIC	?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotInquisitorMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$226068 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$226074 = -36					; size = 8
_unit$226077 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotInquisitorMoves, COMDAT
; _this$ = ecx

; 1892 : {

	push	-1
	push	__ehhandler$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 1893 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 1894 : 
; 1895 : 	// Loop through all recruited units
; 1896 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$226068[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotInquis
	push	edi
	jmp	SHORT $LN30@PlotInquis
	npad	3
$LL85@PlotInquis:
	mov	ebp, DWORD PTR _it$226068[esp+60]
$LN30@PlotInquis:

; 1897 : 	{
; 1898 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$226074[esp+60], edi
	mov	BYTE PTR _pUnit$226074[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotInquis
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotInquis:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 1899 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotInquis

; 1900 : 		{
; 1901 : 			if(pUnit->AI_getUnitAIType() == UNITAI_INQUISITOR)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 36					; 00000024H
	jne	SHORT $LN86@PlotInquis

; 1902 : 			{
; 1903 : 				CvHomelandUnit unit;
; 1904 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 1905 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$226077[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotInquis
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotInquis:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotInquis
	mov	edx, DWORD PTR _unit$226077[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotInquis:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$226068[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotInquis:

; 1906 : 			}
; 1907 : 		}
; 1908 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotInquis
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotInquis:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$226068[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotInquis
	pop	edi
$LN4@PlotInquis:

; 1909 : 
; 1910 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotInquis

; 1911 : 	{
; 1912 : 		ExecuteInquisitorMoves();

	mov	ecx, ebx
	call	?ExecuteInquisitorMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteInquisitorMoves
$LN1@PlotInquis:

; 1913 : 	}
; 1914 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226074[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotInquisitorMoves
PUBLIC	?PlotSSPartMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotSSPartMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotSSPartMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$226086 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$226092 = -36					; size = 8
_unit$226095 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotSSPartMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotSSPartMoves, COMDAT
; _this$ = ecx

; 1918 : {

	push	-1
	push	__ehhandler$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 1919 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 1920 : 
; 1921 : 	// Loop through all recruited units
; 1922 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$226086[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotSSPart
	push	edi
	jmp	SHORT $LN30@PlotSSPart
	npad	3
$LL85@PlotSSPart:
	mov	ebp, DWORD PTR _it$226086[esp+60]
$LN30@PlotSSPart:

; 1923 : 	{
; 1924 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$226092[esp+60], edi
	mov	BYTE PTR _pUnit$226092[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotSSPart
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotSSPart:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 1925 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotSSPart

; 1926 : 		{
; 1927 : 			if(pUnit->AI_getUnitAIType() == UNITAI_SPACESHIP_PART)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN86@PlotSSPart

; 1928 : 			{
; 1929 : 				CvHomelandUnit unit;
; 1930 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 1931 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$226095[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotSSPart
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotSSPart:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotSSPart
	mov	edx, DWORD PTR _unit$226095[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotSSPart:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$226086[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotSSPart:

; 1932 : 			}
; 1933 : 		}
; 1934 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotSSPart
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotSSPart:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$226086[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotSSPart
	pop	edi
$LN4@PlotSSPart:

; 1935 : 
; 1936 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotSSPart

; 1937 : 	{
; 1938 : 		ExecuteSSPartMoves();

	mov	ecx, ebx
	call	?ExecuteSSPartMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteSSPartMoves
$LN1@PlotSSPart:

; 1939 : 	}
; 1940 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226092[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotSSPartMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotSSPartMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotSSPartMoves
PUBLIC	?PlotSSPartAdds@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotSSPartAdds
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotSSPartAdds@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$226104 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$226110 = -36					; size = 8
_unit$226113 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotSSPartAdds@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotSSPartAdds, COMDAT
; _this$ = ecx

; 1944 : {

	push	-1
	push	__ehhandler$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 1945 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 1946 : 
; 1947 : 	// Loop through all recruited units
; 1948 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$226104[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotSSPart@2
	push	edi
	jmp	SHORT $LN30@PlotSSPart@2
	npad	3
$LL85@PlotSSPart@2:
	mov	ebp, DWORD PTR _it$226104[esp+60]
$LN30@PlotSSPart@2:

; 1949 : 	{
; 1950 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$226110[esp+60], edi
	mov	BYTE PTR _pUnit$226110[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotSSPart@2
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotSSPart@2:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 1951 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotSSPart@2

; 1952 : 		{
; 1953 : 			if(pUnit->AI_getUnitAIType() == UNITAI_SPACESHIP_PART)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN86@PlotSSPart@2

; 1954 : 			{
; 1955 : 				CvHomelandUnit unit;
; 1956 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 1957 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$226113[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotSSPart@2
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotSSPart@2:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotSSPart@2
	mov	edx, DWORD PTR _unit$226113[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotSSPart@2:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$226104[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotSSPart@2:

; 1958 : 			}
; 1959 : 		}
; 1960 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotSSPart@2
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotSSPart@2:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$226104[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotSSPart@2
	pop	edi
$LN4@PlotSSPart@2:

; 1961 : 
; 1962 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotSSPart@2

; 1963 : 	{
; 1964 : 		ExecuteSSPartAdds();

	mov	ecx, ebx
	call	?ExecuteSSPartAdds@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteSSPartAdds
$LN1@PlotSSPart@2:

; 1965 : 	}
; 1966 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226110[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotSSPartAdds@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotSSPartAdds@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotSSPartAdds
PUBLIC	?PlotTreasureMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotTreasureMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotTreasureMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$226122 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$226128 = -36					; size = 8
_unit$226131 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotTreasureMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotTreasureMoves, COMDAT
; _this$ = ecx

; 1970 : {

	push	-1
	push	__ehhandler$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 1971 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 1972 : 
; 1973 : 	// Loop through all recruited units
; 1974 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$226122[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotTreasu
	push	edi
	jmp	SHORT $LN30@PlotTreasu
	npad	3
$LL85@PlotTreasu:
	mov	ebp, DWORD PTR _it$226122[esp+60]
$LN30@PlotTreasu:

; 1975 : 	{
; 1976 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$226128[esp+60], edi
	mov	BYTE PTR _pUnit$226128[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotTreasu
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotTreasu:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 1977 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotTreasu

; 1978 : 		{
; 1979 : 			if(pUnit->AI_getUnitAIType() == UNITAI_TREASURE)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 33					; 00000021H
	jne	SHORT $LN86@PlotTreasu

; 1980 : 			{
; 1981 : 				CvHomelandUnit unit;
; 1982 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 1983 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$226131[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotTreasu
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotTreasu:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotTreasu
	mov	edx, DWORD PTR _unit$226131[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotTreasu:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$226122[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotTreasu:

; 1984 : 			}
; 1985 : 		}
; 1986 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotTreasu
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotTreasu:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$226122[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotTreasu
	pop	edi
$LN4@PlotTreasu:

; 1987 : 
; 1988 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotTreasu

; 1989 : 	{
; 1990 : 		ExecuteTreasureMoves();

	mov	ecx, ebx
	call	?ExecuteTreasureMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteTreasureMoves
$LN1@PlotTreasu:

; 1991 : 	}
; 1992 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226128[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotTreasureMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotTreasureMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotTreasureMoves
PUBLIC	?PlotAircraftMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotAircraftMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotAircraftMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$226176 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$226182 = -36					; size = 8
_unit$226185 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotAircraftMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotAircraftMoves, COMDAT
; _this$ = ecx

; 2048 : {

	push	-1
	push	__ehhandler$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 2049 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 2050 : 
; 2051 : 	// Loop through all recruited units
; 2052 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$226176[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotAircra
	push	edi
	jmp	SHORT $LN30@PlotAircra
	npad	3
$LL87@PlotAircra:
	mov	ebp, DWORD PTR _it$226176[esp+60]
$LN30@PlotAircra:

; 2053 : 	{
; 2054 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$226182[esp+60], edi
	mov	BYTE PTR _pUnit$226182[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotAircra
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotAircra:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 2055 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN88@PlotAircra

; 2056 : 		{
; 2057 : 			if(pUnit->getDomainType() == DOMAIN_AIR && pUnit->getDamage() < 50)

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN88@PlotAircra
	mov	ecx, edi
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	cmp	eax, 50					; 00000032H
	jge	SHORT $LN88@PlotAircra

; 2058 : 			{
; 2059 : 				CvHomelandUnit unit;
; 2060 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 2061 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$226185[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN71@PlotAircra
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN71@PlotAircra:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN74@PlotAircra
	mov	edx, DWORD PTR _unit$226185[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN74@PlotAircra:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$226176[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN88@PlotAircra:

; 2062 : 			}
; 2063 : 		}
; 2064 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotAircra
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotAircra:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$226176[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL87@PlotAircra
	pop	edi
$LN4@PlotAircra:

; 2065 : 
; 2066 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotAircra

; 2067 : 	{
; 2068 : 		ExecuteAircraftMoves();

	mov	ecx, ebx
	call	?ExecuteAircraftMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteAircraftMoves
$LN1@PlotAircra:

; 2069 : 	}
; 2070 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226182[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotAircraftMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotAircraftMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotAircraftMoves
PUBLIC	?FindArchaeologistTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z ; CvHomelandAI::FindArchaeologistTarget
; Function compile flags: /Ogtpy
;	COMDAT ?FindArchaeologistTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z
_TEXT	SEGMENT
$T261785 = -16						; size = 4
_it$ = -16						; size = 4
_this$ = -12						; size = 4
_iBestTurns$ = -8					; size = 4
_pBestTarget$ = -4					; size = 4
_pUnit$ = 8						; size = 4
?FindArchaeologistTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z PROC ; CvHomelandAI::FindArchaeologistTarget, COMDAT
; _this$ = ecx

; 5797 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	mov	ebx, ecx
	push	esi
	push	edi

; 5798 : 	CvPlot *pBestTarget = NULL;
; 5799 : 	int iBestTurns = MAX_INT;
; 5800 : 
; 5801 : 	// Reverse the logic from most of the Homeland moves; for this we'll loop through units and find the best targets for them (instead of vice versa)
; 5802 : 	std::vector<CvHomelandTarget>::iterator it;
; 5803 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 5804 : 	for (it = m_TargetedAntiquitySites.begin(); it != m_TargetedAntiquitySites.end(); ++it)
; 5805 : #else
; 5806 : 	for (it = m_TargetedAntiquitySites.begin(); it != m_TargetedAntiquitySites.end(); it++)

	mov	edi, DWORD PTR [ebx+2512]
	xor	eax, eax
	mov	DWORD PTR _this$[esp+32], ebx
	mov	DWORD PTR _pBestTarget$[esp+32], eax
	mov	DWORD PTR _iBestTurns$[esp+32], 2147483647 ; 7fffffffH
	mov	DWORD PTR _it$[esp+32], edi
	cmp	edi, DWORD PTR [ebx+2516]
	je	$LN2@FindArchae@2
$LN28@FindArchae@2:

; 5807 : #endif
; 5808 : 	{
; 5809 : 		CvPlot* pTarget = GC.getMap().plot(it->GetTargetX(), it->GetTargetY());

	mov	eax, DWORD PTR [edi+4]
	mov	ebp, DWORD PTR [edi+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN58@FindArchae@2
	cmp	ebp, -2147483647			; 80000001H
	je	$LN58@FindArchae@2
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ebx+4056]
	mov	ecx, DWORD PTR [ebx+4020]
	test	dl, dl
	je	SHORT $LN68@FindArchae@2
	test	eax, eax
	jge	SHORT $LN70@FindArchae@2
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN72@FindArchae@2
$LN70@FindArchae@2:
	cmp	eax, ecx
	jl	SHORT $LN68@FindArchae@2
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN72@FindArchae@2
$LN68@FindArchae@2:
	mov	esi, eax
$LN72@FindArchae@2:
	mov	al, BYTE PTR [ebx+4057]
	mov	edi, DWORD PTR [ebx+4024]
	test	al, al
	je	SHORT $LN78@FindArchae@2
	test	ebp, ebp
	jge	SHORT $LN80@FindArchae@2
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN82@FindArchae@2
$LN80@FindArchae@2:
	cmp	ebp, edi
	jl	SHORT $LN78@FindArchae@2
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN82@FindArchae@2
$LN78@FindArchae@2:
	mov	edx, ebp
$LN82@FindArchae@2:
	test	esi, esi
	jl	SHORT $LN62@FindArchae@2
	cmp	esi, ecx
	jge	SHORT $LN62@FindArchae@2
	test	edx, edx
	jl	SHORT $LN62@FindArchae@2
	cmp	edx, edi
	jge	SHORT $LN62@FindArchae@2
	mov	edi, DWORD PTR _it$[esp+32]
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebx+4068]
	mov	ebx, DWORD PTR _this$[esp+32]
	mov	esi, ecx
	jmp	SHORT $LN60@FindArchae@2
$LN62@FindArchae@2:
	mov	edi, DWORD PTR _it$[esp+32]
	mov	ebx, DWORD PTR _this$[esp+32]
$LN58@FindArchae@2:
	xor	esi, esi
$LN60@FindArchae@2:

; 5810 : 		if (m_pPlayer->GetPlotDanger(*pTarget) == 0)

	mov	ecx, DWORD PTR [ebx]
	push	esi
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	test	eax, eax
	jne	SHORT $LN9@FindArchae@2

; 5811 : 		{
; 5812 : 			int iTurns = TurnsToReachTarget(pUnit, pTarget);

	mov	ecx, DWORD PTR _pUnit$[esp+28]
	push	eax
	push	eax
	push	eax
	push	esi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T261785[esp+56], esp
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 0
	test	ecx, ecx
	je	SHORT $LN99@FindArchae@2
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN99@FindArchae@2:
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 5813 : 
; 5814 : 			if (iTurns < iBestTurns)

	cmp	eax, DWORD PTR _iBestTurns$[esp+32]
	jge	SHORT $LN9@FindArchae@2

; 5815 : 			{
; 5816 : 				pBestTarget = pTarget;

	mov	DWORD PTR _pBestTarget$[esp+32], esi

; 5817 : 				iBestTurns = iTurns;

	mov	DWORD PTR _iBestTurns$[esp+32], eax
$LN9@FindArchae@2:
	add	edi, 20					; 00000014H
	mov	DWORD PTR _it$[esp+32], edi
	cmp	edi, DWORD PTR [ebx+2516]
	jne	$LN28@FindArchae@2

; 5818 : 			}
; 5819 : 		}
; 5820 : 	}
; 5821 : 
; 5822 : 	// Erase this site from future contention
; 5823 : 	if (pBestTarget)

	mov	esi, DWORD PTR _pBestTarget$[esp+32]
	test	esi, esi
	je	SHORT $LN171@FindArchae@2

; 5824 : 	{
; 5825 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 5826 : 		for (it = m_TargetedAntiquitySites.begin(); it != m_TargetedAntiquitySites.end(); ++it)
; 5827 : #else
; 5828 : 		for (it = m_TargetedAntiquitySites.begin(); it != m_TargetedAntiquitySites.end(); it++)

	mov	eax, DWORD PTR [ebx+2512]
	mov	ecx, DWORD PTR [ebx+2516]
	cmp	eax, ecx
	je	SHORT $LN171@FindArchae@2
	movsx	edx, WORD PTR [esi]
	npad	1
$LL111@FindArchae@2:

; 5829 : #endif
; 5830 : 		{
; 5831 : 			if (it->GetTargetX() == pBestTarget->getX() && it->GetTargetY() == pBestTarget->getY())

	cmp	DWORD PTR [eax+4], edx
	jne	SHORT $LN3@FindArchae@2
	movsx	edi, WORD PTR [esi+2]
	cmp	DWORD PTR [eax+8], edi
	je	SHORT $LN165@FindArchae@2
$LN3@FindArchae@2:

; 5824 : 	{
; 5825 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 5826 : 		for (it = m_TargetedAntiquitySites.begin(); it != m_TargetedAntiquitySites.end(); ++it)
; 5827 : #else
; 5828 : 		for (it = m_TargetedAntiquitySites.begin(); it != m_TargetedAntiquitySites.end(); it++)

	add	eax, 20					; 00000014H
	cmp	eax, ecx
	jne	SHORT $LL111@FindArchae@2

; 5834 : 				break;
; 5835 : 			}
; 5836 : 		}
; 5837 : 	}
; 5838 : 
; 5839 : 	return pBestTarget;

	mov	eax, esi

; 5840 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
$LN165@FindArchae@2:

; 5832 : 			{
; 5833 : 				m_TargetedAntiquitySites.erase(it);

	mov	edx, ecx
	add	eax, 20					; 00000014H
	cmp	eax, edx
	je	SHORT $LN151@FindArchae@2
	lea	ecx, DWORD PTR [eax-20]
	npad	3
$LL153@FindArchae@2:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edi
	mov	edi, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edi
	mov	edi, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edi
	add	eax, 20					; 00000014H
	add	ecx, 20					; 00000014H
	cmp	eax, edx
	jne	SHORT $LL153@FindArchae@2
$LN151@FindArchae@2:
	add	DWORD PTR [ebx+2516], -20		; ffffffecH
$LN171@FindArchae@2:

; 5834 : 				break;
; 5835 : 			}
; 5836 : 		}
; 5837 : 	}
; 5838 : 
; 5839 : 	return pBestTarget;

	mov	eax, esi
$LN2@FindArchae@2:

; 5840 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	4
?FindArchaeologistTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z ENDP ; CvHomelandAI::FindArchaeologistTarget
_TEXT	ENDS
PUBLIC	?clear@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXXZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::clear
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?clear@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T262328 = -4						; size = 1
$T262330 = -4						; size = 1
__Cat$262332 = -4					; size = 1
?clear@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXXZ PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx
	push	esi
	mov	esi, ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN15@clear@2
	mov	BYTE PTR $T262328[esp+8], 0
	mov	edx, DWORD PTR $T262328[esp+8]
	push	edx
	mov	edx, DWORD PTR __Cat$262332[esp+12]
	push	edx
	mov	edx, DWORD PTR $T262330[esp+16]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
$LN15@clear@2:
	pop	esi

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::clear
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@ABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@ABVCvHomelandTarget@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@ABVCvHomelandTarget@@@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@IABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi+esi*4]
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@ABVCvHomelandTarget@@@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::insert
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z ; FStaticVector<TradeConnection,168,0,297,0>::Free
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z PROC ; FStaticVector<TradeConnection,168,0,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);

	mov	eax, DWORD PTR _uiNumElements$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _pVal$[esp+4]
	push	eax
	push	edi
	mov	esi, ecx
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy

; 811  : 		if( pVal != (T*)m_aData )

	add	esi, 12					; 0000000cH
	cmp	edi, esi
	je	SHORT $LN1@Free@6

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@Free@6:
	pop	edi
	pop	esi

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z ENDP ; FStaticVector<TradeConnection,168,0,297,0>::Free
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::insert
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@2
	xor	esi, esi
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@2:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@V?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@ABQAVCvPlot@@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::insert
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@3
	xor	esi, esi
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@3:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z
_TEXT	SEGMENT
__Mid$231558 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort:
	test	esi, esi
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$231558[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$231558[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$231558[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$231558[esp+36]
$LN26@Sort:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort
$LN25@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN10@Sort
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,100,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z
_TEXT	SEGMENT
__Mid$231629 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort@2
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort@2:
	test	esi, esi
	jle	SHORT $LN6@Sort@2

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$231629[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvCity *,64,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$231629[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$231629[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort@2
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort@2
$LN5@Sort@2:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$231629[esp+36]
$LN26@Sort@2:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort@2
$LN25@Sort@2:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort@2

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvCity *,64,1>::WeightedElement *,CvWeightedVector<CvCity *,64,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort@2:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort@2

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN10@Sort@2
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int,CvWeightedVector<CvCity *,64,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort@2:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@0@PAU?$pair@HPAVCvPlot@@@0@0P6A_NABU20@1@Z@Z ; std::_Unguarded_partition<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unguarded_partition@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@0@PAU?$pair@HPAVCvPlot@@@0@0P6A_NABU20@1@Z@Z
_TEXT	SEGMENT
__Tmp$262837 = -12					; size = 4
__Plast$ = -12						; size = 4
__Glast$ = -8						; size = 4
__Tmp$263167 = -4					; size = 4
__Tmp$263085 = -4					; size = 4
__Tmp$263004 = -4					; size = 4
__Tmp$262922 = -4					; size = 4
__Tmp$262915 = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Unguarded_partition@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@0@PAU?$pair@HPAVCvPlot@@@0@0P6A_NABU20@1@Z@Z PROC ; std::_Unguarded_partition<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 3185 : 	{	// partition [_First, _Last), using _Pred

	sub	esp, 12					; 0000000cH

; 3186 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

	mov	ecx, DWORD PTR __Last$[esp+8]
	push	ebx
	mov	ebx, DWORD PTR __First$[esp+12]
	mov	eax, ecx
	sub	eax, ebx
	push	ebp
	push	esi
	sar	eax, 3
	push	edi

; 3187 : 	std::_Median(_First, _Mid, _Last - 1, _Pred);

	mov	edi, DWORD PTR __Pred$[esp+24]
	cdq
	sub	eax, edx
	push	edi
	sar	eax, 1
	add	ecx, -8					; fffffff8H
	push	ecx
	lea	esi, DWORD PTR [ebx+eax*8]
	push	esi
	push	ebx
	call	??$_Median@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@00P6A_NABU10@1@Z@Z ; std::_Median<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 16					; 00000010H

; 3188 : 	_RanIt _Pfirst = _Mid;
; 3189 : 	_RanIt _Plast = _Pfirst + 1;

	lea	ebp, DWORD PTR [esi+8]
	mov	DWORD PTR __Plast$[esp+28], ebp

; 3190 : 
; 3191 : 	while (_First < _Pfirst
; 3192 : 		&& !_DEBUG_LT_PRED(_Pred, *(_Pfirst - 1), *_Pfirst)
; 3193 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

	cmp	ebx, esi
	jae	SHORT $LN153@Unguarded_@3
	npad	4
$LL27@Unguarded_@3:
	lea	edi, DWORD PTR [esi-8]
	push	esi
	push	edi
	call	DWORD PTR __Pred$[esp+32]
	add	esp, 8
	test	al, al
	jne	SHORT $LN177@Unguarded_@3
	push	edi
	push	esi
	call	DWORD PTR __Pred$[esp+32]
	add	esp, 8
	test	al, al
	jne	SHORT $LN177@Unguarded_@3

; 3194 : 		--_Pfirst;

	mov	esi, edi
	cmp	ebx, esi
	jb	SHORT $LL27@Unguarded_@3
$LN177@Unguarded_@3:

; 3190 : 
; 3191 : 	while (_First < _Pfirst
; 3192 : 		&& !_DEBUG_LT_PRED(_Pred, *(_Pfirst - 1), *_Pfirst)
; 3193 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

	mov	edi, DWORD PTR __Pred$[esp+24]
$LN153@Unguarded_@3:

; 3195 : 	while (_Plast < _Last
; 3196 : 		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
; 3197 : 		&& !_Pred(*_Pfirst, *_Plast))

	mov	ebx, DWORD PTR __Last$[esp+24]
	cmp	ebp, ebx
	jae	SHORT $LN24@Unguarded_@3
	npad	1
$LL25@Unguarded_@3:
	push	esi
	push	ebp
	call	edi
	add	esp, 8
	test	al, al
	jne	SHORT $LN179@Unguarded_@3
	push	ebp
	push	esi
	call	edi
	add	esp, 8
	test	al, al
	jne	SHORT $LN179@Unguarded_@3

; 3198 : 		++_Plast;

	add	ebp, 8
	cmp	ebp, ebx
	jb	SHORT $LL25@Unguarded_@3
$LN179@Unguarded_@3:
	mov	DWORD PTR __Plast$[esp+28], ebp
$LN24@Unguarded_@3:

; 3199 : 
; 3200 : 	_RanIt _Gfirst = _Plast;
; 3201 : 	_RanIt _Glast = _Pfirst;

	mov	edx, esi
	mov	ebx, ebp
	mov	DWORD PTR __Glast$[esp+28], edx
	npad	7
$LL23@Unguarded_@3:

; 3202 : 
; 3203 : 	for (; ; )
; 3204 : 		{	// partition
; 3205 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	ebx, DWORD PTR __Last$[esp+24]
	jae	SHORT $LN157@Unguarded_@3
	lea	edi, DWORD PTR [ebx+4]
	npad	7
$LL21@Unguarded_@3:

; 3206 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

	push	ebx
	push	esi
	call	DWORD PTR __Pred$[esp+32]
	add	esp, 8
	test	al, al
	jne	SHORT $LN20@Unguarded_@3

; 3207 : 				;
; 3208 : 			else if (_Pred(*_Gfirst, *_Pfirst))

	push	esi
	push	ebx
	call	DWORD PTR __Pred$[esp+32]
	add	esp, 8
	test	al, al
	jne	SHORT $LN181@Unguarded_@3

; 3209 : 				break;
; 3210 : 			else
; 3211 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	eax, ebp
	add	ebp, 8
	cmp	eax, ebx
	je	SHORT $LN20@Unguarded_@3
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ebx]
	mov	DWORD PTR [eax], edx
	add	eax, 4
	mov	DWORD PTR [ebx], ecx
	cmp	eax, edi
	je	SHORT $LN20@Unguarded_@3
	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [edi], ecx
$LN20@Unguarded_@3:
	add	ebx, 8
	add	edi, 8
	cmp	ebx, DWORD PTR __Last$[esp+24]
	jb	SHORT $LL21@Unguarded_@3
$LN181@Unguarded_@3:

; 3202 : 
; 3203 : 	for (; ; )
; 3204 : 		{	// partition
; 3205 : 		for (; _Gfirst < _Last; ++_Gfirst)

	mov	edx, DWORD PTR __Glast$[esp+28]

; 3209 : 				break;
; 3210 : 			else
; 3211 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	DWORD PTR __Plast$[esp+28], ebp
$LN157@Unguarded_@3:

; 3212 : 		for (; _First < _Glast; --_Glast)

	cmp	edx, DWORD PTR __First$[esp+24]
	jbe	SHORT $LN182@Unguarded_@3
	lea	ebp, DWORD PTR [esi+4]
	lea	edi, DWORD PTR [edx-8]
	npad	6
$LL14@Unguarded_@3:

; 3213 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

	push	esi
	push	edi
	call	DWORD PTR __Pred$[esp+32]
	add	esp, 8
	test	al, al
	jne	SHORT $LN13@Unguarded_@3

; 3214 : 				;
; 3215 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

	push	edi
	push	esi
	call	DWORD PTR __Pred$[esp+32]
	add	esp, 8
	test	al, al
	jne	SHORT $LN174@Unguarded_@3

; 3216 : 				break;
; 3217 : 			else
; 3218 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	esi, 8
	sub	ebp, 8
	cmp	esi, edi
	je	SHORT $LN13@Unguarded_@3
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [edi], eax
	lea	eax, DWORD PTR [edi+4]
	cmp	ebp, eax
	je	SHORT $LN13@Unguarded_@3
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [ebp], edx
	mov	DWORD PTR [eax], ecx
$LN13@Unguarded_@3:
	mov	eax, DWORD PTR __Glast$[esp+28]
	sub	eax, 8
	sub	edi, 8
	mov	DWORD PTR __Glast$[esp+28], eax
	cmp	DWORD PTR __First$[esp+24], eax
	jb	SHORT $LL14@Unguarded_@3
$LN174@Unguarded_@3:

; 3212 : 		for (; _First < _Glast; --_Glast)

	mov	edx, DWORD PTR __Glast$[esp+28]
	mov	ebp, DWORD PTR __Plast$[esp+28]

; 3219 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	edx, DWORD PTR __First$[esp+24]
$LN182@Unguarded_@3:
	jne	$LN6@Unguarded_@3
	cmp	ebx, DWORD PTR __Last$[esp+24]
	je	$LN159@Unguarded_@3

; 3221 : 
; 3222 : 		if (_Glast == _First)
; 3223 : 			{	// no room at bottom, rotate pivot upward
; 3224 : 			if (_Plast != _Gfirst)

	cmp	ebp, ebx
	je	SHORT $LN80@Unguarded_@3

; 3225 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	esi, ebp
	je	SHORT $LN80@Unguarded_@3
	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [ebp], eax
	lea	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN80@Unguarded_@3
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$262837[esp+28], edi
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	ecx, DWORD PTR __Tmp$262837[esp+28]
	mov	DWORD PTR [eax], ecx
$LN80@Unguarded_@3:

; 3226 : 			++_Plast;
; 3227 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	eax, ebx
	mov	ecx, esi
	add	ebp, 8
	add	esi, 8
	add	ebx, 8
	mov	DWORD PTR __Plast$[esp+28], ebp
	cmp	ecx, eax
	je	$LL23@Unguarded_@3
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$262915[esp+28], edi
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR __Tmp$262915[esp+28]
	mov	DWORD PTR [eax], edi
	add	eax, 4
	add	ecx, 4
	cmp	ecx, eax
	je	$LL23@Unguarded_@3
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$262922[esp+28], edi
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	ecx, DWORD PTR __Tmp$262922[esp+28]
	mov	DWORD PTR [eax], ecx
	jmp	$LL23@Unguarded_@3
$LN6@Unguarded_@3:

; 3228 : 			}
; 3229 : 		else if (_Gfirst == _Last)
; 3230 : 			{	// no room at top, rotate pivot downward
; 3231 : 			if (--_Glast != --_Pfirst)

	sub	edx, 8
	mov	DWORD PTR __Glast$[esp+28], edx
	cmp	ebx, DWORD PTR __Last$[esp+24]
	jne	SHORT $LN3@Unguarded_@3
	sub	esi, 8
	cmp	edx, esi
	je	SHORT $LN114@Unguarded_@3

; 3232 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [esi], eax
	lea	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [edx+4]
	cmp	ecx, eax
	je	SHORT $LN114@Unguarded_@3
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$263004[esp+28], edi
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	ecx, DWORD PTR __Tmp$263004[esp+28]
	mov	DWORD PTR [eax], ecx
$LN114@Unguarded_@3:

; 3233 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	ebp, 8
	mov	DWORD PTR __Plast$[esp+28], ebp
	cmp	esi, ebp
	je	$LL23@Unguarded_@3
	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [ebp], eax
	lea	eax, DWORD PTR [ebp+4]
	lea	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	$LL23@Unguarded_@3
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$263085[esp+28], edi
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	ecx, DWORD PTR __Tmp$263085[esp+28]
	mov	DWORD PTR [eax], ecx

; 3234 : 			}
; 3235 : 		else

	jmp	$LL23@Unguarded_@3
$LN3@Unguarded_@3:

; 3236 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	ebx, edx
	je	SHORT $LN148@Unguarded_@3
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [edx], eax
	lea	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [ebx+4]
	cmp	ecx, eax
	je	SHORT $LN148@Unguarded_@3
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$263167[esp+28], edi
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	ecx, DWORD PTR __Tmp$263167[esp+28]
	mov	DWORD PTR [eax], ecx
$LN148@Unguarded_@3:
	add	ebx, 8

; 3237 : 		}

	jmp	$LL23@Unguarded_@3
$LN159@Unguarded_@3:

; 3220 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	mov	DWORD PTR [eax+4], ebp
	pop	ebp
	pop	ebx

; 3238 : 	}

	add	esp, 12					; 0000000cH
	ret	0
??$_Unguarded_partition@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@0@PAU?$pair@HPAVCvPlot@@@0@0P6A_NABU20@1@Z@Z ENDP ; std::_Unguarded_partition<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z
_TEXT	SEGMENT
$T263331 = -8						; size = 1
$T263302 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T263301 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z PROC ; std::_Buffered_merge_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>, COMDAT

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@4
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@4:

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;
; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	lea	esi, DWORD PTR [eax+640]

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	push	ebx
	push	esi
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAVCvHomelandTarget@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>
	add	esp, 12					; 0000000cH
	sub	ebp, 1

; 3363 : 		_Mid = _Midend;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@4
$LN4@Buffered_m@4:

; 3364 : 		}
; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAVCvHomelandTarget@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 12					; 0000000cH
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@4
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
$LL3@Buffered_m@4:

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebp+16]
	mov	BYTE PTR $T263301[esp+20], bl
	mov	eax, DWORD PTR $T263301[esp+20]
	push	eax
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	edx, DWORD PTR __First$[esp+52]
	mov	DWORD PTR $T263302[esp+56], esp
	push	ecx
	push	edx
	call	??$_Chunked_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@H@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0V?$_Temp_iterator@VCvHomelandTarget@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget>,int>

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+60]
	mov	BYTE PTR $T263331[esp+64], bl
	mov	ecx, DWORD PTR $T263331[esp+64]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@H@std@@YAXPAVCvHomelandTarget@@0V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int>
	add	esi, esi
	add	esp, 64					; 00000040H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@4
$LN1@Buffered_m@4:

; 3373 : 		}
; 3374 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ENDP ; std::_Buffered_merge_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z
_TEXT	SEGMENT
tv515 = -24						; size = 4
$T263640 = -24						; size = 4
$T263551 = -24						; size = 4
$T263346 = -20						; size = 20
$T263343 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T263483 = 20						; size = 1
__Midn$233174 = 20					; size = 4
$T263347 = 20						; size = 4
$T263345 = 20						; size = 4
$T263344 = 20						; size = 4
$T263342 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z PROC ; std::_Buffered_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>, COMDAT

; 2759 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	ebx, DWORD PTR __Count1$[esp+24]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+36]
	lea	eax, DWORD PTR [ebx+edi]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@5

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp+36]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR __First$[esp+36]
	cmp	edx, DWORD PTR [ecx+16]
	jle	$LN3@Buffered_m@5

; 2763 : 			std::iter_swap(_First, _Mid);

	push	eax
	push	ecx
	call	??$swap@VCvHomelandTarget@@@std@@YAXAAVCvHomelandTarget@@0@Z ; std::swap<CvHomelandTarget>
	add	esp, 8

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN9@Buffered_m@5:

; 2764 : 		}
; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	ebx, edi
	mov	esi, DWORD PTR __Tempbuf$[esp+36]
	jg	$LN6@Buffered_m@5
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen
	cmp	ebx, eax
	jg	SHORT $LN6@Buffered_m@5

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Mid$[esp+56]
	mov	ecx, DWORD PTR __First$[esp+56]
	mov	DWORD PTR $T263342[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T263343[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	mov	eax, DWORD PTR $T263343[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN50@Buffered_m@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN50@Buffered_m@5:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	eax, DWORD PTR __First$[esp+36]
	mov	ecx, DWORD PTR __Last$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR __Mid$[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T263344[esp+56]
	push	edx
	call	??$unchecked_merge@PAVCvHomelandTarget@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V23@@stdext@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@0V12@11@Z ; stdext::unchecked_merge<CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
	add	esp, 24					; 00000018H

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN6@Buffered_m@5:

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_m@5

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebx, ebx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last$[esp+56]
	mov	ecx, DWORD PTR __Mid$[esp+56]
	mov	DWORD PTR $T263345[esp+56], esp
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T263346[esp+68]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@V?$_Temp_iterator@VCvHomelandTarget@@@2@@stdext@@YA?AV?$_Temp_iterator@VCvHomelandTarget@@@std@@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,std::_Temp_iterator<CvHomelandTarget> >
	mov	eax, DWORD PTR $T263346[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN70@Buffered_m@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN70@Buffered_m@5:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	esi, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR __Last$[esp+36]
	mov	edx, DWORD PTR [esi+4]
	mov	BYTE PTR $T263483[esp+36], bl
	mov	eax, DWORD PTR $T263483[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	ecx, DWORD PTR __Mid$[esp+44]
	push	edx
	mov	edx, DWORD PTR __First$[esp+48]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T263347[esp+60]
	push	eax
	call	??$_Merge_backward@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@PAVCvHomelandTarget@@V12@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0PAVCvHomelandTarget@@10U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget *,std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
	add	esp, 28					; 0000001cH

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN4@Buffered_m@5:

; 2775 : 		}
; 2776 : 	else
; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	cmp	edi, ebx

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2784 : 			_Firstn = _First;
; 2785 : 			std::advance(_Firstn, _Count1n);
; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	push	0
	jge	SHORT $LN2@Buffered_m@5
	mov	esi, DWORD PTR __Mid$[esp+40]
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+40]
	mov	edi, eax
	mov	eax, DWORD PTR __Last$[esp+40]
	sar	edi, 1
	lea	ecx, DWORD PTR [edi+edi*4]
	lea	ebp, DWORD PTR [edx+ecx*4]
	push	ebp
	push	eax
	lea	ecx, DWORD PTR $T263551[esp+52]
	push	esi
	push	ecx
	call	??$_Lower_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>
	mov	ebx, DWORD PTR [eax]

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esp, 20					; 00000014H
	add	esi, edx

; 2788 : 			}
; 2789 : 		else

	jmp	SHORT $LN136@Buffered_m@5
$LN2@Buffered_m@5:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	eax, edi

; 2792 : 			_Lastn = _Mid;
; 2793 : 			std::advance(_Lastn, _Count2n);
; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	mov	edi, DWORD PTR __First$[esp+40]
	cdq
	sub	eax, edx
	mov	esi, eax
	mov	eax, DWORD PTR __Mid$[esp+40]
	sar	esi, 1
	lea	edx, DWORD PTR [esi+esi*4]
	lea	ebx, DWORD PTR [eax+edx*4]
	push	ebx
	push	eax
	lea	eax, DWORD PTR $T263640[esp+52]
	push	edi
	push	eax
	call	??$_Upper_bound@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@H@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@0ABVCvHomelandTarget@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget,int>
	mov	ebp, DWORD PTR [eax]

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	ecx, ebp
	sub	ecx, edi
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	esp, 20					; 00000014H
	add	edi, edx
$LN136@Buffered_m@5:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	ecx, DWORD PTR __Tempbuf$[esp+36]
	mov	eax, DWORD PTR __Count1$[esp+36]
	mov	edx, DWORD PTR __Mid$[esp+36]
	push	ecx
	push	esi
	sub	eax, edi
	push	eax
	push	ebx
	push	edx
	mov	DWORD PTR tv515[esp+60], eax
	lea	eax, DWORD PTR __Midn$233174[esp+56]
	push	ebp
	push	eax
	call	??$_Buffered_rotate@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YA?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@V10@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	ecx, DWORD PTR __Tempbuf$[esp+64]
	mov	edx, DWORD PTR __First$[esp+64]
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Midn$233174[esp+76]
	push	edi
	push	ebp
	push	edx
	call	??$_Buffered_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	eax, DWORD PTR __Tempbuf$[esp+88]
	mov	ecx, DWORD PTR tv515[esp+92]
	mov	edx, DWORD PTR __Last$[esp+88]
	push	eax
	mov	eax, DWORD PTR __Count2$[esp+92]
	sub	eax, esi
	push	eax
	push	ecx
	push	edx
	push	ebx
	push	edi
	call	??$_Buffered_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 76					; 0000004cH
$LN3@Buffered_m@5:

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Buffered_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ENDP ; std::_Buffered_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z
_TEXT	SEGMENT
$T263690 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T263691 = 40						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T263690[esp+8], bl
	mov	eax, DWORD PTR $T263690[esp+8]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR $T263691[esp+36], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+36]
	push	edx
	push	eax
	call	??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>

; 5254 : 	}

	mov	eax, DWORD PTR __Dest$[esp+44]
	add	esp, 40					; 00000028H
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_@6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_@6:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@stdext@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z$0
__ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z
_TEXT	SEGMENT
$T263727 = -16						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
$T263728 = 44						; size = 4
__Pred$ = 44						; size = 4
??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z PROC ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 5285 : 	{

	push	-1
	push	__ehhandler$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Pred$[esp+16]
	mov	edx, DWORD PTR __Count$[esp+16]
	xor	ebx, ebx
	mov	BYTE PTR $T263727[esp+20], bl
	mov	eax, DWORD PTR $T263727[esp+20]
	push	eax
	mov	eax, DWORD PTR __Chunk$[esp+20]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+28]
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+68]
	mov	DWORD PTR $T263728[esp+52], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+52]
	push	edx
	push	eax
	mov	DWORD PTR __$EHRec$[esp+72], ebx
	call	??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHP6A_NV1@2@ZU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>

; 5287 : 	}

	mov	eax, DWORD PTR __Dest$[esp+60]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_@7:
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp-4]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z ENDP ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
PUBLIC	??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z
_TEXT	SEGMENT
$T263770 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T263771 = 40						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T263770[esp+8], bl
	mov	eax, DWORD PTR $T263770[esp+8]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR $T263771[esp+36], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+36]
	push	edx
	push	eax
	call	??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>

; 5254 : 	}

	mov	eax, DWORD PTR __Dest$[esp+44]
	add	esp, 40					; 00000028H
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_@8:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>
_TEXT	ENDS
PUBLIC	?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteArchaeologistMoves
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	SEGMENT
__unwindtable$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ$1
__ehfuncinfo$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$ = -48						; size = 4
$T263878 = -44						; size = 4
_strLogString$228543 = -40				; size = 28
_strLogString$228539 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ExecuteArchaeologistMoves, COMDAT
; _this$ = ecx

; 5080 : {

	push	-1
	push	__ehhandler$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	mov	ebx, ecx

; 5081 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 5082 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+20]
	push	ebp
	mov	ebp, DWORD PTR [ebx+16]
	shl	eax, 4
	add	eax, ebp
	mov	DWORD PTR _it$[esp+56], ebp
	cmp	ebp, eax
	je	$LN8@ExecuteArc
	push	esi
	push	edi
$LL10@ExecuteArc:

; 5083 : 	{
; 5084 : 		CvUnit* pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax

; 5085 : 		if(!pUnit)

	test	edi, edi
	je	$LN9@ExecuteArc

; 5086 : 		{
; 5087 : 			continue;
; 5088 : 		}
; 5089 : 
; 5090 : 		CvPlot* pTarget = FindArchaeologistTarget(pUnit);

	push	edi
	mov	ecx, ebx
	call	?FindArchaeologistTarget@CvHomelandAI@@AAEPAVCvPlot@@PAVCvUnit@@@Z ; CvHomelandAI::FindArchaeologistTarget
	mov	esi, eax

; 5091 : 		if (pTarget)

	test	esi, esi
	je	$LN9@ExecuteArc

; 5092 : 		{
; 5093 : 			BuildTypes eBuild = (BuildTypes)GC.getInfoTypeForString("BUILD_ARCHAEOLOGY_DIG");

	push	0
	push	OFFSET $SG228536
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 5094 : 			if(pUnit->UnitPathTo(pTarget->getX(), pTarget->getY(), 0) > 0)

	movsx	ecx, WORD PTR [esi]
	push	0
	push	-1
	mov	ebp, eax
	movsx	eax, WORD PTR [esi+2]
	push	0
	push	eax
	push	ecx
	mov	ecx, edi
	call	?UnitPathTo@CvUnit@@QAEHHHHH_N@Z	; CvUnit::UnitPathTo
	test	eax, eax
	jle	$LN58@ExecuteArc

; 5095 : 			{
; 5096 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 5097 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN4@ExecuteArc
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN4@ExecuteArc

; 5098 : 				{
; 5099 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228539[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5100 : 					strLogString.Format("Archaeologist moving to site at, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strLogString$228539[esp+72]
	push	OFFSET $SG228540
	push	eax
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5101 : 					LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$228539[esp+64]
	push	ecx
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 5102 : 				}

	lea	ecx, DWORD PTR _strLogString$228539[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@ExecuteArc:

; 5103 : 
; 5104 : 				if(pUnit->plot() == pTarget)

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 5105 : 				{
; 5106 : 					pUnit->PushMission(CvTypes::getMISSION_BUILD(), eBuild, -1, 0, (pUnit->GetLengthMissionQueue() > 0), false, MISSIONAI_BUILD, pTarget);

	mov	ecx, edi
	cmp	eax, esi
	jne	$LN3@ExecuteArc
	push	0
	push	esi
	push	18					; 00000012H
	push	0
	call	?GetLengthMissionQueue@CvUnit@@QBEHXZ	; CvUnit::GetLengthMissionQueue
	test	eax, eax
	setg	dl
	movzx	eax, dl
	push	eax
	push	0
	push	-1
	push	ebp
	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 5107 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN58@ExecuteArc
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN58@ExecuteArc

; 5108 : 					{
; 5109 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228543[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5110 : 						strLogString.Format("Archaeologist creating dig at, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strLogString$228543[esp+72]
	push	OFFSET $SG228544
	push	eax
	mov	DWORD PTR __$EHRec$[esp+88], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5111 : 						LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$228543[esp+64]
	push	ecx
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 5112 : 					}

	lea	ecx, DWORD PTR _strLogString$228543[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5113 : 				}
; 5114 : 				else

	jmp	SHORT $LN58@ExecuteArc
$LN3@ExecuteArc:

; 5115 : 				{
; 5116 : 					pUnit->finishMoves();

	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN58@ExecuteArc:

; 5117 : 				}
; 5118 : 			}
; 5119 : 			// Delete this unit from those we have to move
; 5120 : 			UnitProcessed(pUnit->GetID());

	mov	edi, DWORD PTR [edi+100]
	lea	edx, DWORD PTR $T263878[esp+64]
	push	edx
	lea	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR $T263878[esp+68], edi
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN59@ExecuteArc
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN59@ExecuteArc:
	mov	ebp, DWORD PTR _it$[esp+64]
$LN9@ExecuteArc:

; 5081 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 5082 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+20]
	shl	eax, 4
	add	eax, DWORD PTR [ebx+16]
	add	ebp, 16					; 00000010H
	mov	DWORD PTR _it$[esp+64], ebp
	cmp	ebp, eax
	jne	$LL10@ExecuteArc
	pop	edi
	pop	esi
$LN8@ExecuteArc:

; 5121 : 		}
; 5122 : 	}
; 5123 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$228539[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$228543[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ExecuteArchaeologistMoves
PUBLIC	??4?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??4?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T264103 = 8						; size = 1
__Cat$264107 = 8					; size = 1
$T264105 = 8						; size = 1
$T264073 = 8						; size = 1
__Cat$264077 = 8					; size = 1
$T264075 = 8						; size = 1
__Right$ = 8						; size = 4
??4?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	esi
	push	edi

; 564  : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	$LN78@operator@7

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	push	ebp
	sar	edx, 3
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH
	add	ebp, edx
	jne	SHORT $LN8@operator@7

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	$LN79@operator@7
	mov	BYTE PTR $T264073[esp+8], 0
	mov	edx, DWORD PTR $T264073[esp+8]
	push	edx
	mov	edx, DWORD PTR __Cat$264077[esp+12]
	push	edx
	mov	edx, DWORD PTR $T264075[esp+16]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	pop	ebp
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN8@operator@7:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR [esi+8]
	push	ebx
	mov	ebx, DWORD PTR [esi+4]
	sub	ecx, ebx
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ebp, ecx
	ja	SHORT $LN6@operator@7

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	BYTE PTR $T264103[esp+12], 0
	mov	eax, DWORD PTR $T264103[esp+12]
	mov	ecx, DWORD PTR __Cat$264107[esp+12]
	mov	edx, DWORD PTR $T264105[esp+12]
	push	eax
	mov	eax, DWORD PTR [edi+8]
	push	ecx
	push	edx
	push	ebx
	push	eax
	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	mov	ecx, DWORD PTR [esi+4]
	sar	edx, 3
	add	esp, 24					; 00000018H
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	ebx
	lea	eax, DWORD PTR [eax+eax*4]
	pop	ebp
	lea	edx, DWORD PTR [ecx+eax*4]
	pop	edi
	mov	DWORD PTR [esi+8], edx

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN6@operator@7:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	test	ebx, ebx
	jne	SHORT $LN69@operator@7
	xor	eax, eax
	jmp	SHORT $LN70@operator@7
$LN69@operator@7:
	mov	edx, DWORD PTR [esi+12]
	sub	edx, ebx
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$LN70@operator@7:
	cmp	ebp, eax
	ja	SHORT $LN4@operator@7

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	ebp, DWORD PTR [eax+ecx*4]

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	push	ebx
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvHomelandTarget@@PAV1@@stdext@@YAPAVCvHomelandTarget@@PAV1@00@Z ; stdext::unchecked_copy<CvHomelandTarget *,CvHomelandTarget *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH
	push	edx
	push	eax
	push	ebp
	mov	ecx, esi
	call	??$_Ucopy@PAVCvHomelandTarget@@@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV2@00@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Ucopy<CvHomelandTarget *>
	pop	ebx
	pop	ebp
	mov	DWORD PTR [esi+8], eax
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
$LN4@operator@7:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN73@operator@7

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN73@operator@7:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	mov	ecx, esi
	call	?_Buy@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAE_NI@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Buy
	test	al, al
	je	SHORT $LN77@operator@7

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [edi+4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Ucopy@PAVCvHomelandTarget@@@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@IAEPAVCvHomelandTarget@@PAV2@00@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::_Ucopy<CvHomelandTarget *>
	mov	DWORD PTR [esi+8], eax
$LN77@operator@7:
	pop	ebx
$LN79@operator@7:
	pop	ebp
$LN78@operator@7:
	pop	edi

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, esi
	pop	esi

; 599  : 		}

	ret	4
??4?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator=
_TEXT	ENDS
PUBLIC	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z
_TEXT	SEGMENT
$T264182 = -4						; size = 1
__Cat$264185 = 8					; size = 1
$T264151 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z PROC ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back@8
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back@8
$LN9@push_back@8:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back@8:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back@8

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$264185[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T264182[esp+16], 0
	mov	ecx, DWORD PTR $T264182[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAVCvHomelandTarget@@IV1@V?$allocator@VCvHomelandTarget@@@std@@@std@@YAXPAVCvHomelandTarget@@IABV1@AAV?$allocator@VCvHomelandTarget@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvHomelandTarget *,unsigned int,CvHomelandTarget,std::allocator<CvHomelandTarget> >
	add	esp, 24					; 00000018H
	add	edi, 20					; 00000014H
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@8:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T264151[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@V?$_Vector_const_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@2@ABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ENDP ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	esi
	mov	esi, ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi]
	push	eax
	push	edi
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	add	esi, 12					; 0000000cH
	cmp	edi, esi
	je	SHORT $LN3@FStaticVec@6
	push	edi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN3@FStaticVec@6:
	pop	edi
	pop	esi

; 619  : 	};

	ret	0
??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::push_back
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z PROC ; std::vector<CvPlot *,std::allocator<CvPlot *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back@9
	xor	eax, eax
	jmp	SHORT $LN10@push_back@9
$LN9@push_back@9:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back@9:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back@9
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back@9:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAEXABQAVCvPlot@@@Z ENDP ; std::vector<CvPlot *,std::allocator<CvPlot *> >::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back@10
	xor	eax, eax
	jmp	SHORT $LN10@push_back@10
$LN9@push_back@10:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back@10:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back@10
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back@10:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
_TEXT	ENDS
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ; std::sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z PROC ; std::sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0@Z ENDP ; std::sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ; std::sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z PROC ; std::sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0@Z ENDP ; std::sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Sort@PAU?$pair@HPAVCvPlot@@@std@@HP6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0HP6A_NABU10@1@Z@Z ; std::_Sort<std::pair<int,CvPlot *> *,int,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort@PAU?$pair@HPAVCvPlot@@@std@@HP6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0HP6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__Mid$231204 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$_Sort@PAU?$pair@HPAVCvPlot@@@std@@HP6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0HP6A_NABU10@1@Z@Z PROC ; std::_Sort<std::pair<int,CvPlot *> *,int,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 3244 : 	{	// order [_First, _Last), using _Pred

	sub	esp, 8
	push	ebx

; 3245 : 	_Diff _Count;
; 3246 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR __Pred$[esp+12]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort@3
	mov	esi, DWORD PTR __Ideal$[esp+20]
$LL7@Sort@3:
	test	esi, esi
	jle	SHORT $LN6@Sort@3

; 3247 : 		{	// divide and conquer by quicksort
; 3248 : 		pair<_RanIt, _RanIt> _Mid =
; 3249 : 			std::_Unguarded_partition(_First, _Last, _Pred);

	push	ebp
	push	edi
	lea	eax, DWORD PTR __Mid$231204[esp+32]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YA?AU?$pair@PAU?$pair@HPAVCvPlot@@@std@@PAU12@@0@PAU?$pair@HPAVCvPlot@@@0@0P6A_NABU20@1@Z@Z ; std::_Unguarded_partition<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>

; 3250 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx

; 3251 : 
; 3252 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	edx, DWORD PTR __Mid$231204[esp+40]
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$231204[esp+44]
	mov	ecx, edi
	add	esp, 16					; 00000010H
	sub	ecx, eax
	sub	edx, ebx
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3253 : 			{	// loop on second half
; 3254 : 			std::_Sort(_First, _Mid.first, _Ideal, _Pred);

	push	ebp
	push	esi
	jge	SHORT $LN5@Sort@3
	mov	eax, DWORD PTR __Mid$231204[esp+32]
	push	eax
	push	ebx
	call	??$_Sort@PAU?$pair@HPAVCvPlot@@@std@@HP6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0HP6A_NABU10@1@Z@Z ; std::_Sort<std::pair<int,CvPlot *> *,int,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>

; 3255 : 			_First = _Mid.second;

	mov	ebx, DWORD PTR __Mid$231204[esp+44]

; 3256 : 			}
; 3257 : 		else

	jmp	SHORT $LN26@Sort@3
$LN5@Sort@3:

; 3258 : 			{	// loop on first half
; 3259 : 			std::_Sort(_Mid.second, _Last, _Ideal, _Pred);

	push	edi
	push	eax
	call	??$_Sort@PAU?$pair@HPAVCvPlot@@@std@@HP6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0HP6A_NABU10@1@Z@Z ; std::_Sort<std::pair<int,CvPlot *> *,int,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>

; 3260 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$231204[esp+40]
$LN26@Sort@3:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 16					; 00000010H
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort@3
$LN25@Sort@3:

; 3268 : 		}
; 3269 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort@3

; 3270 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	push	0
	push	ebp
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@ZU12@@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z0@Z ; std::_Insertion_sort1<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &),std::pair<int,CvPlot *> >
	add	esp, 16					; 00000010H
$LN19@Sort@3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3271 : 	}

	add	esp, 8
	ret	0
$LN6@Sort@3:

; 3261 : 			}
; 3262 : 		}
; 3263 : 
; 3264 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort@3

; 3265 : 		{	// heap sort if too many divisions
; 3266 : 		std::make_heap(_First, _Last, _Pred);

	mov	ecx, edi
	sub	ecx, ebx
	and	ecx, -8					; fffffff8H
	cmp	ecx, 8
	jle	SHORT $LN10@Sort@3
	push	0
	push	0
	push	ebp
	push	edi
	push	ebx
	call	??$_Make_heap@PAU?$pair@HPAVCvPlot@@@std@@HU12@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@ZPAH0@Z ; std::_Make_heap<std::pair<int,CvPlot *> *,int,std::pair<int,CvPlot *>,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 20					; 00000014H
$LN10@Sort@3:

; 3267 : 		std::sort_heap(_First, _Last, _Pred);

	push	ebp
	push	edi
	push	ebx
	call	??$_Sort_heap@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ; std::_Sort_heap<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3271 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAU?$pair@HPAVCvPlot@@@std@@HP6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0HP6A_NABU10@1@Z@Z ENDP ; std::_Sort<std::pair<int,CvPlot *> *,int,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	edi

; 3382 : 	if (_Count <= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp]
	cmp	edi, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@VCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAVCvHomelandTarget@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,CvHomelandTarget>
	add	esp, 12					; 0000000cH
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
$LN4@Stable_sor:
	push	ebx

; 3384 : 	else
; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [edi+1]
	cdq
	push	ebp

; 3387 : 		_BidIt _Mid = _First;
; 3388 : 		std::advance(_Mid, _Count2);
; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+8]
	sub	eax, edx
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR __First$[esp+12]
	sar	esi, 1
	lea	edx, DWORD PTR [esi+esi*4]
	mov	ecx, ebp
	lea	ebx, DWORD PTR [eax+edx*4]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandTarget@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandTarget>::_Maxlen
	cmp	esi, eax

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	push	ebp
	push	esi
	push	ebx
	jg	SHORT $LN2@Stable_sor
	mov	ecx, DWORD PTR __First$[esp+24]
	push	ecx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	edx
	push	ebx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN21@Stable_sor
$LN2@Stable_sor:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	eax, DWORD PTR __First$[esp+24]
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	ecx
	push	ebx
	call	??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
$LN21@Stable_sor:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	edx, DWORD PTR __Last$[esp+44]
	mov	eax, DWORD PTR __First$[esp+44]
	add	esp, 32					; 00000020H
	push	ebp
	push	edi
	push	esi
	push	edx
	push	ebx
	push	eax
	call	??$_Buffered_merge@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@00HHAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Buffered_merge<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 24					; 00000018H
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_merge_sort<CvHomelandMove *,int,CvHomelandMove>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z
_TEXT	SEGMENT
$T264912 = -8						; size = 1
$T264883 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T264882 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z PROC ; std::_Buffered_merge_sort<CvHomelandMove *,int,CvHomelandMove>, COMDAT

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@6
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@6:

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;
; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	lea	esi, DWORD PTR [eax+256]

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	push	ebx
	push	esi
	push	eax
	call	??$_Insertion_sort1@PAVCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@00@Z ; std::_Insertion_sort1<CvHomelandMove *,CvHomelandMove>
	add	esp, 12					; 0000000cH
	sub	ebp, 1

; 3363 : 		_Mid = _Midend;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@6
$LN4@Buffered_m@6:

; 3364 : 		}
; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@PAVCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@00@Z ; std::_Insertion_sort1<CvHomelandMove *,CvHomelandMove>

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 12					; 0000000cH
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@6
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
$LL3@Buffered_m@6:

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+20]
	mov	BYTE PTR $T264882[esp+20], bl
	mov	eax, DWORD PTR $T264882[esp+20]
	push	eax
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	DWORD PTR $T264883[esp+56], esp
	push	ecx
	push	edx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	call	??$_Chunked_merge@PAVCvHomelandMove@@V?$_Temp_iterator@VCvHomelandMove@@@std@@H@std@@YAXPAVCvHomelandMove@@0V?$_Temp_iterator@VCvHomelandMove@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandMove *,std::_Temp_iterator<CvHomelandMove>,int>

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+60]
	mov	BYTE PTR $T264912[esp+64], bl
	mov	ecx, DWORD PTR $T264912[esp+64]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvHomelandMove@@PAV1@H@std@@YAXPAVCvHomelandMove@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandMove *,CvHomelandMove *,int>
	add	esi, esi
	add	esp, 64					; 00000040H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@6
$LN1@Buffered_m@6:

; 3373 : 		}
; 3374 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ENDP ; std::_Buffered_merge_sort<CvHomelandMove *,int,CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
$T264922 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T264982 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z PROC ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 3502 : 	{	// sort using temp buffer for merges, using _Pred

	push	ecx

; 3503 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp]
	push	ebx

; 3504 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	ebx, DWORD PTR __Pred$[esp+4]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count$[esp+16]
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@7
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@7:

; 3505 : 		{	// sort chunks
; 3506 : 		_BidIt _Midn = _Mid;
; 3507 : 		std::advance(_Midn, (int)_ISORT_MAX);
; 3508 : 
; 3509 : 		std::_Insertion_sort(_Mid, _Midn, _Pred);

	push	0
	lea	esi, DWORD PTR [eax+512]
	push	ebx
	push	esi
	push	eax
	call	??$_Insertion_sort1@PAVCvHomelandUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z0@Z ; std::_Insertion_sort1<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),CvHomelandUnit>
	add	esp, 16					; 00000010H
	sub	ebp, 1

; 3510 : 		_Mid = _Midn;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@7
$LN4@Buffered_m@7:

; 3511 : 		}
; 3512 : 	std::_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+16]
	push	0
	push	ebx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@PAVCvHomelandUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z0@Z ; std::_Insertion_sort1<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),CvHomelandUnit>

; 3513 : 
; 3514 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 16					; 00000010H
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@7
	mov	ebp, DWORD PTR __Tempbuf$[esp+16]
$LL3@Buffered_m@7:

; 3515 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3516 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3517 : 			_Chunk, _Count, _Pred);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Last$[esp+20]
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [ebp+16]
	mov	DWORD PTR $T264922[esp+52], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+48]
	push	edx
	push	eax
	call	??$_Unchecked_chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@HP6A_NV1@0@Z@stdext@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@std@@HHP6A_NV1@2@Z@Z ; stdext::_Unchecked_chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>

; 3518 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3519 : 			_Chunk *= 2, _Count, _Pred);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+56]
	mov	BYTE PTR $T264982[esp+56], 0
	mov	ecx, DWORD PTR $T264982[esp+56]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	ebx
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@HP6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHP6A_NV1@1@ZU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esi, esi
	add	esp, 68					; 00000044H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@7
$LN1@Buffered_m@7:

; 3520 : 		}
; 3521 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ENDP ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z
_TEXT	SEGMENT
$T265101 = -8						; size = 1
$T265072 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T265071 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z PROC ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit>, COMDAT

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@8
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@8:

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;
; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	lea	esi, DWORD PTR [eax+512]

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	push	ebx
	push	esi
	push	eax
	call	??$_Insertion_sort1@PAVCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@00@Z ; std::_Insertion_sort1<CvHomelandUnit *,CvHomelandUnit>
	add	esp, 12					; 0000000cH
	sub	ebp, 1

; 3363 : 		_Mid = _Midend;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@8
$LN4@Buffered_m@8:

; 3364 : 		}
; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@PAVCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@00@Z ; std::_Insertion_sort1<CvHomelandUnit *,CvHomelandUnit>

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 12					; 0000000cH
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@8
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
$LL3@Buffered_m@8:

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+20]
	mov	BYTE PTR $T265071[esp+20], bl
	mov	eax, DWORD PTR $T265071[esp+20]
	push	eax
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	DWORD PTR $T265072[esp+56], esp
	push	ecx
	push	edx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	call	??$_Chunked_merge@PAVCvHomelandUnit@@V?$_Temp_iterator@VCvHomelandUnit@@@std@@H@std@@YAXPAVCvHomelandUnit@@0V?$_Temp_iterator@VCvHomelandUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,std::_Temp_iterator<CvHomelandUnit>,int>

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+60]
	mov	BYTE PTR $T265101[esp+64], bl
	mov	ecx, DWORD PTR $T265101[esp+64]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvHomelandUnit@@PAV1@H@std@@YAXPAVCvHomelandUnit@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvHomelandUnit *,CvHomelandUnit *,int>
	add	esi, esi
	add	esp, 64					; 00000040H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@8
$LN1@Buffered_m@8:

; 3373 : 		}
; 3374 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ENDP ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit>
_TEXT	ENDS
PUBLIC	?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotArchaeologistMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$226212 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$226218 = -36					; size = 8
_unit$226221 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::PlotArchaeologistMoves, COMDAT
; _this$ = ecx

; 2100 : {

	push	-1
	push	__ehhandler$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 2101 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 2102 : 
; 2103 : 	// Loop through all recruited units
; 2104 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$226212[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotArchae
	push	edi
	jmp	SHORT $LN30@PlotArchae
	npad	3
$LL85@PlotArchae:
	mov	ebp, DWORD PTR _it$226212[esp+60]
$LN30@PlotArchae:

; 2105 : 	{
; 2106 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$226218[esp+60], edi
	mov	BYTE PTR _pUnit$226218[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotArchae
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotArchae:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 2107 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotArchae

; 2108 : 		{
; 2109 : 			if(pUnit->AI_getUnitAIType() == UNITAI_ARCHAEOLOGIST)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN86@PlotArchae

; 2110 : 			{
; 2111 : 				CvHomelandUnit unit;
; 2112 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 2113 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$226221[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotArchae
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotArchae:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotArchae
	mov	edx, DWORD PTR _unit$226221[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotArchae:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$226212[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotArchae:

; 2114 : 			}
; 2115 : 		}
; 2116 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotArchae
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotArchae:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$226212[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotArchae
	pop	edi
$LN4@PlotArchae:

; 2117 : 
; 2118 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotArchae

; 2119 : 	{
; 2120 : 		ExecuteArchaeologistMoves();

	mov	ecx, ebx
	call	?ExecuteArchaeologistMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteArchaeologistMoves
$LN1@PlotArchae:

; 2121 : 	}
; 2122 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226218[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::PlotArchaeologistMoves
PUBLIC	?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ ; CvHomelandAI::EliminateAdjacentHomelandRoads
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
tv558 = -32						; size = 4
$T265619 = -32						; size = 1
__Cat$265623 = -32					; size = 1
$T265621 = -32						; size = 1
_tempPoints$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ PROC ; CvHomelandAI::EliminateAdjacentHomelandRoads, COMDAT
; _this$ = ecx

; 5163 : {

	push	-1
	push	__ehhandler$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi

; 5164 : 	// Create temporary copy of list
; 5165 : 	std::vector<CvHomelandTarget> tempPoints;

	xor	ebp, ebp
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+52], edi
	mov	DWORD PTR _tempPoints$[esp+56], ebp
	mov	DWORD PTR _tempPoints$[esp+60], ebp
	mov	DWORD PTR _tempPoints$[esp+64], ebp

; 5166 : 	tempPoints = m_TargetedHomelandRoads;

	lea	esi, DWORD PTR [edi+2476]
	push	esi
	lea	ecx, DWORD PTR _tempPoints$[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], ebp
	call	??4?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator=

; 5167 : 
; 5168 : 	// Clear out main list
; 5169 : 	m_TargetedHomelandRoads.clear();

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN63@EliminateA
	mov	BYTE PTR $T265619[esp+52], 0
	mov	edx, DWORD PTR $T265619[esp+52]
	push	edx
	mov	edx, DWORD PTR __Cat$265623[esp+56]
	push	edx
	mov	edx, DWORD PTR $T265621[esp+60]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
$LN63@EliminateA:

; 5170 : 
; 5171 : 	// Loop through all points in copy
; 5172 : 	std::vector<CvHomelandTarget>::iterator it, it2;
; 5173 : 	for(it = tempPoints.begin(); it != tempPoints.end(); ++it)

	mov	ebx, DWORD PTR _tempPoints$[esp+56]
	cmp	ebx, DWORD PTR _tempPoints$[esp+60]
	je	SHORT $LN6@EliminateA
	npad	6
$LL104@EliminateA:

; 5174 : 	{
; 5175 : 		bool bFoundAdjacent = false;
; 5176 : 
; 5177 : 		// Is it adjacent to a point in the main list?
; 5178 : 		for(it2 = m_TargetedHomelandRoads.begin(); it2 != m_TargetedHomelandRoads.end(); ++it2)

	mov	eax, DWORD PTR [edi+2484]
	mov	esi, DWORD PTR [edi+2480]
	mov	DWORD PTR tv558[esp+52], eax
	cmp	esi, eax
	je	SHORT $LN184@EliminateA
	mov	edi, DWORD PTR [ebx+8]
	mov	ebp, DWORD PTR [ebx+4]
	npad	6
$LL124@EliminateA:

; 5179 : 		{
; 5180 : 			if(plotDistance(it->GetTargetX(), it->GetTargetY(), it2->GetTargetX(), it2->GetTargetY()) == 1)

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	push	ecx
	push	edi
	push	ebp
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	SHORT $LN185@EliminateA
	add	esi, 20					; 00000014H
	cmp	esi, DWORD PTR tv558[esp+52]
	jne	SHORT $LL124@EliminateA

; 5174 : 	{
; 5175 : 		bool bFoundAdjacent = false;
; 5176 : 
; 5177 : 		// Is it adjacent to a point in the main list?
; 5178 : 		for(it2 = m_TargetedHomelandRoads.begin(); it2 != m_TargetedHomelandRoads.end(); ++it2)

	mov	edi, DWORD PTR _this$[esp+52]
$LN184@EliminateA:

; 5181 : 			{
; 5182 : 				bFoundAdjacent = true;
; 5183 : 				break;
; 5184 : 			}
; 5185 : 		}
; 5186 : 
; 5187 : 		if(!bFoundAdjacent)
; 5188 : 		{
; 5189 : 			m_TargetedHomelandRoads.push_back(*it);

	push	ebx
	lea	ecx, DWORD PTR [edi+2476]
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
	jmp	SHORT $LN7@EliminateA
$LN185@EliminateA:
	mov	edi, DWORD PTR _this$[esp+52]
$LN7@EliminateA:

; 5170 : 
; 5171 : 	// Loop through all points in copy
; 5172 : 	std::vector<CvHomelandTarget>::iterator it, it2;
; 5173 : 	for(it = tempPoints.begin(); it != tempPoints.end(); ++it)

	add	ebx, 20					; 00000014H
	cmp	ebx, DWORD PTR _tempPoints$[esp+60]
	jne	SHORT $LL104@EliminateA
	mov	ebx, DWORD PTR _tempPoints$[esp+56]
	xor	ebp, ebp
$LN6@EliminateA:

; 5190 : 		}
; 5191 : 	}
; 5192 : }

	cmp	ebx, ebp
	je	SHORT $LN177@EliminateA
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN177@EliminateA:
	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 36					; 00000024H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _tempPoints$[ebp]
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__ehhandler$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ ENDP ; CvHomelandAI::EliminateAdjacentHomelandRoads
PUBLIC	?SortItems@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ ; CvWeightedVector<CvPlot *,100,1>::SortItems
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?SortItems@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ PROC ; CvWeightedVector<CvPlot *,100,1>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAEXXZ ENDP ; CvWeightedVector<CvPlot *,100,1>::SortItems
_TEXT	ENDS
PUBLIC	?SortItems@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEXXZ ; CvWeightedVector<CvCity *,64,1>::SortItems
; Function compile flags: /Ogtpy
;	COMDAT ?SortItems@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEXXZ PROC ; CvWeightedVector<CvCity *,64,1>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAEXXZ ENDP ; CvWeightedVector<CvCity *,64,1>::SortItems
_TEXT	ENDS
PUBLIC	??$sort@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ; std::sort<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$sort@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$sort@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z PROC ; std::sort<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>, COMDAT

; 3277 : 	_DEBUG_RANGE(_First, _Last);
; 3278 : 	_DEBUG_POINTER(_Pred);
; 3279 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First, _Pred);

	mov	eax, DWORD PTR __Pred$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAU?$pair@HPAVCvPlot@@@std@@HP6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0HP6A_NABU10@1@Z@Z ; std::_Sort<std::pair<int,CvPlot *> *,int,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 16					; 00000010H

; 3280 : 	}

	ret	0
??$sort@PAU?$pair@HPAVCvPlot@@@std@@P6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0P6A_NABU10@1@Z@Z ENDP ; std::sort<std::pair<int,CvPlot *> *,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z$0
__ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	-1
	push	__ehhandler$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3411 : 	_Diff _Count = 0;
; 3412 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	mov	edx, eax
	push	edx
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	call	??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0HAAV?$_Temp_iterator@VCvHomelandTarget@@@0@@Z ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>

; 3415 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+60]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN24@Stable_sor@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Stable_sor@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandTarget@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandTarget>::~_Temp_iterator<CvHomelandTarget>
__ehhandler$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
PUBLIC	??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z PROC ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	edi

; 3382 : 	if (_Count <= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp]
	cmp	edi, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor@3

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvHomelandMove@@V1@@std@@YAXPAVCvHomelandMove@@00@Z ; std::_Insertion_sort1<CvHomelandMove *,CvHomelandMove>
	add	esp, 12					; 0000000cH
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
$LN4@Stable_sor@3:
	push	ebx

; 3384 : 	else
; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [edi+1]
	cdq
	push	ebp

; 3387 : 		_BidIt _Mid = _First;
; 3388 : 		std::advance(_Mid, _Count2);
; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+8]
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	esi
	mov	esi, eax
	sar	esi, 1
	mov	ecx, ebp
	lea	ebx, DWORD PTR [edx+esi*8]
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandMove@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandMove>::_Maxlen
	cmp	esi, eax

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	push	ebp
	push	esi
	push	ebx
	jg	SHORT $LN2@Stable_sor@3
	mov	eax, DWORD PTR __First$[esp+24]
	push	eax
	call	??$_Buffered_merge_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_merge_sort<CvHomelandMove *,int,CvHomelandMove>

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	ecx
	push	ebx
	call	??$_Buffered_merge_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_merge_sort<CvHomelandMove *,int,CvHomelandMove>

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN17@Stable_sor@3
$LN2@Stable_sor@3:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	edx, DWORD PTR __First$[esp+24]
	push	edx
	call	??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	eax, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	eax
	push	ebx
	call	??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>
$LN17@Stable_sor@3:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	ecx, DWORD PTR __Last$[esp+44]
	mov	edx, DWORD PTR __First$[esp+44]
	add	esp, 32					; 00000020H
	push	ebp
	push	edi
	push	esi
	push	ecx
	push	ebx
	push	edx
	call	??$_Buffered_merge@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@00HHAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Buffered_merge<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 24					; 00000018H
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ENDP ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z PROC ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 3529 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebx

; 3530 : 	if (_Count <= _ISORT_MAX)

	mov	ebx, DWORD PTR __Count$[esp]
	cmp	ebx, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor@4

; 3531 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	mov	eax, DWORD PTR __Pred$[esp]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Insertion_sort1@PAVCvHomelandUnit@@P6A_NV1@0@ZV1@@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z0@Z ; std::_Insertion_sort1<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit),CvHomelandUnit>
	add	esp, 16					; 00000010H
	pop	ebx

; 3552 : 		}
; 3553 : 	}

	ret	0
$LN4@Stable_sor@4:

; 3532 : 	else
; 3533 : 		{	// sort halves and merge
; 3534 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [ebx+1]
	push	ebp

; 3535 : 		_BidIt _Mid = _First;
; 3536 : 		std::advance(_Mid, _Count2);
; 3537 : 
; 3538 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+4]
	cdq
	push	esi
	sub	eax, edx
	mov	esi, eax
	push	edi
	sar	esi, 1
	mov	edi, esi
	shl	edi, 4
	add	edi, DWORD PTR __First$[esp+12]
	mov	ecx, ebp
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	esi, eax
	jg	SHORT $LN2@Stable_sor@4

; 3539 : 			{	// temp buffer big enough, sort each half using buffer
; 3540 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+12]
	mov	ecx, DWORD PTR __First$[esp+12]
	push	eax
	push	ebp
	push	esi
	push	edi
	push	ecx
	call	??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>

; 3541 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
; 3542 : 				_Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+32]
	mov	eax, DWORD PTR __Last$[esp+32]
	push	edx
	push	ebp
	sub	ebx, esi
	push	ebx
	push	eax
	push	edi
	call	??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>

; 3543 : 			}
; 3544 : 		else

	jmp	SHORT $LN17@Stable_sor@4
$LN2@Stable_sor@4:

; 3545 : 			{	// temp buffer not big enough, divide and conquer
; 3546 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	mov	ecx, DWORD PTR __Pred$[esp+12]
	mov	edx, DWORD PTR __First$[esp+12]
	push	ecx
	push	ebp
	push	esi
	push	edi
	push	edx
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>

; 3547 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);

	mov	eax, DWORD PTR __Pred$[esp+32]
	mov	ecx, DWORD PTR __Last$[esp+32]
	push	eax
	push	ebp
	sub	ebx, esi
	push	ebx
	push	ecx
	push	edi
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
$LN17@Stable_sor@4:

; 3548 : 			}
; 3549 : 
; 3550 : 		_Buffered_merge(_First, _Mid, _Last,
; 3551 : 			_Count2, _Count - _Count2, _Tempbuf, _Pred);	// merge halves

	mov	edx, DWORD PTR __Pred$[esp+52]
	mov	eax, DWORD PTR __Last$[esp+52]
	mov	ecx, DWORD PTR __First$[esp+52]
	add	esp, 40					; 00000028H
	push	edx
	push	ebp
	push	ebx
	push	esi
	push	eax
	push	edi
	push	ecx
	call	??$_Buffered_merge@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3552 : 		}
; 3553 : 	}

	ret	0
??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ENDP ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z PROC ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	ebx

; 3382 : 	if (_Count <= _ISORT_MAX)

	mov	ebx, DWORD PTR __Count$[esp]
	cmp	ebx, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor@5

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvHomelandUnit@@V1@@std@@YAXPAVCvHomelandUnit@@00@Z ; std::_Insertion_sort1<CvHomelandUnit *,CvHomelandUnit>
	add	esp, 12					; 0000000cH
	pop	ebx

; 3403 : 		}
; 3404 : 	}

	ret	0
$LN4@Stable_sor@5:

; 3384 : 	else
; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [ebx+1]
	push	ebp

; 3387 : 		_BidIt _Mid = _First;
; 3388 : 		std::advance(_Mid, _Count2);
; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+4]
	cdq
	push	esi
	sub	eax, edx
	mov	esi, eax
	push	edi
	sar	esi, 1
	mov	edi, esi
	shl	edi, 4
	add	edi, DWORD PTR __First$[esp+12]
	mov	ecx, ebp
	call	?_Maxlen@?$_Temp_iterator@VCvHomelandUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvHomelandUnit>::_Maxlen
	cmp	esi, eax

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	push	ebp
	push	esi
	push	edi
	jg	SHORT $LN2@Stable_sor@5
	mov	edx, DWORD PTR __First$[esp+24]
	push	edx
	call	??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit>

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	eax, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	ebx, esi
	push	ebx
	push	eax
	push	edi
	call	??$_Buffered_merge_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_merge_sort<CvHomelandUnit *,int,CvHomelandUnit>

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN17@Stable_sor@5
$LN2@Stable_sor@5:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __First$[esp+24]
	push	ecx
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	ebx, esi
	push	ebx
	push	edx
	push	edi
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
$LN17@Stable_sor@5:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	eax, DWORD PTR __Last$[esp+44]
	mov	ecx, DWORD PTR __First$[esp+44]
	add	esp, 32					; 00000020H
	push	ebp
	push	ebx
	push	esi
	push	eax
	push	edi
	push	ecx
	call	??$_Buffered_merge@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@00HHAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Buffered_merge<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3403 : 		}
; 3404 : 	}

	ret	0
??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ENDP ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
_TEXT	ENDS
PUBLIC	?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z ; CvHomelandAI::IsAnyValidExploreMoves
EXTRN	?GetExplorationPlotRatings@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ:PROC ; CvEconomicAI::GetExplorationPlotRatings
EXTRN	?GetExplorationPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ:PROC ; CvEconomicAI::GetExplorationPlots
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z$0
__ehfuncinfo$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z
_TEXT	SEGMENT
_aiExplorationPlots$ = -48				; size = 4
_ui$224924 = -44					; size = 4
_iUnitY$224856 = -40					; size = 4
_iUnitX$224855 = -36					; size = 4
_aiExplorationPlotRatings$ = -32			; size = 4
_this$ = -28						; size = 4
_aDistanceList$224923 = -24				; size = 12
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z PROC ; CvHomelandAI::IsAnyValidExploreMoves, COMDAT
; _this$ = ecx

; 179  : {

	push	-1
	push	__ehhandler$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$[esp+60], ecx

; 180  : 	CvEconomicAI* pEconomicAI = m_pPlayer->GetEconomicAI();

	mov	ecx, DWORD PTR [ecx]
	push	edi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	esi, eax

; 181  : 	FFastVector<int>& aiExplorationPlots = pEconomicAI->GetExplorationPlots();

	mov	ecx, esi
	call	?GetExplorationPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ; CvEconomicAI::GetExplorationPlots
	mov	edi, eax

; 182  : 	FFastVector<int>& aiExplorationPlotRatings = pEconomicAI->GetExplorationPlotRatings();

	mov	ecx, esi
	mov	DWORD PTR _aiExplorationPlots$[esp+64], edi
	call	?GetExplorationPlotRatings@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ; CvEconomicAI::GetExplorationPlotRatings
	mov	DWORD PTR _aiExplorationPlotRatings$[esp+64], eax

; 183  : 
; 184  : 	if (aiExplorationPlots.size() > 0)

	mov	eax, DWORD PTR [edi+4]
	xor	esi, esi
	cmp	eax, esi
	jbe	$LN112@IsAnyValid

; 185  : 	{
; 186  : 		int iUnitX = pUnit->getX();

	mov	ecx, DWORD PTR _pUnit$[esp+60]
	mov	edx, DWORD PTR [ecx+76]

; 187  : 		int iUnitY = pUnit->getY();

	mov	ecx, DWORD PTR [ecx+88]

; 188  : 
; 189  : 		// Filter the list with some quick checks, then add the rest to a list that we can sort by distance
; 190  : 		DistanceSortedPlotArray aDistanceList;

	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _iUnitX$224855[esp+64], edx
	mov	DWORD PTR _iUnitY$224856[esp+64], ecx
	mov	DWORD PTR _aDistanceList$224923[esp+68], ebx
	mov	DWORD PTR _aDistanceList$224923[esp+72], ebp
	mov	DWORD PTR _aDistanceList$224923[esp+64], esi
	mov	DWORD PTR __$EHRec$[esp+72], esi

; 191  : 		aDistanceList.reserve( aiExplorationPlots.size() );

	cmp	eax, esi
	jbe	SHORT $LN41@IsAnyValid
	push	eax
	lea	ecx, DWORD PTR _aDistanceList$224923[esp+68]
	call	?SetSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::SetSize
	mov	ebp, DWORD PTR _aDistanceList$224923[esp+72]
	mov	ebx, DWORD PTR _aDistanceList$224923[esp+68]
	mov	esi, DWORD PTR _aDistanceList$224923[esp+64]
$LN41@IsAnyValid:

; 192  : 
; 193  : 		for(uint ui = 0; ui < aiExplorationPlots.size(); ui++)

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	mov	DWORD PTR _ui$224924[esp+64], ecx
	test	eax, eax
	jbe	$LN10@IsAnyValid
	npad	1
$LL127@IsAnyValid:

; 194  : 		{
; 195  : 			int iPlot = aiExplorationPlots[ui];

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+ecx*4]

; 196  : 			if(iPlot < 0)

	test	eax, eax
	jl	$LN11@IsAnyValid

; 197  : 			{
; 198  : 				continue;
; 199  : 			}
; 200  : 
; 201  : 			CvPlot* pEvalPlot = GC.getMap().plotByIndex(iPlot);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [edx+4028]
	jge	SHORT $LN11@IsAnyValid
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [edx+4068]
	mov	edi, eax

; 202  : 			if(!pEvalPlot)

	je	SHORT $LN125@IsAnyValid

; 203  : 			{
; 204  : 				continue;
; 205  : 			}
; 206  : 
; 207  : 			if(aiExplorationPlotRatings[ui] == 0)

	mov	eax, DWORD PTR _aiExplorationPlotRatings$[esp+64]
	mov	edx, DWORD PTR [eax]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $LN125@IsAnyValid

; 208  : 			{
; 209  : 				continue;
; 210  : 			}
; 211  : 
; 212  : 			int iDistX = abs( pEvalPlot->getX() - iUnitX );

	movsx	eax, WORD PTR [edi]
	sub	eax, DWORD PTR _iUnitX$224855[esp+64]
	cdq
	mov	ecx, eax

; 213  : 			int iDistY = abs( pEvalPlot->getY() - iUnitY );

	movsx	eax, WORD PTR [edi+2]
	sub	eax, DWORD PTR _iUnitY$224856[esp+64]
	xor	ecx, edx
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 214  : 
; 215  : 			aDistanceList.push_back(std::pair<int, CvPlot*>((iDistX*iDistX)+(iDistY*iDistY), pEvalPlot));

	mov	esi, eax
	imul	esi, eax
	mov	eax, ecx
	imul	eax, ecx
	add	esi, eax
	cmp	ebx, ebp
	jne	SHORT $LN63@IsAnyValid
	push	ebp
	lea	ecx, DWORD PTR _aDistanceList$224923[esp+68]
	call	?GrowSize@?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@IAEXI@Z ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::GrowSize
	mov	ebp, DWORD PTR _aDistanceList$224923[esp+72]
	mov	ebx, DWORD PTR _aDistanceList$224923[esp+68]
$LN63@IsAnyValid:
	mov	ecx, DWORD PTR _aDistanceList$224923[esp+64]
	lea	eax, DWORD PTR [ecx+ebx*8]
	test	eax, eax
	je	SHORT $LN66@IsAnyValid
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
$LN66@IsAnyValid:
	mov	esi, DWORD PTR _aDistanceList$224923[esp+64]
	mov	ecx, DWORD PTR _ui$224924[esp+64]
	inc	ebx
	mov	DWORD PTR _aDistanceList$224923[esp+68], ebx
$LN125@IsAnyValid:
	mov	edi, DWORD PTR _aiExplorationPlots$[esp+64]
$LN11@IsAnyValid:

; 192  : 
; 193  : 		for(uint ui = 0; ui < aiExplorationPlots.size(); ui++)

	inc	ecx
	mov	DWORD PTR _ui$224924[esp+64], ecx
	cmp	ecx, DWORD PTR [edi+4]
	jb	$LL127@IsAnyValid
$LN10@IsAnyValid:

; 216  : 
; 217  : 		}
; 218  : 
; 219  : 		if (aDistanceList.size())

	test	ebx, ebx
	je	SHORT $LN3@IsAnyValid

; 220  : 		{
; 221  : 			std::sort(aDistanceList.begin(), aDistanceList.end(), SortUnitDistance);

	lea	ebx, DWORD PTR [esi+ebx*8]
	mov	edx, ebx
	sub	edx, esi
	push	OFFSET ?SortUnitDistance@@YA_NABU?$pair@HPAVCvPlot@@@std@@0@Z ; SortUnitDistance
	sar	edx, 3
	push	edx
	push	ebx
	push	esi
	call	??$_Sort@PAU?$pair@HPAVCvPlot@@@std@@HP6A_NABU12@0@Z@std@@YAXPAU?$pair@HPAVCvPlot@@@0@0HP6A_NABU10@1@Z@Z ; std::_Sort<std::pair<int,CvPlot *> *,int,bool (__cdecl*)(std::pair<int,CvPlot *> const &,std::pair<int,CvPlot *> const &)>
	add	esp, 16					; 00000010H

; 222  : 
; 223  : 			for (DistanceSortedPlotArray::const_iterator itr = aDistanceList.begin(); itr != aDistanceList.end(); ++itr)

	mov	edi, esi
	cmp	esi, ebx
	je	SHORT $LN3@IsAnyValid
	npad	9
$LL5@IsAnyValid:

; 224  : 			{
; 225  : 				CvPlot* pEvalPlot = (*itr).second;

	mov	esi, DWORD PTR [edi+4]

; 226  : 				if(!IsValidExplorerEndTurnPlot(pUnit, pEvalPlot))

	mov	ebp, DWORD PTR _pUnit$[esp+60]
	mov	ecx, DWORD PTR _this$[esp+64]
	push	esi
	push	ebp
	call	?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z ; CvHomelandAI::IsValidExplorerEndTurnPlot
	test	al, al
	je	SHORT $LN4@IsAnyValid

; 227  : 				{
; 228  : 					continue;
; 229  : 				}
; 230  : 				// hitting the path finder, may not be the best idea. . .
; 231  : 				bool bCanFindPath = GC.getPathFinder().GenerateUnitPath(pUnit, iUnitX, iUnitY, pEvalPlot->getX(), pEvalPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	1
	push	138					; 0000008aH
	push	eax
	mov	eax, DWORD PTR _iUnitY$224856[esp+76]
	push	ecx
	mov	ecx, DWORD PTR _iUnitX$224855[esp+80]
	push	eax
	push	ecx
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	ecx, eax
	call	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath

; 232  : 				if(!bCanFindPath)

	test	al, al
	jne	SHORT $LN1@IsAnyValid
$LN4@IsAnyValid:

; 222  : 
; 223  : 			for (DistanceSortedPlotArray::const_iterator itr = aDistanceList.begin(); itr != aDistanceList.end(); ++itr)

	add	edi, 8
	cmp	edi, ebx
	jne	SHORT $LL5@IsAnyValid

; 192  : 
; 193  : 		for(uint ui = 0; ui < aiExplorationPlots.size(); ui++)

	mov	esi, DWORD PTR _aDistanceList$224923[esp+64]
$LN3@IsAnyValid:

; 238  : 			}
; 239  : 		}
; 240  : 	}

	push	esi
	mov	DWORD PTR __$EHRec$[esp+76], -1
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN112@IsAnyValid:
	pop	edi
	pop	esi
	pop	ebp

; 241  : 
; 242  : 
; 243  : 	return false;

	xor	al, al
	pop	ebx

; 244  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	4
$LN1@IsAnyValid:

; 233  : 				{
; 234  : 					continue;
; 235  : 				}
; 236  : 
; 237  : 				return true;

	mov	edx, DWORD PTR _aDistanceList$224923[esp+64]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+76], -1
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking

; 244  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _aDistanceList$224923[ebp]
	jmp	??1?$FFastVector@U?$pair@HPAVCvPlot@@@std@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@U?$pair@HPAVCvPlot@@@std@@$0A@@@@@QAE@XZ ; FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>::~FFastVector<std::pair<int,CvPlot *>,0,0,0,BaseVector<std::pair<int,CvPlot *>,0>::FDefaultFastVectorAllocator>
__ehhandler$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsAnyValidExploreMoves@CvHomelandAI@@QBE_NPBVCvUnit@@@Z ENDP ; CvHomelandAI::IsAnyValidExploreMoves
PUBLIC	__real@3f400000
PUBLIC	__real@3f000000
PUBLIC	?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteExplorerMoves
EXTRN	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z:PROC	; CvUnit::kill
EXTRN	?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z:PROC ; CvIgnoreUnitsPathFinder::DoesPathExist
EXTRN	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ:PROC ; CvGlobals::getIgnoreUnitsPathFinder
EXTRN	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z:PROC ; CvUnit::SetAutomateType
EXTRN	?getMoves@CvUnit@@QBEHXZ:PROC			; CvUnit::getMoves
EXTRN	?isAdjacentToLand@CvPlot@@QBE_NXZ:PROC		; CvPlot::isAdjacentToLand
EXTRN	?canSellExoticGoods@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canSellExoticGoods
EXTRN	?isShallowWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isShallowWater
EXTRN	?IsEmbarkAllWater@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsEmbarkAllWater
EXTRN	?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z:PROC ; CvEconomicAI::ScoreExplorePlot
EXTRN	?movesLeft@CvUnit@@QBEHXZ:PROC			; CvUnit::movesLeft
EXTRN	?GetBaseSightRange@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetBaseSightRange
EXTRN	?ClearUnitTargetGoodyStepPlot@CvEconomicAI@@QAEXPAVCvUnit@@@Z:PROC ; CvEconomicAI::ClearUnitTargetGoodyStepPlot
EXTRN	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z:PROC ; CvPlot::isVisibleEnemyDefender
EXTRN	?HasBarbarianCamp@CvPlot@@QAE_NXZ:PROC		; CvPlot::HasBarbarianCamp
EXTRN	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC	; CvPlot::isGoody
EXTRN	?GetUnitTargetGoodyPlot@CvEconomicAI@@QAEPAVCvPlot@@PAVCvUnit@@PAPAV2@@Z:PROC ; CvEconomicAI::GetUnitTargetGoodyPlot
EXTRN	?calculateExoticGoodsDistanceFactor@CvUnit@@QAEMPBVCvPlot@@@Z:PROC ; CvUnit::calculateExoticGoodsDistanceFactor
EXTRN	?CanStartMission@CvUnit@@QAE_NHHHPAVCvPlot@@_N@Z:PROC ; CvUnit::CanStartMission
EXTRN	?getMISSION_SELL_EXOTIC_GOODS@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_SELL_EXOTIC_GOODS
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallHook
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?UpdatePlots@CvEconomicAI@@QAEXXZ:PROC		; CvEconomicAI::UpdatePlots
;	COMDAT __real@3f400000
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$4
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$5
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$6
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$7
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$8
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$9
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$10
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$11
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$12
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -976						; size = 4
$T267602 = -972						; size = 4
$T267488 = -972						; size = 4
$T267339 = -972						; size = 4
_aiExplorationPlotRatings$227262 = -972			; size = 4
_uiListSize$227229 = -972				; size = 4
_fRewardFactor$227224 = -972				; size = 4
_bCanFindPath$227179 = -965				; size = 1
_aiExplorationPlots$227251 = -964			; size = 4
_iX$227204 = -964					; size = 4
_fRewardFactor$227164 = -964				; size = 4
_iMovementRange$227202 = -960				; size = 4
_bResult$227160 = -953					; size = 1
_iUnitY$227170 = -952					; size = 4
_pkStepPlot$227171 = -948				; size = 4
_iUnitX$227169 = -944					; size = 4
_args$227159 = -940					; size = 4
_strLogString$227317 = -936				; size = 28
_strLogString$227307 = -936				; size = 28
_strLogString$227302 = -936				; size = 28
_strLogString$227294 = -936				; size = 28
_strLogString$227196 = -936				; size = 28
_strLogString$227192 = -936				; size = 28
_strLogString$227188 = -936				; size = 28
_strLogString$227175 = -936				; size = 28
_strLogString$227167 = -936				; size = 28
tv2581 = -908						; size = 4
_pEconomicAI$ = -904					; size = 4
tv2596 = -900						; size = 4
_it$ = -896						; size = 4
_kPathFinder$ = -892					; size = 4
_iY$227208 = -888					; size = 4
_iLoop$227310 = -884					; size = 4
tv2059 = -880						; size = 4
tv2063 = -876						; size = 4
_iBaseSightRange$227201 = -872				; size = 4
_eTeam$227200 = -868					; size = 4
_pUnit$227154 = -864					; size = 8
_strLogString$227322 = -856				; size = 28
_aBestPlotList$ = -828					; size = 816
__$EHRec$ = -12						; size = 12
?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteExplorerMoves, COMDAT
; _this$ = ecx

; 2270 : {

	push	-1
	push	__ehhandler$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 964				; 000003c4H
	push	ebx
	mov	ebx, ecx

; 2271 : 	bool bFoundNearbyExplorePlot = false;
; 2272 : 	CvEconomicAI* pEconomicAI = m_pPlayer->GetEconomicAI();

	mov	ecx, DWORD PTR [ebx]
	push	ebp
	mov	DWORD PTR _this$[esp+984], ebx
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI

; 2273 : 
; 2274 : 	pEconomicAI->UpdatePlots();

	mov	ecx, eax
	mov	DWORD PTR _pEconomicAI$[esp+984], eax
	call	?UpdatePlots@CvEconomicAI@@QAEXXZ	; CvEconomicAI::UpdatePlots

; 2275 : 
; 2276 : #if defined(PATH_PLAN_LAST)
; 2277 : 	WeightedPlotVector aBestPlotList;

	xor	eax, eax
	lea	ecx, DWORD PTR _aBestPlotList$[esp+996]
	mov	DWORD PTR _aBestPlotList$[esp+988], eax
	mov	DWORD PTR _aBestPlotList$[esp+992], 100	; 00000064H
	mov	DWORD PTR _aBestPlotList$[esp+984], ecx

; 2278 : 	aBestPlotList.reserve(100);
; 2279 : #endif
; 2280 : 
; 2281 : 	CvTwoLayerPathFinder& kPathFinder = GC.getPathFinder();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+992], eax
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder

; 2282 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 2283 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	ebp, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ebx+20]
	shl	edx, 4
	add	edx, ebp
	mov	DWORD PTR _kPathFinder$[esp+984], eax
	mov	DWORD PTR _it$[esp+984], ebp
	cmp	ebp, edx
	je	$LN88@ExecuteExp
	push	esi
	push	edi
$LL90@ExecuteExp:

; 2284 : 	{
; 2285 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$227154[esp+992], esi
	mov	BYTE PTR _pUnit$227154[esp+996], 0
	test	esi, esi
	je	SHORT $LN159@ExecuteExp
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN159@ExecuteExp:
	mov	BYTE PTR __$EHRec$[esp+1000], 1

; 2286 : 		if(!pUnit || pUnit->TurnProcessed())

	test	esi, esi
	je	$LN86@ExecuteExp
	mov	ecx, esi
	call	?TurnProcessed@CvUnit@@QBE_NXZ		; CvUnit::TurnProcessed
	test	al, al
	jne	$LN86@ExecuteExp

; 2289 : 		}
; 2290 : 
; 2291 : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	edi, eax

; 2292 : 		if(pkScriptSystem)

	test	edi, edi
	je	SHORT $LN85@ExecuteExp

; 2293 : 		{
; 2294 : 			CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$227159[esp+992]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 2295 : 			args->Push(pUnit->getOwner());

	mov	eax, DWORD PTR [esi+40]
	mov	ecx, DWORD PTR _args$227159[esp+992]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR __$EHRec$[esp+1004], 2
	call	eax

; 2296 : 			args->Push(pUnit->GetID());

	mov	eax, DWORD PTR [esi+100]
	mov	ecx, DWORD PTR _args$227159[esp+992]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2297 : 
; 2298 : 			bool bResult;
; 2299 : 			LuaSupport::CallHook(pkScriptSystem, "UnitGetSpecialExploreTarget", args.get(), bResult);

	mov	edx, DWORD PTR _args$227159[esp+992]
	lea	ecx, DWORD PTR _bResult$227160[esp+992]
	push	ecx
	push	edx
	push	OFFSET $SG227161
	push	edi
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 2300 : 
; 2301 : 			if(bResult)

	cmp	BYTE PTR _bResult$227160[esp+992], 0

; 2302 : 			{
; 2303 : 				continue;

	mov	BYTE PTR __$EHRec$[esp+1000], 1
	lea	ecx, DWORD PTR _args$227159[esp+992]
	je	SHORT $LN84@ExecuteExp
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
	mov	BYTE PTR __$EHRec$[esp+1000], 0
	jmp	$LN785@ExecuteExp
$LN84@ExecuteExp:

; 2304 : 			}
; 2305 : 		}

	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN85@ExecuteExp:

; 2306 : 
; 2307 : 		if (!m_pPlayer->isHuman() && pUnit->CanStartMission(CvTypes::getMISSION_SELL_EXOTIC_GOODS(), -1, -1))

	mov	ecx, DWORD PTR [ebx]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	$LN81@ExecuteExp
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SELL_EXOTIC_GOODS@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SELL_EXOTIC_GOODS
	push	eax
	mov	ecx, esi
	call	?CanStartMission@CvUnit@@QAE_NHHHPAVCvPlot@@_N@Z ; CvUnit::CanStartMission
	test	al, al
	je	$LN81@ExecuteExp

; 2308 : 		{
; 2309 : 			// Far enough from home to get a good reward?
; 2310 : 			float fRewardFactor = pUnit->calculateExoticGoodsDistanceFactor(pUnit->plot());

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?calculateExoticGoodsDistanceFactor@CvUnit@@QAEMPBVCvPlot@@@Z ; CvUnit::calculateExoticGoodsDistanceFactor
	fstp	DWORD PTR _fRewardFactor$227164[esp+992]

; 2311 : 			if (fRewardFactor >= 0.5f)

	fld	DWORD PTR _fRewardFactor$227164[esp+992]
	fld	DWORD PTR __real@3f000000
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	$LN81@ExecuteExp

; 2312 : 			{
; 2313 : 				pUnit->PushMission(CvTypes::getMISSION_SELL_EXOTIC_GOODS());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SELL_EXOTIC_GOODS@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SELL_EXOTIC_GOODS
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2314 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN81@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN81@ExecuteExp

; 2315 : 				{
; 2316 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227167[esp+992]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2317 : 					strLogString.Format("UnitID: %d used Sell Exotic Goods, X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [esi+100]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strLogString$227167[esp+1004]
	push	OFFSET $SG227168
	push	eax
	mov	BYTE PTR __$EHRec$[esp+1020], 3
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2318 : 					LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227167[esp+992]
	push	ecx
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2319 : 				}

	lea	ecx, DWORD PTR _strLogString$227167[esp+992]
	mov	BYTE PTR __$EHRec$[esp+1000], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN81@ExecuteExp:

; 2320 : 			}
; 2321 : 		}
; 2322 : 
; 2323 : 		int iUnitX = pUnit->getX();

	mov	ebp, DWORD PTR [esi+76]

; 2324 : 		int iUnitY = pUnit->getY();

	mov	edx, DWORD PTR [esi+88]

; 2325 : 
; 2326 : 		CvPlot* pkStepPlot = NULL;
; 2327 : 		CvPlot* pGoodyPlot = pEconomicAI->GetUnitTargetGoodyPlot(pUnit.pointer(), &pkStepPlot);

	mov	ecx, DWORD PTR _pEconomicAI$[esp+992]
	lea	eax, DWORD PTR _pkStepPlot$227171[esp+992]
	push	eax
	push	esi
	mov	DWORD PTR _iUnitX$227169[esp+1000], ebp
	mov	DWORD PTR _iUnitY$227170[esp+1000], edx
	mov	DWORD PTR _pkStepPlot$227171[esp+1000], 0
	call	?GetUnitTargetGoodyPlot@CvEconomicAI@@QAEPAVCvPlot@@PAVCvUnit@@PAPAV2@@Z ; CvEconomicAI::GetUnitTargetGoodyPlot
	mov	edi, eax

; 2328 : 		if (pGoodyPlot)

	test	edi, edi
	je	$LN65@ExecuteExp

; 2329 : 		{
; 2330 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN79@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN79@ExecuteExp

; 2331 : 			{
; 2332 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227175[esp+992]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2333 : 				strLogString.Format("UnitID: %d has goody target, X: %d, Y: %d", pUnit->GetID(), pGoodyPlot->getX(), pGoodyPlot->getY());

	movsx	ecx, WORD PTR [edi+2]
	movsx	edx, WORD PTR [edi]
	mov	eax, DWORD PTR [esi+100]
	push	ecx
	push	edx
	push	eax
	lea	eax, DWORD PTR _strLogString$227175[esp+1004]
	push	OFFSET $SG227176
	push	eax
	mov	BYTE PTR __$EHRec$[esp+1020], 4
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2334 : 				LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227175[esp+992]
	push	ecx
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2335 : 			}

	lea	ecx, DWORD PTR _strLogString$227175[esp+992]
	mov	BYTE PTR __$EHRec$[esp+1000], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN79@ExecuteExp:

; 2336 : 		}
; 2337 : 
; 2338 : #ifdef AUI_WARNING_FIXES
; 2339 : 		if (pGoodyPlot && (pGoodyPlot->isGoody(m_pPlayer->getTeam()) || (pGoodyPlot->HasBarbarianCamp() && !pGoodyPlot->isVisibleEnemyDefender(pUnit.pointer()))))
; 2340 : #else
; 2341 : 		if(pGoodyPlot && (pGoodyPlot->isGoody(m_pPlayer->getTeam()) || (pGoodyPlot->HasBarbarianCamp()) && !pGoodyPlot->isVisibleEnemyDefender(pUnit.pointer())))

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN261@ExecuteExp
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN262@ExecuteExp
$LN261@ExecuteExp:
	or	eax, -1
$LN262@ExecuteExp:
	push	eax
	mov	ecx, edi
	call	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isGoody
	test	al, al
	jne	SHORT $LN77@ExecuteExp
	mov	ecx, edi
	call	?HasBarbarianCamp@CvPlot@@QAE_NXZ	; CvPlot::HasBarbarianCamp
	test	al, al
	je	$LN65@ExecuteExp
	push	esi
	mov	ecx, edi
	call	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyDefender
	test	al, al
	jne	$LN65@ExecuteExp
$LN77@ExecuteExp:

; 2342 : #endif
; 2343 : 		{
; 2344 : 			bool bCanFindPath = false;
; 2345 : 			if (pkStepPlot)	// Do we already have our first step point?

	mov	eax, DWORD PTR _pkStepPlot$227171[esp+992]
	mov	BYTE PTR _bCanFindPath$227179[esp+992], 0
	test	eax, eax
	je	SHORT $LN73@ExecuteExp

; 2346 : 			{
; 2347 : 				if (IsValidExplorerEndTurnPlot(pUnit.pointer(), pkStepPlot))

	push	eax
	push	esi
	mov	ecx, ebx
	call	?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z ; CvHomelandAI::IsValidExplorerEndTurnPlot
	test	al, al
	je	SHORT $LN75@ExecuteExp

; 2348 : 					bCanFindPath = true;

	mov	BYTE PTR _bCanFindPath$227179[esp+992], 1
$LN75@ExecuteExp:

; 2349 : 
; 2350 : 				// The economic AI should recalculate next time through, but just in case, let's say that we've used the step plot
; 2351 : 				pEconomicAI->ClearUnitTargetGoodyStepPlot(pUnit.pointer());

	mov	ecx, DWORD PTR _pEconomicAI$[esp+992]
	push	esi
	call	?ClearUnitTargetGoodyStepPlot@CvEconomicAI@@QAEXPAVCvUnit@@@Z ; CvEconomicAI::ClearUnitTargetGoodyStepPlot

; 2352 : 			}
; 2353 : 
; 2354 : 			if (!pkStepPlot || !bCanFindPath)

	mov	eax, DWORD PTR _pkStepPlot$227171[esp+992]
	test	eax, eax
	je	SHORT $LN73@ExecuteExp
	cmp	BYTE PTR _bCanFindPath$227179[esp+992], 0
	jne	SHORT $LN765@ExecuteExp
$LN73@ExecuteExp:

; 2355 : 			{
; 2356 : 				bCanFindPath = kPathFinder.GenerateUnitPath(pUnit.pointer(), iUnitX, iUnitY, pGoodyPlot->getX(), pGoodyPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	1
	push	138					; 0000008aH
	push	eax
	mov	eax, DWORD PTR _iUnitY$227170[esp+1004]
	push	ecx
	mov	ecx, DWORD PTR _kPathFinder$[esp+1008]
	push	eax
	push	ebp
	push	esi
	call	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath

; 2357 : 				if(bCanFindPath)

	test	al, al
	je	$LN71@ExecuteExp

; 2358 : 				{
; 2359 : 					pkStepPlot = kPathFinder.GetPathEndTurnPlot();

	mov	ecx, DWORD PTR _kPathFinder$[esp+992]
	call	?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ ; CvTwoLayerPathFinder::GetPathEndTurnPlot
	mov	DWORD PTR _pkStepPlot$227171[esp+992], eax
$LN765@ExecuteExp:

; 2360 : 				}
; 2361 : 			}
; 2362 : 
; 2363 : 			if (bCanFindPath)
; 2364 : 			{
; 2365 : 				if(pkStepPlot)
; 2366 : 				{
; 2367 : 					CvAssert(!pUnit->atPlot(*pkStepPlot));
; 2368 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	test	eax, eax
	je	$LN70@ExecuteExp
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN69@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN69@ExecuteExp

; 2369 : 					{
; 2370 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227188[esp+992]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2371 : 						strLogString.Format("UnitID: %d Moving to goody hut, X: %d, Y: %d, from X: %d Y: %d", pUnit->GetID(), pkStepPlot->getX(), pkStepPlot->getY(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [esi+100]
	push	eax
	mov	eax, DWORD PTR _pkStepPlot$227171[esp+996]
	push	ecx
	movsx	ecx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	ecx
	push	eax
	push	edx
	lea	ecx, DWORD PTR _strLogString$227188[esp+1012]
	push	OFFSET $SG227189
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+1028], 5
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 2372 : 						LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227188[esp+992]
	push	edx
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2373 : 					}

	lea	ecx, DWORD PTR _strLogString$227188[esp+992]
	mov	BYTE PTR __$EHRec$[esp+1000], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN69@ExecuteExp:

; 2374 : 					pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pkStepPlot->getX(), pkStepPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER, false, false, MISSIONAI_EXPLORE, pkStepPlot);

	mov	eax, DWORD PTR _pkStepPlot$227171[esp+992]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	0
	push	eax
	push	14					; 0000000eH
	push	0
	push	0
	push	138					; 0000008aH
	push	ecx
	push	edx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2375 : #ifndef AUI_HOMELAND_FIX_EXECUTE_EXPLORER_MOVES_MOVE_AFTER_GOODY
; 2376 : 					pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 2377 : 					UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR [esi+100]
	push	eax
	mov	ecx, ebx
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 2388 : 				}
; 2389 : 
; 2390 : 				continue;

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+1000], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ebp, DWORD PTR _it$[esp+992]
	jmp	$LN89@ExecuteExp
$LN70@ExecuteExp:

; 2378 : #endif
; 2379 : 				}
; 2380 : 				else
; 2381 : 				{
; 2382 : 					if(GC.getLogging() && GC.getAILogging())

	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN67@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN67@ExecuteExp

; 2383 : 					{
; 2384 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227192[esp+992]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2385 : 						strLogString.Format("UnitID: %d No end turn plot to goody from, X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [esi+100]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strLogString$227192[esp+1004]
	push	OFFSET $SG227193
	push	eax
	mov	BYTE PTR __$EHRec$[esp+1020], 6
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2386 : 						LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227192[esp+992]
	push	ecx
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2387 : 					}

	lea	ecx, DWORD PTR _strLogString$227192[esp+992]
	mov	BYTE PTR __$EHRec$[esp+1000], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN67@ExecuteExp:

; 2388 : 				}
; 2389 : 
; 2390 : 				continue;

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+1000], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ebp, DWORD PTR _it$[esp+992]
	jmp	$LN89@ExecuteExp
$LN71@ExecuteExp:

; 2391 : 
; 2392 : 			}
; 2393 : 			else
; 2394 : 			{
; 2395 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN65@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN65@ExecuteExp

; 2396 : 				{
; 2397 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227196[esp+992]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2398 : 					strLogString.Format("UnitID: %d Can't find path to goody from, X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [esi+100]
	push	eax
	push	ecx
	push	edx
	lea	edx, DWORD PTR _strLogString$227196[esp+1004]
	push	OFFSET $SG227197
	push	edx
	mov	BYTE PTR __$EHRec$[esp+1020], 7
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2399 : 					LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227196[esp+992]
	push	eax
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2400 : 				}

	lea	ecx, DWORD PTR _strLogString$227196[esp+992]
	mov	BYTE PTR __$EHRec$[esp+1000], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN65@ExecuteExp:

; 2401 : 			}
; 2402 : 		}
; 2403 : 
; 2404 : 		CvPlot* pBestPlot = NULL;
; 2405 : 		int iBestPlotScore = 0;
; 2406 : 
; 2407 : #if defined(PATH_PLAN_LAST)
; 2408 : 		aBestPlotList.clear();
; 2409 : #endif
; 2410 : 		TeamTypes eTeam = pUnit->getTeam();

	mov	ecx, esi
	mov	DWORD PTR _aBestPlotList$[esp+996], 0
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam

; 2411 : 		int iBaseSightRange = pUnit->getUnitInfo().GetBaseSightRange();

	mov	ecx, esi
	mov	DWORD PTR _eTeam$227200[esp+992], eax
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetBaseSightRange@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetBaseSightRange

; 2412 : 
; 2413 : 		int iMovementRange = pUnit->movesLeft() / GC.getMOVE_DENOMINATOR();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	ecx, esi
	mov	DWORD PTR _iBaseSightRange$227201[esp+992], eax
	call	?movesLeft@CvUnit@@QBEHXZ		; CvUnit::movesLeft
	cdq
	idiv	edi

; 2414 : 
; 2415 : 		// if iMovesLeft value is greater than zero but not enough to be a positive integer when divided by move_denominator
; 2416 : 		// then just give them an extra movement. Who could it hurt, right?
; 2417 : 		if (pUnit->movesLeft() > 0 && iMovementRange == 0)

	mov	ecx, esi
	mov	edi, eax
	mov	DWORD PTR _iMovementRange$227202[esp+992], edi
	call	?movesLeft@CvUnit@@QBEHXZ		; CvUnit::movesLeft
	test	eax, eax
	jle	SHORT $LN64@ExecuteExp
	test	edi, edi
	jne	SHORT $LN64@ExecuteExp

; 2418 : 		{
; 2419 : 			iMovementRange = 1;

	mov	DWORD PTR _iMovementRange$227202[esp+992], 1
$LN64@ExecuteExp:

; 2420 : 		}
; 2421 : 
; 2422 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2423 : 		int iMaxDX, iDX;
; 2424 : 		CvPlot* pEvalPlot;
; 2425 : 		for (int iDY = -iMovementRange; iDY <= iMovementRange; iDY++)
; 2426 : 		{
; 2427 : 			iMaxDX = iMovementRange - MAX(0, iDY);
; 2428 : 			for (iDX = -iMovementRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 2429 : 			{
; 2430 : 				// No need for range check because loops are set up properly
; 2431 : 				pEvalPlot = plotXY(iUnitX, iUnitY, iDX, iDY);
; 2432 : #else
; 2433 : 		for(int iX = -iMovementRange; iX <= iMovementRange; iX++)

	mov	eax, DWORD PTR _iMovementRange$227202[esp+992]
	mov	ebp, eax
	neg	ebp
	cmp	ebp, eax
	mov	DWORD PTR tv2059[esp+992], ebp
	mov	DWORD PTR _iX$227204[esp+992], ebp
	jg	$LN769@ExecuteExp
	mov	eax, ebp
	neg	eax
	mov	DWORD PTR tv2596[esp+992], eax
	npad	10
$LL63@ExecuteExp:

; 2434 : 		{
; 2435 : 			for(int iY = -iMovementRange; iY <= iMovementRange; iY++)

	mov	ebx, DWORD PTR tv2059[esp+992]
	cmp	ebx, DWORD PTR _iMovementRange$227202[esp+992]
	mov	DWORD PTR _iY$227208[esp+992], ebx
	jg	$LN62@ExecuteExp

; 2436 : 			{
; 2437 : 				CvPlot* pEvalPlot = plotXYWithRangeCheck(iUnitX, iUnitY, iX, iY, iMovementRange);

	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	mov	eax, ebx
	neg	eax
	mov	DWORD PTR tv2581[esp+992], eax
	mov	DWORD PTR tv2063[esp+992], ecx
$LL60@ExecuteExp:
	xor	edx, edx
	test	ebx, ebx
	setge	dl
	mov	ecx, ebp
	cmp	DWORD PTR tv2063[esp+992], edx
	jne	SHORT $LN395@ExecuteExp
	test	ebp, ebp
	jge	SHORT $LN399@ExecuteExp
	mov	ecx, DWORD PTR tv2596[esp+992]
$LN399@ExecuteExp:
	mov	eax, ebx
	test	ebx, ebx
	jge	SHORT $LN401@ExecuteExp
	mov	eax, DWORD PTR tv2581[esp+992]
$LN401@ExecuteExp:
	add	eax, ecx
	jmp	SHORT $LN406@ExecuteExp
$LN395@ExecuteExp:
	test	ebp, ebp
	jge	SHORT $LN403@ExecuteExp
	mov	ecx, DWORD PTR tv2596[esp+992]
$LN403@ExecuteExp:
	mov	eax, ebx
	test	ebx, ebx
	jge	SHORT $LN405@ExecuteExp
	mov	eax, DWORD PTR tv2581[esp+992]
$LN405@ExecuteExp:
	cmp	ecx, eax
	jl	SHORT $LN406@ExecuteExp
	mov	eax, ecx
$LN406@ExecuteExp:
	cmp	eax, DWORD PTR _iMovementRange$227202[esp+992]
	jg	$LN59@ExecuteExp
	mov	eax, DWORD PTR _iUnitY$227170[esp+992]
	mov	ecx, DWORD PTR _iUnitX$227169[esp+992]
	push	ebx
	push	ebp
	push	eax
	push	ecx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	edi, eax
	add	esp, 16					; 00000010H

; 2438 : #endif
; 2439 : 				if(!pEvalPlot)

	test	edi, edi
	je	$LN59@ExecuteExp

; 2440 : 				{
; 2441 : 					continue;
; 2442 : 				}
; 2443 : 
; 2444 : 				if(!IsValidExplorerEndTurnPlot(pUnit.pointer(), pEvalPlot))

	mov	ecx, DWORD PTR _this$[esp+992]
	push	edi
	push	esi
	call	?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z ; CvHomelandAI::IsValidExplorerEndTurnPlot
	test	al, al
	je	$LN59@ExecuteExp

; 2445 : 				{
; 2446 : 					continue;
; 2447 : 				}
; 2448 : 
; 2449 : #if !defined(PATH_PLAN_LAST)
; 2450 : 				bool bCanFindPath = kPathFinder.GenerateUnitPath(pUnit.pointer(), pUnit->getX(), pUnit->getY(), pEvalPlot->getX(), pEvalPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);
; 2451 : 				if(!bCanFindPath)
; 2452 : 				{
; 2453 : 					continue;
; 2454 : 				}
; 2455 : 
; 2456 : 				CvAStarNode* pNode = kPathFinder.GetLastNode();
; 2457 : 				int iDistance = pNode->m_iData2;
; 2458 : 				if(iDistance > 1)
; 2459 : 				{
; 2460 : 					continue;
; 2461 : 				}
; 2462 : #endif
; 2463 : 
; 2464 : 				DomainTypes eDomain = pUnit->getDomainType();

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType

; 2465 : 				int iScore = CvEconomicAI::ScoreExplorePlot(pEvalPlot, eTeam, iBaseSightRange, eDomain);

	mov	edx, DWORD PTR _iBaseSightRange$227201[esp+992]
	mov	ebp, eax
	mov	eax, DWORD PTR _eTeam$227200[esp+992]
	push	ebp
	push	edx
	push	eax
	push	edi
	call	?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z ; CvEconomicAI::ScoreExplorePlot
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 2466 : 				if(iScore > 0)

	test	ebx, ebx
	jle	$LN772@ExecuteExp

; 2467 : 				{
; 2468 : 					if (eDomain == DOMAIN_LAND)

	cmp	ebp, 2
	jne	SHORT $LN54@ExecuteExp

; 2469 : 					{
; 2470 : 						if (pEvalPlot->isHills())

	cmp	BYTE PTR [edi+5], 1
	jne	SHORT $LN53@ExecuteExp

; 2471 : 						{
; 2472 : 							iScore += 50;

	add	ebx, 50					; 00000032H
$LN53@ExecuteExp:

; 2473 : 						}
; 2474 : 						if (pUnit->IsEmbarkAllWater() && !pEvalPlot->isShallowWater())

	mov	ecx, esi
	call	?IsEmbarkAllWater@CvUnit@@QBE_NXZ	; CvUnit::IsEmbarkAllWater
	test	al, al
	je	SHORT $LN45@ExecuteExp
	mov	ecx, edi
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	test	al, al
	jne	SHORT $LN45@ExecuteExp

; 2475 : 						{
; 2476 : 							iScore += 200;
; 2477 : 						}
; 2478 : 					}

	jmp	SHORT $LN786@ExecuteExp
$LN54@ExecuteExp:

; 2479 : 					else if (eDomain == DOMAIN_SEA)

	test	ebp, ebp
	jne	SHORT $LN45@ExecuteExp

; 2480 : 					{
; 2481 : 						if(pUnit->canSellExoticGoods(pEvalPlot))

	push	ebp
	push	edi
	mov	ecx, esi
	call	?canSellExoticGoods@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canSellExoticGoods
	test	al, al
	je	SHORT $LN46@ExecuteExp

; 2482 : 						{
; 2483 : 							float fRewardFactor = pUnit->calculateExoticGoodsDistanceFactor(pEvalPlot);

	push	edi
	mov	ecx, esi
	call	?calculateExoticGoodsDistanceFactor@CvUnit@@QAEMPBVCvPlot@@@Z ; CvUnit::calculateExoticGoodsDistanceFactor
	fstp	DWORD PTR _fRewardFactor$227224[esp+992]

; 2484 : 							if (fRewardFactor >= 0.75f)

	fld	DWORD PTR _fRewardFactor$227224[esp+992]
	fld	DWORD PTR __real@3f400000
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN48@ExecuteExp
	fstp	ST(0)

; 2485 : 							{
; 2486 : 								iScore += 150;

	add	ebx, 150				; 00000096H
	jmp	SHORT $LN46@ExecuteExp
$LN48@ExecuteExp:

; 2487 : 							}
; 2488 : 							else if (fRewardFactor >= 0.5f)

	fld	DWORD PTR __real@3f000000
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN46@ExecuteExp

; 2489 : 							{
; 2490 : 								iScore += 75;

	add	ebx, 75					; 0000004bH
$LN46@ExecuteExp:

; 2491 : 							}
; 2492 : 						}
; 2493 : 
; 2494 : 						if(pEvalPlot->isAdjacentToLand())

	mov	ecx, edi
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	test	al, al
	je	SHORT $LN45@ExecuteExp
$LN786@ExecuteExp:

; 2495 : 						{
; 2496 : 							iScore += 200;

	add	ebx, 200				; 000000c8H
$LN45@ExecuteExp:

; 2497 : 						}
; 2498 : 					}
; 2499 : 
; 2500 : #if defined(PATH_PLAN_LAST)
; 2501 : 					aBestPlotList.push_back(pEvalPlot, iScore);

	mov	eax, DWORD PTR _aBestPlotList$[esp+1000]
	mov	BYTE PTR _aBestPlotList$[esp+1804], 0
	cmp	DWORD PTR _aBestPlotList$[esp+996], eax
	jne	SHORT $LN424@ExecuteExp
	push	eax
	lea	ecx, DWORD PTR _aBestPlotList$[esp+996]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSize
$LN424@ExecuteExp:
	mov	ecx, DWORD PTR _aBestPlotList$[esp+992]
	mov	edx, DWORD PTR _aBestPlotList$[esp+996]
	lea	eax, DWORD PTR [ecx+edx*8]
	test	eax, eax
	je	SHORT $LN427@ExecuteExp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ebx
$LN427@ExecuteExp:
	inc	DWORD PTR _aBestPlotList$[esp+996]
$LN772@ExecuteExp:
	mov	ebp, DWORD PTR _iX$227204[esp+992]
	mov	ebx, DWORD PTR _iY$227208[esp+992]
$LN59@ExecuteExp:
	dec	DWORD PTR tv2581[esp+992]
	inc	ebx
	cmp	ebx, DWORD PTR _iMovementRange$227202[esp+992]
	mov	DWORD PTR _iY$227208[esp+992], ebx
	jle	$LL60@ExecuteExp
$LN62@ExecuteExp:

; 2420 : 		}
; 2421 : 
; 2422 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2423 : 		int iMaxDX, iDX;
; 2424 : 		CvPlot* pEvalPlot;
; 2425 : 		for (int iDY = -iMovementRange; iDY <= iMovementRange; iDY++)
; 2426 : 		{
; 2427 : 			iMaxDX = iMovementRange - MAX(0, iDY);
; 2428 : 			for (iDX = -iMovementRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 2429 : 			{
; 2430 : 				// No need for range check because loops are set up properly
; 2431 : 				pEvalPlot = plotXY(iUnitX, iUnitY, iDX, iDY);
; 2432 : #else
; 2433 : 		for(int iX = -iMovementRange; iX <= iMovementRange; iX++)

	dec	DWORD PTR tv2596[esp+992]
	inc	ebp
	cmp	ebp, DWORD PTR _iMovementRange$227202[esp+992]
	mov	DWORD PTR _iX$227204[esp+992], ebp
	jle	$LL63@ExecuteExp
$LN769@ExecuteExp:
	mov	eax, DWORD PTR _aBestPlotList$[esp+996]
	mov	ecx, DWORD PTR _aBestPlotList$[esp+992]

; 2502 : #endif
; 2503 : 				}
; 2504 : 
; 2505 : #if !defined(PATH_PLAN_LAST)
; 2506 : 				if(iScore > iBestPlotScore)
; 2507 : 				{
; 2508 : 					pBestPlot = pEvalPlot;
; 2509 : 					iBestPlotScore = iScore;
; 2510 : 					bFoundNearbyExplorePlot = true;
; 2511 : 				}
; 2512 : #endif
; 2513 : 			}
; 2514 : 		}
; 2515 : 
; 2516 : #if defined(PATH_PLAN_LAST)
; 2517 : 		uint uiListSize;
; 2518 : 		if ((uiListSize = aBestPlotList.size()) > 0)

	mov	edi, eax
	mov	DWORD PTR _uiListSize$227229[esp+992], edi
	test	eax, eax
	jbe	SHORT $LN778@ExecuteExp

; 2519 : 		{
; 2520 : 			aBestPlotList.SortItems();	// highest score will be first.

	lea	eax, DWORD PTR [ecx+eax*8]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 2521 : 			for (uint i = 0; i < uiListSize; ++i )	

	xor	ebx, ebx
	test	edi, edi
	jbe	SHORT $LN778@ExecuteExp
	mov	ebp, DWORD PTR _iUnitX$227169[esp+992]
$LL43@ExecuteExp:

; 2522 : 			{
; 2523 : 				CvPlot* pPlot = aBestPlotList.GetElement(i);

	mov	eax, DWORD PTR _aBestPlotList$[esp+992]
	mov	edi, DWORD PTR [eax+ebx*8]

; 2524 : 				bool bCanFindPath = kPathFinder.GenerateUnitPath(pUnit.pointer(), iUnitX, iUnitY, pPlot->getX(), pPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	1
	push	138					; 0000008aH
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _iUnitY$227170[esp+1008]
	push	ecx
	mov	ecx, DWORD PTR _kPathFinder$[esp+1012]
	push	ebp
	push	esi
	call	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath

; 2525 : 				if(!bCanFindPath)

	test	al, al
	je	SHORT $LN42@ExecuteExp

; 2526 : 				{
; 2527 : 					continue;
; 2528 : 				}
; 2529 : 
; 2530 : 				CvAStarNode* pNode = GC.getPathFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	eax, DWORD PTR [eax+96]

; 2531 : 				int iDistance = pNode->m_iData2;
; 2532 : 				if(iDistance <= 1)

	cmp	DWORD PTR [eax+16], 1
	jle	$LN764@ExecuteExp
$LN42@ExecuteExp:

; 2521 : 			for (uint i = 0; i < uiListSize; ++i )	

	inc	ebx
	cmp	ebx, DWORD PTR _uiListSize$227229[esp+992]
	jb	SHORT $LL43@ExecuteExp
$LN778@ExecuteExp:

; 2533 : 				{
; 2534 : 					pBestPlot = pPlot;
; 2535 : 					break;
; 2536 : 				}
; 2537 : 			}
; 2538 : 		}
; 2539 : #endif
; 2540 : 
; 2541 : 		if(!pBestPlot && iMovementRange > 0)

	cmp	DWORD PTR _iMovementRange$227202[esp+992], 0
	jle	$LN19@ExecuteExp

; 2542 : 		{
; 2543 : 			FFastVector<int>& aiExplorationPlots = pEconomicAI->GetExplorationPlots();

	mov	ecx, DWORD PTR _pEconomicAI$[esp+992]
	call	?GetExplorationPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ; CvEconomicAI::GetExplorationPlots

; 2544 : 			if (aiExplorationPlots.size() > 0)

	cmp	DWORD PTR [eax+4], 0
	mov	DWORD PTR _aiExplorationPlots$227251[esp+992], eax
	jbe	$LN19@ExecuteExp

; 2545 : 			{
; 2546 : 				FFastVector<int>& aiExplorationPlotRatings = pEconomicAI->GetExplorationPlotRatings();

	mov	ecx, DWORD PTR _pEconomicAI$[esp+992]
	call	?GetExplorationPlotRatings@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ; CvEconomicAI::GetExplorationPlotRatings

; 2547 : 
; 2548 : 				aBestPlotList.clear();
; 2549 : 				aBestPlotList.reserve(aiExplorationPlots.size());

	mov	ebx, DWORD PTR _aiExplorationPlots$227251[esp+992]
	xor	ebp, ebp
	mov	DWORD PTR _aiExplorationPlotRatings$227262[esp+992], eax
	mov	DWORD PTR _aBestPlotList$[esp+996], ebp
	mov	eax, DWORD PTR [ebx+4]
	push	eax
	lea	ecx, DWORD PTR _aBestPlotList$[esp+996]
	call	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSizeToFit

; 2550 : 
; 2551 : 				iBestPlotScore = 0;
; 2552 : 
; 2553 : 				for(uint ui = 0; ui < aiExplorationPlots.size(); ui++)

	cmp	DWORD PTR [ebx+4], ebp
	jbe	$LN771@ExecuteExp
$LL780@ExecuteExp:

; 2554 : 				{
; 2555 : 					int iPlot = aiExplorationPlots[ui];

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+ebp*4]

; 2556 : 					if(iPlot < 0)

	test	eax, eax
	jl	$LN35@ExecuteExp

; 2557 : 					{
; 2558 : 						continue;
; 2559 : 					}
; 2560 : 
; 2561 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2562 : 					pEvalPlot = GC.getMap().plotByIndex(iPlot);
; 2563 : #else
; 2564 : 					CvPlot* pEvalPlot = GC.getMap().plotByIndex(iPlot);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [ecx+4028]
	jge	$LN35@ExecuteExp
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	mov	edi, eax

; 2565 : #endif
; 2566 : 					if(!pEvalPlot)

	je	$LN35@ExecuteExp

; 2567 : 					{
; 2568 : 						continue;
; 2569 : 					}
; 2570 : 
; 2571 : 					int iPlotScore = 0;
; 2572 : 
; 2573 : 					if(!IsValidExplorerEndTurnPlot(pUnit.pointer(), pEvalPlot))

	mov	ecx, DWORD PTR _this$[esp+992]
	push	edi
	push	esi
	call	?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z ; CvHomelandAI::IsValidExplorerEndTurnPlot
	test	al, al
	je	$LN35@ExecuteExp

; 2574 : 					{
; 2575 : 						continue;
; 2576 : 					}
; 2577 : 
; 2578 : 					int iRating = aiExplorationPlotRatings[ui];

	mov	eax, DWORD PTR _aiExplorationPlotRatings$227262[esp+992]
	mov	ecx, DWORD PTR [eax]

; 2579 : 
; 2580 : #if defined(PATH_PLAN_LAST)
; 2581 : 					int iDistance = plotDistance(iUnitX, iUnitY, pEvalPlot->getX(), pEvalPlot->getY());

	movsx	edx, WORD PTR [edi+2]
	movsx	eax, WORD PTR [edi]
	mov	ebx, DWORD PTR [ecx+ebp*4]
	mov	ecx, DWORD PTR _iUnitY$227170[esp+992]
	push	edx
	mov	edx, DWORD PTR _iUnitX$227169[esp+996]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance

; 2582 : 					int iEstimateTurns = iDistance / iMovementRange;

	cdq
	idiv	DWORD PTR _iMovementRange$227202[esp+1008]
	add	esp, 16					; 00000010H
	mov	ecx, eax

; 2583 : 					if(iEstimateTurns == 0)

	test	ecx, ecx
	jne	SHORT $LN30@ExecuteExp

; 2584 : 					{
; 2585 : 						iPlotScore = 1000 * iRating;

	imul	ebx, 1000				; 000003e8H

; 2586 : 					}
; 2587 : 					else

	jmp	SHORT $LN29@ExecuteExp
$LN30@ExecuteExp:

; 2588 : 					{
; 2589 : 						iPlotScore = (1000 * iRating) / iEstimateTurns;

	mov	eax, ebx
	imul	eax, 1000				; 000003e8H
	cdq
	idiv	ecx
	mov	ebx, eax
$LN29@ExecuteExp:

; 2590 : 					}
; 2591 : 
; 2592 : 					aBestPlotList.push_back(pEvalPlot, iPlotScore);

	mov	eax, DWORD PTR _aBestPlotList$[esp+1000]
	mov	BYTE PTR _aBestPlotList$[esp+1804], 0
	cmp	DWORD PTR _aBestPlotList$[esp+996], eax
	jne	SHORT $LN500@ExecuteExp
	push	eax
	lea	ecx, DWORD PTR _aBestPlotList$[esp+996]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSize
$LN500@ExecuteExp:
	mov	eax, DWORD PTR _aBestPlotList$[esp+996]
	mov	ecx, DWORD PTR _aBestPlotList$[esp+992]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN503@ExecuteExp
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ebx
$LN503@ExecuteExp:
	inc	DWORD PTR _aBestPlotList$[esp+996]
	mov	ebx, DWORD PTR _aiExplorationPlots$227251[esp+992]
$LN35@ExecuteExp:
	inc	ebp
	cmp	ebp, DWORD PTR [ebx+4]
	jb	$LL780@ExecuteExp
$LN771@ExecuteExp:

; 2593 : #else
; 2594 : 					// hitting the path finder, may not be the best idea. . .
; 2595 : 					bool bCanFindPath = GC.getPathFinder().GenerateUnitPath(pUnit.pointer(), iUnitX, iUnitY, pEvalPlot->getX(), pEvalPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);
; 2596 : 					if(!bCanFindPath)
; 2597 : 					{
; 2598 : 						continue;
; 2599 : 					}
; 2600 : 
; 2601 : 					CvAStarNode* pNode = GC.getPathFinder().GetLastNode();
; 2602 : 					int iDistance = pNode->m_iData2;
; 2603 : 					if(iDistance == 0)
; 2604 : 					{
; 2605 : 						iPlotScore = 1000 * iRating;
; 2606 : 					}
; 2607 : 					else
; 2608 : 					{
; 2609 : 						iPlotScore = (1000 * iRating) / iDistance;
; 2610 : 					}
; 2611 : 
; 2612 : 					if(iPlotScore > iBestPlotScore)
; 2613 : 					{
; 2614 : 						CvPlot* pEndTurnPlot = GC.getPathFinder().GetPathEndTurnPlot();
; 2615 : 						if(pEndTurnPlot == pUnit->plot())
; 2616 : 						{
; 2617 : 							pBestPlot = NULL;
; 2618 : 							iBestPlotScore = iPlotScore;
; 2619 : 						}
; 2620 : 						else if(IsValidExplorerEndTurnPlot(pUnit.pointer(), pEndTurnPlot))
; 2621 : 						{
; 2622 : 							pBestPlot = pEndTurnPlot;
; 2623 : 							iBestPlotScore = iPlotScore;
; 2624 : 						}
; 2625 : 						else
; 2626 : 						{
; 2627 : 							// not a valid destination
; 2628 : 							continue;
; 2629 : 						}
; 2630 : 					}
; 2631 : #endif
; 2632 : 				}
; 2633 : 
; 2634 : #if defined(PATH_PLAN_LAST)
; 2635 : 				if ((uiListSize = aBestPlotList.size()) > 0)

	mov	ebp, DWORD PTR _aBestPlotList$[esp+996]
	test	ebp, ebp
	jbe	$LN19@ExecuteExp

; 2636 : 				{
; 2637 : 					aBestPlotList.SortItems();		// Highest score will be first.

	mov	ecx, DWORD PTR _aBestPlotList$[esp+992]
	lea	eax, DWORD PTR [ecx+ebp*8]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 2638 : 					for (uint i = 0; i < uiListSize ; ++i )	

	xor	edi, edi
	test	ebp, ebp
	jbe	SHORT $LN19@ExecuteExp
$LL27@ExecuteExp:

; 2639 : 					{
; 2640 : 						CvPlot* pPlot = aBestPlotList.GetElement(i);

	mov	eax, DWORD PTR _aBestPlotList$[esp+992]
	mov	eax, DWORD PTR [eax+edi*8]

; 2641 : 						bool bCanFindPath = GC.getPathFinder().GenerateUnitPath(pUnit.pointer(), iUnitX, iUnitY, pPlot->getX(), pPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);

	movsx	ecx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	mov	edx, DWORD PTR _iUnitX$227169[esp+992]
	push	1
	push	138					; 0000008aH
	push	ecx
	mov	ecx, DWORD PTR _iUnitY$227170[esp+1004]
	push	eax
	push	ecx
	push	edx
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	ecx, eax
	call	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath

; 2642 : 						if(!bCanFindPath)

	test	al, al
	je	SHORT $LN26@ExecuteExp

; 2643 : 						{
; 2644 : 							continue;
; 2645 : 						}
; 2646 : 
; 2647 : 						CvPlot* pEndTurnPlot = GC.getPathFinder().GetPathEndTurnPlot();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	ecx, eax
	call	?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ ; CvTwoLayerPathFinder::GetPathEndTurnPlot

; 2648 : 						if(pEndTurnPlot == pUnit->plot())

	mov	ecx, esi
	mov	ebx, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	ebx, eax
	je	SHORT $LN26@ExecuteExp

; 2649 : 						{
; 2650 : 							continue;
; 2651 : 						}
; 2652 : 						else if(IsValidExplorerEndTurnPlot(pUnit.pointer(), pEndTurnPlot))

	mov	ecx, DWORD PTR _this$[esp+992]
	push	ebx
	push	esi
	call	?IsValidExplorerEndTurnPlot@CvHomelandAI@@ABE_NPBVCvUnit@@PAVCvPlot@@@Z ; CvHomelandAI::IsValidExplorerEndTurnPlot
	test	al, al
	jne	$LN755@ExecuteExp
$LN26@ExecuteExp:

; 2638 : 					for (uint i = 0; i < uiListSize ; ++i )	

	inc	edi
	cmp	edi, ebp
	jb	SHORT $LL27@ExecuteExp
$LN19@ExecuteExp:

; 2694 : 		{
; 2695 : 			if(pUnit->isHuman())

	mov	ecx, esi
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	je	$LN13@ExecuteExp

; 2696 : 			{
; 2697 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN773@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN773@ExecuteExp

; 2698 : 				{
; 2699 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227302[esp+992]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2700 : 					strLogString.Format("UnitID: %d Explorer (human) found no target, X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [esi+100]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strLogString$227302[esp+1004]
	push	OFFSET $SG227303
	push	eax
	mov	BYTE PTR __$EHRec$[esp+1020], 9
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2701 : 					LogHomelandMessage(strLogString);

	mov	edi, DWORD PTR _this$[esp+1012]
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR _strLogString$227302[esp+992]
	push	ecx
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2702 : 				}

	lea	ecx, DWORD PTR _strLogString$227302[esp+992]
	mov	BYTE PTR __$EHRec$[esp+1000], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN12@ExecuteExp
$LN755@ExecuteExp:

; 2653 : 						{
; 2654 : 							pBestPlot = pEndTurnPlot;

	mov	edi, ebx

; 2655 : 							break;
; 2656 : 						}
; 2657 : 						else
; 2658 : 						{
; 2659 : 							// not a valid destination
; 2660 : 							continue;
; 2661 : 						}
; 2662 : 					}
; 2663 : 				}
; 2664 : #endif
; 2665 : 			}
; 2666 : 		}
; 2667 : 
; 2668 : 		if(pBestPlot)

	test	ebx, ebx
	je	$LN19@ExecuteExp
$LN764@ExecuteExp:

; 2669 : 		{
; 2670 : 			CvAssertMsg(!pUnit->atPlot(*pBestPlot), "Exploring unit is already at the best place to explore");
; 2671 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestPlot->getX(), pBestPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER, false, false, MISSIONAI_EXPLORE, pBestPlot);

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	0
	push	edi
	push	14					; 0000000eH
	push	0
	push	0
	push	138					; 0000008aH
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2672 : 
; 2673 : 			// Only mark as done if out of movement
; 2674 : 			if(pUnit->getMoves() <= 0)

	mov	ecx, esi
	call	?getMoves@CvUnit@@QBEHXZ		; CvUnit::getMoves
	test	eax, eax
	jg	SHORT $LN551@ExecuteExp

; 2675 : 			{
; 2676 : 				UnitProcessed(pUnit->GetID());

	mov	edi, DWORD PTR [esi+100]
	mov	ebx, DWORD PTR _this$[esp+992]
	lea	eax, DWORD PTR $T267339[esp+992]
	push	eax
	lea	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR $T267339[esp+996], edi
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN551@ExecuteExp
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN551@ExecuteExp:

; 2677 : 			}
; 2678 : 
; 2679 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteExp

; 2680 : 			{
; 2681 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227294[esp+992]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2682 : 				if(bFoundNearbyExplorePlot)
; 2683 : 				{
; 2684 : 					strLogString.Format("UnitID: %d Explored to nearby target, To X: %d, Y: %d, From X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY(), iUnitX, iUnitY);
; 2685 : 				}
; 2686 : 				else
; 2687 : 				{
; 2688 : 					strLogString.Format("UnitID: %d Explored to distant target, To X: %d, Y: %d, From X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY(), iUnitX, iUnitY);

	mov	edi, DWORD PTR _iUnitY$227170[esp+992]
	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [esi+100]
	push	edi
	mov	edi, DWORD PTR _iUnitX$227169[esp+996]
	push	edi
	push	eax
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _strLogString$227294[esp+1012]
	push	OFFSET $SG227298
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+1028], 8
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2689 : 				}
; 2690 : 				LogHomelandMessage(strLogString);

	mov	ecx, DWORD PTR _this$[esp+1020]
	add	esp, 28					; 0000001cH
	lea	edx, DWORD PTR _strLogString$227294[esp+992]
	push	edx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2691 : 			}

	lea	ecx, DWORD PTR _strLogString$227294[esp+992]

; 2692 : 		}
; 2693 : 		else

	jmp	$LN787@ExecuteExp
$LN773@ExecuteExp:

; 2702 : 				}

	mov	edi, DWORD PTR _this$[esp+992]
$LN12@ExecuteExp:

; 2703 : 				pUnit->SetAutomateType(NO_AUTOMATE);

	push	-1
	mov	ecx, esi
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 2704 : 				UnitProcessed(pUnit->GetID());

	mov	ebx, DWORD PTR [esi+100]
	lea	edx, DWORD PTR $T267488[esp+992]
	push	edx
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T267488[esp+996], ebx
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	$LN1@ExecuteExp
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed

; 2705 : 			}
; 2706 : 			else

	jmp	$LN1@ExecuteExp
$LN13@ExecuteExp:

; 2707 : 			{
; 2708 : 				// If this is a land explorer and there is no ignore unit path to a friendly city, then disband him
; 2709 : 				if(pUnit->AI_getUnitAIType() == UNITAI_EXPLORE)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	jne	$LN10@ExecuteExp

; 2710 : 				{
; 2711 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN774@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN774@ExecuteExp

; 2712 : 					{
; 2713 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227307[esp+992]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2714 : 						strLogString.Format("UnitID: %d Explorer (AI) found no target, X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [esi+100]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strLogString$227307[esp+1004]
	push	OFFSET $SG227308
	push	eax
	mov	BYTE PTR __$EHRec$[esp+1020], 10	; 0000000aH
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2715 : 						LogHomelandMessage(strLogString);

	mov	ebx, DWORD PTR _this$[esp+1012]
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR _strLogString$227307[esp+992]
	push	ecx
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2716 : 					}

	lea	ecx, DWORD PTR _strLogString$227307[esp+992]
	mov	BYTE PTR __$EHRec$[esp+1000], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	SHORT $LN9@ExecuteExp
$LN774@ExecuteExp:
	mov	ebx, DWORD PTR _this$[esp+992]
$LN9@ExecuteExp:

; 2717 : 
; 2718 : 					CvCity* pLoopCity;
; 2719 : 					int iLoop;
; 2720 : 					bool bFoundPath = false;
; 2721 : 					for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [ebx]
	push	0
	lea	edx, DWORD PTR _iLoop$227310[esp+996]
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	test	eax, eax
	je	SHORT $LN767@ExecuteExp
	npad	4
$LL8@ExecuteExp:

; 2722 : 					{
; 2723 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2724 : 						if (GC.getIgnoreUnitsPathFinder().DoesPathExist(pUnit.pointer(), pUnit->plot(), pLoopCity->plot()))
; 2725 : #else
; 2726 : 						if(GC.getIgnoreUnitsPathFinder().DoesPathExist(*(pUnit), pUnit->plot(), pLoopCity->plot()))

	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	ecx, eax
	call	?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z ; CvIgnoreUnitsPathFinder::DoesPathExist
	test	al, al
	jne	$LN1@ExecuteExp
	mov	ecx, DWORD PTR [ebx]
	push	0
	lea	eax, DWORD PTR _iLoop$227310[esp+996]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL8@ExecuteExp
$LN767@ExecuteExp:

; 2727 : #endif
; 2728 : 						{
; 2729 : 							bFoundPath = true;
; 2730 : 							break;
; 2731 : 						}
; 2732 : 					}
; 2733 : 					if(!bFoundPath)
; 2734 : 					{
; 2735 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227317[esp+992]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2736 : 						strLogString.Format("UnitID: %d Disbanding explorer, X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [esi+100]
	push	eax
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _strLogString$227317[esp+1004]
	push	OFFSET $SG227318
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+1020], 11	; 0000000bH
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2737 : 						LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227317[esp+992]
	push	edx
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2738 : 
; 2739 : 						UnitProcessed(pUnit->GetID());

	mov	edi, DWORD PTR [esi+100]
	lea	eax, DWORD PTR $T267602[esp+992]
	push	eax
	lea	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR $T267602[esp+996], edi
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN775@ExecuteExp
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN775@ExecuteExp:

; 2740 : #ifdef AUI_HOMELAND_FIX_EXECUTE_EXPLORER_MOVES_DISBAND
; 2741 : 						pUnit->scrap();
; 2742 : #else
; 2743 : 						pUnit->kill(true);

	push	-1
	push	1
	mov	ecx, esi
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill

; 2744 : #endif
; 2745 : 						m_pPlayer->GetEconomicAI()->IncrementExplorersDisbanded();

	mov	ecx, DWORD PTR [ebx]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	inc	DWORD PTR [eax+36]

; 2746 : 					}

	lea	ecx, DWORD PTR _strLogString$227317[esp+992]

; 2747 : 				}

	jmp	$LN787@ExecuteExp
$LN10@ExecuteExp:

; 2748 : 				else if(pUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	jne	$LN1@ExecuteExp

; 2749 : 				{
; 2750 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@ExecuteExp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@ExecuteExp

; 2751 : 					{
; 2752 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227322[esp+992]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2753 : 						strLogString.Format("UnitID: %d Sea explorer (AI) found no target, X: %d, Y: %d", pUnit->GetID(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [esi+100]
	push	eax
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _strLogString$227322[esp+1004]
	push	OFFSET $SG227323
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+1020], 12	; 0000000cH
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 2754 : 						LogHomelandMessage(strLogString);

	mov	ecx, DWORD PTR _this$[esp+1012]
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR _strLogString$227322[esp+992]
	push	edx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2755 : 					}

	lea	ecx, DWORD PTR _strLogString$227322[esp+992]
$LN787@ExecuteExp:
	mov	BYTE PTR __$EHRec$[esp+1000], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteExp:

; 2756 : 				}
; 2757 : 			}
; 2758 : 		}
; 2759 : 	}

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+1000], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ebx, DWORD PTR _this$[esp+992]
	mov	ebp, DWORD PTR _it$[esp+992]
	jmp	SHORT $LN89@ExecuteExp
$LN86@ExecuteExp:

; 2287 : 		{
; 2288 : 			continue;

	mov	BYTE PTR __$EHRec$[esp+1000], 0
	test	esi, esi
	je	SHORT $LN89@ExecuteExp
$LN785@ExecuteExp:
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN89@ExecuteExp:
	mov	eax, DWORD PTR [ebx+20]
	shl	eax, 4
	add	eax, DWORD PTR [ebx+16]
	add	ebp, 16					; 00000010H
	mov	DWORD PTR _it$[esp+992], ebp
	cmp	ebp, eax
	jne	$LL90@ExecuteExp
	pop	edi
	pop	esi
$LN88@ExecuteExp:

; 2760 : }

	mov	eax, DWORD PTR _aBestPlotList$[esp+984]
	lea	ecx, DWORD PTR _aBestPlotList$[esp+996]
	pop	ebp
	mov	DWORD PTR __$EHRec$[esp+988], -1
	pop	ebx
	cmp	eax, ecx
	je	SHORT $LN735@ExecuteExp
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN735@ExecuteExp:
	mov	ecx, DWORD PTR __$EHRec$[esp+976]
	mov	DWORD PTR fs:0, ecx
	add	esp, 976				; 000003d0H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	jmp	??1?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ ; CvWeightedVector<CvPlot *,100,1>::~CvWeightedVector<CvPlot *,100,1>
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pUnit$227154[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _args$227159[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$227167[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$227175[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$227188[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strLogString$227192[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$227196[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$9:
	lea	ecx, DWORD PTR _strLogString$227302[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR _strLogString$227294[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$10:
	lea	ecx, DWORD PTR _strLogString$227307[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$11:
	lea	ecx, DWORD PTR _strLogString$227317[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ$12:
	lea	ecx, DWORD PTR _strLogString$227322[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteExplorerMoves
PUBLIC	?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteMovesToSafestPlot
EXTRN	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z:PROC ; CanReachInXTurns
EXTRN	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::IsCanDefend
EXTRN	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlot::getNumDefenders
EXTRN	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z:PROC ; CvPlot::isFriendlyCity
EXTRN	?GetMoves@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$4
__ehfuncinfo$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_bIsInCover$227418 = -922				; size = 1
_bIsZeroDanger$227416 = -921				; size = 1
_this$ = -920						; size = 4
tv1400 = -916						; size = 4
$T268388 = -916						; size = 4
$T267786 = -916						; size = 4
tv1402 = -912						; size = 4
_iY$227409 = -908					; size = 4
_iX$227405 = -904					; size = 4
_iRange$227404 = -900					; size = 4
_iI$227396 = -896					; size = 4
_pUnit$227401 = -892					; size = 8
_strTemp$227443 = -884					; size = 28
_strLogString$227442 = -856				; size = 28
_aBestPlotList$227400 = -828				; size = 816
__$EHRec$ = -12						; size = 12
?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ExecuteMovesToSafestPlot, COMDAT
; _this$ = ecx

; 2921 : {

	push	-1
	push	__ehhandler$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 912				; 00000390H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2922 : 	int iDanger;
; 2923 : 
; 2924 : 	for(unsigned int iI = 0; iI < m_CurrentMoveUnits.size(); iI++)

	xor	edi, edi
	mov	DWORD PTR _this$[esp+940], ecx
	mov	DWORD PTR _iI$227396[esp+940], edi
	cmp	DWORD PTR [ecx+20], edi
	jbe	$LN27@ExecuteMov@2
	mov	DWORD PTR tv1402[esp+940], edi
	npad	10
$LL29@ExecuteMov@2:

; 2925 : 	{
; 2926 : 		WeightedPlotVector aBestPlotList;

	lea	eax, DWORD PTR _aBestPlotList$227400[esp+952]
	mov	DWORD PTR _aBestPlotList$227400[esp+944], edi
	mov	DWORD PTR _aBestPlotList$227400[esp+948], 100 ; 00000064H
	mov	DWORD PTR _aBestPlotList$227400[esp+940], eax
	mov	eax, DWORD PTR [ecx+16]
	add	eax, DWORD PTR tv1402[esp+940]

; 2927 : 		aBestPlotList.reserve(100);
; 2928 : 
; 2929 : 		UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[iI].GetID());

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+952], edi
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebx, eax
	mov	DWORD PTR _pUnit$227401[esp+940], ebx
	mov	BYTE PTR _pUnit$227401[esp+944], 0
	cmp	ebx, edi
	je	SHORT $LN92@ExecuteMov@2
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN92@ExecuteMov@2:
	mov	BYTE PTR __$EHRec$[esp+948], 1

; 2930 : 		if(pUnit)

	cmp	ebx, edi
	je	$LN1@ExecuteMov@2

; 2931 : 		{
; 2932 : 			CvPlot* pBestPlot = NULL;
; 2933 : 
; 2934 : #ifdef AUI_HOMELAND_FIX_EXECUTE_MOVES_TO_SAFEST_PLOT_USE_GAME_MOVEMENT_RANGE
; 2935 : 			int iRange = pUnit->baseMoves();
; 2936 : #else
; 2937 : 			int iRange = pUnit->getUnitInfo().GetMoves();

	mov	ecx, ebx
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetMoves@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetMoves
	mov	edx, eax

; 2938 : #endif
; 2939 : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 2940 : 			IncreaseMoveRangeForRoads(pUnit.pointer(), iRange);
; 2941 : #endif
; 2942 : 
; 2943 : 			// For each plot within movement range of the fleeing unit
; 2944 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2945 : 			int iMaxDX, iX;
; 2946 : 			CvPlot* pPlot;
; 2947 : 			for (int iY = -iRange; iY <= iRange; iY++)
; 2948 : 			{
; 2949 : 				iMaxDX = iRange - MAX(0, iY);
; 2950 : 				for (iX = -iRange - MIN(0, iY); iX <= iMaxDX; iX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 2951 : 				{
; 2952 : 					// No need for range check because loops are set up properly
; 2953 : 					pPlot = plotXY(pUnit->getX(), pUnit->getY(), iX, iY);
; 2954 : #else
; 2955 : 			for(int iX = -iRange; iX <= iRange; iX++)

	mov	ecx, edx
	neg	ecx
	mov	esi, ecx
	cmp	esi, edx
	mov	DWORD PTR _iRange$227404[esp+940], edx
	mov	DWORD PTR tv1400[esp+940], ecx
	mov	DWORD PTR _iX$227405[esp+940], ecx
	jg	$LN23@ExecuteMov@2
	npad	4
$LL25@ExecuteMov@2:

; 2956 : 			{
; 2957 : 				for(int iY = -iRange; iY <= iRange; iY++)

	cmp	ecx, edx
	mov	DWORD PTR _iY$227409[esp+940], ecx
	jg	$LN24@ExecuteMov@2
	npad	4
$LL22@ExecuteMov@2:

; 2958 : 				{
; 2959 : 					CvPlot* pPlot = GC.getMap().plot(pUnit->getX() + iX, pUnit->getY() + iY);

	mov	eax, DWORD PTR [ebx+76]
	mov	ebp, DWORD PTR [ebx+88]
	add	eax, esi
	add	ebp, ecx
	cmp	eax, -2147483647			; 80000001H
	je	$LN21@ExecuteMov@2
	cmp	ebp, -2147483647			; 80000001H
	je	$LN21@ExecuteMov@2
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [edi+4056]
	mov	ecx, DWORD PTR [edi+4020]
	test	dl, dl
	je	SHORT $LN122@ExecuteMov@2
	test	eax, eax
	jge	SHORT $LN124@ExecuteMov@2
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN126@ExecuteMov@2
$LN124@ExecuteMov@2:
	cmp	eax, ecx
	jl	SHORT $LN122@ExecuteMov@2
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN126@ExecuteMov@2
$LN122@ExecuteMov@2:
	mov	esi, eax
$LN126@ExecuteMov@2:
	mov	al, BYTE PTR [edi+4057]
	mov	edi, DWORD PTR [edi+4024]
	test	al, al
	je	SHORT $LN132@ExecuteMov@2
	test	ebp, ebp
	jge	SHORT $LN134@ExecuteMov@2
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN136@ExecuteMov@2
$LN134@ExecuteMov@2:
	cmp	ebp, edi
	jl	SHORT $LN132@ExecuteMov@2
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN136@ExecuteMov@2
$LN132@ExecuteMov@2:
	mov	edx, ebp
$LN136@ExecuteMov@2:
	test	esi, esi
	jl	$LN319@ExecuteMov@2
	cmp	esi, ecx
	jge	$LN319@ExecuteMov@2
	test	edx, edx
	jl	$LN319@ExecuteMov@2
	cmp	edx, edi
	jge	$LN319@ExecuteMov@2
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	edi, ecx

; 2960 : #endif
; 2961 : 					if(pPlot == NULL)

	je	$LN319@ExecuteMov@2

; 2962 : 					{
; 2963 : 						continue;
; 2964 : 					}
; 2965 : 
; 2966 : #ifndef AUI_HEXSPACE_DX_LOOPS
; 2967 : 					if (plotDistance(pPlot->getX(), pPlot->getY(), pUnit->getX(), pUnit->getY()) > iRange)

	mov	eax, DWORD PTR [ebx+88]
	movsx	ecx, WORD PTR [edi]
	push	eax
	mov	eax, DWORD PTR [ebx+76]
	push	eax
	movsx	eax, WORD PTR [edi+2]
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iRange$227404[esp+940]
	jg	$LN319@ExecuteMov@2

; 2968 : 					{
; 2969 : 						continue;
; 2970 : 					}
; 2971 : #endif
; 2972 : 
; 2973 : 					//   prefer being in a city with the lowest danger value
; 2974 : 					//   prefer being in a plot with no danger value
; 2975 : 					//   prefer being under a unit with the lowest danger value
; 2976 : 					//   prefer being in your own territory with the lowest danger value
; 2977 : 					//   prefer the lowest danger value
; 2978 : 
; 2979 : 					iDanger = m_pPlayer->GetPlotDanger(*pPlot);

	mov	edx, DWORD PTR _this$[esp+940]
	mov	ecx, DWORD PTR [edx]
	push	edi
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	mov	ebp, eax

; 2980 : 					bool bIsZeroDanger = (iDanger <= 0);
; 2981 : 					bool bIsInCity = pPlot->isFriendlyCity(*pUnit, false);

	push	0
	test	ebp, ebp
	push	ebx
	mov	ecx, edi
	setle	BYTE PTR _bIsZeroDanger$227416[esp+948]
	call	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z ; CvPlot::isFriendlyCity

; 2982 : 					bool bIsInCover = (pPlot->getNumDefenders(m_pPlayer->GetID()) > 0) && !pUnit->IsCanDefend();

	mov	esi, DWORD PTR _this$[esp+940]
	mov	bl, al
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	push	eax
	mov	ecx, edi
	call	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumDefenders
	test	eax, eax
	jle	SHORT $LN32@ExecuteMov@2
	mov	ecx, DWORD PTR _pUnit$227401[esp+940]
	push	0
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	mov	BYTE PTR _bIsInCover$227418[esp+940], 1
	test	al, al
	je	SHORT $LN33@ExecuteMov@2
$LN32@ExecuteMov@2:
	mov	BYTE PTR _bIsInCover$227418[esp+940], 0
$LN33@ExecuteMov@2:

; 2983 : 					bool bIsInTerritory = (pPlot->getTeam() == m_pPlayer->getTeam());

	movsx	eax, BYTE PTR [edi+4]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, -1
	je	SHORT $LN175@ExecuteMov@2
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN182@ExecuteMov@2
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, eax
	jmp	SHORT $LN174@ExecuteMov@2
$LN182@ExecuteMov@2:
	or	eax, -1
	mov	ecx, eax
	jmp	SHORT $LN174@ExecuteMov@2
$LN175@ExecuteMov@2:
	or	ecx, -1
$LN174@ExecuteMov@2:
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN191@ExecuteMov@2
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN192@ExecuteMov@2
$LN191@ExecuteMov@2:
	or	eax, -1
$LN192@ExecuteMov@2:
	cmp	ecx, eax
	sete	al

; 2984 : #ifdef AUI_HOMELAND_FIX_EXECUTE_MOVES_TO_SAFEST_PLOT_NO_EMBARK_SUICIDE
; 2985 : 					bool bNeedEmbark = ((pUnit->getDomainType() == DOMAIN_LAND) && (!pUnit->plot()->isWater()) && (pPlot->isWater()));
; 2986 : #endif
; 2987 : 
; 2988 : 					#define MAX_DANGER_VALUE	100000
; 2989 : 					#define PREFERENCE_LEVEL(x, y) (x * MAX_DANGER_VALUE) + ((MAX_DANGER_VALUE - 1) - y)
; 2990 : 
; 2991 : 					CvAssert(iDanger < MAX_DANGER_VALUE);
; 2992 : 
; 2993 : 					int iScore;
; 2994 : 					if(bIsInCity)

	test	bl, bl
	je	SHORT $LN17@ExecuteMov@2

; 2995 : 					{
; 2996 : 						iScore = PREFERENCE_LEVEL(5, iDanger);

	mov	esi, 599999				; 000927bfH
	jmp	SHORT $LN325@ExecuteMov@2
$LN17@ExecuteMov@2:

; 2997 : 					}
; 2998 : 					else if(bIsZeroDanger)

	cmp	BYTE PTR _bIsZeroDanger$227416[esp+940], 0
	je	SHORT $LN15@ExecuteMov@2

; 2999 : 					{
; 3000 : 						if (bIsInTerritory)

	test	al, al
	je	SHORT $LN14@ExecuteMov@2

; 3001 : 							iScore = PREFERENCE_LEVEL(4, iDanger);

	mov	esi, 499999				; 0007a11fH

; 3002 : 						else

	jmp	SHORT $LN325@ExecuteMov@2
$LN14@ExecuteMov@2:

; 3003 : 							iScore = PREFERENCE_LEVEL(3, iDanger);

	mov	esi, 399999				; 00061a7fH
	jmp	SHORT $LN325@ExecuteMov@2
$LN15@ExecuteMov@2:

; 3004 : 					}
; 3005 : 					else if(bIsInCover)

	cmp	BYTE PTR _bIsInCover$227418[esp+940], 0
	je	SHORT $LN11@ExecuteMov@2

; 3006 : 					{
; 3007 : 						iScore = PREFERENCE_LEVEL(2, iDanger);

	mov	esi, 299999				; 000493dfH
	jmp	SHORT $LN325@ExecuteMov@2
$LN11@ExecuteMov@2:

; 3008 : 					}
; 3009 : 					else if(bIsInTerritory)
; 3010 : 					{
; 3011 : 						iScore = PREFERENCE_LEVEL(1, iDanger);

	mov	esi, 199999				; 00030d3fH
	test	al, al
	jne	SHORT $LN325@ExecuteMov@2

; 3012 : 					}
; 3013 : 					// if we have no good home, head to the lowest danger value
; 3014 : 					else 
; 3015 : 					{
; 3016 : 						iScore = PREFERENCE_LEVEL(0, iDanger);

	mov	esi, 99999				; 0001869fH
$LN325@ExecuteMov@2:

; 3017 : 					}
; 3018 : 
; 3019 : #ifdef AUI_HOMELAND_FIX_EXECUTE_MOVES_TO_SAFEST_PLOT_NO_EMBARK_SUICIDE
; 3020 : 					// makes sure the AI doesn't suicide units via embarking onto a tile that can be attacked
; 3021 : 					if (bNeedEmbark && !bIsInCover)
; 3022 : 					{
; 3023 : 						iScore = PREFERENCE_LEVEL(0, iDanger);
; 3024 : 					}
; 3025 : #endif
; 3026 : 
; 3027 : 					aBestPlotList.push_back(pPlot, iScore);

	mov	eax, DWORD PTR _aBestPlotList$227400[esp+948]
	sub	esi, ebp
	mov	BYTE PTR _aBestPlotList$227400[esp+1752], 0
	cmp	DWORD PTR _aBestPlotList$227400[esp+944], eax
	jne	SHORT $LN200@ExecuteMov@2
	push	eax
	lea	ecx, DWORD PTR _aBestPlotList$227400[esp+944]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSize
$LN200@ExecuteMov@2:
	mov	eax, DWORD PTR _aBestPlotList$227400[esp+940]
	mov	ecx, DWORD PTR _aBestPlotList$227400[esp+944]
	lea	eax, DWORD PTR [eax+ecx*8]
	test	eax, eax
	je	SHORT $LN203@ExecuteMov@2
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
$LN203@ExecuteMov@2:
	inc	DWORD PTR _aBestPlotList$227400[esp+944]
	mov	ebx, DWORD PTR _pUnit$227401[esp+940]
$LN319@ExecuteMov@2:
	mov	ecx, DWORD PTR _iY$227409[esp+940]
	mov	edx, DWORD PTR _iRange$227404[esp+940]
$LN21@ExecuteMov@2:
	mov	esi, DWORD PTR _iX$227405[esp+940]
	inc	ecx
	cmp	ecx, edx
	mov	DWORD PTR _iY$227409[esp+940], ecx
	jle	$LL22@ExecuteMov@2

; 2956 : 			{
; 2957 : 				for(int iY = -iRange; iY <= iRange; iY++)

	mov	ecx, DWORD PTR tv1400[esp+940]
$LN24@ExecuteMov@2:

; 2938 : #endif
; 2939 : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 2940 : 			IncreaseMoveRangeForRoads(pUnit.pointer(), iRange);
; 2941 : #endif
; 2942 : 
; 2943 : 			// For each plot within movement range of the fleeing unit
; 2944 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 2945 : 			int iMaxDX, iX;
; 2946 : 			CvPlot* pPlot;
; 2947 : 			for (int iY = -iRange; iY <= iRange; iY++)
; 2948 : 			{
; 2949 : 				iMaxDX = iRange - MAX(0, iY);
; 2950 : 				for (iX = -iRange - MIN(0, iY); iX <= iMaxDX; iX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 2951 : 				{
; 2952 : 					// No need for range check because loops are set up properly
; 2953 : 					pPlot = plotXY(pUnit->getX(), pUnit->getY(), iX, iY);
; 2954 : #else
; 2955 : 			for(int iX = -iRange; iX <= iRange; iX++)

	inc	esi
	cmp	esi, edx
	mov	DWORD PTR _iX$227405[esp+940], esi
	jle	$LL25@ExecuteMov@2
	xor	edi, edi
$LN23@ExecuteMov@2:

; 3028 : 				}
; 3029 : 			}
; 3030 : 
; 3031 : 			aBestPlotList.SortItems();

	mov	ecx, DWORD PTR _aBestPlotList$227400[esp+940]
	mov	edx, DWORD PTR _aBestPlotList$227400[esp+944]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>

; 3032 : 
; 3033 : 			// Now loop through the sorted score list and go to the best one we can reach in one turn.
; 3034 : 			// #define EXECUTEMOVESTOSAFESTPLOT_FAILURE_LIMIT
; 3035 : 			#ifdef EXECUTEMOVESTOSAFESTPLOT_FAILURE_LIMIT
; 3036 : 			int iFailureLimit = 10;
; 3037 : 			#endif
; 3038 : 			uint uiListSize;
; 3039 : 			if ((uiListSize = aBestPlotList.size()) > 0)

	mov	ecx, DWORD PTR _aBestPlotList$227400[esp+956]
	add	esp, 12					; 0000000cH
	mov	ebp, ecx
	cmp	ecx, edi
	jbe	$LN1@ExecuteMov@2

; 3040 : 			{
; 3041 : 				aBestPlotList.SortItems();	// highest score will be first.

	mov	eax, DWORD PTR _aBestPlotList$227400[esp+940]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3042 : 				for (uint i = 0; i < uiListSize; ++i )	

	test	ebp, ebp
	jbe	$LN1@ExecuteMov@2
$LL6@ExecuteMov@2:

; 3043 : 				{
; 3044 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 3045 : 					pPlot = aBestPlotList.GetElement(i);
; 3046 : #else
; 3047 : 					CvPlot* pPlot = aBestPlotList.GetElement(i);

	mov	eax, DWORD PTR _aBestPlotList$227400[esp+940]
	mov	esi, DWORD PTR [eax+edi*8]

; 3048 : #endif
; 3049 : 
; 3050 : 					if(CanReachInXTurns(pUnit, pPlot, 1))

	push	0
	push	0
	push	1
	push	esi
	sub	esp, 8
	mov	eax, esp
	mov	ecx, ebx
	mov	DWORD PTR $T267786[esp+964], esp
	mov	DWORD PTR [eax], ebx
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ; CanReachInXTurns
	add	esp, 24					; 00000018H
	test	al, al
	jne	SHORT $LN308@ExecuteMov@2
	inc	edi
	cmp	edi, ebp
	jb	SHORT $LL6@ExecuteMov@2
	jmp	$LN1@ExecuteMov@2
$LN308@ExecuteMov@2:

; 3051 : 					{
; 3052 : 						pBestPlot = pPlot;
; 3053 : 						break;
; 3054 : 					}
; 3055 : 					#ifdef EXECUTEMOVESTOSAFESTPLOT_FAILURE_LIMIT
; 3056 : 					else
; 3057 : 					{
; 3058 : 						if (iFailureLimit-- == 0)
; 3059 : 							break;
; 3060 : 					}
; 3061 : 					#endif
; 3062 : 				}
; 3063 : 			}
; 3064 : 
; 3065 : 			if(pBestPlot != NULL)

	test	esi, esi
	je	$LN1@ExecuteMov@2

; 3066 : 			{
; 3067 : 				// Move to the lowest danger value found
; 3068 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestPlot->getX(), pBestPlot->getY(), MOVE_UNITS_IGNORE_DANGER);

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	8
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, ebx
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3069 : 				pUnit->finishMoves();

	mov	ecx, ebx
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3070 : 				UnitProcessed(pUnit->GetID());

	mov	edi, DWORD PTR [ebx+100]
	mov	ebp, DWORD PTR _this$[esp+940]
	lea	ecx, DWORD PTR $T268388[esp+940]
	push	ecx
	lea	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR $T268388[esp+944], edi
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [ebp]
	push	edi
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN254@ExecuteMov@2
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN254@ExecuteMov@2:

; 3071 : 
; 3072 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteMov@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteMov@2

; 3073 : 				{
; 3074 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227442[esp+940]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3075 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227443[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3076 : #ifdef AUI_WARNING_FIXES
; 3077 : 					CvUnitEntry* pTempUnitInfo = GC.getUnitInfo(pUnit->getUnitType());
; 3078 : 					if (pTempUnitInfo)
; 3079 : 						strTemp = pTempUnitInfo->GetDescription();
; 3080 : #else
; 3081 : 					strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+948], 3
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$227443[esp+940]
	test	eax, eax
	je	SHORT $LN267@ExecuteMov@2
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN266@ExecuteMov@2
$LN267@ExecuteMov@2:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN266@ExecuteMov@2:

; 3082 : #endif
; 3083 : 					strLogString.Format("Moving %s to safety, X: %d, Y: %d", strTemp.GetCString(), pBestPlot->getX(), pBestPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strTemp$227443[esp+948]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$227442[esp+952]
	push	OFFSET $SG227444
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 3084 : 					LogHomelandMessage(strLogString);

	mov	ecx, DWORD PTR _this$[esp+960]
	add	esp, 20					; 00000014H
	lea	eax, DWORD PTR _strLogString$227442[esp+940]
	push	eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3085 : 				}

	lea	ecx, DWORD PTR _strTemp$227443[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$227442[esp+940]
	mov	BYTE PTR __$EHRec$[esp+948], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteMov@2:

; 3086 : 			}
; 3087 : 		}
; 3088 : 	}

	xor	edi, edi
	mov	BYTE PTR __$EHRec$[esp+948], 0
	cmp	ebx, edi
	je	SHORT $LN285@ExecuteMov@2
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN285@ExecuteMov@2:
	mov	eax, DWORD PTR _aBestPlotList$227400[esp+940]
	lea	ecx, DWORD PTR _aBestPlotList$227400[esp+952]
	mov	DWORD PTR __$EHRec$[esp+948], -1
	cmp	eax, ecx
	je	SHORT $LN28@ExecuteMov@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN28@ExecuteMov@2:
	mov	eax, DWORD PTR _iI$227396[esp+940]
	mov	ecx, DWORD PTR _this$[esp+940]
	add	DWORD PTR tv1402[esp+940], 16		; 00000010H
	inc	eax
	mov	DWORD PTR _iI$227396[esp+940], eax
	cmp	eax, DWORD PTR [ecx+20]
	jb	$LL29@ExecuteMov@2
$LN27@ExecuteMov@2:

; 3089 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+940]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 924				; 0000039cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _aBestPlotList$227400[ebp]
	jmp	??1?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ ; CvWeightedVector<CvPlot *,100,1>::~CvWeightedVector<CvPlot *,100,1>
__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pUnit$227401[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$227442[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strTemp$227443[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ExecuteMovesToSafestPlot
PUBLIC	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
EXTRN	?canHold@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canHold
EXTRN	?GetMaxDefenseStrength@CvUnit@@QBEHPBVCvPlot@@PBV1@_N@Z:PROC ; CvUnit::GetMaxDefenseStrength
EXTRN	?isWaiting@CvUnit@@QBE_NXZ:PROC			; CvUnit::isWaiting
EXTRN	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z:PROC ; CvPlot::nextUnitNode
EXTRN	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z:PROC	; getUnit
EXTRN	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ:PROC	; CvPlot::headUnitNode
EXTRN	?getStrengthValue@CvCity@@QBEH_N@Z:PROC		; CvCity::getStrengthValue
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
EXTRN	?SearchRange@CvUnit@@QBEHH@Z:PROC		; CvUnit::SearchRange
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$8
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z
_TEXT	SEGMENT
_this$ = -920						; size = 4
tv1467 = -916						; size = 4
_iSearchRange$ = -912					; size = 4
tv1450 = -908						; size = 4
tv1397 = -904						; size = 4
_iPathTurns$228441 = -904				; size = 4
_iDX$228405 = -900					; size = 4
_iDY$228409 = -896					; size = 4
_strTemp$228466 = -892					; size = 28
_strTemp$228460 = -892					; size = 28
_strTemp$228455 = -892					; size = 28
_strTemp$228449 = -892					; size = 28
_strLogString$228465 = -864				; size = 28
_strLogString$228459 = -864				; size = 28
_strLogString$228454 = -864				; size = 28
_strLogString$228448 = -864				; size = 28
tv1070 = -836						; size = 4
tv1060 = -832						; size = 4
_aBestPlotList$ = -828					; size = 816
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
_bIgnoreUnits$ = 12					; size = 1
?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z PROC ; CvHomelandAI::MoveCivilianToSafety, COMDAT
; _this$ = ecx

; 4808 : {

	push	-1
	push	__ehhandler$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 908				; 0000038cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+936], ecx

; 4809 : 	int iSearchRange = pUnit->SearchRange(1);

	mov	ecx, DWORD PTR _pUnit$[esp+932]
	push	1
	call	?SearchRange@CvUnit@@QBEHH@Z		; CvUnit::SearchRange
	mov	esi, eax

; 4810 : 
; 4811 : 	// Collecting all the possibilities first.
; 4812 : 	WeightedPlotVector aBestPlotList;

	xor	eax, eax
	lea	ecx, DWORD PTR _aBestPlotList$[esp+948]
	mov	DWORD PTR _iSearchRange$[esp+936], esi
	mov	DWORD PTR _aBestPlotList$[esp+940], eax
	mov	DWORD PTR _aBestPlotList$[esp+944], 100	; 00000064H
	mov	DWORD PTR _aBestPlotList$[esp+936], ecx

; 4813 : 	aBestPlotList.reserve( ((iSearchRange * 2) + 1) * 2 );

	lea	edx, DWORD PTR [esi*4+2]
	push	edx
	lea	ecx, DWORD PTR _aBestPlotList$[esp+940]
	mov	DWORD PTR __$EHRec$[esp+948], eax
	call	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSizeToFit

; 4814 : 
; 4815 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 4816 : 	int iMaxDX, iDX;
; 4817 : 	CvPlot* pLoopPlot;
; 4818 : 	for (int iDY = -iSearchRange; iDY <= iSearchRange; iDY++)
; 4819 : 	{
; 4820 : 		iMaxDX = iSearchRange - MAX(0, iDY);
; 4821 : 		for (iDX = -iSearchRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 4822 : 		{
; 4823 : 			// No need for range check because loops are set up properly
; 4824 : 			pLoopPlot = plotXY(pUnit->getX(), pUnit->getY(), iDX, iDY);
; 4825 : #else
; 4826 : 	for(int iDX = -(iSearchRange); iDX <= iSearchRange; iDX++)

	mov	ebp, esi
	neg	ebp
	cmp	ebp, esi
	mov	DWORD PTR tv1060[esp+936], ebp
	mov	DWORD PTR _iDX$228405[esp+936], ebp
	jg	$LN326@MoveCivili
	mov	eax, ebp
	neg	eax
	mov	DWORD PTR tv1467[esp+936], eax
$LL36@MoveCivili:

; 4827 : 	{
; 4828 : 		for(int iDY = -(iSearchRange); iDY <= iSearchRange; iDY++)

	mov	ebx, DWORD PTR tv1060[esp+936]
	cmp	ebx, DWORD PTR _iSearchRange$[esp+936]
	mov	DWORD PTR _iDY$228409[esp+936], ebx
	jg	$LN35@MoveCivili

; 4829 : 		{
; 4830 : 			CvPlot* pLoopPlot = plotXYWithRangeCheck(pUnit->getX(), pUnit->getY(), iDX, iDY, iSearchRange);

	xor	eax, eax
	test	ebp, ebp
	setge	al
	mov	DWORD PTR tv1070[esp+936], eax
	mov	eax, ebx
	neg	eax
	mov	DWORD PTR tv1450[esp+936], eax
	npad	10
$LL33@MoveCivili:
	mov	eax, DWORD PTR _pUnit$[esp+932]
	mov	edx, DWORD PTR [eax+88]
	mov	esi, DWORD PTR [eax+76]
	xor	ecx, ecx
	test	ebx, ebx
	setge	cl
	cmp	DWORD PTR tv1070[esp+936], ecx
	mov	ecx, ebp
	jne	SHORT $LN73@MoveCivili
	test	ebp, ebp
	jge	SHORT $LN77@MoveCivili
	mov	ecx, DWORD PTR tv1467[esp+936]
$LN77@MoveCivili:
	mov	eax, ebx
	test	ebx, ebx
	jge	SHORT $LN79@MoveCivili
	mov	eax, DWORD PTR tv1450[esp+936]
$LN79@MoveCivili:
	add	eax, ecx
	jmp	SHORT $LN84@MoveCivili
$LN73@MoveCivili:
	test	ebp, ebp
	jge	SHORT $LN81@MoveCivili
	mov	ecx, DWORD PTR tv1467[esp+936]
$LN81@MoveCivili:
	mov	eax, ebx
	test	ebx, ebx
	jge	SHORT $LN83@MoveCivili
	mov	eax, DWORD PTR tv1450[esp+936]
$LN83@MoveCivili:
	cmp	ecx, eax
	jl	SHORT $LN84@MoveCivili
	mov	eax, ecx
$LN84@MoveCivili:
	cmp	eax, DWORD PTR _iSearchRange$[esp+936]
	jg	$LN32@MoveCivili
	push	ebx
	push	ebp
	push	edx
	push	esi
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	edi, eax
	add	esp, 16					; 00000010H

; 4831 : #endif
; 4832 : 			if(!pLoopPlot)

	test	edi, edi
	je	$LN32@MoveCivili

; 4833 : 			{
; 4834 : 				continue;
; 4835 : 			}
; 4836 : 
; 4837 : 			if(!pUnit->PlotValid(pLoopPlot))

	mov	esi, DWORD PTR _pUnit$[esp+932]
	push	edi
	mov	ecx, esi
	call	?PlotValid@CvUnit@@QBE_NPAVCvPlot@@@Z	; CvUnit::PlotValid
	test	al, al
	je	$LN32@MoveCivili

; 4838 : 			{
; 4839 : 				continue;
; 4840 : 			}
; 4841 : 
; 4842 : 			if(pLoopPlot->isVisibleEnemyUnit(pUnit))

	push	esi
	mov	ecx, edi
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	test	al, al
	jne	$LN32@MoveCivili

; 4843 : 			{
; 4844 : 				continue;
; 4845 : 			}
; 4846 : 
; 4847 : 			int iValue = 0;
; 4848 : 			if(pLoopPlot->getOwner() != NO_PLAYER && GET_PLAYER(pLoopPlot->getOwner()).getTeam() == m_pPlayer->getTeam())

	mov	al, BYTE PTR [edi+4]
	mov	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	ebx, ebx
	cmp	al, -1
	je	SHORT $LN27@MoveCivili
	movsx	edx, al
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR [edx+esi+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN96@MoveCivili
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN97@MoveCivili
$LN96@MoveCivili:
	or	eax, -1
$LN97@MoveCivili:
	mov	ecx, DWORD PTR _this$[esp+936]
	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN105@MoveCivili
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN106@MoveCivili
$LN105@MoveCivili:
	or	ecx, -1
$LN106@MoveCivili:
	cmp	eax, ecx
	jne	SHORT $LN27@MoveCivili

; 4849 : 			{
; 4850 : 				// if this is within our territory, provide a minor benefit
; 4851 : 				iValue += 1;

	mov	ebx, 1
$LN27@MoveCivili:

; 4852 : 			}
; 4853 : 
; 4854 : 			CvCity* pCity = pLoopPlot->getPlotCity();

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	SHORT $LN26@MoveCivili
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN26@MoveCivili
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, esi
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax

; 4855 : 			if(pCity && pCity->getTeam() == pUnit->getTeam())

	test	esi, esi
	je	SHORT $LN26@MoveCivili
	mov	ecx, esi
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	ecx, DWORD PTR _pUnit$[esp+932]
	mov	ebp, eax
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	ebp, eax
	jne	SHORT $LN26@MoveCivili

; 4856 : 			{
; 4857 : 				iValue += pCity->getStrengthValue() * (GC.getMAX_CITY_DEFENSE_DAMAGE() - pCity->getDamage());

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6740
	mov	ecx, esi
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	push	0
	mov	ecx, esi
	sub	ebp, eax
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue
	imul	eax, ebp
	add	ebx, eax
	jmp	$LN327@MoveCivili
$LN26@MoveCivili:

; 4858 : 			}
; 4859 : 			else if(!bIgnoreUnits)

	cmp	BYTE PTR _bIgnoreUnits$[esp+932], 0
	jne	$LN327@MoveCivili

; 4860 : 			{
; 4861 : 				IDInfo* pUnitNode = pLoopPlot->headUnitNode();

	mov	ecx, edi
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	ebp, eax

; 4862 : 				while(pUnitNode != NULL)

	test	ebp, ebp
	je	SHORT $LN327@MoveCivili
$LL23@MoveCivili:

; 4863 : 				{
; 4864 : 					CvUnit* pLoopUnit = ::getUnit(*pUnitNode);

	push	ebp
	call	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z	; getUnit
	add	esp, 4

; 4865 : 					pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);

	push	ebp
	mov	ecx, edi
	mov	esi, eax
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	ebp, eax

; 4866 : 
; 4867 : 					if(pLoopUnit && pLoopUnit->getOwner() == pUnit->getOwner())

	test	esi, esi
	je	SHORT $LN18@MoveCivili
	mov	eax, DWORD PTR [esi+40]
	mov	edx, DWORD PTR _pUnit$[esp+932]
	cmp	eax, DWORD PTR [edx+40]
	jne	SHORT $LN18@MoveCivili

; 4868 : 					{
; 4869 : 						if(pLoopUnit->IsCanDefend())

	push	0
	mov	ecx, esi
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	je	SHORT $LN18@MoveCivili

; 4870 : 						{
; 4871 : 							if(pLoopUnit != pUnit)

	cmp	esi, DWORD PTR _pUnit$[esp+932]
	je	SHORT $LN18@MoveCivili

; 4872 : 							{
; 4873 : 								if(pLoopUnit->isWaiting() || !(pLoopUnit->canMove()))

	mov	ecx, esi
	call	?isWaiting@CvUnit@@QBE_NXZ		; CvUnit::isWaiting
	test	al, al
	jne	SHORT $LN17@MoveCivili
	mov	ecx, esi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	jne	SHORT $LN18@MoveCivili
$LN17@MoveCivili:

; 4874 : 								{
; 4875 : 									iValue += pLoopUnit->GetMaxDefenseStrength(pLoopPlot, NULL) * pLoopUnit->GetCurrHitPoints();

	push	0
	push	0
	push	edi
	mov	ecx, esi
	call	?GetMaxDefenseStrength@CvUnit@@QBEHPBVCvPlot@@PBV1@_N@Z ; CvUnit::GetMaxDefenseStrength
	mov	ecx, esi
	mov	DWORD PTR tv1397[esp+936], eax
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	mov	ecx, DWORD PTR tv1397[esp+936]
	imul	ecx, eax
	add	ebx, ecx
$LN18@MoveCivili:

; 4862 : 				while(pUnitNode != NULL)

	test	ebp, ebp
	jne	SHORT $LL23@MoveCivili
$LN327@MoveCivili:

; 4876 : 								}
; 4877 : 							}
; 4878 : 						}
; 4879 : 					}
; 4880 : 				}
; 4881 : 			}
; 4882 : 
; 4883 : 			iValue -= m_pPlayer->GetPlotDanger(*pLoopPlot);

	mov	eax, DWORD PTR _this$[esp+936]
	mov	ecx, DWORD PTR [eax]
	push	edi
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	sub	ebx, eax

; 4884 : 
; 4885 : 			aBestPlotList.push_back(pLoopPlot, iValue);

	mov	eax, DWORD PTR _aBestPlotList$[esp+944]
	mov	BYTE PTR _aBestPlotList$[esp+1748], 0
	cmp	DWORD PTR _aBestPlotList$[esp+940], eax
	jne	SHORT $LN129@MoveCivili
	push	eax
	lea	ecx, DWORD PTR _aBestPlotList$[esp+940]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,100,1>::WeightedElement,100,1,0,0>::GrowSize
$LN129@MoveCivili:
	mov	ecx, DWORD PTR _aBestPlotList$[esp+936]
	mov	edx, DWORD PTR _aBestPlotList$[esp+940]
	lea	eax, DWORD PTR [ecx+edx*8]
	test	eax, eax
	je	SHORT $LN132@MoveCivili
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ebx
$LN132@MoveCivili:
	inc	DWORD PTR _aBestPlotList$[esp+940]
	mov	ebp, DWORD PTR _iDX$228405[esp+936]
	mov	ebx, DWORD PTR _iDY$228409[esp+936]
$LN32@MoveCivili:
	dec	DWORD PTR tv1450[esp+936]
	inc	ebx
	cmp	ebx, DWORD PTR _iSearchRange$[esp+936]
	mov	DWORD PTR _iDY$228409[esp+936], ebx
	jle	$LL33@MoveCivili
$LN35@MoveCivili:

; 4814 : 
; 4815 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 4816 : 	int iMaxDX, iDX;
; 4817 : 	CvPlot* pLoopPlot;
; 4818 : 	for (int iDY = -iSearchRange; iDY <= iSearchRange; iDY++)
; 4819 : 	{
; 4820 : 		iMaxDX = iSearchRange - MAX(0, iDY);
; 4821 : 		for (iDX = -iSearchRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 4822 : 		{
; 4823 : 			// No need for range check because loops are set up properly
; 4824 : 			pLoopPlot = plotXY(pUnit->getX(), pUnit->getY(), iDX, iDY);
; 4825 : #else
; 4826 : 	for(int iDX = -(iSearchRange); iDX <= iSearchRange; iDX++)

	dec	DWORD PTR tv1467[esp+936]
	inc	ebp
	cmp	ebp, DWORD PTR _iSearchRange$[esp+936]
	mov	DWORD PTR _iDX$228405[esp+936], ebp
	jle	$LL36@MoveCivili
$LN326@MoveCivili:

; 4886 : 		}
; 4887 : 	}
; 4888 : 
; 4889 : 	// Now loop through the sorted score list and go to the best one we can reach in one turn.
; 4890 : 	CvPlot* pBestPlot = NULL;
; 4891 : 	uint uiListSize;
; 4892 : 	if ((uiListSize = aBestPlotList.size()) > 0)

	mov	ebp, DWORD PTR _aBestPlotList$[esp+940]
	test	ebp, ebp
	jbe	SHORT $LN10@MoveCivili

; 4893 : 	{
; 4894 : 		aBestPlotList.SortItems();	// highest score will be first.

	mov	ecx, DWORD PTR _aBestPlotList$[esp+936]
	mov	eax, ebp
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,100,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 4895 : 		for (uint i = 0; i < uiListSize; ++i )	

	xor	edi, edi
	test	ebp, ebp
	jbe	SHORT $LN10@MoveCivili
	mov	ebx, DWORD PTR _pUnit$[esp+932]
	npad	8
$LL15@MoveCivili:

; 4896 : 		{
; 4897 : 			CvPlot* pPlot = aBestPlotList.GetElement(i);

	mov	eax, DWORD PTR _aBestPlotList$[esp+936]
	mov	esi, DWORD PTR [eax+edi*8]

; 4898 : 
; 4899 : 			int iPathTurns;
; 4900 : 			if(!pUnit->GeneratePath(pPlot, MOVE_UNITS_IGNORE_DANGER, true, &iPathTurns))

	lea	ecx, DWORD PTR _iPathTurns$228441[esp+936]
	push	ecx
	push	1
	push	8
	push	esi
	mov	ecx, ebx
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	test	al, al
	je	SHORT $LN14@MoveCivili

; 4901 : 			{
; 4902 : 				continue;
; 4903 : 			}
; 4904 : 
; 4905 : 			// if we can't get there this turn, forget it
; 4906 : 			if(iPathTurns > 1)

	cmp	DWORD PTR _iPathTurns$228441[esp+936], 1
	jle	SHORT $LN11@MoveCivili
$LN14@MoveCivili:

; 4895 : 		for (uint i = 0; i < uiListSize; ++i )	

	inc	edi
	cmp	edi, ebp
	jb	SHORT $LL15@MoveCivili
$LN10@MoveCivili:

; 4975 : 	{
; 4976 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN328@MoveCivili
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN328@MoveCivili

; 4977 : 		{
; 4978 : 			CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228465[esp+936]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	bl, 7

; 4979 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228466[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4980 : 			strTemp = pUnit->getUnitInfo().GetDescription();

	mov	esi, DWORD PTR _pUnit$[esp+932]
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+944], 8
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$228466[esp+936]
	test	eax, eax
	je	$LN286@MoveCivili
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	$LN285@MoveCivili
$LN11@MoveCivili:

; 4907 : 			{
; 4908 : 				continue;
; 4909 : 			}
; 4910 : 
; 4911 : 			pBestPlot = pPlot;
; 4912 : 			break;
; 4913 : 		}
; 4914 : 	}
; 4915 : 
; 4916 : 	if(pBestPlot != NULL)

	test	esi, esi
	je	SHORT $LN10@MoveCivili

; 4917 : 	{
; 4918 : 		if(pUnit->atPlot(*pBestPlot))

	push	esi
	mov	ecx, ebx
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	test	al, al
	je	$LN9@MoveCivili

; 4919 : 		{
; 4920 : 			if (pUnit->canHold(pBestPlot))

	push	esi
	mov	ecx, ebx
	call	?canHold@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canHold

; 4921 : 			{
; 4922 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	test	al, al
	je	$LN8@MoveCivili
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN330@MoveCivili
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN330@MoveCivili

; 4923 : 				{
; 4924 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228448[esp+936]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4925 : #ifdef AUI_WARNING_FIXES
; 4926 : 					CvString strTemp = pUnit->getUnitInfo().GetDescription();
; 4927 : #else
; 4928 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228449[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4929 : 					strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+944], 2
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$228449[esp+936]
	test	eax, eax
	je	SHORT $LN164@MoveCivili
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN163@MoveCivili
$LN164@MoveCivili:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN163@MoveCivili:

; 4930 : #endif
; 4931 : 					strLogString.Format("%s (%d) tried to move to safety but is at the best spot, X: %d, Y: %d", strTemp.GetCString(), pUnit->GetID(), pBestPlot->getX(), pBestPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	mov	edx, DWORD PTR [ebx+100]
	push	eax
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _strTemp$228449[esp+948]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$228448[esp+952]
	push	OFFSET $SG228450
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4932 : 					LogHomelandMessage(strLogString);

	mov	ecx, DWORD PTR _this$[esp+960]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR _strLogString$228448[esp+936]
	push	eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4933 : 				}

	lea	ecx, DWORD PTR _strTemp$228449[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$228448[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN330@MoveCivili:

; 4934 : 
; 4935 : 				pUnit->PushMission(CvTypes::getMISSION_SKIP());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, ebx
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4936 : 				return true;

	mov	eax, DWORD PTR _aBestPlotList$[esp+936]
	lea	ecx, DWORD PTR _aBestPlotList$[esp+948]
	mov	DWORD PTR __$EHRec$[esp+944], -1
	cmp	eax, ecx
	je	SHORT $LN188@MoveCivili
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN188@MoveCivili:
	mov	al, 1
	jmp	$LN37@MoveCivili
$LN8@MoveCivili:

; 4937 : 			}
; 4938 : 			else
; 4939 : 			{
; 4940 : 				if(GC.getLogging() && GC.getAILogging())

	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN5@MoveCivili
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN5@MoveCivili

; 4941 : 				{
; 4942 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228454[esp+936]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	bl, 3

; 4943 : #ifdef AUI_WARNING_FIXES
; 4944 : 					CvString strTemp = pUnit->getUnitInfo().GetDescription();
; 4945 : #else
; 4946 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228455[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4947 : 					strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	edi, DWORD PTR _pUnit$[esp+932]
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+944], 4
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$228455[esp+936]
	test	eax, eax
	je	SHORT $LN209@MoveCivili
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN208@MoveCivili
$LN209@MoveCivili:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN208@MoveCivili:

; 4948 : #endif
; 4949 : 					strLogString.Format("%s (%d) tried to move to safety but cannot hold in current location, X: %d, Y: %d", strTemp.GetCString(), pUnit->GetID(), pBestPlot->getX(), pBestPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	mov	edx, DWORD PTR [edi+100]
	push	eax
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _strTemp$228455[esp+948]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$228454[esp+952]
	push	OFFSET $SG228456
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4950 : 					LogHomelandMessage(strLogString);

	mov	ecx, DWORD PTR _this$[esp+960]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR _strLogString$228454[esp+936]
	push	eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4951 : 				}

	lea	ecx, DWORD PTR _strTemp$228455[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$228454[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ebx, edi
$LN5@MoveCivili:

; 4952 : 				pUnit->SetAutomateType(NO_AUTOMATE);

	push	-1
	mov	ecx, ebx
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 4972 : 		}
; 4973 : 	}
; 4974 : 	else

	jmp	$LN328@MoveCivili
$LN9@MoveCivili:

; 4953 : 			}
; 4954 : 		}
; 4955 : 		else
; 4956 : 		{
; 4957 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN3@MoveCivili
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN3@MoveCivili

; 4958 : 			{
; 4959 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228459[esp+936]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	bl, 5

; 4960 : #ifdef AUI_WARNING_FIXES
; 4961 : 				CvString strTemp = pUnit->getUnitInfo().GetDescription();
; 4962 : #else
; 4963 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$228460[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4964 : 				strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	edi, DWORD PTR _pUnit$[esp+932]
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+944], 6
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$228460[esp+936]
	test	eax, eax
	je	SHORT $LN237@MoveCivili
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN236@MoveCivili
$LN237@MoveCivili:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN236@MoveCivili:

; 4965 : #endif
; 4966 : 				strLogString.Format("%s (%d) moving to safety, X: %d, Y: %d", strTemp.GetCString(), pUnit->GetID(), pBestPlot->getX(), pBestPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	mov	edx, DWORD PTR [edi+100]
	push	eax
	push	ecx
	push	edx
	lea	ecx, DWORD PTR _strTemp$228460[esp+948]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$228459[esp+952]
	push	OFFSET $SG228461
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4967 : 				LogHomelandMessage(strLogString);

	mov	ecx, DWORD PTR _this$[esp+960]
	add	esp, 24					; 00000018H
	lea	edx, DWORD PTR _strLogString$228459[esp+936]
	push	edx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4968 : 			}

	lea	ecx, DWORD PTR _strTemp$228460[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$228459[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ebx, edi
$LN3@MoveCivili:

; 4969 : 
; 4970 : 			pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestPlot->getX(), pBestPlot->getY(), MOVE_UNITS_IGNORE_DANGER);

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	8
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, ebx
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4971 : 			return true;

	mov	eax, DWORD PTR _aBestPlotList$[esp+936]
	lea	ecx, DWORD PTR _aBestPlotList$[esp+948]
	mov	DWORD PTR __$EHRec$[esp+944], -1
	cmp	eax, ecx
	je	$LN188@MoveCivili
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	mov	al, 1
	jmp	SHORT $LN37@MoveCivili

; 4980 : 			strTemp = pUnit->getUnitInfo().GetDescription();

$LN286@MoveCivili:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN285@MoveCivili:

; 4981 : 			strLogString.Format("%s (%d) tried to move to a safe point but couldn't find a good place to go", strTemp.GetCString(), pUnit->GetID());

	mov	eax, DWORD PTR [esi+100]
	push	eax
	lea	ecx, DWORD PTR _strTemp$228466[esp+940]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$228465[esp+944]
	push	OFFSET $SG228467
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 4982 : 			LogHomelandMessage(strLogString);

	mov	ecx, DWORD PTR _this$[esp+952]
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR _strLogString$228465[esp+936]
	push	eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4983 : 		}

	lea	ecx, DWORD PTR _strTemp$228466[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$228465[esp+936]
	mov	BYTE PTR __$EHRec$[esp+944], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN328@MoveCivili:

; 4984 : 	}
; 4985 : 
; 4986 : 
; 4987 : 	return false;

	mov	eax, DWORD PTR _aBestPlotList$[esp+936]
	lea	ecx, DWORD PTR _aBestPlotList$[esp+948]
	mov	DWORD PTR __$EHRec$[esp+944], -1
	cmp	eax, ecx
	je	SHORT $LN306@MoveCivili
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN306@MoveCivili:
	xor	al, al
$LN37@MoveCivili:

; 4988 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+936]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 920				; 00000398H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$0:
	lea	ecx, DWORD PTR _aBestPlotList$[ebp]
	jmp	??1?$CvWeightedVector@PAVCvPlot@@$0GE@$00@@QAE@XZ ; CvWeightedVector<CvPlot *,100,1>::~CvWeightedVector<CvPlot *,100,1>
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$7:
	lea	ecx, DWORD PTR _strLogString$228465[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$8:
	lea	ecx, DWORD PTR _strTemp$228466[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$1:
	lea	ecx, DWORD PTR _strLogString$228448[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$2:
	lea	ecx, DWORD PTR _strTemp$228449[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$3:
	lea	ecx, DWORD PTR _strLogString$228454[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$4:
	lea	ecx, DWORD PTR _strTemp$228455[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$5:
	lea	ecx, DWORD PTR _strLogString$228459[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z$6:
	lea	ecx, DWORD PTR _strTemp$228460[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ENDP ; CvHomelandAI::MoveCivilianToSafety
PUBLIC	?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteTradeUnitMoves
EXTRN	?getMISSION_ESTABLISH_TRADE_ROUTE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_ESTABLISH_TRADE_ROUTE
EXTRN	?getMISSION_CHANGE_TRADE_UNIT_HOME_CITY@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_CHANGE_TRADE_UNIT_HOME_CITY
EXTRN	?ChooseTradeUnitTargetPlot@CvTradeAI@@QAE_NPAVCvUnit@@AAH1AAW4TradeConnectionType@@AA_NABV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z:PROC ; CvTradeAI::ChooseTradeUnitTargetPlot
EXTRN	?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z:PROC ; CvTradeAI::PrioritizeTradeRoutes
EXTRN	_atexit:PROC
EXTRN	?GetTradeAI@CvPlayer@@QBEPAVCvTradeAI@@XZ:PROC	; CvPlayer::GetTradeAI
;	COMDAT ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_BSS	SEGMENT
?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A DB 012370H DUP (?) ; `CvHomelandAI::ExecuteTradeUnitMoves'::`2'::aTradeConnections
_BSS	ENDS
;	COMDAT ?$S1@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4IA
_BSS	SEGMENT
?$S1@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4IA DD 01H DUP (?) ; `CvHomelandAI::ExecuteTradeUnitMoves'::`2'::$S1
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$4
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_bDisband$228489 = -85					; size = 1
_iDestPlotIndex$228487 = -84				; size = 4
_eTradeConnectionType$228488 = -80			; size = 4
_iOriginPlotIndex$228486 = -76				; size = 4
_it$ = -72						; size = 4
_strLogString$228506 = -68				; size = 28
_strLogString$228501 = -68				; size = 28
_strLogString$228494 = -68				; size = 28
_strLogString$228519 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ExecuteTradeUnitMoves, COMDAT
; _this$ = ecx

; 4992 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	push	ebp
	mov	ebp, ecx

; 4993 : 	CvTradeAI* pkTradeAI = m_pPlayer->GetTradeAI();

	mov	ecx, DWORD PTR [ebp]
	push	esi
	call	?GetTradeAI@CvPlayer@@QBEPAVCvTradeAI@@XZ ; CvPlayer::GetTradeAI

; 4994 : 
; 4995 : 	static TradeConnectionList aTradeConnections; // slewis - added static to work around the stack limit

	test	BYTE PTR ?$S1@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4IA, 1
	mov	esi, eax
	jne	SHORT $LN112@ExecuteTra
	or	DWORD PTR ?$S1@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4IA, 1
	push	OFFSET ??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ ; `CvHomelandAI::ExecuteTradeUnitMoves'::`2'::`dynamic atexit destructor for 'aTradeConnections''
	mov	DWORD PTR ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A+4, 0
	mov	DWORD PTR ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A+8, 168 ; 000000a8H
	mov	DWORD PTR ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A, OFFSET ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A+12
	call	_atexit
	add	esp, 4
	mov	DWORD PTR __$EHRec$[esp+104], -1
$LN112@ExecuteTra:

; 4996 : 	pkTradeAI->PrioritizeTradeRoutes(aTradeConnections);

	push	OFFSET ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A
	mov	ecx, esi
	call	?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ; CvTradeAI::PrioritizeTradeRoutes

; 4997 : 
; 4998 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4999 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR [ebp+16]
	mov	ecx, DWORD PTR [ebp+20]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _it$[esp+96], eax
	cmp	eax, ecx
	je	$LN17@ExecuteTra
	push	edi
	npad	3
$LL114@ExecuteTra:

; 5000 : 	{
; 5001 : 		CvUnit* pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax

; 5002 : 		if(!pUnit)

	test	esi, esi
	je	$LN18@ExecuteTra

; 5003 : 		{
; 5004 : 			continue;
; 5005 : 		}
; 5006 : 
; 5007 : 		int iOriginPlotIndex = MAX_INT;
; 5008 : 		int iDestPlotIndex = MAX_INT;
; 5009 : 		TradeConnectionType eTradeConnectionType = NUM_TRADE_CONNECTION_TYPES;
; 5010 : 		bool bDisband = false;
; 5011 : 		bool bSuccess = m_pPlayer->GetTradeAI()->ChooseTradeUnitTargetPlot(pUnit, iOriginPlotIndex, iDestPlotIndex, eTradeConnectionType, bDisband, aTradeConnections);

	push	OFFSET ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A
	mov	eax, 2147483647				; 7fffffffH
	lea	edx, DWORD PTR _bDisband$228489[esp+104]
	push	edx
	mov	DWORD PTR _iOriginPlotIndex$228486[esp+108], eax
	mov	DWORD PTR _iDestPlotIndex$228487[esp+108], eax
	lea	eax, DWORD PTR _eTradeConnectionType$228488[esp+108]
	push	eax
	lea	ecx, DWORD PTR _iDestPlotIndex$228487[esp+112]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	lea	edx, DWORD PTR _iOriginPlotIndex$228486[esp+116]
	push	edx
	push	esi
	mov	DWORD PTR _eTradeConnectionType$228488[esp+124], 3
	mov	BYTE PTR _bDisband$228489[esp+124], 0
	call	?GetTradeAI@CvPlayer@@QBEPAVCvTradeAI@@XZ ; CvPlayer::GetTradeAI
	mov	ecx, eax
	call	?ChooseTradeUnitTargetPlot@CvTradeAI@@QAE_NPAVCvUnit@@AAH1AAW4TradeConnectionType@@AA_NABV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ; CvTradeAI::ChooseTradeUnitTargetPlot

; 5012 : 		if (bSuccess)

	test	al, al
	je	$LN15@ExecuteTra

; 5013 : 		{
; 5014 : 			if (bDisband)

	cmp	BYTE PTR _bDisband$228489[esp+100], 0
	je	SHORT $LN14@ExecuteTra

; 5015 : 			{
; 5016 : 				pUnit->kill(true);

	push	-1
	push	1
	mov	ecx, esi
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill

; 5017 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN18@ExecuteTra
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN18@ExecuteTra

; 5018 : 				{
; 5019 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228494[esp+100]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5020 : 					strLogString.Format("Disbanding unit because we want different domains for our trade units");

	lea	eax, DWORD PTR _strLogString$228494[esp+100]
	push	OFFSET $SG228495
	push	eax
	mov	DWORD PTR __$EHRec$[esp+116], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 5021 : 					LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$228494[esp+100]
	push	ecx
	mov	ecx, ebp
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 5022 : 				}

	lea	ecx, DWORD PTR _strLogString$228494[esp+100]

; 5023 : 			}
; 5024 : 			else

	jmp	$LN116@ExecuteTra
$LN14@ExecuteTra:

; 5025 : 			{
; 5026 : 				CvPlot* pOriginPlot = GC.getMap().plotByIndex(iOriginPlotIndex);

	mov	edi, DWORD PTR _iOriginPlotIndex$228486[esp+100]
	test	edi, edi
	jl	SHORT $LN52@ExecuteTra
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	edi, DWORD PTR [eax+4028]
	jge	SHORT $LN52@ExecuteTra
	imul	edi, 484				; 000001e4H
	add	edi, DWORD PTR [eax+4068]
	jmp	SHORT $LN53@ExecuteTra
$LN52@ExecuteTra:
	xor	edi, edi
$LN53@ExecuteTra:

; 5027 : 				if (pOriginPlot != pUnit->plot())

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 5028 : 				{
; 5029 : 					pUnit->PushMission(CvTypes::getMISSION_CHANGE_TRADE_UNIT_HOME_CITY(), pOriginPlot->getX(), pOriginPlot->getY());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	cmp	edi, eax
	je	$LN11@ExecuteTra
	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	eax
	push	ecx
	call	?getMISSION_CHANGE_TRADE_UNIT_HOME_CITY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CHANGE_TRADE_UNIT_HOME_CITY
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 5030 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN18@ExecuteTra
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN18@ExecuteTra

; 5031 : 					{
; 5032 : 						CvPlot* pPlot = GC.getMap().plotByIndex(iDestPlotIndex);

	mov	eax, DWORD PTR _iDestPlotIndex$228487[esp+100]
	test	eax, eax
	jl	SHORT $LN64@ExecuteTra
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN64@ExecuteTra
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	mov	esi, eax
	jmp	SHORT $LN65@ExecuteTra
$LN64@ExecuteTra:
	xor	esi, esi
$LN65@ExecuteTra:

; 5033 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228501[esp+100]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5034 : 						strLogString.Format("Changing trade route home city, X: %d, Y: %d", pPlot->getX(), pPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	edx
	push	eax
	mov	DWORD PTR __$EHRec$[esp+116], 2
	push	OFFSET $SG228502
$LN117@ExecuteTra:
	lea	ecx, DWORD PTR _strLogString$228501[esp+112]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H
$LN6@ExecuteTra:

; 5035 : 						LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$228501[esp+100]
	push	edx
	mov	ecx, ebp
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 5036 : 					}

	lea	ecx, DWORD PTR _strLogString$228501[esp+100]

; 5037 : 				}
; 5038 : 				else

	jmp	$LN116@ExecuteTra
$LN11@ExecuteTra:

; 5039 : 				{
; 5040 : 					pUnit->PushMission(CvTypes::getMISSION_ESTABLISH_TRADE_ROUTE(), iDestPlotIndex, eTradeConnectionType);

	mov	eax, DWORD PTR _eTradeConnectionType$228488[esp+124]
	mov	ecx, DWORD PTR _iDestPlotIndex$228487[esp+124]
	push	eax
	push	ecx
	call	?getMISSION_ESTABLISH_TRADE_ROUTE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ESTABLISH_TRADE_ROUTE
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 5041 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN18@ExecuteTra
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN18@ExecuteTra

; 5042 : 					{
; 5043 : 						CvPlot* pPlot = GC.getMap().plotByIndex(iDestPlotIndex);

	mov	eax, DWORD PTR _iDestPlotIndex$228487[esp+100]
	test	eax, eax
	jl	SHORT $LN82@ExecuteTra
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN82@ExecuteTra
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	mov	esi, eax
	jmp	SHORT $LN83@ExecuteTra
$LN82@ExecuteTra:
	xor	esi, esi
$LN83@ExecuteTra:

; 5044 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228506[esp+100]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5045 : 
; 5046 : 						switch (eTradeConnectionType)

	mov	eax, DWORD PTR _eTradeConnectionType$228488[esp+100]
	sub	eax, 0
	mov	DWORD PTR __$EHRec$[esp+108], 3
	je	SHORT $LN4@ExecuteTra
	sub	eax, 1
	je	SHORT $LN5@ExecuteTra
	sub	eax, 1
	jne	$LN6@ExecuteTra

; 5053 : 							break;
; 5054 : 						case TRADE_CONNECTION_PRODUCTION:
; 5055 : 							strLogString.Format("Establishing trade route, X: %d, Y: %d, production", pPlot->getX(), pPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	edx
	push	eax
	push	OFFSET $SG228516

; 5056 : 							break;

	jmp	$LN117@ExecuteTra
$LN5@ExecuteTra:

; 5047 : 						{
; 5048 : 						case TRADE_CONNECTION_FOOD:
; 5049 : 							strLogString.Format("Establishing trade route, X: %d, Y: %d, food", pPlot->getX(), pPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	edx
	push	eax
	push	OFFSET $SG228512

; 5050 : 							break;

	jmp	$LN117@ExecuteTra
$LN4@ExecuteTra:

; 5051 : 						case TRADE_CONNECTION_INTERNATIONAL:
; 5052 : 							strLogString.Format("Establishing trade route, X: %d, Y: %d, gold", pPlot->getX(), pPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [esi]
	push	edx
	push	eax
	push	OFFSET $SG228514

; 5057 : 						}
; 5058 : 
; 5059 : 						LogHomelandMessage(strLogString);
; 5060 : 					}
; 5061 : 				}
; 5062 : 			}
; 5063 : 		}
; 5064 : 		else

	jmp	$LN117@ExecuteTra
$LN15@ExecuteTra:

; 5065 : 		{
; 5066 : 			pUnit->PushMission(CvTypes::getMISSION_SKIP());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 5067 : 			pUnit->finishMoves();			

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 5068 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN18@ExecuteTra
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN18@ExecuteTra

; 5069 : 			{
; 5070 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228519[esp+100]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5071 : 				strLogString.Format("Trade unit idling");

	lea	eax, DWORD PTR _strLogString$228519[esp+100]
	push	OFFSET $SG228520
	push	eax
	mov	DWORD PTR __$EHRec$[esp+116], 4
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 5072 : 				LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$228519[esp+100]
	push	ecx
	mov	ecx, ebp
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 5073 : 			}

	lea	ecx, DWORD PTR _strLogString$228519[esp+100]
$LN116@ExecuteTra:
	mov	DWORD PTR __$EHRec$[esp+108], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN18@ExecuteTra:
	mov	edx, DWORD PTR [ebp+20]
	mov	eax, DWORD PTR _it$[esp+100]
	shl	edx, 4
	add	edx, DWORD PTR [ebp+16]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _it$[esp+100], eax
	cmp	eax, edx
	jne	$LL114@ExecuteTra
	pop	edi
$LN17@ExecuteTra:

; 5074 : 		}
; 5075 : 	}
; 5076 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$0:
	mov	eax, DWORD PTR ?$S1@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4IA, eax
	ret	0
__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$228494[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$228501[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$228506[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$228519[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ExecuteTradeUnitMoves
PUBLIC	?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteCultureBlast
EXTRN	?getMISSION_GIVE_POLICIES@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_GIVE_POLICIES
EXTRN	?canGivePolicies@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canGivePolicies
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$1
__ehfuncinfo$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
_TEXT	SEGMENT
_strTemp$229022 = -68					; size = 28
_strLogString$229021 = -40				; size = 28
__$EHRec$ = -12						; size = 12
$T269371 = 8						; size = 4
_pUnit$ = 8						; size = 4
?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z PROC ; CvHomelandAI::ExecuteCultureBlast, COMDAT
; _this$ = ecx

; 6087 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	esi

; 6088 : 	if (pUnit->canGivePolicies(pUnit->plot()))

	mov	esi, DWORD PTR _pUnit$[esp+68]
	push	edi
	mov	edi, ecx
	push	0
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?canGivePolicies@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canGivePolicies
	test	al, al
	je	$LN3@ExecuteCul
	push	ebp

; 6089 : 	{
; 6090 : 		pUnit->PushMission(CvTypes::getMISSION_GIVE_POLICIES());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GIVE_POLICIES@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GIVE_POLICIES
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6091 : 		UnitProcessed(pUnit->GetID());

	mov	ebp, DWORD PTR [esi+100]
	lea	eax, DWORD PTR $T269371[esp+76]
	push	eax
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T269371[esp+80], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	pop	ebp
	test	eax, eax
	je	SHORT $LN13@ExecuteCul
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN13@ExecuteCul:

; 6092 : 
; 6093 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN44@ExecuteCul
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN44@ExecuteCul

; 6094 : 		{
; 6095 : 			CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$229021[esp+76]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6096 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$229022[esp+76]
	mov	DWORD PTR __$EHRec$[esp+84], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6097 : 			strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+84], 1
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$229022[esp+76]
	test	eax, eax
	je	SHORT $LN24@ExecuteCul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN23@ExecuteCul
$LN24@ExecuteCul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN23@ExecuteCul:

; 6098 : 			strLogString.Format("%s blasted culture with unit at, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	push	eax
	push	esi
	lea	ecx, DWORD PTR _strTemp$229022[esp+84]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$229021[esp+88]
	push	OFFSET $SG229023
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 6099 : 			LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$229021[esp+76]
	push	edx
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 6100 : 		}

	lea	ecx, DWORD PTR _strTemp$229022[esp+76]
	mov	BYTE PTR __$EHRec$[esp+84], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$229021[esp+76]
	mov	DWORD PTR __$EHRec$[esp+84], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi

; 6105 : 	}
; 6106 : 
; 6107 : 	return true;

	mov	al, 1
	pop	esi

; 6108 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	4
$LN3@ExecuteCul:

; 6101 : 	}
; 6102 : 	else
; 6103 : 	{
; 6104 : 		MoveCivilianToSafety(pUnit);

	push	0
	push	esi
	mov	ecx, edi
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN44@ExecuteCul:

; 6108 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	pop	edi
	mov	al, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _strLogString$229021[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$1:
	lea	ecx, DWORD PTR _strTemp$229022[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ENDP ; CvHomelandAI::ExecuteCultureBlast
PUBLIC	?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteGoldenAgeMove
EXTRN	?getMISSION_GOLDEN_AGE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_GOLDEN_AGE
EXTRN	?canGoldenAge@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canGoldenAge
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$1
__ehfuncinfo$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
_TEXT	SEGMENT
_strTemp$229032 = -68					; size = 28
_strLogString$229031 = -40				; size = 28
__$EHRec$ = -12						; size = 12
$T269446 = 8						; size = 4
_pUnit$ = 8						; size = 4
?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z PROC ; CvHomelandAI::ExecuteGoldenAgeMove, COMDAT
; _this$ = ecx

; 6111 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	esi

; 6112 : 	if (pUnit->canGoldenAge(pUnit->plot()))

	mov	esi, DWORD PTR _pUnit$[esp+68]
	push	edi
	mov	edi, ecx
	push	0
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?canGoldenAge@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canGoldenAge
	test	al, al
	je	$LN3@ExecuteGol
	push	ebp

; 6113 : 	{
; 6114 : 		pUnit->PushMission(CvTypes::getMISSION_GOLDEN_AGE());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GOLDEN_AGE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GOLDEN_AGE
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 6115 : 		UnitProcessed(pUnit->GetID());

	mov	ebp, DWORD PTR [esi+100]
	lea	eax, DWORD PTR $T269446[esp+76]
	push	eax
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T269446[esp+80], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	pop	ebp
	test	eax, eax
	je	SHORT $LN13@ExecuteGol
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN13@ExecuteGol:

; 6116 : 
; 6117 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN44@ExecuteGol
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN44@ExecuteGol

; 6118 : 		{
; 6119 : 			CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$229031[esp+76]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6120 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$229032[esp+76]
	mov	DWORD PTR __$EHRec$[esp+84], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 6121 : 			strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+84], 1
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$229032[esp+76]
	test	eax, eax
	je	SHORT $LN24@ExecuteGol
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN23@ExecuteGol
$LN24@ExecuteGol:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN23@ExecuteGol:

; 6122 : 			strLogString.Format("%s started golden age with unit at, X: %d, Y: %d", strTemp.GetCString(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	push	eax
	push	esi
	lea	ecx, DWORD PTR _strTemp$229032[esp+84]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$229031[esp+88]
	push	OFFSET $SG229033
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 6123 : 			LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$229031[esp+76]
	push	edx
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 6124 : 		}

	lea	ecx, DWORD PTR _strTemp$229032[esp+76]
	mov	BYTE PTR __$EHRec$[esp+84], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$229031[esp+76]
	mov	DWORD PTR __$EHRec$[esp+84], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi

; 6129 : 	}
; 6130 : 
; 6131 : 	return true;

	mov	al, 1
	pop	esi

; 6132 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	4
$LN3@ExecuteGol:

; 6125 : 	}
; 6126 : 	else
; 6127 : 	{
; 6128 : 		MoveCivilianToSafety(pUnit);

	push	0
	push	esi
	mov	ecx, edi
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN44@ExecuteGol:

; 6132 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	pop	edi
	mov	al, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _strLogString$229031[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z$1:
	lea	ecx, DWORD PTR _strTemp$229032[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ENDP ; CvHomelandAI::ExecuteGoldenAgeMove
PUBLIC	??$stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z ; std::stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z PROC ; std::stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >, COMDAT

; 3420 : 	_DEBUG_RANGE(_First, _Last);
; 3421 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor

; 3422 : 		{
; 3423 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 16					; 00000010H
$LN1@stable_sor:

; 3424 : 		}
; 3425 : 	}

	ret	0
??$stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0@Z ENDP ; std::stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> > >
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z PROC ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3411 : 	_Diff _Count = 0;
; 3412 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	sar	ecx, 3

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	mov	edx, eax
	push	edx
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	call	??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0HAAV?$_Temp_iterator@VCvHomelandMove@@@0@@Z ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>

; 3415 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+60]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN20@Stable_sor@6
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@Stable_sor@6:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandMove@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandMove>::~_Temp_iterator<CvHomelandMove>
__ehhandler$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z ENDP ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>
PUBLIC	??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
__Pred$ = 24						; size = 4
??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z PROC ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 3560 : 	{	// sort preserving order of equivalents, using _Pred

	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3561 : 	_Diff _Count = 0;
; 3562 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	sar	ecx, 4

; 3563 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3564 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);

	mov	edx, DWORD PTR __Pred$[esp+40]
	push	edx
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+72], ebx
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@P6A_NV1@2@Z@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>

; 3565 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+64]
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN20@Stable_sor@7
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@Stable_sor@7:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z ENDP ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
PUBLIC	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z PROC ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3411 : 	_Diff _Count = 0;
; 3412 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	sar	ecx, 4

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	mov	edx, eax
	push	edx
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0HAAV?$_Temp_iterator@VCvHomelandUnit@@@0@@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>

; 3415 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+60]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN20@Stable_sor@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@Stable_sor@8:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvHomelandUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvHomelandUnit>::~_Temp_iterator<CvHomelandUnit>
__ehhandler$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z ENDP ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
PUBLIC	?PlotExplorerMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotExplorerMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotExplorerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$225531 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$225537 = -36					; size = 8
_unit$225541 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotExplorerMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotExplorerMoves, COMDAT
; _this$ = ecx

; 851  : {

	push	-1
	push	__ehhandler$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 852  : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 853  : 
; 854  : 	// Loop through all recruited units
; 855  : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$225531[esp+56], ebp
	cmp	ebp, eax
	je	$LN5@PlotExplor
	push	edi
	jmp	SHORT $LN31@PlotExplor
	npad	3
$LL92@PlotExplor:
	mov	ebp, DWORD PTR _it$225531[esp+60]
$LN31@PlotExplor:

; 856  : 	{
; 857  : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$225537[esp+60], edi
	mov	BYTE PTR _pUnit$225537[esp+64], 0
	test	edi, edi
	je	SHORT $LN54@PlotExplor
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN54@PlotExplor:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 858  : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN94@PlotExplor

; 859  : 		{
; 860  : 			if(pUnit->AI_getUnitAIType() == UNITAI_EXPLORE ||
; 861  : #ifdef AUI_WARNING_FIXES
; 862  : 					(pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_LAND && pUnit->GetAutomateType() == AUTOMATE_EXPLORE))
; 863  : #else
; 864  : 			        pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_LAND && pUnit->GetAutomateType() == AUTOMATE_EXPLORE)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN93@PlotExplor
	mov	ecx, edi
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	test	al, al
	je	SHORT $LN94@PlotExplor
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN94@PlotExplor
	mov	ecx, edi
	call	?GetAutomateType@CvUnit@@QBE?AW4AutomateTypes@@XZ ; CvUnit::GetAutomateType
	cmp	eax, 1
	jne	SHORT $LN94@PlotExplor
$LN93@PlotExplor:

; 865  : #endif
; 866  : 			{
; 867  : 				CvHomelandUnit unit;
; 868  : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 869  : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$225541[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN76@PlotExplor
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN76@PlotExplor:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN79@PlotExplor
	mov	edx, DWORD PTR _unit$225541[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN79@PlotExplor:
	inc	DWORD PTR [esi+4]
	mov	ebx, DWORD PTR _this$[esp+60]
	mov	ebp, DWORD PTR _it$225531[esp+60]
$LN94@PlotExplor:

; 870  : 			}
; 871  : 		}
; 872  : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN6@PlotExplor
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@PlotExplor:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$225531[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL92@PlotExplor
	pop	edi
$LN5@PlotExplor:

; 873  : 
; 874  : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotExplor

; 875  : 	{
; 876  : 		// Execute twice so explorers who can reach the end of their sight can move again
; 877  : 		ExecuteExplorerMoves();

	mov	ecx, ebx
	call	?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteExplorerMoves

; 878  : 		ExecuteExplorerMoves();

	mov	ecx, ebx
	call	?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteExplorerMoves
$LN1@PlotExplor:

; 879  : 	}
; 880  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225537[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotExplorerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotExplorerMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotExplorerMoves
PUBLIC	?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotExplorerSeaMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$225550 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$225556 = -36					; size = 8
_unit$225560 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotExplorerSeaMoves, COMDAT
; _this$ = ecx

; 884  : {

	push	-1
	push	__ehhandler$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 885  : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 886  : 
; 887  : 	// Loop through all recruited units
; 888  : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$225550[esp+56], ebp
	cmp	ebp, eax
	je	$LN5@PlotExplor@2
	push	edi
	jmp	SHORT $LN31@PlotExplor@2
	npad	3
$LL92@PlotExplor@2:
	mov	ebp, DWORD PTR _it$225550[esp+60]
$LN31@PlotExplor@2:

; 889  : 	{
; 890  : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$225556[esp+60], edi
	mov	BYTE PTR _pUnit$225556[esp+64], 0
	test	edi, edi
	je	SHORT $LN54@PlotExplor@2
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN54@PlotExplor@2:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 891  : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN94@PlotExplor@2

; 892  : 		{
; 893  : 			if(pUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA ||
; 894  : #ifdef AUI_WARNING_FIXES
; 895  : 					(pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_SEA && pUnit->GetAutomateType() == AUTOMATE_EXPLORE))
; 896  : #else
; 897  : 			        pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_SEA && pUnit->GetAutomateType() == AUTOMATE_EXPLORE)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	je	SHORT $LN93@PlotExplor@2
	mov	ecx, edi
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	test	al, al
	je	SHORT $LN94@PlotExplor@2
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN94@PlotExplor@2
	mov	ecx, edi
	call	?GetAutomateType@CvUnit@@QBE?AW4AutomateTypes@@XZ ; CvUnit::GetAutomateType
	cmp	eax, 1
	jne	SHORT $LN94@PlotExplor@2
$LN93@PlotExplor@2:

; 898  : #endif
; 899  : 			{
; 900  : 				CvHomelandUnit unit;
; 901  : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 902  : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$225560[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN76@PlotExplor@2
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN76@PlotExplor@2:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN79@PlotExplor@2
	mov	edx, DWORD PTR _unit$225560[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN79@PlotExplor@2:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$225550[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN94@PlotExplor@2:

; 903  : 			}
; 904  : 		}
; 905  : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN6@PlotExplor@2
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@PlotExplor@2:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$225550[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL92@PlotExplor@2
	pop	edi
$LN5@PlotExplor@2:

; 906  : 
; 907  : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotExplor@2

; 908  : 	{
; 909  : 		// Execute twice so explorers who can reach the end of their sight can move again
; 910  : 		ExecuteExplorerMoves();

	mov	ecx, ebx
	call	?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteExplorerMoves

; 911  : 		ExecuteExplorerMoves();

	mov	ecx, ebx
	call	?ExecuteExplorerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteExplorerMoves
$LN1@PlotExplor@2:

; 912  : 	}
; 913  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225556[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotExplorerSeaMoves
PUBLIC	?PlotMovesToSafety@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotMovesToSafety
EXTRN	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ:PROC ; CvUnit::GetBaseCombatStrengthConsideringDamage
EXTRN	?isBarbarian@CvUnit@@QBE_NXZ:PROC		; CvUnit::isBarbarian
EXTRN	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z:PROC	; CvUnit::GetBaseCombatStrength
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotMovesToSafety@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$225633 = -48					; size = 4
_iDangerLevel$225642 = -44				; size = 4
_this$ = -40						; size = 4
_pUnit$225639 = -36					; size = 8
_unit$225660 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotMovesToSafety@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotMovesToSafety, COMDAT
; _this$ = ecx

; 1049 : {

	push	-1
	push	__ehhandler$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 1050 : 	ClearCurrentMoveUnits();

	xor	ebp, ebp
	push	edi
	mov	DWORD PTR [ebx+20], ebp

; 1051 : 
; 1052 : 	// Loop through all recruited units
; 1053 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	lea	edi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], ebp
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+60], ebx
	mov	DWORD PTR _it$225633[esp+60], ecx
	cmp	ecx, eax
	je	$LN18@PlotMovesT
	push	esi
	npad	5
$LL124@PlotMovesT:

; 1054 : 	{
; 1055 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR _it$225633[esp+64]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$225639[esp+64], esi
	mov	BYTE PTR _pUnit$225639[esp+68], 0
	cmp	esi, ebp
	je	SHORT $LN67@PlotMovesT
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN67@PlotMovesT:
	mov	DWORD PTR __$EHRec$[esp+72], ebp

; 1056 : 		if(pUnit)

	cmp	esi, ebp
	je	$LN126@PlotMovesT

; 1057 : 		{
; 1058 : 			// Danger value of plot must be greater than 0
; 1059 : 			CvPlot* pPlot = pUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 1060 : 
; 1061 : 			int iDangerLevel = m_pPlayer->GetPlotDanger(*pPlot);

	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger

; 1062 : 			if(iDangerLevel > 0)

	cmp	eax, ebp
	mov	DWORD PTR _iDangerLevel$225642[esp+64], eax
	jle	$LN126@PlotMovesT

; 1063 : 			{
; 1064 : 				bool bAddUnit = false;
; 1065 : 
; 1066 : 				// If civilian (or embarked unit) always ready to flee
; 1067 : 				// slewis - 4.18.2013 - Problem here is that a combat unit that is a boat can get stuck in a city hiding from barbarians on the land
; 1068 : 				if(!pUnit->IsCanDefend())

	push	ebp
	mov	ecx, esi
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend

; 1069 : 				{
; 1070 : 					if (pUnit->IsAutomated() && pUnit->GetBaseCombatStrength() > 0)

	mov	ecx, esi
	test	al, al
	jne	SHORT $LN15@PlotMovesT
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	test	al, al
	je	SHORT $LN125@PlotMovesT
	push	ebp
	mov	ecx, esi
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	test	eax, eax
	jg	$LN126@PlotMovesT

; 1071 : 					{
; 1072 : 						// then this is our special case
; 1073 : 					}
; 1074 : 					else
; 1075 : 					{
; 1076 : 						bAddUnit = true;
; 1077 : 					}

	jmp	SHORT $LN125@PlotMovesT
$LN15@PlotMovesT:

; 1078 : 				}
; 1079 : 
; 1080 : 				// Also may be true if a damaged combat unit
; 1081 : 				else if(pUnit->GetCurrHitPoints() < pUnit->GetMaxHitPoints())

	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	mov	ecx, esi
	mov	ebp, eax
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	cmp	ebp, eax

; 1082 : 				{
; 1083 : 					if(pUnit->isBarbarian())

	mov	ecx, esi
	jge	SHORT $LN11@PlotMovesT
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian

; 1084 : 					{
; 1085 : 						// Barbarian combat units - only naval units flee (but they flee if have taken ANY damage)
; 1086 : 						if(pUnit->getDomainType() == DOMAIN_SEA)

	mov	ecx, esi
	test	al, al
	je	SHORT $LN10@PlotMovesT
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	$LN126@PlotMovesT

; 1087 : 						{
; 1088 : 							bAddUnit = true;
; 1089 : 						}
; 1090 : 					}

	jmp	SHORT $LN125@PlotMovesT
$LN10@PlotMovesT:

; 1091 : 
; 1092 : 					// Everyone else flees at less than or equal to 50% combat strength
; 1093 : 					else if(pUnit->IsUnderEnemyRangedAttack() || pUnit->GetBaseCombatStrengthConsideringDamage() * 2 <= pUnit->GetBaseCombatStrength())

	call	?IsUnderEnemyRangedAttack@CvUnit@@QBE_NXZ ; CvUnit::IsUnderEnemyRangedAttack
	test	al, al
	jne	SHORT $LN125@PlotMovesT
	push	0
	mov	ecx, esi
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	mov	ecx, esi
	mov	ebp, eax
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage
	add	eax, eax
	cmp	eax, ebp
	jg	SHORT $LN126@PlotMovesT

; 1094 : 					{
; 1095 : 						bAddUnit = true;
; 1096 : 					}
; 1097 : 				}

	jmp	SHORT $LN125@PlotMovesT
$LN11@PlotMovesT:

; 1098 : 
; 1099 : 				// Also flee if danger is really high in current plot (but not if we're barbarian)
; 1100 : 				else if(!pUnit->isBarbarian())

	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	test	al, al
	jne	SHORT $LN126@PlotMovesT

; 1101 : 				{
; 1102 : 					int iAcceptableDanger;
; 1103 : #ifdef AUI_HOMELAND_TWEAKED_ACCEPTABLE_DANGER
; 1104 : 					iAcceptableDanger = pUnit->GetBaseCombatStrengthConsideringDamage() * (int)(AUI_HOMELAND_TWEAKED_ACCEPTABLE_DANGER + 0.5 +
; 1105 : 						(100.0 - AUI_HOMELAND_TWEAKED_ACCEPTABLE_DANGER) * pow((double)pUnit->GetCurrHitPoints() / (double)pUnit->GetMaxHitPoints(), 2.0));
; 1106 : #else
; 1107 : 					iAcceptableDanger = pUnit->GetBaseCombatStrengthConsideringDamage() * 100;

	mov	ecx, esi
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage
	imul	eax, 100				; 00000064H

; 1108 : #endif
; 1109 : 					if(iDangerLevel > iAcceptableDanger)

	cmp	DWORD PTR _iDangerLevel$225642[esp+64], eax
	jle	SHORT $LN126@PlotMovesT
$LN125@PlotMovesT:

; 1110 : 					{
; 1111 : 						bAddUnit = true;
; 1112 : 					}
; 1113 : 				}
; 1114 : 
; 1115 : 				if(bAddUnit)
; 1116 : 				{
; 1117 : 					// Just one unit involved in this move to execute
; 1118 : 					CvHomelandUnit unit;
; 1119 : 					unit.SetID(pUnit->GetID());

	mov	edx, DWORD PTR [esi+100]

; 1120 : 					m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [edi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$225660[esp+64], edx
	mov	BYTE PTR [edi+1036], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN107@PlotMovesT
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN107@PlotMovesT:
	mov	eax, DWORD PTR [edi+4]
	shl	eax, 4
	add	eax, DWORD PTR [edi]
	je	SHORT $LN110@PlotMovesT
	mov	ecx, DWORD PTR _unit$225660[esp+64]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN110@PlotMovesT:
	inc	DWORD PTR [edi+4]
	mov	ebx, DWORD PTR _this$[esp+64]
$LN126@PlotMovesT:

; 1121 : 				}
; 1122 : 			}
; 1123 : 		}
; 1124 : 	}

	xor	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+72], -1
	cmp	esi, ebp
	je	SHORT $LN19@PlotMovesT
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN19@PlotMovesT:
	mov	edx, DWORD PTR _it$225633[esp+64]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225633[esp+64], eax
	cmp	eax, DWORD PTR [ebx+8]
	jne	$LL124@PlotMovesT
	pop	esi
$LN18@PlotMovesT:

; 1125 : 
; 1126 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], ebp
	jbe	SHORT $LN1@PlotMovesT

; 1127 : 	{
; 1128 : 		ExecuteMovesToSafestPlot();

	mov	ecx, ebx
	call	?ExecuteMovesToSafestPlot@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteMovesToSafestPlot
$LN1@PlotMovesT:

; 1129 : 	}
; 1130 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225639[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotMovesToSafety@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotMovesToSafety@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotMovesToSafety
PUBLIC	?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotTradeUnitMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$226194 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$226200 = -36					; size = 8
_unit$226203 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotTradeUnitMoves, COMDAT
; _this$ = ecx

; 2074 : {

	push	-1
	push	__ehhandler$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 2075 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 2076 : 
; 2077 : 	// Loop through all recruited units
; 2078 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$226194[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotTradeU
	push	edi
	jmp	SHORT $LN30@PlotTradeU
	npad	3
$LL85@PlotTradeU:
	mov	ebp, DWORD PTR _it$226194[esp+60]
$LN30@PlotTradeU:

; 2079 : 	{
; 2080 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$226200[esp+60], edi
	mov	BYTE PTR _pUnit$226200[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotTradeU
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotTradeU:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 2081 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotTradeU

; 2082 : 		{
; 2083 : 			if(pUnit->AI_getUnitAIType() == UNITAI_TRADE_UNIT)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN86@PlotTradeU

; 2084 : 			{
; 2085 : 				CvHomelandUnit unit;
; 2086 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 2087 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$226203[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotTradeU
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotTradeU:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotTradeU
	mov	edx, DWORD PTR _unit$226203[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotTradeU:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$226194[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotTradeU:

; 2088 : 			}
; 2089 : 		}
; 2090 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotTradeU
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotTradeU:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$226194[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotTradeU
	pop	edi
$LN4@PlotTradeU:

; 2091 : 
; 2092 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotTradeU

; 2093 : 	{
; 2094 : 		ExecuteTradeUnitMoves();

	mov	ecx, ebx
	call	?ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteTradeUnitMoves
$LN1@PlotTradeU:

; 2095 : 	}
; 2096 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226200[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotTradeUnitMoves
PUBLIC	?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteWorkerMoves
EXTRN	?IsPlotUnderImmediateThreat@CvPlayer@@QBE_NAAVCvPlot@@@Z:PROC ; CvPlayer::IsPlotUnderImmediateThreat
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$5
	DD	04H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$6
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$7
	DD	06H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$8
	DD	07H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$9
	DD	08H
	DD	FLAT:__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$10
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
$T270818 = -180						; size = 4
$T270784 = -180						; size = 4
$T270667 = -180						; size = 4
$T270511 = -176						; size = 4
_it$ = -172						; size = 4
_strLog$227359 = -168					; size = 28
_strLog$227345 = -168					; size = 28
_strTemp$227360 = -140					; size = 28
_strTemp$227346 = -140					; size = 28
_strPlayerName$227361 = -112				; size = 28
_strPlayerName$227347 = -112				; size = 28
$T270507 = -84						; size = 8
_pUnit$227333 = -76					; size = 8
_strFileName$227356 = -68				; size = 28
_strFileName$227342 = -68				; size = 28
_strLogString$ = -40					; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteWorkerMoves, COMDAT
; _this$ = ecx

; 2764 : {

	push	-1
	push	__ehhandler$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 168				; 000000a8H
	push	esi
	push	edi
	mov	edi, ecx
	xor	esi, esi

; 2765 : 	CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$[esp+188]
	mov	DWORD PTR $T270511[esp+188], esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2766 : 
; 2767 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 2768 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [edi+20]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+196], esi
	mov	DWORD PTR _it$[esp+188], eax
	cmp	eax, ecx
	je	$LN9@ExecuteWor@3
	push	ebx
	push	ebp
$LL215@ExecuteWor@3:

; 2769 : 	{
; 2770 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$227333[esp+196], esi
	mov	BYTE PTR _pUnit$227333[esp+200], 0
	test	esi, esi
	je	SHORT $LN41@ExecuteWor@3
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@ExecuteWor@3:
	mov	BYTE PTR __$EHRec$[esp+204], 1

; 2771 : 		if(pUnit)

	test	esi, esi
	je	$LN214@ExecuteWor@3

; 2772 : 		{
; 2773 : 			CvPlot* pPlot = pUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ebp, eax

; 2774 : 
; 2775 : 			AI_PERF_FORMAT("Homeland-ExecuteWorkerMoves-perf.csv", ("ExecuteWorkerMoves, Turn %03d, %s, Unit %d, at x=%d, y=%d", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription(), pUnit->GetID(), pUnit->getX(), pUnit->getY()) );
; 2776 : 
; 2777 : 			if(pPlot && m_pPlayer->IsPlotUnderImmediateThreat(*pPlot) && !pPlot->getBestDefender(m_pPlayer->GetID()))

	test	ebp, ebp
	je	SHORT $LN211@ExecuteWor@3
	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?IsPlotUnderImmediateThreat@CvPlayer@@QBE_NAAVCvPlot@@@Z ; CvPlayer::IsPlotUnderImmediateThreat
	test	al, al
	je	SHORT $LN211@ExecuteWor@3
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+44]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	eax
	lea	eax, DWORD PTR $T270507[esp+224]
	push	eax
	mov	ecx, ebp
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	or	DWORD PTR $T270511[esp+196], 1
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN211@ExecuteWor@3
	mov	bl, 1
	jmp	SHORT $LN15@ExecuteWor@3
$LN211@ExecuteWor@3:
	xor	bl, bl
$LN15@ExecuteWor@3:
	test	BYTE PTR $T270511[esp+196], 1
	je	SHORT $LN213@ExecuteWor@3
	mov	ecx, DWORD PTR $T270507[esp+196]
	and	DWORD PTR $T270511[esp+196], -2		; fffffffeH
	test	ecx, ecx
	je	SHORT $LN213@ExecuteWor@3
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN213@ExecuteWor@3:
	test	bl, bl
	je	$LN216@ExecuteWor@3

; 2778 : 			{
; 2779 : 				if(MoveCivilianToSafety(pUnit.pointer()))

	push	0
	push	esi
	mov	ecx, edi
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
	test	al, al
	je	$LN216@ExecuteWor@3

; 2780 : 				{
; 2781 : 					if(GC.getLogging() && GC.GetBuilderAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN5@ExecuteWor@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuilderAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::GetBuilderAILogging
	test	al, al
	je	$LN5@ExecuteWor@3

; 2782 : 					{
; 2783 : 						// Open the log file
; 2784 : 						CvString strFileName = "BuilderTaskingLog.csv";

	push	OFFSET $SG227343
	lea	ecx, DWORD PTR _strFileName$227342[esp+200]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+204], 2

; 2785 : 						FILogFile* pLog;
; 2786 : 						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strFileName$227342[esp+196]
	mov	ebp, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [ebp]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, ebp
	call	eax

; 2787 : 
; 2788 : 						// write in data
; 2789 : 						CvString strLog;

	lea	ecx, DWORD PTR _strLog$227345[esp+196]
	mov	ebp, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2790 : 						CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227346[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2791 : 
; 2792 : 						CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$227347[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2793 : 						strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	BYTE PTR __$EHRec$[esp+204], 5
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$227347[esp+196]
	test	eax, eax
	je	SHORT $LN77@ExecuteWor@3
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN76@ExecuteWor@3
$LN77@ExecuteWor@3:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN76@ExecuteWor@3:

; 2794 : 						strLog += strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$227347[esp+196]
	push	ecx
	lea	ecx, DWORD PTR _strLog$227345[esp+200]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2795 : 						strLog += ",";

	push	OFFSET $SG227348
	lea	ecx, DWORD PTR _strLog$227345[esp+200]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2796 : 
; 2797 : 						strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	lea	edx, DWORD PTR _strTemp$227346[esp+200]
	push	OFFSET $SG227349
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 2798 : 						strLog += strTemp;

	lea	eax, DWORD PTR _strTemp$227346[esp+196]
	push	eax
	lea	ecx, DWORD PTR _strLog$227345[esp+200]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2799 : 
; 2800 : 						strTemp.Format("%d,", pUnit->GetID()); // unit id

	mov	eax, DWORD PTR [esi+100]
	push	eax
	lea	ecx, DWORD PTR _strTemp$227346[esp+200]
	push	OFFSET $SG227350
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 2801 : 						strLog += strTemp;

	lea	edx, DWORD PTR _strTemp$227346[esp+196]
	push	edx
	lea	ecx, DWORD PTR _strLog$227345[esp+200]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2802 : 
; 2803 : 						strLog += "1st Safety,";

	push	OFFSET $SG227351
	lea	ecx, DWORD PTR _strLog$227345[esp+200]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2804 : 
; 2805 : 						pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$227345[esp+196]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	ebp
	call	edx
	add	esp, 8

; 2806 : 					}

	lea	ecx, DWORD PTR _strPlayerName$227347[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$227346[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLog$227345[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strFileName$227342[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@ExecuteWor@3:

; 2807 : 
; 2808 : 					pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 2809 : 					UnitProcessed(pUnit->GetID());

	mov	ebp, DWORD PTR [esi+100]
	lea	eax, DWORD PTR $T270667[esp+196]
	push	eax
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T270667[esp+200], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN111@ExecuteWor@3
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN111@ExecuteWor@3:

; 2810 : 					continue;

	mov	BYTE PTR __$EHRec$[esp+204], 0
	jmp	$LN218@ExecuteWor@3
$LN216@ExecuteWor@3:

; 2811 : 				}
; 2812 : 			}
; 2813 : 
; 2814 : 			bool bActionPerformed = ExecuteWorkerMove(pUnit.pointer());

	push	esi
	mov	ecx, edi
	call	?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteWorkerMove

; 2815 : 			if(bActionPerformed)

	test	al, al
	je	SHORT $LN4@ExecuteWor@3

; 2816 : 			{
; 2817 : 				continue;

	mov	BYTE PTR __$EHRec$[esp+204], 0
	jmp	$LN218@ExecuteWor@3
$LN4@ExecuteWor@3:

; 2818 : 			}
; 2819 : 
; 2820 : 			// if there's nothing else to do, move to the safest spot nearby
; 2821 : 			if(MoveCivilianToSafety(pUnit.pointer(), true /*bIgnoreUnits*/))

	push	1
	push	esi
	mov	ecx, edi
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
	test	al, al
	je	$LN3@ExecuteWor@3

; 2822 : 			{
; 2823 : 				if(GC.getLogging() && GC.GetBuilderAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN2@ExecuteWor@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuilderAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::GetBuilderAILogging
	test	al, al
	je	$LN2@ExecuteWor@3

; 2824 : 				{
; 2825 : 					// Open the log file
; 2826 : 					CvString strFileName = "BuilderTaskingLog.csv";

	push	OFFSET $SG227357
	lea	ecx, DWORD PTR _strFileName$227356[esp+200]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+204], 6

; 2827 : 					FILogFile* pLog;
; 2828 : 					pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strFileName$227356[esp+196]
	mov	ebp, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [ebp]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, ebp
	call	eax

; 2829 : 
; 2830 : 					// write in data
; 2831 : 					CvString strLog;

	lea	ecx, DWORD PTR _strLog$227359[esp+196]
	mov	ebp, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2832 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$227360[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 7
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2833 : 
; 2834 : 					CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$227361[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 8
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2835 : 					strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [edi]
	mov	BYTE PTR __$EHRec$[esp+204], 9
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$227361[esp+196]
	test	eax, eax
	je	SHORT $LN144@ExecuteWor@3
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN143@ExecuteWor@3
$LN144@ExecuteWor@3:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN143@ExecuteWor@3:

; 2836 : 					strLog += strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$227361[esp+196]
	push	ecx
	lea	ecx, DWORD PTR _strLog$227359[esp+200]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2837 : 					strLog += ",";

	push	OFFSET $SG227362
	lea	ecx, DWORD PTR _strLog$227359[esp+200]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2838 : 
; 2839 : 					strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	lea	edx, DWORD PTR _strTemp$227360[esp+200]
	push	OFFSET $SG227363
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 2840 : 					strLog += strTemp;

	lea	eax, DWORD PTR _strTemp$227360[esp+196]
	push	eax
	lea	ecx, DWORD PTR _strLog$227359[esp+200]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2841 : 
; 2842 : 					strTemp.Format("%d,", pUnit->GetID()); // unit id

	mov	eax, DWORD PTR [esi+100]
	push	eax
	lea	ecx, DWORD PTR _strTemp$227360[esp+200]
	push	OFFSET $SG227364
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 2843 : 					strLog += strTemp;

	lea	edx, DWORD PTR _strTemp$227360[esp+196]
	push	edx
	lea	ecx, DWORD PTR _strLog$227359[esp+200]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2844 : 
; 2845 : 					strLog += "2nd Safety,";

	push	OFFSET $SG227365
	lea	ecx, DWORD PTR _strLog$227359[esp+200]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2846 : 
; 2847 : 					pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$227359[esp+196]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	ebp
	call	edx
	add	esp, 8

; 2848 : 				}

	lea	ecx, DWORD PTR _strPlayerName$227361[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$227360[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLog$227359[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strFileName$227356[esp+196]
	mov	BYTE PTR __$EHRec$[esp+204], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ExecuteWor@3:

; 2849 : 
; 2850 : 				// slewis - this was removed because a unit would eat all its moves. So if it didn't do anything this turn, it wouldn't be able to work 
; 2851 : 				pUnit->PushMission(CvTypes::getMISSION_SKIP());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2852 : 				if (!m_pPlayer->isHuman())

	mov	ecx, DWORD PTR [edi]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	SHORT $LN1@ExecuteWor@3

; 2853 : 				{
; 2854 : 					pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN1@ExecuteWor@3:

; 2855 : 				}
; 2856 : 				UnitProcessed(pUnit->GetID());

	mov	ebp, DWORD PTR [esi+100]
	lea	eax, DWORD PTR $T270784[esp+196]
	push	eax
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T270784[esp+200], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	$LN111@ExecuteWor@3
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed

; 2857 : 				continue;

	mov	BYTE PTR __$EHRec$[esp+204], 0
	jmp	SHORT $LN218@ExecuteWor@3
$LN3@ExecuteWor@3:

; 2858 : 			}
; 2859 : 
; 2860 : 			pUnit->PushMission(CvTypes::getMISSION_SKIP());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_SKIP@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SKIP
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 2861 : 			pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 2862 : 			UnitProcessed(pUnit->GetID());

	mov	ebp, DWORD PTR [esi+100]
	lea	ecx, DWORD PTR $T270818[esp+196]
	push	ecx
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T270818[esp+200], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN214@ExecuteWor@3
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN214@ExecuteWor@3:

; 2863 : 		}
; 2864 : 	}

	mov	BYTE PTR __$EHRec$[esp+204], 0
	test	esi, esi
	je	SHORT $LN10@ExecuteWor@3
$LN218@ExecuteWor@3:
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN10@ExecuteWor@3:
	mov	edx, DWORD PTR [edi+20]
	mov	eax, DWORD PTR _it$[esp+196]
	shl	edx, 4
	add	edx, DWORD PTR [edi+16]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _it$[esp+196], eax
	cmp	eax, edx
	jne	$LL215@ExecuteWor@3
	pop	ebp
	pop	ebx
$LN9@ExecuteWor@3:

; 2865 : }

	lea	ecx, DWORD PTR _strLogString$[esp+188]
	mov	DWORD PTR __$EHRec$[esp+196], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+188]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 180				; 000000b4H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pUnit$227333[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strFileName$227342[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLog$227345[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strTemp$227346[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strPlayerName$227347[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strFileName$227356[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR _strLog$227359[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$9:
	lea	ecx, DWORD PTR _strTemp$227360[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ$10:
	lea	ecx, DWORD PTR _strPlayerName$227361[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteWorkerMoves
PUBLIC	?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteWriterMoves
EXTRN	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_GREAT_WORK
EXTRN	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z:PROC ; CvEconomicAI::GetBestGreatWorkCity
EXTRN	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ:PROC ; CvUnit::GetGreatWork
EXTRN	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ:PROC ; CvUnit::GetGreatPeopleDirective
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$7
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_iI$227525 = -96					; size = 4
$T270851 = -96						; size = 4
_iBestTurns$227521 = -92				; size = 4
_it$ = -88						; size = 4
$T271156 = -84						; size = 4
$T271090 = -84						; size = 4
_pTargetCity$227509 = -84				; size = 4
$T270852 = -80						; size = 4
_pUnit$227499 = -76					; size = 8
_strLogString$227541 = -68				; size = 28
_strLogString$227537 = -68				; size = 28
_strLogString$227517 = -68				; size = 28
_strLogString$227512 = -68				; size = 28
_strLogString$227545 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteWriterMoves, COMDAT
; _this$ = ecx

; 3206 : {

	push	-1
	push	__ehhandler$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 3207 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3208 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [edi+20]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _it$[esp+112], eax
	cmp	eax, ecx
	je	$LN26@ExecuteWri
$LL28@ExecuteWri:

; 3209 : 	{
; 3210 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$227499[esp+112], esi
	mov	BYTE PTR _pUnit$227499[esp+116], 0
	test	esi, esi
	je	SHORT $LN48@ExecuteWri
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN48@ExecuteWri:
	mov	DWORD PTR __$EHRec$[esp+120], 0

; 3211 : 		if(!pUnit)

	test	esi, esi
	jne	SHORT $LN25@ExecuteWri

; 3212 : 		{
; 3213 : 			continue;

	mov	DWORD PTR __$EHRec$[esp+120], -1
	jmp	$LN27@ExecuteWri
$LN25@ExecuteWri:

; 3214 : 		}
; 3215 : 
; 3216 : 		GreatPeopleDirectiveTypes eDirective = pUnit->GetGreatPeopleDirective();

	mov	ecx, esi
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective

; 3217 : 		switch(eDirective)

	cmp	eax, -1
	je	$LN1@ExecuteWri
	cmp	eax, 1
	je	SHORT $LN21@ExecuteWri
	cmp	eax, 4
	jne	$LN23@ExecuteWri

; 3218 : 		{
; 3219 : 		case GREAT_PEOPLE_DIRECTIVE_CULTURE_BLAST:
; 3220 : 			ExecuteCultureBlast(pUnit.pointer());

	push	esi
	mov	ecx, edi
	call	?ExecuteCultureBlast@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteCultureBlast

; 3221 : 			break;

	jmp	$LN23@ExecuteWri
$LN21@ExecuteWri:

; 3222 : 
; 3223 : 		case GREAT_PEOPLE_DIRECTIVE_USE_POWER:
; 3224 : 			{
; 3225 : 				// Do we want to create a Great Work?
; 3226 : 				GreatWorkType eGreatWorkType = pUnit->GetGreatWork();

	mov	ecx, esi
	call	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ ; CvUnit::GetGreatWork

; 3227 : 				CvCity* pTargetCity = m_pPlayer->GetEconomicAI()->GetBestGreatWorkCity(pUnit->plot(), eGreatWorkType);

	push	eax
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ; CvEconomicAI::GetBestGreatWorkCity
	mov	ebx, eax
	mov	DWORD PTR _pTargetCity$227509[esp+112], ebx

; 3228 : 
; 3229 : 				// No?  Just move to safety...
; 3230 : 				if (pTargetCity == NULL)

	test	ebx, ebx
	jne	$LN20@ExecuteWri

; 3231 : 				{
; 3232 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@ExecuteWri
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@ExecuteWri

; 3233 : 					{
; 3234 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227512[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3235 : 						strLogString.Format("Great writer can't find a Great Work slot. Running to safety");

	lea	edx, DWORD PTR _strLogString$227512[esp+112]
	push	OFFSET $SG227513
	push	edx
	mov	BYTE PTR __$EHRec$[esp+128], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3236 : 						LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227512[esp+112]
	push	eax
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3237 : 					}

	lea	ecx, DWORD PTR _strLogString$227512[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteWri:

; 3327 : 
; 3328 : 		case NO_GREAT_PEOPLE_DIRECTIVE_TYPE:
; 3329 : 			MoveCivilianToSafety(pUnit.pointer());

	push	0
	push	esi
	mov	ecx, edi
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN23@ExecuteWri:

; 3330 : 			break;
; 3331 : 		}
; 3332 : 	}

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN27@ExecuteWri:
	mov	ecx, DWORD PTR [edi+20]
	mov	eax, DWORD PTR _it$[esp+112]
	shl	ecx, 4
	add	ecx, DWORD PTR [edi+16]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _it$[esp+112], eax
	cmp	eax, ecx
	jne	$LL28@ExecuteWri
$LN26@ExecuteWri:

; 3333 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 96					; 00000060H
	ret	0
$LN20@ExecuteWri:

; 3238 : 
; 3239 : 					MoveCivilianToSafety(pUnit.pointer());
; 3240 : 				}
; 3241 : 				else
; 3242 : 				{
; 3243 : 					// Already at (or adjacent to) target?
; 3244 : 					if (plotDistance(pUnit->getX(), pUnit->getY(), pTargetCity->getX(), pTargetCity->getY()) <= 1)

	mov	eax, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+96]
	mov	edx, DWORD PTR [esi+88]
	mov	ebp, DWORD PTR [esi+76]
	push	eax
	push	ecx
	push	edx
	push	ebp
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1

; 3245 : 					{
; 3246 : 						pUnit->PushMission(CvTypes::getMISSION_GREAT_WORK());

	push	0
	push	0
	jg	SHORT $LN17@ExecuteWri
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GREAT_WORK
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3247 : 						UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR [esi+100]
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3248 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN23@ExecuteWri
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN23@ExecuteWri

; 3249 : 						{
; 3250 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227517[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3251 : 							strLogString.Format("Creating Great Work at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strLogString$227517[esp+120]
	push	OFFSET $SG227518
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+136], 2
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3252 : 							LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227517[esp+112]
	push	edx

; 3253 : 							continue;

	jmp	$LN238@ExecuteWri
$LN17@ExecuteWri:

; 3254 : 						}
; 3255 : 					}
; 3256 : 
; 3257 : 					// No, then move there
; 3258 : 					else
; 3259 : 					{
; 3260 : 						// Find which plot (in or adjacent), we can reach in the fewest turns
; 3261 : 						CvPlot *pBestTarget = NULL;

	xor	ebp, ebp

; 3262 : 						int iBestTurns = MAX_INT;
; 3263 : 						int iTurns;
; 3264 : 						iTurns = TurnsToReachTarget(pUnit, pTargetCity->plot());

	push	ebp
	mov	ecx, ebx
	mov	DWORD PTR _iBestTurns$227521[esp+124], 2147483647 ; 7fffffffH
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T270851[esp+136], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 3265 : 						if (iTurns < iBestTurns)

	cmp	eax, 2147483647				; 7fffffffH
	jge	SHORT $LN14@ExecuteWri

; 3266 : 						{
; 3267 : 							pBestTarget = pTargetCity->plot();

	mov	ecx, ebx
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ebp, eax
$LN14@ExecuteWri:

; 3268 : 						}
; 3269 : 						for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$227525[esp+112], 0
	jmp	SHORT $LN13@ExecuteWri
	npad	5
$LL234@ExecuteWri:
	mov	ebx, DWORD PTR _pTargetCity$227509[esp+112]
$LN13@ExecuteWri:

; 3270 : 						{
; 3271 : 							CvPlot* pAdjacentPlot = plotDirection(pTargetCity->getX(), pTargetCity->getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _iI$227525[esp+112]
	mov	eax, DWORD PTR [ebx+108]
	mov	ebx, DWORD PTR [ebx+96]
	push	ecx
	push	eax
	push	ebx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 3272 : 							if(pAdjacentPlot != NULL)

	test	ebx, ebx
	je	SHORT $LN12@ExecuteWri

; 3273 : 							{
; 3274 : 								iTurns = TurnsToReachTarget(pUnit, pAdjacentPlot);

	push	0
	push	0
	push	0
	push	ebx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T270852[esp+136], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 3275 : 								if (iTurns < iBestTurns)

	cmp	eax, DWORD PTR _iBestTurns$227521[esp+112]
	jge	SHORT $LN12@ExecuteWri

; 3276 : 								{
; 3277 : 									pBestTarget = pAdjacentPlot;

	mov	ebp, ebx

; 3278 : 									iBestTurns = iTurns;

	mov	DWORD PTR _iBestTurns$227521[esp+112], eax
$LN12@ExecuteWri:
	mov	eax, DWORD PTR _iI$227525[esp+112]
	inc	eax
	cmp	eax, 6
	mov	DWORD PTR _iI$227525[esp+112], eax
	jl	SHORT $LL234@ExecuteWri

; 3279 : 								}
; 3280 : 							}
; 3281 : 						}
; 3282 : 
; 3283 : 						if (pBestTarget)

	test	ebp, ebp
	je	$LN8@ExecuteWri

; 3284 : 						{
; 3285 : 							// In less than one turn?
; 3286 : 							if (iBestTurns == 0)
; 3287 : 							{
; 3288 : 								pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestTarget->getX(), pBestTarget->getY());

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission
	cmp	DWORD PTR _iBestTurns$227521[esp+112], 0
	jne	$LN7@ExecuteWri

; 3289 : 								pUnit->PushMission(CvTypes::getMISSION_GREAT_WORK());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GREAT_WORK
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3290 : 								UnitProcessed(pUnit->GetID());

	mov	ebx, DWORD PTR [esi+100]
	lea	edx, DWORD PTR $T271090[esp+112]
	push	edx
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T271090[esp+116], ebx
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN157@ExecuteWri
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN157@ExecuteWri:

; 3291 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN23@ExecuteWri
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN23@ExecuteWri

; 3292 : 								{
; 3293 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227537[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3294 : 									strLogString.Format("Moving and creating Great Work at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+128], 3
	push	OFFSET $SG227538

; 3295 : 									LogHomelandMessage(strLogString);
; 3296 : 									continue;

	jmp	SHORT $LN239@ExecuteWri
$LN7@ExecuteWri:

; 3297 : 								}
; 3298 : 							}
; 3299 : 
; 3300 : 							// In multiple moves
; 3301 : 							else
; 3302 : 							{
; 3303 : 								pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestTarget->getX(), pBestTarget->getY());
; 3304 : 								pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3305 : 								UnitProcessed(it->GetID());

	mov	edx, DWORD PTR _it$[esp+112]
	mov	ebx, DWORD PTR [edx]
	lea	eax, DWORD PTR $T271156[esp+112]
	push	eax
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T271156[esp+116], ebx
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN193@ExecuteWri
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN193@ExecuteWri:

; 3306 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN23@ExecuteWri
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN23@ExecuteWri

; 3307 : 								{
; 3308 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227541[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3309 : 									strLogString.Format("Moving Great Writer toward Great Work city at, X: %d, Y: %d", pBestTarget->getX(),  pBestTarget->getY());

	movsx	ecx, WORD PTR [ebp+2]
	movsx	edx, WORD PTR [ebp]
	push	ecx
	push	edx
	mov	BYTE PTR __$EHRec$[esp+128], 4
	push	OFFSET $SG227542
$LN239@ExecuteWri:
	lea	eax, DWORD PTR _strLogString$227541[esp+124]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3310 : 									LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227541[esp+112]
	push	ecx
$LN238@ExecuteWri:
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3311 : 								}

	lea	ecx, DWORD PTR _strLogString$227541[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3312 : 							}
; 3313 : 						}
; 3314 : 						else

	jmp	$LN23@ExecuteWri
$LN8@ExecuteWri:

; 3315 : 						{
; 3316 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN23@ExecuteWri
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN23@ExecuteWri

; 3317 : 							{
; 3318 : 								CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227545[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3319 : 								strLogString.Format("Could not find a target for Great Writer at, X: %d, Y: %d", pUnit->getX(),  pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLogString$227545[esp+120]
	push	OFFSET $SG227546
	push	edx
	mov	BYTE PTR __$EHRec$[esp+136], 5
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3320 : 								LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227545[esp+112]
	push	eax
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3321 : 							}

	lea	ecx, DWORD PTR _strLogString$227545[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3322 : 						}
; 3323 : 					}
; 3324 : 				}
; 3325 : 			}	
; 3326 : 			break;

	jmp	$LN23@ExecuteWri
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227499[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227512[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$227517[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$227537[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strLogString$227541[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$227545[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteWriterMoves
PUBLIC	?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteArtistMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$7
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -96						; size = 4
_iI$227582 = -92					; size = 4
$T271233 = -92						; size = 4
_iBestTurns$227578 = -88				; size = 4
_it$ = -84						; size = 4
$T271234 = -80						; size = 4
_pUnit$227556 = -76					; size = 8
_strLogString$227598 = -68				; size = 28
_strLogString$227594 = -68				; size = 28
_strLogString$227574 = -68				; size = 28
_strLogString$227569 = -68				; size = 28
_strLogString$227602 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteArtistMoves, COMDAT
; _this$ = ecx

; 3337 : {

	push	-1
	push	__ehhandler$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 3338 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3339 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [edi+20]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _this$[esp+112], edi
	mov	DWORD PTR _it$[esp+112], eax
	cmp	eax, ecx
	je	$LN26@ExecuteArt
	npad	7
$LL28@ExecuteArt:

; 3340 : 	{
; 3341 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$227556[esp+112], esi
	mov	BYTE PTR _pUnit$227556[esp+116], 0
	test	esi, esi
	je	SHORT $LN48@ExecuteArt
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN48@ExecuteArt:
	mov	DWORD PTR __$EHRec$[esp+120], 0

; 3342 : 		if(!pUnit)

	test	esi, esi
	jne	SHORT $LN25@ExecuteArt

; 3343 : 		{
; 3344 : 			continue;

	mov	DWORD PTR __$EHRec$[esp+120], -1
	jmp	$LN27@ExecuteArt
$LN25@ExecuteArt:

; 3345 : 		}
; 3346 : 
; 3347 : 		GreatPeopleDirectiveTypes eDirective = pUnit->GetGreatPeopleDirective();

	mov	ecx, esi
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective

; 3348 : 		switch(eDirective)

	cmp	eax, -1
	je	$LN19@ExecuteArt
	test	eax, eax
	je	$LN22@ExecuteArt
	cmp	eax, 1
	jne	$LN23@ExecuteArt

; 3353 : 
; 3354 : 		case GREAT_PEOPLE_DIRECTIVE_USE_POWER:
; 3355 : 			{
; 3356 : 				// Do we want to create a Great Work?
; 3357 : 				GreatWorkType eGreatWorkType = pUnit->GetGreatWork();

	mov	ecx, esi
	call	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ ; CvUnit::GetGreatWork

; 3358 : 				CvCity* pTargetCity = m_pPlayer->GetEconomicAI()->GetBestGreatWorkCity(pUnit->plot(), eGreatWorkType);

	push	eax
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ; CvEconomicAI::GetBestGreatWorkCity
	mov	ebx, eax

; 3359 : 
; 3360 : 				// No?  Just move to safety...
; 3361 : 				if (pTargetCity == NULL)

	test	ebx, ebx
	jne	SHORT $LN20@ExecuteArt

; 3362 : 				{
; 3363 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN19@ExecuteArt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN19@ExecuteArt

; 3364 : 					{
; 3365 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227569[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3366 : 						strLogString.Format("Great artist can't find a Great Work slot. Running to safety");

	lea	edx, DWORD PTR _strLogString$227569[esp+112]
	push	OFFSET $SG227570
	push	edx
	mov	BYTE PTR __$EHRec$[esp+128], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3367 : 						LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227569[esp+112]
	push	eax
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3368 : 					}

	lea	ecx, DWORD PTR _strLogString$227569[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN19@ExecuteArt:

; 3369 : 
; 3370 : 					MoveCivilianToSafety(pUnit.pointer());

	push	0
	push	esi
	mov	ecx, edi
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety

; 3371 : 				}
; 3372 : 				else

	jmp	$LN23@ExecuteArt
$LN20@ExecuteArt:

; 3373 : 				{
; 3374 : 					// Already at (or adjacent to) target?
; 3375 : 					if (plotDistance(pUnit->getX(), pUnit->getY(), pTargetCity->getX(), pTargetCity->getY()) <= 1)

	mov	eax, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+96]
	mov	edx, DWORD PTR [esi+88]
	mov	ebp, DWORD PTR [esi+76]
	push	eax
	push	ecx
	push	edx
	push	ebp
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1

; 3376 : 					{
; 3377 : 						pUnit->PushMission(CvTypes::getMISSION_GREAT_WORK());

	push	0
	push	0
	jg	$LN17@ExecuteArt
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GREAT_WORK
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3378 : 						UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR [esi+100]
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3379 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN23@ExecuteArt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN23@ExecuteArt

; 3380 : 						{
; 3381 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227574[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3382 : 							strLogString.Format("Creating Great Work at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strLogString$227574[esp+120]
	push	OFFSET $SG227575
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+136], 2
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3383 : 							LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227574[esp+112]
	push	edx
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3384 : 							continue;

	lea	ecx, DWORD PTR _strLogString$227574[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN23@ExecuteArt
$LN17@ExecuteArt:

; 3385 : 						}
; 3386 : 					}
; 3387 : 
; 3388 : 					// No, then move there
; 3389 : 					else
; 3390 : 					{
; 3391 : 						// Find which plot (in or adjacent), we can reach in the fewest turns
; 3392 : 						CvPlot *pBestTarget = NULL;

	xor	edi, edi

; 3393 : 						int iBestTurns = MAX_INT;
; 3394 : 						int iTurns;
; 3395 : 						iTurns = TurnsToReachTarget(pUnit, pTargetCity->plot());

	push	edi
	mov	ecx, ebx
	mov	DWORD PTR _iBestTurns$227578[esp+124], 2147483647 ; 7fffffffH
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T271233[esp+136], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 3396 : 						if (iTurns < iBestTurns)

	cmp	eax, 2147483647				; 7fffffffH
	jge	SHORT $LN14@ExecuteArt

; 3397 : 						{
; 3398 : 							pBestTarget = pTargetCity->plot();

	mov	ecx, ebx
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	edi, eax
$LN14@ExecuteArt:

; 3399 : 						}
; 3400 : 						for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$227582[esp+112], 0
$LN13@ExecuteArt:

; 3401 : 						{
; 3402 : 							CvPlot* pAdjacentPlot = plotDirection(pTargetCity->getX(), pTargetCity->getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _iI$227582[esp+112]
	mov	eax, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+96]
	push	edx
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	ebp, eax
	add	esp, 12					; 0000000cH

; 3403 : 							if(pAdjacentPlot != NULL)

	test	ebp, ebp
	je	SHORT $LN12@ExecuteArt

; 3404 : 							{
; 3405 : 								iTurns = TurnsToReachTarget(pUnit, pAdjacentPlot);

	push	0
	push	0
	push	0
	push	ebp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T271234[esp+136], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 3406 : 								if (iTurns < iBestTurns)

	cmp	eax, DWORD PTR _iBestTurns$227578[esp+112]
	jge	SHORT $LN12@ExecuteArt

; 3407 : 								{
; 3408 : 									pBestTarget = pAdjacentPlot;

	mov	edi, ebp

; 3409 : 									iBestTurns = iTurns;

	mov	DWORD PTR _iBestTurns$227578[esp+112], eax
$LN12@ExecuteArt:
	mov	eax, DWORD PTR _iI$227582[esp+112]
	inc	eax
	cmp	eax, 6
	mov	DWORD PTR _iI$227582[esp+112], eax
	jl	SHORT $LN13@ExecuteArt

; 3410 : 								}
; 3411 : 							}
; 3412 : 						}
; 3413 : 
; 3414 : 						if (pBestTarget)

	test	edi, edi
	je	$LN8@ExecuteArt

; 3415 : 						{
; 3416 : 							// In less than one turn?
; 3417 : 							if (iBestTurns == 0)
; 3418 : 							{
; 3419 : 								pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestTarget->getX(), pBestTarget->getY());

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission
	cmp	DWORD PTR _iBestTurns$227578[esp+112], 0
	jne	$LN7@ExecuteArt

; 3420 : 								pUnit->PushMission(CvTypes::getMISSION_GREAT_WORK());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GREAT_WORK
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3421 : 								UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR [esi+100]
	mov	ecx, DWORD PTR _this$[esp+112]
	push	eax
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3422 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN229@ExecuteArt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN229@ExecuteArt

; 3423 : 								{
; 3424 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227594[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3425 : 									strLogString.Format("Moving and creating Great Work at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	eax, DWORD PTR _strLogString$227594[esp+120]
	push	OFFSET $SG227595
	push	eax
	mov	BYTE PTR __$EHRec$[esp+136], 3
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3426 : 									LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227594[esp+112]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+116]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3427 : 									continue;

	lea	ecx, DWORD PTR _strLogString$227594[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	edi, DWORD PTR _this$[esp+112]
	jmp	$LN27@ExecuteArt
$LN7@ExecuteArt:

; 3428 : 								}
; 3429 : 							}
; 3430 : 
; 3431 : 							// In multiple moves
; 3432 : 							else
; 3433 : 							{
; 3434 : 								pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestTarget->getX(), pBestTarget->getY());
; 3435 : 								pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3436 : 								UnitProcessed(it->GetID());

	mov	edx, DWORD PTR _it$[esp+112]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[esp+112]
	push	eax
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3437 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN229@ExecuteArt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN229@ExecuteArt

; 3438 : 								{
; 3439 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227598[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3440 : 									strLogString.Format("Moving Great Artist toward Great Work city at, X: %d, Y: %d", pBestTarget->getX(),  pBestTarget->getY());

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLogString$227598[esp+120]
	push	OFFSET $SG227599
	push	edx
	mov	BYTE PTR __$EHRec$[esp+136], 4
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 3441 : 									LogHomelandMessage(strLogString);

	mov	ecx, DWORD PTR _this$[esp+128]
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR _strLogString$227598[esp+112]
	push	eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3442 : 								}

	mov	BYTE PTR __$EHRec$[esp+120], 0
	lea	ecx, DWORD PTR _strLogString$227598[esp+112]
$LN232@ExecuteArt:

; 3452 : 							}

	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN229@ExecuteArt:

; 3453 : 						}
; 3454 : 					}
; 3455 : 				}
; 3456 : 			}	
; 3457 : 			break;

	mov	edi, DWORD PTR _this$[esp+112]
$LN23@ExecuteArt:

; 3458 : 
; 3459 : 		case NO_GREAT_PEOPLE_DIRECTIVE_TYPE:
; 3460 : 			MoveCivilianToSafety(pUnit.pointer());
; 3461 : 			break;
; 3462 : 		}
; 3463 : 	}

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN27@ExecuteArt:
	mov	ecx, DWORD PTR [edi+20]
	mov	eax, DWORD PTR _it$[esp+112]
	shl	ecx, 4
	add	ecx, DWORD PTR [edi+16]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _it$[esp+112], eax
	cmp	eax, ecx
	jne	$LL28@ExecuteArt
$LN26@ExecuteArt:

; 3464 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 96					; 00000060H
	ret	0
$LN8@ExecuteArt:

; 3443 : 							}
; 3444 : 						}
; 3445 : 						else
; 3446 : 						{
; 3447 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN229@ExecuteArt
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN229@ExecuteArt

; 3448 : 							{
; 3449 : 								CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227602[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3450 : 								strLogString.Format("Could not find a target for Great Artist at, X: %d, Y: %d", pUnit->getX(),  pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strLogString$227602[esp+120]
	push	OFFSET $SG227603
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+136], 5
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 3451 : 								LogHomelandMessage(strLogString);

	mov	ecx, DWORD PTR _this$[esp+128]
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR _strLogString$227602[esp+112]
	push	edx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3452 : 							}

	mov	BYTE PTR __$EHRec$[esp+120], 0
	lea	ecx, DWORD PTR _strLogString$227602[esp+112]

; 3453 : 						}
; 3454 : 					}
; 3455 : 				}
; 3456 : 			}	
; 3457 : 			break;

	jmp	$LN232@ExecuteArt
$LN22@ExecuteArt:

; 3349 : 		{
; 3350 : 		case GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE:
; 3351 : 			ExecuteGoldenAgeMove(pUnit.pointer());

	push	esi
	mov	ecx, edi
	call	?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteGoldenAgeMove

; 3352 : 			break;

	jmp	$LN23@ExecuteArt
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227556[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227569[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$227574[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$227594[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strLogString$227598[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$227602[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteArtistMoves
PUBLIC	?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteMusicianMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$7
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_iI$227639 = -96					; size = 4
$T271602 = -96						; size = 4
_iBestTurns$227635 = -92				; size = 4
_it$ = -88						; size = 4
$T271904 = -84						; size = 4
$T271838 = -84						; size = 4
_pTargetCity$227623 = -84				; size = 4
$T271603 = -80						; size = 4
_pUnit$227613 = -76					; size = 8
_strLogString$227655 = -68				; size = 28
_strLogString$227651 = -68				; size = 28
_strLogString$227631 = -68				; size = 28
_strLogString$227626 = -68				; size = 28
_strLogString$227659 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteMusicianMoves, COMDAT
; _this$ = ecx

; 3468 : {

	push	-1
	push	__ehhandler$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 3469 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3470 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [edi+20]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _it$[esp+112], eax
	cmp	eax, ecx
	je	$LN26@ExecuteMus
$LL28@ExecuteMus:

; 3471 : 	{
; 3472 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$227613[esp+112], esi
	mov	BYTE PTR _pUnit$227613[esp+116], 0
	test	esi, esi
	je	SHORT $LN48@ExecuteMus
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN48@ExecuteMus:
	mov	DWORD PTR __$EHRec$[esp+120], 0

; 3473 : 		if(!pUnit)

	test	esi, esi
	jne	SHORT $LN25@ExecuteMus

; 3474 : 		{
; 3475 : 			continue;

	mov	DWORD PTR __$EHRec$[esp+120], -1
	jmp	$LN27@ExecuteMus
$LN25@ExecuteMus:

; 3476 : 		}
; 3477 : 
; 3478 : 		GreatPeopleDirectiveTypes eDirective = pUnit->GetGreatPeopleDirective();

	mov	ecx, esi
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective

; 3479 : 		switch(eDirective)

	cmp	eax, -1
	je	$LN1@ExecuteMus
	cmp	eax, 1
	jne	$LN23@ExecuteMus

; 3480 : 		{
; 3481 : 		case GREAT_PEOPLE_DIRECTIVE_TOURISM_BLAST:
; 3482 : 			break;
; 3483 : 
; 3484 : 		case GREAT_PEOPLE_DIRECTIVE_USE_POWER:
; 3485 : 			{
; 3486 : 				// Do we want to create a Great Work?
; 3487 : 				GreatWorkType eGreatWorkType = pUnit->GetGreatWork();

	mov	ecx, esi
	call	?GetGreatWork@CvUnit@@QBE?AW4GreatWorkType@@XZ ; CvUnit::GetGreatWork

; 3488 : 				CvCity* pTargetCity = m_pPlayer->GetEconomicAI()->GetBestGreatWorkCity(pUnit->plot(), eGreatWorkType);

	push	eax
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ; CvEconomicAI::GetBestGreatWorkCity
	mov	ebx, eax
	mov	DWORD PTR _pTargetCity$227623[esp+112], ebx

; 3489 : 
; 3490 : 				// No?  Just move to safety...
; 3491 : 				if (pTargetCity == NULL)

	test	ebx, ebx
	jne	$LN20@ExecuteMus

; 3492 : 				{
; 3493 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@ExecuteMus
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@ExecuteMus

; 3494 : 					{
; 3495 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227626[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3496 : 						strLogString.Format("Great musician can't find a Great Work slot. Running to safety");

	lea	edx, DWORD PTR _strLogString$227626[esp+112]
	push	OFFSET $SG227627
	push	edx
	mov	BYTE PTR __$EHRec$[esp+128], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3497 : 						LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227626[esp+112]
	push	eax
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3498 : 					}

	lea	ecx, DWORD PTR _strLogString$227626[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteMus:

; 3588 : 
; 3589 : 		case NO_GREAT_PEOPLE_DIRECTIVE_TYPE:
; 3590 : 			MoveCivilianToSafety(pUnit.pointer());

	push	0
	push	esi
	mov	ecx, edi
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN23@ExecuteMus:

; 3591 : 			break;
; 3592 : 		}
; 3593 : 	}

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+120], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN27@ExecuteMus:
	mov	ecx, DWORD PTR [edi+20]
	mov	eax, DWORD PTR _it$[esp+112]
	shl	ecx, 4
	add	ecx, DWORD PTR [edi+16]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _it$[esp+112], eax
	cmp	eax, ecx
	jne	$LL28@ExecuteMus
$LN26@ExecuteMus:

; 3594 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 96					; 00000060H
	ret	0
$LN20@ExecuteMus:

; 3499 : 
; 3500 : 					MoveCivilianToSafety(pUnit.pointer());
; 3501 : 				}
; 3502 : 				else
; 3503 : 				{
; 3504 : 					// Already at (or adjacent to) target?
; 3505 : 					if (plotDistance(pUnit->getX(), pUnit->getY(), pTargetCity->getX(), pTargetCity->getY()) <= 1)

	mov	eax, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+96]
	mov	edx, DWORD PTR [esi+88]
	mov	ebp, DWORD PTR [esi+76]
	push	eax
	push	ecx
	push	edx
	push	ebp
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1

; 3506 : 					{
; 3507 : 						pUnit->PushMission(CvTypes::getMISSION_GREAT_WORK());

	push	0
	push	0
	jg	SHORT $LN17@ExecuteMus
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GREAT_WORK
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3508 : 						UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR [esi+100]
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3509 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN23@ExecuteMus
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN23@ExecuteMus

; 3510 : 						{
; 3511 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227631[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3512 : 							strLogString.Format("Creating Great Work at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strLogString$227631[esp+120]
	push	OFFSET $SG227632
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+136], 2
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3513 : 							LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227631[esp+112]
	push	edx

; 3514 : 							continue;

	jmp	$LN236@ExecuteMus
$LN17@ExecuteMus:

; 3515 : 						}
; 3516 : 					}
; 3517 : 
; 3518 : 					// No, then move there
; 3519 : 					else
; 3520 : 					{
; 3521 : 						// Find which plot (in or adjacent), we can reach in the fewest turns
; 3522 : 						CvPlot *pBestTarget = NULL;

	xor	ebp, ebp

; 3523 : 						int iBestTurns = MAX_INT;
; 3524 : 						int iTurns;
; 3525 : 						iTurns = TurnsToReachTarget(pUnit, pTargetCity->plot());

	push	ebp
	mov	ecx, ebx
	mov	DWORD PTR _iBestTurns$227635[esp+124], 2147483647 ; 7fffffffH
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T271602[esp+136], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 3526 : 						if (iTurns < iBestTurns)

	cmp	eax, 2147483647				; 7fffffffH
	jge	SHORT $LN14@ExecuteMus

; 3527 : 						{
; 3528 : 							pBestTarget = pTargetCity->plot();

	mov	ecx, ebx
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ebp, eax
$LN14@ExecuteMus:

; 3529 : 						}
; 3530 : 						for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$227639[esp+112], 0
	jmp	SHORT $LN13@ExecuteMus
	npad	7
$LL232@ExecuteMus:
	mov	ebx, DWORD PTR _pTargetCity$227623[esp+112]
$LN13@ExecuteMus:

; 3531 : 						{
; 3532 : 							CvPlot* pAdjacentPlot = plotDirection(pTargetCity->getX(), pTargetCity->getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _iI$227639[esp+112]
	mov	eax, DWORD PTR [ebx+108]
	mov	ebx, DWORD PTR [ebx+96]
	push	ecx
	push	eax
	push	ebx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 3533 : 							if(pAdjacentPlot != NULL)

	test	ebx, ebx
	je	SHORT $LN12@ExecuteMus

; 3534 : 							{
; 3535 : 								iTurns = TurnsToReachTarget(pUnit, pAdjacentPlot);

	push	0
	push	0
	push	0
	push	ebx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T271603[esp+136], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 3536 : 								if (iTurns < iBestTurns)

	cmp	eax, DWORD PTR _iBestTurns$227635[esp+112]
	jge	SHORT $LN12@ExecuteMus

; 3537 : 								{
; 3538 : 									pBestTarget = pAdjacentPlot;

	mov	ebp, ebx

; 3539 : 									iBestTurns = iTurns;

	mov	DWORD PTR _iBestTurns$227635[esp+112], eax
$LN12@ExecuteMus:
	mov	eax, DWORD PTR _iI$227639[esp+112]
	inc	eax
	cmp	eax, 6
	mov	DWORD PTR _iI$227639[esp+112], eax
	jl	SHORT $LL232@ExecuteMus

; 3540 : 								}
; 3541 : 							}
; 3542 : 						}
; 3543 : 
; 3544 : 						if (pBestTarget)

	test	ebp, ebp
	je	$LN8@ExecuteMus

; 3545 : 						{
; 3546 : 							// In less than one turn?
; 3547 : 							if (iBestTurns == 0)
; 3548 : 							{
; 3549 : 								pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestTarget->getX(), pBestTarget->getY());

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission
	cmp	DWORD PTR _iBestTurns$227635[esp+112], 0
	jne	$LN7@ExecuteMus

; 3550 : 								pUnit->PushMission(CvTypes::getMISSION_GREAT_WORK());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_GREAT_WORK@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_GREAT_WORK
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3551 : 								UnitProcessed(pUnit->GetID());

	mov	ebx, DWORD PTR [esi+100]
	lea	edx, DWORD PTR $T271838[esp+112]
	push	edx
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T271838[esp+116], ebx
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN155@ExecuteMus
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN155@ExecuteMus:

; 3552 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN23@ExecuteMus
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN23@ExecuteMus

; 3553 : 								{
; 3554 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227651[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3555 : 									strLogString.Format("Moving and creating Great Work at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+128], 3
	push	OFFSET $SG227652

; 3556 : 									LogHomelandMessage(strLogString);
; 3557 : 									continue;

	jmp	SHORT $LN237@ExecuteMus
$LN7@ExecuteMus:

; 3558 : 								}
; 3559 : 							}
; 3560 : 
; 3561 : 							// In multiple moves
; 3562 : 							else
; 3563 : 							{
; 3564 : 								pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestTarget->getX(), pBestTarget->getY());
; 3565 : 								pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3566 : 								UnitProcessed(it->GetID());

	mov	edx, DWORD PTR _it$[esp+112]
	mov	ebx, DWORD PTR [edx]
	lea	eax, DWORD PTR $T271904[esp+112]
	push	eax
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T271904[esp+116], ebx
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN191@ExecuteMus
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN191@ExecuteMus:

; 3567 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN23@ExecuteMus
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN23@ExecuteMus

; 3568 : 								{
; 3569 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227655[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3570 : 									strLogString.Format("Moving Great Musician toward Great Work city at, X: %d, Y: %d", pBestTarget->getX(),  pBestTarget->getY());

	movsx	ecx, WORD PTR [ebp+2]
	movsx	edx, WORD PTR [ebp]
	push	ecx
	push	edx
	mov	BYTE PTR __$EHRec$[esp+128], 4
	push	OFFSET $SG227656
$LN237@ExecuteMus:
	lea	eax, DWORD PTR _strLogString$227655[esp+124]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3571 : 									LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227655[esp+112]
	push	ecx
$LN236@ExecuteMus:
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3572 : 								}

	lea	ecx, DWORD PTR _strLogString$227655[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3573 : 							}
; 3574 : 						}
; 3575 : 						else

	jmp	$LN23@ExecuteMus
$LN8@ExecuteMus:

; 3576 : 						{
; 3577 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN23@ExecuteMus
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN23@ExecuteMus

; 3578 : 							{
; 3579 : 								CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227659[esp+112]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3580 : 								strLogString.Format("Could not find a target for Great Musician at, X: %d, Y: %d", pUnit->getX(),  pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLogString$227659[esp+120]
	push	OFFSET $SG227660
	push	edx
	mov	BYTE PTR __$EHRec$[esp+136], 5
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3581 : 								LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227659[esp+112]
	push	eax
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3582 : 							}

	lea	ecx, DWORD PTR _strLogString$227659[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3583 : 						}
; 3584 : 					}
; 3585 : 				}
; 3586 : 			}	
; 3587 : 			break;

	jmp	$LN23@ExecuteMus
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227613[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227626[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$227631[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$227651[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strLogString$227655[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$227659[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteMusicianMoves
PUBLIC	?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteScientistMoves
EXTRN	?getMISSION_DISCOVER@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_DISCOVER
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ$1
__ehfuncinfo$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$ = -56						; size = 4
$T272044 = -52						; size = 4
_pUnit$227670 = -48					; size = 8
_strLogString$227680 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::ExecuteScientistMoves, COMDAT
; _this$ = ecx

; 3598 : {

	push	-1
	push	__ehhandler$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	push	ebp
	push	edi
	mov	edi, ecx

; 3599 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3600 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	ebp, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [edi+20]
	shl	eax, 4
	add	eax, ebp
	mov	DWORD PTR _it$[esp+64], ebp
	cmp	ebp, eax
	je	$LN9@ExecuteSci
	push	ebx
	push	esi
	xor	ebx, ebx
$LL11@ExecuteSci:

; 3601 : 	{
; 3602 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$227670[esp+72], esi
	mov	BYTE PTR _pUnit$227670[esp+76], bl
	cmp	esi, ebx
	je	SHORT $LN25@ExecuteSci
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN25@ExecuteSci:
	mov	DWORD PTR __$EHRec$[esp+80], ebx

; 3603 : 		if(!pUnit)

	cmp	esi, ebx
	jne	SHORT $LN8@ExecuteSci

; 3604 : 		{
; 3605 : 			continue;

	mov	DWORD PTR __$EHRec$[esp+80], -1
	jmp	$LN10@ExecuteSci
$LN8@ExecuteSci:

; 3606 : 		}
; 3607 : 
; 3608 : 		GreatPeopleDirectiveTypes eDirective = pUnit->GetGreatPeopleDirective();

	mov	ecx, esi
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective

; 3609 : 		switch(eDirective)

	inc	eax
	cmp	eax, 3
	ja	$LN6@ExecuteSci
	jmp	DWORD PTR $LN80@ExecuteSci[eax*4]
$LN5@ExecuteSci:

; 3610 : 		{
; 3611 : 		case GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE:
; 3612 : 			ExecuteGoldenAgeMove(pUnit.pointer());

	push	esi
	mov	ecx, edi
	call	?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteGoldenAgeMove

; 3613 : 			break;

	jmp	$LN6@ExecuteSci
$LN4@ExecuteSci:

; 3614 : 		case GREAT_PEOPLE_DIRECTIVE_USE_POWER:
; 3615 : 			pUnit->PushMission(CvTypes::getMISSION_DISCOVER());

	push	ebx
	push	ebx
	push	-1
	push	ebx
	push	ebx
	push	ebx
	push	-1
	push	-1
	call	?getMISSION_DISCOVER@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_DISCOVER
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3616 : 			UnitProcessed(pUnit->GetID());

	mov	ebp, DWORD PTR [esi+100]
	lea	ecx, DWORD PTR $T272044[esp+72]
	push	ecx
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR $T272044[esp+76], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [edi]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	cmp	eax, ebx
	je	SHORT $LN47@ExecuteSci
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN47@ExecuteSci:

; 3617 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN78@ExecuteSci
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN78@ExecuteSci

; 3618 : 			{
; 3619 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227680[esp+72]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3620 : 				strLogString.Format("Great scientist discovered free tech at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLogString$227680[esp+80]
	push	OFFSET $SG227681
	push	edx
	mov	BYTE PTR __$EHRec$[esp+96], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3621 : 				LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227680[esp+72]
	push	eax
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3622 : 			}

	lea	ecx, DWORD PTR _strLogString$227680[esp+72]
	mov	BYTE PTR __$EHRec$[esp+80], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN78@ExecuteSci:

; 3623 : 			break;

	mov	ebp, DWORD PTR _it$[esp+72]
$LN6@ExecuteSci:

; 3629 : 			break;
; 3630 : 		}
; 3631 : 	}

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+80], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN10@ExecuteSci:
	mov	ecx, DWORD PTR [edi+20]
	shl	ecx, 4
	add	ecx, DWORD PTR [edi+16]
	add	ebp, 16					; 00000010H
	mov	DWORD PTR _it$[esp+72], ebp
	cmp	ebp, ecx
	jne	$LL11@ExecuteSci
	pop	esi
	pop	ebx
$LN9@ExecuteSci:

; 3632 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 56					; 00000038H
	ret	0
$LN2@ExecuteSci:

; 3624 : 		case GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT:
; 3625 : 			ExecuteWorkerMove(pUnit.pointer());

	push	esi
	mov	ecx, edi
	call	?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteWorkerMove

; 3626 : 			break;

	jmp	SHORT $LN6@ExecuteSci
$LN1@ExecuteSci:

; 3627 : 		case NO_GREAT_PEOPLE_DIRECTIVE_TYPE:
; 3628 : 			MoveCivilianToSafety(pUnit.pointer());

	push	ebx
	push	esi
	mov	ecx, edi
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
	jmp	SHORT $LN6@ExecuteSci
$LN80@ExecuteSci:

; 3632 : }

	DD	$LN1@ExecuteSci
	DD	$LN5@ExecuteSci
	DD	$LN4@ExecuteSci
	DD	$LN2@ExecuteSci
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227670[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227680[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::ExecuteScientistMoves
PUBLIC	?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteMerchantMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_pUnit$227755 = -20					; size = 8
__$EHRec$ = -12						; size = 12
?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteMerchantMoves, COMDAT
; _this$ = ecx

; 3798 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebp
	push	edi
	mov	edi, ecx

; 3799 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3800 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR [edi+20]
	mov	ebp, DWORD PTR [edi+16]
	shl	eax, 4
	add	eax, ebp
	cmp	ebp, eax
	je	$LN8@ExecuteMer
	push	ebx
	push	esi
	xor	ebx, ebx
$LL10@ExecuteMer:

; 3801 : 	{
; 3802 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$227755[esp+36], esi
	mov	BYTE PTR _pUnit$227755[esp+40], bl
	cmp	esi, ebx
	je	SHORT $LN23@ExecuteMer
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN23@ExecuteMer:
	mov	DWORD PTR __$EHRec$[esp+44], ebx

; 3803 : 		if(!pUnit)

	cmp	esi, ebx
	jne	SHORT $LN7@ExecuteMer

; 3804 : 		{
; 3805 : 			continue;

	mov	DWORD PTR __$EHRec$[esp+44], -1
	jmp	SHORT $LN9@ExecuteMer
$LN7@ExecuteMer:

; 3806 : 		}
; 3807 : 
; 3808 : 		GreatPeopleDirectiveTypes eDirective = pUnit->GetGreatPeopleDirective();

	mov	ecx, esi
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective

; 3809 : 		switch(eDirective)

	cmp	eax, -1
	je	SHORT $LN1@ExecuteMer
	cmp	eax, ebx
	je	SHORT $LN4@ExecuteMer
	cmp	eax, 2
	jne	SHORT $LN5@ExecuteMer

; 3814 : 		case GREAT_PEOPLE_DIRECTIVE_USE_POWER:
; 3815 : 			// handled by economic AI
; 3816 : 			break;
; 3817 : 		case GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT:
; 3818 : 			ExecuteWorkerMove(pUnit.pointer());

	push	esi
	mov	ecx, edi
	call	?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteWorkerMove

; 3819 : 			break;

	jmp	SHORT $LN5@ExecuteMer
$LN4@ExecuteMer:

; 3810 : 		{
; 3811 : 		case GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE:
; 3812 : 			ExecuteGoldenAgeMove(pUnit.pointer());

	push	esi
	mov	ecx, edi
	call	?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteGoldenAgeMove

; 3813 : 			break;

	jmp	SHORT $LN5@ExecuteMer
$LN1@ExecuteMer:

; 3820 : 		case NO_GREAT_PEOPLE_DIRECTIVE_TYPE:
; 3821 : 			MoveCivilianToSafety(pUnit.pointer());

	push	ebx
	push	esi
	mov	ecx, edi
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN5@ExecuteMer:

; 3822 : 			break;
; 3823 : 		}
; 3824 : 	}

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+44], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@ExecuteMer:
	mov	ecx, DWORD PTR [edi+20]
	shl	ecx, 4
	add	ecx, DWORD PTR [edi+16]
	add	ebp, 16					; 00000010H
	cmp	ebp, ecx
	jne	$LL10@ExecuteMer
	pop	esi
	pop	ebx
$LN8@ExecuteMer:

; 3825 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227755[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteMerchantMoves
PUBLIC	?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteProphetMoves
EXTRN	?ChooseProphetTargetPlot@CvReligionAI@@QAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@PAH@Z:PROC ; CvReligionAI::ChooseProphetTargetPlot
EXTRN	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z:PROC	; CvPlot::getUnitByIndex
EXTRN	?getNumUnits@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumUnits
EXTRN	?DoEnhanceReligion@CvUnit@@QAE_NXZ:PROC		; CvUnit::DoEnhanceReligion
EXTRN	?CanEnhanceReligion@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC ; CvUnit::CanEnhanceReligion
EXTRN	?DoFoundReligion@CvUnit@@QAE_NXZ:PROC		; CvUnit::DoFoundReligion
EXTRN	?CanFoundReligion@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC ; CvUnit::CanFoundReligion
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$7
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$8
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$9
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$ = -100						; size = 4
_iBestTurns$227793 = -96				; size = 4
_iLoopCity$227792 = -92					; size = 4
_pBestCityPlot$227794 = -88				; size = 4
_iTargetTurns$227818 = -84				; size = 4
$T272173 = -80						; size = 4
$T272172 = -80						; size = 4
_pUnit$227774 = -76					; size = 8
_strLogString$227830 = -68				; size = 28
_strLogString$227824 = -68				; size = 28
_strLogString$227815 = -68				; size = 28
_strLogString$227811 = -68				; size = 28
_strLogString$227788 = -68				; size = 28
_strLogString$227784 = -68				; size = 28
_strLogString$227835 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteProphetMoves, COMDAT
; _this$ = ecx

; 3828 : {

	push	-1
	push	__ehhandler$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 3829 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3830 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	ebp, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [edi+20]
	shl	eax, 4
	add	eax, ebp
	mov	DWORD PTR _it$[esp+116], ebp
	cmp	ebp, eax
	je	$LN35@ExecutePro
$LL37@ExecutePro:

; 3831 : 	{
; 3832 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	xor	ebx, ebx
	mov	DWORD PTR _pUnit$227774[esp+116], esi
	mov	BYTE PTR _pUnit$227774[esp+120], 0
	cmp	esi, ebx
	je	SHORT $LN59@ExecutePro
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN59@ExecutePro:
	mov	DWORD PTR __$EHRec$[esp+124], ebx

; 3833 : 		if(!pUnit)

	cmp	esi, ebx
	jne	SHORT $LN34@ExecutePro

; 3834 : 		{
; 3835 : 			continue;

	mov	DWORD PTR __$EHRec$[esp+124], -1
	jmp	$LN36@ExecutePro
$LN34@ExecutePro:

; 3836 : 		}
; 3837 : 
; 3838 : 		GreatPeopleDirectiveTypes eDirective = pUnit->GetGreatPeopleDirective();

	mov	ecx, esi
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective

; 3839 : 		switch(eDirective)

	inc	eax
	cmp	eax, 4
	ja	$LN32@ExecutePro
	jmp	DWORD PTR $LN261@ExecutePro[eax*4]
$LN31@ExecutePro:

; 3840 : 		{
; 3841 : 		case GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT:
; 3842 : 			ExecuteWorkerMove(pUnit.pointer());

	push	esi
	mov	ecx, edi
	call	?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteWorkerMove

; 3843 : 			break;

	jmp	$LN32@ExecutePro
$LN30@ExecutePro:

; 3844 : 
; 3845 : 		case GREAT_PEOPLE_DIRECTIVE_USE_POWER:
; 3846 : 
; 3847 : 			// Can I found a religion?
; 3848 : 			if(pUnit->CanFoundReligion(pUnit->plot()))

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?CanFoundReligion@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::CanFoundReligion
	test	al, al
	je	SHORT $LN29@ExecutePro

; 3849 : 			{
; 3850 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227784[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3851 : 				strLogString.Format("Great Prophet founding a religion, X: %d, Y: %d", pUnit->plot()->getX(), pUnit->plot()->getY());

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+124], 1
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	ebp, WORD PTR [eax+2]
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	ecx, WORD PTR [eax]
	push	ebp
	push	ecx
	lea	edx, DWORD PTR _strLogString$227784[esp+124]
	push	OFFSET $SG227785
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3852 : 				LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227784[esp+116]
	push	eax
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3853 : 
; 3854 : 				pUnit->DoFoundReligion();

	mov	ecx, esi
	call	?DoFoundReligion@CvUnit@@QAE_NXZ	; CvUnit::DoFoundReligion

; 3929 : 					}

	lea	ecx, DWORD PTR _strLogString$227815[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3930 : 				}
; 3931 : 			}
; 3932 : 
; 3933 : 			break;

	jmp	$LN32@ExecutePro
$LN29@ExecutePro:

; 3855 : 			}
; 3856 : 
; 3857 : 			// Can I enhance a religion?
; 3858 : 			else if(pUnit->CanEnhanceReligion(pUnit->plot()))

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, esi
	call	?CanEnhanceReligion@CvUnit@@QBE_NPBVCvPlot@@@Z ; CvUnit::CanEnhanceReligion
	test	al, al
	je	SHORT $LN27@ExecutePro

; 3859 : 			{
; 3860 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227788[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3861 : 				strLogString.Format("Great Prophet enhancing a religion, X: %d, Y: %d", pUnit->plot()->getX(), pUnit->plot()->getY());

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+124], 2
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	ebp, WORD PTR [eax+2]
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	ecx, WORD PTR [eax]
	push	ebp
	push	ecx
	lea	edx, DWORD PTR _strLogString$227788[esp+124]
	push	OFFSET $SG227789
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3862 : 				LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227788[esp+116]
	push	eax
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3863 : 
; 3864 : 				pUnit->DoEnhanceReligion();

	mov	ecx, esi
	call	?DoEnhanceReligion@CvUnit@@QAE_NXZ	; CvUnit::DoEnhanceReligion

; 3929 : 					}

	lea	ecx, DWORD PTR _strLogString$227815[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3930 : 				}
; 3931 : 			}
; 3932 : 
; 3933 : 			break;

	jmp	$LN32@ExecutePro
$LN27@ExecutePro:

; 3865 : 			}
; 3866 : 
; 3867 : 			// Move to closest city without a civilian in it
; 3868 : 			else
; 3869 : 			{
; 3870 : 				CvCity* pLoopCity;
; 3871 : 				int iLoopCity = 0;
; 3872 : 				int iBestTurns = MAX_INT;
; 3873 : 				CvPlot* pBestCityPlot = NULL;
; 3874 : 				for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	push	ebx
	lea	ecx, DWORD PTR _iLoopCity$227792[esp+120]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR _iLoopCity$227792[esp+124], ebx
	mov	DWORD PTR _iBestTurns$227793[esp+124], 2147483647 ; 7fffffffH
	mov	DWORD PTR _pBestCityPlot$227794[esp+124], ebx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	cmp	eax, ebx
	jne	$LN25@ExecutePro
$LN16@ExecutePro:

; 3920 : 				{
; 3921 : 					pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3922 : 					UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR [esi+100]
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3923 : 
; 3924 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN32@ExecutePro
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN32@ExecutePro

; 3925 : 					{
; 3926 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227815[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3927 : 						strLogString.Format("No place to move Great Prophet at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+132], 4
	push	OFFSET $SG227816
$LN260@ExecutePro:
	lea	ecx, DWORD PTR _strLogString$227815[esp+128]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3928 : 						LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227815[esp+116]
	push	edx
$LN258@ExecutePro:
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3929 : 					}

	lea	ecx, DWORD PTR _strLogString$227815[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3930 : 				}
; 3931 : 			}
; 3932 : 
; 3933 : 			break;

	jmp	$LN32@ExecutePro
	npad	6
$LL251@ExecutePro:

; 3865 : 			}
; 3866 : 
; 3867 : 			// Move to closest city without a civilian in it
; 3868 : 			else
; 3869 : 			{
; 3870 : 				CvCity* pLoopCity;
; 3871 : 				int iLoopCity = 0;
; 3872 : 				int iBestTurns = MAX_INT;
; 3873 : 				CvPlot* pBestCityPlot = NULL;
; 3874 : 				for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	xor	ebx, ebx
$LN25@ExecutePro:

; 3875 : 				{
; 3876 : 					bool bSkipCity = false;
; 3877 : 
; 3878 : 					CvPlot* pTarget = pLoopCity->plot();

	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ebp, eax

; 3879 : #ifdef AUI_WARNING_FIXES
; 3880 : 					if (!pTarget)
; 3881 : 						continue;
; 3882 : 					for (uint iUnitLoop = 0; iUnitLoop < pTarget->getNumUnits(); iUnitLoop++)
; 3883 : #else
; 3884 : 					for(int iUnitLoop = 0; iUnitLoop < pTarget->getNumUnits(); iUnitLoop++)

	mov	ecx, ebp
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	SHORT $LN250@ExecutePro
$LL22@ExecutePro:

; 3885 : #endif
; 3886 : 					{
; 3887 : 						// Don't go here if a civilian is already present
; 3888 : 						if(!pTarget->getUnitByIndex(iUnitLoop)->IsCombatUnit())

	push	ebx
	mov	ecx, ebp
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	cmp	DWORD PTR [eax+1044], 0
	jle	SHORT $LN24@ExecutePro
	mov	ecx, ebp
	inc	ebx
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	ebx, eax
	jl	SHORT $LL22@ExecutePro
$LN250@ExecutePro:

; 3889 : 						{
; 3890 : 							bSkipCity = true;
; 3891 : 							break;
; 3892 : 						}
; 3893 : 					}
; 3894 : 
; 3895 : 					if(!bSkipCity)
; 3896 : 					{
; 3897 : 						int iTurns = TurnsToReachTarget(pUnit, pTarget);

	push	0
	push	0
	push	0
	push	ebp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T272172[esp+140], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 3898 : 						if(iTurns < iBestTurns)

	cmp	eax, DWORD PTR _iBestTurns$227793[esp+116]
	jge	SHORT $LN24@ExecutePro

; 3899 : 						{
; 3900 : 							iBestTurns = iTurns;

	mov	DWORD PTR _iBestTurns$227793[esp+116], eax

; 3901 : 							pBestCityPlot = pTarget;

	mov	DWORD PTR _pBestCityPlot$227794[esp+116], ebp
$LN24@ExecutePro:
	mov	ecx, DWORD PTR [edi]
	push	0
	lea	edx, DWORD PTR _iLoopCity$227792[esp+120]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	test	eax, eax
	jne	SHORT $LL251@ExecutePro

; 3902 : 						}
; 3903 : 					}
; 3904 : 				}
; 3905 : 
; 3906 : 				if(pBestCityPlot)

	mov	ebx, DWORD PTR _pBestCityPlot$227794[esp+116]
	test	ebx, ebx
	je	$LN16@ExecutePro

; 3907 : 				{
; 3908 : 					pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestCityPlot->getX(), pBestCityPlot->getY());

	movsx	eax, WORD PTR [ebx+2]
	movsx	ecx, WORD PTR [ebx]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3909 : 					pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3910 : 					UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR [esi+100]
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3911 : 
; 3912 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN32@ExecutePro
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN32@ExecutePro

; 3913 : 					{
; 3914 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227811[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3915 : 						strLogString.Format("Moving Great Prophet to nearest city without civilian, X: %d, Y: %d", pBestCityPlot->getX(), pBestCityPlot->getY());

	movsx	eax, WORD PTR [ebx+2]
	movsx	ecx, WORD PTR [ebx]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLogString$227811[esp+124]
	push	OFFSET $SG227812
	push	edx
	mov	BYTE PTR __$EHRec$[esp+140], 3
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3916 : 						LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227811[esp+116]
	push	eax

; 3917 : 					}
; 3918 : 				}
; 3919 : 				else

	jmp	$LN258@ExecutePro
$LN12@ExecutePro:

; 3934 : 
; 3935 : 		case GREAT_PEOPLE_DIRECTIVE_SPREAD_RELIGION:
; 3936 : 			{
; 3937 : 				int iTargetTurns;
; 3938 : 				CvPlot* pTarget = m_pPlayer->GetReligionAI()->ChooseProphetTargetPlot(pUnit, &iTargetTurns);

	lea	eax, DWORD PTR _iTargetTurns$227818[esp+116]
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T272173[esp+128], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ecx, DWORD PTR [edi]
	mov	BYTE PTR __$EHRec$[esp+136], 5
	call	?GetReligionAI@CvPlayer@@QBEPAVCvReligionAI@@XZ ; CvPlayer::GetReligionAI
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+136], 0
	call	?ChooseProphetTargetPlot@CvReligionAI@@QAEPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@PAH@Z ; CvReligionAI::ChooseProphetTargetPlot
	mov	ebp, eax

; 3939 : 				if(pTarget)

	cmp	ebp, ebx
	je	$LN32@ExecutePro

; 3940 : 				{
; 3941 : 					if(pUnit->plot() == pTarget)

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebp
	jne	SHORT $LN10@ExecutePro

; 3942 : 					{
; 3943 : 						pUnit->PushMission(CvTypes::getMISSION_SPREAD_RELIGION());

	push	ebx
	push	ebx
	push	-1
	push	ebx
	push	ebx
	push	ebx
	push	-1
	push	-1
	call	?getMISSION_SPREAD_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPREAD_RELIGION
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3944 : 
; 3945 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN32@ExecutePro
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN32@ExecutePro

; 3946 : 						{
; 3947 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227824[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3948 : 							strLogString.Format("Spreading religion, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	movsx	ecx, WORD PTR [ebp+2]
	movsx	edx, WORD PTR [ebp]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strLogString$227824[esp+124]
	push	OFFSET $SG227825
	push	eax
	mov	BYTE PTR __$EHRec$[esp+140], 6
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3949 : 							LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227824[esp+116]
	push	ecx

; 3950 : 						}
; 3951 : 					}

	jmp	$LN258@ExecutePro
$LN10@ExecutePro:

; 3952 : 					else if(iTargetTurns < 1)

	cmp	DWORD PTR _iTargetTurns$227818[esp+116], 1
	jge	$LN7@ExecutePro

; 3953 : 					{
; 3954 : 						pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTarget->getX(), pTarget->getY());

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	ebx
	push	ebx
	push	-1
	push	ebx
	push	ebx
	push	ebx
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3955 : 
; 3956 : 						if(pUnit->plot() == pTarget && pUnit->canMove())

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebp
	jne	$LN32@ExecutePro
	mov	ecx, esi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN32@ExecutePro

; 3957 : 						{
; 3958 : 							pUnit->PushMission(CvTypes::getMISSION_SPREAD_RELIGION());

	push	ebx
	push	ebx
	push	-1
	push	ebx
	push	ebx
	push	ebx
	push	-1
	push	-1
	call	?getMISSION_SPREAD_RELIGION@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_SPREAD_RELIGION
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3959 : 
; 3960 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN32@ExecutePro
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN32@ExecutePro

; 3961 : 							{
; 3962 : 								CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227830[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3963 : 								strLogString.Format("Move to spread religion, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	movsx	edx, WORD PTR [ebp+2]
	movsx	eax, WORD PTR [ebp]
	push	edx
	push	eax
	mov	BYTE PTR __$EHRec$[esp+132], 7
	push	OFFSET $SG227831

; 3964 : 								LogHomelandMessage(strLogString);
; 3965 : 							}
; 3966 : 						}
; 3967 : 						else
; 3968 : 						{
; 3969 : 							CvAssertMsg(false, "Internal error with Prophet spread religion AI move, contact Ed.");
; 3970 : 						}
; 3971 : 					}
; 3972 : 					else

	jmp	$LN260@ExecutePro
$LN7@ExecutePro:

; 3973 : 					{
; 3974 : 						
; 3975 : 						m_CurrentBestMoveHighPriorityUnit = NULL;
; 3976 : 						m_CurrentBestMoveUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR _it$[esp+116]
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [edi+2404], ebx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 3977 : 						ExecuteMoveToTarget(pTarget);

	push	ebp
	mov	ecx, edi
	mov	DWORD PTR [edi+2396], eax
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 3978 : 
; 3979 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN32@ExecutePro
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN32@ExecutePro

; 3980 : 						{
; 3981 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227835[esp+116]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3982 : 							strLogString.Format("Moving to plot adjacent to conversion city, X: %d, Y: %d, Currently at, X: %d, Y: %d", pTarget->getX(), pTarget->getY(), pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	movsx	edx, WORD PTR [ebp]
	push	eax
	push	ecx
	movsx	ecx, WORD PTR [ebp+2]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strLogString$227835[esp+132]
	push	OFFSET $SG227836
	push	eax
	mov	BYTE PTR __$EHRec$[esp+148], 8
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 3983 : 							LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227835[esp+116]
	push	ecx
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3984 : 						}

	lea	ecx, DWORD PTR _strLogString$227835[esp+116]
	mov	BYTE PTR __$EHRec$[esp+124], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3985 : 					}
; 3986 : 				}
; 3987 : 			}
; 3988 : 			break;

	jmp	SHORT $LN32@ExecutePro
$LN1@ExecutePro:

; 3989 : 
; 3990 : 		case NO_GREAT_PEOPLE_DIRECTIVE_TYPE:
; 3991 : 			MoveCivilianToSafety(pUnit.pointer());

	push	ebx
	push	esi
	mov	ecx, edi
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN32@ExecutePro:

; 3992 : 			break;
; 3993 : 		}
; 3994 : 	}

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+124], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	ebp, DWORD PTR _it$[esp+116]
$LN36@ExecutePro:
	mov	edx, DWORD PTR [edi+20]
	shl	edx, 4
	add	edx, DWORD PTR [edi+16]
	add	ebp, 16					; 00000010H
	mov	DWORD PTR _it$[esp+116], ebp
	cmp	ebp, edx
	jne	$LL37@ExecutePro
$LN35@ExecutePro:

; 3995 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+116]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 100				; 00000064H
	ret	0
	npad	3
$LN261@ExecutePro:
	DD	$LN1@ExecutePro
	DD	$LN32@ExecutePro
	DD	$LN30@ExecutePro
	DD	$LN31@ExecutePro
	DD	$LN12@ExecutePro
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227774[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227784[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$227788[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$227815[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$227811[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$6:
	mov	ecx, DWORD PTR $T272173[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$227824[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR _strLogString$227830[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ$9:
	lea	ecx, DWORD PTR _strLogString$227835[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteProphetMoves
PUBLIC	?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteGeneralMoves
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
EXTRN	?getNumBuildInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildInfos
EXTRN	?FindBestArtistTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@AAH@Z:PROC ; CvPlayerAI::FindBestArtistTargetPlot
EXTRN	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligion
EXTRN	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligionCreatedByPlayer
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
EXTRN	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z:PROC ; CvTeam::getProjectCount
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$7
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_bHaveApolloInCapital$ = -134				; size = 1
_bKeepHolyCityClear$ = -133				; size = 1
_pHolyCityPlot$ = -132					; size = 4
_pHolyCity$ = -128					; size = 4
_it$ = -124						; size = 4
$T272886 = -120						; size = 4
_iBestTurns$227896 = -120				; size = 4
_iLoopCity$227895 = -116				; size = 4
$T273072 = -112						; size = 4
$T272983 = -112						; size = 4
_pBestCityPlot$227897 = -112				; size = 4
_iValue$227862 = -112					; size = 4
$T272555 = -108						; size = 4
_pUnit$227859 = -104					; size = 8
_strLogString$227918 = -96				; size = 28
_strLogString$227890 = -96				; size = 28
_strLogString$227882 = -96				; size = 28
_strLogString$227878 = -96				; size = 28
_strLogString$227922 = -68				; size = 28
$T272554 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteGeneralMoves, COMDAT
; _this$ = ecx

; 3999 : {

	push	-1
	push	__ehhandler$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 124				; 0000007cH

; 4000 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4001 : 	CvPlot* pHolyCityPlot = NULL;
; 4002 : 	CvCity* pHolyCity = NULL;
; 4003 : 
; 4004 : 	// Do we have an Apollo program to stay clear of?
; 4005 : 	bool bHaveApolloInCapital = false;
; 4006 : 	ProjectTypes eApolloProgram = (ProjectTypes) GC.getSPACE_RACE_TRIGGER_PROJECT();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8424
	push	ebx
	push	ebp
	xor	ebp, ebp
	push	esi
	push	edi
	mov	ebx, ecx
	mov	DWORD PTR _pHolyCityPlot$[esp+152], ebp
	mov	DWORD PTR _pHolyCity$[esp+152], ebp
	mov	BYTE PTR _bHaveApolloInCapital$[esp+152], 0

; 4007 : 	if(eApolloProgram != NO_PROJECT)

	cmp	edx, -1
	je	SHORT $LN42@ExecuteGen

; 4008 : 	{
; 4009 : 		if(GET_TEAM(m_pPlayer->getTeam()).getProjectCount(eApolloProgram) > 0)

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN60@ExecuteGen
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN61@ExecuteGen
$LN60@ExecuteGen:
	or	eax, -1
$LN61@ExecuteGen:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edx
	mov	ecx, eax
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	test	eax, eax
	jle	SHORT $LN42@ExecuteGen

; 4010 : 		{
; 4011 : 			bHaveApolloInCapital = true;

	mov	BYTE PTR _bHaveApolloInCapital$[esp+152], 1
$LN42@ExecuteGen:

; 4012 : 		}
; 4013 : 	}
; 4014 : 
; 4015 : 	// Do we have a holy city to stay clear of?
; 4016 : 	bool bKeepHolyCityClear = false;
; 4017 : 	CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR _bKeepHolyCityClear$[esp+152], 0
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions

; 4018 : 	ReligionTypes eMyReligion = pReligions->GetReligionCreatedByPlayer(m_pPlayer->GetID());

	mov	edx, DWORD PTR [ebx]
	mov	esi, eax
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, esi
	call	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligionCreatedByPlayer

; 4019 : 	const CvReligion* pMyReligion = pReligions->GetReligion(eMyReligion, m_pPlayer->GetID());

	mov	ecx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ecx+44]
	push	ecx
	push	eax
	mov	ecx, esi
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion

; 4020 : 	if(pMyReligion)

	cmp	eax, ebp
	je	$LN40@ExecuteGen

; 4021 : 	{
; 4022 : 		pHolyCityPlot = GC.getMap().plot(pMyReligion->m_iHolyCityX, pMyReligion->m_iHolyCityY);

	mov	esi, DWORD PTR [eax+8]
	mov	edi, DWORD PTR [eax+12]
	cmp	esi, -2147483647			; 80000001H
	je	$LN79@ExecuteGen
	cmp	edi, -2147483647			; 80000001H
	je	$LN79@ExecuteGen
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	al, al
	je	SHORT $LN89@ExecuteGen
	cmp	esi, ebp
	jge	SHORT $LN91@ExecuteGen
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN89@ExecuteGen
$LN91@ExecuteGen:
	cmp	esi, ecx
	jl	SHORT $LN89@ExecuteGen
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN89@ExecuteGen:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebp, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN99@ExecuteGen
	test	edi, edi
	jge	SHORT $LN101@ExecuteGen
	mov	eax, edi
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN103@ExecuteGen
$LN101@ExecuteGen:
	cmp	edi, ebp
	jl	SHORT $LN99@ExecuteGen
	mov	eax, edi
	cdq
	idiv	ebp
	jmp	SHORT $LN103@ExecuteGen
$LN99@ExecuteGen:
	mov	edx, edi
$LN103@ExecuteGen:
	test	esi, esi
	jl	SHORT $LN83@ExecuteGen
	cmp	esi, ecx
	jge	SHORT $LN83@ExecuteGen
	test	edx, edx
	jl	SHORT $LN83@ExecuteGen
	cmp	edx, ebp
	jge	SHORT $LN83@ExecuteGen
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pHolyCityPlot$[esp+152], ecx
	jmp	SHORT $LN81@ExecuteGen
$LN83@ExecuteGen:
	mov	DWORD PTR _pHolyCityPlot$[esp+152], 0
	jmp	SHORT $LN81@ExecuteGen
$LN79@ExecuteGen:
	mov	DWORD PTR _pHolyCityPlot$[esp+152], ebp
$LN81@ExecuteGen:

; 4023 : 		pHolyCity = pHolyCityPlot->getPlotCity();

	mov	ecx, DWORD PTR _pHolyCityPlot$[esp+152]
	mov	eax, DWORD PTR [ecx+104]
	xor	ebp, ebp
	cmp	eax, ebp
	jl	SHORT $LN117@ExecuteGen
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN117@ExecuteGen
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	DWORD PTR _pHolyCity$[esp+152], eax

; 4024 : 		if(pHolyCity && (pHolyCity->getOwner() == m_pPlayer->GetID()))

	cmp	eax, ebp
	je	SHORT $LN40@ExecuteGen
	mov	eax, DWORD PTR [eax+84]
	mov	edx, DWORD PTR [ebx]
	cmp	eax, DWORD PTR [edx+44]
	jne	SHORT $LN40@ExecuteGen

; 4025 : 		{
; 4026 : 			bKeepHolyCityClear = true;

	mov	BYTE PTR _bKeepHolyCityClear$[esp+152], 1
$LN40@ExecuteGen:

; 4027 : 		}
; 4028 : 	}
; 4029 : 
; 4030 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	edi, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [ebx+20]
	shl	eax, 4
	add	eax, edi
	mov	DWORD PTR _it$[esp+152], edi
	cmp	edi, eax
	je	$LN37@ExecuteGen
	jmp	SHORT $LN39@ExecuteGen

; 4023 : 		pHolyCity = pHolyCityPlot->getPlotCity();

$LN117@ExecuteGen:
	mov	DWORD PTR _pHolyCity$[esp+152], ebp

; 4024 : 		if(pHolyCity && (pHolyCity->getOwner() == m_pPlayer->GetID()))

	jmp	SHORT $LN40@ExecuteGen
	npad	3
$LL347@ExecuteGen:

; 4027 : 		}
; 4028 : 	}
; 4029 : 
; 4030 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	xor	ebp, ebp
$LN39@ExecuteGen:

; 4031 : 	{
; 4032 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pUnit$227859[esp+152], esi
	mov	BYTE PTR _pUnit$227859[esp+156], 0
	cmp	esi, ebp
	je	SHORT $LN139@ExecuteGen
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN139@ExecuteGen:
	mov	DWORD PTR __$EHRec$[esp+160], ebp

; 4033 : 		if(!pUnit)

	cmp	esi, ebp
	jne	SHORT $LN36@ExecuteGen

; 4034 : 		{
; 4035 : 			continue;

	mov	DWORD PTR __$EHRec$[esp+160], -1
	jmp	$LN38@ExecuteGen
$LN36@ExecuteGen:

; 4036 : 		}
; 4037 : 
; 4038 : 		// this is for the citadel/culture bomb
; 4039 : 		if (pUnit->GetGreatPeopleDirective() == GREAT_PEOPLE_DIRECTIVE_USE_POWER)

	mov	ecx, esi
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	cmp	eax, 1
	jne	$LN34@ExecuteGen

; 4040 : 		{
; 4041 : 			int iValue = 0;
; 4042 : 			CvPlot* pTargetPlot = GET_PLAYER(m_pPlayer->GetID()).FindBestArtistTargetPlot(pUnit.pointer(), iValue);

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR _iValue$227862[esp+152], 0
	mov	eax, DWORD PTR [ecx+44]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR _iValue$227862[esp+152]
	push	edx
	push	esi
	mov	ecx, eax
	call	?FindBestArtistTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@AAH@Z ; CvPlayerAI::FindBestArtistTargetPlot
	mov	ebp, eax

; 4043 : 			if(pTargetPlot)

	test	ebp, ebp
	je	$LN34@ExecuteGen

; 4044 : 			{
; 4045 : 				if(pUnit->plot() == pTargetPlot)

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebp
	jne	$LN33@ExecuteGen

; 4046 : 				{
; 4047 : 					// find the great general improvement
; 4048 : 					BuildTypes eSelectedBuildType = NO_BUILD;
; 4049 : 					BuildTypes eBuild;
; 4050 : #ifdef AUI_WARNING_FIXES
; 4051 : 					for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 4052 : #else
; 4053 : 					int iBuildIndex;
; 4054 : 					for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	$LN1@ExecuteGen
$LL32@ExecuteGen:

; 4055 : #endif
; 4056 : 					{
; 4057 : 						eBuild = (BuildTypes)iBuildIndex;
; 4058 : 						CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 4059 : 						if(pkBuild == NULL)

	test	eax, eax
	je	SHORT $LN31@ExecuteGen

; 4060 : 							continue;
; 4061 : 						
; 4062 : 						if(!pUnit->canBuild(pTargetPlot, eBuild))

	push	1
	push	0
	push	edi
	push	ebp
	mov	ecx, esi
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	test	al, al
	jne	SHORT $LN28@ExecuteGen
$LN31@ExecuteGen:

; 4046 : 				{
; 4047 : 					// find the great general improvement
; 4048 : 					BuildTypes eSelectedBuildType = NO_BUILD;
; 4049 : 					BuildTypes eBuild;
; 4050 : #ifdef AUI_WARNING_FIXES
; 4051 : 					for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 4052 : #else
; 4053 : 					int iBuildIndex;
; 4054 : 					for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	edi, eax
	jl	SHORT $LL32@ExecuteGen

; 4154 : 					{
; 4155 : 						bSkipCity = true;
; 4156 : 						break;
; 4157 : 					}
; 4158 : 					else if(pTarget->getUnitByIndex(iUnitLoop)->AI_getUnitAIType() == UNITAI_ADMIRAL)

	jmp	$LN1@ExecuteGen
$LN28@ExecuteGen:

; 4063 : 						{
; 4064 : 							continue;
; 4065 : 						}
; 4066 : 	
; 4067 : 						eSelectedBuildType = eBuild;
; 4068 : 						break;
; 4069 : 					}
; 4070 : 
; 4071 : 					CvAssertMsg(eSelectedBuildType != NO_BUILD, "Great General trying to build something it doesn't qualify for");
; 4072 : 					if (eSelectedBuildType != NO_BUILD)

	cmp	edi, -1
	je	$LN1@ExecuteGen

; 4073 : 					{
; 4074 : 						pUnit->PushMission(CvTypes::getMISSION_BUILD(), eSelectedBuildType, -1, 0, (pUnit->GetLengthMissionQueue() > 0), false, MISSIONAI_BUILD, pTargetPlot);

	push	0
	push	ebp
	push	18					; 00000012H
	push	0
	mov	ecx, esi
	call	?GetLengthMissionQueue@CvUnit@@QBEHXZ	; CvUnit::GetLengthMissionQueue
	test	eax, eax
	setg	al
	movzx	ecx, al
	push	ecx
	push	0
	push	-1
	push	edi
	call	?getMISSION_BUILD@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUILD
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4075 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteGen
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteGen

; 4076 : 						{
; 4077 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227878[esp+152]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4078 : 							strLogString.Format("Great General culture bombed/citadel'd at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+168], 1
	push	OFFSET $SG227879

; 4079 : 							LogHomelandMessage(strLogString);
; 4080 : 						}
; 4081 : 					}
; 4082 : 				}
; 4083 : 				else

	jmp	$LN349@ExecuteGen
$LN33@ExecuteGen:

; 4084 : 				{
; 4085 : 					pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pTargetPlot->getX(), pTargetPlot->getY());

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4086 : 					pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4087 : 					UnitProcessed(pUnit->GetID());

	mov	ebp, DWORD PTR [esi+100]
	lea	ecx, DWORD PTR $T272886[esp+152]
	push	ecx
	lea	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR $T272886[esp+156], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [ebx]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN199@ExecuteGen
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN199@ExecuteGen:

; 4088 : 
; 4089 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteGen
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteGen

; 4090 : 					{
; 4091 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227882[esp+152]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4092 : 						strLogString.Format("Great general moving to culture bomb/citadel at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+168], 2
	push	OFFSET $SG227883
$LN349@ExecuteGen:
	lea	edx, DWORD PTR _strLogString$227882[esp+164]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4093 : 						LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227882[esp+152]
	push	eax
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4094 : 					}

	lea	ecx, DWORD PTR _strLogString$227882[esp+152]

; 4095 : 				}
; 4096 : 				continue;

	jmp	$LN350@ExecuteGen
$LN34@ExecuteGen:

; 4097 : 			}
; 4098 : 		}
; 4099 : 
; 4100 : 
; 4101 : 		if(pUnit->GetGreatPeopleDirective() == GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE)

	mov	ecx, esi
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	test	eax, eax
	jne	SHORT $LN23@ExecuteGen

; 4102 : 		{
; 4103 : 			ExecuteGoldenAgeMove(pUnit.pointer());

	push	esi
	mov	ecx, ebx
	call	?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteGoldenAgeMove

; 4104 : 			continue;

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+160], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	jmp	$LN38@ExecuteGen
$LN23@ExecuteGen:

; 4105 : 		}
; 4106 : 
; 4107 : 		// if we already built the Apollo Program we don't want the general in the capital because it'll block spaceship parts
; 4108 : 
; 4109 : 		// Already in a friendly city?
; 4110 : 		CvPlot* pUnitPlot =  pUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ebp, eax

; 4111 : 		if(pUnitPlot->isFriendlyCity(*pUnit, false) && (!bHaveApolloInCapital || !pUnitPlot->getPlotCity()->isCapital()) && (!bKeepHolyCityClear || pUnitPlot != pHolyCityPlot))

	push	0
	push	esi
	mov	ecx, ebp
	call	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z ; CvPlot::isFriendlyCity
	test	al, al
	je	$LN22@ExecuteGen
	cmp	BYTE PTR _bHaveApolloInCapital$[esp+152], 0
	je	SHORT $LN21@ExecuteGen
	mov	eax, DWORD PTR [ebp+104]
	test	eax, eax
	jl	SHORT $LN237@ExecuteGen
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN237@ExecuteGen
	mov	ecx, DWORD PTR [ebp+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN238@ExecuteGen
$LN237@ExecuteGen:
	xor	eax, eax
$LN238@ExecuteGen:
	mov	ecx, eax
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	jne	$LN22@ExecuteGen
$LN21@ExecuteGen:
	cmp	BYTE PTR _bKeepHolyCityClear$[esp+152], 0
	je	SHORT $LN20@ExecuteGen
	cmp	ebp, DWORD PTR _pHolyCityPlot$[esp+152]
	je	$LN22@ExecuteGen
$LN20@ExecuteGen:

; 4112 : 		{
; 4113 : 			pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4114 : 			UnitProcessed(pUnit->GetID());

	mov	ebp, DWORD PTR [esi+100]
	lea	edx, DWORD PTR $T272983[esp+152]
	push	edx
	lea	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR $T272983[esp+156], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [ebx]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN251@ExecuteGen
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN251@ExecuteGen:

; 4115 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteGen
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteGen

; 4116 : 			{
; 4117 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227890[esp+152]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4118 : 				strLogString.Format("Great General remaining as garrison for %s, X: %d, Y: %d", pUnit->plot()->getPlotCity()->getName().GetCString(), pUnit->getX(), pUnit->getY());

	lea	eax, DWORD PTR $T272554[esp+152]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+164], 3
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	ecx, eax
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	ecx, DWORD PTR [esi+88]
	mov	edx, DWORD PTR [esi+76]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+168], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$227890[esp+164]
	push	OFFSET $SG227892
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T272554[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4119 : 				LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227890[esp+152]
	push	edx
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4120 : 			}

	lea	ecx, DWORD PTR _strLogString$227890[esp+152]

; 4121 : 		}
; 4122 : 
; 4123 : 		else

	jmp	$LN350@ExecuteGen
$LN22@ExecuteGen:

; 4124 : 		{
; 4125 : 			CvCity* pLoopCity;
; 4126 : 			int iLoopCity = 0;
; 4127 : 			int iBestTurns = MAX_INT;
; 4128 : 			CvPlot* pBestCityPlot = NULL;
; 4129 : 			for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	mov	ecx, DWORD PTR [ebx]
	xor	ebp, ebp
	push	ebp
	lea	eax, DWORD PTR _iLoopCity$227895[esp+156]
	push	eax
	mov	DWORD PTR _iLoopCity$227895[esp+160], ebp
	mov	DWORD PTR _iBestTurns$227896[esp+160], 2147483647 ; 7fffffffH
	mov	DWORD PTR _pBestCityPlot$227897[esp+160], ebp
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	edi, eax
	cmp	edi, ebp
	je	$LN4@ExecuteGen
$LL17@ExecuteGen:

; 4130 : 			{
; 4131 : 				if(bHaveApolloInCapital && pLoopCity->isCapital())

	cmp	BYTE PTR _bHaveApolloInCapital$[esp+152], 0
	je	SHORT $LN14@ExecuteGen
	mov	ecx, edi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	jne	$LN16@ExecuteGen
$LN14@ExecuteGen:

; 4132 : 				{
; 4133 : 					continue;
; 4134 : 				}
; 4135 : 
; 4136 : 				if(bKeepHolyCityClear && pLoopCity == pHolyCity)

	cmp	BYTE PTR _bKeepHolyCityClear$[esp+152], 0
	je	SHORT $LN13@ExecuteGen
	cmp	edi, DWORD PTR _pHolyCity$[esp+152]
	je	$LN16@ExecuteGen
$LN13@ExecuteGen:

; 4137 : 				{
; 4138 : 					continue;
; 4139 : 				}
; 4140 : 
; 4141 : 				bool bSkipCity = false;
; 4142 : 
; 4143 : 				CvPlot* pTarget = pLoopCity->plot();

	mov	ecx, edi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	edi, eax

; 4144 : #ifdef AUI_WARNING_FIXES
; 4145 : 				if (!pTarget)
; 4146 : 					continue;
; 4147 : 				for (uint iUnitLoop = 0; iUnitLoop < pTarget->getNumUnits(); iUnitLoop++)
; 4148 : #else
; 4149 : 				for(int iUnitLoop = 0; iUnitLoop < pTarget->getNumUnits(); iUnitLoop++)

	mov	ecx, edi
	xor	ebp, ebp
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	SHORT $LN344@ExecuteGen
$LL12@ExecuteGen:

; 4150 : #endif
; 4151 : 				{
; 4152 : 					// Don't go here if a general or admiral is already present
; 4153 : 					if(pTarget->getUnitByIndex(iUnitLoop)->AI_getUnitAIType() == UNITAI_GENERAL)

	push	ebp
	mov	ecx, edi
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	ecx, eax
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN16@ExecuteGen

; 4154 : 					{
; 4155 : 						bSkipCity = true;
; 4156 : 						break;
; 4157 : 					}
; 4158 : 					else if(pTarget->getUnitByIndex(iUnitLoop)->AI_getUnitAIType() == UNITAI_ADMIRAL)

	push	ebp
	mov	ecx, edi
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	ecx, eax
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 37					; 00000025H
	je	SHORT $LN16@ExecuteGen
	mov	ecx, edi
	inc	ebp
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	ebp, eax
	jl	SHORT $LL12@ExecuteGen
$LN344@ExecuteGen:

; 4159 : 					{
; 4160 : 						bSkipCity = true;
; 4161 : 						break;
; 4162 : 					}
; 4163 : 				}
; 4164 : 
; 4165 : 				if(!bSkipCity)
; 4166 : 				{
; 4167 : 					int iTurns = TurnsToReachTarget(pUnit, pTarget);

	push	0
	push	0
	push	0
	push	edi
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR $T272555[esp+176], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 4168 : 					if(iTurns < iBestTurns)

	cmp	eax, DWORD PTR _iBestTurns$227896[esp+152]
	jge	SHORT $LN16@ExecuteGen

; 4169 : 					{
; 4170 : 						iBestTurns = iTurns;

	mov	DWORD PTR _iBestTurns$227896[esp+152], eax

; 4171 : 						pBestCityPlot = pTarget;

	mov	DWORD PTR _pBestCityPlot$227897[esp+152], edi
$LN16@ExecuteGen:
	push	0
	lea	ecx, DWORD PTR _iLoopCity$227895[esp+156]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	edi, eax
	test	edi, edi
	jne	$LL17@ExecuteGen

; 4172 : 					}
; 4173 : 				}
; 4174 : 			}
; 4175 : 
; 4176 : 			if(pBestCityPlot)

	mov	edi, DWORD PTR _pBestCityPlot$227897[esp+152]
	test	edi, edi
	je	$LN4@ExecuteGen

; 4177 : 			{
; 4178 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pBestCityPlot->getX(), pBestCityPlot->getY());

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4179 : 				pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4180 : 				UnitProcessed(pUnit->GetID());

	mov	ebp, DWORD PTR [esi+100]
	lea	edx, DWORD PTR $T273072[esp+152]
	push	edx
	lea	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR $T273072[esp+156], ebp
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [ebx]
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN298@ExecuteGen
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN298@ExecuteGen:

; 4181 : 
; 4182 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteGen
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteGen

; 4183 : 				{
; 4184 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227918[esp+152]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4185 : 					strLogString.Format("Moving Great General to city garrison, X: %d, Y: %d", pBestCityPlot->getX(), pBestCityPlot->getY());

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	eax
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+168], 5
	push	OFFSET $SG227919

; 4186 : 					LogHomelandMessage(strLogString);
; 4187 : 				}
; 4188 : 			}
; 4189 : 			else

	jmp	$LN349@ExecuteGen
$LN4@ExecuteGen:

; 4190 : 			{
; 4191 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@ExecuteGen
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@ExecuteGen

; 4192 : 				{
; 4193 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227922[esp+152]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4194 : 					strLogString.Format("No place to move Great General at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strLogString$227922[esp+160]
	push	OFFSET $SG227923
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+176], 6
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4195 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227922[esp+152]
	push	edx
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4196 : 				}

	lea	ecx, DWORD PTR _strLogString$227922[esp+152]
$LN350@ExecuteGen:
	mov	BYTE PTR __$EHRec$[esp+160], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteGen:

; 4197 : 			}
; 4198 : 		}
; 4199 : 	}

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+160], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	edi, DWORD PTR _it$[esp+152]
$LN38@ExecuteGen:
	mov	eax, DWORD PTR [ebx+20]
	shl	eax, 4
	add	eax, DWORD PTR [ebx+16]
	add	edi, 16					; 00000010H
	mov	DWORD PTR _it$[esp+152], edi
	cmp	edi, eax
	jne	$LL347@ExecuteGen
$LN37@ExecuteGen:

; 4200 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+152]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 136				; 00000088H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227859[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227878[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$227882[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$227890[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR $T272554[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strLogString$227918[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$227922[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteGeneralMoves
PUBLIC	?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteAdmiralMoves
EXTRN	?getMISSION_CHANGE_ADMIRAL_PORT@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_CHANGE_ADMIRAL_PORT
EXTRN	?GetSizeLargestAdjacentWater@CvPlot@@QBEHXZ:PROC ; CvPlot::GetSizeLargestAdjacentWater
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$4
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$5
	DD	04H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$6
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$7
	DD	06H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$8
	DD	01H
	DD	FLAT:__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$9
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_bNotAtFriendlyCity$227948 = -657			; size = 1
$T273841 = -656						; size = 4
$T273786 = -656						; size = 4
$T273709 = -656						; size = 4
$T273632 = -656						; size = 4
$T273156 = -656						; size = 4
_pLoopCity$227949 = -656				; size = 4
_bHaveApolloInCapital$ = -650				; size = 1
_bKeepHolyCityClear$ = -649				; size = 1
_this$ = -648						; size = 4
_pHolyCity$ = -644					; size = 4
_it$ = -640						; size = 4
_iLoopCity$227950 = -636				; size = 4
_strLogString$228206 = -632				; size = 28
_strLogString$228201 = -632				; size = 28
_strLogString$228195 = -632				; size = 28
_pUnit$227945 = -604					; size = 8
$T273159 = -596						; size = 28
$T273158 = -596						; size = 28
$T273157 = -596						; size = 28
_strLogString$228211 = -568				; size = 28
_weightedCityList$228166 = -540				; size = 528
__$EHRec$ = -12						; size = 12
?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteAdmiralMoves, COMDAT
; _this$ = ecx

; 4204 : {

	push	-1
	push	__ehhandler$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 648				; 00000288H

; 4205 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 4206 : 	CvPlot* pHolyCityPlot = NULL;
; 4207 : 	CvCity* pHolyCity = NULL;
; 4208 : 
; 4209 : 	// Do we have an Apollo program to stay clear of?
; 4210 : 	bool bHaveApolloInCapital = false;
; 4211 : 	ProjectTypes eApolloProgram = (ProjectTypes) GC.getSPACE_RACE_TRIGGER_PROJECT();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8424
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx
	push	edi
	mov	DWORD PTR _this$[esp+676], ebp
	mov	DWORD PTR _pHolyCity$[esp+676], 0
	mov	BYTE PTR _bHaveApolloInCapital$[esp+676], 0

; 4212 : 	if(eApolloProgram != NO_PROJECT)

	cmp	edx, -1
	je	SHORT $LN35@ExecuteAdm

; 4213 : 	{
; 4214 : 		if(GET_TEAM(m_pPlayer->getTeam()).getProjectCount(eApolloProgram) > 0)

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN57@ExecuteAdm
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN58@ExecuteAdm
$LN57@ExecuteAdm:
	or	eax, -1
$LN58@ExecuteAdm:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edx
	mov	ecx, eax
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	test	eax, eax
	jle	SHORT $LN35@ExecuteAdm

; 4215 : 		{
; 4216 : 			bHaveApolloInCapital = true;

	mov	BYTE PTR _bHaveApolloInCapital$[esp+676], 1
$LN35@ExecuteAdm:

; 4217 : 		}
; 4218 : 	}
; 4219 : 
; 4220 : 	// Do we have a holy city to stay clear of?
; 4221 : 	bool bKeepHolyCityClear = false;
; 4222 : 	CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR _bKeepHolyCityClear$[esp+676], 0
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions

; 4223 : 	ReligionTypes eMyReligion = pReligions->GetReligionCreatedByPlayer(m_pPlayer->GetID());

	mov	edx, DWORD PTR [ebp]
	mov	esi, eax
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, esi
	call	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligionCreatedByPlayer

; 4224 : 	const CvReligion* pMyReligion = pReligions->GetReligion(eMyReligion, m_pPlayer->GetID());

	mov	ecx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ecx+44]
	push	ecx
	push	eax
	mov	ecx, esi
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion

; 4225 : 	if(pMyReligion)

	test	eax, eax
	je	$LN33@ExecuteAdm

; 4226 : 	{
; 4227 : 		pHolyCityPlot = GC.getMap().plot(pMyReligion->m_iHolyCityX, pMyReligion->m_iHolyCityY);

	mov	ebx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, -2147483647			; 80000001H
	je	$LN76@ExecuteAdm
	cmp	ebx, -2147483647			; 80000001H
	je	$LN76@ExecuteAdm
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN86@ExecuteAdm
	test	eax, eax
	jge	SHORT $LN88@ExecuteAdm
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN90@ExecuteAdm
$LN88@ExecuteAdm:
	cmp	eax, ecx
	jl	SHORT $LN86@ExecuteAdm
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN90@ExecuteAdm
$LN86@ExecuteAdm:
	mov	esi, eax
$LN90@ExecuteAdm:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	edi, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN96@ExecuteAdm
	test	ebx, ebx
	jge	SHORT $LN98@ExecuteAdm
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN100@ExecuteAdm
$LN98@ExecuteAdm:
	cmp	ebx, edi
	jl	SHORT $LN96@ExecuteAdm
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN100@ExecuteAdm
$LN96@ExecuteAdm:
	mov	edx, ebx
$LN100@ExecuteAdm:
	test	esi, esi
	jl	SHORT $LN76@ExecuteAdm
	cmp	esi, ecx
	jge	SHORT $LN76@ExecuteAdm
	test	edx, edx
	jl	SHORT $LN76@ExecuteAdm
	cmp	edx, edi
	jge	SHORT $LN76@ExecuteAdm
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	jmp	SHORT $LN78@ExecuteAdm
$LN76@ExecuteAdm:
	xor	ecx, ecx
$LN78@ExecuteAdm:

; 4228 : 		pHolyCity = pHolyCityPlot->getPlotCity();

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	$LN114@ExecuteAdm
	cmp	eax, 64					; 00000040H
	jge	$LN114@ExecuteAdm
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax
	mov	DWORD PTR _pHolyCity$[esp+676], esi

; 4229 : 		if(pHolyCity && pHolyCity->isCoastal() && pHolyCity->getOwner() == m_pPlayer->GetID())

	test	esi, esi
	je	SHORT $LN33@ExecuteAdm
	push	-1
	mov	ecx, esi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	SHORT $LN33@ExecuteAdm
	mov	esi, DWORD PTR [esi+84]
	mov	edx, DWORD PTR [ebp]
	cmp	esi, DWORD PTR [edx+44]
	jne	SHORT $LN33@ExecuteAdm

; 4230 : 		{
; 4231 : 			bKeepHolyCityClear = true;

	mov	BYTE PTR _bKeepHolyCityClear$[esp+676], 1
$LN33@ExecuteAdm:

; 4232 : 		}
; 4233 : 	}
; 4234 : 
; 4235 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	esi, DWORD PTR [ebp+16]
	mov	eax, DWORD PTR [ebp+20]
	shl	eax, 4
	add	eax, esi
	mov	DWORD PTR _it$[esp+676], esi
	cmp	esi, eax
	je	$LN30@ExecuteAdm
	or	ebx, -1
$LL32@ExecuteAdm:

; 4236 : 	{
; 4237 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$227945[esp+676], edi
	mov	BYTE PTR _pUnit$227945[esp+680], 0
	test	edi, edi
	je	SHORT $LN136@ExecuteAdm
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN136@ExecuteAdm:
	mov	DWORD PTR __$EHRec$[esp+684], 0

; 4238 : 		if(!pUnit)

	test	edi, edi
	jne	SHORT $LN29@ExecuteAdm

; 4239 : 		{
; 4240 : 			continue;

	mov	DWORD PTR __$EHRec$[esp+684], ebx
	jmp	$LN31@ExecuteAdm

; 4228 : 		pHolyCity = pHolyCityPlot->getPlotCity();

$LN114@ExecuteAdm:
	mov	DWORD PTR _pHolyCity$[esp+676], 0

; 4229 : 		if(pHolyCity && pHolyCity->isCoastal() && pHolyCity->getOwner() == m_pPlayer->GetID())

	jmp	SHORT $LN33@ExecuteAdm
$LN29@ExecuteAdm:

; 4241 : 		}
; 4242 : 
; 4243 : 		if(pUnit->GetGreatPeopleDirective() == GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE)

	mov	ecx, edi
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	test	eax, eax
	jne	SHORT $LN28@ExecuteAdm

; 4244 : 		{
; 4245 : 			ExecuteGoldenAgeMove(pUnit.pointer());

	push	edi
	mov	ecx, ebp
	call	?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteGoldenAgeMove

; 4246 : 			continue;

	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+684], ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	jmp	$LN31@ExecuteAdm
$LN28@ExecuteAdm:

; 4247 : 		}
; 4248 : 
; 4249 : 		bool bNotAtFriendlyCity = !pUnit->plot()->isCity() || pUnit->plot()->getOwner() != pUnit->getOwner();

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, DWORD PTR [eax+104]
	xor	ebx, ebx
	cmp	ecx, ebx
	jl	SHORT $LN39@ExecuteAdm
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN39@ExecuteAdm
	mov	edx, DWORD PTR [eax+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN39@ExecuteAdm
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	eax, BYTE PTR [eax+4]
	mov	ecx, DWORD PTR [edi+40]
	mov	BYTE PTR _bNotAtFriendlyCity$227948[esp+676], bl
	cmp	eax, ecx
	je	SHORT $LN40@ExecuteAdm
$LN39@ExecuteAdm:
	mov	BYTE PTR _bNotAtFriendlyCity$227948[esp+676], 1
$LN40@ExecuteAdm:

; 4250 : 
; 4251 : 			// Score cities to move to
; 4252 : 		CvCity* pLoopCity;
; 4253 : 		int iLoopCity = 0;
; 4254 : 		CvWeightedVector<CvCity *, SAFE_ESTIMATE_NUM_CITIES, true> weightedCityList;

	lea	ecx, DWORD PTR _weightedCityList$228166[esp+688]
	mov	DWORD PTR _iLoopCity$227950[esp+676], ebx
	mov	DWORD PTR _weightedCityList$228166[esp+680], ebx
	mov	DWORD PTR _weightedCityList$228166[esp+684], 64 ; 00000040H
	mov	DWORD PTR _weightedCityList$228166[esp+676], ecx

; 4255 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	mov	ecx, DWORD PTR [ebp]
	push	ebx
	lea	edx, DWORD PTR _iLoopCity$227950[esp+680]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+692], 1
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	mov	DWORD PTR _pLoopCity$227949[esp+676], esi
	cmp	esi, ebx
	je	$LN25@ExecuteAdm
$LL27@ExecuteAdm:

; 4256 : 		{
; 4257 : 			if (bHaveApolloInCapital && pLoopCity->isCapital())

	cmp	BYTE PTR _bHaveApolloInCapital$[esp+676], 0
	je	SHORT $LN24@ExecuteAdm
	mov	ecx, esi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	jne	$LN26@ExecuteAdm
$LN24@ExecuteAdm:

; 4258 : 			{
; 4259 : 				continue;
; 4260 : 			}
; 4261 : 
; 4262 : 			if (bKeepHolyCityClear && pLoopCity == pHolyCity)

	cmp	BYTE PTR _bKeepHolyCityClear$[esp+676], 0
	je	SHORT $LN23@ExecuteAdm
	cmp	esi, DWORD PTR _pHolyCity$[esp+676]
	je	$LN26@ExecuteAdm
$LN23@ExecuteAdm:

; 4263 : 			{
; 4264 : 				continue;
; 4265 : 			}
; 4266 : 
; 4267 : 			if (!pLoopCity->isCoastal())

	push	-1
	mov	ecx, esi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	$LN26@ExecuteAdm

; 4268 : 			{
; 4269 : 				continue;
; 4270 : 			}
; 4271 : 
; 4272 : 			// Don't go here if a different general or admiral is already present
; 4273 : 			bool bSkipCity = false;
; 4274 : 			CvPlot* pTarget = pLoopCity->plot();

	mov	ecx, esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ebx, eax

; 4275 : #ifdef AUI_WARNING_FIXES
; 4276 : 			for (uint iUnitLoop = 0; iUnitLoop < pTarget->getNumUnits(); iUnitLoop++)
; 4277 : #else
; 4278 : 			for(int iUnitLoop = 0; iUnitLoop < pTarget->getNumUnits(); iUnitLoop++)

	mov	ecx, ebx
	xor	ebp, ebp
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	SHORT $LN409@ExecuteAdm
$LL21@ExecuteAdm:

; 4279 : #endif
; 4280 : 			{
; 4281 : 				CvUnit *pLoopUnit = pTarget->getUnitByIndex(iUnitLoop);

	push	ebp
	mov	ecx, ebx
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	esi, eax

; 4282 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_GENERAL && pLoopUnit->GetID() != pUnit->GetID())

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN18@ExecuteAdm
	mov	eax, DWORD PTR [esi+100]
	cmp	eax, DWORD PTR [edi+100]
	jne	$LN26@ExecuteAdm
$LN18@ExecuteAdm:

; 4283 : 				{
; 4284 : 					bSkipCity = true;
; 4285 : 					break;
; 4286 : 				}
; 4287 : 				else if(pLoopUnit->AI_getUnitAIType() == UNITAI_ADMIRAL && pLoopUnit->GetID() != pUnit->GetID())

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN20@ExecuteAdm
	mov	esi, DWORD PTR [esi+100]
	cmp	esi, DWORD PTR [edi+100]
	jne	$LN26@ExecuteAdm
$LN20@ExecuteAdm:

; 4275 : #ifdef AUI_WARNING_FIXES
; 4276 : 			for (uint iUnitLoop = 0; iUnitLoop < pTarget->getNumUnits(); iUnitLoop++)
; 4277 : #else
; 4278 : 			for(int iUnitLoop = 0; iUnitLoop < pTarget->getNumUnits(); iUnitLoop++)

	mov	ecx, ebx
	inc	ebp
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	ebp, eax
	jl	SHORT $LL21@ExecuteAdm
	mov	esi, DWORD PTR _pLoopCity$227949[esp+676]
$LN409@ExecuteAdm:

; 4288 : 				{
; 4289 : 					bSkipCity = true;
; 4290 : 					break;
; 4291 : 				}
; 4292 : 			}
; 4293 : 			if(bSkipCity)
; 4294 : 			{
; 4295 : 				continue;
; 4296 : 			}
; 4297 : 
; 4298 : 			int iTurns = TurnsToReachTarget(pUnit, pLoopCity->plot());

	push	0
	push	0
	push	0
	mov	ecx, esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, edi
	mov	DWORD PTR $T273156[esp+700], esp
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 4299 : 
; 4300 : 			// Don't go here if I'm not in a city currently and this city is not reachable by normal movement
; 4301 : 			if (bNotAtFriendlyCity)

	cmp	BYTE PTR _bNotAtFriendlyCity$227948[esp+676], 0
	mov	ebp, eax
	je	SHORT $LN13@ExecuteAdm

; 4302 : 			{
; 4303 : 				if (iTurns == MAX_INT)

	cmp	ebp, 2147483647				; 7fffffffH
	je	$LN26@ExecuteAdm
$LN13@ExecuteAdm:

; 4304 : 				{
; 4305 : 					continue;
; 4306 : 				}
; 4307 : 			}
; 4308 : 
; 4309 : 			// Weight is size of largest adjacent ocean
; 4310 : 			int iWeight = pTarget->GetSizeLargestAdjacentWater();

	mov	ecx, ebx
	call	?GetSizeLargestAdjacentWater@CvPlot@@QBEHXZ ; CvPlot::GetSizeLargestAdjacentWater

; 4311 : 
; 4312 : 			// If this city is damaged, divide weight by the damage level
; 4313 : 			if (pLoopCity->getDamage() > 0)

	mov	ecx, esi
	mov	ebx, eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	test	eax, eax
	jle	SHORT $LN12@ExecuteAdm

; 4314 : 			{
; 4315 : 				iWeight /= pLoopCity->getDamage();

	mov	ecx, esi
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	ecx, eax
	mov	eax, ebx
	cdq
	idiv	ecx
	mov	ebx, eax
$LN12@ExecuteAdm:

; 4316 : 			}
; 4317 : 
; 4318 : 			// Subtract off turns to reach
; 4319 : 			if (iTurns != MAX_INT)

	cmp	ebp, 2147483647				; 7fffffffH
	je	SHORT $LN11@ExecuteAdm

; 4320 : 			{
; 4321 : 				iWeight -= iTurns;

	sub	ebx, ebp
$LN11@ExecuteAdm:

; 4322 : 			}
; 4323 : 
; 4324 : 			weightedCityList.push_back(pLoopCity, iWeight);

	mov	eax, DWORD PTR _weightedCityList$228166[esp+684]
	mov	BYTE PTR _weightedCityList$228166[esp+1200], 0
	cmp	DWORD PTR _weightedCityList$228166[esp+680], eax
	jne	SHORT $LN211@ExecuteAdm
	push	eax
	lea	ecx, DWORD PTR _weightedCityList$228166[esp+680]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvCity *,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN211@ExecuteAdm:
	mov	edx, DWORD PTR _weightedCityList$228166[esp+676]
	mov	eax, DWORD PTR _weightedCityList$228166[esp+680]
	lea	eax, DWORD PTR [edx+eax*8]
	test	eax, eax
	je	SHORT $LN214@ExecuteAdm
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ebx
$LN214@ExecuteAdm:
	inc	DWORD PTR _weightedCityList$228166[esp+680]
$LN26@ExecuteAdm:

; 4255 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	mov	edx, DWORD PTR _this$[esp+676]
	push	0
	lea	ecx, DWORD PTR _iLoopCity$227950[esp+680]
	push	ecx
	mov	ecx, DWORD PTR [edx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	mov	DWORD PTR _pLoopCity$227949[esp+676], esi
	test	esi, esi
	jne	$LL27@ExecuteAdm
$LN25@ExecuteAdm:

; 4325 : 		}
; 4326 : 
; 4327 : 		weightedCityList.SortItems();

	mov	eax, DWORD PTR _weightedCityList$228166[esp+676]
	mov	ecx, DWORD PTR _weightedCityList$228166[esp+680]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvCity@@$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvCity *,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 4328 : 		if (weightedCityList.size() > 0)

	cmp	DWORD PTR _weightedCityList$228166[esp+680], 0

; 4329 : 		{
; 4330 : 			CvCity *pChosenCity = weightedCityList.GetElement(0);
; 4331 : 
; 4332 : 			// Am I already in chosen city?
; 4333 : 			if (pUnit->plot() == pChosenCity->plot())

	mov	ecx, edi
	jle	$LN10@ExecuteAdm
	mov	eax, DWORD PTR _weightedCityList$228166[esp+676]
	mov	esi, DWORD PTR [eax]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, esi
	mov	ebx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	cmp	ebx, eax
	jne	$LN9@ExecuteAdm

; 4334 : 			{
; 4335 : 				pUnit->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4336 : 				UnitProcessed(pUnit->GetID());

	mov	ebx, DWORD PTR [edi+100]
	mov	ebp, DWORD PTR _this$[esp+676]
	lea	ecx, DWORD PTR $T273632[esp+676]
	push	ecx
	lea	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR $T273632[esp+680], ebx
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [ebp]
	push	ebx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN248@ExecuteAdm
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN248@ExecuteAdm:

; 4337 : 
; 4338 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteAdm
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteAdm

; 4339 : 				{
; 4340 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228195[esp+676]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4341 : 					strLogString.Format("Great Admiral still in most favored city of %s, X: %d, Y: %d", pChosenCity->getName().GetCString(), pChosenCity->getX(), pChosenCity->getY());

	lea	edx, DWORD PTR $T273157[esp+676]
	push	edx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+688], 2
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	ecx, DWORD PTR [esi+108]
	mov	esi, DWORD PTR [esi+96]
	push	ecx
	push	esi
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+692], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$228195[esp+688]
	push	OFFSET $SG228197
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T273157[esp+676]
	mov	BYTE PTR __$EHRec$[esp+684], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4342 : 					LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$228195[esp+676]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+680]
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4343 : 				}

	lea	ecx, DWORD PTR _strLogString$228195[esp+676]

; 4344 : 			}

	jmp	$LN419@ExecuteAdm
$LN9@ExecuteAdm:

; 4345 : 			
; 4346 : 			// Am I currently in a different friendly city?
; 4347 : 			else if (!bNotAtFriendlyCity)

	cmp	BYTE PTR _bNotAtFriendlyCity$227948[esp+676], 0

; 4348 : 			{
; 4349 : 				pUnit->PushMission(CvTypes::getMISSION_CHANGE_ADMIRAL_PORT(), pChosenCity->getX(), pChosenCity->getY());

	mov	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+96]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	jne	$LN6@ExecuteAdm
	call	?getMISSION_CHANGE_ADMIRAL_PORT@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_CHANGE_ADMIRAL_PORT
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4350 : 				pUnit->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4351 : 				UnitProcessed(pUnit->GetID());

	mov	ebx, DWORD PTR [edi+100]
	mov	ebp, DWORD PTR _this$[esp+676]
	lea	edx, DWORD PTR $T273709[esp+676]
	push	edx
	lea	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR $T273709[esp+680], ebx
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [ebp]
	push	ebx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN288@ExecuteAdm
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN288@ExecuteAdm:

; 4352 : 
; 4353 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteAdm
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteAdm

; 4354 : 				{
; 4355 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228201[esp+676]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4356 : 					strLogString.Format("Transferring Great Admiral to city of %s, X: %d, Y: %d", pChosenCity->getName().GetCString(), pChosenCity->getX(), pChosenCity->getY());

	lea	eax, DWORD PTR $T273158[esp+676]
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+688], 4
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	ecx, DWORD PTR [esi+108]
	mov	esi, DWORD PTR [esi+96]
	push	ecx
	push	esi
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+692], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogString$228201[esp+688]
	push	OFFSET $SG228203
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T273158[esp+676]
	mov	BYTE PTR __$EHRec$[esp+684], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4357 : 					LogHomelandMessage(strLogString);

	mov	ecx, DWORD PTR _this$[esp+676]
	lea	edx, DWORD PTR _strLogString$228201[esp+676]
	push	edx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4358 : 				}

	lea	ecx, DWORD PTR _strLogString$228201[esp+676]

; 4359 : 			}
; 4360 : 
; 4361 : 			// Move normally to this city
; 4362 : 			else

	jmp	$LN419@ExecuteAdm
$LN6@ExecuteAdm:

; 4363 : 			{
; 4364 : 				pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pChosenCity->getX(), pChosenCity->getY());

	call	?getMISSION_MOVE_TO@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_MOVE_TO
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 4365 : 				pUnit->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4366 : 				UnitProcessed(pUnit->GetID());

	mov	ebx, DWORD PTR [edi+100]
	mov	ebp, DWORD PTR _this$[esp+676]
	lea	eax, DWORD PTR $T273786[esp+676]
	push	eax
	lea	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR $T273786[esp+680], ebx
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [ebp]
	push	ebx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN328@ExecuteAdm
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN328@ExecuteAdm:

; 4367 : 
; 4368 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@ExecuteAdm
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@ExecuteAdm

; 4369 : 				{
; 4370 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228206[esp+676]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4371 : 					strLogString.Format("Moving Great Admiral normally to city of %s, X: %d, Y: %d", pChosenCity->getName().GetCString(), pChosenCity->getX(), pChosenCity->getY());

	lea	ecx, DWORD PTR $T273159[esp+676]
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+688], 6
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	ecx, DWORD PTR [esi+108]
	mov	esi, DWORD PTR [esi+96]
	push	ecx
	push	esi
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+692], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$228206[esp+688]
	push	OFFSET $SG228208
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T273159[esp+676]
	mov	BYTE PTR __$EHRec$[esp+684], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4372 : 					LogHomelandMessage(strLogString);

	mov	ecx, DWORD PTR _this$[esp+676]
	lea	eax, DWORD PTR _strLogString$228206[esp+676]
	push	eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4373 : 				}

	lea	ecx, DWORD PTR _strLogString$228206[esp+676]

; 4374 : 			}
; 4375 : 		}
; 4376 : 		else

	jmp	$LN419@ExecuteAdm
$LN10@ExecuteAdm:

; 4377 : 		{
; 4378 : 			pUnit->finishMoves();

	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 4379 : 			UnitProcessed(pUnit->GetID());

	mov	ebx, DWORD PTR [edi+100]
	mov	esi, DWORD PTR _this$[esp+676]
	lea	ecx, DWORD PTR $T273841[esp+676]
	push	ecx
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR $T273841[esp+680], ebx
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [esi]
	push	ebx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN358@ExecuteAdm
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN358@ExecuteAdm:

; 4380 : 
; 4381 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@ExecuteAdm
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@ExecuteAdm

; 4382 : 			{
; 4383 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$228211[esp+676]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4384 : 				strLogString.Format("No place to move Great Admiral at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLogString$228211[esp+684]
	push	OFFSET $SG228212
	push	edx
	mov	BYTE PTR __$EHRec$[esp+700], 8
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 4385 : 				LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$228211[esp+676]
	push	eax
	mov	ecx, esi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 4386 : 			}

	lea	ecx, DWORD PTR _strLogString$228211[esp+676]
$LN419@ExecuteAdm:
	mov	BYTE PTR __$EHRec$[esp+684], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteAdm:

; 4387 : 		}
; 4388 : 	}

	mov	eax, DWORD PTR _weightedCityList$228166[esp+676]
	lea	ecx, DWORD PTR _weightedCityList$228166[esp+688]
	mov	BYTE PTR __$EHRec$[esp+684], 0
	cmp	eax, ecx
	je	SHORT $LN383@ExecuteAdm
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN383@ExecuteAdm:
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+684], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	mov	esi, DWORD PTR _it$[esp+676]
	mov	ebp, DWORD PTR _this$[esp+676]
	or	ebx, -1
$LN31@ExecuteAdm:
	mov	edx, DWORD PTR [ebp+20]
	shl	edx, 4
	add	edx, DWORD PTR [ebp+16]
	add	esi, 16					; 00000010H
	mov	DWORD PTR _it$[esp+676], esi
	cmp	esi, edx
	jne	$LL32@ExecuteAdm
$LN30@ExecuteAdm:

; 4389 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+676]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 660				; 00000294H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227945[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _weightedCityList$228166[ebp]
	jmp	??1?$CvWeightedVector@PAVCvCity@@$0EA@$00@@QAE@XZ ; CvWeightedVector<CvCity *,64,1>::~CvWeightedVector<CvCity *,64,1>
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$228195[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR $T273157[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$228201[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR $T273158[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$228206[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR $T273159[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ$9:
	lea	ecx, DWORD PTR _strLogString$228211[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteAdmiralMoves
PUBLIC	?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ ; CvHomelandAI::EliminateAdjacentSentryPoints
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T274354 = -32						; size = 1
__Cat$274358 = -32					; size = 1
$T274356 = -32						; size = 1
tv578 = -32						; size = 4
_tempPoints$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ PROC ; CvHomelandAI::EliminateAdjacentSentryPoints, COMDAT
; _this$ = ecx

; 5127 : {

	push	-1
	push	__ehhandler$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 5128 : 	// First, sort the sentry points by priority
; 5129 : 	std::stable_sort(m_TargetedSentryPoints.begin(), m_TargetedSentryPoints.end());

	mov	eax, DWORD PTR [edi+2436]
	mov	ecx, DWORD PTR [edi+2432]
	mov	DWORD PTR _this$[esp+52], edi
	cmp	ecx, eax
	je	SHORT $LN208@EliminateA@2
	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 16					; 00000010H
$LN208@EliminateA@2:

; 5130 : 
; 5131 : 	// Create temporary copy of list
; 5132 : 	std::vector<CvHomelandTarget> tempPoints;

	xor	ebp, ebp
	mov	DWORD PTR _tempPoints$[esp+56], ebp
	mov	DWORD PTR _tempPoints$[esp+60], ebp
	mov	DWORD PTR _tempPoints$[esp+64], ebp

; 5133 : 	tempPoints = m_TargetedSentryPoints;

	lea	esi, DWORD PTR [edi+2428]
	push	esi
	lea	ecx, DWORD PTR _tempPoints$[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], ebp
	call	??4?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::operator=

; 5134 : 
; 5135 : 	// Clear out main list
; 5136 : 	m_TargetedSentryPoints.clear();

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, eax
	je	SHORT $LN86@EliminateA@2
	mov	BYTE PTR $T274354[esp+52], 0
	mov	edx, DWORD PTR $T274354[esp+52]
	push	edx
	mov	edx, DWORD PTR __Cat$274358[esp+56]
	push	edx
	mov	edx, DWORD PTR $T274356[esp+60]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+8], eax
$LN86@EliminateA@2:

; 5137 : 
; 5138 : 	// Loop through all points in copy
; 5139 : 	std::vector<CvHomelandTarget>::iterator it, it2;
; 5140 : 	for(it = tempPoints.begin(); it != tempPoints.end(); ++it)

	mov	ebx, DWORD PTR _tempPoints$[esp+56]
	cmp	ebx, DWORD PTR _tempPoints$[esp+60]
	je	SHORT $LN6@EliminateA@2
	npad	8
$LL127@EliminateA@2:

; 5141 : 	{
; 5142 : 		bool bFoundAdjacent = false;
; 5143 : 
; 5144 : 		// Is it adjacent to a point in the main list?
; 5145 : 		for(it2 = m_TargetedSentryPoints.begin(); it2 != m_TargetedSentryPoints.end(); ++it2)

	mov	eax, DWORD PTR [edi+2436]
	mov	esi, DWORD PTR [edi+2432]
	mov	DWORD PTR tv578[esp+52], eax
	cmp	esi, eax
	je	SHORT $LN207@EliminateA@2
	mov	edi, DWORD PTR [ebx+8]
	mov	ebp, DWORD PTR [ebx+4]
	npad	6
$LL147@EliminateA@2:

; 5146 : 		{
; 5147 : 			if(plotDistance(it->GetTargetX(), it->GetTargetY(), it2->GetTargetX(), it2->GetTargetY()) == 1)

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	push	ecx
	push	edi
	push	ebp
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	SHORT $LN209@EliminateA@2
	add	esi, 20					; 00000014H
	cmp	esi, DWORD PTR tv578[esp+52]
	jne	SHORT $LL147@EliminateA@2

; 5141 : 	{
; 5142 : 		bool bFoundAdjacent = false;
; 5143 : 
; 5144 : 		// Is it adjacent to a point in the main list?
; 5145 : 		for(it2 = m_TargetedSentryPoints.begin(); it2 != m_TargetedSentryPoints.end(); ++it2)

	mov	edi, DWORD PTR _this$[esp+52]
$LN207@EliminateA@2:

; 5148 : 			{
; 5149 : 				bFoundAdjacent = true;
; 5150 : 				break;
; 5151 : 			}
; 5152 : 		}
; 5153 : 
; 5154 : 		if(!bFoundAdjacent)
; 5155 : 		{
; 5156 : 			m_TargetedSentryPoints.push_back(*it);

	push	ebx
	lea	ecx, DWORD PTR [edi+2428]
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
	jmp	SHORT $LN7@EliminateA@2
$LN209@EliminateA@2:
	mov	edi, DWORD PTR _this$[esp+52]
$LN7@EliminateA@2:

; 5137 : 
; 5138 : 	// Loop through all points in copy
; 5139 : 	std::vector<CvHomelandTarget>::iterator it, it2;
; 5140 : 	for(it = tempPoints.begin(); it != tempPoints.end(); ++it)

	add	ebx, 20					; 00000014H
	cmp	ebx, DWORD PTR _tempPoints$[esp+60]
	jne	SHORT $LL127@EliminateA@2
	mov	ebx, DWORD PTR _tempPoints$[esp+56]
	xor	ebp, ebp
$LN6@EliminateA@2:

; 5157 : 		}
; 5158 : 	}
; 5159 : }

	cmp	ebx, ebp
	je	SHORT $LN200@EliminateA@2
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN200@EliminateA@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 36					; 00000024H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _tempPoints$[ebp]
	jmp	??1?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAE@XZ ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::~vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >
__ehhandler$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ ENDP ; CvHomelandAI::EliminateAdjacentSentryPoints
PUBLIC	??$stable_sort@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@0@Z ; std::stable_sort<CvHomelandMove *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\algorithm
;	COMDAT ??$stable_sort@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$stable_sort@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@0@Z PROC ; std::stable_sort<CvHomelandMove *>, COMDAT

; 3420 : 	_DEBUG_RANGE(_First, _Last);
; 3421 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor@2

; 3422 : 		{
; 3423 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 16					; 00000010H
$LN1@stable_sor@2:

; 3424 : 		}
; 3425 : 	}

	ret	0
??$stable_sort@PAVCvHomelandMove@@@std@@YAXPAVCvHomelandMove@@0@Z ENDP ; std::stable_sort<CvHomelandMove *>
_TEXT	ENDS
PUBLIC	??$stable_sort@PAVCvHomelandUnit@@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z@Z ; std::stable_sort<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
; Function compile flags: /Ogtpy
;	COMDAT ??$stable_sort@PAVCvHomelandUnit@@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$stable_sort@PAVCvHomelandUnit@@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z@Z PROC ; std::stable_sort<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>, COMDAT

; 3571 : 	_DEBUG_RANGE(_First, _Last);
; 3572 : 	_DEBUG_POINTER(_Pred);
; 3573 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor@3

; 3574 : 		{
; 3575 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 3576 : 			_Dist_type(_First), _Val_type(_First), _Pred);

	mov	edx, DWORD PTR __Pred$[esp-4]
	push	edx
	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 20					; 00000014H
$LN1@stable_sor@3:

; 3577 : 		}
; 3578 : 	}

	ret	0
??$stable_sort@PAVCvHomelandUnit@@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0P6A_NV1@1@Z@Z ENDP ; std::stable_sort<CvHomelandUnit *,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
_TEXT	ENDS
PUBLIC	??$stable_sort@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@0@Z ; std::stable_sort<CvHomelandUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$stable_sort@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$stable_sort@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@0@Z PROC ; std::stable_sort<CvHomelandUnit *>, COMDAT

; 3420 : 	_DEBUG_RANGE(_First, _Last);
; 3421 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor@4

; 3422 : 		{
; 3423 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 16					; 00000010H
$LN1@stable_sor@4:

; 3424 : 		}
; 3425 : 	}

	ret	0
??$stable_sort@PAVCvHomelandUnit@@@std@@YAXPAVCvHomelandUnit@@0@Z ENDP ; std::stable_sort<CvHomelandUnit *>
_TEXT	ENDS
PUBLIC	?EstablishHomelandPriorities@CvHomelandAI@@AAEXXZ ; CvHomelandAI::EstablishHomelandPriorities
EXTRN	?HasPolicyEncouragingGarrisons@CvPlayerPolicies@@QBE_NXZ:PROC ; CvPlayerPolicies::HasPolicyEncouragingGarrisons
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z:PROC ; CvFlavorManager::GetIndividualFlavor
EXTRN	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ:PROC ; CvPlayer::GetFlavorManager
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	__ftol2_sse_excpt:PROC
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
;	COMDAT ?EstablishHomelandPriorities@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv810 = -36						; size = 4
_this$ = -36						; size = 4
_iFlavorExplore$ = -32					; size = 4
_iFlavorDefense$ = -28					; size = 4
_iFlavorCulture$ = -24					; size = 4
_iFlavorExpand$ = -20					; size = 4
_iFlavorMilitaryTraining$ = -16				; size = 4
_iFlavorScience$ = -12					; size = 4
_iFlavorWonder$ = -8					; size = 4
_iFlavorGold$ = -4					; size = 4
?EstablishHomelandPriorities@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::EstablishHomelandPriorities, COMDAT
; _this$ = ecx

; 250  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 251  : 	int iPriority = 0;

	xor	esi, esi

; 252  : 	int iFlavorDefense = 0;
; 253  : 	int iFlavorOffense = 0;
; 254  : 	int iFlavorExpand = 0;
; 255  : 	int iFlavorImprove = 0;
; 256  : 	int iFlavorNavalImprove = 0;
; 257  : 	int iFlavorExplore = 0;
; 258  : 	int iFlavorGold = 0;
; 259  : 	int iFlavorScience = 0;
; 260  : 	int iFlavorWonder = 0;
; 261  : 	int iFlavorMilitaryTraining = 0;
; 262  : 	int iFlavorCulture = 0;
; 263  : 
; 264  : 	m_MovePriorityList.clear();

	mov	DWORD PTR [ebp+2100], esi

; 265  : 	m_MovePriorityTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _this$[esp+56], ebp
	xor	edi, edi
	mov	DWORD PTR _iFlavorDefense$[esp+56], esi
	mov	DWORD PTR _iFlavorExpand$[esp+56], esi
	mov	DWORD PTR _iFlavorExplore$[esp+56], esi
	mov	DWORD PTR _iFlavorGold$[esp+56], esi
	mov	DWORD PTR _iFlavorScience$[esp+56], esi
	mov	DWORD PTR _iFlavorWonder$[esp+56], esi
	mov	DWORD PTR _iFlavorMilitaryTraining$[esp+56], esi
	mov	DWORD PTR _iFlavorCulture$[esp+56], esi
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 266  : 
; 267  : 	// Find required flavor values
; 268  : 	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	xor	ebx, ebx
	mov	DWORD PTR [ebp+2392], eax
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, ebx
	jle	$LN71@EstablishH

; 251  : 	int iPriority = 0;

	mov	ebp, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
$LL73@EstablishH:

; 269  : 	{
; 270  : 		if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_DEFENSE")

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	add	eax, esi
	push	OFFSET $SG224977
	push	eax
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN70@EstablishH

; 271  : 		{
; 272  : 			iFlavorDefense = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	ecx, DWORD PTR _this$[esp+56]
	mov	ecx, DWORD PTR [ecx]
	push	ebx
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor

; 273  : 			iFlavorDefense = (int)((double)iFlavorDefense * m_fFlavorDampening);

	mov	edx, DWORD PTR _this$[esp+56]
	mov	DWORD PTR _iFlavorDefense$[esp+56], eax
	fild	DWORD PTR _iFlavorDefense$[esp+56]
	fmul	QWORD PTR [edx+2536]
	call	__ftol2_sse_excpt
	mov	DWORD PTR _iFlavorDefense$[esp+56], eax
$LN70@EstablishH:

; 274  : 		}
; 275  : 		if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_OFFENSE")

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	add	eax, esi
	push	OFFSET $SG224983
	push	eax
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN69@EstablishH

; 276  : 		{
; 277  : 			iFlavorOffense = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	ecx, DWORD PTR _this$[esp+56]
	mov	ecx, DWORD PTR [ecx]
	push	ebx
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor

; 278  : 			iFlavorOffense = (int)((double)iFlavorOffense * m_fFlavorDampening);

	jmp	$LN72@EstablishH
$LN69@EstablishH:

; 279  : 		}
; 280  : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_EXPANSION")

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [esi+edx]
	push	OFFSET $SG224990
	push	eax
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN67@EstablishH

; 281  : 		{
; 282  : 			iFlavorExpand = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	eax, DWORD PTR _this$[esp+56]
	mov	ecx, DWORD PTR [eax]
	push	ebx
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorExpand$[esp+56], eax
	jmp	$LN72@EstablishH
$LN67@EstablishH:

; 283  : 		}
; 284  : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_RECON")

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [esi+ecx]
	push	OFFSET $SG224995
	push	eax
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN65@EstablishH

; 285  : 		{
; 286  : 			iFlavorExplore = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	edx, DWORD PTR _this$[esp+56]
	mov	ecx, DWORD PTR [edx]
	push	ebx
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorExplore$[esp+56], eax

; 287  : 			iFlavorExplore = (int)((double)iFlavorExplore * m_fFlavorDampening);

	fild	DWORD PTR _iFlavorExplore$[esp+56]
	mov	eax, DWORD PTR _this$[esp+56]
	fmul	QWORD PTR [eax+2536]
	call	__ftol2_sse_excpt
	mov	DWORD PTR _iFlavorExplore$[esp+56], eax
	jmp	$LN72@EstablishH
$LN65@EstablishH:

; 288  : 		}
; 289  : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_GOLD")

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [esi+ecx]
	push	OFFSET $SG225002
	push	eax
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN63@EstablishH

; 290  : 		{
; 291  : 			iFlavorGold = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	edx, DWORD PTR _this$[esp+56]
	mov	ecx, DWORD PTR [edx]
	push	ebx
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorGold$[esp+56], eax
	jmp	$LN72@EstablishH
$LN63@EstablishH:

; 292  : 		}
; 293  : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_SCIENCE")

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	add	eax, esi
	push	OFFSET $SG225007
	push	eax
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN61@EstablishH

; 294  : 		{
; 295  : 			iFlavorScience = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	ecx, DWORD PTR _this$[esp+56]
	mov	ecx, DWORD PTR [ecx]
	push	ebx
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorScience$[esp+56], eax
	jmp	$LN72@EstablishH
$LN61@EstablishH:

; 296  : 		}
; 297  : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_WONDER")

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [esi+edx]
	push	OFFSET $SG225012
	push	eax
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN59@EstablishH

; 298  : 		{
; 299  : 			iFlavorWonder = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	eax, DWORD PTR _this$[esp+56]
	mov	ecx, DWORD PTR [eax]
	push	ebx
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorWonder$[esp+56], eax
	jmp	SHORT $LN72@EstablishH
$LN59@EstablishH:

; 300  : 		}
; 301  : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_MILITARY_TRAINING")

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [esi+ecx]
	push	OFFSET $SG225017
	push	eax
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN57@EstablishH

; 302  : 		{
; 303  : 			iFlavorMilitaryTraining = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	edx, DWORD PTR _this$[esp+56]
	mov	ecx, DWORD PTR [edx]
	push	ebx
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorMilitaryTraining$[esp+56], eax
	jmp	SHORT $LN72@EstablishH
$LN57@EstablishH:

; 304  : 		}
; 305  : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_CULTURE")

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	add	eax, esi
	push	OFFSET $SG225022
	push	eax
	call	ebp
	add	esp, 8
	test	al, al
	je	SHORT $LN72@EstablishH

; 306  : 		{
; 307  : 			iFlavorCulture = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	ecx, DWORD PTR _this$[esp+56]
	mov	ecx, DWORD PTR [ecx]
	push	ebx
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	DWORD PTR _iFlavorCulture$[esp+56], eax
$LN72@EstablishH:
	inc	ebx
	add	esi, 28					; 0000001cH
	cmp	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	$LL73@EstablishH
	mov	ebp, DWORD PTR _this$[esp+56]
	mov	esi, DWORD PTR _iFlavorCulture$[esp+56]
$LN71@EstablishH:

; 308  : 		}
; 309  : 	}
; 310  : 
; 311  : 	// Loop through each possible homeland move (other than "none" or "unassigned")
; 312  : 	for(int iI = AI_HOMELAND_MOVE_UNASSIGNED + 1; iI < NUM_AI_HOMELAND_MOVES; iI++)

	xor	ebx, ebx
	mov	DWORD PTR tv810[esp+56], ebx
$LL54@EstablishH:

; 313  : 	{
; 314  : 		// Set base value
; 315  : 		switch((AIHomelandMove)iI)

	cmp	ebx, 31					; 0000001fH
	ja	$LN50@EstablishH
	jmp	DWORD PTR $LN196@EstablishH[ebx*4]
$LN49@EstablishH:

; 316  : 		{
; 317  : 		case AI_HOMELAND_MOVE_EXPLORE:
; 318  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_EXPLORE();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2596

; 319  : 			break;

	jmp	$LN50@EstablishH
$LN48@EstablishH:

; 320  : 		case AI_HOMELAND_MOVE_EXPLORE_SEA:
; 321  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_EXPLORE_SEA();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2600

; 322  : 			break;

	jmp	$LN50@EstablishH
$LN47@EstablishH:

; 323  : 		case AI_HOMELAND_MOVE_SETTLE:
; 324  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_SETTLE();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2576

; 325  : 			break;

	jmp	$LN50@EstablishH
$LN46@EstablishH:

; 326  : 		case AI_HOMELAND_MOVE_GARRISON:
; 327  : 			// Garrisons must beat out sentries if policies encourage garrisoning
; 328  : 			if(m_pPlayer->GetPlayerPolicies()->HasPolicyEncouragingGarrisons())

	mov	ecx, DWORD PTR [ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicyEncouragingGarrisons@CvPlayerPolicies@@QBE_NXZ ; CvPlayerPolicies::HasPolicyEncouragingGarrisons
	test	al, al
	je	SHORT $LN45@EstablishH

; 329  : 			{
; 330  : 				iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_SENTRY() + 1;

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2604
	inc	edi

; 331  : 			}
; 332  : 			else

	jmp	$LN50@EstablishH
$LN45@EstablishH:

; 333  : 			{
; 334  : 				iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_GARRISON();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2612

; 335  : 			}
; 336  : 			break;

	jmp	$LN50@EstablishH
$LN43@EstablishH:

; 337  : 		case AI_HOMELAND_MOVE_HEAL:
; 338  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_HEAL();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2580

; 339  : 			break;

	jmp	$LN50@EstablishH
$LN42@EstablishH:

; 340  : 		case AI_HOMELAND_MOVE_TO_SAFETY:
; 341  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_TO_SAFETY();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2584

; 342  : 			break;

	jmp	$LN50@EstablishH
$LN41@EstablishH:

; 343  : 		case AI_HOMELAND_MOVE_MOBILE_RESERVE:
; 344  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_MOBILE_RESERVE();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2608

; 345  : 			break;

	jmp	$LN50@EstablishH
$LN40@EstablishH:

; 346  : 		case AI_HOMELAND_MOVE_SENTRY:
; 347  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_SENTRY();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2604

; 348  : 			break;

	jmp	$LN50@EstablishH
$LN39@EstablishH:

; 349  : 		case AI_HOMELAND_MOVE_WORKER:
; 350  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_WORKER();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2588

; 351  : 			break;

	jmp	$LN50@EstablishH
$LN38@EstablishH:

; 352  : 		case AI_HOMELAND_MOVE_WORKER_SEA:
; 353  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_WORKER_SEA();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2592

; 354  : 			break;

	jmp	$LN50@EstablishH
$LN37@EstablishH:

; 355  : 		case AI_HOMELAND_MOVE_PATROL:
; 356  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_PATROL();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2616

; 357  : 			break;

	jmp	$LN50@EstablishH
$LN36@EstablishH:

; 358  : 		case AI_HOMELAND_MOVE_UPGRADE:
; 359  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_UPGRADE();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2620

; 360  : 			break;

	jmp	$LN50@EstablishH
$LN35@EstablishH:

; 361  : 		case AI_HOMELAND_MOVE_ANCIENT_RUINS:
; 362  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_ANCIENT_RUINS();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2624

; 363  : 			break;

	jmp	$LN50@EstablishH
$LN34@EstablishH:

; 364  : 		case AI_HOMELAND_MOVE_GARRISON_CITY_STATE:
; 365  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_GARRISON_CITY_STATE();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2628

; 366  : 			break;

	jmp	$LN50@EstablishH
$LN33@EstablishH:

; 367  : 		case AI_HOMELAND_MOVE_WRITER:
; 368  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_WRITER();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2632

; 369  : 			break;

	jmp	$LN50@EstablishH
$LN32@EstablishH:

; 370  : 		case AI_HOMELAND_MOVE_ARTIST_GOLDEN_AGE:
; 371  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_ARTIST();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2636

; 372  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN31@EstablishH:

; 373  : 		case AI_HOMELAND_MOVE_MUSICIAN:
; 374  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_MUSICIAN();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2640

; 375  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN30@EstablishH:

; 376  : 		case AI_HOMELAND_MOVE_SCIENTIST_FREE_TECH:
; 377  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_SCIENTIST_FREE_TECH();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2644

; 378  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN29@EstablishH:

; 379  : 		case AI_HOMELAND_MOVE_ENGINEER_HURRY:
; 380  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_ENGINEER_HURRY();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2648

; 381  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN28@EstablishH:

; 382  : 		case AI_HOMELAND_MOVE_GENERAL_GARRISON:
; 383  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_GENERAL_GARRISON();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2652

; 384  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN27@EstablishH:

; 385  : 		case AI_HOMELAND_MOVE_ADMIRAL_GARRISON:
; 386  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_ADMIRAL_GARRISON();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2656

; 387  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN26@EstablishH:

; 388  : 		case AI_HOMELAND_MOVE_PROPHET_RELIGION:
; 389  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_PROPHET_RELIGION();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2660

; 390  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN25@EstablishH:

; 391  : 		case AI_HOMELAND_MOVE_MISSIONARY:
; 392  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_MISSIONARY();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2664

; 393  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN24@EstablishH:

; 394  : 		case AI_HOMELAND_MOVE_INQUISITOR:
; 395  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_INQUISITOR();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2668

; 396  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN23@EstablishH:

; 397  : 		case AI_HOMELAND_MOVE_SPACESHIP_PART:
; 398  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_SPACESHIP_PART();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2672

; 399  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN22@EstablishH:

; 400  : 		case AI_HOMELAND_MOVE_ADD_SPACESHIP_PART:
; 401  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_ADD_SPACESHIP_PART();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2676

; 402  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN21@EstablishH:

; 403  : 		case AI_HOMELAND_MOVE_AIRCRAFT_TO_THE_FRONT:
; 404  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_AIRCRAFT_TO_THE_FRONT();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2680

; 405  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN20@EstablishH:

; 406  : 		case AI_HOMELAND_MOVE_TREASURE:
; 407  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_TREASURE();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2684

; 408  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN19@EstablishH:

; 409  : 		case AI_HOMELAND_MOVE_TRADE_UNIT:
; 410  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_TRADE_UNIT();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2688

; 411  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN18@EstablishH:

; 412  : 		case AI_HOMELAND_MOVE_ARCHAEOLOGIST:
; 413  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_ARCHAEOLOGIST();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2692

; 414  : 			break;

	jmp	SHORT $LN50@EstablishH
$LN17@EstablishH:

; 415  : 		case AI_HOMELAND_MOVE_AIRLIFT:
; 416  : 			iPriority = GC.getAI_HOMELAND_MOVE_PRIORITY_AIRLIFT();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2696
$LN50@EstablishH:

; 417  : 			break;
; 418  : 		}
; 419  : 
; 420  : 		// Make sure base priority is not negative
; 421  : 		if(iPriority >= 0)

	test	edi, edi
	jl	SHORT $LN53@EstablishH

; 422  : 		{
; 423  : 			// Now add in the appropriate flavor value
; 424  : 			switch((AIHomelandMove)iI)

	cmp	ebx, 30					; 0000001eH
	ja	SHORT $LN14@EstablishH
	movzx	edx, BYTE PTR $LN194@EstablishH[ebx]
	jmp	DWORD PTR $LN197@EstablishH[edx*4]
$LN13@EstablishH:

; 425  : 			{
; 426  : 				// Defensive moves
; 427  : 			case AI_HOMELAND_MOVE_GARRISON:
; 428  : 			case AI_HOMELAND_MOVE_HEAL:
; 429  : 			case AI_HOMELAND_MOVE_TO_SAFETY:
; 430  : 			case AI_HOMELAND_MOVE_MOBILE_RESERVE:
; 431  : 			case AI_HOMELAND_MOVE_SENTRY:
; 432  : 			case AI_HOMELAND_MOVE_GARRISON_CITY_STATE:
; 433  : 			case AI_HOMELAND_MOVE_GENERAL_GARRISON:
; 434  : 			case AI_HOMELAND_MOVE_ADMIRAL_GARRISON:
; 435  : 			case AI_HOMELAND_MOVE_AIRCRAFT_TO_THE_FRONT:
; 436  : 			case AI_HOMELAND_MOVE_TREASURE:
; 437  : 
; 438  : 				// Here so they remain same priority relative to AI_HOMELAND_MOVE_TO_SAFETY
; 439  : 			case AI_HOMELAND_MOVE_MISSIONARY:
; 440  : 			case AI_HOMELAND_MOVE_INQUISITOR:
; 441  : 			case AI_HOMELAND_MOVE_PROPHET_RELIGION:
; 442  : 			case AI_HOMELAND_MOVE_SPACESHIP_PART:
; 443  : 			case AI_HOMELAND_MOVE_ADD_SPACESHIP_PART:
; 444  : 				iPriority += iFlavorDefense;

	add	edi, DWORD PTR _iFlavorDefense$[esp+56]

; 445  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN12@EstablishH:

; 446  : 
; 447  : 				// Other miscellaneous types
; 448  : 			case AI_HOMELAND_MOVE_EXPLORE:
; 449  : 			case AI_HOMELAND_MOVE_EXPLORE_SEA:
; 450  : 				iPriority += iFlavorExplore;

	add	edi, DWORD PTR _iFlavorExplore$[esp+56]

; 451  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN11@EstablishH:

; 452  : 
; 453  : 			case AI_HOMELAND_MOVE_SETTLE:
; 454  : 				iPriority += iFlavorExpand;

	add	edi, DWORD PTR _iFlavorExpand$[esp+56]

; 455  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN8@EstablishH:

; 456  : 
; 457  : 			case AI_HOMELAND_MOVE_WORKER:
; 458  : 				iPriority += iFlavorImprove;
; 459  : 				break;
; 460  : 
; 461  : 			case AI_HOMELAND_MOVE_WORKER_SEA:
; 462  : 				iPriority += iFlavorNavalImprove;
; 463  : 				break;
; 464  : 
; 465  : 			case AI_HOMELAND_MOVE_UPGRADE:
; 466  : 				iPriority += iFlavorMilitaryTraining;

	add	edi, DWORD PTR _iFlavorMilitaryTraining$[esp+56]

; 467  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN7@EstablishH:

; 468  : 
; 469  : 			case AI_HOMELAND_MOVE_WRITER:
; 470  : 				iPriority += iFlavorCulture;

	add	edi, esi

; 471  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN3@EstablishH:

; 472  : 
; 473  : 			case AI_HOMELAND_MOVE_ARTIST_GOLDEN_AGE:
; 474  : 				iPriority += iFlavorCulture;
; 475  : 				break;
; 476  : 
; 477  : 			case AI_HOMELAND_MOVE_MUSICIAN:
; 478  : 				iPriority += iFlavorCulture;
; 479  : 				break;
; 480  : 
; 481  : 			case AI_HOMELAND_MOVE_ANCIENT_RUINS:
; 482  : 				iPriority += iFlavorExplore;
; 483  : 				break;
; 484  : 
; 485  : 			case AI_HOMELAND_MOVE_SCIENTIST_FREE_TECH:
; 486  : 				iPriority += iFlavorScience;

	add	edi, DWORD PTR _iFlavorScience$[esp+56]

; 487  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN2@EstablishH:

; 488  : 
; 489  : 			case AI_HOMELAND_MOVE_ENGINEER_HURRY:
; 490  : 				iPriority += iFlavorWonder;

	add	edi, DWORD PTR _iFlavorWonder$[esp+56]

; 491  : 				break;

	jmp	SHORT $LN14@EstablishH
$LN1@EstablishH:

; 492  : 
; 493  : 			case AI_HOMELAND_MOVE_TRADE_UNIT:
; 494  : 				iPriority += iFlavorGold;

	add	edi, DWORD PTR _iFlavorGold$[esp+56]
$LN14@EstablishH:

; 495  : 				break;
; 496  : 			}
; 497  : 
; 498  : 			// Store off this move and priority
; 499  : 			CvHomelandMove move;
; 500  : 			move.m_eMoveType = (AIHomelandMove)iI;
; 501  : 			move.m_iPriority = iPriority;
; 502  : 			m_MovePriorityList.push_back(move);

	mov	eax, DWORD PTR [ebp+2104]
	lea	esi, DWORD PTR [ebp+2096]
	inc	ebx
	mov	BYTE PTR [esi+292], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN172@EstablishH
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandMove@@$0CD@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandMove,35,1,297,0>::GrowSize
$LN172@EstablishH:
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN175@EstablishH
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], edi
$LN175@EstablishH:
	inc	DWORD PTR [esi+4]
	mov	ebx, DWORD PTR tv810[esp+56]
	mov	esi, DWORD PTR _iFlavorCulture$[esp+56]
$LN53@EstablishH:
	inc	ebx
	lea	edx, DWORD PTR [ebx+1]
	cmp	edx, 33					; 00000021H
	mov	DWORD PTR tv810[esp+56], ebx
	jl	$LL54@EstablishH

; 503  : 		}
; 504  : 	}
; 505  : 
; 506  : 	// Now sort the moves in priority order
; 507  : 	std::stable_sort(m_MovePriorityList.begin(), m_MovePriorityList.end());

	mov	eax, DWORD PTR [ebp+2096]
	mov	ecx, DWORD PTR [ebp+2100]
	mov	edx, eax
	lea	ecx, DWORD PTR [edx+ecx*8]
	cmp	eax, ecx
	je	SHORT $LN183@EstablishH
	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAVCvHomelandMove@@HV1@@std@@YAXPAVCvHomelandMove@@0PAH0@Z ; std::_Stable_sort<CvHomelandMove *,int,CvHomelandMove>
	add	esp, 16					; 00000010H
$LN183@EstablishH:

; 508  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN196@EstablishH:
	DD	$LN49@EstablishH
	DD	$LN48@EstablishH
	DD	$LN47@EstablishH
	DD	$LN46@EstablishH
	DD	$LN43@EstablishH
	DD	$LN42@EstablishH
	DD	$LN41@EstablishH
	DD	$LN40@EstablishH
	DD	$LN39@EstablishH
	DD	$LN38@EstablishH
	DD	$LN37@EstablishH
	DD	$LN36@EstablishH
	DD	$LN35@EstablishH
	DD	$LN34@EstablishH
	DD	$LN33@EstablishH
	DD	$LN32@EstablishH
	DD	$LN31@EstablishH
	DD	$LN30@EstablishH
	DD	$LN50@EstablishH
	DD	$LN29@EstablishH
	DD	$LN28@EstablishH
	DD	$LN27@EstablishH
	DD	$LN23@EstablishH
	DD	$LN21@EstablishH
	DD	$LN20@EstablishH
	DD	$LN26@EstablishH
	DD	$LN25@EstablishH
	DD	$LN24@EstablishH
	DD	$LN19@EstablishH
	DD	$LN18@EstablishH
	DD	$LN22@EstablishH
	DD	$LN17@EstablishH
$LN197@EstablishH:
	DD	$LN12@EstablishH
	DD	$LN11@EstablishH
	DD	$LN13@EstablishH
	DD	$LN14@EstablishH
	DD	$LN8@EstablishH
	DD	$LN7@EstablishH
	DD	$LN3@EstablishH
	DD	$LN2@EstablishH
	DD	$LN1@EstablishH
	DD	$LN14@EstablishH
$LN194@EstablishH:
	DB	0
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	3
	DB	3
	DB	9
	DB	4
	DB	0
	DB	2
	DB	5
	DB	5
	DB	5
	DB	6
	DB	9
	DB	7
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	8
	DB	9
	DB	2
?EstablishHomelandPriorities@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::EstablishHomelandPriorities
_TEXT	ENDS
PUBLIC	?FindHomelandTargets@CvHomelandAI@@AAEXXZ	; CvHomelandAI::FindHomelandTargets
EXTRN	?isRoute@CvPlot@@QBE_NXZ:PROC			; CvPlot::isRoute
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?GetClosestFriendlyCity@CvPlayer@@QAEPAVCvCity@@AAVCvPlot@@H@Z:PROC ; CvPlayer::GetClosestFriendlyCity
EXTRN	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z:PROC ; CvPlot::defenseModifier
EXTRN	?GetNumAdjacentDifferentTeam@CvPlot@@QBEHW4TeamTypes@@_N@Z:PROC ; CvPlot::GetNumAdjacentDifferentTeam
EXTRN	?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z:PROC ; CvPlot::isAdjacentTeam
EXTRN	?isUnit@CvPlot@@QBE_NXZ:PROC			; CvPlot::isUnit
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
EXTRN	?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::isVisibleOtherUnit
EXTRN	?IsPlayerMadeNoDiggingPromise@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsPlayerMadeNoDiggingPromise
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceTrade
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?IsWater@CvBuildInfo@@QBE_NXZ:PROC		; CvBuildInfo::IsWater
EXTRN	?getImprovement@CvBuildInfo@@QBEHXZ:PROC	; CvBuildInfo::getImprovement
EXTRN	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ:PROC	; CvPlot::getWorkingCity
EXTRN	?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getNonObsoleteResourceType
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?getThreatValue@CvCity@@QAEHXZ:PROC		; CvCity::getThreatValue
EXTRN	?isUnderTacticalControl@CvUnit@@QBE_NXZ:PROC	; CvUnit::isUnderTacticalControl
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?FindHomelandTargets@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindHomelandTargets@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?FindHomelandTargets@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindHomelandTargets@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?FindHomelandTargets@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
$T276180 = -64						; size = 4
tv1873 = -60						; size = 4
_this$ = -56						; size = 4
$T276155 = -52						; size = 1
$T275966 = -52						; size = 1
$T275772 = -52						; size = 1
$T275563 = -52						; size = 1
$T275400 = -52						; size = 1
$T275210 = -52						; size = 1
$T275021 = -52						; size = 1
tv426 = -52						; size = 4
_theMap$ = -48						; size = 4
__Cat$276159 = -44					; size = 1
$T276157 = -44						; size = 1
__Cat$275970 = -44					; size = 1
$T275968 = -44						; size = 1
__Cat$275776 = -44					; size = 1
$T275774 = -44						; size = 1
__Cat$275568 = -44					; size = 1
$T275565 = -44						; size = 1
__Cat$275404 = -44					; size = 1
$T275402 = -44						; size = 1
__Cat$275214 = -44					; size = 1
$T275212 = -44						; size = 1
__Cat$275025 = -44					; size = 1
$T275023 = -44						; size = 1
_eNonObsoleteResource$225115 = -44			; size = 4
_pUnit$225108 = -40					; size = 8
_newTarget$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
?FindHomelandTargets@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::FindHomelandTargets, COMDAT
; _this$ = ecx

; 512  : {

	push	-1
	push	__ehhandler$?FindHomelandTargets@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 52					; 00000034H
	push	ebx
	mov	ebx, ecx

; 513  : 	int iI;
; 514  : 	CvPlot* pLoopPlot;
; 515  : 	CvHomelandTarget newTarget;
; 516  : 
; 517  : 	// Clear out target lists since we rebuild them each turn
; 518  : 	m_TargetedCities.clear();

	mov	eax, DWORD PTR [ebx+2420]
	mov	ecx, DWORD PTR [ebx+2416]
	push	esi
	or	esi, -1
	push	edi
	xor	edi, edi
	mov	DWORD PTR _this$[esp+76], ebx
	mov	DWORD PTR _newTarget$[esp+76], 1
	mov	DWORD PTR _newTarget$[esp+80], esi
	mov	DWORD PTR _newTarget$[esp+84], esi
	mov	DWORD PTR _newTarget$[esp+88], edi
	mov	DWORD PTR _newTarget$[esp+92], edi
	cmp	ecx, eax
	je	SHORT $LN58@FindHomela
	mov	BYTE PTR $T275021[esp+76], 0
	mov	edx, DWORD PTR $T275021[esp+76]
	push	edx
	mov	edx, DWORD PTR __Cat$275025[esp+80]
	push	edx
	mov	edx, DWORD PTR $T275023[esp+84]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebx+2420], eax
$LN58@FindHomela:

; 519  : 	m_TargetedSentryPoints.clear();

	mov	eax, DWORD PTR [ebx+2436]
	mov	ecx, DWORD PTR [ebx+2432]
	cmp	ecx, eax
	je	SHORT $LN97@FindHomela
	mov	BYTE PTR $T275210[esp+76], 0
	mov	edx, DWORD PTR $T275210[esp+76]
	push	edx
	mov	edx, DWORD PTR __Cat$275214[esp+80]
	push	edx
	mov	edx, DWORD PTR $T275212[esp+84]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebx+2436], eax
$LN97@FindHomela:

; 520  : 	m_TargetedForts.clear();

	mov	eax, DWORD PTR [ebx+2452]
	mov	ecx, DWORD PTR [ebx+2448]
	cmp	ecx, eax
	je	SHORT $LN136@FindHomela
	mov	BYTE PTR $T275400[esp+76], 0
	mov	edx, DWORD PTR $T275400[esp+76]
	push	edx
	mov	edx, DWORD PTR __Cat$275404[esp+80]
	push	edx
	mov	edx, DWORD PTR $T275402[esp+84]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebx+2452], eax
$LN136@FindHomela:

; 521  : 	m_TargetedNavalResources.clear();

	mov	eax, DWORD PTR [ebx+2468]
	mov	ecx, DWORD PTR [ebx+2464]
	cmp	ecx, eax
	je	SHORT $LN175@FindHomela
	mov	BYTE PTR $T275563[esp+76], 0
	mov	edx, DWORD PTR $T275563[esp+76]
	push	edx
	mov	edx, DWORD PTR __Cat$275568[esp+80]
	push	edx
	mov	edx, DWORD PTR $T275565[esp+84]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebx+2468], eax
$LN175@FindHomela:

; 522  : 	m_TargetedHomelandRoads.clear();

	mov	eax, DWORD PTR [ebx+2484]
	mov	ecx, DWORD PTR [ebx+2480]
	cmp	ecx, eax
	je	SHORT $LN214@FindHomela
	mov	BYTE PTR $T275772[esp+76], 0
	mov	edx, DWORD PTR $T275772[esp+76]
	push	edx
	mov	edx, DWORD PTR __Cat$275776[esp+80]
	push	edx
	mov	edx, DWORD PTR $T275774[esp+84]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebx+2484], eax
$LN214@FindHomela:

; 523  : 	m_TargetedAncientRuins.clear();

	mov	eax, DWORD PTR [ebx+2500]
	mov	ecx, DWORD PTR [ebx+2496]
	cmp	ecx, eax
	je	SHORT $LN253@FindHomela
	mov	BYTE PTR $T275966[esp+76], 0
	mov	edx, DWORD PTR $T275966[esp+76]
	push	edx
	mov	edx, DWORD PTR __Cat$275970[esp+80]
	push	edx
	mov	edx, DWORD PTR $T275968[esp+84]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebx+2500], eax
$LN253@FindHomela:

; 524  : 	m_TargetedAntiquitySites.clear();

	mov	eax, DWORD PTR [ebx+2516]
	mov	ecx, DWORD PTR [ebx+2512]
	cmp	ecx, eax
	je	SHORT $LN292@FindHomela
	mov	BYTE PTR $T276155[esp+76], 0
	mov	edx, DWORD PTR $T276155[esp+76]
	push	edx
	mov	edx, DWORD PTR __Cat$276159[esp+80]
	push	edx
	mov	edx, DWORD PTR $T276157[esp+84]
	push	edx
	push	ecx
	push	eax
	push	eax
	call	??$_Copy_opt@PAVCvHomelandTarget@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvHomelandTarget@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvHomelandTarget *,CvHomelandTarget *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebx+2516], eax
$LN292@FindHomela:

; 525  : 
; 526  : 	TeamTypes eTeam = m_pPlayer->getTeam();

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+44]
	push	ebp
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN321@FindHomela
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ebp, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T276180[esp+80], ebp
	jmp	SHORT $LN322@FindHomela
$LN321@FindHomela:
	mov	DWORD PTR $T276180[esp+80], esi
	mov	ebp, esi
$LN322@FindHomela:

; 527  : 
; 528  : 	// Look at every tile on map
; 529  : 	CvMap& theMap = GC.getMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 530  : 	int iNumPlots = theMap.numPlots();

	mov	eax, DWORD PTR [ecx+4028]

; 531  : 	for(iI = 0; iI < iNumPlots; iI++)

	cmp	eax, edi
	mov	DWORD PTR _theMap$[esp+80], ecx
	jle	$LN36@FindHomela
	mov	DWORD PTR tv1873[esp+80], edi
	mov	DWORD PTR tv426[esp+80], eax
	jmp	SHORT $LN38@FindHomela
	npad	10
$LL560@FindHomela:

; 527  : 
; 528  : 	// Look at every tile on map
; 529  : 	CvMap& theMap = GC.getMap();

	mov	ecx, DWORD PTR _theMap$[esp+80]
$LN38@FindHomela:

; 532  : 	{
; 533  : 		pLoopPlot = theMap.plotByIndexUnchecked(iI);
; 534  : 
; 535  : 		if(pLoopPlot->isVisible(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR [ecx+4068]
	mov	eax, DWORD PTR [eax+44]
	add	esi, DWORD PTR tv1873[esp+80]
	cmp	eax, 63					; 0000003fH
	ja	$LN37@FindHomela
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	cmp	eax, -1
	je	$LN37@FindHomela
	mov	ecx, DWORD PTR [esi+156]
	cmp	WORD PTR [ecx+eax*2], 0
	setg	al
	test	al, al
	je	$LN37@FindHomela

; 536  : 		{
; 537  : 			// Have a ...
; 538  : 			// ... friendly city?
; 539  : 			CvCity* pCity = pLoopPlot->getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	$LN557@FindHomela
	cmp	eax, 64					; 00000040H
	jge	$LN557@FindHomela
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	edi, eax

; 540  : 			if(pCity != NULL)

	test	edi, edi
	je	$LN557@FindHomela

; 541  : 			{
; 542  : 				if(m_pPlayer->GetID() == pCity->getOwner())

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+44]
	cmp	ecx, DWORD PTR [edi+84]
	jne	$LN37@FindHomela

; 543  : 				{
; 544  : 					// Don't send another unit if the tactical AI already sent a garrison here
; 545  : 					UnitHandle pUnit = pLoopPlot->getBestDefender(m_pPlayer->GetID());

	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, ecx
	push	-1
	push	eax
	lea	eax, DWORD PTR _pUnit$225108[esp+108]
	push	eax
	mov	ecx, esi
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender

; 546  : 					if(!pUnit || !pUnit->isUnderTacticalControl())

	mov	ecx, DWORD PTR _pUnit$225108[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	test	ecx, ecx
	je	SHORT $LN31@FindHomela
	call	?isUnderTacticalControl@CvUnit@@QBE_NXZ	; CvUnit::isUnderTacticalControl
	test	al, al
	jne	SHORT $LN32@FindHomela
$LN31@FindHomela:

; 547  : 					{
; 548  : 						newTarget.SetTargetType(AI_HOMELAND_TARGET_CITY);
; 549  : 						newTarget.SetTargetX(pLoopPlot->getX());

	movsx	ecx, WORD PTR [esi]

; 550  : 						newTarget.SetTargetY(pLoopPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	mov	DWORD PTR _newTarget$[esp+84], ecx

; 551  : 						newTarget.SetAuxData((void*)pCity);
; 552  : 						newTarget.SetAuxIntData(pCity->getThreatValue());

	mov	ecx, edi
	mov	DWORD PTR _newTarget$[esp+80], 1
	mov	DWORD PTR _newTarget$[esp+88], edx
	mov	DWORD PTR _newTarget$[esp+92], edi
	call	?getThreatValue@CvCity@@QAEHXZ		; CvCity::getThreatValue
	mov	DWORD PTR _newTarget$[esp+96], eax

; 553  : 						m_TargetedCities.push_back(newTarget);

	lea	eax, DWORD PTR _newTarget$[esp+80]
	push	eax
	lea	ecx, DWORD PTR [ebx+2412]
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
$LN32@FindHomela:

; 554  : 					}
; 555  : 				}

	mov	ecx, DWORD PTR _pUnit$225108[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], -1
	test	ecx, ecx
	je	$LN37@FindHomela
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 556  : 			}
; 557  : 
; 558  : 			// ... naval resource?
; 559  : 			else if(pLoopPlot->isWater() &&

	jmp	$LN37@FindHomela
$LN557@FindHomela:

; 560  : 			        pLoopPlot->getImprovementType() == NO_IMPROVEMENT)

	cmp	BYTE PTR [esi+5], 3
	jne	$LN561@FindHomela
	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	jne	$LN561@FindHomela

; 561  : 			{
; 562  : 				ResourceTypes eNonObsoleteResource = pLoopPlot->getNonObsoleteResourceType(eTeam);

	push	ebp
	mov	ecx, esi
	call	?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getNonObsoleteResourceType
	mov	DWORD PTR _eNonObsoleteResource$225115[esp+80], eax

; 563  : 				if(eNonObsoleteResource != NO_RESOURCE)

	cmp	eax, -1
	je	$LN37@FindHomela

; 564  : 				{
; 565  : 					CvCity* pWorkingCity = pLoopPlot->getWorkingCity();

	mov	ecx, esi
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity

; 566  : 					if(NULL != pWorkingCity && pWorkingCity->getOwner() == m_pPlayer->GetID())

	test	eax, eax
	je	$LN37@FindHomela
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+84]
	cmp	edx, DWORD PTR [ecx+44]
	jne	$LN37@FindHomela

; 567  : 					{
; 568  : 						// Find proper improvement
; 569  : 						BuildTypes eBuild;
; 570  : #ifdef AUI_WARNING_FIXES
; 571  : 						for (uint iJ = 0; iJ < GC.getNumBuildInfos(); iJ++)
; 572  : #else
; 573  : 						for(int iJ = 0; iJ < GC.getNumBuildInfos(); iJ++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	edi, edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	$LN37@FindHomela
$LL554@FindHomela:

; 574  : #endif
; 575  : 						{
; 576  : 							eBuild = ((BuildTypes)iJ);
; 577  : 							CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ebp, eax

; 578  : 							if(pkBuildInfo && pkBuildInfo->getImprovement() != NO_IMPROVEMENT && pkBuildInfo->IsWater())

	test	ebp, ebp
	je	SHORT $LN25@FindHomela
	mov	ecx, ebp
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	cmp	eax, -1
	je	SHORT $LN25@FindHomela
	mov	ecx, ebp
	call	?IsWater@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::IsWater
	test	al, al
	je	SHORT $LN25@FindHomela

; 579  : 							{
; 580  : 								if(GC.getImprovementInfo((ImprovementTypes) GC.getBuildInfo(eBuild)->getImprovement())->IsImprovementResourceTrade(eNonObsoleteResource))

	mov	eax, DWORD PTR _eNonObsoleteResource$225115[esp+80]
	push	eax
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	jne	SHORT $LN548@FindHomela
$LN25@FindHomela:

; 567  : 					{
; 568  : 						// Find proper improvement
; 569  : 						BuildTypes eBuild;
; 570  : #ifdef AUI_WARNING_FIXES
; 571  : 						for (uint iJ = 0; iJ < GC.getNumBuildInfos(); iJ++)
; 572  : #else
; 573  : 						for(int iJ = 0; iJ < GC.getNumBuildInfos(); iJ++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	edi, eax
	jl	SHORT $LL554@FindHomela

; 579  : 							{
; 580  : 								if(GC.getImprovementInfo((ImprovementTypes) GC.getBuildInfo(eBuild)->getImprovement())->IsImprovementResourceTrade(eNonObsoleteResource))

	jmp	SHORT $LN556@FindHomela
$LN548@FindHomela:

; 581  : 								{
; 582  : 									newTarget.SetTargetType(AI_HOMELAND_TARGET_NAVAL_RESOURCE);
; 583  : 									newTarget.SetTargetX(pLoopPlot->getX());

	movsx	ecx, WORD PTR [esi]

; 584  : 									newTarget.SetTargetY(pLoopPlot->getY());

	movsx	edx, WORD PTR [esi+2]

; 585  : 									newTarget.SetAuxData(pLoopPlot);
; 586  : 									newTarget.SetAuxIntData((int)eBuild);
; 587  : 									m_TargetedNavalResources.push_back(newTarget);

	lea	eax, DWORD PTR _newTarget$[esp+80]
	mov	DWORD PTR _newTarget$[esp+84], ecx
	mov	DWORD PTR _newTarget$[esp+80], 4
	mov	DWORD PTR _newTarget$[esp+88], edx
	mov	DWORD PTR _newTarget$[esp+92], esi
	mov	DWORD PTR _newTarget$[esp+96], edi
	push	eax
	lea	ecx, DWORD PTR [ebx+2460]
$LN563@FindHomela:

; 670  : 						}
; 671  : 
; 672  : 						newTarget.SetAuxIntData(iWeight);
; 673  : 						m_TargetedSentryPoints.push_back(newTarget);

	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
$LN556@FindHomela:

; 613  : 				newTarget.SetAuxData(pLoopPlot);
; 614  : 				m_TargetedAntiquitySites.push_back(newTarget);

	mov	ebp, DWORD PTR $T276180[esp+80]
$LN37@FindHomela:

; 531  : 	for(iI = 0; iI < iNumPlots; iI++)

	add	DWORD PTR tv1873[esp+80], 484		; 000001e4H
	sub	DWORD PTR tv426[esp+80], 1
	jne	$LL560@FindHomela
$LN36@FindHomela:

; 686  : 			}
; 687  : 		}
; 688  : 	}
; 689  : 
; 690  : 	// Post-processing on targets
; 691  : 	EliminateAdjacentSentryPoints();

	mov	ecx, ebx
	call	?EliminateAdjacentSentryPoints@CvHomelandAI@@AAEXXZ ; CvHomelandAI::EliminateAdjacentSentryPoints

; 692  : 	EliminateAdjacentHomelandRoads();

	mov	ecx, ebx
	call	?EliminateAdjacentHomelandRoads@CvHomelandAI@@AAEXXZ ; CvHomelandAI::EliminateAdjacentHomelandRoads

; 693  : 	std::stable_sort(m_TargetedCities.begin(), m_TargetedCities.end());

	mov	eax, DWORD PTR [ebx+2420]
	mov	ebx, DWORD PTR [ebx+2416]
	pop	ebp
	cmp	ebx, eax
	je	SHORT $LN535@FindHomela
	push	0
	push	0
	push	eax
	push	ebx
	call	??$_Stable_sort@V?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@HVCvHomelandTarget@@@std@@YAXV?$_Vector_iterator@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@0@0PAHPAVCvHomelandTarget@@@Z ; std::_Stable_sort<std::_Vector_iterator<CvHomelandTarget,std::allocator<CvHomelandTarget> >,int,CvHomelandTarget>
	add	esp, 16					; 00000010H
$LN535@FindHomela:

; 694  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 64					; 00000040H
	ret	0
$LN561@FindHomela:

; 588  : 									break;
; 589  : 								}
; 590  : 							}
; 591  : 						}
; 592  : 					}
; 593  : 				}
; 594  : 			}
; 595  : 
; 596  : 			// ... unpopped goody hut?
; 597  : 			else if(!m_pPlayer->isMinorCiv() && pLoopPlot->isGoody())

	mov	ecx, DWORD PTR [ebx]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN20@FindHomela
	push	-1
	mov	ecx, esi
	call	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isGoody
	test	al, al
	je	SHORT $LN20@FindHomela

; 598  : 			{
; 599  : 				newTarget.SetTargetType(AI_HOMELAND_TARGET_ANCIENT_RUIN);
; 600  : 				newTarget.SetTargetX(pLoopPlot->getX());

	movsx	ecx, WORD PTR [esi]

; 601  : 				newTarget.SetTargetY(pLoopPlot->getY());

	movsx	edx, WORD PTR [esi+2]

; 602  : 				newTarget.SetAuxData(pLoopPlot);
; 603  : 				m_TargetedAncientRuins.push_back(newTarget);

	lea	eax, DWORD PTR _newTarget$[esp+80]
	mov	DWORD PTR _newTarget$[esp+84], ecx
	push	eax
	lea	ecx, DWORD PTR [ebx+2492]
	mov	DWORD PTR _newTarget$[esp+84], 6
	mov	DWORD PTR _newTarget$[esp+92], edx
	mov	DWORD PTR _newTarget$[esp+96], esi
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back

; 604  : 			}
; 605  : 
; 606  : 			// ... antiquity site?
; 607  : 			else if((pLoopPlot->getResourceType(eTeam) == GC.getARTIFACT_RESOURCE() || pLoopPlot->getResourceType(eTeam) == GC.getHIDDEN_ARTIFACT_RESOURCE()) && 

	jmp	$LN37@FindHomela
$LN20@FindHomela:

; 608  : 				!(pLoopPlot->getOwner() != NO_PLAYER && m_pPlayer->GetDiplomacyAI()->IsPlayerMadeNoDiggingPromise(pLoopPlot->getOwner())))

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8408
	push	ebp
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, edi
	je	SHORT $LN17@FindHomela
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8412
	push	ebp
	mov	ecx, esi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, edi
	jne	SHORT $LN18@FindHomela
$LN17@FindHomela:
	mov	al, BYTE PTR [esi+4]
	cmp	al, -1
	je	$LN16@FindHomela
	mov	ecx, DWORD PTR [ebx]
	movsx	eax, al
	push	eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerMadeNoDiggingPromise@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsPlayerMadeNoDiggingPromise
	test	al, al
	je	$LN16@FindHomela
$LN18@FindHomela:

; 615  : 			}
; 616  : 
; 617  : 			// ... enemy civilian (or embarked) unit?
; 618  : 			else if(pLoopPlot->isVisibleOtherUnit(m_pPlayer->GetID()))

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+44]
	push	eax
	mov	ecx, esi
	call	?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleOtherUnit
	test	al, al
	je	SHORT $LN14@FindHomela

; 619  : 			{
; 620  : 				CvUnit* pTargetUnit = pLoopPlot->getUnitByIndex(0);

	push	0
	mov	ecx, esi
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	edi, eax

; 621  : 				if(!pTargetUnit->isDelayedDeath() && atWar(eTeam, pTargetUnit->getTeam()) && !pTargetUnit->IsCanDefend())

	mov	ecx, edi
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	test	al, al
	jne	$LN37@FindHomela
	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	push	ebp
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	je	$LN37@FindHomela
	push	0
	mov	ecx, edi
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	test	al, al
	jne	$LN37@FindHomela

; 622  : 				{
; 623  : 					newTarget.SetTargetType(AI_HOMELAND_TARGET_ANCIENT_RUIN);
; 624  : 					newTarget.SetTargetX(pLoopPlot->getX());

	movsx	edx, WORD PTR [esi]

; 625  : 					newTarget.SetTargetY(pLoopPlot->getY());

	movsx	eax, WORD PTR [esi+2]

; 626  : 					newTarget.SetAuxData(pLoopPlot);
; 627  : 					m_TargetedAncientRuins.push_back(newTarget);

	lea	ecx, DWORD PTR _newTarget$[esp+80]
	push	ecx
	lea	ecx, DWORD PTR [ebx+2492]
	mov	DWORD PTR _newTarget$[esp+84], 6
	mov	DWORD PTR _newTarget$[esp+88], edx
	mov	DWORD PTR _newTarget$[esp+92], eax
	mov	DWORD PTR _newTarget$[esp+96], esi
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back

; 628  : 				}
; 629  : 			}

	jmp	$LN37@FindHomela
$LN14@FindHomela:

; 630  : 
; 631  : 			// ... possible sentry point? (must be empty or only have friendly units)
; 632  : 			else if(!pLoopPlot->isWater() && (!pLoopPlot->isUnit() || pLoopPlot->getNumDefenders(m_pPlayer->GetID()) > 0))

	cmp	BYTE PTR [esi+5], 3
	je	$LN11@FindHomela
	mov	ecx, esi
	call	?isUnit@CvPlot@@QBE_NXZ			; CvPlot::isUnit
	test	al, al
	je	SHORT $LN10@FindHomela
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, esi
	call	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumDefenders
	test	eax, eax
	jle	$LN11@FindHomela
$LN10@FindHomela:

; 633  : 			{
; 634  : 				// Must be at least adjacent to our land
; 635  : 				if(pLoopPlot->getOwner() == m_pPlayer->GetID() ||
; 636  : 				        (pLoopPlot->isAdjacentTeam(eTeam, true /*bLandOnly*/) && pLoopPlot->getOwner() == NO_PLAYER))

	movsx	ecx, BYTE PTR [esi+4]
	mov	eax, DWORD PTR [ebx]
	cmp	ecx, DWORD PTR [eax+44]
	je	SHORT $LN8@FindHomela
	push	1
	push	ebp
	mov	ecx, esi
	call	?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isAdjacentTeam
	test	al, al
	je	$LN37@FindHomela
	cmp	BYTE PTR [esi+4], -1
	jne	$LN37@FindHomela
$LN8@FindHomela:

; 637  : 				{
; 638  : 					// See how many outside plots are nearby to monitor
; 639  : 					int iOutsidePlots = pLoopPlot->GetNumAdjacentDifferentTeam(eTeam, true /*bIgnoreWater*/);

	push	1
	push	ebp
	mov	ecx, esi
	call	?GetNumAdjacentDifferentTeam@CvPlot@@QBEHW4TeamTypes@@_N@Z ; CvPlot::GetNumAdjacentDifferentTeam
	mov	ebp, eax

; 640  : 
; 641  : 					if(iOutsidePlots > 0)

	test	ebp, ebp
	jle	$LN556@FindHomela

; 642  : 					{
; 643  : 						newTarget.SetTargetType(AI_HOMELAND_TARGET_SENTRY_POINT);
; 644  : 						newTarget.SetTargetX(pLoopPlot->getX());

	movsx	edx, WORD PTR [esi]

; 645  : 						newTarget.SetTargetY(pLoopPlot->getY());

	movsx	eax, WORD PTR [esi+2]

; 646  : 						newTarget.SetAuxData(pLoopPlot);
; 647  : 
; 648  : 						// Get weight for this sentry point
; 649  : 						int iWeight = iOutsidePlots * 100;
; 650  : 						iWeight += pLoopPlot->defenseModifier(eTeam, true);

	mov	ecx, DWORD PTR $T276180[esp+80]
	push	0
	push	1
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _newTarget$[esp+92], 2
	mov	DWORD PTR _newTarget$[esp+96], edx
	mov	DWORD PTR _newTarget$[esp+100], eax
	mov	DWORD PTR _newTarget$[esp+104], esi
	call	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ; CvPlot::defenseModifier
	imul	ebp, 100				; 00000064H

; 651  : 						iWeight += m_pPlayer->GetPlotDanger(*pLoopPlot);

	mov	ecx, DWORD PTR [ebx]
	mov	edi, eax
	push	esi
	add	edi, ebp
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger

; 652  : 
; 653  : 						CvCity* pFriendlyCity = m_pPlayer->GetClosestFriendlyCity(*pLoopPlot, 5 /*i SearchRadius */);

	mov	ecx, DWORD PTR [ebx]
	push	5
	push	esi
	add	edi, eax
	call	?GetClosestFriendlyCity@CvPlayer@@QAEPAVCvCity@@AAVCvPlot@@H@Z ; CvPlayer::GetClosestFriendlyCity
	mov	ebp, eax

; 654  : 						if(pFriendlyCity && pFriendlyCity->getOwner() == m_pPlayer->GetID())

	test	ebp, ebp
	je	SHORT $LN5@FindHomela
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebp+84]
	cmp	eax, DWORD PTR [edx+44]
	jne	SHORT $LN5@FindHomela

; 655  : 						{
; 656  : 							iWeight += pFriendlyCity->getThreatValue() * pFriendlyCity->getPopulation() / 50;

	mov	ecx, ebp
	call	?getThreatValue@CvCity@@QAEHXZ		; CvCity::getThreatValue
	mov	ecx, ebp
	mov	ebx, eax
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	imul	ebx, eax
	mov	eax, 1374389535				; 51eb851fH
	imul	ebx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	edi, ecx

; 657  : 							if(pFriendlyCity->isCapital())

	mov	ecx, ebp
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital

; 658  : 							{
; 659  : 								iWeight = (iWeight * GC.getAI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL()) / 100;

	mov	ebx, DWORD PTR _this$[esp+80]
	test	al, al
	je	SHORT $LN5@FindHomela
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2188
	imul	ecx, edi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edi, eax
$LN5@FindHomela:

; 660  : 							}
; 661  : 						}
; 662  : 
; 663  : 						if(pLoopPlot->isHills())

	cmp	BYTE PTR [esi+5], 1
	jne	SHORT $LN4@FindHomela

; 664  : 						{
; 665  : 							iWeight *= 2;

	add	edi, edi
$LN4@FindHomela:

; 666  : 						}
; 667  : 						if(pLoopPlot->isCoastalLand())

	push	-1
	mov	ecx, esi
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	test	al, al
	je	SHORT $LN3@FindHomela

; 668  : 						{
; 669  : 							iWeight /= 2;

	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edi, eax
$LN3@FindHomela:

; 670  : 						}
; 671  : 
; 672  : 						newTarget.SetAuxIntData(iWeight);
; 673  : 						m_TargetedSentryPoints.push_back(newTarget);

	lea	ecx, DWORD PTR _newTarget$[esp+80]
	push	ecx
	mov	DWORD PTR _newTarget$[esp+100], edi
	lea	ecx, DWORD PTR [ebx+2428]

; 674  : 					}
; 675  : 				}
; 676  : 			}

	jmp	$LN563@FindHomela
$LN11@FindHomela:

; 677  : 
; 678  : 			// ... road segment in friendly territory?
; 679  : 			else if(pLoopPlot->getTeam() == eTeam && pLoopPlot->isRoute())

	movsx	eax, BYTE PTR [esi+4]
	cmp	eax, -1
	je	SHORT $LN499@FindHomela
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN499@FindHomela
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN498@FindHomela
$LN499@FindHomela:
	or	eax, -1
$LN498@FindHomela:
	cmp	eax, ebp
	jne	$LN37@FindHomela
	mov	ecx, esi
	call	?isRoute@CvPlot@@QBE_NXZ		; CvPlot::isRoute
	test	al, al
	je	$LN37@FindHomela

; 680  : 			{
; 681  : 				newTarget.SetTargetType(AI_HOMELAND_TARGET_HOME_ROAD);
; 682  : 				newTarget.SetTargetX(pLoopPlot->getX());

	movsx	edx, WORD PTR [esi]

; 683  : 				newTarget.SetTargetY(pLoopPlot->getY());

	movsx	eax, WORD PTR [esi+2]

; 684  : 				newTarget.SetAuxData(pLoopPlot);
; 685  : 				m_TargetedHomelandRoads.push_back(newTarget);

	lea	ecx, DWORD PTR _newTarget$[esp+80]
	push	ecx
	lea	ecx, DWORD PTR [ebx+2476]
	mov	DWORD PTR _newTarget$[esp+84], 5
	mov	DWORD PTR _newTarget$[esp+88], edx
	mov	DWORD PTR _newTarget$[esp+92], eax
	mov	DWORD PTR _newTarget$[esp+96], esi
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
	jmp	$LN37@FindHomela
$LN16@FindHomela:

; 609  : 			{
; 610  : 				newTarget.SetTargetType(AI_HOMELAND_TARGET_ANTIQUITY_SITE);
; 611  : 				newTarget.SetTargetX(pLoopPlot->getX());

	movsx	edx, WORD PTR [esi]

; 612  : 				newTarget.SetTargetY(pLoopPlot->getY());

	movsx	eax, WORD PTR [esi+2]

; 613  : 				newTarget.SetAuxData(pLoopPlot);
; 614  : 				m_TargetedAntiquitySites.push_back(newTarget);

	lea	ecx, DWORD PTR _newTarget$[esp+80]
	push	ecx
	lea	ecx, DWORD PTR [ebx+2508]
	mov	DWORD PTR _newTarget$[esp+84], 7
	mov	DWORD PTR _newTarget$[esp+88], edx
	mov	DWORD PTR _newTarget$[esp+92], eax
	mov	DWORD PTR _newTarget$[esp+96], esi
	call	?push_back@?$vector@VCvHomelandTarget@@V?$allocator@VCvHomelandTarget@@@std@@@std@@QAEXABVCvHomelandTarget@@@Z ; std::vector<CvHomelandTarget,std::allocator<CvHomelandTarget> >::push_back
	jmp	$LN37@FindHomela
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindHomelandTargets@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225108[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindHomelandTargets@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?FindHomelandTargets@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindHomelandTargets@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::FindHomelandTargets
PUBLIC	?PlotWorkerMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotWorkerMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotWorkerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$225698 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$225704 = -36					; size = 8
_unit$225708 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotWorkerMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotWorkerMoves, COMDAT
; _this$ = ecx

; 1204 : {

	push	-1
	push	__ehhandler$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 1205 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 1206 : 
; 1207 : 	// Loop through all recruited units
; 1208 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$225698[esp+56], ebp
	cmp	ebp, eax
	je	$LN5@PlotWorker@2
	push	edi
	jmp	SHORT $LN31@PlotWorker@2
	npad	3
$LL92@PlotWorker@2:
	mov	ebp, DWORD PTR _it$225698[esp+60]
$LN31@PlotWorker@2:

; 1209 : 	{
; 1210 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$225704[esp+60], edi
	mov	BYTE PTR _pUnit$225704[esp+64], 0
	test	edi, edi
	je	SHORT $LN54@PlotWorker@2
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN54@PlotWorker@2:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 1211 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN93@PlotWorker@2

; 1212 : 		{
; 1213 : 			if(pUnit->AI_getUnitAIType() == UNITAI_WORKER  ||
; 1214 : #ifdef AUI_WARNING_FIXES
; 1215 : 				(pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_LAND && pUnit->GetAutomateType() == AUTOMATE_BUILD))
; 1216 : #else
; 1217 : 			        pUnit->IsAutomated() && pUnit->getDomainType() == DOMAIN_LAND && pUnit->GetAutomateType() == AUTOMATE_BUILD)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	je	SHORT $LN2@PlotWorker@2
	mov	ecx, edi
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	test	al, al
	je	SHORT $LN93@PlotWorker@2
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN93@PlotWorker@2
	mov	ecx, edi
	call	?GetAutomateType@CvUnit@@QBE?AW4AutomateTypes@@XZ ; CvUnit::GetAutomateType
	test	eax, eax
	jne	SHORT $LN93@PlotWorker@2
$LN2@PlotWorker@2:

; 1218 : #endif
; 1219 : 			{
; 1220 : 				CvHomelandUnit unit;
; 1221 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 1222 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$225708[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN76@PlotWorker@2
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN76@PlotWorker@2:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN79@PlotWorker@2
	mov	edx, DWORD PTR _unit$225708[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN79@PlotWorker@2:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$225698[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN93@PlotWorker@2:

; 1223 : 			}
; 1224 : 		}
; 1225 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN6@PlotWorker@2
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@PlotWorker@2:
	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR _it$225698[esp+60], eax
	cmp	eax, DWORD PTR [ebx+8]
	jne	$LL92@PlotWorker@2
	pop	edi
$LN5@PlotWorker@2:

; 1226 : 
; 1227 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotWorker@2

; 1228 : 	{
; 1229 : 		ExecuteWorkerMoves();

	mov	ecx, ebx
	call	?ExecuteWorkerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteWorkerMoves
$LN1@PlotWorker@2:

; 1230 : #ifdef AUI_HOMELAND_PLOT_WORKER_MOVES_ALSO_PLOTS_WORKER_DEFENSE
; 1231 : 		FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL > tempList = m_CurrentMoveUnits;
; 1232 : 		for (FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it = tempList.begin(); it != tempList.end(); ++it)
; 1233 : 		{
; 1234 : 			CvUnit* pTargetWorker = m_pPlayer->getUnit(it->GetID());
; 1235 : 
; 1236 : 			if (pTargetWorker && !pTargetWorker->IsCombatUnit() && !pTargetWorker->isDelayedDeath() && !pTargetWorker->IsDead())
; 1237 : 			{
; 1238 : 				CvPlot* pTargetPlot = pTargetWorker->plot();
; 1239 : 				// Grab units that make sense for this move type
; 1240 : 				FindUnitsForThisMove(AI_HOMELAND_MOVE_UNASSIGNED /*Special override for selecting combat units*/, (it == tempList.begin())/*bFirstTime*/);
; 1241 : 
; 1242 : 				if (m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)
; 1243 : 				{
; 1244 : 					if (GetBestUnitToReachTarget(pTargetPlot, 1))
; 1245 : 					{
; 1246 : 						ExecuteMoveToTarget(pTargetPlot);
; 1247 : 
; 1248 : 						if (GC.getLogging() && GC.getAILogging())
; 1249 : 						{
; 1250 : 							CvString strLogString;
; 1251 : 							strLogString.Format("Moving to protect worker, X: %d, Y: %d", pTargetPlot->getX(), pTargetPlot->getY());
; 1252 : 							LogHomelandMessage(strLogString);
; 1253 : 						}
; 1254 : 					}
; 1255 : 				}
; 1256 : 			}
; 1257 : 		}
; 1258 : #endif
; 1259 : 	}
; 1260 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225704[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotWorkerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotWorkerMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotWorkerMoves
PUBLIC	?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotUpgradeMoves
EXTRN	?GetGold@CvTreasury@@QBEHXZ:PROC		; CvTreasury::GetGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?StartSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@HH@Z:PROC ; CvEconomicAI::StartSaveForPurchase
EXTRN	?upgradePrice@CvUnit@@QBEHW4UnitTypes@@@Z:PROC	; CvUnit::upgradePrice
EXTRN	?DoUpgrade@CvUnit@@QAEPAV1@XZ:PROC		; CvUnit::DoUpgrade
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z:PROC ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?CancelSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@@Z:PROC ; CvEconomicAI::CancelSaveForPurchase
EXTRN	?IsSavingForThisPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@@Z:PROC ; CvEconomicAI::IsSavingForThisPurchase
EXTRN	?CanUpgradeRightNow@CvUnit@@QBE_N_N@Z:PROC	; CvUnit::CanUpgradeRightNow
EXTRN	?GetPower@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetPower
EXTRN	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z:PROC ; CvPlayer::getNumResourceAvailable
EXTRN	?GetResourceQuantityRequirement@CvUnitEntry@@QBEHH@Z:PROC ; CvUnitEntry::GetResourceQuantityRequirement
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetPrereqAndTech
EXTRN	?GetUpgradeUnitType@CvUnit@@QBE?AW4UnitTypes@@XZ:PROC ; CvUnit::GetUpgradeUnitType
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$7
	DD	05H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$10
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_bMissingResource$ = -129				; size = 1
_iBestDistance$225887 = -128				; size = 4
_this$ = -128						; size = 4
tv1852 = -124						; size = 4
_iNumUpgraded$225851 = -124				; size = 4
_it$225800 = -124					; size = 4
_iGoldPriority$225868 = -120				; size = 4
_moveUnitIt$ = -120					; size = 4
$T277235 = -116						; size = 4
$T277220 = -116						; size = 4
_iAmountRequired$225866 = -116				; size = 4
_eUpgradeUnitType$225808 = -116				; size = 4
_iI$225888 = -112					; size = 4
$T276859 = -112						; size = 4
$T276857 = -112						; size = 4
$T277621 = -108						; size = 4
_pUpgradeCity$225886 = -108				; size = 4
$T276858 = -108						; size = 4
$T276856 = -108						; size = 4
_iFlavorMilitaryTraining$225837 = -108			; size = 4
_pUnit$225865 = -104					; size = 8
_pUnit$225855 = -104					; size = 8
_pUnit$225806 = -104					; size = 8
$T276860 = -96						; size = 28
_strTemp2$225861 = -96					; size = 28
_unit$225822 = -96					; size = 16
_strTemp$225900 = -68					; size = 28
_strTemp$225883 = -68					; size = 28
_strTemp1$225860 = -68					; size = 28
_strLogString$225899 = -40				; size = 28
_strLogString$225882 = -40				; size = 28
_strLogString$225859 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotUpgradeMoves, COMDAT
; _this$ = ecx

; 1413 : {

	push	-1
	push	__ehhandler$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 120				; 00000078H
	push	ebx
	mov	ebx, ecx

; 1414 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator moveUnitIt;
; 1415 : 	ResourceTypes eResource;
; 1416 : 	int iNumResource;
; 1417 : 	int iNumResourceInUnit;
; 1418 : 	bool bMissingResource;
; 1419 : 
; 1420 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	mov	DWORD PTR [ebx+20], eax
	mov	DWORD PTR [ebx+2396], eax

; 1421 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	push	ebp
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+148], ebx
	mov	DWORD PTR _it$225800[esp+148], ecx
	cmp	ecx, eax
	je	$LN44@PlotUpgrad
$LL80@PlotUpgrad:

; 1422 : 	{
; 1423 : 		// Don't try and upgrade a human player's unit or one already recruited for an operation
; 1424 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR _it$225800[esp+148]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ebp, eax
	mov	DWORD PTR _pUnit$225806[esp+148], ebp
	mov	BYTE PTR _pUnit$225806[esp+152], 0
	test	ebp, ebp
	je	SHORT $LN103@PlotUpgrad
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN103@PlotUpgrad:
	mov	DWORD PTR __$EHRec$[esp+156], 0

; 1425 : 		if(pUnit && !pUnit->isHuman() && pUnit->getArmyID() == -1)

	test	ebp, ebp
	je	$LN153@PlotUpgrad
	mov	ecx, ebp
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	test	al, al
	jne	$LN153@PlotUpgrad
	mov	ecx, ebp
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	$LN153@PlotUpgrad

; 1426 : 		{
; 1427 : 			// Can this unit be upgraded?
; 1428 : 			UnitTypes eUpgradeUnitType = pUnit->GetUpgradeUnitType();

	mov	ecx, ebp
	call	?GetUpgradeUnitType@CvUnit@@QBE?AW4UnitTypes@@XZ ; CvUnit::GetUpgradeUnitType
	mov	DWORD PTR _eUpgradeUnitType$225808[esp+148], eax

; 1429 : 			if(eUpgradeUnitType != NO_UNIT)

	cmp	eax, -1
	je	$LN153@PlotUpgrad

; 1430 : 			{
; 1431 : 				// Tech requirement
; 1432 : 				TechTypes ePrereqTech = (TechTypes) GC.getUnitInfo(eUpgradeUnitType)->GetPrereqAndTech();

	mov	edx, eax
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	ecx, eax
	call	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetPrereqAndTech

; 1433 : 				if(ePrereqTech == NO_TECH || GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech(ePrereqTech))

	cmp	eax, -1
	je	SHORT $LN40@PlotUpgrad
	mov	ecx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ecx+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN117@PlotUpgrad
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN118@PlotUpgrad
$LN117@PlotUpgrad:
	or	ecx, -1
$LN118@PlotUpgrad:
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	je	$LN153@PlotUpgrad
$LN40@PlotUpgrad:

; 1434 : 				{
; 1435 : 					// Resource requirement
; 1436 : 					bMissingResource = false;
; 1437 : #ifdef AUI_WARNING_FIXES
; 1438 : 					for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos() && !bMissingResource; iResourceLoop++)
; 1439 : #else
; 1440 : 					for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos() && !bMissingResource; iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	BYTE PTR _bMissingResource$[esp+148], 0
	xor	esi, esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	test	eax, eax
	jle	SHORT $LN464@PlotUpgrad
	npad	3
$LL39@PlotUpgrad:
	cmp	BYTE PTR _bMissingResource$[esp+148], 0
	jne	$LN153@PlotUpgrad

; 1441 : #endif
; 1442 : 					{
; 1443 : 						eResource = (ResourceTypes) iResourceLoop;
; 1444 : 						iNumResource = GC.getUnitInfo(eUpgradeUnitType)->GetResourceQuantityRequirement(eResource);

	mov	eax, DWORD PTR _eUpgradeUnitType$225808[esp+148]
	push	esi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	ecx, eax
	call	?GetResourceQuantityRequirement@CvUnitEntry@@QBEHH@Z ; CvUnitEntry::GetResourceQuantityRequirement
	mov	edi, eax

; 1445 : 						if (iNumResource > 0)

	test	edi, edi
	jle	SHORT $LN38@PlotUpgrad

; 1446 : 						{
; 1447 : 							iNumResourceInUnit = pUnit->getUnitInfo().GetResourceQuantityRequirement(eResource);

	push	esi
	mov	ecx, ebp
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetResourceQuantityRequirement@CvUnitEntry@@QBEHH@Z ; CvUnitEntry::GetResourceQuantityRequirement

; 1448 : 							if (m_pPlayer->getNumResourceAvailable(eResource) + iNumResourceInUnit < iNumResource)

	mov	ecx, DWORD PTR _this$[esp+148]
	mov	ecx, DWORD PTR [ecx]
	push	1
	push	esi
	mov	ebx, eax
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	add	eax, ebx
	cmp	eax, edi

; 1449 : 							{
; 1450 : 								bMissingResource = true;

	mov	ebx, DWORD PTR _this$[esp+148]
	jge	SHORT $LN38@PlotUpgrad
	mov	BYTE PTR _bMissingResource$[esp+148], 1
$LN38@PlotUpgrad:

; 1434 : 				{
; 1435 : 					// Resource requirement
; 1436 : 					bMissingResource = false;
; 1437 : #ifdef AUI_WARNING_FIXES
; 1438 : 					for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos() && !bMissingResource; iResourceLoop++)
; 1439 : #else
; 1440 : 					for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos() && !bMissingResource; iResourceLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	esi, eax
	jl	SHORT $LL39@PlotUpgrad

; 1451 : 							}
; 1452 : 						}
; 1453 : 					}
; 1454 : 
; 1455 : 					if(!bMissingResource)

	cmp	BYTE PTR _bMissingResource$[esp+148], 0
	jne	$LN153@PlotUpgrad
$LN464@PlotUpgrad:

; 1456 : 					{
; 1457 : 						CvHomelandUnit unit;
; 1458 : 						unit.SetID(pUnit->GetID());

	mov	edx, DWORD PTR [ebp+100]

; 1459 : 
; 1460 : 						// Initial priority: units with lowest power first
; 1461 : 						int iPriority = UPGRADE_THIS_TURN_PRIORITY_BOOST - GC.getUnitInfo(pUnit->getUnitType())->GetPower();

	mov	ecx, ebp
	mov	DWORD PTR _unit$225822[esp+148], edx
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	ecx, eax
	call	?GetPower@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetPower
	mov	esi, 1000				; 000003e8H

; 1462 : 
; 1463 : 						// Priority is boosted if can upgrade immediately
; 1464 : 						if(pUnit->CanUpgradeRightNow(false))

	push	0
	mov	ecx, ebp
	sub	esi, eax
	call	?CanUpgradeRightNow@CvUnit@@QBE_N_N@Z	; CvUnit::CanUpgradeRightNow
	test	al, al
	je	SHORT $LN33@PlotUpgrad

; 1465 : 						{
; 1466 : 							iPriority += UPGRADE_THIS_TURN_PRIORITY_BOOST;

	add	esi, 1000				; 000003e8H
	jmp	SHORT $LN31@PlotUpgrad
$LN33@PlotUpgrad:

; 1467 : 						}
; 1468 : 
; 1469 : 						// Alternatively, priority boosted a lesser amount if in friendly territory
; 1470 : 						else if(pUnit->getOwner() == pUnit->plot()->getOwner())

	mov	edi, DWORD PTR [ebp+40]
	mov	ecx, ebp
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	eax, BYTE PTR [eax+4]
	cmp	edi, eax
	jne	SHORT $LN31@PlotUpgrad

; 1471 : 						{
; 1472 : 							iPriority += UPGRADE_IN_TERRITORY_PRIORITY_BOOST;

	add	esi, 500				; 000001f4H
$LN31@PlotUpgrad:

; 1473 : 						}
; 1474 : 
; 1475 : 						unit.SetAuxIntData(iPriority);
; 1476 : 						m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [ebx+24]
	lea	edi, DWORD PTR [ebx+16]
	mov	BYTE PTR [edi+1036], 0
	cmp	DWORD PTR [edi+4], eax
	jne	SHORT $LN152@PlotUpgrad
	push	eax
	mov	ecx, edi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN152@PlotUpgrad:
	mov	eax, DWORD PTR [edi+4]
	shl	eax, 4
	add	eax, DWORD PTR [edi]
	je	SHORT $LN155@PlotUpgrad
	mov	ecx, DWORD PTR _unit$225822[esp+148]
	mov	DWORD PTR [eax], ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
$LN155@PlotUpgrad:
	inc	DWORD PTR [edi+4]
$LN153@PlotUpgrad:

; 1477 : 					}
; 1478 : 				}
; 1479 : 			}
; 1480 : 		}
; 1481 : 	}

	mov	DWORD PTR __$EHRec$[esp+156], -1
	test	ebp, ebp
	je	SHORT $LN45@PlotUpgrad
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN45@PlotUpgrad:
	mov	edx, DWORD PTR _it$225800[esp+148]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _it$225800[esp+148], eax
	cmp	eax, DWORD PTR [ebx+8]
	jne	$LL80@PlotUpgrad
$LN44@PlotUpgrad:

; 1482 : 
; 1483 : 	// No units found, cancel request for money if we have one in
; 1484 : 	if(m_CurrentMoveUnits.size() == 0)

	cmp	DWORD PTR [ebx+20], 0
	jne	SHORT $LN30@PlotUpgrad

; 1485 : 	{
; 1486 : 		if(!m_pPlayer->GetEconomicAI()->IsSavingForThisPurchase(PURCHASE_TYPE_UNIT_UPGRADE))

	mov	ecx, DWORD PTR [ebx]
	push	1
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsSavingForThisPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@@Z ; CvEconomicAI::IsSavingForThisPurchase
	test	al, al
	jne	$LN449@PlotUpgrad

; 1487 : 		{
; 1488 : 			m_pPlayer->GetEconomicAI()->CancelSaveForPurchase(PURCHASE_TYPE_UNIT_UPGRADE);

	mov	ecx, DWORD PTR [ebx]
	push	1
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?CancelSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@@Z ; CvEconomicAI::CancelSaveForPurchase

; 1489 : 		}
; 1490 : 	}
; 1491 : 
; 1492 : 	else

	jmp	$LN449@PlotUpgrad
$LN30@PlotUpgrad:

; 1493 : 	{
; 1494 : 		// Sort results so highest priority is first
; 1495 : 		std::stable_sort(m_CurrentMoveUnits.begin(), m_CurrentMoveUnits.end(), HomelandAIHelpers::CvHomelandUnitAuxIntReverseSort);

	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [ebx+16]
	shl	eax, 4
	add	eax, ecx
	cmp	ecx, eax
	je	SHORT $LN170@PlotUpgrad
	push	OFFSET ?CvHomelandUnitAuxIntReverseSort@HomelandAIHelpers@@YA_NVCvHomelandUnit@@0@Z ; HomelandAIHelpers::CvHomelandUnitAuxIntReverseSort
	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@P6A_NV1@0@Z@std@@YAXPAVCvHomelandUnit@@0PAH0P6A_NV1@2@Z@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit,bool (__cdecl*)(CvHomelandUnit,CvHomelandUnit)>
	add	esp, 20					; 00000014H
$LN170@PlotUpgrad:

; 1498 : 		for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes() && iFlavorMilitaryTraining == 0; iFlavorLoop++)

	xor	esi, esi
	xor	ebp, ebp
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, esi
	jle	SHORT $LN469@PlotUpgrad

; 1496 : 
; 1497 : 		int iFlavorMilitaryTraining = 0;

	xor	edi, edi
$LL475@PlotUpgrad:

; 1498 : 		for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes() && iFlavorMilitaryTraining == 0; iFlavorLoop++)

	test	ebp, ebp
	jne	SHORT $LN469@PlotUpgrad

; 1499 : 		{
; 1500 : 			if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_MILITARY_TRAINING")

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	add	eax, edi
	push	OFFSET $SG225844
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN26@PlotUpgrad

; 1501 : 			{
; 1502 : 				iFlavorMilitaryTraining = m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)iFlavorLoop);

	mov	ecx, DWORD PTR [ebx]
	push	esi
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	ebp, eax
$LN26@PlotUpgrad:
	inc	esi
	add	edi, 28					; 0000001cH
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL475@PlotUpgrad
$LN469@PlotUpgrad:

; 1503 : 			}
; 1504 : 		}
; 1505 : 
; 1506 : 		iFlavorMilitaryTraining = max(1,iFlavorMilitaryTraining/3);

	mov	eax, 1431655766				; 55555556H
	imul	ebp
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR $T276856[esp+148], eax
	cmp	eax, 1
	mov	DWORD PTR $T276857[esp+148], 1
	lea	eax, DWORD PTR $T276856[esp+148]
	jg	SHORT $LN184@PlotUpgrad
	lea	eax, DWORD PTR $T276857[esp+148]
$LN184@PlotUpgrad:

; 1507 : 		int iBonusUpgrades = max(0,GC.getGame().getHandicapInfo().GetID() - 5); // more at the higher difficulties (the AI should have more money to spend)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	esi, DWORD PTR [eax]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	eax, DWORD PTR [eax+4]
	add	eax, -5					; fffffffbH
	xor	ecx, ecx
	mov	DWORD PTR $T276858[esp+148], eax
	cmp	eax, ecx
	mov	DWORD PTR $T276859[esp+148], ecx
	lea	eax, DWORD PTR $T276858[esp+148]
	jg	SHORT $LN192@PlotUpgrad
	lea	eax, DWORD PTR $T276859[esp+148]
$LN192@PlotUpgrad:

; 1508 : 		iFlavorMilitaryTraining += iBonusUpgrades;

	add	esi, DWORD PTR [eax]

; 1509 : 
; 1510 : 		// Try to find a unit that can upgrade immediately
; 1511 : 		int iNumUpgraded = 0;
; 1512 : 		for(moveUnitIt = m_CurrentMoveUnits.begin(); moveUnitIt != m_CurrentMoveUnits.end(); ++moveUnitIt)

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR _iNumUpgraded$225851[esp+148], ecx
	mov	ecx, DWORD PTR [ebx+20]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _iFlavorMilitaryTraining$225837[esp+148], esi
	mov	DWORD PTR _moveUnitIt$[esp+148], eax
	cmp	eax, ecx
	je	$LN472@PlotUpgrad
$LL470@PlotUpgrad:

; 1513 : 		{
; 1514 : 			UnitHandle pUnit = m_pPlayer->getUnit(moveUnitIt->GetID());

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$225855[esp+148], edi
	mov	BYTE PTR _pUnit$225855[esp+152], 0
	test	edi, edi
	je	SHORT $LN202@PlotUpgrad
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN202@PlotUpgrad:

; 1515 : 			if(pUnit->CanUpgradeRightNow(false))

	push	0
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+160], 1
	call	?CanUpgradeRightNow@CvUnit@@QBE_N_N@Z	; CvUnit::CanUpgradeRightNow
	test	al, al
	je	$LN18@PlotUpgrad

; 1516 : 			{
; 1517 : 				CvUnit* pNewUnit = pUnit->DoUpgrade();

	mov	ecx, edi
	call	?DoUpgrade@CvUnit@@QAEPAV1@XZ		; CvUnit::DoUpgrade

; 1518 : 				UnitProcessed(pUnit->GetID());

	mov	edx, DWORD PTR [edi+100]
	mov	esi, eax
	lea	eax, DWORD PTR $T277220[esp+148]
	lea	ebp, DWORD PTR [ebx+4]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR $T277220[esp+152], edx
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR $T277220[esp+148]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN215@PlotUpgrad
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN215@PlotUpgrad:

; 1519 : 				UnitProcessed(pNewUnit->GetID());

	mov	edx, DWORD PTR [esi+100]
	lea	eax, DWORD PTR $T277235[esp+148]
	push	eax
	mov	ecx, ebp
	mov	DWORD PTR $T277235[esp+152], edx
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR $T277235[esp+148]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN471@PlotUpgrad
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN471@PlotUpgrad:

; 1520 : 
; 1521 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN19@PlotUpgrad
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN19@PlotUpgrad

; 1522 : 				{
; 1523 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225859[esp+148]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1524 : #ifdef AUI_WARNING_FIXES
; 1525 : 					CvString strTemp1 = pUnit->getUnitInfo().GetDescription();
; 1526 : 					CvString strTemp2 = pNewUnit->getUnitInfo().GetDescription();
; 1527 : #else
; 1528 : 					CvString strTemp1, strTemp2;

	lea	ecx, DWORD PTR _strTemp1$225860[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp2$225861[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1529 : 					strTemp1 = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[esp+156], 4
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp1$225860[esp+148]
	test	eax, eax
	je	SHORT $LN238@PlotUpgrad
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN237@PlotUpgrad
$LN238@PlotUpgrad:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN237@PlotUpgrad:

; 1530 : 					strTemp2 = GC.getUnitInfo(pNewUnit->getUnitType())->GetDescription();

	mov	ecx, esi
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp2$225861[esp+148]
	test	eax, eax
	je	SHORT $LN244@PlotUpgrad
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN243@PlotUpgrad
$LN244@PlotUpgrad:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN243@PlotUpgrad:

; 1531 : #endif
; 1532 : 					strLogString.Format("Upgrading unit from type %s to type %s, X: %d, Y: %d", strTemp1.GetCString(), strTemp2.GetCString(), pNewUnit->getX(), pNewUnit->getY());

	mov	ebp, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	lea	ecx, DWORD PTR _strTemp2$225861[esp+148]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	ebp
	push	esi
	push	eax
	lea	ecx, DWORD PTR _strTemp1$225860[esp+160]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _strLogString$225859[esp+164]
	push	OFFSET $SG225862
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 1533 : 					LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$225859[esp+148]
	push	eax
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1534 : 				}

	lea	ecx, DWORD PTR _strTemp2$225861[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp1$225860[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$225859[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN19@PlotUpgrad:

; 1535 : 
; 1536 : 				iNumUpgraded++;

	mov	eax, DWORD PTR _iNumUpgraded$225851[esp+148]
	inc	eax

; 1537 : 				if(iNumUpgraded >= iFlavorMilitaryTraining)

	cmp	eax, DWORD PTR _iFlavorMilitaryTraining$225837[esp+148]
	mov	DWORD PTR _iNumUpgraded$225851[esp+148], eax
	jge	$LN457@PlotUpgrad
$LN18@PlotUpgrad:

; 1540 : 				}
; 1541 : 			}
; 1542 : 		}

	mov	DWORD PTR __$EHRec$[esp+156], -1
	test	edi, edi
	je	SHORT $LN22@PlotUpgrad
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN22@PlotUpgrad:
	mov	ecx, DWORD PTR [ebx+20]
	mov	eax, DWORD PTR _moveUnitIt$[esp+148]
	shl	ecx, 4
	add	ecx, DWORD PTR [ebx+16]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _moveUnitIt$[esp+148], eax
	cmp	eax, ecx
	jne	$LL470@PlotUpgrad

; 1543 : 
; 1544 : 		if(iNumUpgraded > 0)

	cmp	DWORD PTR _iNumUpgraded$225851[esp+148], 0
	jg	$LN449@PlotUpgrad
$LN472@PlotUpgrad:

; 1545 : 		{
; 1546 : 			return;
; 1547 : 		}
; 1548 : 
; 1549 : 		// Couldn't do all upgrades this turn, get ready for highest priority unit to upgrade
; 1550 : 		UnitHandle pUnit = m_pPlayer->getUnit(m_CurrentMoveUnits[0].GetID());

	mov	eax, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	xor	edi, edi
	mov	DWORD PTR _pUnit$225865[esp+148], esi
	mov	BYTE PTR _pUnit$225865[esp+152], 0
	cmp	esi, edi
	je	SHORT $LN285@PlotUpgrad
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN285@PlotUpgrad:

; 1551 : 
; 1552 : 		int iAmountRequired = pUnit->upgradePrice(pUnit->GetUpgradeUnitType());

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+156], 5
	call	?GetUpgradeUnitType@CvUnit@@QBE?AW4UnitTypes@@XZ ; CvUnit::GetUpgradeUnitType
	push	eax
	mov	ecx, esi
	call	?upgradePrice@CvUnit@@QBEHW4UnitTypes@@@Z ; CvUnit::upgradePrice

; 1553 : 		bool bRequiresGold = (iAmountRequired > 0);

	cmp	eax, edi
	mov	DWORD PTR _iAmountRequired$225866[esp+148], eax
	setg	al

; 1554 : 		int iGoldPriority = 0;

	mov	DWORD PTR _iGoldPriority$225868[esp+148], edi

; 1555 : 
; 1556 : 		if(bRequiresGold)

	test	al, al
	je	$LN11@PlotUpgrad

; 1557 : 		{
; 1558 : 			// Find priority of this financial request
; 1559 : 			int iCurrentFlavorMilitaryTraining = 0;

	xor	esi, esi

; 1560 : 			for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes() && iCurrentFlavorMilitaryTraining == 0; iFlavorLoop++)

	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, edi
	jle	SHORT $LN13@PlotUpgrad

; 1557 : 		{
; 1558 : 			// Find priority of this financial request
; 1559 : 			int iCurrentFlavorMilitaryTraining = 0;

	xor	ebp, ebp
$LL474@PlotUpgrad:

; 1560 : 			for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes() && iCurrentFlavorMilitaryTraining == 0; iFlavorLoop++)

	test	esi, esi
	jne	SHORT $LN13@PlotUpgrad

; 1561 : 			{
; 1562 : 				if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_MILITARY_TRAINING")

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [edx+ebp]
	push	OFFSET $SG225877
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	test	al, al
	je	SHORT $LN14@PlotUpgrad

; 1563 : 				{
; 1564 : 					iCurrentFlavorMilitaryTraining = m_pPlayer->GetFlavorManager()->GetIndividualFlavor((FlavorTypes)iFlavorLoop);

	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetIndividualFlavor
	mov	esi, eax
$LN14@PlotUpgrad:
	inc	edi
	add	ebp, 28					; 0000001cH
	cmp	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL474@PlotUpgrad
$LN13@PlotUpgrad:

; 1565 : 				}
; 1566 : 			}
; 1567 : 			iGoldPriority = GC.getAI_GOLD_PRIORITY_UPGRADE_BASE();
; 1568 : 			iGoldPriority += GC.getAI_GOLD_PRIORITY_UPGRADE_PER_FLAVOR_POINT() * iCurrentFlavorMilitaryTraining;

	imul	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2080
	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2076

; 1569 : #ifndef AUI_WARNING_FIXES
; 1570 : 		}
; 1571 : 
; 1572 : 		// Start saving
; 1573 : 		if(bRequiresGold)
; 1574 : 		{
; 1575 : #endif
; 1576 : 			m_pPlayer->GetEconomicAI()->CancelSaveForPurchase(PURCHASE_TYPE_UNIT_UPGRADE);

	mov	ecx, DWORD PTR [ebx]
	push	1
	mov	DWORD PTR _iGoldPriority$225868[esp+152], esi
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?CancelSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@@Z ; CvEconomicAI::CancelSaveForPurchase

; 1577 : 			m_pPlayer->GetEconomicAI()->StartSaveForPurchase(PURCHASE_TYPE_UNIT_UPGRADE, iAmountRequired, iGoldPriority);

	mov	eax, DWORD PTR _iAmountRequired$225866[esp+148]
	mov	ecx, DWORD PTR [ebx]
	push	esi
	push	eax
	push	1
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?StartSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@HH@Z ; CvEconomicAI::StartSaveForPurchase
	mov	esi, DWORD PTR _pUnit$225865[esp+148]
$LN11@PlotUpgrad:

; 1578 : 		}
; 1579 : 
; 1580 : 		// Already in friendly territory
; 1581 : 		if(pUnit->plot()->getOwner() == pUnit->getOwner())

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	ecx, BYTE PTR [eax+4]
	mov	esi, DWORD PTR [esi+40]
	cmp	ecx, esi
	jne	$LN10@PlotUpgrad

; 1582 : 		{
; 1583 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@PlotUpgrad
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@PlotUpgrad

; 1584 : 			{
; 1585 : 				CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225882[esp+148]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1586 : #ifdef AUI_WARNING_FIXES
; 1587 : 				CvString strTemp = pUnit->getUnitInfo().GetDescription();
; 1588 : #else
; 1589 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$225883[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], 6
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1590 : 
; 1591 : 				strTemp = pUnit->getUnitInfo().GetDescription();

	mov	ecx, DWORD PTR _pUnit$225865[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], 7
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$225883[esp+148]
	test	eax, eax
	je	SHORT $LN320@PlotUpgrad
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN319@PlotUpgrad
$LN457@PlotUpgrad:

; 1538 : 				{
; 1539 : 					return; // Only upgrade iFlavorMilitaryTraining units per turn

	mov	ecx, edi
	jmp	$LN477@PlotUpgrad

; 1590 : 
; 1591 : 				strTemp = pUnit->getUnitInfo().GetDescription();

$LN320@PlotUpgrad:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN319@PlotUpgrad:

; 1592 : #endif
; 1593 : 				strLogString.Format("Need gold for %s upgrade, GOLD: Available = %d, Needed = %d, Priority = %d",
; 1594 : 				                    strTemp.GetCString(), m_pPlayer->GetTreasury()->GetGold(), iAmountRequired, iGoldPriority);

	lea	ecx, DWORD PTR _strTemp$225883[esp+148]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR _iGoldPriority$225868[esp+148]
	mov	ecx, DWORD PTR [ebx]
	mov	esi, eax
	mov	eax, DWORD PTR _iAmountRequired$225866[esp+148]
	push	edx
	push	eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	push	eax
	push	esi
	lea	ecx, DWORD PTR _strLogString$225882[esp+164]
	push	OFFSET $SG225884
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 1595 : 				LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$225882[esp+148]
	push	edx
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1596 : 			}

	mov	BYTE PTR __$EHRec$[esp+156], 6

; 1597 : 		}
; 1598 : 
; 1599 : 		else

	jmp	$LN478@PlotUpgrad
$LN10@PlotUpgrad:

; 1603 : 			int iBestDistance = MAX_INT;
; 1604 : 			for(unsigned int iI = 0; iI < m_TargetedCities.size(); iI++)

	mov	ecx, DWORD PTR [ebx+2420]
	sub	ecx, DWORD PTR [ebx+2416]
	xor	eax, eax
	mov	DWORD PTR _pUpgradeCity$225886[esp+148], eax
	mov	DWORD PTR _iI$225888[esp+148], eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iBestDistance$225887[esp+148], 2147483647 ; 7fffffffH
	je	$LN1@PlotUpgrad

; 1600 : 		{
; 1601 : 			// Move top priority unit toward closest city
; 1602 : 			CvCity* pUpgradeCity = NULL;

	mov	DWORD PTR tv1852[esp+148], 0
	npad	8
$LL7@PlotUpgrad:

; 1605 : 			{
; 1606 : 				CvPlot* pTarget = GC.getMap().plot(m_TargetedCities[iI].GetTargetX(), m_TargetedCities[iI].GetTargetY());

	mov	ecx, DWORD PTR [ebx+2416]
	mov	edx, DWORD PTR tv1852[esp+148]
	mov	esi, DWORD PTR [edx+ecx+4]
	mov	ebp, DWORD PTR [edx+ecx+8]
	lea	eax, DWORD PTR [edx+ecx]
	cmp	esi, -2147483647			; 80000001H
	je	$LN343@PlotUpgrad
	cmp	ebp, -2147483647			; 80000001H
	je	$LN343@PlotUpgrad
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	al, al
	je	SHORT $LN353@PlotUpgrad
	test	esi, esi
	jge	SHORT $LN355@PlotUpgrad
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN353@PlotUpgrad
$LN355@PlotUpgrad:
	cmp	esi, ecx
	jl	SHORT $LN353@PlotUpgrad
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN353@PlotUpgrad:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	edi, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN473@PlotUpgrad
	test	ebp, ebp
	jge	SHORT $LN365@PlotUpgrad
	mov	eax, ebp
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN367@PlotUpgrad
$LN365@PlotUpgrad:
	cmp	ebp, edi
	jl	SHORT $LN473@PlotUpgrad
	mov	eax, ebp
	cdq
	idiv	edi
	jmp	SHORT $LN367@PlotUpgrad
$LN473@PlotUpgrad:
	mov	edx, ebp
$LN367@PlotUpgrad:
	test	esi, esi
	jl	SHORT $LN343@PlotUpgrad
	cmp	esi, ecx
	jge	SHORT $LN343@PlotUpgrad
	test	edx, edx
	jl	SHORT $LN343@PlotUpgrad
	cmp	edx, edi
	jge	SHORT $LN343@PlotUpgrad
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]
	jmp	SHORT $LN345@PlotUpgrad
$LN343@PlotUpgrad:
	xor	ecx, ecx
$LN345@PlotUpgrad:

; 1607 : 				CvCity* pCity = pTarget->getPlotCity();

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN381@PlotUpgrad
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN381@PlotUpgrad
	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax
	jmp	SHORT $LN382@PlotUpgrad
$LN381@PlotUpgrad:
	xor	esi, esi
$LN382@PlotUpgrad:

; 1608 : 
; 1609 : 				int iDistance = plotDistance(pCity->getX(), pCity->getY(), pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$225865[esp+148]
	mov	eax, DWORD PTR [ecx+88]
	mov	ecx, DWORD PTR [ecx+76]
	mov	edx, DWORD PTR [esi+108]
	mov	edi, DWORD PTR [esi+96]
	push	eax
	push	ecx
	push	edx
	push	edi
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 1610 : 
; 1611 : 				if(iDistance < iBestDistance)

	cmp	eax, DWORD PTR _iBestDistance$225887[esp+148]
	jge	SHORT $LN6@PlotUpgrad

; 1612 : 				{
; 1613 : 					iBestDistance = iDistance;

	mov	DWORD PTR _iBestDistance$225887[esp+148], eax

; 1614 : 					pUpgradeCity = pCity;

	mov	DWORD PTR _pUpgradeCity$225886[esp+148], esi
$LN6@PlotUpgrad:
	mov	ecx, DWORD PTR [ebx+2420]
	sub	ecx, DWORD PTR [ebx+2416]
	mov	esi, DWORD PTR _iI$225888[esp+148]
	add	DWORD PTR tv1852[esp+148], 20		; 00000014H
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	esi
	add	eax, edx
	mov	DWORD PTR _iI$225888[esp+148], esi
	cmp	esi, eax
	jb	$LL7@PlotUpgrad

; 1615 : 				}
; 1616 : 			}
; 1617 : 
; 1618 : 			if(pUpgradeCity)

	mov	ebp, DWORD PTR _pUpgradeCity$225886[esp+148]
	test	ebp, ebp
	je	$LN1@PlotUpgrad

; 1619 : 			{
; 1620 : 				if(MoveToEmptySpaceNearTarget(pUnit.pointer(), pUpgradeCity->plot()))

	push	1
	mov	ecx, ebp
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	esi, DWORD PTR _pUnit$225865[esp+152]
	push	eax
	push	esi
	mov	ecx, ebx
	call	?MoveToEmptySpaceNearTarget@CvHomelandAI@@AAE_NPAVCvUnit@@PAVCvPlot@@_N@Z ; CvHomelandAI::MoveToEmptySpaceNearTarget
	test	al, al
	je	$LN1@PlotUpgrad

; 1621 : 				{
; 1622 : 					pUnit->finishMoves();

	mov	ecx, esi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 1623 : 					UnitProcessed(pUnit->GetID());

	mov	edi, DWORD PTR [esi+100]
	lea	ecx, DWORD PTR $T277621[esp+148]
	push	ecx
	lea	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR $T277621[esp+152], edi
	call	?remove@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::remove
	mov	ecx, DWORD PTR [ebx]
	push	edi
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	test	eax, eax
	je	SHORT $LN417@PlotUpgrad
	push	1
	mov	ecx, eax
	call	?SetTurnProcessed@CvUnit@@QAEX_N@Z	; CvUnit::SetTurnProcessed
$LN417@PlotUpgrad:

; 1624 : 
; 1625 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@PlotUpgrad
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@PlotUpgrad

; 1626 : 					{
; 1627 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225899[esp+148]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1628 : 						CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$225900[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], 8
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1629 : #ifdef AUI_WARNING_FIXES
; 1630 : 						CvUnitEntry* pTempUnitInfo = GC.getUnitInfo(pUnit->getUnitType());
; 1631 : 						if (pTempUnitInfo)
; 1632 : 							strTemp = pTempUnitInfo->GetDescription();
; 1633 : #else
; 1634 : 						strTemp = GC.getUnitInfo(pUnit->getUnitType())->GetDescription();

	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+156], 9
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	lea	ecx, DWORD PTR [eax+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$225900[esp+148]
	test	eax, eax
	je	SHORT $LN430@PlotUpgrad
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN429@PlotUpgrad
$LN430@PlotUpgrad:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN429@PlotUpgrad:

; 1635 : #endif
; 1636 : 						strLogString.Format("Moving %s for upgrade at %s, GOLD: Available = %d, Needed = %d, Priority = %d, Dist = %d",
; 1637 : 						                    strTemp.GetCString(), pUpgradeCity->getName().GetCString(),
; 1638 : 						                    m_pPlayer->GetTreasury()->GetGold(), iAmountRequired, iGoldPriority, iBestDistance);

	lea	edx, DWORD PTR $T276860[esp+148]
	push	edx
	mov	ecx, ebp
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+156], 10		; 0000000aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	lea	ecx, DWORD PTR _strTemp$225900[esp+148]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _iGoldPriority$225868[esp+148]
	mov	edx, DWORD PTR _iAmountRequired$225866[esp+148]
	mov	edi, eax
	mov	eax, DWORD PTR _iBestDistance$225887[esp+148]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	push	edx
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	push	eax
	push	esi
	push	edi
	lea	eax, DWORD PTR _strLogString$225899[esp+172]
	push	OFFSET $SG225902
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 32					; 00000020H
	lea	ecx, DWORD PTR $T276860[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], 9
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1639 : 						LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$225899[esp+148]
	push	ecx
	mov	ecx, ebx
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1640 : 					}

	mov	BYTE PTR __$EHRec$[esp+156], 8
$LN478@PlotUpgrad:
	lea	ecx, DWORD PTR _strTemp$225900[esp+148]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strLogString$225899[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@PlotUpgrad:

; 1641 : 				}
; 1642 : 			}
; 1643 : 		}
; 1644 : 	}

	mov	ecx, DWORD PTR _pUnit$225865[esp+148]
$LN477@PlotUpgrad:
	mov	DWORD PTR __$EHRec$[esp+156], -1
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN449@PlotUpgrad:

; 1645 : 
; 1646 : 	return;
; 1647 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+148]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 132				; 00000084H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225806[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _pUnit$225855[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$225859[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strTemp1$225860[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strTemp2$225861[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _pUnit$225865[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strLogString$225882[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strTemp$225883[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR _strLogString$225899[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$9:
	lea	ecx, DWORD PTR _strTemp$225900[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ$10:
	lea	ecx, DWORD PTR $T276860[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotUpgradeMoves
PUBLIC	?PlotWriterMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotWriterMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotWriterMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotWriterMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotWriterMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotWriterMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotWriterMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$225924 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$225930 = -36					; size = 8
_unit$225933 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotWriterMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotWriterMoves, COMDAT
; _this$ = ecx

; 1684 : {

	push	-1
	push	__ehhandler$?PlotWriterMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 1685 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 1686 : 
; 1687 : 	// Loop through all recruited units
; 1688 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$225924[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotWriter
	push	edi
	jmp	SHORT $LN30@PlotWriter
	npad	3
$LL85@PlotWriter:
	mov	ebp, DWORD PTR _it$225924[esp+60]
$LN30@PlotWriter:

; 1689 : 	{
; 1690 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$225930[esp+60], edi
	mov	BYTE PTR _pUnit$225930[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotWriter
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotWriter:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 1691 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotWriter

; 1692 : 		{
; 1693 : 			if (pUnit->AI_getUnitAIType() == UNITAI_WRITER)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN86@PlotWriter

; 1694 : 			{
; 1695 : 				CvHomelandUnit unit;
; 1696 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 1697 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$225933[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotWriter
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotWriter:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotWriter
	mov	edx, DWORD PTR _unit$225933[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotWriter:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$225924[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotWriter:

; 1698 : 			}
; 1699 : 		}
; 1700 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotWriter
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotWriter:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$225924[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotWriter
	pop	edi
$LN4@PlotWriter:

; 1701 : 
; 1702 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotWriter

; 1703 : 	{
; 1704 : 		ExecuteWriterMoves();

	mov	ecx, ebx
	call	?ExecuteWriterMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteWriterMoves
$LN1@PlotWriter:

; 1705 : 	}
; 1706 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotWriterMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225930[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotWriterMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotWriterMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotWriterMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotWriterMoves
PUBLIC	?PlotArtistMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotArtistMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotArtistMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotArtistMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotArtistMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotArtistMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotArtistMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$225942 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$225948 = -36					; size = 8
_unit$225951 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotArtistMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotArtistMoves, COMDAT
; _this$ = ecx

; 1710 : {

	push	-1
	push	__ehhandler$?PlotArtistMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 1711 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 1712 : 
; 1713 : 	// Loop through all recruited units
; 1714 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$225942[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotArtist
	push	edi
	jmp	SHORT $LN30@PlotArtist
	npad	3
$LL85@PlotArtist:
	mov	ebp, DWORD PTR _it$225942[esp+60]
$LN30@PlotArtist:

; 1715 : 	{
; 1716 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$225948[esp+60], edi
	mov	BYTE PTR _pUnit$225948[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotArtist
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotArtist:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 1717 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotArtist

; 1718 : 		{
; 1719 : 			if (pUnit->AI_getUnitAIType() == UNITAI_ARTIST)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN86@PlotArtist

; 1720 : 			{
; 1721 : 				CvHomelandUnit unit;
; 1722 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 1723 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$225951[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotArtist
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotArtist:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotArtist
	mov	edx, DWORD PTR _unit$225951[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotArtist:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$225942[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotArtist:

; 1724 : 			}
; 1725 : 		}
; 1726 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotArtist
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotArtist:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$225942[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotArtist
	pop	edi
$LN4@PlotArtist:

; 1727 : 
; 1728 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotArtist

; 1729 : 	{
; 1730 : 		ExecuteArtistMoves();

	mov	ecx, ebx
	call	?ExecuteArtistMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteArtistMoves
$LN1@PlotArtist:

; 1731 : 	}
; 1732 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotArtistMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225948[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotArtistMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotArtistMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotArtistMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotArtistMoves
PUBLIC	?PlotMusicianMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotMusicianMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotMusicianMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$225960 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$225966 = -36					; size = 8
_unit$225969 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotMusicianMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotMusicianMoves, COMDAT
; _this$ = ecx

; 1736 : {

	push	-1
	push	__ehhandler$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 1737 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 1738 : 
; 1739 : 	// Loop through all recruited units
; 1740 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$225960[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotMusici
	push	edi
	jmp	SHORT $LN30@PlotMusici
	npad	3
$LL85@PlotMusici:
	mov	ebp, DWORD PTR _it$225960[esp+60]
$LN30@PlotMusici:

; 1741 : 	{
; 1742 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$225966[esp+60], edi
	mov	BYTE PTR _pUnit$225966[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotMusici
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotMusici:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 1743 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotMusici

; 1744 : 		{
; 1745 : 			if (pUnit->AI_getUnitAIType() == UNITAI_MUSICIAN)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN86@PlotMusici

; 1746 : 			{
; 1747 : 				CvHomelandUnit unit;
; 1748 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 1749 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$225969[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotMusici
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotMusici:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotMusici
	mov	edx, DWORD PTR _unit$225969[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotMusici:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$225960[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotMusici:

; 1750 : 			}
; 1751 : 		}
; 1752 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotMusici
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotMusici:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$225960[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotMusici
	pop	edi
$LN4@PlotMusici:

; 1753 : 
; 1754 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotMusici

; 1755 : 	{
; 1756 : 		ExecuteMusicianMoves();

	mov	ecx, ebx
	call	?ExecuteMusicianMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteMusicianMoves
$LN1@PlotMusici:

; 1757 : 	}
; 1758 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225966[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotMusicianMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotMusicianMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotMusicianMoves
PUBLIC	?PlotScientistMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotScientistMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotScientistMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotScientistMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotScientistMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotScientistMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotScientistMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$225978 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$225984 = -36					; size = 8
_unit$225987 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotScientistMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotScientistMoves, COMDAT
; _this$ = ecx

; 1762 : {

	push	-1
	push	__ehhandler$?PlotScientistMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 1763 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 1764 : 
; 1765 : 	// Loop through all recruited units
; 1766 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$225978[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotScient
	push	edi
	jmp	SHORT $LN30@PlotScient
	npad	3
$LL85@PlotScient:
	mov	ebp, DWORD PTR _it$225978[esp+60]
$LN30@PlotScient:

; 1767 : 	{
; 1768 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$225984[esp+60], edi
	mov	BYTE PTR _pUnit$225984[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotScient
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotScient:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 1769 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotScient

; 1770 : 		{
; 1771 : 			if(pUnit->AI_getUnitAIType() == UNITAI_SCIENTIST)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN86@PlotScient

; 1772 : 			{
; 1773 : 				CvHomelandUnit unit;
; 1774 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 1775 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$225987[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotScient
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotScient:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotScient
	mov	edx, DWORD PTR _unit$225987[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotScient:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$225978[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotScient:

; 1776 : 			}
; 1777 : 		}
; 1778 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotScient
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotScient:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$225978[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotScient
	pop	edi
$LN4@PlotScient:

; 1779 : 
; 1780 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotScient

; 1781 : 	{
; 1782 : 		ExecuteScientistMoves();

	mov	ecx, ebx
	call	?ExecuteScientistMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteScientistMoves
$LN1@PlotScient:

; 1783 : 	}
; 1784 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotScientistMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$225984[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotScientistMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotScientistMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotScientistMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotScientistMoves
PUBLIC	?PlotMerchantMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotMerchantMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotMerchantMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$226014 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$226020 = -36					; size = 8
_unit$226023 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotMerchantMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotMerchantMoves, COMDAT
; _this$ = ecx

; 1814 : {

	push	-1
	push	__ehhandler$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 1815 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 1816 : 
; 1817 : 	// Loop through all recruited units
; 1818 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$226014[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotMercha
	push	edi
	jmp	SHORT $LN30@PlotMercha
	npad	3
$LL85@PlotMercha:
	mov	ebp, DWORD PTR _it$226014[esp+60]
$LN30@PlotMercha:

; 1819 : 	{
; 1820 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$226020[esp+60], edi
	mov	BYTE PTR _pUnit$226020[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotMercha
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotMercha:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 1821 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotMercha

; 1822 : 		{
; 1823 : 			if(pUnit->AI_getUnitAIType() == UNITAI_MERCHANT)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN86@PlotMercha

; 1824 : 			{
; 1825 : 				CvHomelandUnit unit;
; 1826 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 1827 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$226023[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotMercha
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotMercha:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotMercha
	mov	edx, DWORD PTR _unit$226023[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotMercha:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$226014[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotMercha:

; 1828 : 			}
; 1829 : 		}
; 1830 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotMercha
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotMercha:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$226014[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotMercha
	pop	edi
$LN4@PlotMercha:

; 1831 : 
; 1832 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotMercha

; 1833 : 	{
; 1834 : 		ExecuteMerchantMoves();

	mov	ecx, ebx
	call	?ExecuteMerchantMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteMerchantMoves
$LN1@PlotMercha:

; 1835 : 	}
; 1836 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226020[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotMerchantMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotMerchantMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotMerchantMoves
PUBLIC	?PlotProphetMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotProphetMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotProphetMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotProphetMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotProphetMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotProphetMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotProphetMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$226032 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$226038 = -36					; size = 8
_unit$226041 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotProphetMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotProphetMoves, COMDAT
; _this$ = ecx

; 1840 : {

	push	-1
	push	__ehhandler$?PlotProphetMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 1841 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 1842 : 
; 1843 : 	// Loop through all recruited units
; 1844 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$226032[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotProphe
	push	edi
	jmp	SHORT $LN30@PlotProphe
	npad	3
$LL85@PlotProphe:
	mov	ebp, DWORD PTR _it$226032[esp+60]
$LN30@PlotProphe:

; 1845 : 	{
; 1846 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$226038[esp+60], edi
	mov	BYTE PTR _pUnit$226038[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotProphe
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotProphe:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 1847 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotProphe

; 1848 : 		{
; 1849 : 			if(pUnit->AI_getUnitAIType() == UNITAI_PROPHET)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN86@PlotProphe

; 1850 : 			{
; 1851 : 				CvHomelandUnit unit;
; 1852 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 1853 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$226041[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotProphe
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotProphe:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotProphe
	mov	edx, DWORD PTR _unit$226041[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotProphe:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$226032[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotProphe:

; 1854 : 			}
; 1855 : 		}
; 1856 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotProphe
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotProphe:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$226032[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotProphe
	pop	edi
$LN4@PlotProphe:

; 1857 : 
; 1858 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotProphe

; 1859 : 	{
; 1860 : 		ExecuteProphetMoves();

	mov	ecx, ebx
	call	?ExecuteProphetMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteProphetMoves
$LN1@PlotProphe:

; 1861 : 	}
; 1862 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotProphetMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226038[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotProphetMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotProphetMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotProphetMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotProphetMoves
PUBLIC	?PlotGeneralMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotGeneralMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotGeneralMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$226140 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$226146 = -36					; size = 8
_unit$226149 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotGeneralMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotGeneralMoves, COMDAT
; _this$ = ecx

; 1996 : {

	push	-1
	push	__ehhandler$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 1997 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 1998 : 
; 1999 : 	// Loop through all recruited units
; 2000 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$226140[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotGenera
	push	edi
	jmp	SHORT $LN30@PlotGenera
	npad	3
$LL85@PlotGenera:
	mov	ebp, DWORD PTR _it$226140[esp+60]
$LN30@PlotGenera:

; 2001 : 	{
; 2002 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$226146[esp+60], edi
	mov	BYTE PTR _pUnit$226146[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotGenera
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotGenera:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 2003 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotGenera

; 2004 : 		{
; 2005 : 			if(pUnit->AI_getUnitAIType() == UNITAI_GENERAL)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN86@PlotGenera

; 2006 : 			{
; 2007 : 				CvHomelandUnit unit;
; 2008 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 2009 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$226149[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotGenera
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotGenera:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotGenera
	mov	edx, DWORD PTR _unit$226149[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotGenera:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$226140[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotGenera:

; 2010 : 			}
; 2011 : 		}
; 2012 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotGenera
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotGenera:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$226140[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotGenera
	pop	edi
$LN4@PlotGenera:

; 2013 : 
; 2014 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotGenera

; 2015 : 	{
; 2016 : 		ExecuteGeneralMoves();

	mov	ecx, ebx
	call	?ExecuteGeneralMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteGeneralMoves
$LN1@PlotGenera:

; 2017 : 	}
; 2018 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226146[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotGeneralMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotGeneralMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotGeneralMoves
PUBLIC	?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotAdmiralMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$226158 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$226164 = -36					; size = 8
_unit$226167 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotAdmiralMoves, COMDAT
; _this$ = ecx

; 2022 : {

	push	-1
	push	__ehhandler$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 2023 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 2024 : 
; 2025 : 	// Loop through all recruited units
; 2026 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$226158[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotAdmira
	push	edi
	jmp	SHORT $LN30@PlotAdmira
	npad	3
$LL85@PlotAdmira:
	mov	ebp, DWORD PTR _it$226158[esp+60]
$LN30@PlotAdmira:

; 2027 : 	{
; 2028 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$226164[esp+60], edi
	mov	BYTE PTR _pUnit$226164[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotAdmira
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotAdmira:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 2029 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotAdmira

; 2030 : 		{
; 2031 : 			if(pUnit->AI_getUnitAIType() == UNITAI_ADMIRAL)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN86@PlotAdmira

; 2032 : 			{
; 2033 : 				CvHomelandUnit unit;
; 2034 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 2035 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$226167[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotAdmira
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotAdmira:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotAdmira
	mov	edx, DWORD PTR _unit$226167[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotAdmira:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$226158[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotAdmira:

; 2036 : 			}
; 2037 : 		}
; 2038 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotAdmira
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotAdmira:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$226158[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotAdmira
	pop	edi
$LN4@PlotAdmira:

; 2039 : 
; 2040 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotAdmira

; 2041 : 	{
; 2042 : 		ExecuteAdmiralMoves();

	mov	ecx, ebx
	call	?ExecuteAdmiralMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteAdmiralMoves
$LN1@PlotAdmira:

; 2043 : 	}
; 2044 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226164[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotAdmiralMoves
PUBLIC	?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z ; CvHomelandAI::FindWorkersInSameArea
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z$0
__ehfuncinfo$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z
_TEXT	SEGMENT
_rtnValue$ = -45					; size = 1
tv320 = -44						; size = 4
$T279207 = -40						; size = 4
_pLoopUnit$228618 = -36					; size = 8
_unit$228622 = -28					; size = 16
__$EHRec$ = -12						; size = 12
_pTarget$ = 8						; size = 4
_eBuild$ = 12						; size = 4
?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z PROC ; CvHomelandAI::FindWorkersInSameArea, COMDAT
; _this$ = ecx

; 5196 : {

	push	-1
	push	__ehhandler$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 5197 : 	bool rtnValue = false;

	xor	ebx, ebx

; 5198 : 	ClearCurrentMoveUnits();

	lea	edx, DWORD PTR [edi+16]
	mov	DWORD PTR [edx+4], ebx

; 5199 : 
; 5200 : 	// Loop through all units available to homeland AI this turn
; 5201 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+2396], ebx
	mov	DWORD PTR [edi+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	BYTE PTR _rtnValue$[esp+64], bl
	mov	DWORD PTR tv320[esp+64], edx
	cmp	ebp, eax
	je	$LN5@FindWorker
	npad	5
$LL32@FindWorker:

; 5202 : 	{
; 5203 : 		UnitHandle pLoopUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	mov	DWORD PTR _pLoopUnit$228618[esp+64], esi
	mov	BYTE PTR _pLoopUnit$228618[esp+68], bl
	cmp	esi, ebx
	je	SHORT $LN55@FindWorker
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN55@FindWorker:
	mov	DWORD PTR __$EHRec$[esp+72], ebx

; 5204 : 		if(pLoopUnit)

	cmp	esi, ebx
	je	$LN1@FindWorker

; 5205 : 		{
; 5206 : 			// Civilians only
; 5207 : 			if(pLoopUnit->IsCanAttack())

	mov	ecx, esi
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	test	al, al
	je	SHORT $LN3@FindWorker

; 5208 : 			{
; 5209 : 				continue;

	mov	DWORD PTR __$EHRec$[esp+72], -1
	jmp	SHORT $LN107@FindWorker
$LN3@FindWorker:

; 5210 : 			}
; 5211 : 
; 5212 : 			// Can this worker make the right improvement?
; 5213 : 			if(pLoopUnit->canBuild(pTarget, eBuild))

	mov	ecx, DWORD PTR _eBuild$[esp+60]
	mov	edx, DWORD PTR _pTarget$[esp+60]
	push	1
	push	ebx
	push	ecx
	push	edx
	mov	ecx, esi
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	test	al, al
	je	SHORT $LN1@FindWorker

; 5214 : 			{
; 5215 : 				CvHomelandUnit unit;
; 5216 : 				int iMoves = TurnsToReachTarget(pLoopUnit.pointer(), pTarget);

	mov	eax, DWORD PTR _pTarget$[esp+60]
	push	ebx
	push	ebx
	push	ebx
	push	eax
	sub	esp, 8
	mov	eax, esp
	mov	ecx, esi
	mov	DWORD PTR _unit$228622[esp+88], ebx
	mov	DWORD PTR _unit$228622[esp+92], ebx
	mov	DWORD PTR _unit$228622[esp+96], ebx
	mov	DWORD PTR _unit$228622[esp+100], ebx
	mov	DWORD PTR $T279207[esp+88], esp
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], bl
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 5217 : 
; 5218 : 				if(iMoves != MAX_INT)

	cmp	eax, 2147483647				; 7fffffffH
	je	SHORT $LN1@FindWorker

; 5219 : 				{
; 5220 : 					unit.SetID(pLoopUnit->GetID());

	mov	ecx, DWORD PTR [esi+100]

; 5221 : 					unit.SetMovesToTarget(iMoves);
; 5222 : 					m_CurrentMoveUnits.push_back(unit);

	lea	edx, DWORD PTR _unit$228622[esp+64]
	mov	DWORD PTR _unit$228622[esp+64], ecx
	mov	ecx, DWORD PTR tv320[esp+64]
	push	edx
	mov	DWORD PTR _unit$228622[esp+76], eax
	call	?push_back@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@QAEIABVCvHomelandUnit@@@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::push_back

; 5223 : 					rtnValue = true;

	mov	BYTE PTR _rtnValue$[esp+64], 1
$LN1@FindWorker:

; 5224 : 				}
; 5225 : 			}
; 5226 : 		}
; 5227 : 	}

	mov	DWORD PTR __$EHRec$[esp+72], -1
	cmp	esi, ebx
	je	SHORT $LN6@FindWorker
$LN107@FindWorker:
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FindWorker:
	mov	ebp, DWORD PTR [ebp]
	cmp	ebp, DWORD PTR [edi+8]
	jne	$LL32@FindWorker

; 5199 : 
; 5200 : 	// Loop through all units available to homeland AI this turn
; 5201 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	edx, DWORD PTR tv320[esp+64]
$LN5@FindWorker:

; 5228 : 
; 5229 : 	// Now sort them in the order we'd like them to move
; 5230 : 	std::stable_sort(m_CurrentMoveUnits.begin(), m_CurrentMoveUnits.end());

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx]
	shl	eax, 4
	add	eax, ecx
	cmp	ecx, eax
	je	SHORT $LN105@FindWorker
	push	ebx
	push	ebx
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 16					; 00000010H
$LN105@FindWorker:

; 5231 : 
; 5232 : 	return rtnValue;
; 5233 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	mov	al, BYTE PTR _rtnValue$[esp+64]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 48					; 00000030H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$228618[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindWorkersInSameArea@CvHomelandAI@@AAE_NPAVCvPlot@@W4BuildTypes@@@Z ENDP ; CvHomelandAI::FindWorkersInSameArea
PUBLIC	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z$0
__ehfuncinfo$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iTargetY$ = -28					; size = 4
_iTargetX$ = -24					; size = 4
_pLoopUnit$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_pTarget$ = 8						; size = 4
_iMaxTurns$ = 12					; size = 4
?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z PROC ; CvHomelandAI::GetBestUnitToReachTarget, COMDAT
; _this$ = ecx

; 5666 : {

	push	-1
	push	__ehhandler$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp

; 5667 : 	AI_PERF_FORMAT("Homeland-GetBest-perf.csv", ("GetBestUnitToReachTarget, %d, %d, Turn %03d, %s", pTarget->getX(), pTarget->getY(), GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 5668 : 
; 5669 : 	UnitHandle pLoopUnit;

	xor	ebx, ebx
	push	esi
	push	edi
	mov	ebp, ecx
	mov	DWORD PTR _pLoopUnit$[esp+44], ebx
	mov	BYTE PTR _pLoopUnit$[esp+48], bl

; 5670 : 	MoveUnitsArray::iterator it;
; 5671 : 
; 5672 : 	// Get the raw distance for all units
; 5673 : 	int iTargetX = pTarget->getX();

	mov	eax, DWORD PTR _pTarget$[esp+40]
	movsx	ecx, WORD PTR [eax]

; 5674 : 	int iTargetY = pTarget->getY();

	movsx	edx, WORD PTR [eax+2]

; 5675 : 	
; 5676 : 	// Normal priority units
; 5677 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR [ebp+20]
	mov	edi, DWORD PTR [ebp+16]
	shl	eax, 4
	add	eax, edi
	mov	DWORD PTR __$EHRec$[esp+52], ebx
	mov	DWORD PTR _iTargetX$[esp+44], ecx
	mov	DWORD PTR _iTargetY$[esp+44], edx
	cmp	edi, eax
	je	$LN14@GetBestUni
$LL16@GetBestUni:

; 5678 : 	{
; 5679 : 		pLoopUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	test	ebx, ebx
	je	SHORT $LN38@GetBestUni
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN38@GetBestUni:
	mov	DWORD PTR _pLoopUnit$[esp+44], esi
	test	esi, esi
	je	SHORT $LN15@GetBestUni
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 5680 : 		if(pLoopUnit)
; 5681 : 		{
; 5682 : 			// Make sure domain matches
; 5683 : 			if(pLoopUnit->getDomainType() == DOMAIN_SEA && !pTarget->isWater() ||
; 5684 : 				pLoopUnit->getDomainType() == DOMAIN_LAND && pTarget->isWater())

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	ebx, DWORD PTR _pTarget$[esp+40]
	test	eax, eax
	jne	SHORT $LN10@GetBestUni
	cmp	BYTE PTR [ebx+5], 3
	jne	SHORT $LN11@GetBestUni
$LN10@GetBestUni:
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN12@GetBestUni
	cmp	BYTE PTR [ebx+5], 3
	jne	SHORT $LN12@GetBestUni
$LN11@GetBestUni:

; 5685 : 			{
; 5686 : 				it->SetMovesToTarget(MAX_INT);

	mov	DWORD PTR [edi+8], 2147483647		; 7fffffffH

; 5687 : 				continue;

	jmp	SHORT $LN15@GetBestUni
$LN12@GetBestUni:

; 5688 : 			}
; 5689 : 
; 5690 : 			// Make sure we can move into the destination.  The path finder will do a similar check near the beginning, but it is best to get this out of the way before then
; 5691 : 			if(!pLoopUnit->canMoveInto(*pTarget, CvUnit::MOVEFLAG_DESTINATION | CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE))

	push	132					; 00000084H
	push	ebx
	mov	ecx, esi
	call	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveInto
	test	al, al
	jne	SHORT $LN9@GetBestUni

; 5692 : 			{
; 5693 : 				it->SetMovesToTarget(MAX_INT);

	mov	DWORD PTR [edi+8], 2147483647		; 7fffffffH

; 5694 : 				continue;

	jmp	SHORT $LN15@GetBestUni
$LN9@GetBestUni:

; 5695 : 			}
; 5696 : 
; 5697 : 			int iPlotDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), iTargetX, iTargetY);

	mov	ecx, DWORD PTR _iTargetY$[esp+44]
	mov	edx, DWORD PTR _iTargetX$[esp+44]
	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 5698 : 			it->SetMovesToTarget(iPlotDistance);

	mov	DWORD PTR [edi+8], eax
$LN15@GetBestUni:
	mov	eax, DWORD PTR [ebp+20]
	mov	ebx, DWORD PTR _pLoopUnit$[esp+44]
	shl	eax, 4
	add	eax, DWORD PTR [ebp+16]
	add	edi, 16					; 00000010H
	cmp	edi, eax
	jne	$LL16@GetBestUni
$LN14@GetBestUni:

; 5699 : 		}
; 5700 : 	}
; 5701 : 
; 5702 : 	// High priority units
; 5703 : 	for(it = m_CurrentMoveHighPriorityUnits.begin(); it != m_CurrentMoveHighPriorityUnits.end(); ++it)

	mov	ecx, DWORD PTR [ebp+1060]
	mov	edi, DWORD PTR [ebp+1056]
	shl	ecx, 4
	add	ecx, edi
	cmp	edi, ecx
	je	$LN6@GetBestUni
	jmp	SHORT $LN8@GetBestUni
$LL149@GetBestUni:
	mov	ebx, DWORD PTR _pLoopUnit$[esp+44]
$LN8@GetBestUni:

; 5704 : 	{
; 5705 : 		pLoopUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ebp]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	test	ebx, ebx
	je	SHORT $LN82@GetBestUni
	mov	ecx, ebx
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN82@GetBestUni:
	mov	DWORD PTR _pLoopUnit$[esp+44], esi
	test	esi, esi
	je	SHORT $LN7@GetBestUni
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 5706 : 		if(pLoopUnit)
; 5707 : 		{
; 5708 : 			// Make sure domain matches
; 5709 : 			if(pLoopUnit->getDomainType() == DOMAIN_SEA && !pTarget->isWater() ||
; 5710 : 				pLoopUnit->getDomainType() == DOMAIN_LAND && pTarget->isWater())

	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	ebx, DWORD PTR _pTarget$[esp+40]
	test	eax, eax
	jne	SHORT $LN2@GetBestUni
	cmp	BYTE PTR [ebx+5], 3
	jne	SHORT $LN3@GetBestUni
$LN2@GetBestUni:
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN4@GetBestUni
	cmp	BYTE PTR [ebx+5], 3
	jne	SHORT $LN4@GetBestUni
$LN3@GetBestUni:

; 5711 : 			{
; 5712 : 				it->SetMovesToTarget(MAX_INT);

	mov	DWORD PTR [edi+8], 2147483647		; 7fffffffH

; 5713 : 				continue;

	jmp	SHORT $LN7@GetBestUni
$LN4@GetBestUni:

; 5714 : 			}
; 5715 : 
; 5716 : 			// Make sure we can move into the destination.  The path finder will do a similar check near the beginning, but it is best to get this out of the way before then
; 5717 : 			if(!pLoopUnit->canMoveInto(*pTarget, CvUnit::MOVEFLAG_DESTINATION | CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE))

	push	132					; 00000084H
	push	ebx
	mov	ecx, esi
	call	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveInto
	test	al, al
	jne	SHORT $LN1@GetBestUni

; 5718 : 			{
; 5719 : 				it->SetMovesToTarget(MAX_INT);

	mov	DWORD PTR [edi+8], 2147483647		; 7fffffffH

; 5720 : 				continue;

	jmp	SHORT $LN7@GetBestUni
$LN1@GetBestUni:

; 5721 : 			}
; 5722 : 
; 5723 : 			int iPlotDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), iTargetX, iTargetY);

	mov	edx, DWORD PTR _iTargetY$[esp+44]
	mov	ecx, DWORD PTR _iTargetX$[esp+44]
	mov	eax, DWORD PTR [esi+88]
	mov	esi, DWORD PTR [esi+76]
	push	edx
	push	ecx
	push	eax
	push	esi
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 5724 : 			it->SetMovesToTarget(iPlotDistance);

	mov	DWORD PTR [edi+8], eax
$LN7@GetBestUni:
	mov	edx, DWORD PTR [ebp+1060]
	shl	edx, 4
	add	edx, DWORD PTR [ebp+1056]
	add	edi, 16					; 00000010H
	cmp	edi, edx
	jne	$LL149@GetBestUni
$LN6@GetBestUni:

; 5725 : 		}
; 5726 : 	}
; 5727 : 
; 5728 : 	// Sort by raw distance
; 5729 : 	std::stable_sort(m_CurrentMoveUnits.begin(), m_CurrentMoveUnits.end());

	mov	eax, DWORD PTR [ebp+20]
	mov	ecx, DWORD PTR [ebp+16]
	shl	eax, 4
	add	eax, ecx
	cmp	ecx, eax
	je	SHORT $LN152@GetBestUni
	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 16					; 00000010H
$LN152@GetBestUni:

; 5730 : 	std::stable_sort(m_CurrentMoveHighPriorityUnits.begin(), m_CurrentMoveHighPriorityUnits.end());

	mov	eax, DWORD PTR [ebp+1060]
	mov	ecx, DWORD PTR [ebp+1056]
	shl	eax, 4
	add	eax, ecx
	cmp	ecx, eax
	je	SHORT $LN131@GetBestUni
	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvHomelandUnit@@HV1@@std@@YAXPAVCvHomelandUnit@@0PAH0@Z ; std::_Stable_sort<CvHomelandUnit *,int,CvHomelandUnit>
	add	esp, 16					; 00000010H
$LN131@GetBestUni:

; 5731 : 
; 5732 : 	// Find the one with the best true moves distance
; 5733 : 	GetClosestUnitByTurnsToTarget(m_CurrentMoveUnits, pTarget, iMaxTurns, &m_CurrentBestMoveUnit, &m_iCurrentBestMoveUnitTurns);

	mov	ebx, DWORD PTR _iMaxTurns$[esp+40]
	mov	ecx, DWORD PTR _pTarget$[esp+40]
	lea	eax, DWORD PTR [ebp+2400]
	push	eax
	lea	edi, DWORD PTR [ebp+2396]
	push	edi
	push	ebx
	push	ecx
	lea	eax, DWORD PTR [ebp+16]
	push	eax
	mov	ecx, ebp
	call	?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z ; CvHomelandAI::GetClosestUnitByTurnsToTarget

; 5734 : 	GetClosestUnitByTurnsToTarget(m_CurrentMoveHighPriorityUnits, pTarget, iMaxTurns, &m_CurrentBestMoveHighPriorityUnit, &m_iCurrentBestMoveHighPriorityUnitTurns);

	mov	eax, DWORD PTR _pTarget$[esp+40]
	lea	edx, DWORD PTR [ebp+2408]
	push	edx
	lea	esi, DWORD PTR [ebp+2404]
	push	esi
	push	ebx
	push	eax
	lea	eax, DWORD PTR [ebp+1056]
	push	eax
	mov	ecx, ebp
	call	?GetClosestUnitByTurnsToTarget@CvHomelandAI@@AAE_NAAV?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@PAVCvPlot@@HPAPAVCvUnit@@PAH@Z ; CvHomelandAI::GetClosestUnitByTurnsToTarget

; 5735 : 
; 5736 : 	return m_CurrentBestMoveHighPriorityUnit != NULL || m_CurrentBestMoveUnit != NULL;

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN19@GetBestUni
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN19@GetBestUni
	xor	bl, bl
	jmp	SHORT $LN20@GetBestUni
$LN19@GetBestUni:
	mov	bl, 1
$LN20@GetBestUni:
	mov	ecx, DWORD PTR _pLoopUnit$[esp+44]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	ecx, ecx
	je	SHORT $LN147@GetBestUni
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN147@GetBestUni:

; 5737 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 28					; 0000001cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ENDP ; CvHomelandAI::GetBestUnitToReachTarget
PUBLIC	?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z	; CvHomelandAI::PlotGarrisonMoves
EXTRN	?SetLastTurnGarrisonAssigned@CvCity@@QAEXH@Z:PROC ; CvCity::SetLastTurnGarrisonAssigned
EXTRN	?GetLastTurnGarrisonAssigned@CvCity@@QBEHXZ:PROC ; CvCity::GetLastTurnGarrisonAssigned
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z$0
__ehfuncinfo$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z
_TEXT	SEGMENT
_iI$225589 = -44					; size = 4
_strLogString$225599 = -40				; size = 28
__$EHRec$ = -12						; size = 12
tv562 = 8						; size = 4
_bCityStateOnly$ = 8					; size = 1
?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z PROC		; CvHomelandAI::PlotGarrisonMoves, COMDAT
; _this$ = ecx

; 955  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	esi, ecx

; 956  : 	// City state garrisoning has a separate priority, so only do it when the flag is on
; 957  : 	if(bCityStateOnly != m_pPlayer->isMinorCiv())

	mov	ecx, DWORD PTR [esi]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	cmp	BYTE PTR _bCityStateOnly$[esp+44], al
	jne	$LN5@PlotGarris

; 958  : 	{
; 959  : 		return;
; 960  : 	}
; 961  : 
; 962  : 	// Do we have any targets of this type?
; 963  : 	if(m_TargetedCities.size() > 0)

	mov	ecx, DWORD PTR [esi+2420]
	sub	ecx, DWORD PTR [esi+2416]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	je	$LN5@PlotGarris

; 964  : 	{
; 965  : 		for(unsigned int iI = 0; iI < m_TargetedCities.size(); iI++)

	mov	ecx, DWORD PTR [esi+2420]
	sub	ecx, DWORD PTR [esi+2416]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	push	edi
	xor	edi, edi
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR _iI$225589[esp+52], edi
	je	$LN107@PlotGarris
	push	ebx
	mov	DWORD PTR tv562[esp+52], edi
	push	ebp
	npad	1
$LL105@PlotGarris:

; 966  : 		{
; 967  : 			CvPlot* pTarget = GC.getMap().plot(m_TargetedCities[iI].GetTargetX(), m_TargetedCities[iI].GetTargetY());

	mov	edx, DWORD PTR [esi+2416]
	mov	eax, DWORD PTR tv562[esp+56]
	mov	ebx, DWORD PTR [eax+edx+8]
	add	eax, edx
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN27@PlotGarris
	cmp	ebx, -2147483647			; 80000001H
	je	$LN27@PlotGarris
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN37@PlotGarris
	test	eax, eax
	jge	SHORT $LN39@PlotGarris
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN41@PlotGarris
$LN39@PlotGarris:
	cmp	eax, ecx
	jl	SHORT $LN37@PlotGarris
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN41@PlotGarris
$LN37@PlotGarris:
	mov	edi, eax
$LN41@PlotGarris:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebp, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN100@PlotGarris
	test	ebx, ebx
	jge	SHORT $LN49@PlotGarris
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN51@PlotGarris
$LN49@PlotGarris:
	cmp	ebx, ebp
	jl	SHORT $LN100@PlotGarris
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN51@PlotGarris
$LN100@PlotGarris:
	mov	edx, ebx
$LN51@PlotGarris:
	test	edi, edi
	jl	SHORT $LN27@PlotGarris
	cmp	edi, ecx
	jge	SHORT $LN27@PlotGarris
	test	edx, edx
	jl	SHORT $LN27@PlotGarris
	cmp	edx, ebp
	jge	SHORT $LN27@PlotGarris
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	edi, ecx
	jmp	SHORT $LN29@PlotGarris
$LN27@PlotGarris:
	xor	edi, edi
$LN29@PlotGarris:

; 968  : 			CvCity* pCity = pTarget->getPlotCity();

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	jl	$LN6@PlotGarris
	cmp	eax, 64					; 00000040H
	jge	$LN6@PlotGarris
	mov	ecx, DWORD PTR [edi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebx, eax

; 969  : 
; 970  : 			if(pCity && pCity->GetLastTurnGarrisonAssigned() < GC.getGame().getGameTurn())

	test	ebx, ebx
	je	$LN6@PlotGarris
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, ebx
	mov	ebp, eax
	call	?GetLastTurnGarrisonAssigned@CvCity@@QBEHXZ ; CvCity::GetLastTurnGarrisonAssigned
	cmp	eax, ebp
	jge	$LN6@PlotGarris

; 971  : 			{
; 972  : 				// Grab units that make sense for this move type
; 973  : 				FindUnitsForThisMove(AI_HOMELAND_MOVE_GARRISON, (iI == 0)/*bFirstTime*/);

	cmp	DWORD PTR _iI$225589[esp+60], 0
	mov	ecx, esi
	sete	dl
	movzx	eax, dl
	push	eax
	push	4
	call	?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z ; CvHomelandAI::FindUnitsForThisMove

; 974  : 
; 975  : 				if(m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR [esi+1060]
	mov	ecx, DWORD PTR [esi+20]
	add	ecx, eax
	je	$LN6@PlotGarris

; 976  : 				{
; 977  : 					if(GetBestUnitToReachTarget(pTarget, m_iDefensiveMoveTurns))

	mov	ecx, DWORD PTR [esi+2528]
	push	ecx
	push	edi
	mov	ecx, esi
	call	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
	test	al, al
	je	$LN6@PlotGarris

; 978  : 					{
; 979  : 						ExecuteMoveToTarget(pTarget);

	push	edi
	mov	ecx, esi
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 980  : 
; 981  : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN101@PlotGarris
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN101@PlotGarris

; 982  : 						{
; 983  : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225599[esp+60]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 984  : 							strLogString.Format("Moving to garrison, X: %d, Y: %d, Priority: %d", m_TargetedCities[iI].GetTargetX(), m_TargetedCities[iI].GetTargetY(), m_TargetedCities[iI].GetAuxIntData());

	mov	edx, DWORD PTR [esi+2416]
	mov	eax, DWORD PTR tv562[esp+56]
	mov	ecx, DWORD PTR [eax+edx+16]
	add	eax, edx
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strLogString$225599[esp+72]
	push	OFFSET $SG225600
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 985  : 							LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$225599[esp+60]
	push	edx
	mov	ecx, esi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 986  : 						}

	lea	ecx, DWORD PTR _strLogString$225599[esp+60]
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN101@PlotGarris:

; 987  : 
; 988  : 						pCity->SetLastTurnGarrisonAssigned(GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	mov	ecx, ebx
	call	?SetLastTurnGarrisonAssigned@CvCity@@QAEXH@Z ; CvCity::SetLastTurnGarrisonAssigned
$LN6@PlotGarris:
	mov	ecx, DWORD PTR [esi+2420]
	sub	ecx, DWORD PTR [esi+2416]
	mov	edi, DWORD PTR _iI$225589[esp+60]
	add	DWORD PTR tv562[esp+56], 20		; 00000014H
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	edi
	add	eax, edx
	mov	DWORD PTR _iI$225589[esp+60], edi
	cmp	edi, eax
	jb	$LL105@PlotGarris
	pop	ebp
	pop	ebx
$LN107@PlotGarris:
	pop	edi
$LN5@PlotGarris:

; 989  : 					}
; 990  : 				}
; 991  : 			}
; 992  : 		}
; 993  : 	}
; 994  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z$0:
	lea	ecx, DWORD PTR _strLogString$225599[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z ENDP		; CvHomelandAI::PlotGarrisonMoves
PUBLIC	?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotMobileReserveMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv499 = -48						; size = 4
_iI$225666 = -44					; size = 4
_strLogString$225674 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ PROC	; CvHomelandAI::PlotMobileReserveMoves, COMDAT
; _this$ = ecx

; 1134 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	esi, ecx

; 1135 : 	// Do we have any targets of this type?
; 1136 : 	if(!m_TargetedHomelandRoads.empty())

	mov	ecx, DWORD PTR [esi+2484]
	sub	ecx, DWORD PTR [esi+2480]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	je	$LN4@PlotMobile

; 1137 : 	{
; 1138 : 		// Prioritize them (LATER)
; 1139 : 
; 1140 : 		// See how many moves of this type we can execute
; 1141 : 		for(unsigned int iI = 0; iI < m_TargetedHomelandRoads.size(); iI++)

	mov	ecx, DWORD PTR [esi+2484]
	sub	ecx, DWORD PTR [esi+2480]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	push	ebp
	xor	ebp, ebp
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR _iI$225666[esp+56], ebp
	je	$LN89@PlotMobile
	push	ebx
	mov	DWORD PTR tv499[esp+60], ebp
	push	edi
	npad	2
$LL6@PlotMobile:

; 1142 : 		{
; 1143 : 			CvPlot* pTarget = GC.getMap().plot(m_TargetedHomelandRoads[iI].GetTargetX(), m_TargetedHomelandRoads[iI].GetTargetY());

	mov	edx, DWORD PTR [esi+2480]
	mov	eax, DWORD PTR tv499[esp+64]
	mov	ebx, DWORD PTR [eax+edx+8]
	add	eax, edx
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN27@PlotMobile
	cmp	ebx, -2147483647			; 80000001H
	je	$LN27@PlotMobile
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN37@PlotMobile
	test	eax, eax
	jge	SHORT $LN39@PlotMobile
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN41@PlotMobile
$LN39@PlotMobile:
	cmp	eax, ecx
	jl	SHORT $LN37@PlotMobile
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN41@PlotMobile
$LN37@PlotMobile:
	mov	edi, eax
$LN41@PlotMobile:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebp, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN86@PlotMobile
	test	ebx, ebx
	jge	SHORT $LN49@PlotMobile
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN51@PlotMobile
$LN49@PlotMobile:
	cmp	ebx, ebp
	jl	SHORT $LN86@PlotMobile
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN51@PlotMobile
$LN86@PlotMobile:
	mov	edx, ebx
$LN51@PlotMobile:
	test	edi, edi
	jl	SHORT $LN27@PlotMobile
	cmp	edi, ecx
	jge	SHORT $LN27@PlotMobile
	test	edx, edx
	jl	SHORT $LN27@PlotMobile
	cmp	edx, ebp
	jge	SHORT $LN27@PlotMobile
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	edi, ecx
	jmp	SHORT $LN29@PlotMobile
$LN27@PlotMobile:
	xor	edi, edi
$LN29@PlotMobile:

; 1144 : 
; 1145 : 			FindUnitsForThisMove(AI_HOMELAND_MOVE_MOBILE_RESERVE, (iI == 0)/*bFirstTime*/);

	mov	ebx, DWORD PTR _iI$225666[esp+64]
	xor	ebp, ebp
	cmp	ebx, ebp
	sete	al
	movzx	ecx, al
	push	ecx
	push	7
	mov	ecx, esi
	call	?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z ; CvHomelandAI::FindUnitsForThisMove

; 1146 : 
; 1147 : 			if(m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR [esi+1060]
	mov	ecx, DWORD PTR [esi+20]
	add	ecx, eax
	je	$LN5@PlotMobile

; 1148 : 			{
; 1149 : 				if(GetBestUnitToReachTarget(pTarget, MAX_INT))

	push	2147483647				; 7fffffffH
	push	edi
	mov	ecx, esi
	call	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
	test	al, al
	je	SHORT $LN5@PlotMobile

; 1150 : 				{
; 1151 : 					ExecuteMoveToTarget(pTarget);

	push	edi
	mov	ecx, esi
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 1152 : 
; 1153 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN5@PlotMobile
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN5@PlotMobile

; 1154 : 					{
; 1155 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225674[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1156 : 						strLogString.Format("Moving to mobile reserve muster pt, X: %d, Y: %d", m_TargetedHomelandRoads[iI].GetTargetX(), m_TargetedHomelandRoads[iI].GetTargetY());

	mov	edx, DWORD PTR [esi+2480]
	mov	eax, DWORD PTR tv499[esp+64]
	mov	ecx, DWORD PTR [eax+edx+8]
	add	eax, edx
	mov	eax, DWORD PTR [eax+4]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _strLogString$225674[esp+72]
	push	OFFSET $SG225675
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+88], ebp
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1157 : 						LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$225674[esp+64]
	push	edx
	mov	ecx, esi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1158 : 					}

	lea	ecx, DWORD PTR _strLogString$225674[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@PlotMobile:
	mov	ecx, DWORD PTR [esi+2484]
	sub	ecx, DWORD PTR [esi+2480]
	add	DWORD PTR tv499[esp+64], 20		; 00000014H
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ebx
	add	eax, edx
	mov	DWORD PTR _iI$225666[esp+64], ebx
	cmp	ebx, eax
	jb	$LL6@PlotMobile
	pop	edi
	pop	ebx
$LN89@PlotMobile:
	pop	ebp
$LN4@PlotMobile:

; 1159 : 				}
; 1160 : 			}
; 1161 : 		}
; 1162 : 	}
; 1163 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$225674[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ ENDP	; CvHomelandAI::PlotMobileReserveMoves
PUBLIC	?PlotSentryMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotSentryMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?PlotSentryMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotSentryMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotSentryMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotSentryMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotSentryMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv503 = -48						; size = 4
_iI$225680 = -44					; size = 4
_strLogString$225689 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?PlotSentryMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotSentryMoves, COMDAT
; _this$ = ecx

; 1167 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?PlotSentryMoves@CvHomelandAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	esi, ecx

; 1168 : 	// Do we have any targets of this type?
; 1169 : 	if(!m_TargetedSentryPoints.empty())

	mov	ecx, DWORD PTR [esi+2436]
	sub	ecx, DWORD PTR [esi+2432]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	je	$LN4@PlotSentry

; 1170 : 	{
; 1171 : 		// Prioritize them (LATER)
; 1172 : 
; 1173 : 		// See how many moves of this type we can execute
; 1174 : 		for(unsigned int iI = 0; iI < m_TargetedSentryPoints.size(); iI++)

	mov	ecx, DWORD PTR [esi+2436]
	sub	ecx, DWORD PTR [esi+2432]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	push	ebp
	xor	ebp, ebp
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR _iI$225680[esp+56], ebp
	je	$LN93@PlotSentry
	push	ebx
	mov	DWORD PTR tv503[esp+60], ebp
	push	edi
	npad	2
$LL6@PlotSentry:

; 1175 : 		{
; 1176 : #ifndef AUI_PERF_LOGGING_FORMATTING_TWEAKS // Not needed because it's already covered by the general move performance log
; 1177 : 			AI_PERF_FORMAT("Homeland-perf.csv", ("PlotSentryMoves, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 1178 : #endif
; 1179 : 
; 1180 : 			CvPlot* pTarget = GC.getMap().plot(m_TargetedSentryPoints[iI].GetTargetX(), m_TargetedSentryPoints[iI].GetTargetY());

	mov	edx, DWORD PTR [esi+2432]
	mov	eax, DWORD PTR tv503[esp+64]
	mov	ebx, DWORD PTR [eax+edx+8]
	add	eax, edx
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN27@PlotSentry
	cmp	ebx, -2147483647			; 80000001H
	je	$LN27@PlotSentry
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN37@PlotSentry
	test	eax, eax
	jge	SHORT $LN39@PlotSentry
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN41@PlotSentry
$LN39@PlotSentry:
	cmp	eax, ecx
	jl	SHORT $LN37@PlotSentry
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN41@PlotSentry
$LN37@PlotSentry:
	mov	edi, eax
$LN41@PlotSentry:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebp, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN90@PlotSentry
	test	ebx, ebx
	jge	SHORT $LN49@PlotSentry
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN51@PlotSentry
$LN49@PlotSentry:
	cmp	ebx, ebp
	jl	SHORT $LN90@PlotSentry
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN51@PlotSentry
$LN90@PlotSentry:
	mov	edx, ebx
$LN51@PlotSentry:
	test	edi, edi
	jl	SHORT $LN27@PlotSentry
	cmp	edi, ecx
	jge	SHORT $LN27@PlotSentry
	test	edx, edx
	jl	SHORT $LN27@PlotSentry
	cmp	edx, ebp
	jge	SHORT $LN27@PlotSentry
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	edi, ecx
	jmp	SHORT $LN29@PlotSentry
$LN27@PlotSentry:
	xor	edi, edi
$LN29@PlotSentry:

; 1181 : 
; 1182 : 			FindUnitsForThisMove(AI_HOMELAND_MOVE_SENTRY, (iI == 0)/*bFirstTime*/);

	mov	ebx, DWORD PTR _iI$225680[esp+64]
	xor	ebp, ebp
	cmp	ebx, ebp
	sete	al
	movzx	ecx, al
	push	ecx
	push	8
	mov	ecx, esi
	call	?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z ; CvHomelandAI::FindUnitsForThisMove

; 1183 : 
; 1184 : 			if(m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR [esi+1060]
	mov	ecx, DWORD PTR [esi+20]
	add	ecx, eax
	je	$LN5@PlotSentry

; 1185 : 			{
; 1186 : 				if(GetBestUnitToReachTarget(pTarget, MAX_INT))

	push	2147483647				; 7fffffffH
	push	edi
	mov	ecx, esi
	call	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
	test	al, al
	je	$LN5@PlotSentry

; 1187 : 				{
; 1188 : 					ExecuteMoveToTarget(pTarget);

	push	edi
	mov	ecx, esi
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 1189 : 
; 1190 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN5@PlotSentry
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN5@PlotSentry

; 1191 : 					{
; 1192 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225689[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1193 : 						strLogString.Format("Moving to sentry point, X: %d, Y: %d, Priority: %d", m_TargetedSentryPoints[iI].GetTargetX(), m_TargetedSentryPoints[iI].GetTargetY(), m_TargetedSentryPoints[iI].GetAuxIntData());

	mov	edx, DWORD PTR [esi+2432]
	mov	eax, DWORD PTR tv503[esp+64]
	mov	ecx, DWORD PTR [eax+edx+16]
	add	eax, edx
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strLogString$225689[esp+76]
	push	OFFSET $SG225690
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+92], ebp
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1194 : 						LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$225689[esp+64]
	push	edx
	mov	ecx, esi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1195 : 					}

	lea	ecx, DWORD PTR _strLogString$225689[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@PlotSentry:
	mov	ecx, DWORD PTR [esi+2436]
	sub	ecx, DWORD PTR [esi+2432]
	add	DWORD PTR tv503[esp+64], 20		; 00000014H
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ebx
	add	eax, edx
	mov	DWORD PTR _iI$225680[esp+64], ebx
	cmp	ebx, eax
	jb	$LL6@PlotSentry
	pop	edi
	pop	ebx
$LN93@PlotSentry:
	pop	ebp
$LN4@PlotSentry:

; 1196 : 				}
; 1197 : 			}
; 1198 : 		}
; 1199 : 	}
; 1200 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotSentryMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$225689[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotSentryMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotSentryMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotSentryMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotSentryMoves
PUBLIC	?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotAncientRuinMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
tv502 = -48						; size = 4
_iI$225907 = -44					; size = 4
_strLogString$225915 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotAncientRuinMoves, COMDAT
; _this$ = ecx

; 1651 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	esi, ecx

; 1652 : 	// Do we have any targets of this type?
; 1653 : 	if(!m_TargetedAncientRuins.empty())

	mov	ecx, DWORD PTR [esi+2500]
	sub	ecx, DWORD PTR [esi+2496]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	je	$LN4@PlotAncien

; 1654 : 	{
; 1655 : 		// Prioritize them (LATER)
; 1656 : 
; 1657 : 		// See how many moves of this type we can execute
; 1658 : 		for(unsigned int iI = 0; iI < m_TargetedAncientRuins.size(); iI++)

	mov	ecx, DWORD PTR [esi+2500]
	sub	ecx, DWORD PTR [esi+2496]
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	push	ebp
	xor	ebp, ebp
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR _iI$225907[esp+56], ebp
	je	$LN89@PlotAncien
	push	ebx
	mov	DWORD PTR tv502[esp+60], ebp
	push	edi
	npad	2
$LL6@PlotAncien:

; 1659 : 		{
; 1660 : 			CvPlot* pTarget = GC.getMap().plot(m_TargetedAncientRuins[iI].GetTargetX(), m_TargetedAncientRuins[iI].GetTargetY());

	mov	edx, DWORD PTR [esi+2496]
	mov	eax, DWORD PTR tv502[esp+64]
	mov	ebx, DWORD PTR [eax+edx+8]
	add	eax, edx
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -2147483647			; 80000001H
	je	$LN27@PlotAncien
	cmp	ebx, -2147483647			; 80000001H
	je	$LN27@PlotAncien
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	dl, BYTE PTR [ecx+4056]
	mov	ecx, DWORD PTR [ecx+4020]
	test	dl, dl
	je	SHORT $LN37@PlotAncien
	test	eax, eax
	jge	SHORT $LN39@PlotAncien
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN41@PlotAncien
$LN39@PlotAncien:
	cmp	eax, ecx
	jl	SHORT $LN37@PlotAncien
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN41@PlotAncien
$LN37@PlotAncien:
	mov	edi, eax
$LN41@PlotAncien:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	al, BYTE PTR [edx+4057]
	mov	ebp, DWORD PTR [edx+4024]
	test	al, al
	je	SHORT $LN86@PlotAncien
	test	ebx, ebx
	jge	SHORT $LN49@PlotAncien
	mov	eax, ebx
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN51@PlotAncien
$LN49@PlotAncien:
	cmp	ebx, ebp
	jl	SHORT $LN86@PlotAncien
	mov	eax, ebx
	cdq
	idiv	ebp
	jmp	SHORT $LN51@PlotAncien
$LN86@PlotAncien:
	mov	edx, ebx
$LN51@PlotAncien:
	test	edi, edi
	jl	SHORT $LN27@PlotAncien
	cmp	edi, ecx
	jge	SHORT $LN27@PlotAncien
	test	edx, edx
	jl	SHORT $LN27@PlotAncien
	cmp	edx, ebp
	jge	SHORT $LN27@PlotAncien
	imul	ecx, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [edx+4068]
	mov	edi, ecx
	jmp	SHORT $LN29@PlotAncien
$LN27@PlotAncien:
	xor	edi, edi
$LN29@PlotAncien:

; 1661 : 
; 1662 : 			FindUnitsForThisMove(AI_HOMELAND_MOVE_ANCIENT_RUINS, (iI == 0)/*bFirstTime*/);

	mov	ebx, DWORD PTR _iI$225907[esp+64]
	xor	ebp, ebp
	cmp	ebx, ebp
	sete	al
	movzx	ecx, al
	push	ecx
	push	13					; 0000000dH
	mov	ecx, esi
	call	?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z ; CvHomelandAI::FindUnitsForThisMove

; 1663 : 
; 1664 : 			if(m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR [esi+1060]
	mov	ecx, DWORD PTR [esi+20]
	add	ecx, eax
	je	$LN5@PlotAncien

; 1665 : 			{
; 1666 : 				if(GetBestUnitToReachTarget(pTarget, m_iDefensiveMoveTurns))

	mov	edx, DWORD PTR [esi+2528]
	push	edx
	push	edi
	mov	ecx, esi
	call	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
	test	al, al
	je	SHORT $LN5@PlotAncien

; 1667 : 				{
; 1668 : 					ExecuteMoveToTarget(pTarget);

	push	edi
	mov	ecx, esi
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 1669 : 
; 1670 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN5@PlotAncien
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN5@PlotAncien

; 1671 : 					{
; 1672 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$225915[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1673 : 						strLogString.Format("Moving to goody hut (non-explorer), X: %d, Y: %d", m_TargetedAncientRuins[iI].GetTargetX(), m_TargetedAncientRuins[iI].GetTargetY());

	mov	eax, DWORD PTR [esi+2496]
	mov	ecx, DWORD PTR tv502[esp+64]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+4]
	push	ecx
	push	eax
	lea	edx, DWORD PTR _strLogString$225915[esp+72]
	push	OFFSET $SG225916
	push	edx
	mov	DWORD PTR __$EHRec$[esp+88], ebp
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1674 : 						LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$225915[esp+64]
	push	eax
	mov	ecx, esi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1675 : 					}

	lea	ecx, DWORD PTR _strLogString$225915[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@PlotAncien:
	mov	ecx, DWORD PTR [esi+2500]
	sub	ecx, DWORD PTR [esi+2496]
	add	DWORD PTR tv502[esp+64], 20		; 00000014H
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	inc	ebx
	add	ecx, edx
	mov	DWORD PTR _iI$225907[esp+64], ebx
	cmp	ebx, ecx
	jb	$LL6@PlotAncien
	pop	edi
	pop	ebx
$LN89@PlotAncien:
	pop	ebp
$LN4@PlotAncien:

; 1676 : 				}
; 1677 : 			}
; 1678 : 		}
; 1679 : 	}
; 1680 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$225915[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotAncientRuinMoves
PUBLIC	?PlotAirliftMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotAirliftMoves
EXTRN	?getName@CvUnit@@QBE?BVCvString@@XZ:PROC	; CvUnit::getName
EXTRN	?GetZoneByCity@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@PAVCvCity@@_N@Z:PROC ; CvTacticalAnalysisMap::GetZoneByCity
EXTRN	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ:PROC ; CvGame::GetTacticalAnalysisMap
EXTRN	?CanAirlift@CvCity@@QBE_NXZ:PROC		; CvCity::CanAirlift
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$4
	DD	01H
	DD	FLAT:__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$5
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotAirliftMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$ = -128						; size = 4
_pLoopCity$ = -128					; size = 4
_iCityLoop$ = -124					; size = 4
_pMap$ = -120						; size = 4
_pLoopPlot$226705 = -116				; size = 4
_pBestDefender$226708 = -112				; size = 8
_aAirliftPlots$ = -104					; size = 16
_aAirliftCities$ = -88					; size = 16
_strLogString$226891 = -72				; size = 28
_strLogString$226725 = -72				; size = 28
$T280433 = -44						; size = 28
__$EHRec$ = -12						; size = 12
?PlotAirliftMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotAirliftMoves, COMDAT
; _this$ = ecx

; 2126 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 2127 : 	if (m_pPlayer->isHuman())

	mov	ecx, DWORD PTR [ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	jne	$LN438@PlotAirlif

; 2128 : 	{
; 2129 : 		return;
; 2130 : 	}
; 2131 : 
; 2132 : 	// Need at least 2 cities with airports
; 2133 : 	vector<CvCity *> aAirliftCities;

	xor	edi, edi
	xor	ebx, ebx
	mov	DWORD PTR _aAirliftCities$[esp+148], ebx
	mov	DWORD PTR _aAirliftCities$[esp+152], edi
	mov	DWORD PTR _aAirliftCities$[esp+156], edi

; 2134 : 	CvCity *pLoopCity;
; 2135 : 	int iCityLoop;
; 2136 : 	for (pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	mov	ecx, DWORD PTR [ebp]
	push	edi
	lea	eax, DWORD PTR _iCityLoop$[esp+148]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+160], edi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	xor	eax, eax
	mov	DWORD PTR _pLoopCity$[esp+144], esi
	cmp	esi, eax
	je	SHORT $LN22@PlotAirlif
$LL24@PlotAirlif:

; 2137 : 	{
; 2138 : 		if (pLoopCity->CanAirlift())

	mov	ecx, esi
	call	?CanAirlift@CvCity@@QBE_NXZ		; CvCity::CanAirlift
	test	al, al
	je	SHORT $LN23@PlotAirlif

; 2139 : 		{
; 2140 : 			aAirliftCities.push_back(pLoopCity);

	test	ebx, ebx
	jne	SHORT $LN79@PlotAirlif
	xor	eax, eax
	jmp	SHORT $LN80@PlotAirlif
$LN79@PlotAirlif:
	mov	eax, DWORD PTR _aAirliftCities$[esp+156]
	sub	eax, ebx
	sar	eax, 2
$LN80@PlotAirlif:
	mov	ecx, edi
	sub	ecx, ebx
	sar	ecx, 2
	cmp	ecx, eax
	jae	SHORT $LN72@PlotAirlif
	mov	DWORD PTR [edi], esi
	add	edi, 4
	mov	DWORD PTR _aAirliftCities$[esp+152], edi
	jmp	SHORT $LN23@PlotAirlif
$LN72@PlotAirlif:
	lea	edx, DWORD PTR _pLoopCity$[esp+144]
	push	edx
	push	1
	push	edi
	lea	ecx, DWORD PTR _aAirliftCities$[esp+156]
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
	mov	edi, DWORD PTR _aAirliftCities$[esp+152]
	mov	ebx, DWORD PTR _aAirliftCities$[esp+148]
$LN23@PlotAirlif:
	mov	ecx, DWORD PTR [ebp]
	push	0
	lea	eax, DWORD PTR _iCityLoop$[esp+148]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	mov	DWORD PTR _pLoopCity$[esp+144], esi
	test	esi, esi
	jne	SHORT $LL24@PlotAirlif
$LN22@PlotAirlif:

; 2141 : 		}
; 2142 : 	}
; 2143 : 	if (aAirliftCities.size() < 2)

	mov	ecx, edi
	sub	ecx, ebx
	sar	ecx, 2
	cmp	ecx, 2
	jae	SHORT $LN20@PlotAirlif

; 2144 : 	{
; 2145 : 		return;

	cmp	ebx, eax
	jmp	$LN463@PlotAirlif
$LN20@PlotAirlif:

; 2146 : 	}
; 2147 : 
; 2148 : 	// Create list of empty land plots we own adjacent to airlift cities that are not endangered
; 2149 : 	vector<CvPlot *> aAirliftPlots;

	mov	DWORD PTR _aAirliftPlots$[esp+148], eax
	mov	DWORD PTR _aAirliftPlots$[esp+152], eax
	mov	DWORD PTR _aAirliftPlots$[esp+156], eax

; 2150 : 	CvTacticalAnalysisMap* pMap = GC.getGame().GetTacticalAnalysisMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	BYTE PTR __$EHRec$[esp+152], 1
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap

; 2151 : 	CvTacticalDominanceZone *pZone;
; 2152 : 	vector<CvCity *>::const_iterator it;
; 2153 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 2154 : 	for (it = aAirliftCities.begin(); it != aAirliftCities.end(); ++it)
; 2155 : #else
; 2156 : 	for (it = aAirliftCities.begin(); it != aAirliftCities.end(); it++)

	mov	esi, ebx
	mov	DWORD PTR _pMap$[esp+144], eax
	mov	DWORD PTR _it$[esp+144], esi
	cmp	ebx, edi
	je	$LN17@PlotAirlif
$LN189@PlotAirlif:

; 2157 : #endif
; 2158 : 	{
; 2159 : 		pZone = pMap->GetZoneByCity(*it, false);

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR _pMap$[esp+144]
	push	0
	push	edx
	call	?GetZoneByCity@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@PAVCvCity@@_N@Z ; CvTacticalAnalysisMap::GetZoneByCity

; 2160 : 		if (pZone && (pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_FRIENDLY || pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_NO_UNITS_VISIBLE))

	test	eax, eax
	je	$LN18@PlotAirlif
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, 1
	je	SHORT $LN15@PlotAirlif
	test	eax, eax
	jne	$LN18@PlotAirlif
$LN15@PlotAirlif:

; 2161 : 		{
; 2162 : 			for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	xor	edi, edi
$LL14@PlotAirlif:

; 2163 : 			{
; 2164 : 				CvPlot *pLoopPlot = plotDirection((*it)->getX(), (*it)->getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR [eax+96]
	push	edi
	push	ecx
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$226705[esp+144], esi

; 2165 : 				if (pLoopPlot != NULL && !pLoopPlot->isWater() && !pLoopPlot->isMountain() && pLoopPlot->getOwner() == m_pPlayer->GetID())

	test	esi, esi
	je	$LN13@PlotAirlif
	mov	al, BYTE PTR [esi+5]
	cmp	al, 3
	je	$LN13@PlotAirlif
	test	al, al
	je	$LN13@PlotAirlif
	mov	eax, DWORD PTR [ebp]
	movsx	edx, BYTE PTR [esi+4]
	mov	ecx, DWORD PTR [eax+44]
	cmp	edx, ecx
	jne	$LN13@PlotAirlif

; 2166 : 				{
; 2167 : 					UnitHandle pBestDefender = pLoopPlot->getBestDefender(m_pPlayer->GetID());

	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, ecx
	push	-1
	push	eax
	lea	eax, DWORD PTR _pBestDefender$226708[esp+172]
	push	eax
	mov	ecx, esi
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender

; 2168 : 					if (pBestDefender)

	mov	eax, DWORD PTR _pBestDefender$226708[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 2
	test	eax, eax
	je	$LN10@PlotAirlif

; 2169 : 					{
; 2170 : 						if (std::find(m_CurrentTurnUnits.begin(), m_CurrentTurnUnits.end(), pBestDefender->GetID()) != m_CurrentTurnUnits.end())

	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [eax+100]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, ecx
	je	$LN377@PlotAirlif
	npad	6
$LL271@PlotAirlif:
	cmp	DWORD PTR [eax+8], edx
	je	SHORT $LN447@PlotAirlif
	mov	eax, DWORD PTR [eax]
	cmp	eax, ecx
	jne	SHORT $LL271@PlotAirlif
$LN447@PlotAirlif:
	cmp	eax, ecx
	je	$LN377@PlotAirlif

; 2171 : 						{
; 2172 : 							pBestDefender->finishMoves();

	mov	ecx, DWORD PTR _pBestDefender$226708[esp+144]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 2173 : 							UnitProcessed(pBestDefender->GetID());

	mov	ecx, DWORD PTR _pBestDefender$226708[esp+144]
	mov	eax, DWORD PTR [ecx+100]
	push	eax
	mov	ecx, ebp
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 2174 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN377@PlotAirlif
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN377@PlotAirlif

; 2175 : 							{
; 2176 : 								CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226725[esp+144]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2177 : 								strLogString.Format("Remaining in place for future airlift - %s, X: %d, Y: %d", pBestDefender->getName().GetCString(), pBestDefender->getX(), pBestDefender->getY());

	mov	ecx, DWORD PTR _pBestDefender$226708[esp+144]
	lea	edx, DWORD PTR $T280433[esp+144]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+156], 3
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR _pBestDefender$226708[esp+144]
	mov	edx, DWORD PTR [ecx+88]
	mov	ecx, DWORD PTR [ecx+76]
	push	edx
	push	ecx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+160], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _strLogString$226725[esp+156]
	push	OFFSET $SG226727
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T280433[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2178 : 								LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$226725[esp+144]
	push	ecx
	mov	ecx, ebp
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2179 : 							}

	lea	ecx, DWORD PTR _strLogString$226725[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2180 : 						}
; 2181 : 					}
; 2182 : 					else

	jmp	SHORT $LN377@PlotAirlif
$LN10@PlotAirlif:

; 2183 : 					{
; 2184 : 						aAirliftPlots.push_back(pLoopPlot);

	mov	edx, DWORD PTR _aAirliftPlots$[esp+148]
	test	edx, edx
	jne	SHORT $LN330@PlotAirlif
	xor	eax, eax
	jmp	SHORT $LN331@PlotAirlif
$LN330@PlotAirlif:
	mov	eax, DWORD PTR _aAirliftPlots$[esp+156]
	sub	eax, edx
	sar	eax, 2
$LN331@PlotAirlif:
	mov	ecx, DWORD PTR _aAirliftPlots$[esp+152]
	mov	ebx, ecx
	sub	ebx, edx
	sar	ebx, 2
	cmp	ebx, eax
	jae	SHORT $LN323@PlotAirlif
	mov	DWORD PTR [ecx], esi
	add	ecx, 4
	mov	DWORD PTR _aAirliftPlots$[esp+152], ecx
	jmp	SHORT $LN465@PlotAirlif
$LN323@PlotAirlif:
	lea	edx, DWORD PTR _pLoopPlot$226705[esp+144]
	push	edx
	push	1
	push	ecx
	lea	ecx, DWORD PTR _aAirliftPlots$[esp+156]
	call	?_Insert_n@?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@2@IABQAVCvPlot@@@Z ; std::vector<CvPlot *,std::allocator<CvPlot *> >::_Insert_n
$LN465@PlotAirlif:
	mov	ebx, DWORD PTR _aAirliftCities$[esp+148]
$LN377@PlotAirlif:

; 2185 : 					}
; 2186 : 				}

	mov	ecx, DWORD PTR _pBestDefender$226708[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 1
	test	ecx, ecx
	je	SHORT $LN13@PlotAirlif
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN13@PlotAirlif:

; 2161 : 		{
; 2162 : 			for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	esi, DWORD PTR _it$[esp+144]
	inc	edi
	cmp	edi, 6
	jl	$LL14@PlotAirlif
	mov	edi, DWORD PTR _aAirliftCities$[esp+152]
$LN18@PlotAirlif:

; 2151 : 	CvTacticalDominanceZone *pZone;
; 2152 : 	vector<CvCity *>::const_iterator it;
; 2153 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 2154 : 	for (it = aAirliftCities.begin(); it != aAirliftCities.end(); ++it)
; 2155 : #else
; 2156 : 	for (it = aAirliftCities.begin(); it != aAirliftCities.end(); it++)

	add	esi, 4
	mov	DWORD PTR _it$[esp+144], esi
	cmp	esi, edi
	jne	$LN189@PlotAirlif
$LN17@PlotAirlif:

; 2187 : 			}
; 2188 : 		}
; 2189 : 	}
; 2190 : 
; 2191 : 	vector<CvPlot *>::const_iterator plotIt;
; 2192 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 2193 : 	for (plotIt = aAirliftPlots.begin(); plotIt != aAirliftPlots.end(); ++plotIt)
; 2194 : #else
; 2195 : 	for (plotIt = aAirliftPlots.begin(); plotIt != aAirliftPlots.end(); plotIt++)

	mov	edi, DWORD PTR _aAirliftPlots$[esp+148]
	mov	eax, edi
	cmp	eax, DWORD PTR _aAirliftPlots$[esp+152]
	je	$LN4@PlotAirlif
	mov	bl, 5
	npad	4
$LL398@PlotAirlif:

; 2196 : #endif
; 2197 : 	{
; 2198 : 		FindUnitsForThisMove(AI_HOMELAND_MOVE_MOBILE_RESERVE, true);

	push	1
	push	7
	mov	ecx, ebp
	call	?FindUnitsForThisMove@CvHomelandAI@@AAE_NW4AIHomelandMove@@_N@Z ; CvHomelandAI::FindUnitsForThisMove

; 2199 : 
; 2200 : 		if(m_CurrentMoveHighPriorityUnits.size() + m_CurrentMoveUnits.size() > 0)

	mov	eax, DWORD PTR [ebp+1060]
	mov	ecx, DWORD PTR [ebp+20]
	add	eax, ecx
	je	$LN5@PlotAirlif

; 2201 : 		{
; 2202 : 			CvPlot *pTarget = *plotIt;

	mov	esi, DWORD PTR [edi]

; 2203 : 
; 2204 : 			if (GetBestUnitToReachTarget(pTarget, MAX_INT))

	push	2147483647				; 7fffffffH
	push	esi
	mov	ecx, ebp
	call	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
	test	al, al
	je	SHORT $LN5@PlotAirlif

; 2205 : 			{
; 2206 : 				ExecuteMoveToTarget(pTarget);

	push	esi
	mov	ecx, ebp
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 2207 : 
; 2208 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN5@PlotAirlif
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN5@PlotAirlif

; 2209 : 				{
; 2210 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226891[esp+144]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2211 : 					strLogString.Format("Moving to airlift origin plot, X: %d, Y: %d", pTarget->getX(), pTarget->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strLogString$226891[esp+152]
	push	OFFSET $SG226892
	push	edx
	mov	BYTE PTR __$EHRec$[esp+168], bl
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2212 : 					LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$226891[esp+144]
	push	eax
	mov	ecx, ebp
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2213 : 				}

	lea	ecx, DWORD PTR _strLogString$226891[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@PlotAirlif:
	add	edi, 4
	cmp	edi, DWORD PTR _aAirliftPlots$[esp+152]
	jne	$LL398@PlotAirlif
	mov	ebx, DWORD PTR _aAirliftCities$[esp+148]
	mov	eax, DWORD PTR _aAirliftPlots$[esp+148]
$LN4@PlotAirlif:

; 2214 : 			}
; 2215 : 		}
; 2216 : 	}
; 2217 : }

	test	eax, eax
	je	SHORT $LN431@PlotAirlif
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN431@PlotAirlif:
	test	ebx, ebx
$LN463@PlotAirlif:
	je	SHORT $LN438@PlotAirlif
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN438@PlotAirlif:
	mov	ecx, DWORD PTR __$EHRec$[esp+144]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _aAirliftCities$[ebp]
	jmp	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _aAirliftPlots$[ebp]
	jmp	??1?$vector@PAVCvPlot@@V?$allocator@PAVCvPlot@@@std@@@std@@QAE@XZ ; std::vector<CvPlot *,std::allocator<CvPlot *> >::~vector<CvPlot *,std::allocator<CvPlot *> >
__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _pBestDefender$226708[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$226725[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR $T280433[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR _strLogString$226891[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotAirliftMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotAirliftMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotAirliftMoves
PUBLIC	?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::ExecuteEngineerMoves
EXTRN	?pushOrder@CvCity@@QAEXW4OrderTypes@@HH_N111@Z:PROC ; CvCity::pushOrder
EXTRN	?getMISSION_HURRY@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_HURRY
EXTRN	?getProductionTurnsLeft@CvCity@@QBEHXZ:PROC	; CvCity::getProductionTurnsLeft
EXTRN	?getProductionBuilding@CvCity@@QBE?AW4BuildingTypes@@XZ:PROC ; CvCity::getProductionBuilding
EXTRN	?getProductionNeeded@CvCity@@QBEHW4BuildingTypes@@@Z:PROC ; CvCity::getProductionNeeded
EXTRN	?getProduction@CvCity@@QBEHXZ:PROC		; CvCity::getProduction
EXTRN	?GetWonderBuildCity@CvCitySpecializationAI@@QBEPAVCvCity@@XZ:PROC ; CvCitySpecializationAI::GetWonderBuildCity
EXTRN	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ:PROC ; CvPlayer::GetCitySpecializationAI
EXTRN	?ChooseWonderForGreatEngineer@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_NAAHAAPAVCvCity@@@Z:PROC ; CvWonderProductionAI::ChooseWonderForGreatEngineer
EXTRN	?GetWonderProductionAI@CvPlayer@@QBEPAVCvWonderProductionAI@@XZ:PROC ; CvPlayer::GetWonderProductionAI
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__ehfuncinfo$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$6
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$7
	DD	00H
	DD	FLAT:__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$8
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_pCityToBuildAt$227705 = -104				; size = 4
_eNextWonderDesired$227706 = -100			; size = 4
_it$ = -96						; size = 4
$T281885 = -92						; size = 4
_iProductionSoFar$227714 = -92				; size = 4
$T281886 = -88						; size = 4
_iTurnsRemaining$227717 = -88				; size = 4
_iProductionRemaining$227715 = -88			; size = 4
_iNextWonderWeight$227704 = -84				; size = 4
_pUnit$227694 = -80					; size = 8
_strLogString$227739 = -72				; size = 28
_strLogString$227735 = -72				; size = 28
_strLogString$227727 = -72				; size = 28
_strLogString$227722 = -72				; size = 28
_strLogString$227709 = -72				; size = 28
_strLogString$227744 = -44				; size = 28
__$EHRec$ = -12						; size = 12
?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::ExecuteEngineerMoves, COMDAT
; _this$ = ecx

; 3636 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 3637 : 	CvCity* pWonderCity;
; 3638 : 	int iTurnsToTarget;
; 3639 : 
; 3640 : 	FStaticVector< CvHomelandUnit, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 3641 : 	for(it = m_CurrentMoveUnits.begin(); it != m_CurrentMoveUnits.end(); ++it)

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [edi+20]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _it$[esp+120], eax
	cmp	eax, ecx
	je	$LN29@ExecuteEng
	npad	5
$LL31@ExecuteEng:

; 3642 : 	{
; 3643 : 		UnitHandle pUnit = m_pPlayer->getUnit(it->GetID());

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	esi, eax
	xor	ebp, ebp
	mov	DWORD PTR _pUnit$227694[esp+120], esi
	mov	BYTE PTR _pUnit$227694[esp+124], 0
	cmp	esi, ebp
	je	SHORT $LN52@ExecuteEng
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN52@ExecuteEng:
	mov	DWORD PTR __$EHRec$[esp+128], ebp

; 3644 : 		if(!pUnit)

	cmp	esi, ebp
	jne	SHORT $LN28@ExecuteEng

; 3645 : 		{
; 3646 : 			continue;

	mov	DWORD PTR __$EHRec$[esp+128], -1
	jmp	$LN30@ExecuteEng
$LN28@ExecuteEng:

; 3647 : 		}
; 3648 : 
; 3649 : 		GreatPeopleDirectiveTypes eDirective = pUnit->GetGreatPeopleDirective();

	mov	ecx, esi
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective

; 3650 : 		switch(eDirective)

	inc	eax
	cmp	eax, 3
	ja	$LN26@ExecuteEng
	jmp	DWORD PTR $LN215@ExecuteEng[eax*4]
$LN25@ExecuteEng:

; 3651 : 		{
; 3652 : 		case GREAT_PEOPLE_DIRECTIVE_CONSTRUCT_IMPROVEMENT:
; 3653 : 			ExecuteWorkerMove(pUnit.pointer());

	push	esi
	mov	ecx, edi
	call	?ExecuteWorkerMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteWorkerMove

; 3654 : 			break;

	jmp	$LN26@ExecuteEng
$LN24@ExecuteEng:

; 3655 : 		case GREAT_PEOPLE_DIRECTIVE_GOLDEN_AGE:
; 3656 : 			ExecuteGoldenAgeMove(pUnit.pointer());

	push	esi
	mov	ecx, edi
	call	?ExecuteGoldenAgeMove@CvHomelandAI@@AAE_NPAVCvUnit@@@Z ; CvHomelandAI::ExecuteGoldenAgeMove

; 3657 : 			break;

	jmp	$LN26@ExecuteEng
$LN23@ExecuteEng:

; 3658 : 		case GREAT_PEOPLE_DIRECTIVE_USE_POWER:
; 3659 : 		{
; 3660 : 			// Do we want to build any wonder?
; 3661 : 			int iNextWonderWeight;
; 3662 : 			CvCity* pCityToBuildAt = 0;
; 3663 : 			BuildingTypes eNextWonderDesired = m_pPlayer->GetWonderProductionAI()->ChooseWonderForGreatEngineer(false, iNextWonderWeight, pCityToBuildAt);

	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR _pCityToBuildAt$227705[esp+120]
	push	edx
	lea	eax, DWORD PTR _iNextWonderWeight$227704[esp+124]
	push	eax
	push	ebp
	mov	DWORD PTR _pCityToBuildAt$227705[esp+132], ebp
	call	?GetWonderProductionAI@CvPlayer@@QBEPAVCvWonderProductionAI@@XZ ; CvPlayer::GetWonderProductionAI
	mov	ecx, eax
	call	?ChooseWonderForGreatEngineer@CvWonderProductionAI@@QAE?AW4BuildingTypes@@_NAAHAAPAVCvCity@@@Z ; CvWonderProductionAI::ChooseWonderForGreatEngineer
	mov	ebx, eax
	mov	DWORD PTR _eNextWonderDesired$227706[esp+120], ebx

; 3664 : 
; 3665 : 			// No?  Just move to safety...
; 3666 : 			if(eNextWonderDesired == NO_BUILDING)

	cmp	ebx, -1
	jne	$LN22@ExecuteEng

; 3667 : 			{
; 3668 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@ExecuteEng
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@ExecuteEng

; 3669 : 				{
; 3670 : 					CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227709[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3671 : 					strLogString.Format("Great builder can't find a good wonder to build. Running to safety");

	lea	ecx, DWORD PTR _strLogString$227709[esp+120]
	push	OFFSET $SG227710
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+136], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 3672 : 					LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227709[esp+120]
	push	edx
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3673 : 				}

	lea	ecx, DWORD PTR _strLogString$227709[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ExecuteEng:

; 3790 : 		case NO_GREAT_PEOPLE_DIRECTIVE_TYPE:
; 3791 : 			MoveCivilianToSafety(pUnit.pointer());

	push	ebp
	push	esi
	mov	ecx, edi
	call	?MoveCivilianToSafety@CvHomelandAI@@AAE_NPAVCvUnit@@_N@Z ; CvHomelandAI::MoveCivilianToSafety
$LN26@ExecuteEng:

; 3792 : 			break;
; 3793 : 		}
; 3794 : 	}

	mov	DWORD PTR __$EHRec$[esp+128], -1
$LN212@ExecuteEng:
	mov	ecx, esi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN30@ExecuteEng:
	mov	ecx, DWORD PTR [edi+20]
	mov	eax, DWORD PTR _it$[esp+120]
	shl	ecx, 4
	add	ecx, DWORD PTR [edi+16]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _it$[esp+120], eax
	cmp	eax, ecx
	jne	$LL31@ExecuteEng
$LN29@ExecuteEng:

; 3795 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+120]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@ExecuteEng:

; 3674 : 
; 3675 : 				MoveCivilianToSafety(pUnit.pointer());
; 3676 : 			}
; 3677 : 			else
; 3678 : 			{
; 3679 : 				bool bForceWonderCity = true;
; 3680 : 
; 3681 : 				// Are we less than 25% done building the most desired wonder chosen by the city specialization AI?
; 3682 : 				pWonderCity = m_pPlayer->GetCitySpecializationAI()->GetWonderBuildCity();

	mov	ecx, DWORD PTR [edi]
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	ecx, eax
	call	?GetWonderBuildCity@CvCitySpecializationAI@@QBEPAVCvCity@@XZ ; CvCitySpecializationAI::GetWonderBuildCity
	mov	ebp, eax

; 3683 : 				if(pWonderCity)

	test	ebp, ebp
	je	$LN201@ExecuteEng

; 3684 : 				{
; 3685 : 					int iProductionSoFar = pWonderCity->getProduction();

	mov	ecx, ebp
	call	?getProduction@CvCity@@QBEHXZ		; CvCity::getProduction

; 3686 : 					int iProductionRemaining = pWonderCity->getProductionNeeded(eNextWonderDesired);

	push	ebx
	mov	ecx, ebp
	mov	DWORD PTR _iProductionSoFar$227714[esp+124], eax
	call	?getProductionNeeded@CvCity@@QBEHW4BuildingTypes@@@Z ; CvCity::getProductionNeeded

; 3687 : 
; 3688 : 					if(pWonderCity->getProductionBuilding() == eNextWonderDesired && iProductionSoFar * 3 < iProductionRemaining)

	mov	ecx, ebp
	mov	DWORD PTR _iProductionRemaining$227715[esp+120], eax
	call	?getProductionBuilding@CvCity@@QBE?AW4BuildingTypes@@XZ ; CvCity::getProductionBuilding
	cmp	eax, ebx
	jne	$LN201@ExecuteEng
	mov	eax, DWORD PTR _iProductionSoFar$227714[esp+120]
	lea	eax, DWORD PTR [eax+eax*2]
	cmp	eax, DWORD PTR _iProductionRemaining$227715[esp+120]
	jge	$LN201@ExecuteEng

; 3689 : 					{
; 3690 : 						// If engineer can move to city before half done
; 3691 : 						int iTurnsRemaining = pWonderCity->getProductionTurnsLeft();

	mov	ecx, ebp
	call	?getProductionTurnsLeft@CvCity@@QBEHXZ	; CvCity::getProductionTurnsLeft

; 3692 : 						iTurnsToTarget = TurnsToReachTarget(pUnit, pWonderCity->plot(), true /*bReusePaths*/, true);

	push	0
	push	1
	push	1
	mov	ecx, ebp
	mov	DWORD PTR _iTurnsRemaining$227717[esp+132], eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	lea	edx, DWORD PTR _pUnit$227694[esp+144]
	mov	ecx, esp
	mov	DWORD PTR $T281885[esp+144], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	mov	ebx, eax

; 3693 : 						if(iTurnsToTarget * 3 < iTurnsRemaining)

	lea	eax, DWORD PTR [ebx+ebx*2]
	add	esp, 24					; 00000018H
	cmp	eax, DWORD PTR _iTurnsRemaining$227717[esp+120]
	jge	$LN201@ExecuteEng

; 3694 : 						{
; 3695 : 							bForceWonderCity = false;
; 3696 : 
; 3697 : 							// Already at target and the wonder is underway?
; 3698 : 							if(pWonderCity->getProductionBuilding() == eNextWonderDesired && iTurnsToTarget == 0 && pUnit->plot() == pWonderCity->plot())

	mov	ecx, ebp
	call	?getProductionBuilding@CvCity@@QBE?AW4BuildingTypes@@XZ ; CvCity::getProductionBuilding
	cmp	eax, DWORD PTR _eNextWonderDesired$227706[esp+120]
	jne	$LN16@ExecuteEng
	test	ebx, ebx
	jne	$LN16@ExecuteEng
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, ebp
	mov	ebx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	cmp	ebx, eax
	jne	$LN16@ExecuteEng

; 3699 : 							{
; 3700 : 								pUnit->PushMission(CvTypes::getMISSION_HURRY());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_HURRY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_HURRY
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3701 : 								UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR [esi+100]
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3702 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN26@ExecuteEng
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN26@ExecuteEng

; 3703 : 								{
; 3704 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227722[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3705 : 									strLogString.Format("Great Engineer hurrying wonder chosen by city specialization AI at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strLogString$227722[esp+128]
	push	OFFSET $SG227723
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+144], 2
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3706 : 									LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227722[esp+120]
	push	edx

; 3707 : 									continue;

	jmp	$LN213@ExecuteEng
$LN16@ExecuteEng:

; 3708 : 								}
; 3709 : 							}
; 3710 : 
; 3711 : 							// No, then move there
; 3712 : 							else
; 3713 : 							{
; 3714 : 								if(GetBestUnitToReachTarget(pWonderCity->plot(), MAX_INT))

	push	2147483647				; 7fffffffH
	mov	ecx, ebp
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, edi
	call	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
	test	al, al
	je	$LN26@ExecuteEng

; 3715 : 								{
; 3716 : 									ExecuteMoveToTarget(pWonderCity->plot());

	mov	ecx, ebp
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, edi
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 3717 : 
; 3718 : 									if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN26@ExecuteEng
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN26@ExecuteEng

; 3719 : 									{
; 3720 : 										CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227727[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3721 : 										strLogString.Format("Moving Great Engineer to city specialization wonder city at, X: %d, Y: %d", pWonderCity->getX(),  pWonderCity->getY());

	mov	eax, DWORD PTR [ebp+108]
	mov	ebp, DWORD PTR [ebp+96]
	push	eax
	push	ebp
	lea	eax, DWORD PTR _strLogString$227727[esp+128]
	push	OFFSET $SG227728
	push	eax
	mov	BYTE PTR __$EHRec$[esp+144], 3
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3722 : 										LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227727[esp+120]
	push	ecx
$LN213@ExecuteEng:
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3723 : 									}

	lea	ecx, DWORD PTR _strLogString$227727[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3724 : 								}
; 3725 : 							}
; 3726 : 						}
; 3727 : 					}
; 3728 : 				}
; 3729 : 
; 3730 : 				if(bForceWonderCity)

	jmp	$LN26@ExecuteEng
$LN201@ExecuteEng:

; 3731 : 				{
; 3732 : 					pWonderCity = pCityToBuildAt;

	mov	ecx, DWORD PTR _pCityToBuildAt$227705[esp+120]
	mov	ebp, ecx

; 3733 : 
; 3734 : 					if(pWonderCity)

	test	ecx, ecx
	je	$LN26@ExecuteEng

; 3735 : 					{
; 3736 : 						iTurnsToTarget = TurnsToReachTarget(pUnit, pWonderCity->plot(), false /*bReusePaths*/, true);

	push	0
	push	1
	push	0
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	sub	esp, 8
	lea	edx, DWORD PTR _pUnit$227694[esp+144]
	mov	ecx, esp
	mov	DWORD PTR $T281886[esp+144], esp
	push	edx
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 3737 : 
; 3738 : 						// Already at target?
; 3739 : 						if(iTurnsToTarget == 0 && pUnit->plot() == pWonderCity->plot())

	test	eax, eax
	jne	$LN9@ExecuteEng
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, ebp
	mov	ebx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	cmp	ebx, eax
	jne	$LN9@ExecuteEng

; 3740 : 						{
; 3741 : 							// Switch production
; 3742 : 							pWonderCity->pushOrder(ORDER_CONSTRUCT, eNextWonderDesired, -1, false, false, false);

	mov	eax, DWORD PTR _eNextWonderDesired$227706[esp+120]
	push	0
	push	0
	push	0
	push	0
	or	ebx, -1
	push	ebx
	push	eax
	push	1
	mov	ecx, ebp
	call	?pushOrder@CvCity@@QAEXW4OrderTypes@@HH_N111@Z ; CvCity::pushOrder

; 3743 : 
; 3744 : 							if (pWonderCity->getProductionTurnsLeft() > 1)

	mov	ecx, ebp
	call	?getProductionTurnsLeft@CvCity@@QBEHXZ	; CvCity::getProductionTurnsLeft
	cmp	eax, 1
	jle	$LN8@ExecuteEng

; 3745 : 							{
; 3746 : 								// Rush it
; 3747 : 								pUnit->PushMission(CvTypes::getMISSION_HURRY());

	push	0
	push	0
	push	ebx
	push	0
	push	0
	push	0
	push	ebx
	push	ebx
	call	?getMISSION_HURRY@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_HURRY
	push	eax
	mov	ecx, esi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3748 : 								UnitProcessed(pUnit->GetID());

	mov	eax, DWORD PTR [esi+100]
	push	eax
	mov	ecx, edi
	call	?UnitProcessed@CvHomelandAI@@AAEXH@Z	; CvHomelandAI::UnitProcessed

; 3749 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN26@ExecuteEng
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN26@ExecuteEng

; 3750 : 								{
; 3751 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227735[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3752 : 									strLogString.Format("Great Engineer hurrying free wonder at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _strLogString$227735[esp+128]
	push	OFFSET $SG227736
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+144], 4
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3753 : 									LogHomelandMessage(strLogString);

	lea	edx, DWORD PTR _strLogString$227735[esp+120]
	push	edx
$LN214@ExecuteEng:
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3754 : 									continue;

	lea	ecx, DWORD PTR _strLogString$227735[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	jmp	$LN212@ExecuteEng
$LN8@ExecuteEng:

; 3755 : 								}
; 3756 : 							}
; 3757 : 							else
; 3758 : 							{
; 3759 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN26@ExecuteEng
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN26@ExecuteEng

; 3760 : 								{
; 3761 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227739[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3762 : 									strLogString.Format("Great Engineer not needed to hurry 1-turn wonder at, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	eax
	push	ecx
	lea	eax, DWORD PTR _strLogString$227739[esp+128]
	push	OFFSET $SG227740
	push	eax
	mov	BYTE PTR __$EHRec$[esp+144], 5
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3763 : 									LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$227739[esp+120]
	push	ecx

; 3764 : 									continue;

	jmp	SHORT $LN214@ExecuteEng
$LN9@ExecuteEng:

; 3765 : 								}
; 3766 : 							}
; 3767 : 						}
; 3768 : 
; 3769 : 						// No, then move there
; 3770 : 						else
; 3771 : 						{
; 3772 : 							if(GetBestUnitToReachTarget(pWonderCity->plot(), MAX_INT))

	push	2147483647				; 7fffffffH
	mov	ecx, ebp
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, edi
	call	?GetBestUnitToReachTarget@CvHomelandAI@@AAE_NPAVCvPlot@@H@Z ; CvHomelandAI::GetBestUnitToReachTarget
	test	al, al
	je	$LN26@ExecuteEng

; 3773 : 							{
; 3774 : 								ExecuteMoveToTarget(pWonderCity->plot());

	mov	ecx, ebp
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, edi
	call	?ExecuteMoveToTarget@CvHomelandAI@@AAEXPAVCvPlot@@@Z ; CvHomelandAI::ExecuteMoveToTarget

; 3775 : 
; 3776 : 								if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN26@ExecuteEng
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN26@ExecuteEng

; 3777 : 								{
; 3778 : 									CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$227744[esp+120]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3779 : 									strLogString.Format("Moving Great Engineer for free wonder to city at, X: %d, Y: %d", pWonderCity->getX(),  pWonderCity->getY());

	mov	eax, DWORD PTR [ebp+108]
	mov	ebp, DWORD PTR [ebp+96]
	push	eax
	push	ebp
	lea	edx, DWORD PTR _strLogString$227744[esp+128]
	push	OFFSET $SG227745
	push	edx
	mov	BYTE PTR __$EHRec$[esp+144], 6
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3780 : 									LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$227744[esp+120]
	push	eax
	mov	ecx, edi
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3781 : 								}

	lea	ecx, DWORD PTR _strLogString$227744[esp+120]
	mov	BYTE PTR __$EHRec$[esp+128], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3782 : 							}
; 3783 : 						}
; 3784 : 
; 3785 : 					}
; 3786 : 				}
; 3787 : 			}
; 3788 : 		}
; 3789 : 		break;

	jmp	$LN26@ExecuteEng
	npad	2
$LN215@ExecuteEng:

; 3795 : }

	DD	$LN1@ExecuteEng
	DD	$LN24@ExecuteEng
	DD	$LN23@ExecuteEng
	DD	$LN25@ExecuteEng
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$227694[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strLogString$227709[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _strLogString$227722[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strLogString$227727[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR _strLogString$227735[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR _strLogString$227739[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ$8:
	lea	ecx, DWORD PTR _strLogString$227744[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::ExecuteEngineerMoves
PUBLIC	?PlotEngineerMoves@CvHomelandAI@@AAEXXZ		; CvHomelandAI::PlotEngineerMoves
;	COMDAT xdata$x
; File s:\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ$0
__ehfuncinfo$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvhomelandai.cpp
xdata$x	ENDS
;	COMDAT ?PlotEngineerMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_it$225996 = -44					; size = 4
_this$ = -40						; size = 4
_pUnit$226002 = -36					; size = 8
_unit$226005 = -28					; size = 16
__$EHRec$ = -12						; size = 12
?PlotEngineerMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::PlotEngineerMoves, COMDAT
; _this$ = ecx

; 1788 : {

	push	-1
	push	__ehhandler$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	ebp

; 1789 : 	ClearCurrentMoveUnits();

	xor	eax, eax
	push	esi
	mov	DWORD PTR [ebx+20], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+2396], eax

; 1790 : 
; 1791 : 	// Loop through all recruited units
; 1792 : 	for(list<int>::iterator it = m_CurrentTurnUnits.begin(); it != m_CurrentTurnUnits.end(); ++it)

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+2400], 2147483647	; 7fffffffH
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp+56], ebx
	mov	DWORD PTR _it$225996[esp+56], ebp
	cmp	ebp, eax
	je	$LN4@PlotEngine
	push	edi
	jmp	SHORT $LN30@PlotEngine
	npad	3
$LL85@PlotEngine:
	mov	ebp, DWORD PTR _it$225996[esp+60]
$LN30@PlotEngine:

; 1793 : 	{
; 1794 : 		UnitHandle pUnit = m_pPlayer->getUnit(*it);

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pUnit$226002[esp+60], edi
	mov	BYTE PTR _pUnit$226002[esp+64], 0
	test	edi, edi
	je	SHORT $LN53@PlotEngine
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@PlotEngine:
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 1795 : 		if(pUnit)

	test	edi, edi
	je	SHORT $LN86@PlotEngine

; 1796 : 		{
; 1797 : 			if(pUnit->AI_getUnitAIType() == UNITAI_ENGINEER)

	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN86@PlotEngine

; 1798 : 			{
; 1799 : 				CvHomelandUnit unit;
; 1800 : 				unit.SetID(pUnit->GetID());

	mov	ecx, DWORD PTR [edi+100]

; 1801 : 				m_CurrentMoveUnits.push_back(unit);

	mov	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR _unit$226005[esp+60], ecx
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN69@PlotEngine
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@VCvHomelandUnit@@$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvHomelandUnit,64,1,297,0>::GrowSize
$LN69@PlotEngine:
	mov	eax, DWORD PTR [esi+4]
	shl	eax, 4
	add	eax, DWORD PTR [esi]
	je	SHORT $LN72@PlotEngine
	mov	edx, DWORD PTR _unit$226005[esp+60]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ebx
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ecx
$LN72@PlotEngine:
	inc	DWORD PTR [esi+4]
	mov	ebp, DWORD PTR _it$225996[esp+60]
	mov	ebx, DWORD PTR _this$[esp+60]
$LN86@PlotEngine:

; 1802 : 			}
; 1803 : 		}
; 1804 : 	}

	mov	DWORD PTR __$EHRec$[esp+68], -1
	test	edi, edi
	je	SHORT $LN5@PlotEngine
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN5@PlotEngine:
	mov	ebp, DWORD PTR [ebp]
	mov	DWORD PTR _it$225996[esp+60], ebp
	cmp	ebp, DWORD PTR [ebx+8]
	jne	$LL85@PlotEngine
	pop	edi
$LN4@PlotEngine:

; 1805 : 
; 1806 : 	if(m_CurrentMoveUnits.size() > 0)

	cmp	DWORD PTR [ebx+20], 0
	jbe	SHORT $LN1@PlotEngine

; 1807 : 	{
; 1808 : 		ExecuteEngineerMoves();

	mov	ecx, ebx
	call	?ExecuteEngineerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ExecuteEngineerMoves
$LN1@PlotEngine:

; 1809 : 	}
; 1810 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _pUnit$226002[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?PlotEngineerMoves@CvHomelandAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlotEngineerMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::PlotEngineerMoves
PUBLIC	?AssignHomelandMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::AssignHomelandMoves
; Function compile flags: /Ogtpy
;	COMDAT ?AssignHomelandMoves@CvHomelandAI@@AAEXXZ
_TEXT	SEGMENT
_move$225386 = -8					; size = 8
?AssignHomelandMoves@CvHomelandAI@@AAEXXZ PROC		; CvHomelandAI::AssignHomelandMoves, COMDAT
; _this$ = ecx

; 698  : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 699  : 	FStaticVector< CvHomelandMove, 64, true, c_eCiv5GameplayDLL >::iterator it;
; 700  : 
; 701  : 	// Proceed in priority order
; 702  : 	for(it = m_MovePriorityList.begin(); it != m_MovePriorityList.end() && !m_CurrentTurnUnits.empty(); ++it)

	mov	eax, DWORD PTR [esi+2100]
	push	edi
	mov	edi, DWORD PTR [esi+2096]
	mov	ecx, edi
	lea	edx, DWORD PTR [ecx+eax*8]
	cmp	edi, edx
	je	$LN35@AssignHome
$LL37@AssignHome:
	cmp	DWORD PTR [esi+12], 0
	je	$LN35@AssignHome

; 703  : 	{
; 704  : 		CvHomelandMove move = *it;

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+4]

; 705  : 
; 706  : #if defined(AUI_PERF_LOGGING_FORMATTING_TWEAKS) && !defined(FINAL_RELEASE)
; 707  : 		static const char* aHomelandMoves[] = { "AI_HOMELAND_MOVE_UNASSIGNED",
; 708  : 			"AI_HOMELAND_MOVE_EXPLORE",
; 709  : 			"AI_HOMELAND_MOVE_EXPLORE_SEA",
; 710  : 			"AI_HOMELAND_MOVE_SETTLE",
; 711  : 			"AI_HOMELAND_MOVE_GARRISON",
; 712  : 			"AI_HOMELAND_MOVE_HEAL",
; 713  : 			"AI_HOMELAND_MOVE_TO_SAFETY",
; 714  : 			"AI_HOMELAND_MOVE_MOBILE_RESERVE",
; 715  : 			"AI_HOMELAND_MOVE_SENTRY",
; 716  : 			"AI_HOMELAND_MOVE_WORKER",
; 717  : 			"AI_HOMELAND_MOVE_WORKER_SEA",
; 718  : 			"AI_HOMELAND_MOVE_PATROL",
; 719  : 			"AI_HOMELAND_MOVE_UPGRADE",
; 720  : 			"AI_HOMELAND_MOVE_ANCIENT_RUINS",
; 721  : 			"AI_HOMELAND_MOVE_GARRISON_CITY_STATE",
; 722  : 			"AI_HOMELAND_MOVE_WRITER",
; 723  : 			"AI_HOMELAND_MOVE_ARTIST_GOLDEN_AGE",
; 724  : 			"AI_HOMELAND_MOVE_MUSICIAN",
; 725  : 			"AI_HOMELAND_MOVE_SCIENTIST_FREE_TECH",
; 726  : 			"AI_HOMELAND_MOVE_MERCHANT_TRADE",
; 727  : 			"AI_HOMELAND_MOVE_ENGINEER_HURRY",
; 728  : 			"AI_HOMELAND_MOVE_GENERAL_GARRISON",
; 729  : 			"AI_HOMELAND_MOVE_ADMIRAL_GARRISON",
; 730  : 			"AI_HOMELAND_MOVE_SPACESHIP_PART",
; 731  : 			"AI_HOMELAND_MOVE_AIRCRAFT_TO_THE_FRONT",
; 732  : 			"AI_HOMELAND_MOVE_TREASURE",
; 733  : 			"AI_HOMELAND_MOVE_PROPHET_RELIGION",
; 734  : 			"AI_HOMELAND_MOVE_MISSIONARY",
; 735  : 			"AI_HOMELAND_MOVE_INQUISITOR",
; 736  : 			"AI_HOMELAND_MOVE_TRADE_UNIT",
; 737  : 			"AI_HOMELAND_MOVE_ARCHAEOLOGIST",
; 738  : 			"AI_HOMELAND_MOVE_ADD_SPACESHIP_PART",
; 739  : 			"AI_HOMELAND_MOVE_AIRLIFT" };
; 740  : 		AI_PERF_FORMAT("AI-perf-home.csv", ("Move Type: %s (%d), Turn %03d, %s", (move.m_eMoveType > 0 && move.m_eMoveType < 33 ? aHomelandMoves[move.m_eMoveType] : "AI_HOMELAND_MOVE_NONE"), (int)move.m_eMoveType, GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()));
; 741  : #else
; 742  : 		AI_PERF_FORMAT("AI-perf-tact.csv", ("Homeland Move: %d, Turn %03d, %s", (int)move.m_eMoveType, GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()) );
; 743  : #endif
; 744  : 
; 745  : 		switch(move.m_eMoveType)

	dec	eax
	mov	DWORD PTR _move$225386[esp+20], ecx
	cmp	eax, 31					; 0000001fH
	ja	$LN36@AssignHome
	jmp	DWORD PTR $LN50@AssignHome[eax*4]
$LN32@AssignHome:

; 746  : 		{
; 747  : 		case AI_HOMELAND_MOVE_EXPLORE:
; 748  : 			PlotExplorerMoves();

	mov	ecx, esi
	call	?PlotExplorerMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotExplorerMoves

; 749  : 			break;

	jmp	$LN36@AssignHome
$LN31@AssignHome:

; 750  : 		case AI_HOMELAND_MOVE_EXPLORE_SEA:
; 751  : 			PlotExplorerSeaMoves();

	mov	ecx, esi
	call	?PlotExplorerSeaMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotExplorerSeaMoves

; 752  : 			break;

	jmp	$LN36@AssignHome
$LN30@AssignHome:

; 753  : 		case AI_HOMELAND_MOVE_SETTLE:
; 754  : 			PlotFirstTurnSettlerMoves();

	mov	ecx, esi
	call	?PlotFirstTurnSettlerMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotFirstTurnSettlerMoves

; 755  : 			break;

	jmp	$LN36@AssignHome
$LN29@AssignHome:

; 756  : 		case AI_HOMELAND_MOVE_GARRISON:
; 757  : 			PlotGarrisonMoves();

	push	0
	mov	ecx, esi
	call	?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z ; CvHomelandAI::PlotGarrisonMoves

; 758  : 			break;

	jmp	$LN36@AssignHome
$LN28@AssignHome:

; 759  : 		case AI_HOMELAND_MOVE_HEAL:
; 760  : 			PlotHealMoves();

	mov	ecx, esi
	call	?PlotHealMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotHealMoves

; 761  : 			break;

	jmp	$LN36@AssignHome
$LN27@AssignHome:

; 762  : 		case AI_HOMELAND_MOVE_TO_SAFETY:
; 763  : 			PlotMovesToSafety();

	mov	ecx, esi
	call	?PlotMovesToSafety@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotMovesToSafety

; 764  : 			break;

	jmp	$LN36@AssignHome
$LN26@AssignHome:

; 765  : 		case AI_HOMELAND_MOVE_MOBILE_RESERVE:
; 766  : 			PlotMobileReserveMoves();

	mov	ecx, esi
	call	?PlotMobileReserveMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotMobileReserveMoves

; 767  : 			break;

	jmp	$LN36@AssignHome
$LN25@AssignHome:

; 768  : 		case AI_HOMELAND_MOVE_SENTRY:
; 769  : 			PlotSentryMoves();

	mov	ecx, esi
	call	?PlotSentryMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotSentryMoves

; 770  : 			break;

	jmp	$LN36@AssignHome
$LN24@AssignHome:

; 771  : 		case AI_HOMELAND_MOVE_WORKER:
; 772  : 			PlotWorkerMoves();

	mov	ecx, esi
	call	?PlotWorkerMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotWorkerMoves

; 773  : 			break;

	jmp	$LN36@AssignHome
$LN23@AssignHome:

; 774  : 		case AI_HOMELAND_MOVE_WORKER_SEA:
; 775  : 			PlotWorkerSeaMoves();

	mov	ecx, esi
	call	?PlotWorkerSeaMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotWorkerSeaMoves

; 776  : 			break;

	jmp	$LN36@AssignHome
$LN22@AssignHome:

; 777  : 		case AI_HOMELAND_MOVE_PATROL:
; 778  : 			PlotPatrolMoves();

	mov	ecx, esi
	call	?PlotPatrolMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotPatrolMoves

; 779  : 			break;

	jmp	$LN36@AssignHome
$LN21@AssignHome:

; 780  : 		case AI_HOMELAND_MOVE_UPGRADE:
; 781  : 			PlotUpgradeMoves();

	mov	ecx, esi
	call	?PlotUpgradeMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotUpgradeMoves

; 782  : 			break;

	jmp	$LN36@AssignHome
$LN20@AssignHome:

; 783  : 		case AI_HOMELAND_MOVE_ANCIENT_RUINS:
; 784  : 			PlotAncientRuinMoves();

	mov	ecx, esi
	call	?PlotAncientRuinMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotAncientRuinMoves

; 785  : 			break;

	jmp	$LN36@AssignHome
$LN19@AssignHome:

; 786  : 		case AI_HOMELAND_MOVE_GARRISON_CITY_STATE:
; 787  : 			PlotGarrisonMoves(true /*bCityStateOnly*/);

	push	1
	mov	ecx, esi
	call	?PlotGarrisonMoves@CvHomelandAI@@AAEX_N@Z ; CvHomelandAI::PlotGarrisonMoves

; 788  : 			break;

	jmp	$LN36@AssignHome
$LN18@AssignHome:

; 789  : 		case AI_HOMELAND_MOVE_WRITER:
; 790  : 			PlotWriterMoves();

	mov	ecx, esi
	call	?PlotWriterMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotWriterMoves

; 791  : 			break;

	jmp	$LN36@AssignHome
$LN17@AssignHome:

; 792  : 		case AI_HOMELAND_MOVE_ARTIST_GOLDEN_AGE:
; 793  : 			PlotArtistMoves();

	mov	ecx, esi
	call	?PlotArtistMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotArtistMoves

; 794  : 			break;

	jmp	$LN36@AssignHome
$LN16@AssignHome:

; 795  : 		case AI_HOMELAND_MOVE_MUSICIAN:
; 796  : 			PlotMusicianMoves();

	mov	ecx, esi
	call	?PlotMusicianMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotMusicianMoves

; 797  : 			break;

	jmp	$LN36@AssignHome
$LN15@AssignHome:

; 798  : 		case AI_HOMELAND_MOVE_SCIENTIST_FREE_TECH:
; 799  : 			PlotScientistMoves();

	mov	ecx, esi
	call	?PlotScientistMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotScientistMoves

; 800  : 			break;

	jmp	$LN36@AssignHome
$LN14@AssignHome:

; 801  : 		case AI_HOMELAND_MOVE_ENGINEER_HURRY:
; 802  : 			PlotEngineerMoves();

	mov	ecx, esi
	call	?PlotEngineerMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotEngineerMoves

; 803  : 			break;

	jmp	SHORT $LN36@AssignHome
$LN13@AssignHome:

; 804  : 		case AI_HOMELAND_MOVE_MERCHANT_TRADE:
; 805  : 			PlotMerchantMoves();

	mov	ecx, esi
	call	?PlotMerchantMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotMerchantMoves

; 806  : 			break;

	jmp	SHORT $LN36@AssignHome
$LN12@AssignHome:

; 807  : 		case AI_HOMELAND_MOVE_GENERAL_GARRISON:
; 808  : 			PlotGeneralMoves();

	mov	ecx, esi
	call	?PlotGeneralMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotGeneralMoves

; 809  : 			break;

	jmp	SHORT $LN36@AssignHome
$LN11@AssignHome:

; 810  : 		case AI_HOMELAND_MOVE_ADMIRAL_GARRISON:
; 811  : 			PlotAdmiralMoves();

	mov	ecx, esi
	call	?PlotAdmiralMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotAdmiralMoves

; 812  : 			break;

	jmp	SHORT $LN36@AssignHome
$LN10@AssignHome:

; 813  : 		case AI_HOMELAND_MOVE_PROPHET_RELIGION:
; 814  : 			PlotProphetMoves();

	mov	ecx, esi
	call	?PlotProphetMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotProphetMoves

; 815  : 			break;

	jmp	SHORT $LN36@AssignHome
$LN9@AssignHome:

; 816  : 		case AI_HOMELAND_MOVE_MISSIONARY:
; 817  : 			PlotMissionaryMoves();

	mov	ecx, esi
	call	?PlotMissionaryMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotMissionaryMoves

; 818  : 			break;

	jmp	SHORT $LN36@AssignHome
$LN8@AssignHome:

; 819  : 		case AI_HOMELAND_MOVE_INQUISITOR:
; 820  : 			PlotInquisitorMoves();

	mov	ecx, esi
	call	?PlotInquisitorMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotInquisitorMoves

; 821  : 			break;

	jmp	SHORT $LN36@AssignHome
$LN7@AssignHome:

; 822  : 		case AI_HOMELAND_MOVE_AIRCRAFT_TO_THE_FRONT:
; 823  : 			PlotAircraftMoves();

	mov	ecx, esi
	call	?PlotAircraftMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotAircraftMoves

; 824  : 			break;

	jmp	SHORT $LN36@AssignHome
$LN6@AssignHome:

; 825  : 		case AI_HOMELAND_MOVE_ADD_SPACESHIP_PART:
; 826  : 			PlotSSPartAdds();

	mov	ecx, esi
	call	?PlotSSPartAdds@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotSSPartAdds

; 827  : 			break;

	jmp	SHORT $LN36@AssignHome
$LN5@AssignHome:

; 828  : 		case AI_HOMELAND_MOVE_SPACESHIP_PART:
; 829  : 			PlotSSPartMoves();

	mov	ecx, esi
	call	?PlotSSPartMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotSSPartMoves

; 830  : 			break;

	jmp	SHORT $LN36@AssignHome
$LN4@AssignHome:

; 831  : 		case AI_HOMELAND_MOVE_TREASURE:
; 832  : 			PlotTreasureMoves();

	mov	ecx, esi
	call	?PlotTreasureMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotTreasureMoves

; 833  : 			break;

	jmp	SHORT $LN36@AssignHome
$LN3@AssignHome:

; 834  : 		case AI_HOMELAND_MOVE_TRADE_UNIT:
; 835  : 			PlotTradeUnitMoves();

	mov	ecx, esi
	call	?PlotTradeUnitMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotTradeUnitMoves

; 836  : 			break;

	jmp	SHORT $LN36@AssignHome
$LN2@AssignHome:

; 837  : 		case AI_HOMELAND_MOVE_ARCHAEOLOGIST:
; 838  : 			PlotArchaeologistMoves();

	mov	ecx, esi
	call	?PlotArchaeologistMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::PlotArchaeologistMoves

; 839  : 			break;

	jmp	SHORT $LN36@AssignHome
$LN1@AssignHome:

; 840  : 		case AI_HOMELAND_MOVE_AIRLIFT:
; 841  : 			PlotAirliftMoves();

	mov	ecx, esi
	call	?PlotAirliftMoves@CvHomelandAI@@AAEXXZ	; CvHomelandAI::PlotAirliftMoves
$LN36@AssignHome:
	mov	edx, DWORD PTR [esi+2100]
	mov	eax, DWORD PTR [esi+2096]
	add	edi, 8
	lea	ecx, DWORD PTR [eax+edx*8]
	cmp	edi, ecx
	jne	$LL37@AssignHome
$LN35@AssignHome:
	pop	edi

; 842  : 			break;
; 843  : 		}
; 844  : 	}
; 845  : 
; 846  : 	ReviewUnassignedUnits();

	mov	ecx, esi
	pop	esi

; 847  : }

	add	esp, 8

; 842  : 			break;
; 843  : 		}
; 844  : 	}
; 845  : 
; 846  : 	ReviewUnassignedUnits();

	jmp	?ReviewUnassignedUnits@CvHomelandAI@@AAEXXZ ; CvHomelandAI::ReviewUnassignedUnits
	npad	2
$LN50@AssignHome:

; 847  : }

	DD	$LN32@AssignHome
	DD	$LN31@AssignHome
	DD	$LN30@AssignHome
	DD	$LN29@AssignHome
	DD	$LN28@AssignHome
	DD	$LN27@AssignHome
	DD	$LN26@AssignHome
	DD	$LN25@AssignHome
	DD	$LN24@AssignHome
	DD	$LN23@AssignHome
	DD	$LN22@AssignHome
	DD	$LN21@AssignHome
	DD	$LN20@AssignHome
	DD	$LN19@AssignHome
	DD	$LN18@AssignHome
	DD	$LN17@AssignHome
	DD	$LN16@AssignHome
	DD	$LN15@AssignHome
	DD	$LN13@AssignHome
	DD	$LN14@AssignHome
	DD	$LN12@AssignHome
	DD	$LN11@AssignHome
	DD	$LN5@AssignHome
	DD	$LN7@AssignHome
	DD	$LN4@AssignHome
	DD	$LN10@AssignHome
	DD	$LN9@AssignHome
	DD	$LN8@AssignHome
	DD	$LN3@AssignHome
	DD	$LN2@AssignHome
	DD	$LN6@AssignHome
	DD	$LN1@AssignHome
?AssignHomelandMoves@CvHomelandAI@@AAEXXZ ENDP		; CvHomelandAI::AssignHomelandMoves
_TEXT	ENDS
PUBLIC	?Update@CvHomelandAI@@QAEXXZ			; CvHomelandAI::Update
; Function compile flags: /Ogtpy
;	COMDAT ?Update@CvHomelandAI@@QAEXXZ
_TEXT	SEGMENT
?Update@CvHomelandAI@@QAEXXZ PROC			; CvHomelandAI::Update, COMDAT
; _this$ = ecx

; 148  : {

	push	esi
	mov	esi, ecx

; 149  : 	AI_PERF_FORMAT("AI-perf.csv", ("Homeland AI, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), m_pPlayer->getCivilizationShortDescription()));
; 150  : 
; 151  : 	// Make sure we have a unit to handle
; 152  : 	if(!m_CurrentTurnUnits.empty())

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN1@Update

; 153  : 	{
; 154  : 		// Make sure the economic plots are up-to-date, it has a caching system in it.
; 155  : 		CvEconomicAI* pEconomicAI = m_pPlayer->GetEconomicAI();

	mov	ecx, DWORD PTR [esi]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI

; 156  : 		pEconomicAI->UpdatePlots();

	mov	ecx, eax
	call	?UpdatePlots@CvEconomicAI@@QAEXXZ	; CvEconomicAI::UpdatePlots

; 157  : 
; 158  : 		// Start by establishing the priority order for moves this turn
; 159  : 		EstablishHomelandPriorities();

	mov	ecx, esi
	call	?EstablishHomelandPriorities@CvHomelandAI@@AAEXXZ ; CvHomelandAI::EstablishHomelandPriorities

; 160  : 
; 161  : 		// Put together lists of places we may want to move toward
; 162  : 		FindHomelandTargets();

	mov	ecx, esi
	call	?FindHomelandTargets@CvHomelandAI@@AAEXXZ ; CvHomelandAI::FindHomelandTargets

; 163  : 
; 164  : 		// Loop through each move assigning units when available
; 165  : 		AssignHomelandMoves();

	mov	ecx, esi
	pop	esi
	jmp	?AssignHomelandMoves@CvHomelandAI@@AAEXXZ ; CvHomelandAI::AssignHomelandMoves
$LN1@Update:
	pop	esi

; 166  : 	}
; 167  : }

	ret	0
?Update@CvHomelandAI@@QAEXXZ ENDP			; CvHomelandAI::Update
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ
text$yd	SEGMENT
??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ PROC ; `CvHomelandAI::ExecuteTradeUnitMoves'::`2'::`dynamic atexit destructor for 'aTradeConnections'', COMDAT
	mov	eax, DWORD PTR ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A+4
	push	esi
	mov	esi, DWORD PTR ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A
	push	eax
	push	esi
	mov	ecx, OFFSET ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	cmp	esi, OFFSET ?aTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@4V?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@A+12
	je	SHORT $LN5@dynamic
	push	esi
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN5@dynamic:
	pop	esi
	ret	0
??__FaTradeConnections@?1??ExecuteTradeUnitMoves@CvHomelandAI@@AAEXXZ@YAXXZ ENDP ; `CvHomelandAI::ExecuteTradeUnitMoves'::`2'::`dynamic atexit destructor for 'aTradeConnections''
text$yd	ENDS
END
