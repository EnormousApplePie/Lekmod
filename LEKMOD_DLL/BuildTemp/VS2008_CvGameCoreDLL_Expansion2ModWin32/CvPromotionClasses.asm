; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvPromotionClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG218134 DB	'Sound', 00H
	ORG $+2
$SG218135 DB	'CannotBeChosen', 00H
	ORG $+1
$SG218136 DB	'LostWithUpgrade', 00H
$SG218137 DB	'NotWithUpgrade', 00H
	ORG $+1
$SG218138 DB	'InstaHeal', 00H
	ORG $+2
$SG218139 DB	'Leader', 00H
	ORG $+1
$SG218140 DB	'Blitz', 00H
	ORG $+2
$SG218141 DB	'Amphib', 00H
	ORG $+1
$SG218142 DB	'River', 00H
	ORG $+2
$SG218143 DB	'EnemyRoute', 00H
	ORG $+1
$SG218144 DB	'RivalTerritory', 00H
	ORG $+1
$SG218145 DB	'MustSetUpToRangedAttack', 00H
$SG218146 DB	'RangedSupportFire', 00H
	ORG $+2
$SG218147 DB	'AlwaysHeal', 00H
	ORG $+1
$SG218148 DB	'HealOutsideFriendly', 00H
$SG218149 DB	'HillsDoubleMove', 00H
$SG218150 DB	'IgnoreTerrainCost', 00H
	ORG $+2
$SG218151 DB	'RoughTerrainEndsTurn', 00H
	ORG $+3
$SG218152 DB	'HoveringUnit', 00H
	ORG $+3
$SG218153 DB	'FlatMovementCost', 00H
	ORG $+3
$SG218154 DB	'CanMoveImpassable', 00H
	ORG $+2
$SG218155 DB	'NoCapture', 00H
	ORG $+2
$SG218156 DB	'OnlyDefensive', 00H
	ORG $+2
$SG218157 DB	'NoDefensiveBonus', 00H
	ORG $+3
$SG218158 DB	'NukeImmune', 00H
	ORG $+1
$SG218159 DB	'HiddenNationality', 00H
	ORG $+2
$SG218160 DB	'AlwaysHostile', 00H
	ORG $+2
$SG218161 DB	'NoRevealMap', 00H
$SG218162 DB	'Recon', 00H
	ORG $+2
$SG218163 DB	'CanMoveAllTerrain', 00H
	ORG $+2
$SG218164 DB	'CanMoveAfterAttacking', 00H
	ORG $+2
$SG218165 DB	'AirSweepCapable', 00H
$SG218166 DB	'AllowsEmbarkation', 00H
	ORG $+2
$SG218167 DB	'RangeAttackIgnoreLOS', 00H
	ORG $+3
$SG218168 DB	'FreePillageMoves', 00H
	ORG $+3
$SG218169 DB	'HealOnPillage', 00H
	ORG $+2
$SG218170 DB	'HealIfDestroyExcludesBarbarians', 00H
$SG218171 DB	'EmbarkedAllWater', 00H
	ORG $+3
$SG218172 DB	'CityAttackOnly', 00H
	ORG $+1
$SG218173 DB	'CaptureDefeatedEnemy', 00H
	ORG $+3
$SG218174 DB	'IgnoreGreatGeneralBenefit', 00H
	ORG $+2
$SG218175 DB	'IgnoreZOC', 00H
	ORG $+2
$SG218176 DB	'HasPostCombatPromotions', 00H
$SG218177 DB	'PostCombatPromotionsExclusive', 00H
	ORG $+2
$SG218178 DB	'Sapper', 00H
	ORG $+1
$SG218180 DB	'GiveDomain', 00H
	ORG $+1
$SG218183 DB	'ConvertDomainUnit', 00H
	ORG $+2
$SG218186 DB	'ConvertDomain', 00H
	ORG $+2
$SG218188 DB	'HeavyCharge', 00H
$SG218189 DB	'HeavyChargeDownhill', 00H
$SG218190 DB	'VisibilityChange', 00H
	ORG $+3
$SG218191 DB	'MovesChange', 00H
$SG218192 DB	'MoveDiscountChange', 00H
	ORG $+1
$SG218193 DB	'RangeChange', 00H
$SG218194 DB	'RangedAttackModifier', 00H
	ORG $+3
$SG218195 DB	'InterceptionCombatModifier', 00H
	ORG $+1
$SG218196 DB	'InterceptionDefenseDamageModifier', 00H
	ORG $+2
$SG218197 DB	'AirSweepCombatModifier', 00H
	ORG $+1
$SG218198 DB	'InterceptChanceChange', 00H
	ORG $+2
$SG218199 DB	'NumInterceptionChange', 00H
	ORG $+2
$SG218200 DB	'EvasionChange', 00H
	ORG $+2
$SG218201 DB	'CargoChange', 00H
$SG218202 DB	'EnemyHealChange', 00H
$SG218203 DB	'NeutralHealChange', 00H
	ORG $+2
$SG218204 DB	'FriendlyHealChange', 00H
	ORG $+1
$SG218205 DB	'SameTileHealChange', 00H
	ORG $+1
$SG218206 DB	'AdjacentTileHealChange', 00H
	ORG $+1
$SG218207 DB	'EnemyDamageChance', 00H
	ORG $+2
$SG218208 DB	'NeutralDamageChance', 00H
$SG218209 DB	'EnemyDamage', 00H
$SG218210 DB	'NeutralDamage', 00H
	ORG $+2
$SG218211 DB	'CombatPercent', 00H
	ORG $+2
$SG218212 DB	'CityAttack', 00H
	ORG $+1
$SG218213 DB	'CityDefense', 00H
$SG218214 DB	'RangedDefenseMod', 00H
	ORG $+3
$SG218215 DB	'HillsAttack', 00H
$SG218216 DB	'HillsDefense', 00H
	ORG $+3
$SG218217 DB	'OpenAttack', 00H
	ORG $+1
$SG218218 DB	'OpenRangedAttackMod', 00H
$SG218219 DB	'RoughAttack', 00H
$SG218220 DB	'RoughRangedAttackMod', 00H
	ORG $+3
$SG218221 DB	'AttackFortifiedMod', 00H
	ORG $+1
$SG218222 DB	'AttackWoundedMod', 00H
	ORG $+3
$SG218223 DB	'FlankAttackModifier', 00H
$SG218224 DB	'NearbyEnemyCombatMod', 00H
	ORG $+3
$SG218225 DB	'NearbyEnemyCombatRange', 00H
	ORG $+1
$SG218226 DB	'OpenDefense', 00H
$SG218227 DB	'RoughDefense', 00H
	ORG $+3
$SG218228 DB	'ExtraAttacks', 00H
	ORG $+3
$SG218229 DB	'GreatGeneral', 00H
	ORG $+3
$SG218230 DB	'GreatAdmiral', 00H
	ORG $+3
$SG218231 DB	'GreatGeneralModifier', 00H
	ORG $+3
$SG218232 DB	'GreatGeneralReceivesMovement', 00H
	ORG $+3
$SG218233 DB	'EmbarkedUnitReceivesMovement', 00H
	ORG $+3
$SG218234 DB	'GreatGeneralOnOrAdjacentConfersMovement', 00H
$SG218235 DB	'GreatGeneralCombatModifier', 00H
	ORG $+1
$SG218236 DB	'FriendlyLandsModifier', 00H
	ORG $+2
$SG218237 DB	'FriendlyLandsAttackModifier', 00H
$SG218238 DB	'OutsideFriendlyLandsModifier', 00H
	ORG $+3
$SG218239 DB	'GoldenAgeForeignAttackBonus', 00H
$SG218240 DB	'CombatStrengthNearFriendlyMinor', 00H
$SG218241 DB	'UpgradeDiscount', 00H
$SG218242 DB	'ExperiencePercent', 00H
	ORG $+2
$SG218243 DB	'AdjacentMod', 00H
$SG218244 DB	'AttackMod', 00H
	ORG $+2
$SG218245 DB	'DefenseMod', 00H
	ORG $+1
$SG218246 DB	'DropRange', 00H
	ORG $+2
$SG218247 DB	'ExtraNavalMovement', 00H
	ORG $+1
$SG218248 DB	'HPHealedIfDestroyEnemy', 00H
	ORG $+1
$SG218249 DB	'GoldenAgeValueFromKills', 00H
$SG218250 DB	'ExtraWithdrawal', 00H
$SG218251 DB	'EmbarkExtraVisibility', 00H
	ORG $+2
$SG218252 DB	'EmbarkDefenseModifier', 00H
	ORG $+2
$SG218253 DB	'CapitalDefenseModifier', 00H
	ORG $+1
$SG218254 DB	'CapitalDefenseFalloff', 00H
	ORG $+2
$SG218255 DB	'CityAttackPlunderModifier', 00H
	ORG $+2
$SG218256 DB	'ReligiousStrengthLossRivalTerritory', 00H
$SG218257 DB	'TradeMissionInfluenceModifier', 00H
	ORG $+2
$SG218258 DB	'TradeMissionGoldModifier', 00H
	ORG $+3
$SG218260 DB	'LayerAnimationPath', 00H
	ORG $+1
$SG218262 DB	'TechPrereq', 00H
	ORG $+1
$SG218264 DB	'Invisible', 00H
	ORG $+2
$SG218266 DB	'SeeInvisible', 00H
	ORG $+3
$SG218268 DB	'PromotionPrereq', 00H
$SG218270 DB	'PromotionPrereqOr1', 00H
	ORG $+1
$SG218272 DB	'PromotionPrereqOr2', 00H
	ORG $+1
$SG218274 DB	'PromotionPrereqOr3', 00H
	ORG $+1
$SG218276 DB	'PromotionPrereqOr4', 00H
	ORG $+1
$SG218278 DB	'PromotionPrereqOr5', 00H
	ORG $+1
$SG218280 DB	'PromotionPrereqOr6', 00H
	ORG $+1
$SG218282 DB	'PromotionPrereqOr7', 00H
	ORG $+1
$SG218284 DB	'PromotionPrereqOr8', 00H
	ORG $+1
$SG218286 DB	'PromotionPrereqOr9', 00H
	ORG $+1
$SG218288 DB	'PromotionPrereqOr9', 00H
	ORG $+1
$SG218290 DB	'UnitClasses', 00H
$SG218294 DB	'Domains', 00H
$SG218297 DB	'UnitCombatInfos', 00H
$SG218299 DB	'Units', 00H
	ORG $+2
$SG218312 DB	'UnitPromotions_Terrains', 00H
	ORG $+4
$SG218316 DB	'select Terrains.ID as TerrainID, coalesce(Technologies.I'
	DB	'D, -1) as PassableTechID, UnitPromotions_Terrains.* from Unit'
	DB	'Promotions_Terrains inner join Terrains on TerrainType = Terr'
	DB	'ains.Type left join Technologies on PassableTech = Technologi'
	DB	'es.Type where PromotionType = ?', 00H
	ORG $+1
$SG218323 DB	'TerrainID', 00H
	ORG $+2
$SG218325 DB	'Attack', 00H
	ORG $+1
$SG218327 DB	'Defense', 00H
$SG218329 DB	'DoubleMove', 00H
	ORG $+1
$SG218331 DB	'Impassable', 00H
	ORG $+1
$SG218333 DB	'PassableTechID', 00H
	ORG $+1
$SG218335 DB	'UnitPromotions_Features', 00H
	ORG $+4
$SG218339 DB	'select Features.ID as FeatureID, coalesce(Technologies.I'
	DB	'D, -1) as PassableTechID, UnitPromotions_Features.* from Unit'
	DB	'Promotions_Features inner join Features on FeatureType = Feat'
	DB	'ures.Type left join Technologies on PassableTech = Technologi'
	DB	'es.Type where PromotionType = ?', 00H
	ORG $+1
$SG218346 DB	'FeatureID', 00H
	ORG $+2
$SG218348 DB	'Attack', 00H
	ORG $+1
$SG218350 DB	'Defense', 00H
$SG218352 DB	'DoubleMove', 00H
	ORG $+1
$SG218354 DB	'Impassable', 00H
	ORG $+1
$SG218356 DB	'PassableTechID', 00H
	ORG $+1
$SG218358 DB	'UnitPromotions_UnitClasses', 00H
	ORG $+1
$SG218362 DB	'select UnitClasses.ID, Modifier, Attack, Defense from Un'
	DB	'itPromotions_UnitClasses inner join UnitClasses on UnitClassT'
	DB	'ype = UnitClasses.Type where PromotionType = ?', 00H
$SG218370 DB	'Modifier', 00H
	ORG $+3
$SG218372 DB	'Attack', 00H
	ORG $+1
$SG218374 DB	'Defense', 00H
$SG218376 DB	'm_piDomainModifierPercent', 00H
	ORG $+6
$SG218380 DB	'select Domains.ID, Modifier from UnitPromotions_Domains '
	DB	'inner join Domains on DomainType = Domains.Type where Promoti'
	DB	'onType = ?;', 00H
	ORG $+3
$SG218390 DB	'm_piUnitCombatModifierPercent', 00H
	ORG $+6
$SG218394 DB	'select UnitCombatInfos.ID, Modifier from UnitPromotions_'
	DB	'UnitCombatMods inner join UnitCombatInfos on UnitCombatInfos.'
	DB	'Type = UnitCombatType where PromotionType = ?;', 00H
$SG218403 DB	'm_pbUnitCombat', 00H
	ORG $+5
$SG218407 DB	'select UnitCombatInfos.ID from UnitPromotions_UnitCombat'
	DB	's inner join UnitCombatInfos On UnitCombatInfos.Type = UnitCo'
	DB	'mbatType where PromotionType = ?', 00H
	ORG $+2
$SG218415 DB	'm_pbCivilianUnitType', 00H
	ORG $+3
$SG218419 DB	'select Units.ID from UnitPromotions_CivilianUnitType inn'
	DB	'er join Units On Units.Type = UnitType where PromotionType = '
	DB	'?', 00H
	ORG $+1
$SG218427 DB	'PromotionType', 00H
	ORG $+2
$SG218428 DB	'NewPromotion', 00H
	ORG $+3
$SG218429 DB	'UnitPromotions_PostCombatRandomPromotion', 00H
	ORG $+3
$SG218430 DB	'UnitPromotions', 00H
	ORG $+1
$SG219294 DB	'Random Promotion Pick', 00H
	ORG $+2
$SG219340 DB	'PROMOTION_OLIGARCHY', 00H
$SG219347 DB	'LOAD ERROR: Promotion Type not found: %s', 00H
	ORG $+3
$SG219357 DB	'PROMOTION_OLIGARCHY', 00H
$SG219369 DB	'LOAD ERROR: Promotion Type not found for hash: %u', 00H
CONST	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetLayerAnimationPath@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetLayerAnimationPath
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpromotionclasses.cpp
;	COMDAT ?GetLayerAnimationPath@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLayerAnimationPath@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetLayerAnimationPath, COMDAT
; _this$ = ecx

; 659  : 	return m_iLayerAnimationPath;

	mov	eax, DWORD PTR [ecx+460]

; 660  : }

	ret	0
?GetLayerAnimationPath@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetLayerAnimationPath
_TEXT	ENDS
PUBLIC	?GetPrereqPromotion@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetPrereqPromotion
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqPromotion@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPrereqPromotion@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetPrereqPromotion, COMDAT
; _this$ = ecx

; 665  : 	return m_iPrereqPromotion;

	mov	eax, DWORD PTR [ecx+464]

; 666  : }

	ret	0
?GetPrereqPromotion@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetPrereqPromotion
_TEXT	ENDS
PUBLIC	?SetPrereqPromotion@CvPromotionEntry@@QAEXH@Z	; CvPromotionEntry::SetPrereqPromotion
; Function compile flags: /Ogtpy
;	COMDAT ?SetPrereqPromotion@CvPromotionEntry@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?SetPrereqPromotion@CvPromotionEntry@@QAEXH@Z PROC	; CvPromotionEntry::SetPrereqPromotion, COMDAT
; _this$ = ecx

; 671  : 	m_iPrereqPromotion = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+464], eax

; 672  : }

	ret	4
?SetPrereqPromotion@CvPromotionEntry@@QAEXH@Z ENDP	; CvPromotionEntry::SetPrereqPromotion
_TEXT	ENDS
PUBLIC	?GetPrereqOrPromotion1@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetPrereqOrPromotion1
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqOrPromotion1@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPrereqOrPromotion1@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetPrereqOrPromotion1, COMDAT
; _this$ = ecx

; 677  : 	return m_iPrereqOrPromotion1;

	mov	eax, DWORD PTR [ecx+468]

; 678  : }

	ret	0
?GetPrereqOrPromotion1@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetPrereqOrPromotion1
_TEXT	ENDS
PUBLIC	?SetPrereqOrPromotion1@CvPromotionEntry@@QAEXH@Z ; CvPromotionEntry::SetPrereqOrPromotion1
; Function compile flags: /Ogtpy
;	COMDAT ?SetPrereqOrPromotion1@CvPromotionEntry@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?SetPrereqOrPromotion1@CvPromotionEntry@@QAEXH@Z PROC	; CvPromotionEntry::SetPrereqOrPromotion1, COMDAT
; _this$ = ecx

; 683  : 	m_iPrereqOrPromotion1 = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+468], eax

; 684  : }

	ret	4
?SetPrereqOrPromotion1@CvPromotionEntry@@QAEXH@Z ENDP	; CvPromotionEntry::SetPrereqOrPromotion1
_TEXT	ENDS
PUBLIC	?GetPrereqOrPromotion2@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetPrereqOrPromotion2
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqOrPromotion2@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPrereqOrPromotion2@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetPrereqOrPromotion2, COMDAT
; _this$ = ecx

; 689  : 	return m_iPrereqOrPromotion2;

	mov	eax, DWORD PTR [ecx+472]

; 690  : }

	ret	0
?GetPrereqOrPromotion2@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetPrereqOrPromotion2
_TEXT	ENDS
PUBLIC	?SetPrereqOrPromotion2@CvPromotionEntry@@QAEXH@Z ; CvPromotionEntry::SetPrereqOrPromotion2
; Function compile flags: /Ogtpy
;	COMDAT ?SetPrereqOrPromotion2@CvPromotionEntry@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?SetPrereqOrPromotion2@CvPromotionEntry@@QAEXH@Z PROC	; CvPromotionEntry::SetPrereqOrPromotion2, COMDAT
; _this$ = ecx

; 695  : 	m_iPrereqOrPromotion2 = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+472], eax

; 696  : }

	ret	4
?SetPrereqOrPromotion2@CvPromotionEntry@@QAEXH@Z ENDP	; CvPromotionEntry::SetPrereqOrPromotion2
_TEXT	ENDS
PUBLIC	?GetPrereqOrPromotion3@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetPrereqOrPromotion3
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqOrPromotion3@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPrereqOrPromotion3@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetPrereqOrPromotion3, COMDAT
; _this$ = ecx

; 701  : 	return m_iPrereqOrPromotion3;

	mov	eax, DWORD PTR [ecx+476]

; 702  : }

	ret	0
?GetPrereqOrPromotion3@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetPrereqOrPromotion3
_TEXT	ENDS
PUBLIC	?SetPrereqOrPromotion3@CvPromotionEntry@@QAEXH@Z ; CvPromotionEntry::SetPrereqOrPromotion3
; Function compile flags: /Ogtpy
;	COMDAT ?SetPrereqOrPromotion3@CvPromotionEntry@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?SetPrereqOrPromotion3@CvPromotionEntry@@QAEXH@Z PROC	; CvPromotionEntry::SetPrereqOrPromotion3, COMDAT
; _this$ = ecx

; 707  : 	m_iPrereqOrPromotion3 = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+476], eax

; 708  : }

	ret	4
?SetPrereqOrPromotion3@CvPromotionEntry@@QAEXH@Z ENDP	; CvPromotionEntry::SetPrereqOrPromotion3
_TEXT	ENDS
PUBLIC	?GetPrereqOrPromotion4@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetPrereqOrPromotion4
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqOrPromotion4@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPrereqOrPromotion4@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetPrereqOrPromotion4, COMDAT
; _this$ = ecx

; 713  : 	return m_iPrereqOrPromotion4;

	mov	eax, DWORD PTR [ecx+480]

; 714  : }

	ret	0
?GetPrereqOrPromotion4@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetPrereqOrPromotion4
_TEXT	ENDS
PUBLIC	?SetPrereqOrPromotion4@CvPromotionEntry@@QAEXH@Z ; CvPromotionEntry::SetPrereqOrPromotion4
; Function compile flags: /Ogtpy
;	COMDAT ?SetPrereqOrPromotion4@CvPromotionEntry@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?SetPrereqOrPromotion4@CvPromotionEntry@@QAEXH@Z PROC	; CvPromotionEntry::SetPrereqOrPromotion4, COMDAT
; _this$ = ecx

; 719  : 	m_iPrereqOrPromotion4 = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+480], eax

; 720  : }

	ret	4
?SetPrereqOrPromotion4@CvPromotionEntry@@QAEXH@Z ENDP	; CvPromotionEntry::SetPrereqOrPromotion4
_TEXT	ENDS
PUBLIC	?GetPrereqOrPromotion5@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetPrereqOrPromotion5
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqOrPromotion5@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPrereqOrPromotion5@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetPrereqOrPromotion5, COMDAT
; _this$ = ecx

; 725  : 	return m_iPrereqOrPromotion5;

	mov	eax, DWORD PTR [ecx+484]

; 726  : }

	ret	0
?GetPrereqOrPromotion5@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetPrereqOrPromotion5
_TEXT	ENDS
PUBLIC	?SetPrereqOrPromotion5@CvPromotionEntry@@QAEXH@Z ; CvPromotionEntry::SetPrereqOrPromotion5
; Function compile flags: /Ogtpy
;	COMDAT ?SetPrereqOrPromotion5@CvPromotionEntry@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?SetPrereqOrPromotion5@CvPromotionEntry@@QAEXH@Z PROC	; CvPromotionEntry::SetPrereqOrPromotion5, COMDAT
; _this$ = ecx

; 731  : 	m_iPrereqOrPromotion5 = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+484], eax

; 732  : }

	ret	4
?SetPrereqOrPromotion5@CvPromotionEntry@@QAEXH@Z ENDP	; CvPromotionEntry::SetPrereqOrPromotion5
_TEXT	ENDS
PUBLIC	?GetPrereqOrPromotion6@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetPrereqOrPromotion6
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqOrPromotion6@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPrereqOrPromotion6@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetPrereqOrPromotion6, COMDAT
; _this$ = ecx

; 737  : 	return m_iPrereqOrPromotion6;

	mov	eax, DWORD PTR [ecx+488]

; 738  : }

	ret	0
?GetPrereqOrPromotion6@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetPrereqOrPromotion6
_TEXT	ENDS
PUBLIC	?SetPrereqOrPromotion6@CvPromotionEntry@@QAEXH@Z ; CvPromotionEntry::SetPrereqOrPromotion6
; Function compile flags: /Ogtpy
;	COMDAT ?SetPrereqOrPromotion6@CvPromotionEntry@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?SetPrereqOrPromotion6@CvPromotionEntry@@QAEXH@Z PROC	; CvPromotionEntry::SetPrereqOrPromotion6, COMDAT
; _this$ = ecx

; 743  : 	m_iPrereqOrPromotion6 = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+488], eax

; 744  : }

	ret	4
?SetPrereqOrPromotion6@CvPromotionEntry@@QAEXH@Z ENDP	; CvPromotionEntry::SetPrereqOrPromotion6
_TEXT	ENDS
PUBLIC	?GetPrereqOrPromotion7@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetPrereqOrPromotion7
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqOrPromotion7@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPrereqOrPromotion7@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetPrereqOrPromotion7, COMDAT
; _this$ = ecx

; 749  : 	return m_iPrereqOrPromotion7;

	mov	eax, DWORD PTR [ecx+492]

; 750  : }

	ret	0
?GetPrereqOrPromotion7@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetPrereqOrPromotion7
_TEXT	ENDS
PUBLIC	?SetPrereqOrPromotion7@CvPromotionEntry@@QAEXH@Z ; CvPromotionEntry::SetPrereqOrPromotion7
; Function compile flags: /Ogtpy
;	COMDAT ?SetPrereqOrPromotion7@CvPromotionEntry@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?SetPrereqOrPromotion7@CvPromotionEntry@@QAEXH@Z PROC	; CvPromotionEntry::SetPrereqOrPromotion7, COMDAT
; _this$ = ecx

; 755  : 	m_iPrereqOrPromotion7 = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+492], eax

; 756  : }

	ret	4
?SetPrereqOrPromotion7@CvPromotionEntry@@QAEXH@Z ENDP	; CvPromotionEntry::SetPrereqOrPromotion7
_TEXT	ENDS
PUBLIC	?GetPrereqOrPromotion8@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetPrereqOrPromotion8
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqOrPromotion8@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPrereqOrPromotion8@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetPrereqOrPromotion8, COMDAT
; _this$ = ecx

; 761  : 	return m_iPrereqOrPromotion8;

	mov	eax, DWORD PTR [ecx+496]

; 762  : }

	ret	0
?GetPrereqOrPromotion8@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetPrereqOrPromotion8
_TEXT	ENDS
PUBLIC	?SetPrereqOrPromotion8@CvPromotionEntry@@QAEXH@Z ; CvPromotionEntry::SetPrereqOrPromotion8
; Function compile flags: /Ogtpy
;	COMDAT ?SetPrereqOrPromotion8@CvPromotionEntry@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?SetPrereqOrPromotion8@CvPromotionEntry@@QAEXH@Z PROC	; CvPromotionEntry::SetPrereqOrPromotion8, COMDAT
; _this$ = ecx

; 767  : 	m_iPrereqOrPromotion8 = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+496], eax

; 768  : }

	ret	4
?SetPrereqOrPromotion8@CvPromotionEntry@@QAEXH@Z ENDP	; CvPromotionEntry::SetPrereqOrPromotion8
_TEXT	ENDS
PUBLIC	?GetPrereqOrPromotion9@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetPrereqOrPromotion9
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqOrPromotion9@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPrereqOrPromotion9@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetPrereqOrPromotion9, COMDAT
; _this$ = ecx

; 773  : 	return m_iPrereqOrPromotion9;

	mov	eax, DWORD PTR [ecx+500]

; 774  : }

	ret	0
?GetPrereqOrPromotion9@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetPrereqOrPromotion9
_TEXT	ENDS
PUBLIC	?SetPrereqOrPromotion9@CvPromotionEntry@@QAEXH@Z ; CvPromotionEntry::SetPrereqOrPromotion9
; Function compile flags: /Ogtpy
;	COMDAT ?SetPrereqOrPromotion9@CvPromotionEntry@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?SetPrereqOrPromotion9@CvPromotionEntry@@QAEXH@Z PROC	; CvPromotionEntry::SetPrereqOrPromotion9, COMDAT
; _this$ = ecx

; 779  : 	m_iPrereqOrPromotion9 = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+500], eax

; 780  : }

	ret	4
?SetPrereqOrPromotion9@CvPromotionEntry@@QAEXH@Z ENDP	; CvPromotionEntry::SetPrereqOrPromotion9
_TEXT	ENDS
PUBLIC	?GetPrereqOrPromotion10@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion10
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqOrPromotion10@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPrereqOrPromotion10@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetPrereqOrPromotion10, COMDAT
; _this$ = ecx

; 787  : 	return m_iPrereqOrPromotion10;

	mov	eax, DWORD PTR [ecx+504]

; 788  : }

	ret	0
?GetPrereqOrPromotion10@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetPrereqOrPromotion10
_TEXT	ENDS
PUBLIC	?SetPrereqOrPromotion10@CvPromotionEntry@@QAEXH@Z ; CvPromotionEntry::SetPrereqOrPromotion10
; Function compile flags: /Ogtpy
;	COMDAT ?SetPrereqOrPromotion10@CvPromotionEntry@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?SetPrereqOrPromotion10@CvPromotionEntry@@QAEXH@Z PROC	; CvPromotionEntry::SetPrereqOrPromotion10, COMDAT
; _this$ = ecx

; 793  : 	m_iPrereqOrPromotion10 = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+504], eax

; 794  : }

	ret	4
?SetPrereqOrPromotion10@CvPromotionEntry@@QAEXH@Z ENDP	; CvPromotionEntry::SetPrereqOrPromotion10
_TEXT	ENDS
PUBLIC	?GetTechPrereq@CvPromotionEntry@@QBEHXZ		; CvPromotionEntry::GetTechPrereq
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechPrereq@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTechPrereq@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetTechPrereq, COMDAT
; _this$ = ecx

; 801  : 	return m_iTechPrereq;

	mov	eax, DWORD PTR [ecx+508]

; 802  : }

	ret	0
?GetTechPrereq@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetTechPrereq
_TEXT	ENDS
PUBLIC	?GetInvisibleType@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetInvisibleType
; Function compile flags: /Ogtpy
;	COMDAT ?GetInvisibleType@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetInvisibleType@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetInvisibleType, COMDAT
; _this$ = ecx

; 807  : 	return m_iInvisibleType;

	mov	eax, DWORD PTR [ecx+512]

; 808  : }

	ret	0
?GetInvisibleType@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetInvisibleType
_TEXT	ENDS
PUBLIC	?GetSeeInvisibleType@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetSeeInvisibleType
; Function compile flags: /Ogtpy
;	COMDAT ?GetSeeInvisibleType@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSeeInvisibleType@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetSeeInvisibleType, COMDAT
; _this$ = ecx

; 813  : 	return m_iSeeInvisibleType;

	mov	eax, DWORD PTR [ecx+516]

; 814  : }

	ret	0
?GetSeeInvisibleType@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetSeeInvisibleType
_TEXT	ENDS
PUBLIC	?GetVisibilityChange@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetVisibilityChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetVisibilityChange@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetVisibilityChange@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetVisibilityChange, COMDAT
; _this$ = ecx

; 819  : 	return m_iVisibilityChange;

	mov	eax, DWORD PTR [ecx+520]

; 820  : }

	ret	0
?GetVisibilityChange@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetVisibilityChange
_TEXT	ENDS
PUBLIC	?GetMovesChange@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetMovesChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetMovesChange@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMovesChange@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetMovesChange, COMDAT
; _this$ = ecx

; 825  : 	return m_iMovesChange;

	mov	eax, DWORD PTR [ecx+524]

; 826  : }

	ret	0
?GetMovesChange@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetMovesChange
_TEXT	ENDS
PUBLIC	?GetMoveDiscountChange@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetMoveDiscountChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetMoveDiscountChange@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetMoveDiscountChange@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetMoveDiscountChange, COMDAT
; _this$ = ecx

; 831  : 	return m_iMoveDiscountChange;

	mov	eax, DWORD PTR [ecx+528]

; 832  : }

	ret	0
?GetMoveDiscountChange@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetMoveDiscountChange
_TEXT	ENDS
PUBLIC	?GetRangeChange@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetRangeChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetRangeChange@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRangeChange@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetRangeChange, COMDAT
; _this$ = ecx

; 837  : 	return m_iRangeChange;

	mov	eax, DWORD PTR [ecx+532]

; 838  : }

	ret	0
?GetRangeChange@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetRangeChange
_TEXT	ENDS
PUBLIC	?GetRangedAttackModifier@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetRangedAttackModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetRangedAttackModifier@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRangedAttackModifier@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetRangedAttackModifier, COMDAT
; _this$ = ecx

; 843  : 	return m_iRangedAttackModifier;

	mov	eax, DWORD PTR [ecx+536]

; 844  : }

	ret	0
?GetRangedAttackModifier@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetRangedAttackModifier
_TEXT	ENDS
PUBLIC	?GetInterceptionCombatModifier@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetInterceptionCombatModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetInterceptionCombatModifier@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetInterceptionCombatModifier@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetInterceptionCombatModifier, COMDAT
; _this$ = ecx

; 849  : 	return m_iInterceptionCombatModifier;

	mov	eax, DWORD PTR [ecx+540]

; 850  : }

	ret	0
?GetInterceptionCombatModifier@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetInterceptionCombatModifier
_TEXT	ENDS
PUBLIC	?GetInterceptionDefenseDamageModifier@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetInterceptionDefenseDamageModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetInterceptionDefenseDamageModifier@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetInterceptionDefenseDamageModifier@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetInterceptionDefenseDamageModifier, COMDAT
; _this$ = ecx

; 855  : 	return m_iInterceptionDefenseDamageModifier;

	mov	eax, DWORD PTR [ecx+544]

; 856  : }

	ret	0
?GetInterceptionDefenseDamageModifier@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetInterceptionDefenseDamageModifier
_TEXT	ENDS
PUBLIC	?GetAirSweepCombatModifier@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetAirSweepCombatModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetAirSweepCombatModifier@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAirSweepCombatModifier@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetAirSweepCombatModifier, COMDAT
; _this$ = ecx

; 861  : 	return m_iAirSweepCombatModifier;

	mov	eax, DWORD PTR [ecx+548]

; 862  : }

	ret	0
?GetAirSweepCombatModifier@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetAirSweepCombatModifier
_TEXT	ENDS
PUBLIC	?GetInterceptChanceChange@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetInterceptChanceChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetInterceptChanceChange@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetInterceptChanceChange@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetInterceptChanceChange, COMDAT
; _this$ = ecx

; 867  : 	return m_iInterceptChanceChange;

	mov	eax, DWORD PTR [ecx+552]

; 868  : }

	ret	0
?GetInterceptChanceChange@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetInterceptChanceChange
_TEXT	ENDS
PUBLIC	?GetNumInterceptionChange@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetNumInterceptionChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumInterceptionChange@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumInterceptionChange@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetNumInterceptionChange, COMDAT
; _this$ = ecx

; 873  : 	return m_iNumInterceptionChange;

	mov	eax, DWORD PTR [ecx+556]

; 874  : }

	ret	0
?GetNumInterceptionChange@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetNumInterceptionChange
_TEXT	ENDS
PUBLIC	?GetEvasionChange@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetEvasionChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetEvasionChange@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEvasionChange@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetEvasionChange, COMDAT
; _this$ = ecx

; 879  : 	return m_iEvasionChange;

	mov	eax, DWORD PTR [ecx+560]

; 880  : }

	ret	0
?GetEvasionChange@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetEvasionChange
_TEXT	ENDS
PUBLIC	?GetCargoChange@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetCargoChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetCargoChange@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCargoChange@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetCargoChange, COMDAT
; _this$ = ecx

; 885  : 	return m_iCargoChange;

	mov	eax, DWORD PTR [ecx+564]

; 886  : }

	ret	0
?GetCargoChange@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetCargoChange
_TEXT	ENDS
PUBLIC	?GetEnemyHealChange@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetEnemyHealChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyHealChange@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEnemyHealChange@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetEnemyHealChange, COMDAT
; _this$ = ecx

; 891  : 	return m_iEnemyHealChange;

	mov	eax, DWORD PTR [ecx+568]

; 892  : }

	ret	0
?GetEnemyHealChange@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetEnemyHealChange
_TEXT	ENDS
PUBLIC	?GetNeutralHealChange@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetNeutralHealChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetNeutralHealChange@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNeutralHealChange@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetNeutralHealChange, COMDAT
; _this$ = ecx

; 897  : 	return m_iNeutralHealChange;

	mov	eax, DWORD PTR [ecx+572]

; 898  : }

	ret	0
?GetNeutralHealChange@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetNeutralHealChange
_TEXT	ENDS
PUBLIC	?GetFriendlyHealChange@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetFriendlyHealChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendlyHealChange@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFriendlyHealChange@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetFriendlyHealChange, COMDAT
; _this$ = ecx

; 903  : 	return m_iFriendlyHealChange;

	mov	eax, DWORD PTR [ecx+576]

; 904  : }

	ret	0
?GetFriendlyHealChange@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetFriendlyHealChange
_TEXT	ENDS
PUBLIC	?GetSameTileHealChange@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetSameTileHealChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetSameTileHealChange@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetSameTileHealChange@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetSameTileHealChange, COMDAT
; _this$ = ecx

; 909  : 	return m_iSameTileHealChange;

	mov	eax, DWORD PTR [ecx+580]

; 910  : }

	ret	0
?GetSameTileHealChange@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetSameTileHealChange
_TEXT	ENDS
PUBLIC	?GetAdjacentTileHealChange@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetAdjacentTileHealChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdjacentTileHealChange@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAdjacentTileHealChange@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetAdjacentTileHealChange, COMDAT
; _this$ = ecx

; 915  : 	return m_iAdjacentTileHealChange;

	mov	eax, DWORD PTR [ecx+584]

; 916  : }

	ret	0
?GetAdjacentTileHealChange@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetAdjacentTileHealChange
_TEXT	ENDS
PUBLIC	?GetEnemyDamageChance@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetEnemyDamageChance
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyDamageChance@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEnemyDamageChance@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetEnemyDamageChance, COMDAT
; _this$ = ecx

; 921  : 	return m_iEnemyDamageChance;

	mov	eax, DWORD PTR [ecx+588]

; 922  : }

	ret	0
?GetEnemyDamageChance@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetEnemyDamageChance
_TEXT	ENDS
PUBLIC	?GetNeutralDamageChance@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetNeutralDamageChance
; Function compile flags: /Ogtpy
;	COMDAT ?GetNeutralDamageChance@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNeutralDamageChance@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetNeutralDamageChance, COMDAT
; _this$ = ecx

; 927  : 	return m_iNeutralDamageChance;

	mov	eax, DWORD PTR [ecx+592]

; 928  : }

	ret	0
?GetNeutralDamageChance@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetNeutralDamageChance
_TEXT	ENDS
PUBLIC	?GetEnemyDamage@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetEnemyDamage
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyDamage@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEnemyDamage@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetEnemyDamage, COMDAT
; _this$ = ecx

; 933  : 	return m_iEnemyDamage;

	mov	eax, DWORD PTR [ecx+596]

; 934  : }

	ret	0
?GetEnemyDamage@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetEnemyDamage
_TEXT	ENDS
PUBLIC	?GetNeutralDamage@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetNeutralDamage
; Function compile flags: /Ogtpy
;	COMDAT ?GetNeutralDamage@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNeutralDamage@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetNeutralDamage, COMDAT
; _this$ = ecx

; 939  : 	return m_iNeutralDamage;

	mov	eax, DWORD PTR [ecx+600]

; 940  : }

	ret	0
?GetNeutralDamage@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetNeutralDamage
_TEXT	ENDS
PUBLIC	?GetCombatPercent@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetCombatPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetCombatPercent@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCombatPercent@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetCombatPercent, COMDAT
; _this$ = ecx

; 945  : 	return m_iCombatPercent;

	mov	eax, DWORD PTR [ecx+604]

; 946  : }

	ret	0
?GetCombatPercent@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetCombatPercent
_TEXT	ENDS
PUBLIC	?GetCityAttackPercent@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetCityAttackPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityAttackPercent@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityAttackPercent@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetCityAttackPercent, COMDAT
; _this$ = ecx

; 951  : 	return m_iCityAttackPercent;

	mov	eax, DWORD PTR [ecx+608]

; 952  : }

	ret	0
?GetCityAttackPercent@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetCityAttackPercent
_TEXT	ENDS
PUBLIC	?GetCityDefensePercent@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetCityDefensePercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityDefensePercent@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityDefensePercent@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetCityDefensePercent, COMDAT
; _this$ = ecx

; 957  : 	return m_iCityDefensePercent;

	mov	eax, DWORD PTR [ecx+612]

; 958  : }

	ret	0
?GetCityDefensePercent@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetCityDefensePercent
_TEXT	ENDS
PUBLIC	?GetRangedDefenseMod@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetRangedDefenseMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetRangedDefenseMod@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRangedDefenseMod@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetRangedDefenseMod, COMDAT
; _this$ = ecx

; 963  : 	return m_iRangedDefenseMod;

	mov	eax, DWORD PTR [ecx+616]

; 964  : }

	ret	0
?GetRangedDefenseMod@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetRangedDefenseMod
_TEXT	ENDS
PUBLIC	?GetHillsAttackPercent@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetHillsAttackPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetHillsAttackPercent@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHillsAttackPercent@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetHillsAttackPercent, COMDAT
; _this$ = ecx

; 969  : 	return m_iHillsAttackPercent;

	mov	eax, DWORD PTR [ecx+620]

; 970  : }

	ret	0
?GetHillsAttackPercent@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetHillsAttackPercent
_TEXT	ENDS
PUBLIC	?GetHillsDefensePercent@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetHillsDefensePercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetHillsDefensePercent@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHillsDefensePercent@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetHillsDefensePercent, COMDAT
; _this$ = ecx

; 975  : 	return m_iHillsDefensePercent;

	mov	eax, DWORD PTR [ecx+624]

; 976  : }

	ret	0
?GetHillsDefensePercent@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetHillsDefensePercent
_TEXT	ENDS
PUBLIC	?GetOpenAttackPercent@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetOpenAttackPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetOpenAttackPercent@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetOpenAttackPercent@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetOpenAttackPercent, COMDAT
; _this$ = ecx

; 981  : 	return m_iOpenAttackPercent;

	mov	eax, DWORD PTR [ecx+628]

; 982  : }

	ret	0
?GetOpenAttackPercent@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetOpenAttackPercent
_TEXT	ENDS
PUBLIC	?GetOpenRangedAttackMod@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetOpenRangedAttackMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetOpenRangedAttackMod@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetOpenRangedAttackMod@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetOpenRangedAttackMod, COMDAT
; _this$ = ecx

; 987  : 	return m_iOpenRangedAttackMod;

	mov	eax, DWORD PTR [ecx+632]

; 988  : }

	ret	0
?GetOpenRangedAttackMod@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetOpenRangedAttackMod
_TEXT	ENDS
PUBLIC	?GetRoughAttackPercent@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetRoughAttackPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetRoughAttackPercent@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRoughAttackPercent@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetRoughAttackPercent, COMDAT
; _this$ = ecx

; 993  : 	return m_iRoughAttackPercent;

	mov	eax, DWORD PTR [ecx+636]

; 994  : }

	ret	0
?GetRoughAttackPercent@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetRoughAttackPercent
_TEXT	ENDS
PUBLIC	?GetRoughRangedAttackMod@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetRoughRangedAttackMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetRoughRangedAttackMod@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRoughRangedAttackMod@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetRoughRangedAttackMod, COMDAT
; _this$ = ecx

; 999  : 	return m_iRoughRangedAttackMod;

	mov	eax, DWORD PTR [ecx+640]

; 1000 : }

	ret	0
?GetRoughRangedAttackMod@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetRoughRangedAttackMod
_TEXT	ENDS
PUBLIC	?GetAttackFortifiedMod@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetAttackFortifiedMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetAttackFortifiedMod@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAttackFortifiedMod@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetAttackFortifiedMod, COMDAT
; _this$ = ecx

; 1005 : 	return m_iAttackFortifiedMod;

	mov	eax, DWORD PTR [ecx+644]

; 1006 : }

	ret	0
?GetAttackFortifiedMod@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetAttackFortifiedMod
_TEXT	ENDS
PUBLIC	?GetAttackWoundedMod@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetAttackWoundedMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetAttackWoundedMod@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAttackWoundedMod@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetAttackWoundedMod, COMDAT
; _this$ = ecx

; 1011 : 	return m_iAttackWoundedMod;

	mov	eax, DWORD PTR [ecx+648]

; 1012 : }

	ret	0
?GetAttackWoundedMod@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetAttackWoundedMod
_TEXT	ENDS
PUBLIC	?GetFlankAttackModifier@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetFlankAttackModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlankAttackModifier@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFlankAttackModifier@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetFlankAttackModifier, COMDAT
; _this$ = ecx

; 1017 : 	return m_iFlankAttackModifier;

	mov	eax, DWORD PTR [ecx+652]

; 1018 : }

	ret	0
?GetFlankAttackModifier@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetFlankAttackModifier
_TEXT	ENDS
PUBLIC	?GetNearbyEnemyCombatMod@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetNearbyEnemyCombatMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetNearbyEnemyCombatMod@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNearbyEnemyCombatMod@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetNearbyEnemyCombatMod, COMDAT
; _this$ = ecx

; 1023 : 	return m_iNearbyEnemyCombatMod;

	mov	eax, DWORD PTR [ecx+656]

; 1024 : }

	ret	0
?GetNearbyEnemyCombatMod@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetNearbyEnemyCombatMod
_TEXT	ENDS
PUBLIC	?GetNearbyEnemyCombatRange@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetNearbyEnemyCombatRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetNearbyEnemyCombatRange@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNearbyEnemyCombatRange@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetNearbyEnemyCombatRange, COMDAT
; _this$ = ecx

; 1029 : 	return m_iNearbyEnemyCombatRange;

	mov	eax, DWORD PTR [ecx+660]

; 1030 : }

	ret	0
?GetNearbyEnemyCombatRange@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetNearbyEnemyCombatRange
_TEXT	ENDS
PUBLIC	?GetOpenDefensePercent@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetOpenDefensePercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetOpenDefensePercent@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetOpenDefensePercent@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetOpenDefensePercent, COMDAT
; _this$ = ecx

; 1035 : 	return m_iOpenDefensePercent;

	mov	eax, DWORD PTR [ecx+664]

; 1036 : }

	ret	0
?GetOpenDefensePercent@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetOpenDefensePercent
_TEXT	ENDS
PUBLIC	?GetRoughDefensePercent@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetRoughDefensePercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetRoughDefensePercent@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRoughDefensePercent@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetRoughDefensePercent, COMDAT
; _this$ = ecx

; 1041 : 	return m_iRoughDefensePercent;

	mov	eax, DWORD PTR [ecx+668]

; 1042 : }

	ret	0
?GetRoughDefensePercent@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetRoughDefensePercent
_TEXT	ENDS
PUBLIC	?GetExtraAttacks@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetExtraAttacks
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraAttacks@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraAttacks@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetExtraAttacks, COMDAT
; _this$ = ecx

; 1047 : 	return m_iExtraAttacks;

	mov	eax, DWORD PTR [ecx+672]

; 1048 : }

	ret	0
?GetExtraAttacks@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetExtraAttacks
_TEXT	ENDS
PUBLIC	?IsGreatGeneral@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsGreatGeneral
; Function compile flags: /Ogtpy
;	COMDAT ?IsGreatGeneral@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsGreatGeneral@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsGreatGeneral, COMDAT
; _this$ = ecx

; 1053 : 	return m_bGreatGeneral;

	mov	al, BYTE PTR [ecx+676]

; 1054 : }

	ret	0
?IsGreatGeneral@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsGreatGeneral
_TEXT	ENDS
PUBLIC	?IsGreatAdmiral@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsGreatAdmiral
; Function compile flags: /Ogtpy
;	COMDAT ?IsGreatAdmiral@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsGreatAdmiral@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsGreatAdmiral, COMDAT
; _this$ = ecx

; 1059 : 	return m_bGreatAdmiral;

	mov	al, BYTE PTR [ecx+677]

; 1060 : }

	ret	0
?IsGreatAdmiral@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsGreatAdmiral
_TEXT	ENDS
PUBLIC	?GetGreatGeneralModifier@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetGreatGeneralModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatGeneralModifier@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatGeneralModifier@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetGreatGeneralModifier, COMDAT
; _this$ = ecx

; 1065 : 	return m_iGreatGeneralModifier;

	mov	eax, DWORD PTR [ecx+680]

; 1066 : }

	ret	0
?GetGreatGeneralModifier@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetGreatGeneralModifier
_TEXT	ENDS
PUBLIC	?IsGreatGeneralReceivesMovement@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::IsGreatGeneralReceivesMovement
; Function compile flags: /Ogtpy
;	COMDAT ?IsGreatGeneralReceivesMovement@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsGreatGeneralReceivesMovement@CvPromotionEntry@@QBE_NXZ PROC ; CvPromotionEntry::IsGreatGeneralReceivesMovement, COMDAT
; _this$ = ecx

; 1071 : 	return m_bGreatGeneralReceivesMovement;

	mov	al, BYTE PTR [ecx+684]

; 1072 : }

	ret	0
?IsGreatGeneralReceivesMovement@CvPromotionEntry@@QBE_NXZ ENDP ; CvPromotionEntry::IsGreatGeneralReceivesMovement
_TEXT	ENDS
PUBLIC	?IsEmbarkedUnitReceivesMovement@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::IsEmbarkedUnitReceivesMovement
; Function compile flags: /Ogtpy
;	COMDAT ?IsEmbarkedUnitReceivesMovement@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsEmbarkedUnitReceivesMovement@CvPromotionEntry@@QBE_NXZ PROC ; CvPromotionEntry::IsEmbarkedUnitReceivesMovement, COMDAT
; _this$ = ecx

; 1078 : 	return m_bEmbarkedUnitReceivesMovement;

	mov	al, BYTE PTR [ecx+685]

; 1079 : }

	ret	0
?IsEmbarkedUnitReceivesMovement@CvPromotionEntry@@QBE_NXZ ENDP ; CvPromotionEntry::IsEmbarkedUnitReceivesMovement
_TEXT	ENDS
PUBLIC	?GetGreatGeneralOnOrAdjacentConfersMovement@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetGreatGeneralOnOrAdjacentConfersMovement
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatGeneralOnOrAdjacentConfersMovement@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatGeneralOnOrAdjacentConfersMovement@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetGreatGeneralOnOrAdjacentConfersMovement, COMDAT
; _this$ = ecx

; 1086 : 	return m_iGreatGeneralOnOrAdjacentConfersMovement;

	mov	eax, DWORD PTR [ecx+688]

; 1087 : }

	ret	0
?GetGreatGeneralOnOrAdjacentConfersMovement@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetGreatGeneralOnOrAdjacentConfersMovement
_TEXT	ENDS
PUBLIC	?GetGreatGeneralCombatModifier@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetGreatGeneralCombatModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetGreatGeneralCombatModifier@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGreatGeneralCombatModifier@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetGreatGeneralCombatModifier, COMDAT
; _this$ = ecx

; 1094 : 	return m_iGreatGeneralCombatModifier;

	mov	eax, DWORD PTR [ecx+692]

; 1095 : }

	ret	0
?GetGreatGeneralCombatModifier@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetGreatGeneralCombatModifier
_TEXT	ENDS
PUBLIC	?GetFriendlyLandsModifier@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetFriendlyLandsModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendlyLandsModifier@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFriendlyLandsModifier@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetFriendlyLandsModifier, COMDAT
; _this$ = ecx

; 1100 : 	return m_iFriendlyLandsModifier;

	mov	eax, DWORD PTR [ecx+696]

; 1101 : }

	ret	0
?GetFriendlyLandsModifier@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetFriendlyLandsModifier
_TEXT	ENDS
PUBLIC	?GetFriendlyLandsAttackModifier@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetFriendlyLandsAttackModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendlyLandsAttackModifier@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFriendlyLandsAttackModifier@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetFriendlyLandsAttackModifier, COMDAT
; _this$ = ecx

; 1106 : 	return m_iFriendlyLandsAttackModifier;

	mov	eax, DWORD PTR [ecx+700]

; 1107 : }

	ret	0
?GetFriendlyLandsAttackModifier@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetFriendlyLandsAttackModifier
_TEXT	ENDS
PUBLIC	?GetOutsideFriendlyLandsModifier@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetOutsideFriendlyLandsModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetOutsideFriendlyLandsModifier@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetOutsideFriendlyLandsModifier@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetOutsideFriendlyLandsModifier, COMDAT
; _this$ = ecx

; 1112 : 	return m_iOutsideFriendlyLandsModifier;

	mov	eax, DWORD PTR [ecx+704]

; 1113 : }

	ret	0
?GetOutsideFriendlyLandsModifier@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetOutsideFriendlyLandsModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeForeignAttackBonus@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetGoldenAgeForeignAttackBonus
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeForeignAttackBonus@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeForeignAttackBonus@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetGoldenAgeForeignAttackBonus, COMDAT
; _this$ = ecx

; 1119 : 	return m_iGoldenAgeForeignAttackBonus;

	mov	eax, DWORD PTR [ecx+708]

; 1120 : }

	ret	0
?GetGoldenAgeForeignAttackBonus@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetGoldenAgeForeignAttackBonus
_TEXT	ENDS
PUBLIC	?GetCombatStrengthNearFriendlyMinor@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetCombatStrengthNearFriendlyMinor
; Function compile flags: /Ogtpy
;	COMDAT ?GetCombatStrengthNearFriendlyMinor@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCombatStrengthNearFriendlyMinor@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetCombatStrengthNearFriendlyMinor, COMDAT
; _this$ = ecx

; 1127 : 	return m_iCombatStrengthNearFriendlyMinor;

	mov	eax, DWORD PTR [ecx+712]

; 1128 : }

	ret	0
?GetCombatStrengthNearFriendlyMinor@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetCombatStrengthNearFriendlyMinor
_TEXT	ENDS
PUBLIC	?GetCommandType@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetCommandType
; Function compile flags: /Ogtpy
;	COMDAT ?GetCommandType@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCommandType@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetCommandType, COMDAT
; _this$ = ecx

; 1134 : 	return m_iCommandType;

	mov	eax, DWORD PTR [ecx+716]

; 1135 : }

	ret	0
?GetCommandType@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetCommandType
_TEXT	ENDS
PUBLIC	?SetCommandType@CvPromotionEntry@@QAEXH@Z	; CvPromotionEntry::SetCommandType
; Function compile flags: /Ogtpy
;	COMDAT ?SetCommandType@CvPromotionEntry@@QAEXH@Z
_TEXT	SEGMENT
_iNewType$ = 8						; size = 4
?SetCommandType@CvPromotionEntry@@QAEXH@Z PROC		; CvPromotionEntry::SetCommandType, COMDAT
; _this$ = ecx

; 1140 : 	m_iCommandType = iNewType;

	mov	eax, DWORD PTR _iNewType$[esp-4]
	mov	DWORD PTR [ecx+716], eax

; 1141 : }

	ret	4
?SetCommandType@CvPromotionEntry@@QAEXH@Z ENDP		; CvPromotionEntry::SetCommandType
_TEXT	ENDS
PUBLIC	?GetUpgradeDiscount@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetUpgradeDiscount
; Function compile flags: /Ogtpy
;	COMDAT ?GetUpgradeDiscount@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUpgradeDiscount@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetUpgradeDiscount, COMDAT
; _this$ = ecx

; 1146 : 	return m_iUpgradeDiscount;

	mov	eax, DWORD PTR [ecx+720]

; 1147 : }

	ret	0
?GetUpgradeDiscount@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetUpgradeDiscount
_TEXT	ENDS
PUBLIC	?GetExperiencePercent@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetExperiencePercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetExperiencePercent@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExperiencePercent@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetExperiencePercent, COMDAT
; _this$ = ecx

; 1152 : 	return m_iExperiencePercent;

	mov	eax, DWORD PTR [ecx+724]

; 1153 : }

	ret	0
?GetExperiencePercent@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetExperiencePercent
_TEXT	ENDS
PUBLIC	?GetAdjacentMod@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetAdjacentMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdjacentMod@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAdjacentMod@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetAdjacentMod, COMDAT
; _this$ = ecx

; 1158 : 	return m_iAdjacentMod;

	mov	eax, DWORD PTR [ecx+728]

; 1159 : }

	ret	0
?GetAdjacentMod@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetAdjacentMod
_TEXT	ENDS
PUBLIC	?GetAttackMod@CvPromotionEntry@@QBEHXZ		; CvPromotionEntry::GetAttackMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetAttackMod@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAttackMod@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetAttackMod, COMDAT
; _this$ = ecx

; 1164 : 	return m_iAttackMod;

	mov	eax, DWORD PTR [ecx+732]

; 1165 : }

	ret	0
?GetAttackMod@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetAttackMod
_TEXT	ENDS
PUBLIC	?GetDefenseMod@CvPromotionEntry@@QBEHXZ		; CvPromotionEntry::GetDefenseMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetDefenseMod@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetDefenseMod@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetDefenseMod, COMDAT
; _this$ = ecx

; 1170 : 	return m_iDefenseMod;

	mov	eax, DWORD PTR [ecx+736]

; 1171 : }

	ret	0
?GetDefenseMod@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetDefenseMod
_TEXT	ENDS
PUBLIC	?GetDropRange@CvPromotionEntry@@QBEHXZ		; CvPromotionEntry::GetDropRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetDropRange@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetDropRange@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetDropRange, COMDAT
; _this$ = ecx

; 1176 : 	return m_iDropRange;

	mov	eax, DWORD PTR [ecx+740]

; 1177 : }

	ret	0
?GetDropRange@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetDropRange
_TEXT	ENDS
PUBLIC	?GetExtraNavalMoves@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetExtraNavalMoves
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraNavalMoves@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraNavalMoves@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetExtraNavalMoves, COMDAT
; _this$ = ecx

; 1182 : 	return m_iExtraNavalMoves;

	mov	eax, DWORD PTR [ecx+744]

; 1183 : }

	ret	0
?GetExtraNavalMoves@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetExtraNavalMoves
_TEXT	ENDS
PUBLIC	?GetHPHealedIfDefeatEnemy@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetHPHealedIfDefeatEnemy
; Function compile flags: /Ogtpy
;	COMDAT ?GetHPHealedIfDefeatEnemy@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHPHealedIfDefeatEnemy@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetHPHealedIfDefeatEnemy, COMDAT
; _this$ = ecx

; 1188 : 	return m_iHPHealedIfDefeatEnemy;

	mov	eax, DWORD PTR [ecx+748]

; 1189 : }

	ret	0
?GetHPHealedIfDefeatEnemy@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetHPHealedIfDefeatEnemy
_TEXT	ENDS
PUBLIC	?GetGoldenAgeValueFromKills@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetGoldenAgeValueFromKills
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoldenAgeValueFromKills@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldenAgeValueFromKills@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetGoldenAgeValueFromKills, COMDAT
; _this$ = ecx

; 1194 : 	return m_iGoldenAgeValueFromKills;

	mov	eax, DWORD PTR [ecx+752]

; 1195 : }

	ret	0
?GetGoldenAgeValueFromKills@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetGoldenAgeValueFromKills
_TEXT	ENDS
PUBLIC	?GetExtraWithdrawal@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetExtraWithdrawal
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraWithdrawal@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraWithdrawal@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetExtraWithdrawal, COMDAT
; _this$ = ecx

; 1200 : 	return m_iExtraWithdrawal;

	mov	eax, DWORD PTR [ecx+756]

; 1201 : }

	ret	0
?GetExtraWithdrawal@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetExtraWithdrawal
_TEXT	ENDS
PUBLIC	?GetEmbarkExtraVisibility@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetEmbarkExtraVisibility
; Function compile flags: /Ogtpy
;	COMDAT ?GetEmbarkExtraVisibility@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEmbarkExtraVisibility@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetEmbarkExtraVisibility, COMDAT
; _this$ = ecx

; 1206 : 	return m_iEmbarkExtraVisibility;

	mov	eax, DWORD PTR [ecx+760]

; 1207 : }

	ret	0
?GetEmbarkExtraVisibility@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetEmbarkExtraVisibility
_TEXT	ENDS
PUBLIC	?GetEmbarkDefenseModifier@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetEmbarkDefenseModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetEmbarkDefenseModifier@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEmbarkDefenseModifier@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetEmbarkDefenseModifier, COMDAT
; _this$ = ecx

; 1212 : 	return m_iEmbarkDefenseModifier;

	mov	eax, DWORD PTR [ecx+764]

; 1213 : }

	ret	0
?GetEmbarkDefenseModifier@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetEmbarkDefenseModifier
_TEXT	ENDS
PUBLIC	?GetCapitalDefenseModifier@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetCapitalDefenseModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalDefenseModifier@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCapitalDefenseModifier@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetCapitalDefenseModifier, COMDAT
; _this$ = ecx

; 1218 : 	return m_iCapitalDefenseModifier;

	mov	eax, DWORD PTR [ecx+768]

; 1219 : }

	ret	0
?GetCapitalDefenseModifier@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetCapitalDefenseModifier
_TEXT	ENDS
PUBLIC	?GetCapitalDefenseFalloff@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetCapitalDefenseFalloff
; Function compile flags: /Ogtpy
;	COMDAT ?GetCapitalDefenseFalloff@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCapitalDefenseFalloff@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetCapitalDefenseFalloff, COMDAT
; _this$ = ecx

; 1224 : 	return m_iCapitalDefenseFalloff;

	mov	eax, DWORD PTR [ecx+772]

; 1225 : }

	ret	0
?GetCapitalDefenseFalloff@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetCapitalDefenseFalloff
_TEXT	ENDS
PUBLIC	?GetCityAttackPlunderModifier@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetCityAttackPlunderModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityAttackPlunderModifier@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCityAttackPlunderModifier@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetCityAttackPlunderModifier, COMDAT
; _this$ = ecx

; 1230 : 	return m_iCityAttackPlunderModifier;

	mov	eax, DWORD PTR [ecx+776]

; 1231 : }

	ret	0
?GetCityAttackPlunderModifier@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetCityAttackPlunderModifier
_TEXT	ENDS
PUBLIC	?GetReligiousStrengthLossRivalTerritory@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetReligiousStrengthLossRivalTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?GetReligiousStrengthLossRivalTerritory@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetReligiousStrengthLossRivalTerritory@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetReligiousStrengthLossRivalTerritory, COMDAT
; _this$ = ecx

; 1236 : 	return m_iReligiousStrengthLossRivalTerritory;

	mov	eax, DWORD PTR [ecx+780]

; 1237 : }

	ret	0
?GetReligiousStrengthLossRivalTerritory@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetReligiousStrengthLossRivalTerritory
_TEXT	ENDS
PUBLIC	?GetTradeMissionInfluenceModifier@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetTradeMissionInfluenceModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeMissionInfluenceModifier@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTradeMissionInfluenceModifier@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetTradeMissionInfluenceModifier, COMDAT
; _this$ = ecx

; 1242 : 	return m_iTradeMissionInfluenceModifier;

	mov	eax, DWORD PTR [ecx+784]

; 1243 : }

	ret	0
?GetTradeMissionInfluenceModifier@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetTradeMissionInfluenceModifier
_TEXT	ENDS
PUBLIC	?GetTradeMissionGoldModifier@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetTradeMissionGoldModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeMissionGoldModifier@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTradeMissionGoldModifier@CvPromotionEntry@@QBEHXZ PROC ; CvPromotionEntry::GetTradeMissionGoldModifier, COMDAT
; _this$ = ecx

; 1248 : 	return m_iTradeMissionGoldModifier;

	mov	eax, DWORD PTR [ecx+788]

; 1249 : }

	ret	0
?GetTradeMissionGoldModifier@CvPromotionEntry@@QBEHXZ ENDP ; CvPromotionEntry::GetTradeMissionGoldModifier
_TEXT	ENDS
PUBLIC	?IsCannotBeChosen@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsCannotBeChosen
; Function compile flags: /Ogtpy
;	COMDAT ?IsCannotBeChosen@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsCannotBeChosen@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsCannotBeChosen, COMDAT
; _this$ = ecx

; 1254 : 	return m_bCannotBeChosen;

	mov	al, BYTE PTR [ecx+792]

; 1255 : }

	ret	0
?IsCannotBeChosen@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsCannotBeChosen
_TEXT	ENDS
PUBLIC	?IsLostWithUpgrade@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsLostWithUpgrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsLostWithUpgrade@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsLostWithUpgrade@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsLostWithUpgrade, COMDAT
; _this$ = ecx

; 1260 : 	return m_bLostWithUpgrade;

	mov	al, BYTE PTR [ecx+793]

; 1261 : }

	ret	0
?IsLostWithUpgrade@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsLostWithUpgrade
_TEXT	ENDS
PUBLIC	?IsNotWithUpgrade@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsNotWithUpgrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsNotWithUpgrade@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNotWithUpgrade@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsNotWithUpgrade, COMDAT
; _this$ = ecx

; 1266 : 	return m_bNotWithUpgrade;

	mov	al, BYTE PTR [ecx+794]

; 1267 : }

	ret	0
?IsNotWithUpgrade@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsNotWithUpgrade
_TEXT	ENDS
PUBLIC	?IsInstaHeal@CvPromotionEntry@@QBE_NXZ		; CvPromotionEntry::IsInstaHeal
; Function compile flags: /Ogtpy
;	COMDAT ?IsInstaHeal@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsInstaHeal@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsInstaHeal, COMDAT
; _this$ = ecx

; 1272 : 	return m_bInstaHeal;

	mov	al, BYTE PTR [ecx+795]

; 1273 : }

	ret	0
?IsInstaHeal@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsInstaHeal
_TEXT	ENDS
PUBLIC	?IsLeader@CvPromotionEntry@@QBE_NXZ		; CvPromotionEntry::IsLeader
; Function compile flags: /Ogtpy
;	COMDAT ?IsLeader@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsLeader@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsLeader, COMDAT
; _this$ = ecx

; 1278 : 	return m_bLeader;

	mov	al, BYTE PTR [ecx+796]

; 1279 : }

	ret	0
?IsLeader@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsLeader
_TEXT	ENDS
PUBLIC	?IsBlitz@CvPromotionEntry@@QBE_NXZ		; CvPromotionEntry::IsBlitz
; Function compile flags: /Ogtpy
;	COMDAT ?IsBlitz@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsBlitz@CvPromotionEntry@@QBE_NXZ PROC			; CvPromotionEntry::IsBlitz, COMDAT
; _this$ = ecx

; 1284 : 	return m_bBlitz;

	mov	al, BYTE PTR [ecx+797]

; 1285 : }

	ret	0
?IsBlitz@CvPromotionEntry@@QBE_NXZ ENDP			; CvPromotionEntry::IsBlitz
_TEXT	ENDS
PUBLIC	?IsAmphib@CvPromotionEntry@@QBE_NXZ		; CvPromotionEntry::IsAmphib
; Function compile flags: /Ogtpy
;	COMDAT ?IsAmphib@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAmphib@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsAmphib, COMDAT
; _this$ = ecx

; 1290 : 	return m_bAmphib;

	mov	al, BYTE PTR [ecx+798]

; 1291 : }

	ret	0
?IsAmphib@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsAmphib
_TEXT	ENDS
PUBLIC	?IsRiver@CvPromotionEntry@@QBE_NXZ		; CvPromotionEntry::IsRiver
; Function compile flags: /Ogtpy
;	COMDAT ?IsRiver@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRiver@CvPromotionEntry@@QBE_NXZ PROC			; CvPromotionEntry::IsRiver, COMDAT
; _this$ = ecx

; 1296 : 	return m_bRiver;

	mov	al, BYTE PTR [ecx+799]

; 1297 : }

	ret	0
?IsRiver@CvPromotionEntry@@QBE_NXZ ENDP			; CvPromotionEntry::IsRiver
_TEXT	ENDS
PUBLIC	?IsEnemyRoute@CvPromotionEntry@@QBE_NXZ		; CvPromotionEntry::IsEnemyRoute
; Function compile flags: /Ogtpy
;	COMDAT ?IsEnemyRoute@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsEnemyRoute@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsEnemyRoute, COMDAT
; _this$ = ecx

; 1302 : 	return m_bEnemyRoute;

	mov	al, BYTE PTR [ecx+800]

; 1303 : }

	ret	0
?IsEnemyRoute@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsEnemyRoute
_TEXT	ENDS
PUBLIC	?IsRivalTerritory@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsRivalTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?IsRivalTerritory@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRivalTerritory@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsRivalTerritory, COMDAT
; _this$ = ecx

; 1308 : 	return m_bRivalTerritory;

	mov	al, BYTE PTR [ecx+801]

; 1309 : }

	ret	0
?IsRivalTerritory@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsRivalTerritory
_TEXT	ENDS
PUBLIC	?IsMustSetUpToRangedAttack@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::IsMustSetUpToRangedAttack
; Function compile flags: /Ogtpy
;	COMDAT ?IsMustSetUpToRangedAttack@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMustSetUpToRangedAttack@CvPromotionEntry@@QBE_NXZ PROC ; CvPromotionEntry::IsMustSetUpToRangedAttack, COMDAT
; _this$ = ecx

; 1314 : 	return m_bMustSetUpToRangedAttack;

	mov	al, BYTE PTR [ecx+802]

; 1315 : }

	ret	0
?IsMustSetUpToRangedAttack@CvPromotionEntry@@QBE_NXZ ENDP ; CvPromotionEntry::IsMustSetUpToRangedAttack
_TEXT	ENDS
PUBLIC	?IsRangedSupportFire@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsRangedSupportFire
; Function compile flags: /Ogtpy
;	COMDAT ?IsRangedSupportFire@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRangedSupportFire@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsRangedSupportFire, COMDAT
; _this$ = ecx

; 1320 : 	return m_bRangedSupportFire;

	mov	al, BYTE PTR [ecx+803]

; 1321 : }

	ret	0
?IsRangedSupportFire@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsRangedSupportFire
_TEXT	ENDS
PUBLIC	?IsAlwaysHeal@CvPromotionEntry@@QBE_NXZ		; CvPromotionEntry::IsAlwaysHeal
; Function compile flags: /Ogtpy
;	COMDAT ?IsAlwaysHeal@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAlwaysHeal@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsAlwaysHeal, COMDAT
; _this$ = ecx

; 1326 : 	return m_bAlwaysHeal;

	mov	al, BYTE PTR [ecx+804]

; 1327 : }

	ret	0
?IsAlwaysHeal@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsAlwaysHeal
_TEXT	ENDS
PUBLIC	?IsHealOutsideFriendly@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::IsHealOutsideFriendly
; Function compile flags: /Ogtpy
;	COMDAT ?IsHealOutsideFriendly@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsHealOutsideFriendly@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsHealOutsideFriendly, COMDAT
; _this$ = ecx

; 1332 : 	return m_bHealOutsideFriendly;

	mov	al, BYTE PTR [ecx+805]

; 1333 : }

	ret	0
?IsHealOutsideFriendly@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsHealOutsideFriendly
_TEXT	ENDS
PUBLIC	?IsHillsDoubleMove@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsHillsDoubleMove
; Function compile flags: /Ogtpy
;	COMDAT ?IsHillsDoubleMove@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsHillsDoubleMove@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsHillsDoubleMove, COMDAT
; _this$ = ecx

; 1338 : 	return m_bHillsDoubleMove;

	mov	al, BYTE PTR [ecx+806]

; 1339 : }

	ret	0
?IsHillsDoubleMove@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsHillsDoubleMove
_TEXT	ENDS
PUBLIC	?IsIgnoreTerrainCost@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsIgnoreTerrainCost
; Function compile flags: /Ogtpy
;	COMDAT ?IsIgnoreTerrainCost@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsIgnoreTerrainCost@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsIgnoreTerrainCost, COMDAT
; _this$ = ecx

; 1344 : 	return m_bIgnoreTerrainCost;

	mov	al, BYTE PTR [ecx+807]

; 1345 : }

	ret	0
?IsIgnoreTerrainCost@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsIgnoreTerrainCost
_TEXT	ENDS
PUBLIC	?IsRoughTerrainEndsTurn@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::IsRoughTerrainEndsTurn
; Function compile flags: /Ogtpy
;	COMDAT ?IsRoughTerrainEndsTurn@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRoughTerrainEndsTurn@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsRoughTerrainEndsTurn, COMDAT
; _this$ = ecx

; 1350 : 	return m_bRoughTerrainEndsTurn;

	mov	al, BYTE PTR [ecx+808]

; 1351 : }

	ret	0
?IsRoughTerrainEndsTurn@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsRoughTerrainEndsTurn
_TEXT	ENDS
PUBLIC	?IsHoveringUnit@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsHoveringUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsHoveringUnit@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsHoveringUnit@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsHoveringUnit, COMDAT
; _this$ = ecx

; 1356 : 	return m_bHoveringUnit;

	mov	al, BYTE PTR [ecx+809]

; 1357 : }

	ret	0
?IsHoveringUnit@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsHoveringUnit
_TEXT	ENDS
PUBLIC	?IsFlatMovementCost@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsFlatMovementCost
; Function compile flags: /Ogtpy
;	COMDAT ?IsFlatMovementCost@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFlatMovementCost@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsFlatMovementCost, COMDAT
; _this$ = ecx

; 1362 : 	return m_bFlatMovementCost;

	mov	al, BYTE PTR [ecx+810]

; 1363 : }

	ret	0
?IsFlatMovementCost@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsFlatMovementCost
_TEXT	ENDS
PUBLIC	?IsCanMoveImpassable@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsCanMoveImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?IsCanMoveImpassable@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsCanMoveImpassable@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsCanMoveImpassable, COMDAT
; _this$ = ecx

; 1368 : 	return m_bCanMoveImpassable;

	mov	al, BYTE PTR [ecx+811]

; 1369 : }

	ret	0
?IsCanMoveImpassable@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsCanMoveImpassable
_TEXT	ENDS
PUBLIC	?IsNoCapture@CvPromotionEntry@@QBE_NXZ		; CvPromotionEntry::IsNoCapture
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoCapture@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNoCapture@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsNoCapture, COMDAT
; _this$ = ecx

; 1374 : 	return m_bNoCapture;

	mov	al, BYTE PTR [ecx+812]

; 1375 : }

	ret	0
?IsNoCapture@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsNoCapture
_TEXT	ENDS
PUBLIC	?IsOnlyDefensive@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsOnlyDefensive
; Function compile flags: /Ogtpy
;	COMDAT ?IsOnlyDefensive@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsOnlyDefensive@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsOnlyDefensive, COMDAT
; _this$ = ecx

; 1380 : 	return m_bOnlyDefensive;

	mov	al, BYTE PTR [ecx+813]

; 1381 : }

	ret	0
?IsOnlyDefensive@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsOnlyDefensive
_TEXT	ENDS
PUBLIC	?IsNoDefensiveBonus@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsNoDefensiveBonus
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoDefensiveBonus@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNoDefensiveBonus@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsNoDefensiveBonus, COMDAT
; _this$ = ecx

; 1386 : 	return m_bNoDefensiveBonus;

	mov	al, BYTE PTR [ecx+814]

; 1387 : }

	ret	0
?IsNoDefensiveBonus@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsNoDefensiveBonus
_TEXT	ENDS
PUBLIC	?IsNukeImmune@CvPromotionEntry@@QBE_NXZ		; CvPromotionEntry::IsNukeImmune
; Function compile flags: /Ogtpy
;	COMDAT ?IsNukeImmune@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNukeImmune@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsNukeImmune, COMDAT
; _this$ = ecx

; 1392 : 	return m_bNukeImmune;

	mov	al, BYTE PTR [ecx+815]

; 1393 : }

	ret	0
?IsNukeImmune@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsNukeImmune
_TEXT	ENDS
PUBLIC	?IsHiddenNationality@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsHiddenNationality
; Function compile flags: /Ogtpy
;	COMDAT ?IsHiddenNationality@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsHiddenNationality@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsHiddenNationality, COMDAT
; _this$ = ecx

; 1398 : 	return m_bHiddenNationality;

	mov	al, BYTE PTR [ecx+816]

; 1399 : }

	ret	0
?IsHiddenNationality@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsHiddenNationality
_TEXT	ENDS
PUBLIC	?IsAlwaysHostile@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsAlwaysHostile
; Function compile flags: /Ogtpy
;	COMDAT ?IsAlwaysHostile@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAlwaysHostile@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsAlwaysHostile, COMDAT
; _this$ = ecx

; 1404 : 	return m_bAlwaysHostile;

	mov	al, BYTE PTR [ecx+817]

; 1405 : }

	ret	0
?IsAlwaysHostile@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsAlwaysHostile
_TEXT	ENDS
PUBLIC	?IsNoRevealMap@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsNoRevealMap
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoRevealMap@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNoRevealMap@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsNoRevealMap, COMDAT
; _this$ = ecx

; 1410 : 	return m_bNoRevealMap;

	mov	al, BYTE PTR [ecx+818]

; 1411 : }

	ret	0
?IsNoRevealMap@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsNoRevealMap
_TEXT	ENDS
PUBLIC	?IsRecon@CvPromotionEntry@@QBE_NXZ		; CvPromotionEntry::IsRecon
; Function compile flags: /Ogtpy
;	COMDAT ?IsRecon@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRecon@CvPromotionEntry@@QBE_NXZ PROC			; CvPromotionEntry::IsRecon, COMDAT
; _this$ = ecx

; 1416 : 	return m_bRecon;

	mov	al, BYTE PTR [ecx+819]

; 1417 : }

	ret	0
?IsRecon@CvPromotionEntry@@QBE_NXZ ENDP			; CvPromotionEntry::IsRecon
_TEXT	ENDS
PUBLIC	?CanMoveAllTerrain@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::CanMoveAllTerrain
; Function compile flags: /Ogtpy
;	COMDAT ?CanMoveAllTerrain@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?CanMoveAllTerrain@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::CanMoveAllTerrain, COMDAT
; _this$ = ecx

; 1422 : 	return m_bCanMoveAllTerrain;

	mov	al, BYTE PTR [ecx+820]

; 1423 : }

	ret	0
?CanMoveAllTerrain@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::CanMoveAllTerrain
_TEXT	ENDS
PUBLIC	?IsCanMoveAfterAttacking@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::IsCanMoveAfterAttacking
; Function compile flags: /Ogtpy
;	COMDAT ?IsCanMoveAfterAttacking@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsCanMoveAfterAttacking@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsCanMoveAfterAttacking, COMDAT
; _this$ = ecx

; 1428 : 	return m_bCanMoveAfterAttacking;

	mov	al, BYTE PTR [ecx+821]

; 1429 : }

	ret	0
?IsCanMoveAfterAttacking@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsCanMoveAfterAttacking
_TEXT	ENDS
PUBLIC	?IsAirSweepCapable@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsAirSweepCapable
; Function compile flags: /Ogtpy
;	COMDAT ?IsAirSweepCapable@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAirSweepCapable@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsAirSweepCapable, COMDAT
; _this$ = ecx

; 1434 : 	return m_bAirSweepCapable;

	mov	al, BYTE PTR [ecx+822]

; 1435 : }

	ret	0
?IsAirSweepCapable@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsAirSweepCapable
_TEXT	ENDS
PUBLIC	?IsAllowsEmbarkation@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsAllowsEmbarkation
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowsEmbarkation@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAllowsEmbarkation@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsAllowsEmbarkation, COMDAT
; _this$ = ecx

; 1440 : 	return m_bAllowsEmbarkation;

	mov	al, BYTE PTR [ecx+823]

; 1441 : }

	ret	0
?IsAllowsEmbarkation@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsAllowsEmbarkation
_TEXT	ENDS
PUBLIC	?IsRangeAttackIgnoreLOS@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::IsRangeAttackIgnoreLOS
; Function compile flags: /Ogtpy
;	COMDAT ?IsRangeAttackIgnoreLOS@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRangeAttackIgnoreLOS@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsRangeAttackIgnoreLOS, COMDAT
; _this$ = ecx

; 1446 : 	return m_bRangeAttackIgnoreLOS;

	mov	al, BYTE PTR [ecx+824]

; 1447 : }

	ret	0
?IsRangeAttackIgnoreLOS@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsRangeAttackIgnoreLOS
_TEXT	ENDS
PUBLIC	?IsFreePillageMoves@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsFreePillageMoves
; Function compile flags: /Ogtpy
;	COMDAT ?IsFreePillageMoves@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFreePillageMoves@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsFreePillageMoves, COMDAT
; _this$ = ecx

; 1452 : 	return m_bFreePillageMoves;

	mov	al, BYTE PTR [ecx+825]

; 1453 : }

	ret	0
?IsFreePillageMoves@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsFreePillageMoves
_TEXT	ENDS
PUBLIC	?IsHealOnPillage@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsHealOnPillage
; Function compile flags: /Ogtpy
;	COMDAT ?IsHealOnPillage@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsHealOnPillage@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsHealOnPillage, COMDAT
; _this$ = ecx

; 1458 : 	return m_bHealOnPillage;

	mov	al, BYTE PTR [ecx+826]

; 1459 : }

	ret	0
?IsHealOnPillage@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsHealOnPillage
_TEXT	ENDS
PUBLIC	?IsHealIfDefeatExcludeBarbarians@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::IsHealIfDefeatExcludeBarbarians
; Function compile flags: /Ogtpy
;	COMDAT ?IsHealIfDefeatExcludeBarbarians@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsHealIfDefeatExcludeBarbarians@CvPromotionEntry@@QBE_NXZ PROC ; CvPromotionEntry::IsHealIfDefeatExcludeBarbarians, COMDAT
; _this$ = ecx

; 1464 : 	return m_bHealIfDefeatExcludesBarbarians;

	mov	al, BYTE PTR [ecx+827]

; 1465 : }

	ret	0
?IsHealIfDefeatExcludeBarbarians@CvPromotionEntry@@QBE_NXZ ENDP ; CvPromotionEntry::IsHealIfDefeatExcludeBarbarians
_TEXT	ENDS
PUBLIC	?IsEmbarkedAllWater@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsEmbarkedAllWater
; Function compile flags: /Ogtpy
;	COMDAT ?IsEmbarkedAllWater@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsEmbarkedAllWater@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsEmbarkedAllWater, COMDAT
; _this$ = ecx

; 1470 : 	return m_bEmbarkedAllWater;

	mov	al, BYTE PTR [ecx+828]

; 1471 : }

	ret	0
?IsEmbarkedAllWater@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsEmbarkedAllWater
_TEXT	ENDS
PUBLIC	?IsCityAttackOnly@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsCityAttackOnly
; Function compile flags: /Ogtpy
;	COMDAT ?IsCityAttackOnly@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsCityAttackOnly@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsCityAttackOnly, COMDAT
; _this$ = ecx

; 1476 : 	return m_bCityAttackOnly;

	mov	al, BYTE PTR [ecx+829]

; 1477 : }

	ret	0
?IsCityAttackOnly@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsCityAttackOnly
_TEXT	ENDS
PUBLIC	?IsCaptureDefeatedEnemy@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::IsCaptureDefeatedEnemy
; Function compile flags: /Ogtpy
;	COMDAT ?IsCaptureDefeatedEnemy@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsCaptureDefeatedEnemy@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsCaptureDefeatedEnemy, COMDAT
; _this$ = ecx

; 1482 : 	return m_bCaptureDefeatedEnemy;

	mov	al, BYTE PTR [ecx+830]

; 1483 : }

	ret	0
?IsCaptureDefeatedEnemy@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsCaptureDefeatedEnemy
_TEXT	ENDS
PUBLIC	?IsIgnoreGreatGeneralBenefit@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::IsIgnoreGreatGeneralBenefit
; Function compile flags: /Ogtpy
;	COMDAT ?IsIgnoreGreatGeneralBenefit@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsIgnoreGreatGeneralBenefit@CvPromotionEntry@@QBE_NXZ PROC ; CvPromotionEntry::IsIgnoreGreatGeneralBenefit, COMDAT
; _this$ = ecx

; 1488 : 	return m_bIgnoreGreatGeneralBenefit;

	mov	al, BYTE PTR [ecx+831]

; 1489 : }

	ret	0
?IsIgnoreGreatGeneralBenefit@CvPromotionEntry@@QBE_NXZ ENDP ; CvPromotionEntry::IsIgnoreGreatGeneralBenefit
_TEXT	ENDS
PUBLIC	?IsIgnoreZOC@CvPromotionEntry@@QBE_NXZ		; CvPromotionEntry::IsIgnoreZOC
; Function compile flags: /Ogtpy
;	COMDAT ?IsIgnoreZOC@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsIgnoreZOC@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsIgnoreZOC, COMDAT
; _this$ = ecx

; 1494 : 	return m_bIgnoreZOC;

	mov	al, BYTE PTR [ecx+832]

; 1495 : }

	ret	0
?IsIgnoreZOC@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsIgnoreZOC
_TEXT	ENDS
PUBLIC	?IsSapper@CvPromotionEntry@@QBE_NXZ		; CvPromotionEntry::IsSapper
; Function compile flags: /Ogtpy
;	COMDAT ?IsSapper@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsSapper@CvPromotionEntry@@QBE_NXZ PROC		; CvPromotionEntry::IsSapper, COMDAT
; _this$ = ecx

; 1500 : 	return m_bSapper;

	mov	al, BYTE PTR [ecx+835]

; 1501 : }

	ret	0
?IsSapper@CvPromotionEntry@@QBE_NXZ ENDP		; CvPromotionEntry::IsSapper
_TEXT	ENDS
PUBLIC	?GetConvertDomainUnit@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetConvertDomainUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetConvertDomainUnit@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetConvertDomainUnit@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetConvertDomainUnit, COMDAT
; _this$ = ecx

; 1507 : 	return m_iConvertDomainUnit;

	mov	eax, DWORD PTR [ecx+840]

; 1508 : }

	ret	0
?GetConvertDomainUnit@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetConvertDomainUnit
_TEXT	ENDS
PUBLIC	?GetConvertDomain@CvPromotionEntry@@QBEHXZ	; CvPromotionEntry::GetConvertDomain
; Function compile flags: /Ogtpy
;	COMDAT ?GetConvertDomain@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetConvertDomain@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetConvertDomain, COMDAT
; _this$ = ecx

; 1513 : 	return m_iConvertDomain;

	mov	eax, DWORD PTR [ecx+844]

; 1514 : }

	ret	0
?GetConvertDomain@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetConvertDomain
_TEXT	ENDS
PUBLIC	?GetGiveDomain@CvPromotionEntry@@QBEHXZ		; CvPromotionEntry::GetGiveDomain
; Function compile flags: /Ogtpy
;	COMDAT ?GetGiveDomain@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGiveDomain@CvPromotionEntry@@QBEHXZ PROC		; CvPromotionEntry::GetGiveDomain, COMDAT
; _this$ = ecx

; 1519 : 	return m_iGiveDomain;

	mov	eax, DWORD PTR [ecx+836]

; 1520 : }

	ret	0
?GetGiveDomain@CvPromotionEntry@@QBEHXZ ENDP		; CvPromotionEntry::GetGiveDomain
_TEXT	ENDS
PUBLIC	?IsCanHeavyCharge@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsCanHeavyCharge
; Function compile flags: /Ogtpy
;	COMDAT ?IsCanHeavyCharge@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsCanHeavyCharge@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::IsCanHeavyCharge, COMDAT
; _this$ = ecx

; 1525 : 	return m_bCanHeavyCharge;

	mov	al, BYTE PTR [ecx+848]

; 1526 : }

	ret	0
?IsCanHeavyCharge@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::IsCanHeavyCharge
_TEXT	ENDS
PUBLIC	?GetHeavyChargeDownhill@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetHeavyChargeDownhill
; Function compile flags: /Ogtpy
;	COMDAT ?GetHeavyChargeDownhill@CvPromotionEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHeavyChargeDownhill@CvPromotionEntry@@QBEHXZ PROC	; CvPromotionEntry::GetHeavyChargeDownhill, COMDAT
; _this$ = ecx

; 1532 : 	return m_iHeavyChargeDownhill;

	mov	eax, DWORD PTR [ecx+852]

; 1533 : }

	ret	0
?GetHeavyChargeDownhill@CvPromotionEntry@@QBEHXZ ENDP	; CvPromotionEntry::GetHeavyChargeDownhill
_TEXT	ENDS
PUBLIC	?HasPostCombatPromotions@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::HasPostCombatPromotions
; Function compile flags: /Ogtpy
;	COMDAT ?HasPostCombatPromotions@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?HasPostCombatPromotions@CvPromotionEntry@@QBE_NXZ PROC	; CvPromotionEntry::HasPostCombatPromotions, COMDAT
; _this$ = ecx

; 1539 : 	return m_bHasPostCombatPromotions;

	mov	al, BYTE PTR [ecx+833]

; 1540 : }

	ret	0
?HasPostCombatPromotions@CvPromotionEntry@@QBE_NXZ ENDP	; CvPromotionEntry::HasPostCombatPromotions
_TEXT	ENDS
PUBLIC	?ArePostCombatPromotionsExclusive@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::ArePostCombatPromotionsExclusive
; Function compile flags: /Ogtpy
;	COMDAT ?ArePostCombatPromotionsExclusive@CvPromotionEntry@@QBE_NXZ
_TEXT	SEGMENT
?ArePostCombatPromotionsExclusive@CvPromotionEntry@@QBE_NXZ PROC ; CvPromotionEntry::ArePostCombatPromotionsExclusive, COMDAT
; _this$ = ecx

; 1545 : 	return m_bPostCombatPromotionsExclusive;

	mov	al, BYTE PTR [ecx+834]

; 1546 : }

	ret	0
?ArePostCombatPromotionsExclusive@CvPromotionEntry@@QBE_NXZ ENDP ; CvPromotionEntry::ArePostCombatPromotionsExclusive
_TEXT	ENDS
PUBLIC	?GetTerrainAttackPercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetTerrainAttackPercent
EXTRN	?getNumTerrainInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumTerrainInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?GetTerrainAttackPercent@CvPromotionEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetTerrainAttackPercent@CvPromotionEntry@@QBEHH@Z PROC	; CvPromotionEntry::GetTerrainAttackPercent, COMDAT
; _this$ = ecx

; 1571 : {

	push	esi

; 1572 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 1573 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1574 : 
; 1575 : 	if(i > -1 && i < GC.getNumTerrainInfos() && m_piTerrainAttackPercent)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetTerrain
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetTerrain
	mov	eax, DWORD PTR [edi+884]
	test	eax, eax
	je	SHORT $LN1@GetTerrain

; 1576 : #endif
; 1577 : 	{
; 1578 : 		return m_piTerrainAttackPercent[i];

	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 1582 : }

	ret	4
$LN1@GetTerrain:
	pop	edi

; 1579 : 	}
; 1580 : 
; 1581 : 	return -1;

	or	eax, -1
	pop	esi

; 1582 : }

	ret	4
?GetTerrainAttackPercent@CvPromotionEntry@@QBEHH@Z ENDP	; CvPromotionEntry::GetTerrainAttackPercent
_TEXT	ENDS
PUBLIC	?GetTerrainDefensePercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetTerrainDefensePercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetTerrainDefensePercent@CvPromotionEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetTerrainDefensePercent@CvPromotionEntry@@QBEHH@Z PROC ; CvPromotionEntry::GetTerrainDefensePercent, COMDAT
; _this$ = ecx

; 1593 : {

	push	esi

; 1594 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 1595 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1596 : 
; 1597 : 	if(i > -1 && i < GC.getNumTerrainInfos() && m_piTerrainDefensePercent)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetTerrain@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetTerrain@2
	mov	eax, DWORD PTR [edi+888]
	test	eax, eax
	je	SHORT $LN1@GetTerrain@2

; 1598 : #endif
; 1599 : 	{
; 1600 : 		return m_piTerrainDefensePercent[i];

	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 1604 : }

	ret	4
$LN1@GetTerrain@2:
	pop	edi

; 1601 : 	}
; 1602 : 
; 1603 : 	return-1;

	or	eax, -1
	pop	esi

; 1604 : }

	ret	4
?GetTerrainDefensePercent@CvPromotionEntry@@QBEHH@Z ENDP ; CvPromotionEntry::GetTerrainDefensePercent
_TEXT	ENDS
PUBLIC	?GetFeatureAttackPercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetFeatureAttackPercent
EXTRN	?getNumFeatureInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumFeatureInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetFeatureAttackPercent@CvPromotionEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFeatureAttackPercent@CvPromotionEntry@@QBEHH@Z PROC	; CvPromotionEntry::GetFeatureAttackPercent, COMDAT
; _this$ = ecx

; 1615 : {

	push	esi

; 1616 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 1617 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1618 : 
; 1619 : 	if(i > -1 && i < GC.getNumFeatureInfos() && m_piFeatureAttackPercent)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetFeature
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetFeature
	mov	eax, DWORD PTR [edi+892]
	test	eax, eax
	je	SHORT $LN1@GetFeature

; 1620 : #endif
; 1621 : 	{
; 1622 : 		return m_piFeatureAttackPercent[i];

	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 1626 : }

	ret	4
$LN1@GetFeature:
	pop	edi

; 1623 : 	}
; 1624 : 
; 1625 : 	return -1;

	or	eax, -1
	pop	esi

; 1626 : }

	ret	4
?GetFeatureAttackPercent@CvPromotionEntry@@QBEHH@Z ENDP	; CvPromotionEntry::GetFeatureAttackPercent
_TEXT	ENDS
PUBLIC	?GetFeatureDefensePercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetFeatureDefensePercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetFeatureDefensePercent@CvPromotionEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFeatureDefensePercent@CvPromotionEntry@@QBEHH@Z PROC ; CvPromotionEntry::GetFeatureDefensePercent, COMDAT
; _this$ = ecx

; 1637 : {

	push	esi

; 1638 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 1639 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1640 : 
; 1641 : 	if(i > -1 && i < GC.getNumFeatureInfos() && m_piFeatureDefensePercent)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetFeature@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetFeature@2
	mov	eax, DWORD PTR [edi+896]
	test	eax, eax
	je	SHORT $LN1@GetFeature@2

; 1642 : #endif
; 1643 : 	{
; 1644 : 		return m_piFeatureDefensePercent[i];

	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 1648 : }

	ret	4
$LN1@GetFeature@2:
	pop	edi

; 1645 : 	}
; 1646 : 
; 1647 : 	return -1;

	or	eax, -1
	pop	esi

; 1648 : }

	ret	4
?GetFeatureDefensePercent@CvPromotionEntry@@QBEHH@Z ENDP ; CvPromotionEntry::GetFeatureDefensePercent
_TEXT	ENDS
PUBLIC	?GetUnitCombatModifierPercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetUnitCombatModifierPercent
EXTRN	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumUnitCombatClassInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitCombatModifierPercent@CvPromotionEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetUnitCombatModifierPercent@CvPromotionEntry@@QBEHH@Z PROC ; CvPromotionEntry::GetUnitCombatModifierPercent, COMDAT
; _this$ = ecx

; 1659 : {

	push	esi

; 1660 : 	CvAssertMsg(i < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 1661 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1662 : 
; 1663 : 	if(i > -1 && i < GC.getNumUnitCombatClassInfos() && m_piUnitCombatModifierPercent)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetUnitCom
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumUnitCombatClassInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetUnitCom
	mov	eax, DWORD PTR [edi+900]
	test	eax, eax
	je	SHORT $LN1@GetUnitCom

; 1664 : #endif
; 1665 : 	{
; 1666 : 		return m_piUnitCombatModifierPercent[i];

	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 1670 : }

	ret	4
$LN1@GetUnitCom:
	pop	edi

; 1667 : 	}
; 1668 : 
; 1669 : 	return -1;

	or	eax, -1
	pop	esi

; 1670 : }

	ret	4
?GetUnitCombatModifierPercent@CvPromotionEntry@@QBEHH@Z ENDP ; CvPromotionEntry::GetUnitCombatModifierPercent
_TEXT	ENDS
PUBLIC	?GetUnitClassModifierPercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetUnitClassModifierPercent
EXTRN	?getNumUnitClassInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumUnitClassInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitClassModifierPercent@CvPromotionEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetUnitClassModifierPercent@CvPromotionEntry@@QBEHH@Z PROC ; CvPromotionEntry::GetUnitClassModifierPercent, COMDAT
; _this$ = ecx

; 1681 : {

	push	esi

; 1682 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 1683 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1684 : 
; 1685 : 	if(i > -1 && i < GC.getNumUnitClassInfos() && m_piUnitClassModifierPercent)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetUnitCla
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetUnitCla
	mov	eax, DWORD PTR [edi+904]
	test	eax, eax
	je	SHORT $LN1@GetUnitCla

; 1686 : #endif
; 1687 : 	{
; 1688 : 		return m_piUnitClassModifierPercent[i];

	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 1692 : }

	ret	4
$LN1@GetUnitCla:
	pop	edi

; 1689 : 	}
; 1690 : 
; 1691 : 	return -1;

	or	eax, -1
	pop	esi

; 1692 : }

	ret	4
?GetUnitClassModifierPercent@CvPromotionEntry@@QBEHH@Z ENDP ; CvPromotionEntry::GetUnitClassModifierPercent
_TEXT	ENDS
PUBLIC	?GetDomainModifierPercent@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetDomainModifierPercent
; Function compile flags: /Ogtpy
;	COMDAT ?GetDomainModifierPercent@CvPromotionEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetDomainModifierPercent@CvPromotionEntry@@QBEHH@Z PROC ; CvPromotionEntry::GetDomainModifierPercent, COMDAT
; _this$ = ecx

; 1704 : 	CvAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
; 1705 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1706 : 
; 1707 : 	if(i > -1 && i < NUM_DOMAIN_TYPES && m_piDomainModifierPercent)

	mov	edx, DWORD PTR _i$[esp-4]
	cmp	edx, 4
	ja	SHORT $LN1@GetDomainM
	mov	eax, DWORD PTR [ecx+908]
	test	eax, eax
	je	SHORT $LN1@GetDomainM

; 1708 : #endif
; 1709 : 	{
; 1710 : 		return m_piDomainModifierPercent[i];

	mov	eax, DWORD PTR [eax+edx*4]

; 1714 : }

	ret	4
$LN1@GetDomainM:

; 1711 : 	}
; 1712 : 
; 1713 : 	return -1;

	or	eax, -1

; 1714 : }

	ret	4
?GetDomainModifierPercent@CvPromotionEntry@@QBEHH@Z ENDP ; CvPromotionEntry::GetDomainModifierPercent
_TEXT	ENDS
PUBLIC	?GetUnitClassAttackModifier@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetUnitClassAttackModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitClassAttackModifier@CvPromotionEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetUnitClassAttackModifier@CvPromotionEntry@@QBEHH@Z PROC ; CvPromotionEntry::GetUnitClassAttackModifier, COMDAT
; _this$ = ecx

; 1725 : {

	push	esi

; 1726 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 1727 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1728 : 
; 1729 : 	if(i > -1 && i < GC.getNumUnitClassInfos() && m_piUnitClassAttackModifier)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetUnitCla@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetUnitCla@2
	mov	eax, DWORD PTR [edi+912]
	test	eax, eax
	je	SHORT $LN1@GetUnitCla@2

; 1730 : #endif
; 1731 : 	{
; 1732 : 		return m_piUnitClassAttackModifier[i];

	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 1736 : }

	ret	4
$LN1@GetUnitCla@2:
	pop	edi

; 1733 : 	}
; 1734 : 
; 1735 : 	return -1;

	or	eax, -1
	pop	esi

; 1736 : }

	ret	4
?GetUnitClassAttackModifier@CvPromotionEntry@@QBEHH@Z ENDP ; CvPromotionEntry::GetUnitClassAttackModifier
_TEXT	ENDS
PUBLIC	?GetUnitClassDefenseModifier@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetUnitClassDefenseModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitClassDefenseModifier@CvPromotionEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetUnitClassDefenseModifier@CvPromotionEntry@@QBEHH@Z PROC ; CvPromotionEntry::GetUnitClassDefenseModifier, COMDAT
; _this$ = ecx

; 1747 : {

	push	esi

; 1748 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 1749 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1750 : 
; 1751 : 	if(i > -1 && i < GC.getNumUnitClassInfos() && m_piUnitClassDefenseModifier)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetUnitCla@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetUnitCla@3
	mov	eax, DWORD PTR [edi+916]
	test	eax, eax
	je	SHORT $LN1@GetUnitCla@3

; 1752 : #endif
; 1753 : 	{
; 1754 : 		return m_piUnitClassDefenseModifier[i];

	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 1758 : }

	ret	4
$LN1@GetUnitCla@3:
	pop	edi

; 1755 : 	}
; 1756 : 
; 1757 : 	return -1;

	or	eax, -1
	pop	esi

; 1758 : }

	ret	4
?GetUnitClassDefenseModifier@CvPromotionEntry@@QBEHH@Z ENDP ; CvPromotionEntry::GetUnitClassDefenseModifier
_TEXT	ENDS
PUBLIC	?GetFeaturePassableTech@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetFeaturePassableTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetFeaturePassableTech@CvPromotionEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFeaturePassableTech@CvPromotionEntry@@QBEHH@Z PROC	; CvPromotionEntry::GetFeaturePassableTech, COMDAT
; _this$ = ecx

; 1769 : {

	push	esi

; 1770 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 1771 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1772 : 
; 1773 : 	if(i > -1 && i < GC.getNumFeatureInfos() && m_piFeaturePassableTech)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetFeature@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetFeature@3
	mov	eax, DWORD PTR [edi+924]
	test	eax, eax
	je	SHORT $LN1@GetFeature@3

; 1774 : #endif
; 1775 : 	{
; 1776 : 		return m_piFeaturePassableTech[i];

	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 1780 : }

	ret	4
$LN1@GetFeature@3:
	pop	edi

; 1777 : 	}
; 1778 : 
; 1779 : 	return -1;

	or	eax, -1
	pop	esi

; 1780 : }

	ret	4
?GetFeaturePassableTech@CvPromotionEntry@@QBEHH@Z ENDP	; CvPromotionEntry::GetFeaturePassableTech
_TEXT	ENDS
PUBLIC	?GetTerrainDoubleMove@CvPromotionEntry@@QBE_NH@Z ; CvPromotionEntry::GetTerrainDoubleMove
; Function compile flags: /Ogtpy
;	COMDAT ?GetTerrainDoubleMove@CvPromotionEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetTerrainDoubleMove@CvPromotionEntry@@QBE_NH@Z PROC	; CvPromotionEntry::GetTerrainDoubleMove, COMDAT
; _this$ = ecx

; 1791 : {

	push	esi

; 1792 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 1793 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1794 : 
; 1795 : 	if(i > -1 && i < GC.getNumTerrainInfos() && m_pbTerrainDoubleMove)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetTerrain@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetTerrain@3
	mov	eax, DWORD PTR [edi+928]
	test	eax, eax
	je	SHORT $LN1@GetTerrain@3

; 1796 : #endif
; 1797 : 	{
; 1798 : 		return m_pbTerrainDoubleMove[i];

	mov	al, BYTE PTR [eax+esi]
	pop	edi
	pop	esi

; 1802 : }

	ret	4
$LN1@GetTerrain@3:
	pop	edi

; 1799 : 	}
; 1800 : 
; 1801 : 	return false;

	xor	al, al
	pop	esi

; 1802 : }

	ret	4
?GetTerrainDoubleMove@CvPromotionEntry@@QBE_NH@Z ENDP	; CvPromotionEntry::GetTerrainDoubleMove
_TEXT	ENDS
PUBLIC	?GetFeatureDoubleMove@CvPromotionEntry@@QBE_NH@Z ; CvPromotionEntry::GetFeatureDoubleMove
; Function compile flags: /Ogtpy
;	COMDAT ?GetFeatureDoubleMove@CvPromotionEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFeatureDoubleMove@CvPromotionEntry@@QBE_NH@Z PROC	; CvPromotionEntry::GetFeatureDoubleMove, COMDAT
; _this$ = ecx

; 1813 : {

	push	esi

; 1814 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 1815 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1816 : 
; 1817 : 	if(i > -1 && i < GC.getNumFeatureInfos() && m_pbFeatureDoubleMove)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetFeature@4
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetFeature@4
	mov	eax, DWORD PTR [edi+932]
	test	eax, eax
	je	SHORT $LN1@GetFeature@4

; 1818 : #endif
; 1819 : 	{
; 1820 : 		return m_pbFeatureDoubleMove[i];

	mov	al, BYTE PTR [eax+esi]
	pop	edi
	pop	esi

; 1824 : }

	ret	4
$LN1@GetFeature@4:
	pop	edi

; 1821 : 	}
; 1822 : 
; 1823 : 	return false;

	xor	al, al
	pop	esi

; 1824 : }

	ret	4
?GetFeatureDoubleMove@CvPromotionEntry@@QBE_NH@Z ENDP	; CvPromotionEntry::GetFeatureDoubleMove
_TEXT	ENDS
PUBLIC	?GetTerrainImpassable@CvPromotionEntry@@QBE_NH@Z ; CvPromotionEntry::GetTerrainImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?GetTerrainImpassable@CvPromotionEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetTerrainImpassable@CvPromotionEntry@@QBE_NH@Z PROC	; CvPromotionEntry::GetTerrainImpassable, COMDAT
; _this$ = ecx

; 1835 : {

	push	esi

; 1836 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 1837 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1838 : 
; 1839 : 	if(i > -1 && i < GC.getNumTerrainInfos() && m_pbTerrainImpassable)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetTerrain@4
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetTerrain@4
	mov	eax, DWORD PTR [edi+936]
	test	eax, eax
	je	SHORT $LN1@GetTerrain@4

; 1840 : #endif
; 1841 : 	{
; 1842 : 		return m_pbTerrainImpassable[i];

	mov	al, BYTE PTR [eax+esi]
	pop	edi
	pop	esi

; 1846 : }

	ret	4
$LN1@GetTerrain@4:
	pop	edi

; 1843 : 	}
; 1844 : 
; 1845 : 	return false;

	xor	al, al
	pop	esi

; 1846 : }

	ret	4
?GetTerrainImpassable@CvPromotionEntry@@QBE_NH@Z ENDP	; CvPromotionEntry::GetTerrainImpassable
_TEXT	ENDS
PUBLIC	?GetTerrainPassableTech@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetTerrainPassableTech
; Function compile flags: /Ogtpy
;	COMDAT ?GetTerrainPassableTech@CvPromotionEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetTerrainPassableTech@CvPromotionEntry@@QBEHH@Z PROC	; CvPromotionEntry::GetTerrainPassableTech, COMDAT
; _this$ = ecx

; 1857 : {

	push	esi

; 1858 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 1859 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1860 : 
; 1861 : 	if(i > -1 && i < GC.getNumTerrainInfos() && m_piTerrainPassableTech)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetTerrain@5
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetTerrain@5
	mov	eax, DWORD PTR [edi+920]
	test	eax, eax
	je	SHORT $LN1@GetTerrain@5

; 1862 : #endif
; 1863 : 	{
; 1864 : 		return m_piTerrainPassableTech[i];

	mov	eax, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi

; 1868 : }

	ret	4
$LN1@GetTerrain@5:
	pop	edi

; 1865 : 	}
; 1866 : 
; 1867 : 	return -1;

	or	eax, -1
	pop	esi

; 1868 : }

	ret	4
?GetTerrainPassableTech@CvPromotionEntry@@QBEHH@Z ENDP	; CvPromotionEntry::GetTerrainPassableTech
_TEXT	ENDS
PUBLIC	?GetFeatureImpassable@CvPromotionEntry@@QBE_NH@Z ; CvPromotionEntry::GetFeatureImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?GetFeatureImpassable@CvPromotionEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFeatureImpassable@CvPromotionEntry@@QBE_NH@Z PROC	; CvPromotionEntry::GetFeatureImpassable, COMDAT
; _this$ = ecx

; 1879 : {

	push	esi

; 1880 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 1881 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1882 : 
; 1883 : 	if(i > -1 && i < GC.getNumFeatureInfos() && m_pbFeatureImpassable)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetFeature@5
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetFeature@5
	mov	eax, DWORD PTR [edi+940]
	test	eax, eax
	je	SHORT $LN1@GetFeature@5

; 1884 : #endif
; 1885 : 	{
; 1886 : 		return m_pbFeatureImpassable[i];

	mov	al, BYTE PTR [eax+esi]
	pop	edi
	pop	esi

; 1890 : }

	ret	4
$LN1@GetFeature@5:
	pop	edi

; 1887 : 	}
; 1888 : 
; 1889 : 	return false;

	xor	al, al
	pop	esi

; 1890 : }

	ret	4
?GetFeatureImpassable@CvPromotionEntry@@QBE_NH@Z ENDP	; CvPromotionEntry::GetFeatureImpassable
_TEXT	ENDS
PUBLIC	?GetUnitCombatClass@CvPromotionEntry@@QBE_NH@Z	; CvPromotionEntry::GetUnitCombatClass
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitCombatClass@CvPromotionEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetUnitCombatClass@CvPromotionEntry@@QBE_NH@Z PROC	; CvPromotionEntry::GetUnitCombatClass, COMDAT
; _this$ = ecx

; 1901 : {

	push	esi

; 1902 : 	CvAssertMsg(i < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 1903 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1904 : 
; 1905 : 	if(i > -1 && i < GC.getNumUnitCombatClassInfos() && m_pbUnitCombat)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetUnitCom@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumUnitCombatClassInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetUnitCom@2
	mov	eax, DWORD PTR [edi+944]
	test	eax, eax
	je	SHORT $LN1@GetUnitCom@2

; 1906 : #endif
; 1907 : 	{
; 1908 : 		return m_pbUnitCombat[i];

	mov	al, BYTE PTR [eax+esi]
	pop	edi
	pop	esi

; 1912 : }

	ret	4
$LN1@GetUnitCom@2:
	pop	edi

; 1909 : 	}
; 1910 : 
; 1911 : 	return false;

	xor	al, al
	pop	esi

; 1912 : }

	ret	4
?GetUnitCombatClass@CvPromotionEntry@@QBE_NH@Z ENDP	; CvPromotionEntry::GetUnitCombatClass
_TEXT	ENDS
PUBLIC	?GetCivilianUnitType@CvPromotionEntry@@QBE_NH@Z	; CvPromotionEntry::GetCivilianUnitType
EXTRN	?getNumUnitInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumUnitInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetCivilianUnitType@CvPromotionEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetCivilianUnitType@CvPromotionEntry@@QBE_NH@Z PROC	; CvPromotionEntry::GetCivilianUnitType, COMDAT
; _this$ = ecx

; 1923 : {

	push	esi

; 1924 : 	CvAssertMsg(i < GC.getNumUnitInfos(), "Index out of bounds");
; 1925 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1926 : 
; 1927 : 	if(i > -1 && i < GC.getNumUnitInfos() && m_pbCivilianUnitType)

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, -1
	push	edi
	mov	edi, ecx
	jle	SHORT $LN1@GetCivilia
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitInfos
	cmp	esi, eax
	jge	SHORT $LN1@GetCivilia
	mov	eax, DWORD PTR [edi+948]
	test	eax, eax
	je	SHORT $LN1@GetCivilia

; 1928 : #endif
; 1929 : 	{
; 1930 : 		return m_pbCivilianUnitType[i];

	mov	al, BYTE PTR [eax+esi]
	pop	edi
	pop	esi

; 1934 : }

	ret	4
$LN1@GetCivilia:
	pop	edi

; 1931 : 	}
; 1932 : 
; 1933 : 	return false;

	xor	al, al
	pop	esi

; 1934 : }

	ret	4
?GetCivilianUnitType@CvPromotionEntry@@QBE_NH@Z ENDP	; CvPromotionEntry::GetCivilianUnitType
_TEXT	ENDS
PUBLIC	?IsPostCombatRandomPromotion@CvPromotionEntry@@QBE_NH@Z ; CvPromotionEntry::IsPostCombatRandomPromotion
; Function compile flags: /Ogtpy
;	COMDAT ?IsPostCombatRandomPromotion@CvPromotionEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?IsPostCombatRandomPromotion@CvPromotionEntry@@QBE_NH@Z PROC ; CvPromotionEntry::IsPostCombatRandomPromotion, COMDAT
; _this$ = ecx

; 1949 : 	CvAssertMsg(i < GC.getNumPromotionInfos(), "Index out of bounds");
; 1950 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1951 : 	return m_pbPostCombatRandomPromotion ? m_pbPostCombatRandomPromotion[i] : false;

	mov	eax, DWORD PTR [ecx+952]
	test	eax, eax
	je	SHORT $LN3@IsPostComb
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 1952 : #endif
; 1953 : }

	ret	4
$LN3@IsPostComb:

; 1949 : 	CvAssertMsg(i < GC.getNumPromotionInfos(), "Index out of bounds");
; 1950 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1951 : 	return m_pbPostCombatRandomPromotion ? m_pbPostCombatRandomPromotion[i] : false;

	xor	al, al

; 1952 : #endif
; 1953 : }

	ret	4
?IsPostCombatRandomPromotion@CvPromotionEntry@@QBE_NH@Z ENDP ; CvPromotionEntry::IsPostCombatRandomPromotion
_TEXT	ENDS
PUBLIC	?GetPromotionEntries@CvPromotionXMLEntries@@QAEAAV?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@XZ ; CvPromotionXMLEntries::GetPromotionEntries
; Function compile flags: /Ogtpy
;	COMDAT ?GetPromotionEntries@CvPromotionXMLEntries@@QAEAAV?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetPromotionEntries@CvPromotionXMLEntries@@QAEAAV?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@XZ PROC ; CvPromotionXMLEntries::GetPromotionEntries, COMDAT
; _this$ = ecx

; 1972 : {

	mov	eax, ecx

; 1973 : 	return m_paPromotionEntries;
; 1974 : }

	ret	0
?GetPromotionEntries@CvPromotionXMLEntries@@QAEAAV?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@XZ ENDP ; CvPromotionXMLEntries::GetPromotionEntries
_TEXT	ENDS
PUBLIC	?GetUnit@CvUnitPromotions@@QAEPAVCvUnit@@XZ	; CvUnitPromotions::GetUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnit@CvUnitPromotions@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?GetUnit@CvUnitPromotions@@QAEPAVCvUnit@@XZ PROC	; CvUnitPromotions::GetUnit, COMDAT
; _this$ = ecx

; 2086 : 	return m_pUnit;

	mov	eax, DWORD PTR [ecx+12]

; 2087 : }

	ret	0
?GetUnit@CvUnitPromotions@@QAEPAVCvUnit@@XZ ENDP	; CvUnitPromotions::GetUnit
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEIXZ ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAPAVCvPromotionEntry@@I@Z ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAPAVCvPromotionEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAPAVCvPromotionEntry@@I@Z PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAPAVCvPromotionEntry@@I@Z ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvPromotionEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPromotionEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPromotionEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPromotionEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPromotionEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvPromotionEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPromotionEntry@@@std@@QAE@XZ ; std::allocator<CvPromotionEntry *>::allocator<CvPromotionEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPromotionEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvPromotionEntry@@@std@@QAE@XZ PROC	; std::allocator<CvPromotionEntry *>::allocator<CvPromotionEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvPromotionEntry@@@std@@QAE@XZ ENDP	; std::allocator<CvPromotionEntry *>::allocator<CvPromotionEntry *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEABQAVCvPromotionEntry@@XZ ; std::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEABQAVCvPromotionEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEABQAVCvPromotionEntry@@XZ PROC ; std::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEABQAVCvPromotionEntry@@XZ ENDP ; std::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator==
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@KAXXZ ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T220781 = -80						; size = 28
$T220780 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T220781[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T220780[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T220781[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T220780[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T220780[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T220780[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T220780[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T220781[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T220780[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPromotionEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvPromotionEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvPromotionEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPromotionEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPromotionEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvPromotionEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvPromotionEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPromotionEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvPromotionEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvPromotionEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvPromotionEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvPromotionEntry *>::allocator<CvPromotionEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvPromotionEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvPromotionEntry@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvPromotionEntry *>::allocator<CvPromotionEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvPromotionEntry@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvPromotionEntry *>::allocator<CvPromotionEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvPromotionEntry@@@std@@QAEXPAPAVCvPromotionEntry@@I@Z ; std::allocator<CvPromotionEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvPromotionEntry@@@std@@QAEXPAPAVCvPromotionEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvPromotionEntry@@@std@@QAEXPAPAVCvPromotionEntry@@I@Z PROC ; std::allocator<CvPromotionEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvPromotionEntry@@@std@@QAEXPAPAVCvPromotionEntry@@I@Z ENDP ; std::allocator<CvPromotionEntry *>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@PAPAVCvPromotionEntry@@@Z ; std::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@PAPAVCvPromotionEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@PAPAVCvPromotionEntry@@@Z PROC ; std::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@PAPAVCvPromotionEntry@@@Z ENDP ; std::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvPromotionEntry@@@std@@QBEIXZ ; std::allocator<CvPromotionEntry *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvPromotionEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvPromotionEntry@@@std@@QBEIXZ PROC ; std::allocator<CvPromotionEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvPromotionEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvPromotionEntry *>::max_size
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z		; SAFE_DELETE_ARRAY<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z PROC		; SAFE_DELETE_ARRAY<bool>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z ENDP		; SAFE_DELETE_ARRAY<bool>
_TEXT	ENDS
PUBLIC	??$?5VFStringA@@@FDataStream@@QAEAAV0@AAVFStringA@@@Z ; FDataStream::operator>><FStringA>
EXTRN	?Read@FDataStream@@IAEXAAVFStringA@@@Z:PROC	; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5VFStringA@@@FDataStream@@QAEAAV0@AAVFStringA@@@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5VFStringA@@@FDataStream@@QAEAAV0@AAVFStringA@@@Z PROC ; FDataStream::operator>><FStringA>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAVFStringA@@@Z	; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5VFStringA@@@FDataStream@@QAEAAV0@AAVFStringA@@@Z ENDP ; FDataStream::operator>><FStringA>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVCvPromotionEntry@@@std@@YAPAPAVCvPromotionEntry@@IPAPAV1@@Z ; std::_Allocate<CvPromotionEntry *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVCvPromotionEntry@@@std@@YAPAPAVCvPromotionEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T220834 = -12						; size = 12
$T220838 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvPromotionEntry@@@std@@YAPAPAVCvPromotionEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvPromotionEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T220838[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T220834[esp+16]
	mov	DWORD PTR $T220838[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T220834[esp+16]
	push	ecx
	mov	DWORD PTR $T220834[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@PAVCvPromotionEntry@@@std@@YAPAPAVCvPromotionEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvPromotionEntry *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvPromotionEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPromotionEntry@@0@Z ; std::_Iter_random<CvPromotionEntry * *,CvPromotionEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAPAVCvPromotionEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPromotionEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvPromotionEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPromotionEntry@@0@Z PROC ; std::_Iter_random<CvPromotionEntry * *,CvPromotionEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvPromotionEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvPromotionEntry@@0@Z ENDP ; std::_Iter_random<CvPromotionEntry * *,CvPromotionEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvPromotionEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPromotionEntry@@0@Z ; std::_Ptr_cat<CvPromotionEntry * *,CvPromotionEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvPromotionEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPromotionEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvPromotionEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPromotionEntry@@0@Z PROC ; std::_Ptr_cat<CvPromotionEntry * *,CvPromotionEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvPromotionEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvPromotionEntry@@0@Z ENDP ; std::_Ptr_cat<CvPromotionEntry * *,CvPromotionEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvPromotionEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPromotionEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvPromotionEntry * *,CvPromotionEntry * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvPromotionEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPromotionEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvPromotionEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPromotionEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvPromotionEntry * *,CvPromotionEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvPromotionEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvPromotionEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvPromotionEntry * *,CvPromotionEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@YAXPAPAVCvPromotionEntry@@0AAV?$allocator@PAVCvPromotionEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvPromotionEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@YAXPAPAVCvPromotionEntry@@0AAV?$allocator@PAVCvPromotionEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@YAXPAPAVCvPromotionEntry@@0AAV?$allocator@PAVCvPromotionEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPromotionEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@YAXPAPAVCvPromotionEntry@@0AAV?$allocator@PAVCvPromotionEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPromotionEntry *> >
_TEXT	ENDS
PUBLIC	?Compare@FStringA@@QBEHPBD@Z			; FStringA::Compare
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ?Compare@FStringA@@QBEHPBD@Z
_TEXT	SEGMENT
_lpsz$ = 8						; size = 4
?Compare@FStringA@@QBEHPBD@Z PROC			; FStringA::Compare, COMDAT
; _this$ = ecx

; 600  : 	FSTRING_CHECK_BUFFER;
; 601  : 	return ( strcmp( m_pszString, lpsz ) );

	mov	edx, DWORD PTR _lpsz$[esp-4]
	mov	eax, DWORD PTR [ecx]
$LL3@Compare:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN4@Compare
	test	cl, cl
	je	SHORT $LN5@Compare
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN4@Compare
	add	eax, 2
	add	edx, 2
	test	cl, cl
	jne	SHORT $LL3@Compare
$LN5@Compare:
	xor	eax, eax

; 602  : }

	ret	4
$LN4@Compare:

; 600  : 	FSTRING_CHECK_BUFFER;
; 601  : 	return ( strcmp( m_pszString, lpsz ) );

	sbb	eax, eax
	sbb	eax, -1

; 602  : }

	ret	4
?Compare@FStringA@@QBEHPBD@Z ENDP			; FStringA::Compare
_TEXT	ENDS
PUBLIC	?GetCString@FStringA@@QBEPBDXZ			; FStringA::GetCString
; Function compile flags: /Ogtpy
;	COMDAT ?GetCString@FStringA@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@FStringA@@QBEPBDXZ PROC			; FStringA::GetCString, COMDAT
; _this$ = ecx

; 1015 : 	FSTRING_CHECK_BUFFER;
; 1016 : 	return ( m_pszString );

	mov	eax, DWORD PTR [ecx]

; 1017 : }

	ret	0
?GetCString@FStringA@@QBEPBDXZ ENDP			; FStringA::GetCString
_TEXT	ENDS
PUBLIC	?SafeStrlen@FStringA@@SAHPBD@Z			; FStringA::SafeStrlen
; Function compile flags: /Ogtpy
;	COMDAT ?SafeStrlen@FStringA@@SAHPBD@Z
_TEXT	SEGMENT
_lpsz$ = 8						; size = 4
?SafeStrlen@FStringA@@SAHPBD@Z PROC			; FStringA::SafeStrlen, COMDAT

; 1030 : 	return ( lpsz ? ( int )strlen( lpsz ) : 0 );

	mov	eax, DWORD PTR _lpsz$[esp-4]
	test	eax, eax
	je	SHORT $LN3@SafeStrlen
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL5@SafeStrlen:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL5@SafeStrlen
	sub	eax, edx

; 1031 : }

	ret	0
$LN3@SafeStrlen:

; 1030 : 	return ( lpsz ? ( int )strlen( lpsz ) : 0 );

	xor	eax, eax

; 1031 : }

	ret	0
?SafeStrlen@FStringA@@SAHPBD@Z ENDP			; FStringA::SafeStrlen
_TEXT	ENDS
PUBLIC	?StringData@FStringAData@FStringA@@QAEPADXZ	; FStringA::FStringAData::StringData
; Function compile flags: /Ogtpy
;	COMDAT ?StringData@FStringAData@FStringA@@QAEPADXZ
_TEXT	SEGMENT
?StringData@FStringAData@FStringA@@QAEPADXZ PROC	; FStringA::FStringAData::StringData, COMDAT
; _this$ = ecx

; 1067 : 	return ( ( LPSTR )( this + 1 ) );

	lea	eax, DWORD PTR [ecx+12]

; 1068 : }

	ret	0
?StringData@FStringAData@FStringA@@QAEPADXZ ENDP	; FStringA::FStringAData::StringData
_TEXT	ENDS
PUBLIC	?GetData@FStringA@@IBEPAUFStringAData@1@XZ	; FStringA::GetData
; Function compile flags: /Ogtpy
;	COMDAT ?GetData@FStringA@@IBEPAUFStringAData@1@XZ
_TEXT	SEGMENT
?GetData@FStringA@@IBEPAUFStringAData@1@XZ PROC		; FStringA::GetData, COMDAT
; _this$ = ecx

; 1077 : 	assert( m_pszString != NULL );
; 1078 : 
; 1079 : 	return ( ( ( FStringAData* )m_pszString ) - 1 );

	mov	eax, DWORD PTR [ecx]
	sub	eax, 12					; 0000000cH

; 1080 : }

	ret	0
?GetData@FStringA@@IBEPAUFStringAData@1@XZ ENDP		; FStringA::GetData
_TEXT	ENDS
PUBLIC	?Init@FStringA@@IAEXXZ				; FStringA::Init
EXTRN	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ:PROC ; FStringA_GetStringInitData
; Function compile flags: /Ogtpy
;	COMDAT ?Init@FStringA@@IAEXXZ
_TEXT	SEGMENT
?Init@FStringA@@IAEXXZ PROC				; FStringA::Init, COMDAT
; _this$ = ecx

; 1084 : {

	push	esi
	mov	esi, ecx

; 1085 : #ifdef		_NDS
; 1086 : 	static int strEmpty[] = { FIXED, 0 };	// Empty string
; 1087 : 
; 1088 : 	m_pszString = (LPSTR)&strEmpty[1];
; 1089 : #else	//	_NDS
; 1090 : 	m_pszString = FStringA_GetStringInitData()->StringData();

	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [esi], eax
	pop	esi

; 1091 : #endif	//	_NDS
; 1092 : }

	ret	0
?Init@FStringA@@IAEXXZ ENDP				; FStringA::Init
_TEXT	ENDS
PUBLIC	?Release@FStringA@@IAEXPAUFStringAData@1@@Z	; FStringA::Release
; Function compile flags: /Ogtpy
;	COMDAT ?Release@FStringA@@IAEXPAUFStringAData@1@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Release@FStringA@@IAEXPAUFStringAData@1@@Z PROC	; FStringA::Release, COMDAT
; _this$ = ecx

; 1105 : {

	push	esi

; 1106 : 	FSTRING_CHECK_BUFFER;
; 1107 : 	if ( pkData && ( pkData != FStringA_GetStringInitData() ) && !pkData->m_bFixed )

	mov	esi, DWORD PTR _pkData$[esp]
	test	esi, esi
	je	SHORT $LN1@Release
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN1@Release
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN1@Release

; 1108 : 	{
; 1109 : #ifdef		ENABLE_FSTRING_STATS
; 1110 : 		extern uint g_uiFStringBytesCurrent;
; 1111 : 		g_uiFStringBytesCurrent -= sizeof ( FStringAData ) + ( sizeof ( char ) * pkData->m_iAllocLength + 1 );
; 1112 : #endif	//	ENABLE_FSTRING_STATS
; 1113 : 
; 1114 : 		// Free any memory associated with the string
; 1115 : 		delete [] ( byte* )pkData;

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@Release:
	pop	esi

; 1116 : 	}
; 1117 : }

	ret	4
?Release@FStringA@@IAEXPAUFStringAData@1@@Z ENDP	; FStringA::Release
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?GetCString@CvString@@QBEPBDXZ			; CvString::GetCString
; Function compile flags: /Ogtpy
;	COMDAT ?GetCString@CvString@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@CvString@@QBEPBDXZ PROC			; CvString::GetCString, COMDAT
; _this$ = ecx

; 42   : 	const char* GetCString() const 	{ return c_str(); }

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCString@CvString@@QBEPBDXZ ENDP			; CvString::GetCString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	??0CvBitfield@@QAE@XZ				; CvBitfield::CvBitfield
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbitfield.h
;	COMDAT ??0CvBitfield@@QAE@XZ
_TEXT	SEGMENT
??0CvBitfield@@QAE@XZ PROC				; CvBitfield::CvBitfield, COMDAT
; _this$ = ecx

; 18   : 	CvBitfield() : m_pBits(NULL), m_uiByteSize(0) {};

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0CvBitfield@@QAE@XZ ENDP				; CvBitfield::CvBitfield
_TEXT	ENDS
PUBLIC	?GetBit@CvBitfield@@QBE_NI@Z			; CvBitfield::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@CvBitfield@@QBE_NI@Z
_TEXT	SEGMENT
_uiIndex$ = 8						; size = 4
?GetBit@CvBitfield@@QBE_NI@Z PROC			; CvBitfield::GetBit, COMDAT
; _this$ = ecx

; 24   : 	{

	push	esi
	mov	esi, ecx

; 25   : 		uint uiByteIndex = uiIndex >> 3;

	mov	ecx, DWORD PTR _uiIndex$[esp]
	mov	eax, ecx
	shr	eax, 3

; 26   : 		if (uiByteIndex < m_uiByteSize)

	cmp	eax, DWORD PTR [esi]
	jae	SHORT $LN1@GetBit

; 27   : 		{
; 28   : 			return (m_pBits[uiByteIndex] & (1 << (uiIndex&0x7))) != 0;

	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	mov	ecx, DWORD PTR [esi+4]
	mov	al, BYTE PTR [eax+ecx]
	pop	esi
	test	dl, al
	mov	eax, 0
	setne	al

; 31   : 	}

	ret	4
$LN1@GetBit:

; 29   : 		}
; 30   : 		return false;

	xor	al, al
	pop	esi

; 31   : 	}

	ret	4
?GetBit@CvBitfield@@QBE_NI@Z ENDP			; CvBitfield::GetBit
_TEXT	ENDS
PUBLIC	?SetSize@CvBitfield@@QAEXI@Z			; CvBitfield::SetSize
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?SetSize@CvBitfield@@QAEXI@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?SetSize@CvBitfield@@QAEXI@Z PROC			; CvBitfield::SetSize, COMDAT
; _this$ = ecx

; 65   : 		uint uiByteSize = (uiSize >> 3) + ((uiSize&0x07)?1:0);

	mov	eax, DWORD PTR _uiSize$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 7
	mov	ecx, 0
	setne	cl
	shr	eax, 3
	push	edi
	add	ecx, eax
	mov	edi, ecx

; 66   : 		if (uiByteSize == 0)

	jne	SHORT $LN7@SetSize

; 67   : 		{
; 68   : 			delete []m_pBits;

	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	edi

; 69   : 			m_uiByteSize = 0;

	mov	DWORD PTR [esi], 0

; 70   : 			m_pBits = NULL;

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 97   : 				}
; 98   : 	}

	ret	4
$LN7@SetSize:

; 71   : 		}
; 72   : 		else
; 73   : 			if (uiByteSize > m_uiByteSize)

	mov	eax, DWORD PTR [esi]
	push	ebx
	cmp	edi, eax
	jbe	SHORT $LN11@SetSize

; 74   : 			{
; 75   : 				byte* pNewBits = new byte[uiByteSize];

	push	edi
	call	??_U@YAPAXI@Z				; operator new[]

; 76   : 				memset(pNewBits, 0, uiByteSize);

	push	edi
	mov	ebx, eax
	push	0
	push	ebx
	call	_memset

; 77   : 				if (m_uiByteSize)

	mov	eax, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN1@SetSize

; 78   : 				{
; 79   : 					memcpy(pNewBits, m_pBits, m_uiByteSize);

	push	eax
	mov	eax, DWORD PTR [esi+4]
	push	eax
	push	ebx
	call	_memcpy

; 80   : 					delete []m_pBits;

	mov	ecx, DWORD PTR [esi+4]
	push	ecx

; 93   : 						delete []m_pBits;

	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 94   : 					}
; 95   : 					m_pBits = pNewBits;

	mov	DWORD PTR [esi+4], ebx
	pop	ebx

; 96   : 					m_uiByteSize = uiByteSize;

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi

; 97   : 				}
; 98   : 	}

	ret	4
$LN11@SetSize:

; 81   : 				}
; 82   : 				m_pBits = pNewBits;
; 83   : 				m_uiByteSize = uiByteSize;
; 84   : 			}
; 85   : 			else
; 86   : 				if (uiByteSize < m_uiByteSize)

	jae	SHORT $LN10@SetSize

; 87   : 				{
; 88   : 					byte* pNewBits = new byte[uiByteSize];

	push	edi
	call	??_U@YAPAXI@Z				; operator new[]

; 89   : 					memset(pNewBits, 0, uiByteSize);

	push	edi
	mov	ebx, eax
	push	0
	push	ebx
	call	_memset
	add	esp, 16					; 00000010H

; 90   : 					if (m_uiByteSize)

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN1@SetSize

; 91   : 					{
; 92   : 						memcpy(pNewBits, m_pBits, uiByteSize);

	mov	edx, DWORD PTR [esi+4]
	push	edi
	push	edx
	push	ebx
	call	_memcpy

; 93   : 						delete []m_pBits;

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H
$LN1@SetSize:

; 96   : 					m_uiByteSize = uiByteSize;

	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], ebx
$LN10@SetSize:
	pop	ebx
	pop	edi
	pop	esi

; 97   : 				}
; 98   : 	}

	ret	4
?SetSize@CvBitfield@@QAEXI@Z ENDP			; CvBitfield::SetSize
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z
_TEXT	SEGMENT
_pArray$ = 8						; size = 4
_count$ = 12						; size = 4
_iDefault$ = 16						; size = 4
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z PROC	; CvDatabaseUtility::InitializeArray, COMDAT
; _this$ = ecx

; 120  : {

	push	esi

; 121  : 	CvAssertMsg(count > 0, "Initializing array to 0 or less items.");
; 122  : #ifdef AUI_WARNING_FIXES
; 123  : 	delete[] pArray;
; 124  : #endif
; 125  : 	pArray = FNEW(int[count], c_eCiv5GameplayDLL, 0);

	mov	esi, DWORD PTR _count$[esp]
	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 126  : 	if(iDefault == 0)

	mov	edx, DWORD PTR _iDefault$[esp+4]
	mov	ecx, DWORD PTR _pArray$[esp+4]
	add	esp, 4
	mov	DWORD PTR [ecx], eax
	test	edx, edx
	jne	SHORT $LN5@Initialize

; 127  : 	{
; 128  : 		ZeroMemory(pArray, sizeof(int) * count);

	lea	ecx, DWORD PTR [esi*4]
	push	ecx
	push	edx
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
$LN5@Initialize:

; 129  : 	}
; 130  : 	else
; 131  : 	{
; 132  : 		for(size_t i = 0; i < count; ++i)

	xor	eax, eax
	test	esi, esi
	jbe	SHORT $LN1@Initialize
	push	edi
	npad	5
$LL3@Initialize:

; 133  : 			pArray[i] = iDefault;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edi+eax*4], edx
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL3@Initialize
	pop	edi
$LN1@Initialize:
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ENDP	; CvDatabaseUtility::InitializeArray
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z ; CvDatabaseUtility::InitializeArray
EXTRN	__fltused:DWORD
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z
_TEXT	SEGMENT
_pArray$ = 8						; size = 4
_count$ = 12						; size = 4
tv143 = 16						; size = 4
_bDefault$ = 16						; size = 1
?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z PROC ; CvDatabaseUtility::InitializeArray, COMDAT
; _this$ = ecx

; 138  : {

	push	esi

; 139  : 	CvAssertMsg(count > 0, "Initializing array to 0 or less items.");
; 140  : #ifdef AUI_WARNING_FIXES
; 141  : 	delete[] pArray;
; 142  : #endif
; 143  : 	pArray = FNEW(bool[count], c_eCiv5GameplayDLL, 0);

	mov	esi, DWORD PTR _count$[esp]
	push	edi
	push	esi
	call	??_U@YAPAXI@Z				; operator new[]

; 144  : #ifdef AUI_WARNING_FIXES
; 145  : 	if (bDefault == false)
; 146  : #else
; 147  : 	if(bDefault == 0.0f)

	mov	dl, BYTE PTR _bDefault$[esp+8]
	mov	ecx, DWORD PTR _pArray$[esp+8]
	mov	edi, eax
	movzx	eax, dl
	mov	DWORD PTR tv143[esp+8], eax
	add	esp, 4
	mov	DWORD PTR [ecx], edi
	fild	DWORD PTR tv143[esp+4]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@Initialize@2

; 148  : #endif
; 149  : 	{
; 150  : 		ZeroMemory(pArray, sizeof(bool) * count);

	push	esi
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 156  : 	}
; 157  : }

	ret	12					; 0000000cH
$LN5@Initialize@2:

; 151  : 	}
; 152  : 	else
; 153  : 	{
; 154  : 		for(size_t i = 0; i < count; ++i)

	xor	eax, eax
	test	esi, esi
	jbe	SHORT $LN1@Initialize@2
$LL3@Initialize@2:

; 155  : 			pArray[i] = bDefault;

	mov	edi, DWORD PTR [ecx]
	mov	BYTE PTR [eax+edi], dl
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL3@Initialize@2
$LN1@Initialize@2:
	pop	edi
	pop	esi

; 156  : 	}
; 157  : }

	ret	12					; 0000000cH
?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z ENDP ; CvDatabaseUtility::InitializeArray
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T221013 = -80						; size = 28
$T221012 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T221013[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T221012[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T221013[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T221012[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T221012[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T221012[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T221012[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T221013[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T221012[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T221060 = -12						; size = 12
$T221064 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T221064[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T221060[esp+16]
	mov	DWORD PTR $T221064[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T221060[esp+16]
	push	ecx
	mov	DWORD PTR $T221060[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	?GetSound@CvPromotionEntry@@QBEPBDXZ		; CvPromotionEntry::GetSound
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpromotionclasses.cpp
;	COMDAT ?GetSound@CvPromotionEntry@@QBEPBDXZ
_TEXT	SEGMENT
?GetSound@CvPromotionEntry@@QBEPBDXZ PROC		; CvPromotionEntry::GetSound, COMDAT
; _this$ = ecx

; 1551 : 	return m_strSound;

	add	ecx, 856				; 00000358H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetSound@CvPromotionEntry@@QBEPBDXZ ENDP		; CvPromotionEntry::GetSound
_TEXT	ENDS
PUBLIC	?SetSound@CvPromotionEntry@@QAEXPBD@Z		; CvPromotionEntry::SetSound
; Function compile flags: /Ogtpy
;	COMDAT ?SetSound@CvPromotionEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?SetSound@CvPromotionEntry@@QAEXPBD@Z PROC		; CvPromotionEntry::SetSound, COMDAT
; _this$ = ecx

; 1557 : 	m_strSound = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 856				; 00000358H
	test	eax, eax
	je	SHORT $LN4@SetSound
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@SetSound:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 1558 : }

	ret	4
?SetSound@CvPromotionEntry@@QAEXPBD@Z ENDP		; CvPromotionEntry::SetSound
_TEXT	ENDS
PUBLIC	?GetNumPromotions@CvPromotionXMLEntries@@QAEHXZ	; CvPromotionXMLEntries::GetNumPromotions
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumPromotions@CvPromotionXMLEntries@@QAEHXZ
_TEXT	SEGMENT
?GetNumPromotions@CvPromotionXMLEntries@@QAEHXZ PROC	; CvPromotionXMLEntries::GetNumPromotions, COMDAT
; _this$ = ecx

; 1983 : 	return m_paPromotionEntries.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1984 : }

	ret	0
?GetNumPromotions@CvPromotionXMLEntries@@QAEHXZ ENDP	; CvPromotionXMLEntries::GetNumPromotions
_TEXT	ENDS
PUBLIC	?GetEntry@CvPromotionXMLEntries@@QAEPAVCvPromotionEntry@@H@Z ; CvPromotionXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetEntry@CvPromotionXMLEntries@@QAEPAVCvPromotionEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetEntry@CvPromotionXMLEntries@@QAEPAVCvPromotionEntry@@H@Z PROC ; CvPromotionXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 1993 : 	return m_paPromotionEntries[index];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1994 : }

	ret	4
?GetEntry@CvPromotionXMLEntries@@QAEPAVCvPromotionEntry@@H@Z ENDP ; CvPromotionXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	?Uninit@CvUnitPromotions@@QAEXXZ		; CvUnitPromotions::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvUnitPromotions@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvUnitPromotions@@QAEXXZ PROC			; CvUnitPromotions::Uninit, COMDAT
; _this$ = ecx

; 2042 : 	m_kHasPromotion.SetSize(0);

	push	0
	call	?SetSize@CvBitfield@@QAEXI@Z		; CvBitfield::SetSize

; 2043 : }

	ret	0
?Uninit@CvUnitPromotions@@QAEXXZ ENDP			; CvUnitPromotions::Uninit
_TEXT	ENDS
PUBLIC	?Reset@CvUnitPromotions@@QAEXXZ			; CvUnitPromotions::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvUnitPromotions@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvUnitPromotions@@QAEXXZ PROC			; CvUnitPromotions::Reset, COMDAT
; _this$ = ecx

; 2048 : 	m_kHasPromotion.SetSize(0);

	push	0
	call	?SetSize@CvBitfield@@QAEXI@Z		; CvBitfield::SetSize

; 2049 : }

	ret	0
?Reset@CvUnitPromotions@@QAEXXZ ENDP			; CvUnitPromotions::Reset
_TEXT	ENDS
PUBLIC	?HasPromotion@CvUnitPromotions@@QBE_NW4PromotionTypes@@@Z ; CvUnitPromotions::HasPromotion
EXTRN	?getNumPromotionInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPromotionInfos
; Function compile flags: /Ogtpy
;	COMDAT ?HasPromotion@CvUnitPromotions@@QBE_NW4PromotionTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?HasPromotion@CvUnitPromotions@@QBE_NW4PromotionTypes@@@Z PROC ; CvUnitPromotions::HasPromotion, COMDAT
; _this$ = ecx

; 2091 : {

	push	esi

; 2092 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2093 : 	CvAssertMsg(eIndex < GC.getNumPromotionInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2094 : 
; 2095 : #ifdef AUI_WARNING_FIXES
; 2096 : 	if (uint(eIndex) < GC.getNumPromotionInfos())
; 2097 : #else
; 2098 : 	if(eIndex >= 0 && eIndex < GC.getNumPromotionInfos())

	mov	esi, DWORD PTR _eIndex$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jl	SHORT $LN1@HasPromoti
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	cmp	esi, eax
	jge	SHORT $LN1@HasPromoti

; 2099 : #endif
; 2100 : 	{
; 2101 : 		return m_kHasPromotion.GetBit(eIndex);

	mov	eax, esi
	shr	eax, 3
	cmp	eax, DWORD PTR [edi]
	jae	SHORT $LN1@HasPromoti
	mov	ecx, esi
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	mov	ecx, DWORD PTR [edi+4]
	mov	al, BYTE PTR [eax+ecx]
	pop	edi
	test	dl, al
	setne	al
	pop	esi

; 2105 : }

	ret	4
$LN1@HasPromoti:
	pop	edi

; 2102 : 	}
; 2103 : 
; 2104 : 	return false;

	xor	al, al
	pop	esi

; 2105 : }

	ret	4
?HasPromotion@CvUnitPromotions@@QBE_NW4PromotionTypes@@@Z ENDP ; CvUnitPromotions::HasPromotion
_TEXT	ENDS
PUBLIC	?GetAllowFeaturePassable@CvUnitPromotions@@QBE_NW4FeatureTypes@@@Z ; CvUnitPromotions::GetAllowFeaturePassable
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z:PROC ; CvGlobals::getPromotionInfo
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?GetAllowFeaturePassable@CvUnitPromotions@@QBE_NW4FeatureTypes@@@Z
_TEXT	SEGMENT
_teamTechs$ = -8					; size = 4
_iNumPromos$ = -4					; size = 4
_eFeatureType$ = 8					; size = 4
?GetAllowFeaturePassable@CvUnitPromotions@@QBE_NW4FeatureTypes@@@Z PROC ; CvUnitPromotions::GetAllowFeaturePassable, COMDAT
; _this$ = ecx

; 2125 : {

	sub	esp, 8
	push	ebp
	mov	ebp, ecx

; 2126 : 	CvTeamTechs* teamTechs = GET_TEAM(m_pUnit->getTeam()).GetTeamTechs();

	mov	ecx, DWORD PTR [ebp+12]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	DWORD PTR _teamTechs$[esp+12], eax

; 2127 : 	CvAssert(teamTechs);
; 2128 : 	if(!teamTechs) return false;

	test	eax, eax
	jne	SHORT $LN7@GetAllowFe
	xor	al, al
	pop	ebp

; 2153 : }

	add	esp, 8
	ret	4
$LN7@GetAllowFe:
	push	ebx
	push	esi
	push	edi

; 2129 : 
; 2130 : #ifdef AUI_WARNING_FIXES
; 2131 : 	for (uint iLoop = 0; iLoop < GC.getNumPromotionInfos(); iLoop++)
; 2132 : #else
; 2133 : 	int iNumPromos = GC.getNumPromotionInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	mov	ecx, eax

; 2134 : 	for(int iLoop = 0; iLoop < iNumPromos; iLoop++)

	xor	esi, esi
	mov	DWORD PTR _iNumPromos$[esp+24], ecx
	test	ecx, ecx
	jle	SHORT $LN4@GetAllowFe
	mov	ebx, DWORD PTR _eFeatureType$[esp+20]
	npad	1
$LL6@GetAllowFe:

; 2135 : #endif
; 2136 : 	{
; 2137 : 		PromotionTypes ePromotion = (PromotionTypes) iLoop;
; 2138 : 		if(m_kHasPromotion.GetBit(ePromotion))

	mov	eax, esi
	shr	eax, 3
	cmp	eax, DWORD PTR [ebp]
	jae	SHORT $LN5@GetAllowFe
	mov	ecx, esi
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	mov	ecx, DWORD PTR [ebp+4]
	mov	al, BYTE PTR [eax+ecx]
	test	dl, al
	setne	al
	test	al, al
	je	SHORT $LN21@GetAllowFe

; 2139 : 		{
; 2140 : 			CvPromotionEntry* promotion = GC.getPromotionInfo(ePromotion);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	mov	edi, eax

; 2141 : 			if(promotion)

	test	edi, edi
	je	SHORT $LN21@GetAllowFe

; 2142 : 			{
; 2143 : 				TechTypes eTech = (TechTypes) promotion->GetFeaturePassableTech(eFeatureType);

	cmp	ebx, -1
	jle	SHORT $LN21@GetAllowFe
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	cmp	ebx, eax
	jge	SHORT $LN21@GetAllowFe
	mov	eax, DWORD PTR [edi+924]
	test	eax, eax
	je	SHORT $LN21@GetAllowFe
	mov	eax, DWORD PTR [eax+ebx*4]

; 2144 : 				if(eTech != NO_TECH && teamTechs->HasTech(eTech))

	cmp	eax, -1
	je	SHORT $LN21@GetAllowFe
	mov	ecx, DWORD PTR _teamTechs$[esp+24]
	push	eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	jne	SHORT $LN19@GetAllowFe
$LN21@GetAllowFe:
	mov	ecx, DWORD PTR _iNumPromos$[esp+24]
$LN5@GetAllowFe:

; 2134 : 	for(int iLoop = 0; iLoop < iNumPromos; iLoop++)

	inc	esi
	cmp	esi, ecx
	jl	SHORT $LL6@GetAllowFe
$LN4@GetAllowFe:
	pop	edi
	pop	esi
	pop	ebx

; 2147 : 				}
; 2148 : 			}
; 2149 : 		}
; 2150 : 	}
; 2151 : 
; 2152 : 	return false;

	xor	al, al
	pop	ebp

; 2153 : }

	add	esp, 8
	ret	4
$LN19@GetAllowFe:
	pop	edi
	pop	esi
	pop	ebx

; 2145 : 				{
; 2146 : 					return true;

	mov	al, 1
	pop	ebp

; 2153 : }

	add	esp, 8
	ret	4
?GetAllowFeaturePassable@CvUnitPromotions@@QBE_NW4FeatureTypes@@@Z ENDP ; CvUnitPromotions::GetAllowFeaturePassable
_TEXT	ENDS
PUBLIC	?GetAllowTerrainPassable@CvUnitPromotions@@QBE_NW4TerrainTypes@@@Z ; CvUnitPromotions::GetAllowTerrainPassable
; Function compile flags: /Ogtpy
;	COMDAT ?GetAllowTerrainPassable@CvUnitPromotions@@QBE_NW4TerrainTypes@@@Z
_TEXT	SEGMENT
_teamTechs$ = -8					; size = 4
_iNumPromos$ = -4					; size = 4
_eTerrainType$ = 8					; size = 4
?GetAllowTerrainPassable@CvUnitPromotions@@QBE_NW4TerrainTypes@@@Z PROC ; CvUnitPromotions::GetAllowTerrainPassable, COMDAT
; _this$ = ecx

; 2157 : {

	sub	esp, 8
	push	ebp
	mov	ebp, ecx

; 2158 : 	CvTeamTechs* teamTechs = GET_TEAM(m_pUnit->getTeam()).GetTeamTechs();

	mov	ecx, DWORD PTR [ebp+12]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	DWORD PTR _teamTechs$[esp+12], eax

; 2159 : 	CvAssert(teamTechs);
; 2160 : 	if(!teamTechs) return false;

	test	eax, eax
	jne	SHORT $LN7@GetAllowTe
	xor	al, al
	pop	ebp

; 2185 : }

	add	esp, 8
	ret	4
$LN7@GetAllowTe:
	push	ebx
	push	esi
	push	edi

; 2161 : 
; 2162 : #ifdef AUI_WARNING_FIXES
; 2163 : 	for (uint iLoop = 0; iLoop < GC.getNumPromotionInfos(); iLoop++)
; 2164 : #else
; 2165 : 	int iNumPromos = GC.getNumPromotionInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	mov	ecx, eax

; 2166 : 	for(int iLoop = 0; iLoop < iNumPromos; iLoop++)

	xor	esi, esi
	mov	DWORD PTR _iNumPromos$[esp+24], ecx
	test	ecx, ecx
	jle	SHORT $LN4@GetAllowTe
	mov	ebx, DWORD PTR _eTerrainType$[esp+20]
	npad	1
$LL6@GetAllowTe:

; 2167 : #endif
; 2168 : 	{
; 2169 : 		PromotionTypes ePromotion = (PromotionTypes) iLoop;
; 2170 : 		if(m_kHasPromotion.GetBit(ePromotion))

	mov	eax, esi
	shr	eax, 3
	cmp	eax, DWORD PTR [ebp]
	jae	SHORT $LN5@GetAllowTe
	mov	ecx, esi
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	mov	ecx, DWORD PTR [ebp+4]
	mov	al, BYTE PTR [eax+ecx]
	test	dl, al
	setne	al
	test	al, al
	je	SHORT $LN21@GetAllowTe

; 2171 : 		{
; 2172 : 			CvPromotionEntry* promotion = GC.getPromotionInfo(ePromotion);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	mov	edi, eax

; 2173 : 
; 2174 : 			if(promotion)

	test	edi, edi
	je	SHORT $LN21@GetAllowTe

; 2175 : 			{
; 2176 : 				TechTypes eTech = (TechTypes) promotion->GetTerrainPassableTech(eTerrainType);

	cmp	ebx, -1
	jle	SHORT $LN21@GetAllowTe
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	cmp	ebx, eax
	jge	SHORT $LN21@GetAllowTe
	mov	eax, DWORD PTR [edi+920]
	test	eax, eax
	je	SHORT $LN21@GetAllowTe
	mov	eax, DWORD PTR [eax+ebx*4]

; 2177 : 				if(eTech != NO_TECH && teamTechs->HasTech(eTech))

	cmp	eax, -1
	je	SHORT $LN21@GetAllowTe
	mov	ecx, DWORD PTR _teamTechs$[esp+24]
	push	eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	test	al, al
	jne	SHORT $LN19@GetAllowTe
$LN21@GetAllowTe:
	mov	ecx, DWORD PTR _iNumPromos$[esp+24]
$LN5@GetAllowTe:

; 2166 : 	for(int iLoop = 0; iLoop < iNumPromos; iLoop++)

	inc	esi
	cmp	esi, ecx
	jl	SHORT $LL6@GetAllowTe
$LN4@GetAllowTe:
	pop	edi
	pop	esi
	pop	ebx

; 2180 : 				}
; 2181 : 			}
; 2182 : 		}
; 2183 : 	}
; 2184 : 	return false;

	xor	al, al
	pop	ebp

; 2185 : }

	add	esp, 8
	ret	4
$LN19@GetAllowTe:
	pop	edi
	pop	esi
	pop	ebx

; 2178 : 				{
; 2179 : 					return true;

	mov	al, 1
	pop	ebp

; 2185 : }

	add	esp, 8
	ret	4
?GetAllowTerrainPassable@CvUnitPromotions@@QBE_NW4TerrainTypes@@@Z ENDP ; CvUnitPromotions::GetAllowTerrainPassable
_TEXT	ENDS
PUBLIC	?GetUnitClassAttackMod@CvUnitPromotions@@QBEHW4UnitClassTypes@@@Z ; CvUnitPromotions::GetUnitClassAttackMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitClassAttackMod@CvUnitPromotions@@QBEHW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_iSum$ = -4						; size = 4
_eUnitClass$ = 8					; size = 4
?GetUnitClassAttackMod@CvUnitPromotions@@QBEHW4UnitClassTypes@@@Z PROC ; CvUnitPromotions::GetUnitClassAttackMod, COMDAT
; _this$ = ecx

; 2189 : {

	push	ecx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 2190 : 	int iSum = 0;

	xor	edi, edi

; 2191 : #ifdef AUI_WARNING_FIXES
; 2192 : 	for (uint iLoop = 0; iLoop < GC.getNumPromotionInfos(); iLoop++)
; 2193 : #else
; 2194 : 	for(int iLoop = 0; iLoop < GC.getNumPromotionInfos(); iLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iSum$[esp+16], edi
	xor	esi, esi
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	test	eax, eax
	jle	$LN18@GetUnitCla@4
	push	ebx
	mov	ebx, DWORD PTR _eUnitClass$[esp+16]
$LL19@GetUnitCla@4:

; 2195 : #endif
; 2196 : 	{
; 2197 : 		PromotionTypes ePromotion = (PromotionTypes)iLoop;
; 2198 : 		CvPromotionEntry* promotion = GC.getPromotionInfo(ePromotion);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	mov	edi, eax

; 2199 : 		if(promotion && HasPromotion(ePromotion))

	test	edi, edi
	je	SHORT $LN3@GetUnitCla@4
	test	esi, esi
	jl	SHORT $LN3@GetUnitCla@4
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	cmp	esi, eax
	jge	SHORT $LN3@GetUnitCla@4
	mov	eax, esi
	shr	eax, 3
	cmp	eax, DWORD PTR [ebp]
	jae	SHORT $LN3@GetUnitCla@4
	mov	ecx, esi
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	mov	ecx, DWORD PTR [ebp+4]
	mov	al, BYTE PTR [eax+ecx]
	test	dl, al
	setne	al
	test	al, al
	je	SHORT $LN3@GetUnitCla@4

; 2200 : 		{
; 2201 : 			iSum += promotion->GetUnitClassAttackModifier(eUnitClass);

	cmp	ebx, -1
	jle	SHORT $LN20@GetUnitCla@4
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	ebx, eax
	jge	SHORT $LN20@GetUnitCla@4
	mov	eax, DWORD PTR [edi+912]
	test	eax, eax
	je	SHORT $LN20@GetUnitCla@4
	mov	eax, DWORD PTR [eax+ebx*4]
	jmp	SHORT $LN14@GetUnitCla@4
$LN20@GetUnitCla@4:
	or	eax, -1
$LN14@GetUnitCla@4:
	add	DWORD PTR _iSum$[esp+20], eax
$LN3@GetUnitCla@4:

; 2191 : #ifdef AUI_WARNING_FIXES
; 2192 : 	for (uint iLoop = 0; iLoop < GC.getNumPromotionInfos(); iLoop++)
; 2193 : #else
; 2194 : 	for(int iLoop = 0; iLoop < GC.getNumPromotionInfos(); iLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	cmp	esi, eax
	jl	SHORT $LL19@GetUnitCla@4

; 2202 : 		}
; 2203 : 	}
; 2204 : 	return iSum;

	mov	eax, DWORD PTR _iSum$[esp+20]
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 2205 : }

	pop	ecx
	ret	4
$LN18@GetUnitCla@4:

; 2202 : 		}
; 2203 : 	}
; 2204 : 	return iSum;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp

; 2205 : }

	pop	ecx
	ret	4
?GetUnitClassAttackMod@CvUnitPromotions@@QBEHW4UnitClassTypes@@@Z ENDP ; CvUnitPromotions::GetUnitClassAttackMod
_TEXT	ENDS
PUBLIC	?GetUnitClassDefenseMod@CvUnitPromotions@@QBEHW4UnitClassTypes@@@Z ; CvUnitPromotions::GetUnitClassDefenseMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitClassDefenseMod@CvUnitPromotions@@QBEHW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_iSum$ = -4						; size = 4
_eUnitClass$ = 8					; size = 4
?GetUnitClassDefenseMod@CvUnitPromotions@@QBEHW4UnitClassTypes@@@Z PROC ; CvUnitPromotions::GetUnitClassDefenseMod, COMDAT
; _this$ = ecx

; 2209 : {

	push	ecx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx

; 2210 : 	int iSum = 0;

	xor	edi, edi

; 2211 : #ifdef AUI_WARNING_FIXES
; 2212 : 	for (uint iLoop = 0; iLoop < GC.getNumPromotionInfos(); iLoop++)
; 2213 : #else
; 2214 : 	for(int iLoop = 0; iLoop < GC.getNumPromotionInfos(); iLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iSum$[esp+16], edi
	xor	esi, esi
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	test	eax, eax
	jle	$LN18@GetUnitCla@5
	push	ebx
	mov	ebx, DWORD PTR _eUnitClass$[esp+16]
$LL19@GetUnitCla@5:

; 2215 : #endif
; 2216 : 	{
; 2217 : 		PromotionTypes ePromotion = (PromotionTypes)iLoop;
; 2218 : 		CvPromotionEntry* promotion = GC.getPromotionInfo(ePromotion);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	mov	edi, eax

; 2219 : 		if(promotion && HasPromotion(ePromotion))

	test	edi, edi
	je	SHORT $LN3@GetUnitCla@5
	test	esi, esi
	jl	SHORT $LN3@GetUnitCla@5
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	cmp	esi, eax
	jge	SHORT $LN3@GetUnitCla@5
	mov	eax, esi
	shr	eax, 3
	cmp	eax, DWORD PTR [ebp]
	jae	SHORT $LN3@GetUnitCla@5
	mov	ecx, esi
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	mov	ecx, DWORD PTR [ebp+4]
	mov	al, BYTE PTR [eax+ecx]
	test	dl, al
	setne	al
	test	al, al
	je	SHORT $LN3@GetUnitCla@5

; 2220 : 		{
; 2221 : 			iSum += promotion->GetUnitClassDefenseModifier(eUnitClass);

	cmp	ebx, -1
	jle	SHORT $LN20@GetUnitCla@5
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	ebx, eax
	jge	SHORT $LN20@GetUnitCla@5
	mov	eax, DWORD PTR [edi+916]
	test	eax, eax
	je	SHORT $LN20@GetUnitCla@5
	mov	eax, DWORD PTR [eax+ebx*4]
	jmp	SHORT $LN14@GetUnitCla@5
$LN20@GetUnitCla@5:
	or	eax, -1
$LN14@GetUnitCla@5:
	add	DWORD PTR _iSum$[esp+20], eax
$LN3@GetUnitCla@5:

; 2211 : #ifdef AUI_WARNING_FIXES
; 2212 : 	for (uint iLoop = 0; iLoop < GC.getNumPromotionInfos(); iLoop++)
; 2213 : #else
; 2214 : 	for(int iLoop = 0; iLoop < GC.getNumPromotionInfos(); iLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	cmp	esi, eax
	jl	SHORT $LL19@GetUnitCla@5

; 2222 : 		}
; 2223 : 	}
; 2224 : 	return iSum;

	mov	eax, DWORD PTR _iSum$[esp+20]
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 2225 : }

	pop	ecx
	ret	4
$LN18@GetUnitCla@5:

; 2222 : 		}
; 2223 : 	}
; 2224 : 	return iSum;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp

; 2225 : }

	pop	ecx
	ret	4
?GetUnitClassDefenseMod@CvUnitPromotions@@QBEHW4UnitClassTypes@@@Z ENDP ; CvUnitPromotions::GetUnitClassDefenseMod
_TEXT	ENDS
PUBLIC	?IsInUseByPlayer@CvUnitPromotions@@AAE_NW4PromotionTypes@@W4PlayerTypes@@@Z ; CvUnitPromotions::IsInUseByPlayer
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?isHasPromotion@CvUnit@@QBE_NW4PromotionTypes@@@Z:PROC ; CvUnit::isHasPromotion
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsInUseByPlayer@CvUnitPromotions@@AAE_NW4PromotionTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iValueLoop$ = 12					; size = 4
_ePlayer$ = 12						; size = 4
?IsInUseByPlayer@CvUnitPromotions@@AAE_NW4PromotionTypes@@W4PlayerTypes@@@Z PROC ; CvUnitPromotions::IsInUseByPlayer, COMDAT
; _this$ = ecx

; 2262 : {

	push	esi

; 2263 : 	bool bRtnValue = false;
; 2264 : 	CvPlayer &kPlayer = GET_PLAYER(ePlayer);

	mov	esi, DWORD PTR _ePlayer$[esp]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi

; 2265 : 
; 2266 : 	CvUnit *pLoopUnit;
; 2267 : 	int iValueLoop;
; 2268 : 	for(pLoopUnit = kPlayer.firstUnit(&iValueLoop); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iValueLoop))

	push	0
	lea	eax, DWORD PTR _iValueLoop$[esp+8]
	push	eax
	mov	ecx, esi
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	test	eax, eax
	je	SHORT $LN2@IsInUseByP
	mov	edi, DWORD PTR _eIndex$[esp+4]
$LL4@IsInUseByP:

; 2269 : 	{
; 2270 : 		if (pLoopUnit->isHasPromotion(eIndex))

	push	edi
	mov	ecx, eax
	call	?isHasPromotion@CvUnit@@QBE_NW4PromotionTypes@@@Z ; CvUnit::isHasPromotion
	test	al, al
	jne	SHORT $LN10@IsInUseByP
	push	0
	lea	ecx, DWORD PTR _iValueLoop$[esp+8]
	push	ecx
	mov	ecx, esi
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	test	eax, eax
	jne	SHORT $LL4@IsInUseByP
$LN2@IsInUseByP:
	pop	edi

; 2273 : 		}
; 2274 : 	}
; 2275 : 
; 2276 : 	return bRtnValue;

	xor	al, al
	pop	esi

; 2277 : }

	ret	8
$LN10@IsInUseByP:
	pop	edi

; 2271 : 		{
; 2272 : 			return true;

	mov	al, 1
	pop	esi

; 2277 : }

	ret	8
?IsInUseByPlayer@CvUnitPromotions@@AAE_NW4PromotionTypes@@W4PlayerTypes@@@Z ENDP ; CvUnitPromotions::IsInUseByPlayer
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEAAPAVCvPromotionEntry@@XZ ; std::_Vector_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEAAPAVCvPromotionEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEAAPAVCvPromotionEntry@@XZ PROC ; std::_Vector_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEAAPAVCvPromotionEntry@@XZ ENDP ; std::_Vector_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::~_Vector_val<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::~_Vector_val<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::~_Vector_val<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPromotionEntry@@@1@@Z ; std::_Vector_val<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Vector_val<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPromotionEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPromotionEntry@@@1@@Z PROC ; std::_Vector_val<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Vector_val<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE@V?$allocator@PAVCvPromotionEntry@@@1@@Z ENDP ; std::_Vector_val<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Vector_val<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@PAPAVCvPromotionEntry@@@Z ; std::_Vector_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Vector_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@PAPAVCvPromotionEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@PAPAVCvPromotionEntry@@@Z PROC ; std::_Vector_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Vector_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@PAPAVCvPromotionEntry@@@Z ENDP ; std::_Vector_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Vector_iterator<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@@Z ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@@Z PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@@Z ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEIXZ ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvPromotionEntry@@@std@@QAEPAPAVCvPromotionEntry@@I@Z ; std::allocator<CvPromotionEntry *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvPromotionEntry@@@std@@QAEPAPAVCvPromotionEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvPromotionEntry@@@std@@QAEPAPAVCvPromotionEntry@@I@Z PROC ; std::allocator<CvPromotionEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvPromotionEntry@@@std@@YAPAPAVCvPromotionEntry@@IPAPAV1@@Z ; std::_Allocate<CvPromotionEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvPromotionEntry@@@std@@QAEPAPAVCvPromotionEntry@@I@Z ENDP ; std::allocator<CvPromotionEntry *>::allocate
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvPromotionEntry@@PAPAV1@@stdext@@YAPAPAVCvPromotionEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvPromotionEntry * *,CvPromotionEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvPromotionEntry@@PAPAV1@@stdext@@YAPAPAVCvPromotionEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvPromotionEntry@@PAPAV1@@stdext@@YAPAPAVCvPromotionEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvPromotionEntry * *,CvPromotionEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvPromotionEntry@@PAPAV1@@stdext@@YAPAPAVCvPromotionEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvPromotionEntry * *,CvPromotionEntry * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@YAXPAPAVCvPromotionEntry@@0AAV?$allocator@PAVCvPromotionEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvPromotionEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@YAXPAPAVCvPromotionEntry@@0AAV?$allocator@PAVCvPromotionEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@YAXPAPAVCvPromotionEntry@@0AAV?$allocator@PAVCvPromotionEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvPromotionEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@YAXPAPAVCvPromotionEntry@@0AAV?$allocator@PAVCvPromotionEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvPromotionEntry *> >
_TEXT	ENDS
PUBLIC	??0FStringA@@QAE@XZ				; FStringA::FStringA
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ??0FStringA@@QAE@XZ
_TEXT	SEGMENT
??0FStringA@@QAE@XZ PROC				; FStringA::FStringA, COMDAT
; _this$ = ecx

; 85   : {

	push	esi
	mov	esi, ecx

; 86   : 	Init();

	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [esi], eax

; 87   : }

	mov	eax, esi
	pop	esi
	ret	0
??0FStringA@@QAE@XZ ENDP				; FStringA::FStringA
_TEXT	ENDS
PUBLIC	??8FStringA@@QBE_NPBD@Z				; FStringA::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8FStringA@@QBE_NPBD@Z
_TEXT	SEGMENT
_s2$ = 8						; size = 4
??8FStringA@@QBE_NPBD@Z PROC				; FStringA::operator==, COMDAT
; _this$ = ecx

; 390  : 	return ( Compare( s2 ) == 0 );

	mov	edx, DWORD PTR _s2$[esp-4]
	mov	eax, DWORD PTR [ecx]
$LL5@operator@2:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN6@operator@2
	test	cl, cl
	je	SHORT $LN7@operator@2
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN6@operator@2
	add	eax, 2
	add	edx, 2
	test	cl, cl
	jne	SHORT $LL5@operator@2
$LN7@operator@2:
	xor	eax, eax
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	mov	al, cl

; 391  : }

	ret	4
$LN6@operator@2:

; 390  : 	return ( Compare( s2 ) == 0 );

	sbb	eax, eax
	sbb	eax, -1
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	mov	al, cl

; 391  : }

	ret	4
??8FStringA@@QBE_NPBD@Z ENDP				; FStringA::operator==
_TEXT	ENDS
PUBLIC	??BFStringA@@QBEPBDXZ				; FStringA::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BFStringA@@QBEPBDXZ
_TEXT	SEGMENT
??BFStringA@@QBEPBDXZ PROC				; FStringA::operator char const *, COMDAT
; _this$ = ecx

; 570  : 	return ( GetCString() );

	mov	eax, DWORD PTR [ecx]

; 571  : }

	ret	0
??BFStringA@@QBEPBDXZ ENDP				; FStringA::operator char const *
_TEXT	ENDS
PUBLIC	?Hash@FStringA@@SAIPBD@Z			; FStringA::Hash
EXTRN	?Calc@FCRC@@QBEKPBXHK@Z:PROC			; FCRC::Calc
EXTRN	?g_CRC32@@3VFCRC@@A:BYTE			; g_CRC32
; Function compile flags: /Ogtpy
;	COMDAT ?Hash@FStringA@@SAIPBD@Z
_TEXT	SEGMENT
_pszStr$ = 8						; size = 4
?Hash@FStringA@@SAIPBD@Z PROC				; FStringA::Hash, COMDAT

; 998  : {

	push	esi

; 999  : 	FAssert(pszStr != NULL);
; 1000 : 	return ( g_CRC32.Calc( ( void* )pszStr, SafeStrlen(pszStr) * sizeof ( char ) ) );

	mov	esi, DWORD PTR _pszStr$[esp]
	test	esi, esi
	je	SHORT $LN5@Hash
	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL7@Hash:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL7@Hash
	push	-1
	sub	eax, edx
	push	eax
	push	esi
	mov	ecx, OFFSET ?g_CRC32@@3VFCRC@@A		; g_CRC32
	call	?Calc@FCRC@@QBEKPBXHK@Z			; FCRC::Calc
	pop	esi

; 1001 : }

	ret	0

; 999  : 	FAssert(pszStr != NULL);
; 1000 : 	return ( g_CRC32.Calc( ( void* )pszStr, SafeStrlen(pszStr) * sizeof ( char ) ) );

$LN5@Hash:
	push	-1
	xor	eax, eax
	push	eax
	push	esi
	mov	ecx, OFFSET ?g_CRC32@@3VFCRC@@A		; g_CRC32
	call	?Calc@FCRC@@QBEKPBXHK@Z			; FCRC::Calc
	pop	esi

; 1001 : }

	ret	0
?Hash@FStringA@@SAIPBD@Z ENDP				; FStringA::Hash
_TEXT	ENDS
PUBLIC	?Release@FStringA@@QAEXXZ			; FStringA::Release
; Function compile flags: /Ogtpy
;	COMDAT ?Release@FStringA@@QAEXXZ
_TEXT	SEGMENT
?Release@FStringA@@QAEXXZ PROC				; FStringA::Release, COMDAT
; _this$ = ecx

; 1096 : {

	push	esi
	push	edi
	mov	edi, ecx

; 1097 : 	Release( GetData() );

	mov	esi, DWORD PTR [edi]
	sub	esi, 12					; 0000000cH
	je	SHORT $LN5@Release@2
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN5@Release@2
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN5@Release@2
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@Release@2:

; 1098 : 	m_pszString = NULL;

	mov	DWORD PTR [edi], 0

; 1099 : 	Init();

	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi

; 1100 : }

	ret	0
?Release@FStringA@@QAEXXZ ENDP				; FStringA::Release
_TEXT	ENDS
PUBLIC	?SetFixedBuffer@FStringA@@QAEXPAUFStringAData@1@@Z ; FStringA::SetFixedBuffer
; Function compile flags: /Ogtpy
;	COMDAT ?SetFixedBuffer@FStringA@@QAEXPAUFStringAData@1@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?SetFixedBuffer@FStringA@@QAEXPAUFStringAData@1@@Z PROC	; FStringA::SetFixedBuffer, COMDAT
; _this$ = ecx

; 1122 : {

	push	ebx

; 1123 : 	assert( pkData != NULL );
; 1124 : 	if(!pkData) return;

	mov	ebx, DWORD PTR _pkData$[esp]
	push	edi
	mov	edi, ecx
	test	ebx, ebx
	je	SHORT $LN2@SetFixedBu
	push	esi

; 1125 : 	assert( pkData->m_bFixed == 1 );
; 1126 : 	assert( pkData->m_iAllocLength > 0 );
; 1127 : 	Release();

	mov	esi, DWORD PTR [edi]
	sub	esi, 12					; 0000000cH
	je	SHORT $LN8@SetFixedBu
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN8@SetFixedBu
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN8@SetFixedBu
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN8@SetFixedBu:
	mov	DWORD PTR [edi], 0
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData

; 1128 : 	m_pszString = pkData->StringData();

	add	ebx, 12					; 0000000cH
	mov	DWORD PTR [edi], ebx
	pop	esi
$LN2@SetFixedBu:
	pop	edi
	pop	ebx

; 1129 : }

	ret	4
?SetFixedBuffer@FStringA@@QAEXPAUFStringAData@1@@Z ENDP	; FStringA::SetFixedBuffer
_TEXT	ENDS
PUBLIC	??1CvBitfield@@QAE@XZ				; CvBitfield::~CvBitfield
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvbitfield.h
;	COMDAT ??1CvBitfield@@QAE@XZ
_TEXT	SEGMENT
??1CvBitfield@@QAE@XZ PROC				; CvBitfield::~CvBitfield, COMDAT
; _this$ = ecx

; 20   : 	~CvBitfield() { SetSize(0); }

	push	0
	call	?SetSize@CvBitfield@@QAEXI@Z		; CvBitfield::SetSize
	ret	0
??1CvBitfield@@QAE@XZ ENDP				; CvBitfield::~CvBitfield
_TEXT	ENDS
PUBLIC	?SetBit@CvBitfield@@QAEXI_N@Z			; CvBitfield::SetBit
; Function compile flags: /Ogtpy
;	COMDAT ?SetBit@CvBitfield@@QAEXI_N@Z
_TEXT	SEGMENT
_uiIndex$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetBit@CvBitfield@@QAEXI_N@Z PROC			; CvBitfield::SetBit, COMDAT
; _this$ = ecx

; 35   : 	{

	push	ebx

; 36   : 		uint uiByteIndex = uiIndex >> 3;

	mov	ebx, DWORD PTR _uiIndex$[esp]
	push	esi
	mov	esi, ebx
	push	edi
	mov	edi, ecx
	shr	esi, 3

; 37   : 		if (uiByteIndex < m_uiByteSize)

	cmp	esi, DWORD PTR [edi]
	jae	SHORT $LN5@SetBit

; 38   : 		{
; 39   : 			if (bValue)
; 40   : 				m_pBits[uiByteIndex] |= (1 << (uiIndex&0x7));

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, ebx
	and	ecx, 7
	mov	dl, 1
	add	eax, esi
	shl	dl, cl
	cmp	BYTE PTR _bValue$[esp+8], 0

; 41   : 			else

	jne	SHORT $LN8@SetBit
	pop	edi

; 42   : 				m_pBits[uiByteIndex] &= ~(1 << (uiIndex&0x7));

	not	dl
	and	BYTE PTR [eax], dl
	pop	esi
	pop	ebx

; 49   : 			}
; 50   : 	}

	ret	8
$LN5@SetBit:

; 43   : 		}
; 44   : 		else
; 45   : 			if (bValue)		// Only resize if setting the value

	cmp	BYTE PTR _bValue$[esp+8], 0
	je	SHORT $LN1@SetBit

; 46   : 			{
; 47   : 				SetSize(uiIndex + 1);

	lea	eax, DWORD PTR [ebx+1]
	push	eax
	call	?SetSize@CvBitfield@@QAEXI@Z		; CvBitfield::SetSize

; 48   : 				m_pBits[uiByteIndex] |= (1 << (uiIndex&0x7));

	mov	ecx, DWORD PTR [edi+4]
	lea	eax, DWORD PTR [ecx+esi]
	mov	ecx, ebx
	and	ecx, 7
	mov	dl, 1
	shl	dl, cl
$LN8@SetBit:
	or	BYTE PTR [eax], dl
$LN1@SetBit:
	pop	edi
	pop	esi
	pop	ebx

; 49   : 			}
; 50   : 	}

	ret	8
?SetBit@CvBitfield@@QAEXI_N@Z ENDP			; CvBitfield::SetBit
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@2
	pop	esi
$LN3@Fill_n@2:

; 3243 : 	}

	ret	0
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??1CvHotKeyInfo@@QAE@XZ				; CvHotKeyInfo::~CvHotKeyInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvHotKeyInfo@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??1CvHotKeyInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvHotKeyInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$5
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvHotKeyInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvHotKeyInfo@@QAE@XZ PROC				; CvHotKeyInfo::~CvHotKeyInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvHotKeyInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+432]
	mov	DWORD PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+404]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+376]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+348]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+320]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+292]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 320				; 00000140H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 348				; 0000015cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 376				; 00000178H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvHotKeyInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvHotKeyInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvHotKeyInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvHotKeyInfo@@QAE@XZ ENDP				; CvHotKeyInfo::~CvHotKeyInfo
PUBLIC	??_7CvPromotionEntry@@6B@			; CvPromotionEntry::`vftable'
PUBLIC	??1CvPromotionEntry@@QAE@XZ			; CvPromotionEntry::~CvPromotionEntry
PUBLIC	??_R4CvPromotionEntry@@6B@			; CvPromotionEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvPromotionEntry@@@8			; CvPromotionEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvPromotionEntry@@8			; CvPromotionEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvPromotionEntry@@8			; CvPromotionEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvPromotionEntry@@8		; CvPromotionEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvHotKeyInfo@@8			; CvHotKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvHotKeyInfo@@@8			; CvHotKeyInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvHotKeyInfo@@8				; CvHotKeyInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvHotKeyInfo@@8				; CvHotKeyInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvPromotionEntry::CacheResults
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_R2CvBaseInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvHotKeyInfo@@8
rdata$r	SEGMENT
??_R2CvHotKeyInfo@@8 DD FLAT:??_R1A@?0A@EA@CvHotKeyInfo@@8 ; CvHotKeyInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvHotKeyInfo@@8
rdata$r	SEGMENT
??_R3CvHotKeyInfo@@8 DD 00H				; CvHotKeyInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvHotKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvHotKeyInfo@@@8
_DATA	SEGMENT
??_R0?AVCvHotKeyInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvHotKeyInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvHotKeyInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvHotKeyInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvHotKeyInfo@@8 DD FLAT:??_R0?AVCvHotKeyInfo@@@8 ; CvHotKeyInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvHotKeyInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvPromotionEntry@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvPromotionEntry@@8 DD FLAT:??_R0?AVCvPromotionEntry@@@8 ; CvPromotionEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvPromotionEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvPromotionEntry@@8
rdata$r	SEGMENT
??_R2CvPromotionEntry@@8 DD FLAT:??_R1A@?0A@EA@CvPromotionEntry@@8 ; CvPromotionEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvHotKeyInfo@@8
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvPromotionEntry@@8
rdata$r	SEGMENT
??_R3CvPromotionEntry@@8 DD 00H				; CvPromotionEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvPromotionEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvPromotionEntry@@@8
_DATA	SEGMENT
??_R0?AVCvPromotionEntry@@@8 DD FLAT:??_7type_info@@6B@	; CvPromotionEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvPromotionEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvPromotionEntry@@6B@
rdata$r	SEGMENT
??_R4CvPromotionEntry@@6B@ DD 00H			; CvPromotionEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvPromotionEntry@@@8
	DD	FLAT:??_R3CvPromotionEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvPromotionEntry@@6B@
CONST	SEGMENT
??_7CvPromotionEntry@@6B@ DD FLAT:??_R4CvPromotionEntry@@6B@ ; CvPromotionEntry::`vftable'
	DD	FLAT:?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvPromotionEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPromotionEntry@@QAE@XZ$0
__ehfuncinfo$??1CvPromotionEntry@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvPromotionEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpromotionclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvPromotionEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPromotionEntry@@QAE@XZ PROC			; CvPromotionEntry::~CvPromotionEntry, COMDAT
; _this$ = ecx

; 187  : {

	push	-1
	push	__ehhandler$??1CvPromotionEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvPromotionEntry@@6B@

; 188  : 	SAFE_DELETE_ARRAY(m_piTerrainAttackPercent);

	mov	eax, DWORD PTR [esi+884]
	xor	edi, edi
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], edi
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+884], edi

; 189  : 	SAFE_DELETE_ARRAY(m_piTerrainDefensePercent);

	mov	eax, DWORD PTR [esi+888]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+888], edi

; 190  : 	SAFE_DELETE_ARRAY(m_piFeatureAttackPercent);

	mov	eax, DWORD PTR [esi+892]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+892], edi

; 191  : 	SAFE_DELETE_ARRAY(m_piFeatureDefensePercent);

	mov	eax, DWORD PTR [esi+896]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+896], edi

; 192  : 	SAFE_DELETE_ARRAY(m_piUnitCombatModifierPercent);

	mov	eax, DWORD PTR [esi+900]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+900], edi

; 193  : 	SAFE_DELETE_ARRAY(m_piUnitClassModifierPercent);

	mov	eax, DWORD PTR [esi+904]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+904], edi

; 194  : 	SAFE_DELETE_ARRAY(m_piDomainModifierPercent);

	mov	eax, DWORD PTR [esi+908]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+908], edi

; 195  : 	SAFE_DELETE_ARRAY(m_piFeaturePassableTech);

	mov	eax, DWORD PTR [esi+924]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+924], edi

; 196  : 	SAFE_DELETE_ARRAY(m_piUnitClassAttackModifier);

	mov	eax, DWORD PTR [esi+912]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+912], edi

; 197  : 	SAFE_DELETE_ARRAY(m_piUnitClassDefenseModifier);

	mov	eax, DWORD PTR [esi+916]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+916], edi

; 198  : 	SAFE_DELETE_ARRAY(m_pbTerrainDoubleMove);

	mov	eax, DWORD PTR [esi+928]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+928], edi

; 199  : 	SAFE_DELETE_ARRAY(m_pbFeatureDoubleMove);

	mov	eax, DWORD PTR [esi+932]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+932], edi

; 200  : 	SAFE_DELETE_ARRAY(m_pbTerrainImpassable);

	mov	eax, DWORD PTR [esi+936]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+936], edi

; 201  : 	SAFE_DELETE_ARRAY(m_piTerrainPassableTech);

	mov	eax, DWORD PTR [esi+920]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+920], edi

; 202  : 	SAFE_DELETE_ARRAY(m_pbFeatureImpassable);

	mov	eax, DWORD PTR [esi+940]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+940], edi

; 203  : 	SAFE_DELETE_ARRAY(m_pbUnitCombat);

	mov	eax, DWORD PTR [esi+944]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+944], edi

; 204  : 	SAFE_DELETE_ARRAY(m_pbCivilianUnitType);

	mov	eax, DWORD PTR [esi+948]
	add	esp, 64					; 00000040H
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+948], edi

; 205  : 	SAFE_DELETE_ARRAY(m_pbPostCombatRandomPromotion);

	mov	eax, DWORD PTR [esi+952]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 8

; 206  : }

	lea	ecx, DWORD PTR [esi+856]
	mov	DWORD PTR [esi+952], edi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1CvHotKeyInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPromotionEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvHotKeyInfo@@QAE@XZ
__ehhandler$??1CvPromotionEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvPromotionEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPromotionEntry@@QAE@XZ ENDP			; CvPromotionEntry::~CvPromotionEntry
EXTRN	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z:PROC ; CvDatabaseUtility::PopulateArrayByExistence
EXTRN	__imp_?Reset@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBD_N@Z:PROC
EXTRN	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; CvDatabaseUtility::PrepareResults
EXTRN	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CvDatabaseUtility::GetResults
EXTRN	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z:PROC	; CvDatabaseUtility::MaxRows
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvHotKeyInfo::CacheResults
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
xdata$x	SEGMENT
__ehfuncinfo$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpromotionclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_iFeatureID$218345 = -88				; size = 4
_iTerrainID$218322 = -88				; size = 4
_iNumUnitCombatClasses$ = -84				; size = 4
_iNumFeatures$ = -80					; size = 4
_iNumUnitClasses$ = -76					; size = 4
_iNumUnitTypes$ = -72					; size = 4
_sqlKey$218402 = -68					; size = 28
_sqlKey$218389 = -68					; size = 28
_sqlKey$218375 = -68					; size = 28
_sqlKey$218357 = -68					; size = 28
_sqlKey$218334 = -68					; size = 28
_sqlKey$218311 = -68					; size = 28
_sqlKey$218414 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_szPromotionType$ = 8					; size = 4
_kResults$ = 8						; size = 4
_iUnitCombatID$218400 = 12				; size = 4
_iDomainID$218386 = 12					; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvPromotionEntry::CacheResults, COMDAT
; _this$ = ecx

; 209  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax

; 210  : 	if(!CvHotKeyInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+92]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvHotKeyInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvHotKeyInfo::CacheResults
	test	al, al
	jne	SHORT $LN30@CacheResul
	pop	edi
	pop	esi

; 652  : 
; 653  : 	return true;
; 654  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	8
$LN30@CacheResul:
	push	ebp

; 211  : 		return false;
; 212  : 
; 213  : 	SetSound(kResults.GetText("Sound"));

	mov	ebp, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG218134
	mov	ecx, edi
	call	ebp
	lea	ecx, DWORD PTR [esi+856]
	test	eax, eax
	je	SHORT $LN43@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN42@CacheResul
$LN43@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN42@CacheResul:
	push	ebx

; 214  : 
; 215  : 	//Basic Properties
; 216  : 	m_bCannotBeChosen = kResults.GetBool("CannotBeChosen");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG218135
	mov	ecx, edi
	call	ebx

; 217  : 	m_bLostWithUpgrade = kResults.GetBool("LostWithUpgrade");

	push	OFFSET $SG218136
	mov	ecx, edi
	mov	BYTE PTR [esi+792], al
	call	ebx

; 218  : 	m_bNotWithUpgrade = kResults.GetBool("NotWithUpgrade");

	push	OFFSET $SG218137
	mov	ecx, edi
	mov	BYTE PTR [esi+793], al
	call	ebx

; 219  : 	m_bInstaHeal = kResults.GetBool("InstaHeal");

	push	OFFSET $SG218138
	mov	ecx, edi
	mov	BYTE PTR [esi+794], al
	call	ebx

; 220  : 	m_bLeader = kResults.GetBool("Leader");

	push	OFFSET $SG218139
	mov	ecx, edi
	mov	BYTE PTR [esi+795], al
	call	ebx

; 221  : 	m_bBlitz = kResults.GetBool("Blitz");

	push	OFFSET $SG218140
	mov	ecx, edi
	mov	BYTE PTR [esi+796], al
	call	ebx

; 222  : 	m_bAmphib = kResults.GetBool("Amphib");

	push	OFFSET $SG218141
	mov	ecx, edi
	mov	BYTE PTR [esi+797], al
	call	ebx

; 223  : 	m_bRiver = kResults.GetBool("River");

	push	OFFSET $SG218142
	mov	ecx, edi
	mov	BYTE PTR [esi+798], al
	call	ebx

; 224  : 	m_bEnemyRoute = kResults.GetBool("EnemyRoute");

	push	OFFSET $SG218143
	mov	ecx, edi
	mov	BYTE PTR [esi+799], al
	call	ebx

; 225  : 	m_bRivalTerritory = kResults.GetBool("RivalTerritory");

	push	OFFSET $SG218144
	mov	ecx, edi
	mov	BYTE PTR [esi+800], al
	call	ebx

; 226  : 	m_bMustSetUpToRangedAttack = kResults.GetBool("MustSetUpToRangedAttack");

	push	OFFSET $SG218145
	mov	ecx, edi
	mov	BYTE PTR [esi+801], al
	call	ebx

; 227  : 	m_bRangedSupportFire= kResults.GetBool("RangedSupportFire");

	push	OFFSET $SG218146
	mov	ecx, edi
	mov	BYTE PTR [esi+802], al
	call	ebx

; 228  : 	m_bAlwaysHeal = kResults.GetBool("AlwaysHeal");

	push	OFFSET $SG218147
	mov	ecx, edi
	mov	BYTE PTR [esi+803], al
	call	ebx

; 229  : 	m_bHealOutsideFriendly = kResults.GetBool("HealOutsideFriendly");

	push	OFFSET $SG218148
	mov	ecx, edi
	mov	BYTE PTR [esi+804], al
	call	ebx

; 230  : 	m_bHillsDoubleMove = kResults.GetBool("HillsDoubleMove");

	push	OFFSET $SG218149
	mov	ecx, edi
	mov	BYTE PTR [esi+805], al
	call	ebx

; 231  : 	m_bIgnoreTerrainCost = kResults.GetBool("IgnoreTerrainCost");

	push	OFFSET $SG218150
	mov	ecx, edi
	mov	BYTE PTR [esi+806], al
	call	ebx

; 232  : 	m_bRoughTerrainEndsTurn = kResults.GetBool("RoughTerrainEndsTurn");

	push	OFFSET $SG218151
	mov	ecx, edi
	mov	BYTE PTR [esi+807], al
	call	ebx

; 233  : 	m_bHoveringUnit = kResults.GetBool("HoveringUnit");

	push	OFFSET $SG218152
	mov	ecx, edi
	mov	BYTE PTR [esi+808], al
	call	ebx

; 234  : 	m_bFlatMovementCost = kResults.GetBool("FlatMovementCost");

	push	OFFSET $SG218153
	mov	ecx, edi
	mov	BYTE PTR [esi+809], al
	call	ebx

; 235  : 	m_bCanMoveImpassable = kResults.GetBool("CanMoveImpassable");

	push	OFFSET $SG218154
	mov	ecx, edi
	mov	BYTE PTR [esi+810], al
	call	ebx

; 236  : 	m_bNoCapture = kResults.GetBool("NoCapture");

	push	OFFSET $SG218155
	mov	ecx, edi
	mov	BYTE PTR [esi+811], al
	call	ebx

; 237  : 	m_bOnlyDefensive = kResults.GetBool("OnlyDefensive");

	push	OFFSET $SG218156
	mov	ecx, edi
	mov	BYTE PTR [esi+812], al
	call	ebx

; 238  : 	m_bNoDefensiveBonus = kResults.GetBool("NoDefensiveBonus");

	push	OFFSET $SG218157
	mov	ecx, edi
	mov	BYTE PTR [esi+813], al
	call	ebx

; 239  : 	m_bNukeImmune = kResults.GetBool("NukeImmune");

	push	OFFSET $SG218158
	mov	ecx, edi
	mov	BYTE PTR [esi+814], al
	call	ebx

; 240  : 	m_bHiddenNationality = kResults.GetBool("HiddenNationality");

	push	OFFSET $SG218159
	mov	ecx, edi
	mov	BYTE PTR [esi+815], al
	call	ebx

; 241  : 	m_bAlwaysHostile = kResults.GetBool("AlwaysHostile");

	push	OFFSET $SG218160
	mov	ecx, edi
	mov	BYTE PTR [esi+816], al
	call	ebx

; 242  : 	m_bNoRevealMap = kResults.GetBool("NoRevealMap");

	push	OFFSET $SG218161
	mov	ecx, edi
	mov	BYTE PTR [esi+817], al
	call	ebx

; 243  : 	m_bRecon = kResults.GetBool("Recon");

	push	OFFSET $SG218162
	mov	ecx, edi
	mov	BYTE PTR [esi+818], al
	call	ebx

; 244  : 	m_bCanMoveAllTerrain = kResults.GetBool("CanMoveAllTerrain");

	push	OFFSET $SG218163
	mov	ecx, edi
	mov	BYTE PTR [esi+819], al
	call	ebx

; 245  : 	m_bCanMoveAfterAttacking = kResults.GetBool("CanMoveAfterAttacking");

	push	OFFSET $SG218164
	mov	ecx, edi
	mov	BYTE PTR [esi+820], al
	call	ebx

; 246  : 	m_bAirSweepCapable = kResults.GetBool("AirSweepCapable");

	push	OFFSET $SG218165
	mov	ecx, edi
	mov	BYTE PTR [esi+821], al
	call	ebx

; 247  : 	m_bAllowsEmbarkation = kResults.GetBool("AllowsEmbarkation");

	push	OFFSET $SG218166
	mov	ecx, edi
	mov	BYTE PTR [esi+822], al
	call	ebx

; 248  : 	m_bRangeAttackIgnoreLOS = kResults.GetBool("RangeAttackIgnoreLOS");

	push	OFFSET $SG218167
	mov	ecx, edi
	mov	BYTE PTR [esi+823], al
	call	ebx

; 249  : 	m_bFreePillageMoves = kResults.GetBool("FreePillageMoves");

	push	OFFSET $SG218168
	mov	ecx, edi
	mov	BYTE PTR [esi+824], al
	call	ebx

; 250  : 	m_bHealOnPillage = kResults.GetBool("HealOnPillage");

	push	OFFSET $SG218169
	mov	ecx, edi
	mov	BYTE PTR [esi+825], al
	call	ebx

; 251  : 	m_bHealIfDefeatExcludesBarbarians = kResults.GetBool("HealIfDestroyExcludesBarbarians");

	push	OFFSET $SG218170
	mov	ecx, edi
	mov	BYTE PTR [esi+826], al
	call	ebx

; 252  : 	m_bEmbarkedAllWater = kResults.GetBool("EmbarkedAllWater");

	push	OFFSET $SG218171
	mov	ecx, edi
	mov	BYTE PTR [esi+827], al
	call	ebx

; 253  : 	m_bCityAttackOnly = kResults.GetBool("CityAttackOnly");

	push	OFFSET $SG218172
	mov	ecx, edi
	mov	BYTE PTR [esi+828], al
	call	ebx

; 254  : 	m_bCaptureDefeatedEnemy = kResults.GetBool("CaptureDefeatedEnemy");

	push	OFFSET $SG218173
	mov	ecx, edi
	mov	BYTE PTR [esi+829], al
	call	ebx

; 255  : 	m_bIgnoreGreatGeneralBenefit = kResults.GetBool("IgnoreGreatGeneralBenefit");

	push	OFFSET $SG218174
	mov	ecx, edi
	mov	BYTE PTR [esi+830], al
	call	ebx
	mov	BYTE PTR [esi+831], al

; 256  : 	m_bIgnoreZOC = kResults.GetBool("IgnoreZOC");

	push	OFFSET $SG218175
	mov	ecx, edi
	call	ebx

; 257  : 	m_bHasPostCombatPromotions = kResults.GetBool("HasPostCombatPromotions");

	push	OFFSET $SG218176
	mov	ecx, edi
	mov	BYTE PTR [esi+832], al
	call	ebx

; 258  : 	m_bPostCombatPromotionsExclusive = kResults.GetBool("PostCombatPromotionsExclusive");

	push	OFFSET $SG218177
	mov	ecx, edi
	mov	BYTE PTR [esi+833], al
	call	ebx

; 259  : 	m_bSapper = kResults.GetBool("Sapper");

	push	OFFSET $SG218178
	mov	ecx, edi
	mov	BYTE PTR [esi+834], al
	call	ebx

; 260  : 
; 261  : 	// CMP
; 262  : 	const char* szGiveDomain = kResults.GetText("GiveDomain");

	push	OFFSET $SG218180
	mov	ecx, edi
	mov	BYTE PTR [esi+835], al
	call	ebp

; 263  : 	m_iGiveDomain = (DomainTypes)GC.getInfoTypeForString(szGiveDomain, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 264  : 	const char* szConvertDomainUnit = kResults.GetText("ConvertDomainUnit");

	push	OFFSET $SG218183
	mov	ecx, edi
	mov	DWORD PTR [esi+836], eax
	call	ebp

; 265  : 	m_iConvertDomainUnit = (UnitTypes)GC.getInfoTypeForString(szConvertDomainUnit, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 266  : 	const char* szConvertDomain = kResults.GetText("ConvertDomain");

	push	OFFSET $SG218186
	mov	ecx, edi
	mov	DWORD PTR [esi+840], eax
	call	ebp

; 267  : 	m_iConvertDomain = (DomainTypes)GC.getInfoTypeForString(szConvertDomain, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 268  : 	//
; 269  : 
; 270  : 	m_bCanHeavyCharge = kResults.GetBool("HeavyCharge");

	push	OFFSET $SG218188
	mov	ecx, edi
	mov	DWORD PTR [esi+844], eax
	call	ebx

; 271  : #ifdef NQ_HEAVY_CHARGE_DOWNHILL
; 272  : 	m_iHeavyChargeDownhill = kResults.GetInt("HeavyChargeDownhill");

	mov	ebp, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG218189
	mov	ecx, edi
	mov	BYTE PTR [esi+848], al
	call	ebp

; 273  : #endif
; 274  : 
; 275  : 	m_iVisibilityChange = kResults.GetInt("VisibilityChange");

	push	OFFSET $SG218190
	mov	ecx, edi
	mov	DWORD PTR [esi+852], eax
	call	ebp

; 276  : 	m_iMovesChange = kResults.GetInt("MovesChange");

	push	OFFSET $SG218191
	mov	ecx, edi
	mov	DWORD PTR [esi+520], eax
	call	ebp

; 277  : 	m_iMoveDiscountChange = kResults.GetInt("MoveDiscountChange");

	push	OFFSET $SG218192
	mov	ecx, edi
	mov	DWORD PTR [esi+524], eax
	call	ebp

; 278  : 	m_iRangeChange = kResults.GetInt("RangeChange");

	push	OFFSET $SG218193
	mov	ecx, edi
	mov	DWORD PTR [esi+528], eax
	call	ebp

; 279  : 	m_iRangedAttackModifier = kResults.GetInt("RangedAttackModifier");

	push	OFFSET $SG218194
	mov	ecx, edi
	mov	DWORD PTR [esi+532], eax
	call	ebp

; 280  : 	m_iInterceptionCombatModifier = kResults.GetInt("InterceptionCombatModifier");

	push	OFFSET $SG218195
	mov	ecx, edi
	mov	DWORD PTR [esi+536], eax
	call	ebp

; 281  : 	m_iInterceptionDefenseDamageModifier = kResults.GetInt("InterceptionDefenseDamageModifier");

	push	OFFSET $SG218196
	mov	ecx, edi
	mov	DWORD PTR [esi+540], eax
	call	ebp

; 282  : 	m_iAirSweepCombatModifier = kResults.GetInt("AirSweepCombatModifier");

	push	OFFSET $SG218197
	mov	ecx, edi
	mov	DWORD PTR [esi+544], eax
	call	ebp
	mov	DWORD PTR [esi+548], eax

; 283  : 	m_iInterceptChanceChange = kResults.GetInt("InterceptChanceChange");

	push	OFFSET $SG218198
	mov	ecx, edi
	call	ebp

; 284  : 	m_iNumInterceptionChange = kResults.GetInt("NumInterceptionChange");

	push	OFFSET $SG218199
	mov	ecx, edi
	mov	DWORD PTR [esi+552], eax
	call	ebp

; 285  : 	m_iEvasionChange = kResults.GetInt("EvasionChange");

	push	OFFSET $SG218200
	mov	ecx, edi
	mov	DWORD PTR [esi+556], eax
	call	ebp

; 286  : 	m_iCargoChange = kResults.GetInt("CargoChange");

	push	OFFSET $SG218201
	mov	ecx, edi
	mov	DWORD PTR [esi+560], eax
	call	ebp

; 287  : 	m_iEnemyHealChange = kResults.GetInt("EnemyHealChange");

	push	OFFSET $SG218202
	mov	ecx, edi
	mov	DWORD PTR [esi+564], eax
	call	ebp

; 288  : 	m_iNeutralHealChange = kResults.GetInt("NeutralHealChange");

	push	OFFSET $SG218203
	mov	ecx, edi
	mov	DWORD PTR [esi+568], eax
	call	ebp

; 289  : 	m_iFriendlyHealChange = kResults.GetInt("FriendlyHealChange");

	push	OFFSET $SG218204
	mov	ecx, edi
	mov	DWORD PTR [esi+572], eax
	call	ebp

; 290  : 	m_iSameTileHealChange = kResults.GetInt("SameTileHealChange");

	push	OFFSET $SG218205
	mov	ecx, edi
	mov	DWORD PTR [esi+576], eax
	call	ebp

; 291  : 	m_iAdjacentTileHealChange = kResults.GetInt("AdjacentTileHealChange");

	push	OFFSET $SG218206
	mov	ecx, edi
	mov	DWORD PTR [esi+580], eax
	call	ebp

; 292  : 	m_iEnemyDamageChance = kResults.GetInt("EnemyDamageChance");

	push	OFFSET $SG218207
	mov	ecx, edi
	mov	DWORD PTR [esi+584], eax
	call	ebp

; 293  : 	m_iNeutralDamageChance = kResults.GetInt("NeutralDamageChance");

	push	OFFSET $SG218208
	mov	ecx, edi
	mov	DWORD PTR [esi+588], eax
	call	ebp

; 294  : 	m_iEnemyDamage = kResults.GetInt("EnemyDamage");

	push	OFFSET $SG218209
	mov	ecx, edi
	mov	DWORD PTR [esi+592], eax
	call	ebp

; 295  : 	m_iNeutralDamage = kResults.GetInt("NeutralDamage");

	push	OFFSET $SG218210
	mov	ecx, edi
	mov	DWORD PTR [esi+596], eax
	call	ebp

; 296  : 	m_iCombatPercent = kResults.GetInt("CombatPercent");

	push	OFFSET $SG218211
	mov	ecx, edi
	mov	DWORD PTR [esi+600], eax
	call	ebp

; 297  : 	m_iCityAttackPercent = kResults.GetInt("CityAttack");

	push	OFFSET $SG218212
	mov	ecx, edi
	mov	DWORD PTR [esi+604], eax
	call	ebp

; 298  : 	m_iCityDefensePercent = kResults.GetInt("CityDefense");

	push	OFFSET $SG218213
	mov	ecx, edi
	mov	DWORD PTR [esi+608], eax
	call	ebp

; 299  : 	m_iRangedDefenseMod = kResults.GetInt("RangedDefenseMod");

	push	OFFSET $SG218214
	mov	ecx, edi
	mov	DWORD PTR [esi+612], eax
	call	ebp

; 300  : 	m_iHillsAttackPercent = kResults.GetInt("HillsAttack");

	push	OFFSET $SG218215
	mov	ecx, edi
	mov	DWORD PTR [esi+616], eax
	call	ebp

; 301  : 	m_iHillsDefensePercent = kResults.GetInt("HillsDefense");

	push	OFFSET $SG218216
	mov	ecx, edi
	mov	DWORD PTR [esi+620], eax
	call	ebp

; 302  : 	m_iOpenAttackPercent = kResults.GetInt("OpenAttack");

	push	OFFSET $SG218217
	mov	ecx, edi
	mov	DWORD PTR [esi+624], eax
	call	ebp
	mov	DWORD PTR [esi+628], eax

; 303  : 	m_iOpenRangedAttackMod = kResults.GetInt("OpenRangedAttackMod");

	push	OFFSET $SG218218
	mov	ecx, edi
	call	ebp

; 304  : 	m_iRoughAttackPercent = kResults.GetInt("RoughAttack");

	push	OFFSET $SG218219
	mov	ecx, edi
	mov	DWORD PTR [esi+632], eax
	call	ebp

; 305  : 	m_iRoughRangedAttackMod = kResults.GetInt("RoughRangedAttackMod");

	push	OFFSET $SG218220
	mov	ecx, edi
	mov	DWORD PTR [esi+636], eax
	call	ebp

; 306  : 	m_iAttackFortifiedMod = kResults.GetInt("AttackFortifiedMod");

	push	OFFSET $SG218221
	mov	ecx, edi
	mov	DWORD PTR [esi+640], eax
	call	ebp

; 307  : 	m_iAttackWoundedMod = kResults.GetInt("AttackWoundedMod");

	push	OFFSET $SG218222
	mov	ecx, edi
	mov	DWORD PTR [esi+644], eax
	call	ebp

; 308  : 	m_iFlankAttackModifier = kResults.GetInt("FlankAttackModifier");

	push	OFFSET $SG218223
	mov	ecx, edi
	mov	DWORD PTR [esi+648], eax
	call	ebp

; 309  : 	m_iNearbyEnemyCombatMod = kResults.GetInt("NearbyEnemyCombatMod");

	push	OFFSET $SG218224
	mov	ecx, edi
	mov	DWORD PTR [esi+652], eax
	call	ebp

; 310  : 	m_iNearbyEnemyCombatRange = kResults.GetInt("NearbyEnemyCombatRange");

	push	OFFSET $SG218225
	mov	ecx, edi
	mov	DWORD PTR [esi+656], eax
	call	ebp

; 311  : 	m_iOpenDefensePercent = kResults.GetInt("OpenDefense");

	push	OFFSET $SG218226
	mov	ecx, edi
	mov	DWORD PTR [esi+660], eax
	call	ebp

; 312  : 	m_iRoughDefensePercent = kResults.GetInt("RoughDefense");

	push	OFFSET $SG218227
	mov	ecx, edi
	mov	DWORD PTR [esi+664], eax
	call	ebp

; 313  : 	m_iExtraAttacks = kResults.GetInt("ExtraAttacks");

	push	OFFSET $SG218228
	mov	ecx, edi
	mov	DWORD PTR [esi+668], eax
	call	ebp

; 314  : 	m_bGreatGeneral = kResults.GetBool("GreatGeneral");

	push	OFFSET $SG218229
	mov	ecx, edi
	mov	DWORD PTR [esi+672], eax
	call	ebx

; 315  : 	m_bGreatAdmiral = kResults.GetBool("GreatAdmiral");

	push	OFFSET $SG218230
	mov	ecx, edi
	mov	BYTE PTR [esi+676], al
	call	ebx

; 316  : 	m_iGreatGeneralModifier = kResults.GetInt("GreatGeneralModifier");

	push	OFFSET $SG218231
	mov	ecx, edi
	mov	BYTE PTR [esi+677], al
	call	ebp

; 317  : 	m_bGreatGeneralReceivesMovement = kResults.GetBool("GreatGeneralReceivesMovement");

	push	OFFSET $SG218232
	mov	ecx, edi
	mov	DWORD PTR [esi+680], eax
	call	ebx

; 318  : 	m_bEmbarkedUnitReceivesMovement = kResults.GetBool("EmbarkedUnitReceivesMovement"); // NQMP GJS - Danish Longship

	push	OFFSET $SG218233
	mov	ecx, edi
	mov	BYTE PTR [esi+684], al
	call	ebx

; 319  : #ifdef NQ_ART_OF_WAR_PROMOTION
; 320  : 	m_iGreatGeneralOnOrAdjacentConfersMovement = kResults.GetInt("GreatGeneralOnOrAdjacentConfersMovement");

	push	OFFSET $SG218234
	mov	ecx, edi
	mov	BYTE PTR [esi+685], al
	call	ebp

; 321  : #endif
; 322  : 	m_iGreatGeneralCombatModifier = kResults.GetInt("GreatGeneralCombatModifier");

	push	OFFSET $SG218235
	mov	ecx, edi
	mov	DWORD PTR [esi+688], eax
	call	ebp

; 323  : 	m_iFriendlyLandsModifier = kResults.GetInt("FriendlyLandsModifier");

	push	OFFSET $SG218236
	mov	ecx, edi
	mov	DWORD PTR [esi+692], eax
	call	ebp

; 324  : 	m_iFriendlyLandsAttackModifier = kResults.GetInt("FriendlyLandsAttackModifier");

	push	OFFSET $SG218237
	mov	ecx, edi
	mov	DWORD PTR [esi+696], eax
	call	ebp
	mov	DWORD PTR [esi+700], eax

; 325  : 	m_iOutsideFriendlyLandsModifier = kResults.GetInt("OutsideFriendlyLandsModifier");

	push	OFFSET $SG218238
	mov	ecx, edi
	call	ebp

; 326  : #ifdef NQ_GOLDEN_AGE_FOREIGN_ATTACK_BONUS
; 327  : 	m_iGoldenAgeForeignAttackBonus = kResults.GetInt("GoldenAgeForeignAttackBonus");

	push	OFFSET $SG218239
	mov	ecx, edi
	mov	DWORD PTR [esi+704], eax
	call	ebp

; 328  : #endif
; 329  : #ifdef NQ_COMBAT_STRENGTH_NEAR_FRIENDLY_MINOR
; 330  : 	m_iCombatStrengthNearFriendlyMinor = kResults.GetInt("CombatStrengthNearFriendlyMinor");

	push	OFFSET $SG218240
	mov	ecx, edi
	mov	DWORD PTR [esi+708], eax
	call	ebp

; 331  : #endif
; 332  : 	m_iUpgradeDiscount = kResults.GetInt("UpgradeDiscount");

	push	OFFSET $SG218241
	mov	ecx, edi
	mov	DWORD PTR [esi+712], eax
	call	ebp

; 333  : 	m_iExperiencePercent = kResults.GetInt("ExperiencePercent");

	push	OFFSET $SG218242
	mov	ecx, edi
	mov	DWORD PTR [esi+720], eax
	call	ebp

; 334  : 	m_iAdjacentMod = kResults.GetInt("AdjacentMod");

	push	OFFSET $SG218243
	mov	ecx, edi
	mov	DWORD PTR [esi+724], eax
	call	ebp

; 335  : 	m_iAttackMod = kResults.GetInt("AttackMod");

	push	OFFSET $SG218244
	mov	ecx, edi
	mov	DWORD PTR [esi+728], eax
	call	ebp

; 336  : 	m_iDefenseMod = kResults.GetInt("DefenseMod");

	push	OFFSET $SG218245
	mov	ecx, edi
	mov	DWORD PTR [esi+732], eax
	call	ebp

; 337  : 	m_iDropRange = kResults.GetInt("DropRange");

	push	OFFSET $SG218246
	mov	ecx, edi
	mov	DWORD PTR [esi+736], eax
	call	ebp

; 338  : 	m_iExtraNavalMoves = kResults.GetInt("ExtraNavalMovement");

	push	OFFSET $SG218247
	mov	ecx, edi
	mov	DWORD PTR [esi+740], eax
	call	ebp

; 339  : 	m_iHPHealedIfDefeatEnemy = kResults.GetInt("HPHealedIfDestroyEnemy");

	push	OFFSET $SG218248
	mov	ecx, edi
	mov	DWORD PTR [esi+744], eax
	call	ebp

; 340  : 	m_iGoldenAgeValueFromKills = kResults.GetInt("GoldenAgeValueFromKills");

	push	OFFSET $SG218249
	mov	ecx, edi
	mov	DWORD PTR [esi+748], eax
	call	ebp

; 341  : 	m_iExtraWithdrawal = kResults.GetInt("ExtraWithdrawal");

	push	OFFSET $SG218250
	mov	ecx, edi
	mov	DWORD PTR [esi+752], eax
	call	ebp

; 342  : 	m_iEmbarkExtraVisibility = kResults.GetInt("EmbarkExtraVisibility");

	push	OFFSET $SG218251
	mov	ecx, edi
	mov	DWORD PTR [esi+756], eax
	call	ebp

; 343  : 	m_iEmbarkDefenseModifier = kResults.GetInt("EmbarkDefenseModifier");

	push	OFFSET $SG218252
	mov	ecx, edi
	mov	DWORD PTR [esi+760], eax
	call	ebp

; 344  : 	m_iCapitalDefenseModifier = kResults.GetInt("CapitalDefenseModifier");

	push	OFFSET $SG218253
	mov	ecx, edi
	mov	DWORD PTR [esi+764], eax
	call	ebp

; 345  : 	m_iCapitalDefenseFalloff = kResults.GetInt("CapitalDefenseFalloff");

	push	OFFSET $SG218254
	mov	ecx, edi
	mov	DWORD PTR [esi+768], eax
	call	ebp

; 346  : 	m_iCityAttackPlunderModifier = kResults.GetInt("CityAttackPlunderModifier");

	push	OFFSET $SG218255
	mov	ecx, edi
	mov	DWORD PTR [esi+772], eax
	call	ebp

; 347  : 	m_iReligiousStrengthLossRivalTerritory = kResults.GetInt("ReligiousStrengthLossRivalTerritory");

	push	OFFSET $SG218256
	mov	ecx, edi
	mov	DWORD PTR [esi+776], eax
	call	ebp

; 348  : 	m_iTradeMissionInfluenceModifier = kResults.GetInt("TradeMissionInfluenceModifier");

	push	OFFSET $SG218257
	mov	ecx, edi
	mov	DWORD PTR [esi+780], eax
	call	ebp

; 349  : 	m_iTradeMissionGoldModifier = kResults.GetInt("TradeMissionGoldModifier");

	push	OFFSET $SG218258
	mov	ecx, edi
	mov	DWORD PTR [esi+784], eax
	call	ebp

; 350  : 
; 351  : 	//References
; 352  : 	const char* szLayerAnimationPath = kResults.GetText("LayerAnimationPath");

	push	OFFSET $SG218260
	mov	ecx, edi
	mov	DWORD PTR [esi+788], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 353  : 	m_iLayerAnimationPath = GC.getInfoTypeForString(szLayerAnimationPath, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 354  : 
; 355  : 	const char* szTechPrereq = kResults.GetText("TechPrereq");

	push	OFFSET $SG218262
	mov	ecx, edi
	mov	DWORD PTR [esi+460], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 356  : 	m_iTechPrereq = GC.getInfoTypeForString(szTechPrereq, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 357  : 
; 358  : 	const char* szInvisible = kResults.GetText("Invisible");

	push	OFFSET $SG218264
	mov	ecx, edi
	mov	DWORD PTR [esi+508], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 359  : 	m_iInvisibleType = GC.getInfoTypeForString(szInvisible, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 360  : 
; 361  : 	const char* szSeeInvisible = kResults.GetText("SeeInvisible");

	push	OFFSET $SG218266
	mov	ecx, edi
	mov	DWORD PTR [esi+512], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 362  : 	m_iSeeInvisibleType = GC.getInfoTypeForString(szSeeInvisible, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 363  : 
; 364  : 	const char* szPromotionPrereq = kResults.GetText("PromotionPrereq");

	push	OFFSET $SG218268
	mov	ecx, edi
	mov	DWORD PTR [esi+516], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 365  : 	m_iPrereqPromotion = GC.getInfoTypeForString(szPromotionPrereq, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 366  : 
; 367  : 	const char* szPromotionPrereqOr1 = kResults.GetText("PromotionPrereqOr1");

	push	OFFSET $SG218270
	mov	ecx, edi
	mov	DWORD PTR [esi+464], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 368  : 	m_iPrereqOrPromotion1 = GC.getInfoTypeForString(szPromotionPrereqOr1, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 369  : 
; 370  : 	const char* szPromotionPrereqOr2 = kResults.GetText("PromotionPrereqOr2");

	push	OFFSET $SG218272
	mov	ecx, edi
	mov	DWORD PTR [esi+468], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 371  : 	m_iPrereqOrPromotion2 = GC.getInfoTypeForString(szPromotionPrereqOr2, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 372  : 
; 373  : 	const char* szPromotionPrereqOr3 = kResults.GetText("PromotionPrereqOr3");

	push	OFFSET $SG218274
	mov	ecx, edi
	mov	DWORD PTR [esi+472], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 374  : 	m_iPrereqOrPromotion3 = GC.getInfoTypeForString(szPromotionPrereqOr3, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 375  : 
; 376  : 	const char* szPromotionPrereqOr4 = kResults.GetText("PromotionPrereqOr4");

	push	OFFSET $SG218276
	mov	ecx, edi
	mov	DWORD PTR [esi+476], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 377  : 	m_iPrereqOrPromotion4 = GC.getInfoTypeForString(szPromotionPrereqOr4, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 378  : 
; 379  : 	const char* szPromotionPrereqOr5 = kResults.GetText("PromotionPrereqOr5");

	push	OFFSET $SG218278
	mov	ecx, edi
	mov	DWORD PTR [esi+480], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 380  : 	m_iPrereqOrPromotion5 = GC.getInfoTypeForString(szPromotionPrereqOr5, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR [esi+484], eax

; 381  : 
; 382  : 	const char* szPromotionPrereqOr6 = kResults.GetText("PromotionPrereqOr6");

	push	OFFSET $SG218280
	mov	ecx, edi
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 383  : 	m_iPrereqOrPromotion6 = GC.getInfoTypeForString(szPromotionPrereqOr6, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 384  : 
; 385  : 	const char* szPromotionPrereqOr7 = kResults.GetText("PromotionPrereqOr7");

	push	OFFSET $SG218282
	mov	ecx, edi
	mov	DWORD PTR [esi+488], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 386  : 	m_iPrereqOrPromotion7 = GC.getInfoTypeForString(szPromotionPrereqOr7, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 387  : 
; 388  : 	const char* szPromotionPrereqOr8 = kResults.GetText("PromotionPrereqOr8");

	push	OFFSET $SG218284
	mov	ecx, edi
	mov	DWORD PTR [esi+492], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 389  : 	m_iPrereqOrPromotion8 = GC.getInfoTypeForString(szPromotionPrereqOr8, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 390  : 
; 391  : 	const char* szPromotionPrereqOr9 = kResults.GetText("PromotionPrereqOr9");

	push	OFFSET $SG218286
	mov	ecx, edi
	mov	DWORD PTR [esi+496], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 392  : 	m_iPrereqOrPromotion9 = GC.getInfoTypeForString(szPromotionPrereqOr9, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 393  : 
; 394  : 	const char* szPromotionPrereqOr10 = kResults.GetText("PromotionPrereqOr9");

	push	OFFSET $SG218288
	mov	ecx, edi
	mov	DWORD PTR [esi+500], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 395  : 	m_iPrereqOrPromotion10 = GC.getInfoTypeForString(szPromotionPrereqOr10, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 396  : 
; 397  : 	//Arrays
; 398  : 	const int iNumUnitClasses = kUtility.MaxRows("UnitClasses");

	mov	ecx, DWORD PTR _kUtility$[esp+100]
	push	OFFSET $SG218290
	mov	DWORD PTR [esi+504], eax
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 399  : 	const int iNumTerrains = GC.getNumTerrainInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iNumUnitClasses$[esp+104], eax
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos

; 400  : 	const int iNumFeatures = GC.getNumFeatureInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	edi, eax
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos

; 401  : 	const int iNumDomains = kUtility.MaxRows("Domains");

	mov	ecx, DWORD PTR _kUtility$[esp+100]
	push	OFFSET $SG218294
	mov	DWORD PTR _iNumFeatures$[esp+108], eax
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 402  : 	DEBUG_VARIABLE(iNumDomains);
; 403  : 	const int iNumUnitCombatClasses = kUtility.MaxRows("UnitCombatInfos");

	mov	ecx, DWORD PTR _kUtility$[esp+100]
	push	OFFSET $SG218297
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 404  : 	const int iNumUnitTypes = kUtility.MaxRows("Units");

	mov	ecx, DWORD PTR _kUtility$[esp+100]
	push	OFFSET $SG218299
	mov	DWORD PTR _iNumUnitCombatClasses$[esp+108], eax
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 405  : 
; 406  : 	const char* szPromotionType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR _iNumUnitTypes$[esp+104], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szPromotionType$[esp+100], eax

; 407  : 
; 408  : 	//UnitPromotions_Terrains
; 409  : 	{
; 410  : 		kUtility.InitializeArray(m_piTerrainAttackPercent, iNumTerrains, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+884], eax
	call	_memset

; 411  : 		kUtility.InitializeArray(m_piTerrainDefensePercent, iNumTerrains, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+888], eax
	call	_memset

; 412  : 		kUtility.InitializeArray(m_piTerrainPassableTech, iNumTerrains, NO_TECH);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+920], eax
	add	esp, 36					; 00000024H
	xor	eax, eax
	test	edi, edi
	jbe	SHORT $LN62@CacheResul
	npad	6
$LL64@CacheResul:
	mov	ecx, DWORD PTR [esi+920]
	mov	DWORD PTR [ecx+eax*4], -1
	inc	eax
	cmp	eax, edi
	jb	SHORT $LL64@CacheResul
$LN62@CacheResul:

; 413  : 		kUtility.InitializeArray(m_pbTerrainDoubleMove, iNumTerrains, false);

	mov	ecx, DWORD PTR _kUtility$[esp+100]
	push	0
	lea	eax, DWORD PTR [esi+928]
	push	edi
	push	eax
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z ; CvDatabaseUtility::InitializeArray

; 414  : 		kUtility.InitializeArray(m_pbTerrainImpassable, iNumTerrains, false);

	push	0
	push	edi
	mov	edi, DWORD PTR _kUtility$[esp+108]
	lea	eax, DWORD PTR [esi+936]
	push	eax
	mov	ecx, edi
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z ; CvDatabaseUtility::InitializeArray

; 415  : 
; 416  : 		std::string sqlKey = "UnitPromotions_Terrains";

	push	OFFSET $SG218312
	lea	ecx, DWORD PTR _sqlKey$218311[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 417  : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	edx, DWORD PTR _sqlKey$218311[esp+104]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+116], 0
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 418  : 		if(pResults == NULL)

	test	edi, edi
	jne	SHORT $LN28@CacheResul

; 419  : 		{
; 420  : 			const char* szSQL = "select Terrains.ID as TerrainID, coalesce(Technologies.ID, -1) as PassableTechID, UnitPromotions_Terrains.* from UnitPromotions_Terrains inner join Terrains on TerrainType = Terrains.Type left join Technologies on PassableTech = Technologies.Type where PromotionType = ?";
; 421  : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	mov	ecx, DWORD PTR _kUtility$[esp+100]
	push	OFFSET $SG218316
	lea	eax, DWORD PTR _sqlKey$218311[esp+108]
	push	eax
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax

; 422  : 		}
; 423  : 
; 424  : 		CvAssert(pResults);
; 425  : 		if(!pResults) return false;

	test	edi, edi
	je	$LN141@CacheResul
$LN28@CacheResul:

; 426  : 
; 427  : 		pResults->Bind(1, szPromotionType);

	mov	ecx, DWORD PTR _szPromotionType$[esp+100]
	push	1
	push	ecx
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 428  : 
; 429  : 		while(pResults->Step())

	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	$LN26@CacheResul
$LL27@CacheResul:

; 430  : 		{
; 431  : 			const int iTerrainID = pResults->GetInt("TerrainID");

	push	OFFSET $SG218323
	mov	ecx, edi
	call	ebp

; 432  : 			CvAssert(iTerrainID > -1 && iTerrainID < iNumTerrains);
; 433  : 
; 434  : 			const int iTerrainAttack = pResults->GetInt("Attack");

	push	OFFSET $SG218325
	mov	ecx, edi
	mov	DWORD PTR _iTerrainID$218322[esp+108], eax
	call	ebp

; 435  : 			m_piTerrainAttackPercent[iTerrainID] = iTerrainAttack;

	mov	edx, DWORD PTR [esi+884]
	mov	ecx, DWORD PTR _iTerrainID$218322[esp+104]
	mov	DWORD PTR [edx+ecx*4], eax

; 436  : 
; 437  : 			const int iTerrainDefense = pResults->GetInt("Defense");

	push	OFFSET $SG218327
	mov	ecx, edi
	call	ebp

; 438  : 			m_piTerrainDefensePercent[iTerrainID] = iTerrainDefense;

	mov	edx, DWORD PTR [esi+888]
	mov	ecx, DWORD PTR _iTerrainID$218322[esp+104]
	mov	DWORD PTR [edx+ecx*4], eax

; 439  : 
; 440  : 			const bool bDoubleMove = pResults->GetBool("DoubleMove");

	push	OFFSET $SG218329
	mov	ecx, edi
	call	ebx

; 441  : 			m_pbTerrainDoubleMove[iTerrainID] = bDoubleMove;

	mov	edx, DWORD PTR [esi+928]
	mov	ecx, DWORD PTR _iTerrainID$218322[esp+104]
	mov	BYTE PTR [ecx+edx], al

; 442  : 
; 443  : 			const bool bImpassable = pResults->GetBool("Impassable");

	push	OFFSET $SG218331
	mov	ecx, edi
	call	ebx

; 444  : 			m_pbTerrainImpassable[iTerrainID] = bImpassable;

	mov	edx, DWORD PTR [esi+936]
	mov	ecx, DWORD PTR _iTerrainID$218322[esp+104]
	mov	BYTE PTR [ecx+edx], al

; 445  : 
; 446  : 			const int iPassableTechID = pResults->GetInt("PassableTechID");

	push	OFFSET $SG218333
	mov	ecx, edi
	call	ebp

; 447  : 			m_piTerrainPassableTech[iTerrainID] = iPassableTechID;

	mov	edx, DWORD PTR [esi+920]
	mov	ecx, DWORD PTR _iTerrainID$218322[esp+104]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	$LL27@CacheResul
$LN26@CacheResul:

; 448  : 		}
; 449  : 	}

	lea	ecx, DWORD PTR _sqlKey$218311[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 450  : 
; 451  : 	//UnitPromotions_Features
; 452  : 	{
; 453  : 		kUtility.InitializeArray(m_piFeatureAttackPercent, iNumFeatures, 0);

	mov	edi, DWORD PTR _iNumFeatures$[esp+104]
	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+892], eax
	call	_memset

; 454  : 		kUtility.InitializeArray(m_piFeatureDefensePercent, iNumFeatures, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+896], eax
	call	_memset

; 455  : 		kUtility.InitializeArray(m_piFeaturePassableTech, iNumFeatures, NO_TECH);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+924], eax
	add	esp, 36					; 00000024H
	xor	eax, eax
	test	edi, edi
	jbe	SHORT $LN83@CacheResul
	npad	11
$LL85@CacheResul:
	mov	ecx, DWORD PTR [esi+924]
	mov	DWORD PTR [ecx+eax*4], -1
	inc	eax
	cmp	eax, edi
	jb	SHORT $LL85@CacheResul
$LN83@CacheResul:

; 456  : 		kUtility.InitializeArray(m_pbFeatureDoubleMove, iNumFeatures, false);

	mov	ecx, DWORD PTR _kUtility$[esp+100]
	push	0
	lea	eax, DWORD PTR [esi+932]
	push	edi
	push	eax
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z ; CvDatabaseUtility::InitializeArray

; 457  : 		kUtility.InitializeArray(m_pbFeatureImpassable, iNumFeatures, false);

	push	0
	push	edi
	mov	edi, DWORD PTR _kUtility$[esp+108]
	lea	eax, DWORD PTR [esi+940]
	push	eax
	mov	ecx, edi
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z ; CvDatabaseUtility::InitializeArray

; 458  : 
; 459  : 		std::string sqlKey = "UnitPromotions_Features";

	push	OFFSET $SG218335
	lea	ecx, DWORD PTR _sqlKey$218334[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 460  : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	edx, DWORD PTR _sqlKey$218334[esp+104]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+116], 1
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 461  : 		if(pResults == NULL)

	test	edi, edi
	jne	SHORT $LN24@CacheResul

; 462  : 		{
; 463  : 			const char* szSQL = "select Features.ID as FeatureID, coalesce(Technologies.ID, -1) as PassableTechID, UnitPromotions_Features.* from UnitPromotions_Features inner join Features on FeatureType = Features.Type left join Technologies on PassableTech = Technologies.Type where PromotionType = ?";
; 464  : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	mov	ecx, DWORD PTR _kUtility$[esp+100]
	push	OFFSET $SG218339
	lea	eax, DWORD PTR _sqlKey$218334[esp+108]
	push	eax
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax

; 465  : 		}
; 466  : 
; 467  : 		CvAssert(pResults);
; 468  : 		if(!pResults) return false;

	test	edi, edi
	je	$LN141@CacheResul
$LN24@CacheResul:

; 469  : 
; 470  : 		pResults->Bind(1, szPromotionType);

	mov	ecx, DWORD PTR _szPromotionType$[esp+100]
	push	1
	push	ecx
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 471  : 
; 472  : 		while(pResults->Step())

	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	$LN22@CacheResul
$LL23@CacheResul:

; 473  : 		{
; 474  : 			const int iFeatureID = pResults->GetInt("FeatureID");

	push	OFFSET $SG218346
	mov	ecx, edi
	call	ebp

; 475  : 			CvAssert(iFeatureID > -1 && iFeatureID < iNumFeatures);
; 476  : 
; 477  : 			const int iFeatureAttack = pResults->GetInt("Attack");

	push	OFFSET $SG218348
	mov	ecx, edi
	mov	DWORD PTR _iFeatureID$218345[esp+108], eax
	call	ebp

; 478  : 			m_piFeatureAttackPercent[iFeatureID] = iFeatureAttack;

	mov	edx, DWORD PTR [esi+892]
	mov	ecx, DWORD PTR _iFeatureID$218345[esp+104]
	mov	DWORD PTR [edx+ecx*4], eax

; 479  : 
; 480  : 			const int iFeatureDefense = pResults->GetInt("Defense");

	push	OFFSET $SG218350
	mov	ecx, edi
	call	ebp

; 481  : 			m_piFeatureDefensePercent[iFeatureID] = iFeatureDefense;

	mov	edx, DWORD PTR [esi+896]
	mov	ecx, DWORD PTR _iFeatureID$218345[esp+104]
	mov	DWORD PTR [edx+ecx*4], eax

; 482  : 
; 483  : 			const bool bDoubleMove = pResults->GetBool("DoubleMove");

	push	OFFSET $SG218352
	mov	ecx, edi
	call	ebx

; 484  : 			m_pbFeatureDoubleMove[iFeatureID] = bDoubleMove;

	mov	edx, DWORD PTR [esi+932]
	mov	ecx, DWORD PTR _iFeatureID$218345[esp+104]
	mov	BYTE PTR [ecx+edx], al

; 485  : 
; 486  : 			const bool bImpassable = pResults->GetBool("Impassable");

	push	OFFSET $SG218354
	mov	ecx, edi
	call	ebx

; 487  : 			m_pbFeatureImpassable[iFeatureID] = bImpassable;

	mov	edx, DWORD PTR [esi+940]
	mov	ecx, DWORD PTR _iFeatureID$218345[esp+104]
	mov	BYTE PTR [ecx+edx], al

; 488  : 
; 489  : 			const int iPassableTech = pResults->GetInt("PassableTechID");

	push	OFFSET $SG218356
	mov	ecx, edi
	call	ebp

; 490  : 			m_piFeaturePassableTech[iFeatureID] = iPassableTech;

	mov	edx, DWORD PTR [esi+924]
	mov	ecx, DWORD PTR _iFeatureID$218345[esp+104]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	$LL23@CacheResul
$LN22@CacheResul:

; 491  : 		}
; 492  : 	}

	lea	ecx, DWORD PTR _sqlKey$218334[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 493  : 
; 494  : 	//UnitPromotions_UnitClasses
; 495  : 	{
; 496  : 		kUtility.InitializeArray(m_piUnitClassModifierPercent, iNumUnitClasses, 0);

	mov	ebx, DWORD PTR _iNumUnitClasses$[esp+104]
	xor	ecx, ecx
	mov	eax, ebx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	edi, DWORD PTR [ebx*4]
	push	edi
	push	0
	push	eax
	mov	DWORD PTR [esi+904], eax
	call	_memset

; 497  : 		kUtility.InitializeArray(m_piUnitClassAttackModifier, iNumUnitClasses, 0);

	xor	ecx, ecx
	mov	eax, ebx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	push	edi
	push	0
	push	eax
	mov	DWORD PTR [esi+912], eax
	call	_memset

; 498  : 		kUtility.InitializeArray(m_piUnitClassDefenseModifier, iNumUnitClasses, 0);

	xor	ecx, ecx
	mov	eax, ebx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	push	edi
	push	0
	push	eax
	mov	DWORD PTR [esi+916], eax
	call	_memset
	add	esp, 48					; 00000030H

; 499  : 
; 500  : 		std::string sqlKey = "UnitPromotions_UnitClasses";

	push	OFFSET $SG218358
	lea	ecx, DWORD PTR _sqlKey$218357[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 501  : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	mov	ebx, DWORD PTR _kUtility$[esp+100]
	lea	eax, DWORD PTR _sqlKey$218357[esp+104]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+116], 2
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 502  : 		if(pResults == NULL)

	test	edi, edi
	jne	SHORT $LN20@CacheResul

; 503  : 		{
; 504  : 			const char* szSQL = "select UnitClasses.ID, Modifier, Attack, Defense from UnitPromotions_UnitClasses inner join UnitClasses on UnitClassType = UnitClasses.Type where PromotionType = ?";
; 505  : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	push	OFFSET $SG218362
	lea	ecx, DWORD PTR _sqlKey$218357[esp+108]
	push	ecx
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax

; 506  : 		}
; 507  : 
; 508  : 		CvAssert(pResults);
; 509  : 		if(!pResults) return false;

	test	edi, edi
	je	$LN141@CacheResul
$LN20@CacheResul:

; 510  : 
; 511  : 		pResults->Bind(1, szPromotionType);

	mov	edx, DWORD PTR _szPromotionType$[esp+100]
	push	1
	push	edx
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 512  : 
; 513  : 		while(pResults->Step())

	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN18@CacheResul
$LL19@CacheResul:

; 514  : 		{
; 515  : 			const int iUnitClassID = pResults->GetInt(0);

	push	0
	mov	ecx, edi
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z

; 516  : 			CvAssert(iUnitClassID > -1 && iUnitClassID  < iNumUnitClasses);
; 517  : 
; 518  : 			const int iModifier = pResults->GetInt("Modifier");

	push	OFFSET $SG218370
	mov	ecx, edi
	mov	ebx, eax
	call	ebp

; 519  : 			m_piUnitClassModifierPercent[iUnitClassID] = iModifier;

	mov	ecx, DWORD PTR [esi+904]
	mov	DWORD PTR [ecx+ebx*4], eax

; 520  : 
; 521  : 			const int iAttack = pResults->GetInt("Attack");

	push	OFFSET $SG218372
	mov	ecx, edi
	call	ebp

; 522  : 			m_piUnitClassAttackModifier[iUnitClassID] = iAttack;

	mov	edx, DWORD PTR [esi+912]

; 523  : 
; 524  : 			const int iDefense = pResults->GetInt("Defense");

	push	OFFSET $SG218374
	mov	ecx, edi
	mov	DWORD PTR [edx+ebx*4], eax
	call	ebp

; 525  : 			m_piUnitClassDefenseModifier[iUnitClassID] = iDefense;

	mov	ecx, DWORD PTR [esi+916]
	mov	DWORD PTR [ecx+ebx*4], eax
	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL19@CacheResul

; 512  : 
; 513  : 		while(pResults->Step())

	mov	ebx, DWORD PTR _kUtility$[esp+100]
$LN18@CacheResul:

; 526  : 		}
; 527  : 
; 528  : 		pResults->Reset();

	mov	ecx, edi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 529  : 	}

	lea	ecx, DWORD PTR _sqlKey$218357[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 530  : 
; 531  : 	//UnitPromotions_Domains
; 532  : 	{
; 533  : 		kUtility.InitializeArray(m_piDomainModifierPercent, NUM_DOMAIN_TYPES, 0);

	xor	ecx, ecx
	mov	eax, 5
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	xor	ecx, ecx
	mov	DWORD PTR [esi+908], eax
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	add	esp, 4
	mov	DWORD PTR [eax+16], ecx

; 534  : 
; 535  : 		std::string sqlKey = "m_piDomainModifierPercent";

	push	OFFSET $SG218376
	lea	ecx, DWORD PTR _sqlKey$218375[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 536  : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	eax, DWORD PTR _sqlKey$218375[esp+104]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+116], 3
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 537  : 		if(pResults == NULL)

	test	edi, edi
	jne	SHORT $LN16@CacheResul

; 538  : 		{
; 539  : 			const char* szSQL = "select Domains.ID, Modifier from UnitPromotions_Domains inner join Domains on DomainType = Domains.Type where PromotionType = ?;";
; 540  : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	push	OFFSET $SG218380
	lea	ecx, DWORD PTR _sqlKey$218375[esp+108]
	push	ecx
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax

; 541  : 		}
; 542  : 
; 543  : 		CvAssert(pResults);
; 544  : 		if(!pResults) return false;

	test	edi, edi
	je	$LN141@CacheResul
$LN16@CacheResul:

; 545  : 
; 546  : 		pResults->Bind(1, szPromotionType);

	mov	edx, DWORD PTR _szPromotionType$[esp+100]
	push	1
	push	edx
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 547  : 
; 548  : 		while(pResults->Step())

	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN136@CacheResul
	npad	9
$LL15@CacheResul:

; 549  : 		{
; 550  : 			const int iDomainID = pResults->GetInt(0);

	mov	ebp, DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	push	0
	mov	ecx, edi
	call	ebp

; 551  : 			CvAssert(iDomainID > -1 && iDomainID < iNumDomains);
; 552  : 
; 553  : 			const int iDomainMod = pResults->GetInt(1);

	push	1
	mov	ecx, edi
	mov	DWORD PTR _iDomainID$218386[esp+104], eax
	call	ebp

; 554  : 			if (iDomainID > -1 && iDomainID < NUM_DOMAIN_TYPES)

	mov	ecx, DWORD PTR _iDomainID$218386[esp+100]
	cmp	ecx, 4
	ja	SHORT $LN13@CacheResul

; 555  : 				m_piDomainModifierPercent[iDomainID] = iDomainMod;

	mov	edx, DWORD PTR [esi+908]
	mov	DWORD PTR [edx+ecx*4], eax
$LN13@CacheResul:
	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL15@CacheResul

; 547  : 
; 548  : 		while(pResults->Step())

	jmp	SHORT $LN14@CacheResul
$LN136@CacheResul:
	mov	ebp, DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
$LN14@CacheResul:

; 556  : 		}
; 557  : 
; 558  : 		pResults->Reset();

	mov	ecx, edi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 559  : 	}

	lea	ecx, DWORD PTR _sqlKey$218375[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 560  : 
; 561  : 	//UnitPromotions_UnitCombatMods
; 562  : 	{
; 563  : 		kUtility.InitializeArray(m_piUnitCombatModifierPercent, iNumUnitCombatClasses, 0);

	mov	ecx, DWORD PTR _iNumUnitCombatClasses$[esp+104]
	push	0
	push	ecx
	lea	eax, DWORD PTR [esi+900]
	push	eax
	mov	ecx, ebx
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray

; 564  : 
; 565  : 		std::string sqlKey = "m_piUnitCombatModifierPercent";

	push	OFFSET $SG218390
	lea	ecx, DWORD PTR _sqlKey$218389[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 566  : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	edx, DWORD PTR _sqlKey$218389[esp+104]
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+116], 4
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 567  : 		if(pResults == NULL)

	test	edi, edi
	jne	SHORT $LN11@CacheResul

; 568  : 		{
; 569  : 			const char* szSQL = "select UnitCombatInfos.ID, Modifier from UnitPromotions_UnitCombatMods inner join UnitCombatInfos on UnitCombatInfos.Type = UnitCombatType where PromotionType = ?;";
; 570  : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	push	OFFSET $SG218394
	lea	eax, DWORD PTR _sqlKey$218389[esp+108]
	push	eax
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax

; 571  : 		}
; 572  : 
; 573  : 		CvAssert(pResults);
; 574  : 		if(!pResults) return false;

	test	edi, edi
	je	$LN141@CacheResul
$LN11@CacheResul:

; 575  : 
; 576  : 		pResults->Bind(1, szPromotionType);

	mov	ecx, DWORD PTR _szPromotionType$[esp+100]
	push	1
	push	ecx
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 577  : 
; 578  : 		while(pResults->Step())

	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN9@CacheResul
	npad	4
$LL10@CacheResul:

; 579  : 		{
; 580  : 			const int iUnitCombatID = pResults->GetInt(0);

	push	0
	mov	ecx, edi
	call	ebp

; 581  : 			CvAssert(iUnitCombatID > -1 && iUnitCombatID < iNumUnitCombatClasses);
; 582  : 
; 583  : 			const int iUnitCombatMod = pResults->GetInt(1);

	push	1
	mov	ecx, edi
	mov	DWORD PTR _iUnitCombatID$218400[esp+104], eax
	call	ebp

; 584  : 			m_piUnitCombatModifierPercent[iUnitCombatID] = iUnitCombatMod;

	mov	edx, DWORD PTR [esi+900]
	mov	ecx, DWORD PTR _iUnitCombatID$218400[esp+100]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL10@CacheResul
$LN9@CacheResul:

; 585  : 		}
; 586  : 
; 587  : 		pResults->Reset();

	mov	ecx, edi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 588  : 	}

	lea	ecx, DWORD PTR _sqlKey$218389[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 589  : 
; 590  : 	//UnitPromotions_UnitCombats
; 591  : 	{
; 592  : 		kUtility.InitializeArray(m_pbUnitCombat, iNumUnitCombatClasses, false);

	mov	edx, DWORD PTR _iNumUnitCombatClasses$[esp+104]
	push	0
	lea	eax, DWORD PTR [esi+944]
	push	edx
	push	eax
	mov	ecx, ebx
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z ; CvDatabaseUtility::InitializeArray

; 593  : 
; 594  : 		std::string sqlKey = "m_pbUnitCombat";

	push	OFFSET $SG218403
	lea	ecx, DWORD PTR _sqlKey$218402[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 595  : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	eax, DWORD PTR _sqlKey$218402[esp+104]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+116], 5
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 596  : 		if(pResults == NULL)

	test	edi, edi
	jne	SHORT $LN7@CacheResul

; 597  : 		{
; 598  : 			const char* szSQL = "select UnitCombatInfos.ID from UnitPromotions_UnitCombats inner join UnitCombatInfos On UnitCombatInfos.Type = UnitCombatType where PromotionType = ?";
; 599  : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	push	OFFSET $SG218407
	lea	ecx, DWORD PTR _sqlKey$218402[esp+108]
	push	ecx
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax

; 600  : 		}
; 601  : 
; 602  : 		CvAssert(pResults);
; 603  : 		if(!pResults) return false;

	test	edi, edi
	jne	SHORT $LN7@CacheResul
$LN141@CacheResul:
	lea	ecx, DWORD PTR _sqlKey$218402[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	ebx
	pop	ebp
	pop	edi
	xor	al, al
	pop	esi

; 652  : 
; 653  : 	return true;
; 654  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	8
$LN7@CacheResul:

; 604  : 
; 605  : 		pResults->Bind(1, szPromotionType);

	mov	edx, DWORD PTR _szPromotionType$[esp+100]
	push	1
	push	edx
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 606  : 
; 607  : 		while(pResults->Step())

	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN5@CacheResul
	npad	2
$LL6@CacheResul:

; 608  : 		{
; 609  : 			const int iUnitCombatInfoID = pResults->GetInt(0);

	push	0
	mov	ecx, edi
	call	ebp

; 610  : 			CvAssert(iUnitCombatInfoID < iNumUnitCombatClasses);
; 611  : 
; 612  : 			m_pbUnitCombat[iUnitCombatInfoID] = true;

	mov	ecx, DWORD PTR [esi+944]
	mov	BYTE PTR [eax+ecx], 1
	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL6@CacheResul
$LN5@CacheResul:

; 613  : 		}
; 614  : 
; 615  : 		pResults->Reset();

	mov	ecx, edi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 616  : 	}

	lea	ecx, DWORD PTR _sqlKey$218402[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 617  : 
; 618  : 	//UnitPromotions_CivilianUnitType
; 619  : 	{
; 620  : 		kUtility.InitializeArray(m_pbCivilianUnitType, iNumUnitTypes, false);

	mov	edx, DWORD PTR _iNumUnitTypes$[esp+104]
	push	0
	lea	eax, DWORD PTR [esi+948]
	push	edx
	push	eax
	mov	ecx, ebx
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPA_NI_N@Z ; CvDatabaseUtility::InitializeArray

; 621  : 
; 622  : 		std::string sqlKey = "m_pbCivilianUnitType";

	push	OFFSET $SG218415
	lea	ecx, DWORD PTR _sqlKey$218414[esp+108]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 623  : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	eax, DWORD PTR _sqlKey$218414[esp+104]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+116], 6
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 624  : 		if(pResults == NULL)

	test	edi, edi
	jne	SHORT $LN3@CacheResul

; 625  : 		{
; 626  : 			const char* szSQL = "select Units.ID from UnitPromotions_CivilianUnitType inner join Units On Units.Type = UnitType where PromotionType = ?";
; 627  : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	push	OFFSET $SG218419
	lea	ecx, DWORD PTR _sqlKey$218414[esp+108]
	push	ecx
	mov	ecx, ebx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax

; 628  : 		}
; 629  : 
; 630  : 		CvAssert(pResults);
; 631  : 		if(!pResults) return false;

	test	edi, edi
	jne	SHORT $LN3@CacheResul
	lea	ecx, DWORD PTR _sqlKey$218414[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	ebx
	pop	ebp
	pop	edi
	xor	al, al
	pop	esi

; 652  : 
; 653  : 	return true;
; 654  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	8
$LN3@CacheResul:

; 632  : 
; 633  : 		pResults->Bind(1, szPromotionType);

	mov	edx, DWORD PTR _szPromotionType$[esp+100]
	push	1
	push	edx
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 634  : 
; 635  : 		while(pResults->Step())

	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN1@CacheResul
$LL2@CacheResul:

; 636  : 		{
; 637  : 			const int iUnit = (UnitTypes)pResults->GetInt(0);

	push	0
	mov	ecx, edi
	call	ebp

; 638  : 			CvAssert(iUnit < iNumUnitTypes);
; 639  : 
; 640  : 			m_pbCivilianUnitType[iUnit] = true;

	mov	ecx, DWORD PTR [esi+948]
	mov	BYTE PTR [eax+ecx], 1
	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL2@CacheResul
$LN1@CacheResul:

; 641  : 		}
; 642  : 
; 643  : 		pResults->Reset();

	mov	ecx, edi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 644  : 	}

	lea	ecx, DWORD PTR _sqlKey$218414[esp+104]
	mov	DWORD PTR __$EHRec$[esp+112], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 645  : 
; 646  : 	kUtility.PopulateArrayByExistence(m_pbPostCombatRandomPromotion,
; 647  : 		"UnitPromotions",
; 648  : 		"UnitPromotions_PostCombatRandomPromotion",
; 649  : 		"NewPromotion",
; 650  : 		"PromotionType",
; 651  : 		szPromotionType);

	mov	edx, DWORD PTR _szPromotionType$[esp+100]
	push	edx
	push	OFFSET $SG218427
	push	OFFSET $SG218428
	push	OFFSET $SG218429
	push	OFFSET $SG218430
	add	esi, 952				; 000003b8H
	push	esi
	mov	ecx, ebx
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 652  : 
; 653  : 	return true;
; 654  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+104]
	pop	ebx
	pop	ebp
	pop	edi
	mov	al, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 88					; 00000058H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _sqlKey$218311[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _sqlKey$218334[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2:
	lea	ecx, DWORD PTR _sqlKey$218357[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3:
	lea	ecx, DWORD PTR _sqlKey$218375[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4:
	lea	ecx, DWORD PTR _sqlKey$218389[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5:
	lea	ecx, DWORD PTR _sqlKey$218402[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6:
	lea	ecx, DWORD PTR _sqlKey$218414[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvPromotionEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvPromotionEntry::CacheResults
PUBLIC	??0CvUnitPromotions@@QAE@XZ			; CvUnitPromotions::CvUnitPromotions
; Function compile flags: /Ogtpy
;	COMDAT ??0CvUnitPromotions@@QAE@XZ
_TEXT	SEGMENT
??0CvUnitPromotions@@QAE@XZ PROC			; CvUnitPromotions::CvUnitPromotions, COMDAT
; _this$ = ecx

; 2014 : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 2015 : }

	ret	0
??0CvUnitPromotions@@QAE@XZ ENDP			; CvUnitPromotions::CvUnitPromotions
_TEXT	ENDS
PUBLIC	??1CvUnitPromotions@@QAE@XZ			; CvUnitPromotions::~CvUnitPromotions
; Function compile flags: /Ogtpy
;	COMDAT ??1CvUnitPromotions@@QAE@XZ
_TEXT	SEGMENT
??1CvUnitPromotions@@QAE@XZ PROC			; CvUnitPromotions::~CvUnitPromotions, COMDAT
; _this$ = ecx

; 2020 : }

	push	0
	call	?SetSize@CvBitfield@@QAEXI@Z		; CvBitfield::SetSize
	ret	0
??1CvUnitPromotions@@QAE@XZ ENDP			; CvUnitPromotions::~CvUnitPromotions
_TEXT	ENDS
PUBLIC	?Init@CvUnitPromotions@@QAEXPAVCvPromotionXMLEntries@@PAVCvUnit@@@Z ; CvUnitPromotions::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvUnitPromotions@@QAEXPAVCvPromotionXMLEntries@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_pPromotions$ = 8					; size = 4
_pUnit$ = 12						; size = 4
?Init@CvUnitPromotions@@QAEXPAVCvPromotionXMLEntries@@PAVCvUnit@@@Z PROC ; CvUnitPromotions::Init, COMDAT
; _this$ = ecx

; 2025 : 	CvAssert(pPromotions);
; 2026 : 	if(!pPromotions)

	mov	edx, DWORD PTR _pPromotions$[esp-4]
	test	edx, edx
	je	SHORT $LN5@Init

; 2027 : 		return;
; 2028 : 
; 2029 : 	CvAssert(pUnit);
; 2030 : 	if(!pUnit)

	mov	eax, DWORD PTR _pUnit$[esp-4]
	test	eax, eax
	je	SHORT $LN5@Init

; 2031 : 		return;
; 2032 : 
; 2033 : 	m_pPromotions = pPromotions;
; 2034 : 	m_pUnit = pUnit;
; 2035 : 
; 2036 : 	Reset();

	push	0
	mov	DWORD PTR [ecx+8], edx
	mov	DWORD PTR [ecx+12], eax
	call	?SetSize@CvBitfield@@QAEXI@Z		; CvBitfield::SetSize
$LN5@Init:

; 2037 : }

	ret	8
?Init@CvUnitPromotions@@QAEXPAVCvPromotionXMLEntries@@PAVCvUnit@@@Z ENDP ; CvUnitPromotions::Init
_TEXT	ENDS
PUBLIC	?SetPromotion@CvUnitPromotions@@QAEXW4PromotionTypes@@_N@Z ; CvUnitPromotions::SetPromotion
; Function compile flags: /Ogtpy
;	COMDAT ?SetPromotion@CvUnitPromotions@@QAEXW4PromotionTypes@@_N@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetPromotion@CvUnitPromotions@@QAEXW4PromotionTypes@@_N@Z PROC ; CvUnitPromotions::SetPromotion, COMDAT
; _this$ = ecx

; 2109 : {

	push	esi

; 2110 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2111 : 	CvAssertMsg(eIndex < GC.getNumPromotionInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2112 : 
; 2113 : #ifdef AUI_WARNING_FIXES
; 2114 : 	if (uint(eIndex) < GC.getNumPromotionInfos())
; 2115 : #else
; 2116 : 	if(eIndex >= 0 && eIndex < GC.getNumPromotionInfos())

	mov	esi, DWORD PTR _eIndex$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jl	SHORT $LN1@SetPromoti
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	cmp	esi, eax
	jge	SHORT $LN1@SetPromoti

; 2117 : #endif
; 2118 : 	{
; 2119 : 		m_kHasPromotion.SetBit(eIndex, bValue);

	mov	eax, DWORD PTR _bValue$[esp+4]
	push	eax
	push	esi
	mov	ecx, edi
	call	?SetBit@CvBitfield@@QAEXI_N@Z		; CvBitfield::SetBit
$LN1@SetPromoti:
	pop	edi
	pop	esi

; 2120 : 	}
; 2121 : }

	ret	8
?SetPromotion@CvUnitPromotions@@QAEXW4PromotionTypes@@_N@Z ENDP ; CvUnitPromotions::SetPromotion
_TEXT	ENDS
PUBLIC	?Read@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z ; PromotionArrayHelpers::Read
EXTRN	?LogMessage@CvGlobals@@QAEXPBD@Z:PROC		; CvGlobals::LogMessage
EXTRN	?getInfoTypeForHash@CvGlobals@@QBEHI_N@Z:PROC	; CvGlobals::getInfoTypeForHash
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Read@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Read@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z$0
__ehfuncinfo$?Read@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Read@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpromotionclasses.cpp
xdata$x	ENDS
;	COMDAT ?Read@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z
_TEXT	SEGMENT
_bTemp$219363 = -58					; size = 1
_bDummy$219370 = -57					; size = 1
_iNumEntries$ = -56					; size = 4
_uiHashTemp$ = -52					; size = 4
_uiOligarchyHash$ = -48					; size = 4
_bValue$219366 = -44					; size = 1
_szError$219368 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
_kPromotions$ = 12					; size = 4
?Read@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z PROC ; PromotionArrayHelpers::Read, COMDAT

; 2326 : {

	push	-1
	push	__ehhandler$?Read@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	ebp
	push	edi

; 2327 : 	int iNumEntries;
; 2328 : 	int iType;
; 2329 : 
; 2330 : 	kStream >> iNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+68]
	lea	eax, DWORD PTR _iNumEntries$[esp+72]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2331 : 
; 2332 : 	kPromotions.SetSize( iNumEntries );

	mov	ecx, DWORD PTR _iNumEntries$[esp+72]
	mov	ebp, DWORD PTR _kPromotions$[esp+68]
	push	ecx
	mov	ecx, ebp
	call	?SetSize@CvBitfield@@QAEXI@Z		; CvBitfield::SetSize

; 2333 : 
; 2334 : 	uint uiHashTemp;
; 2335 : 	uint uiOligarchyHash = FString::Hash("PROMOTION_OLIGARCHY");

	push	-1
	push	19					; 00000013H
	push	OFFSET $SG219357
	mov	ecx, OFFSET ?g_CRC32@@3VFCRC@@A		; g_CRC32
	call	?Calc@FCRC@@QBEKPBXHK@Z			; FCRC::Calc

; 2336 : 	for(int iI = 0; iI < iNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _iNumEntries$[esp+72], ebx
	mov	DWORD PTR _uiOligarchyHash$[esp+72], eax
	jle	$LN5@Read
	push	esi
	npad	1
$LL37@Read:

; 2337 : 	{
; 2338 : 		kStream >> uiHashTemp;

	lea	edx, DWORD PTR _uiHashTemp$[esp+76]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2339 : 		if(uiHashTemp == uiOligarchyHash)

	mov	eax, DWORD PTR _uiHashTemp$[esp+76]
	cmp	eax, DWORD PTR _uiOligarchyHash$[esp+76]
	jne	SHORT $LN4@Read

; 2340 : 		{
; 2341 : 			bool bTemp;
; 2342 : 			kStream >> bTemp;

	lea	eax, DWORD PTR _bTemp$219363[esp+76]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2343 : 		}
; 2344 : 		else

	jmp	$LN6@Read
$LN4@Read:

; 2345 : 		{
; 2346 : 			iType = GC.getInfoTypeForHash(uiHashTemp);

	push	0
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForHash@CvGlobals@@QBEHI_N@Z ; CvGlobals::getInfoTypeForHash
	mov	esi, eax

; 2347 : 			if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN2@Read

; 2348 : 			{
; 2349 : 				bool bValue;
; 2350 : 				kStream >> bValue;

	lea	ecx, DWORD PTR _bValue$219366[esp+76]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2351 : 				kPromotions.SetBit(iType, bValue);

	mov	edx, DWORD PTR _bValue$219366[esp+76]
	push	edx
	push	esi
	mov	ecx, ebp
	call	?SetBit@CvBitfield@@QAEXI_N@Z		; CvBitfield::SetBit

; 2352 : 			}
; 2353 : 			else

	jmp	SHORT $LN6@Read
$LN2@Read:

; 2354 : 			{
; 2355 : 				CvString szError;

	lea	ecx, DWORD PTR _szError$219368[esp+76]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2356 : 				szError.Format("LOAD ERROR: Promotion Type not found for hash: %u", uiHashTemp);

	mov	eax, DWORD PTR _uiHashTemp$[esp+76]
	push	eax
	lea	ecx, DWORD PTR _szError$219368[esp+80]
	push	OFFSET $SG219369
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 2357 : 				GC.LogMessage(szError.GetCString());

	lea	ecx, DWORD PTR _szError$219368[esp+76]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage

; 2358 : 				CvAssertMsg(false, szError);
; 2359 : 				bool bDummy;
; 2360 : 				kStream >> bDummy;

	lea	edx, DWORD PTR _bDummy$219370[esp+76]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2361 : 			}

	lea	ecx, DWORD PTR _szError$219368[esp+76]
	mov	DWORD PTR __$EHRec$[esp+84], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@Read:
	inc	ebx
	cmp	ebx, DWORD PTR _iNumEntries$[esp+76]
	jl	$LL37@Read
	pop	esi
$LN5@Read:

; 2362 : 		}
; 2363 : 	}
; 2364 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	pop	edi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 60					; 0000003cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Read@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z$0:
	lea	ecx, DWORD PTR _szError$219368[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?Read@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Read@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Read@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z ENDP ; PromotionArrayHelpers::Read
PUBLIC	?Write@PromotionArrayHelpers@@YAXAAVFDataStream@@ABVCvBitfield@@H@Z ; PromotionArrayHelpers::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@PromotionArrayHelpers@@YAXAAVFDataStream@@ABVCvBitfield@@H@Z
_TEXT	SEGMENT
_bValue$219390 = -9					; size = 1
_iCount$ = -8						; size = 4
_uiHash$219394 = -4					; size = 4
_kStream$ = 8						; size = 4
_kPromotions$ = 12					; size = 4
_iArraySize$ = 16					; size = 4
?Write@PromotionArrayHelpers@@YAXAAVFDataStream@@ABVCvBitfield@@H@Z PROC ; PromotionArrayHelpers::Write, COMDAT

; 2368 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2369 : 	// We are only going to save the 'on' bit, so we have to count them
; 2370 : 	int iCount = 0;
; 2371 : 
; 2372 : 	for(int iI = 0; iI < iArraySize; iI++)

	mov	edi, DWORD PTR _iArraySize$[esp+24]
	xor	esi, esi
	cmp	edi, esi
	mov	DWORD PTR _iCount$[esp+28], esi
	mov	bl, 1
	jle	SHORT $LN7@Write
$LL9@Write:

; 2373 : 	{
; 2374 : 		const PromotionTypes ePromotion = static_cast<PromotionTypes>(iI);
; 2375 : 		if (kPromotions.GetBit(ePromotion) && GC.getPromotionInfo(ePromotion) != NULL)

	mov	ecx, DWORD PTR _kPromotions$[esp+24]
	mov	eax, esi
	shr	eax, 3
	cmp	eax, DWORD PTR [ecx]
	jae	SHORT $LN8@Write
	mov	ecx, DWORD PTR [ecx+4]
	test	BYTE PTR [eax+ecx], bl
	setne	al
	test	al, al
	je	SHORT $LN8@Write
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	test	eax, eax
	je	SHORT $LN8@Write

; 2376 : 			++iCount;

	inc	DWORD PTR _iCount$[esp+28]
$LN8@Write:

; 2369 : 	// We are only going to save the 'on' bit, so we have to count them
; 2370 : 	int iCount = 0;
; 2371 : 
; 2372 : 	for(int iI = 0; iI < iArraySize; iI++)

	inc	esi
	rol	bl, 1
	cmp	esi, edi
	jl	SHORT $LL9@Write
$LN7@Write:

; 2377 : 	}
; 2378 : 
; 2379 : 	kStream << iCount;

	mov	ebp, DWORD PTR _kStream$[esp+24]
	lea	edx, DWORD PTR _iCount$[esp+28]
	push	edx
	mov	ecx, ebp
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2380 : 
; 2381 : 	for(int iI = 0; iI < iArraySize; iI++)

	xor	edi, edi
	cmp	DWORD PTR _iArraySize$[esp+24], edi
	mov	bl, 1
	jle	$LN3@Write
	npad	7
$LL38@Write:

; 2382 : 	{
; 2383 : 		const PromotionTypes ePromotion = static_cast<PromotionTypes>(iI);
; 2384 : 		bool bValue = kPromotions.GetBit(ePromotion);

	mov	ecx, DWORD PTR _kPromotions$[esp+24]
	mov	eax, edi
	shr	eax, 3
	cmp	eax, DWORD PTR [ecx]
	jae	SHORT $LN17@Write
	mov	ecx, DWORD PTR [ecx+4]
	test	BYTE PTR [eax+ecx], bl
	setne	al
	jmp	SHORT $LN18@Write
$LN17@Write:
	xor	al, al
$LN18@Write:
	mov	BYTE PTR _bValue$219390[esp+28], al

; 2385 : 		if (bValue)

	test	al, al
	je	SHORT $LN4@Write

; 2386 : 		{
; 2387 : 			CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(ePromotion);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo

; 2388 : 			if(pkPromotionInfo)

	test	eax, eax
	je	SHORT $LN4@Write

; 2389 : 			{
; 2390 : 				uint uiHash = FString::Hash( pkPromotionInfo->GetType() );		// Save just the hash

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	je	SHORT $LN26@Write
	mov	ecx, eax
	lea	esi, DWORD PTR [ecx+1]
$LL36@Write:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL36@Write
	sub	ecx, esi
	jmp	SHORT $LN27@Write
$LN26@Write:
	xor	ecx, ecx
$LN27@Write:
	push	-1
	push	ecx
	push	eax
	mov	ecx, OFFSET ?g_CRC32@@3VFCRC@@A		; g_CRC32
	call	?Calc@FCRC@@QBEKPBXHK@Z			; FCRC::Calc

; 2391 : 				kStream << uiHash;

	lea	edx, DWORD PTR _uiHash$219394[esp+28]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR _uiHash$219394[esp+32], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2392 : 				kStream << bValue;

	lea	eax, DWORD PTR _bValue$219390[esp+28]
	push	eax
	mov	ecx, ebp
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
$LN4@Write:
	inc	edi
	rol	bl, 1
	cmp	edi, DWORD PTR _iArraySize$[esp+24]
	jl	$LL38@Write
$LN3@Write:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2393 : 			}
; 2394 : 		}
; 2395 : 	}
; 2396 : }

	add	esp, 12					; 0000000cH
	ret	0
?Write@PromotionArrayHelpers@@YAXAAVFDataStream@@ABVCvBitfield@@H@Z ENDP ; PromotionArrayHelpers::Write
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@XZ ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@XZ PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@XZ ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@XZ ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@XZ PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@XZ ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@KAXXZ ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvPromotionEntry@@@std@@YAPAPAVCvPromotionEntry@@IPAPAV1@@Z ; std::_Allocate<CvPromotionEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAEXPAPAVCvPromotionEntry@@0@Z ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAEXPAPAVCvPromotionEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAEXPAPAVCvPromotionEntry@@0@Z PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAEXPAPAVCvPromotionEntry@@0@Z ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	??0?$FStringAFixedBuffer@$0EA@@FStringA@@QAE@AAV1@@Z ; FStringA::FStringAFixedBuffer<64>::FStringAFixedBuffer<64>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstringa.inl
;	COMDAT ??0?$FStringAFixedBuffer@$0EA@@FStringA@@QAE@AAV1@@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
??0?$FStringAFixedBuffer@$0EA@@FStringA@@QAE@AAV1@@Z PROC ; FStringA::FStringAFixedBuffer<64>::FStringAFixedBuffer<64>, COMDAT
; _this$ = ecx

; 58   : {

	push	ebx
	push	ebp

; 59   : 	assert( nLENGTH > 0 );
; 60   : 	m_kStringData.m_bLocked = 0;
; 61   : 	m_kStringData.m_bFixed = 1;
; 62   : 	m_kStringData.m_iAllocLength = nLENGTH;
; 63   : 	m_kStringData.m_iDataLength = 0;
; 64   : 	m_szStringBuffer[ 0 ] = 0;
; 65   : 	str.SetFixedBuffer( &m_kStringData );

	mov	ebp, DWORD PTR _str$[esp+4]
	push	esi
	mov	esi, ecx
	xor	eax, eax
	mov	ecx, 1
	lea	ebx, DWORD PTR [esi+12]
	push	edi
	mov	WORD PTR [esi+8], ax
	mov	WORD PTR [esi+10], cx
	mov	DWORD PTR [esi], 64			; 00000040H
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [ebx], al
	mov	edi, DWORD PTR [ebp]
	sub	edi, 12					; 0000000cH
	je	SHORT $LN19@FStringAFi
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	edi, eax
	je	SHORT $LN19@FStringAFi
	cmp	WORD PTR [edi+10], 0
	jne	SHORT $LN19@FStringAFi
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN19@FStringAFi:
	mov	DWORD PTR [ebp], 0
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	pop	edi

; 66   : }

	mov	eax, esi
	pop	esi
	mov	DWORD PTR [ebp], ebx
	pop	ebp
	pop	ebx
	ret	4
??0?$FStringAFixedBuffer@$0EA@@FStringA@@QAE@AAV1@@Z ENDP ; FStringA::FStringAFixedBuffer<64>::FStringAFixedBuffer<64>
_TEXT	ENDS
PUBLIC	??_GCvPromotionEntry@@QAEPAXI@Z			; CvPromotionEntry::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvPromotionEntry@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvPromotionEntry@@QAEPAXI@Z PROC			; CvPromotionEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvPromotionEntry@@QAE@XZ		; CvPromotionEntry::~CvPromotionEntry
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvPromotionEntry@@QAEPAXI@Z ENDP			; CvPromotionEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1FStringA@@QAE@XZ				; FStringA::~FStringA
; Function compile flags: /Ogtpy
;	COMDAT ??1FStringA@@QAE@XZ
_TEXT	SEGMENT
??1FStringA@@QAE@XZ PROC				; FStringA::~FStringA, COMDAT
; _this$ = ecx

; 151  : {

	push	esi
	push	edi
	mov	edi, ecx

; 152  : 	Release();

	mov	esi, DWORD PTR [edi]
	sub	esi, 12					; 0000000cH
	je	SHORT $LN7@FStringA
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN7@FStringA
	cmp	WORD PTR [esi+10], 0
	jne	SHORT $LN7@FStringA
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@FStringA:
	mov	DWORD PTR [edi], 0
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi

; 153  : }

	ret	0
??1FStringA@@QAE@XZ ENDP				; FStringA::~FStringA
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@3
	pop	esi
$LN7@unchecked_@3:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??0CvPromotionEntry@@QAE@XZ			; CvPromotionEntry::CvPromotionEntry
EXTRN	??0CvHotKeyInfo@@QAE@XZ:PROC			; CvHotKeyInfo::CvHotKeyInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??0CvPromotionEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPromotionEntry@@QAE@XZ$0
__ehfuncinfo$??0CvPromotionEntry@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvPromotionEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpromotionclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvPromotionEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvPromotionEntry@@QAE@XZ PROC			; CvPromotionEntry::CvPromotionEntry, COMDAT
; _this$ = ecx

; 182  : {

	push	-1
	push	__ehhandler$??0CvPromotionEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	??0CvHotKeyInfo@@QAE@XZ			; CvHotKeyInfo::CvHotKeyInfo
	xor	ebx, ebx
	or	eax, -1
	mov	DWORD PTR __$EHRec$[esp+32], ebx
	mov	DWORD PTR [esi], OFFSET ??_7CvPromotionEntry@@6B@
	mov	DWORD PTR [esi+460], eax
	mov	DWORD PTR [esi+464], eax
	mov	DWORD PTR [esi+468], eax
	mov	DWORD PTR [esi+472], eax
	mov	DWORD PTR [esi+476], eax
	mov	DWORD PTR [esi+480], eax
	mov	DWORD PTR [esi+484], eax
	mov	DWORD PTR [esi+488], eax
	mov	DWORD PTR [esi+492], eax
	mov	DWORD PTR [esi+496], eax
	mov	DWORD PTR [esi+500], eax
	mov	DWORD PTR [esi+504], eax
	mov	DWORD PTR [esi+508], eax
	mov	DWORD PTR [esi+512], eax
	mov	DWORD PTR [esi+516], eax
	mov	DWORD PTR [esi+520], ebx
	mov	DWORD PTR [esi+524], ebx
	mov	DWORD PTR [esi+528], ebx
	mov	DWORD PTR [esi+532], ebx
	mov	DWORD PTR [esi+536], ebx
	mov	DWORD PTR [esi+540], ebx
	mov	DWORD PTR [esi+544], ebx
	mov	DWORD PTR [esi+548], ebx
	mov	DWORD PTR [esi+552], ebx
	mov	DWORD PTR [esi+556], ebx
	mov	DWORD PTR [esi+560], ebx
	mov	DWORD PTR [esi+564], ebx
	mov	DWORD PTR [esi+568], ebx
	mov	DWORD PTR [esi+572], ebx
	mov	DWORD PTR [esi+576], ebx
	mov	DWORD PTR [esi+580], ebx
	mov	DWORD PTR [esi+584], ebx
	mov	DWORD PTR [esi+588], ebx
	mov	DWORD PTR [esi+592], ebx
	mov	DWORD PTR [esi+596], ebx
	mov	DWORD PTR [esi+600], ebx
	mov	DWORD PTR [esi+604], ebx
	mov	DWORD PTR [esi+608], ebx
	mov	DWORD PTR [esi+612], ebx
	mov	DWORD PTR [esi+616], ebx
	mov	DWORD PTR [esi+620], ebx
	mov	DWORD PTR [esi+624], ebx
	mov	DWORD PTR [esi+628], ebx
	mov	DWORD PTR [esi+632], ebx
	mov	DWORD PTR [esi+636], ebx
	mov	DWORD PTR [esi+640], ebx
	mov	DWORD PTR [esi+644], ebx
	mov	DWORD PTR [esi+648], ebx
	mov	DWORD PTR [esi+652], ebx
	mov	DWORD PTR [esi+656], ebx
	mov	DWORD PTR [esi+660], ebx
	mov	DWORD PTR [esi+664], ebx
	mov	DWORD PTR [esi+668], ebx
	mov	DWORD PTR [esi+672], ebx
	mov	BYTE PTR [esi+676], bl
	mov	BYTE PTR [esi+677], bl
	mov	DWORD PTR [esi+680], ebx
	mov	BYTE PTR [esi+684], bl
	mov	BYTE PTR [esi+685], bl
	mov	DWORD PTR [esi+688], ebx
	mov	DWORD PTR [esi+692], ebx
	mov	DWORD PTR [esi+696], ebx
	mov	DWORD PTR [esi+700], ebx
	mov	DWORD PTR [esi+704], ebx
	mov	DWORD PTR [esi+708], ebx
	mov	DWORD PTR [esi+712], ebx
	mov	DWORD PTR [esi+716], eax
	mov	DWORD PTR [esi+720], ebx
	mov	DWORD PTR [esi+724], ebx
	mov	DWORD PTR [esi+728], ebx
	mov	DWORD PTR [esi+732], ebx
	mov	DWORD PTR [esi+736], ebx
	mov	DWORD PTR [esi+740], ebx
	mov	DWORD PTR [esi+744], ebx
	mov	DWORD PTR [esi+748], ebx
	mov	DWORD PTR [esi+752], ebx
	mov	DWORD PTR [esi+756], ebx
	mov	DWORD PTR [esi+760], ebx
	mov	DWORD PTR [esi+764], ebx
	mov	DWORD PTR [esi+768], ebx
	mov	DWORD PTR [esi+772], ebx
	mov	DWORD PTR [esi+776], ebx
	mov	DWORD PTR [esi+780], ebx
	mov	DWORD PTR [esi+784], ebx
	mov	DWORD PTR [esi+788], ebx
	mov	BYTE PTR [esi+792], bl
	mov	BYTE PTR [esi+793], bl
	mov	BYTE PTR [esi+794], bl
	mov	BYTE PTR [esi+795], bl
	mov	BYTE PTR [esi+796], bl
	mov	BYTE PTR [esi+797], bl
	mov	BYTE PTR [esi+798], bl
	mov	BYTE PTR [esi+799], bl
	mov	BYTE PTR [esi+800], bl
	mov	BYTE PTR [esi+801], bl
	mov	BYTE PTR [esi+802], bl
	mov	BYTE PTR [esi+803], bl
	mov	BYTE PTR [esi+804], bl
	mov	BYTE PTR [esi+805], bl
	mov	BYTE PTR [esi+806], bl
	mov	BYTE PTR [esi+807], bl
	mov	BYTE PTR [esi+808], bl
	mov	BYTE PTR [esi+809], bl
	mov	BYTE PTR [esi+810], bl
	mov	BYTE PTR [esi+811], bl
	mov	BYTE PTR [esi+812], bl
	mov	BYTE PTR [esi+813], bl
	mov	BYTE PTR [esi+814], bl
	mov	BYTE PTR [esi+815], bl
	mov	BYTE PTR [esi+816], bl
	mov	BYTE PTR [esi+817], bl
	mov	BYTE PTR [esi+818], bl
	mov	BYTE PTR [esi+819], bl
	mov	BYTE PTR [esi+820], bl
	mov	BYTE PTR [esi+821], bl
	mov	BYTE PTR [esi+822], bl
	mov	BYTE PTR [esi+823], bl
	mov	BYTE PTR [esi+824], bl
	mov	BYTE PTR [esi+825], bl
	mov	BYTE PTR [esi+826], bl
	mov	BYTE PTR [esi+827], bl
	mov	BYTE PTR [esi+828], bl
	mov	BYTE PTR [esi+829], bl
	mov	BYTE PTR [esi+830], bl
	mov	BYTE PTR [esi+831], bl
	mov	BYTE PTR [esi+832], bl
	mov	BYTE PTR [esi+833], bl
	mov	BYTE PTR [esi+834], bl
	mov	BYTE PTR [esi+835], bl
	mov	DWORD PTR [esi+836], eax
	mov	DWORD PTR [esi+840], eax
	mov	DWORD PTR [esi+844], eax
	mov	BYTE PTR [esi+848], bl
	lea	ecx, DWORD PTR [esi+856]
	mov	DWORD PTR [esi+852], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR [esi+884], ebx
	mov	DWORD PTR [esi+888], ebx
	mov	DWORD PTR [esi+892], ebx
	mov	DWORD PTR [esi+896], ebx
	mov	DWORD PTR [esi+900], ebx
	mov	DWORD PTR [esi+904], ebx
	mov	DWORD PTR [esi+908], ebx
	mov	DWORD PTR [esi+912], ebx
	mov	DWORD PTR [esi+916], ebx
	mov	DWORD PTR [esi+920], ebx
	mov	DWORD PTR [esi+924], ebx
	mov	DWORD PTR [esi+928], ebx
	mov	DWORD PTR [esi+932], ebx
	mov	DWORD PTR [esi+936], ebx
	mov	DWORD PTR [esi+940], ebx
	mov	DWORD PTR [esi+944], ebx

; 183  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+948], ebx
	mov	DWORD PTR [esi+952], ebx
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPromotionEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvHotKeyInfo@@QAE@XZ
__ehhandler$??0CvPromotionEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvPromotionEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPromotionEntry@@QAE@XZ ENDP			; CvPromotionEntry::CvPromotionEntry
PUBLIC	?Read@CvUnitPromotions@@QAEXAAVFDataStream@@@Z	; CvUnitPromotions::Read
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvUnitPromotions@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -8					; size = 4
_iNumPromotions$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvUnitPromotions@@QAEXAAVFDataStream@@@Z PROC	; CvUnitPromotions::Read, COMDAT
; _this$ = ecx

; 2053 : {

	sub	esp, 8
	push	esi
	push	edi

; 2054 : 	Reset();

	push	0
	mov	esi, ecx
	call	?SetSize@CvBitfield@@QAEXI@Z		; CvBitfield::SetSize

; 2055 : 
; 2056 : 	// Version number to maintain backwards compatibility
; 2057 : 	uint uiVersion;
; 2058 : 	kStream >> uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+12]
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2059 : 
; 2060 : 	// Read number of promotions
; 2061 : 	int iNumPromotions;
; 2062 : 	kStream >> iNumPromotions;

	lea	ecx, DWORD PTR _iNumPromotions$[esp+16]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2063 : 	CvAssertMsg(m_pPromotions != NULL && m_pPromotions->GetNumPromotions() > 0, "Number of promotions to serialize is expected to greater than 0");
; 2064 : 
; 2065 : 	PromotionArrayHelpers::Read(kStream, m_kHasPromotion);

	push	esi
	push	edi
	call	?Read@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z ; PromotionArrayHelpers::Read
	add	esp, 8
	pop	edi
	pop	esi

; 2066 : }

	add	esp, 8
	ret	4
?Read@CvUnitPromotions@@QAEXAAVFDataStream@@@Z ENDP	; CvUnitPromotions::Read
_TEXT	ENDS
PUBLIC	?Write@CvUnitPromotions@@QBEXAAVFDataStream@@@Z	; CvUnitPromotions::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvUnitPromotions@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_iNumPromotions$ = 8					; size = 4
_kStream$ = 8						; size = 4
?Write@CvUnitPromotions@@QBEXAAVFDataStream@@@Z PROC	; CvUnitPromotions::Write, COMDAT
; _this$ = ecx

; 2070 : {

	push	ecx
	push	esi
	push	edi

; 2071 : 	// Current version number
; 2072 : 	uint uiVersion = 1;
; 2073 : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+16], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2074 : 
; 2075 : 	// Write out number of promotions to save
; 2076 : 	int iNumPromotions = m_pPromotions->GetNumPromotions();

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]

; 2077 : 	kStream << iNumPromotions;

	lea	edx, DWORD PTR _iNumPromotions$[esp+8]
	sar	ecx, 2
	mov	DWORD PTR _iNumPromotions$[esp+8], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2078 : 	CvAssertMsg(iNumPromotions > 0, "Number of promotions to serialize is expected to greater than 0");
; 2079 : 
; 2080 : 	PromotionArrayHelpers::Write(kStream, m_kHasPromotion, iNumPromotions);

	mov	eax, DWORD PTR _iNumPromotions$[esp+8]
	push	eax
	push	esi
	push	edi
	call	?Write@PromotionArrayHelpers@@YAXAAVFDataStream@@ABVCvBitfield@@H@Z ; PromotionArrayHelpers::Write
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 2081 : }

	pop	ecx
	ret	4
?Write@CvUnitPromotions@@QBEXAAVFDataStream@@@Z ENDP	; CvUnitPromotions::Write
_TEXT	ENDS
PUBLIC	?ReadV3@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z ; PromotionArrayHelpers::ReadV3
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstringa.inl
xdata$x	SEGMENT
__unwindtable$?ReadV3@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadV3@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ReadV3@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z$1
__ehfuncinfo$?ReadV3@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ReadV3@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpromotionclasses.cpp
xdata$x	ENDS
;	COMDAT ?ReadV3@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z
_TEXT	SEGMENT
_bTemp$219341 = -130					; size = 1
_bDummy$219348 = -129					; size = 1
_sTemp$ = -128						; size = 4
_iNumEntries$ = -124					; size = 4
_bValue$219344 = -120					; size = 1
_szError$219346 = -116					; size = 28
_FStringFixedBuffer_sTemp$ = -88			; size = 76
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
_kPromotions$ = 12					; size = 4
?ReadV3@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z PROC ; PromotionArrayHelpers::ReadV3, COMDAT

; 2281 : {

	push	-1
	push	__ehhandler$?ReadV3@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 2282 : 	int iNumEntries;
; 2283 : 	FStringFixedBuffer(sTemp, 64);

	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _sTemp$[esp+148], eax
	lea	eax, DWORD PTR _sTemp$[esp+148]
	xor	ebx, ebx
	push	eax
	lea	ecx, DWORD PTR _FStringFixedBuffer_sTemp$[esp+152]
	mov	DWORD PTR __$EHRec$[esp+160], ebx
	call	??0?$FStringAFixedBuffer@$0EA@@FStringA@@QAE@AAV1@@Z ; FStringA::FStringAFixedBuffer<64>::FStringAFixedBuffer<64>

; 2284 : 	int iType;
; 2285 : 
; 2286 : 	kStream >> iNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+144]
	lea	ecx, DWORD PTR _iNumEntries$[esp+148]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2287 : 
; 2288 : 	kPromotions.SetSize( iNumEntries );

	mov	edx, DWORD PTR _iNumEntries$[esp+148]
	mov	ecx, DWORD PTR _kPromotions$[esp+144]
	push	edx
	call	?SetSize@CvBitfield@@QAEXI@Z		; CvBitfield::SetSize

; 2289 : 
; 2290 : 	for(int iI = 0; iI < iNumEntries; iI++)

	xor	ebp, ebp
	cmp	DWORD PTR _iNumEntries$[esp+148], ebx
	jle	$LN5@ReadV3
	npad	1
$LL7@ReadV3:

; 2291 : 	{
; 2292 : 		kStream >> sTemp;

	lea	eax, DWORD PTR _sTemp$[esp+148]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAVFStringA@@@Z	; FDataStream::Read

; 2293 : 		if(sTemp == "PROMOTION_OLIGARCHY")

	mov	esi, DWORD PTR _sTemp$[esp+148]
	mov	ecx, OFFSET $SG219340
	mov	eax, esi
$LL59@ReadV3:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN60@ReadV3
	cmp	dl, bl
	je	SHORT $LN61@ReadV3
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN60@ReadV3
	add	eax, 2
	add	ecx, 2
	cmp	dl, bl
	jne	SHORT $LL59@ReadV3
$LN61@ReadV3:
	xor	eax, eax
	jmp	SHORT $LN62@ReadV3
$LN60@ReadV3:
	sbb	eax, eax
	sbb	eax, -1
$LN62@ReadV3:
	cmp	eax, ebx
	jne	SHORT $LN4@ReadV3

; 2294 : 		{
; 2295 : 			bool bTemp;
; 2296 : 			kStream >> bTemp;

	lea	ecx, DWORD PTR _bTemp$219341[esp+148]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2297 : 		}
; 2298 : 		else

	jmp	$LN6@ReadV3
$LN4@ReadV3:

; 2299 : 		{
; 2300 : 			iType = GC.getInfoTypeForString(sTemp);

	push	ebx
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	esi, eax

; 2301 : 			if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN2@ReadV3

; 2302 : 			{
; 2303 : 				bool bValue;
; 2304 : 				kStream >> bValue;

	lea	edx, DWORD PTR _bValue$219344[esp+148]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2305 : 				kPromotions.SetBit(iType, bValue);

	mov	eax, DWORD PTR _bValue$219344[esp+148]
	mov	ecx, DWORD PTR _kPromotions$[esp+144]
	push	eax
	push	esi
	call	?SetBit@CvBitfield@@QAEXI_N@Z		; CvBitfield::SetBit

; 2306 : 			}
; 2307 : 			else

	jmp	SHORT $LN6@ReadV3
$LN2@ReadV3:

; 2308 : 			{
; 2309 : 				CvString szError;

	lea	ecx, DWORD PTR _szError$219346[esp+148]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2310 : #ifdef AUI_WARNING_FIXES
; 2311 : 				szError.Format("LOAD ERROR:  Promotion Type not found: %s", sTemp.GetCString());
; 2312 : #else
; 2313 : 				szError.Format("LOAD ERROR: Promotion Type not found: %s", sTemp);

	mov	ecx, DWORD PTR _sTemp$[esp+148]
	push	ecx
	lea	edx, DWORD PTR _szError$219346[esp+152]
	push	OFFSET $SG219347
	push	edx
	mov	BYTE PTR __$EHRec$[esp+168], 1
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 2314 : #endif
; 2315 : 				GC.LogMessage(szError.GetCString());

	lea	ecx, DWORD PTR _szError$219346[esp+148]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage

; 2316 : 				CvAssertMsg(false, szError);
; 2317 : 				bool bDummy;
; 2318 : 				kStream >> bDummy;

	lea	eax, DWORD PTR _bDummy$219348[esp+148]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2319 : 			}

	lea	ecx, DWORD PTR _szError$219346[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@ReadV3:
	inc	ebp
	cmp	ebp, DWORD PTR _iNumEntries$[esp+148]
	jl	$LL7@ReadV3
$LN5@ReadV3:

; 2320 : 		}
; 2321 : 	}
; 2322 : }

	mov	esi, DWORD PTR _sTemp$[esp+148]
	add	esi, -12				; fffffff4H
	mov	DWORD PTR __$EHRec$[esp+156], -1
	cmp	esi, ebx
	je	SHORT $LN50@ReadV3
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	esi, eax
	je	SHORT $LN50@ReadV3
	cmp	WORD PTR [esi+10], bx
	jne	SHORT $LN50@ReadV3
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN50@ReadV3:
	mov	DWORD PTR _sTemp$[esp+148], ebx
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	mov	ecx, DWORD PTR __$EHRec$[esp+148]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 132				; 00000084H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReadV3@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z$0:
	lea	ecx, DWORD PTR _sTemp$[ebp]
	jmp	??1FStringA@@QAE@XZ			; FStringA::~FStringA
__unwindfunclet$?ReadV3@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z$1:
	lea	ecx, DWORD PTR _szError$219346[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ReadV3@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ReadV3@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ReadV3@PromotionArrayHelpers@@YAXAAVFDataStream@@AAVCvBitfield@@@Z ENDP ; PromotionArrayHelpers::ReadV3
PUBLIC	??0?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@XZ ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@0@Z ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@0@Z PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@2@0@Z ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAEXXZ ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvPromotionEntry@@@@YAXAAPAVCvPromotionEntry@@@Z ; SAFE_DELETE<CvPromotionEntry>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvPromotionEntry@@@@YAXAAPAVCvPromotionEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvPromotionEntry@@@@YAXAAPAVCvPromotionEntry@@@Z PROC ; SAFE_DELETE<CvPromotionEntry>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET
	mov	ecx, esi
	call	??1CvPromotionEntry@@QAE@XZ		; CvPromotionEntry::~CvPromotionEntry
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvPromotionEntry@@@@YAXAAPAVCvPromotionEntry@@@Z ENDP ; SAFE_DELETE<CvPromotionEntry>
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil
	pop	esi
$LN9@Uninit_fil:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@XZ ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::~vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::~vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::~vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEXXZ ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::clear
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@4
	pop	esi
$LN13@unchecked_@4:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	??0CvPromotionXMLEntries@@QAE@XZ		; CvPromotionXMLEntries::CvPromotionXMLEntries
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpromotionclasses.cpp
;	COMDAT ??0CvPromotionXMLEntries@@QAE@XZ
_TEXT	SEGMENT
??0CvPromotionXMLEntries@@QAE@XZ PROC			; CvPromotionXMLEntries::CvPromotionXMLEntries, COMDAT
; _this$ = ecx

; 1960 : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 1961 : 
; 1962 : }

	ret	0
??0CvPromotionXMLEntries@@QAE@XZ ENDP			; CvPromotionXMLEntries::CvPromotionXMLEntries
_TEXT	ENDS
PUBLIC	?DeleteArray@CvPromotionXMLEntries@@QAEXXZ	; CvPromotionXMLEntries::DeleteArray
; Function compile flags: /Ogtpy
;	COMDAT ?DeleteArray@CvPromotionXMLEntries@@QAEXXZ
_TEXT	SEGMENT
?DeleteArray@CvPromotionXMLEntries@@QAEXXZ PROC		; CvPromotionXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 1998 : {

	push	ebx
	mov	ebx, ecx
	push	esi

; 1999 : 	for(std::vector<CvPromotionEntry*>::iterator it = m_paPromotionEntries.begin(); it != m_paPromotionEntries.end(); ++it)

	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@DeleteArra
	npad	3
$LL14@DeleteArra:

; 2000 : 	{
; 2001 : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@DeleteArra
	mov	ecx, edi
	call	??1CvPromotionEntry@@QAE@XZ		; CvPromotionEntry::~CvPromotionEntry
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@DeleteArra:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@DeleteArra
$LN1@DeleteArra:

; 2002 : 	}
; 2003 : 
; 2004 : 	m_paPromotionEntries.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN51@DeleteArra
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN76@DeleteArra
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN76@DeleteArra:
	mov	DWORD PTR [ebx+8], edi
$LN51@DeleteArra:
	pop	edi
	pop	esi
	pop	ebx

; 2005 : }

	ret	0
?DeleteArray@CvPromotionXMLEntries@@QAEXXZ ENDP		; CvPromotionXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$215406 = 16					; size = 4
__Tmp$215396 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$215396[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215396[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215396[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$215406[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	??1CvPromotionXMLEntries@@QAE@XZ		; CvPromotionXMLEntries::~CvPromotionXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvPromotionXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPromotionXMLEntries@@QAE@XZ$0
__ehfuncinfo$??1CvPromotionXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvPromotionXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpromotionclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvPromotionXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPromotionXMLEntries@@QAE@XZ PROC			; CvPromotionXMLEntries::~CvPromotionXMLEntries, COMDAT
; _this$ = ecx

; 1966 : {

	push	-1
	push	__ehhandler$??1CvPromotionXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi

; 1967 : 	DeleteArray();

	call	?DeleteArray@CvPromotionXMLEntries@@QAEXXZ ; CvPromotionXMLEntries::DeleteArray

; 1968 : }

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN9@CvPromotio
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@CvPromotio:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPromotionXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvPromotionEntry@@V?$allocator@PAVCvPromotionEntry@@@std@@@std@@QAE@XZ ; std::vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >::~vector<CvPromotionEntry *,std::allocator<CvPromotionEntry *> >
__ehhandler$??1CvPromotionXMLEntries@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvPromotionXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPromotionXMLEntries@@QAE@XZ ENDP			; CvPromotionXMLEntries::~CvPromotionXMLEntries
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back
	xor	eax, eax
	jmp	SHORT $LN10@push_back
$LN9@push_back:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?ChangePromotionAfterCombat@CvUnitPromotions@@QAE?AW4PromotionTypes@@W42@@Z ; CvUnitPromotions::ChangePromotionAfterCombat
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?ChangePromotionAfterCombat@CvUnitPromotions@@QAE?AW4PromotionTypes@@W42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChangePromotionAfterCombat@CvUnitPromotions@@QAE?AW4PromotionTypes@@W42@@Z$0
__ehfuncinfo$?ChangePromotionAfterCombat@CvUnitPromotions@@QAE?AW4PromotionTypes@@W42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ChangePromotionAfterCombat@CvUnitPromotions@@QAE?AW4PromotionTypes@@W42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpromotionclasses.cpp
xdata$x	ENDS
;	COMDAT ?ChangePromotionAfterCombat@CvUnitPromotions@@QAE?AW4PromotionTypes@@W42@@Z
_TEXT	SEGMENT
_iI$219282 = -32					; size = 4
_aPossiblePromotions$ = -28				; size = 16
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
?ChangePromotionAfterCombat@CvUnitPromotions@@QAE?AW4PromotionTypes@@W42@@Z PROC ; CvUnitPromotions::ChangePromotionAfterCombat, COMDAT
; _this$ = ecx

; 2229 : {

	push	-1
	push	__ehhandler$?ChangePromotionAfterCombat@CvUnitPromotions@@QAE?AW4PromotionTypes@@W42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi

; 2230 : 	std::vector<int> aPossiblePromotions;

	xor	esi, esi
	xor	ebx, ebx
	push	edi
	mov	ebp, ecx
	mov	DWORD PTR _aPossiblePromotions$[esp+52], ebx
	mov	DWORD PTR _aPossiblePromotions$[esp+56], esi
	mov	DWORD PTR _aPossiblePromotions$[esp+60], esi

; 2231 : 
; 2232 : #ifdef AUI_WARNING_FIXES
; 2233 : 	for (uint iI = 0; iI < m_pPromotions->GetNumPromotions(); iI++)
; 2234 : #else
; 2235 : 	for (int iI = 0; iI < m_pPromotions->GetNumPromotions(); iI++)

	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+56], esi
	mov	DWORD PTR _iI$219282[esp+48], edi
	test	ecx, -4					; fffffffcH
	jle	$LN5@ChangeProm
	npad	3
$LL152@ChangeProm:

; 2236 : #endif
; 2237 : 	{
; 2238 : 		CvPromotionEntry *pkEntry = m_pPromotions->GetEntry(eIndex);

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _eIndex$[esp+44]
	mov	eax, DWORD PTR [edx+eax*4]

; 2239 : 		if (pkEntry && pkEntry->IsPostCombatRandomPromotion(iI))

	test	eax, eax
	je	SHORT $LN6@ChangeProm
	mov	ecx, DWORD PTR [eax+952]
	test	ecx, ecx
	je	SHORT $LN6@ChangeProm
	cmp	BYTE PTR [ecx+edi], 0
	je	SHORT $LN6@ChangeProm

; 2240 : 		{
; 2241 : 			if (!pkEntry->ArePostCombatPromotionsExclusive() || !IsInUseByPlayer((PromotionTypes)iI, m_pUnit->getOwner()))

	cmp	BYTE PTR [eax+834], 0
	je	SHORT $LN2@ChangeProm
	mov	ecx, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR [ecx+40]
	push	eax
	push	edi
	mov	ecx, ebp
	call	?IsInUseByPlayer@CvUnitPromotions@@AAE_NW4PromotionTypes@@W4PlayerTypes@@@Z ; CvUnitPromotions::IsInUseByPlayer
	test	al, al
	jne	SHORT $LN6@ChangeProm
$LN2@ChangeProm:

; 2242 : 			{
; 2243 : 				aPossiblePromotions.push_back(iI);

	test	ebx, ebx
	jne	SHORT $LN74@ChangeProm
	xor	eax, eax
	jmp	SHORT $LN75@ChangeProm
$LN74@ChangeProm:
	mov	eax, DWORD PTR _aPossiblePromotions$[esp+60]
	sub	eax, ebx
	sar	eax, 2
$LN75@ChangeProm:
	mov	edx, esi
	sub	edx, ebx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN67@ChangeProm
	mov	DWORD PTR [esi], edi
	add	esi, 4
	mov	DWORD PTR _aPossiblePromotions$[esp+56], esi
	jmp	SHORT $LN6@ChangeProm
$LN67@ChangeProm:
	lea	eax, DWORD PTR _iI$219282[esp+48]
	push	eax
	push	1
	push	esi
	lea	ecx, DWORD PTR _aPossiblePromotions$[esp+60]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	mov	esi, DWORD PTR _aPossiblePromotions$[esp+56]
	mov	ebx, DWORD PTR _aPossiblePromotions$[esp+52]
$LN6@ChangeProm:
	mov	eax, DWORD PTR [ebp+8]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	inc	edi
	sar	ecx, 2
	cmp	edi, ecx
	mov	DWORD PTR _iI$219282[esp+48], edi
	jl	$LL152@ChangeProm
$LN5@ChangeProm:

; 2244 : 			}
; 2245 : 		}
; 2246 : 	}
; 2247 : 
; 2248 : 	int iNumChoices = aPossiblePromotions.size();

	sub	esi, ebx
	sar	esi, 2

; 2249 : 	if (iNumChoices > 0)

	test	esi, esi
	jle	SHORT $LN1@ChangeProm

; 2250 : 	{
; 2251 : 		int iChoice = GC.getGame().getJonRandNum(iNumChoices, "Random Promotion Pick");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	OFFSET $SG219294
	push	esi
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum

; 2252 : 		return (PromotionTypes)aPossiblePromotions[iChoice];

	mov	esi, DWORD PTR [ebx+eax*4]
	test	ebx, ebx
	je	SHORT $LN138@ChangeProm
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN138@ChangeProm:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 2256 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	4
$LN1@ChangeProm:

; 2253 : 	}
; 2254 : 
; 2255 : 	return NO_PROMOTION;

	test	ebx, ebx
	je	SHORT $LN145@ChangeProm
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN145@ChangeProm:

; 2256 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	pop	ebp
	or	eax, -1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ChangePromotionAfterCombat@CvUnitPromotions@@QAE?AW4PromotionTypes@@W42@@Z$0:
	lea	ecx, DWORD PTR _aPossiblePromotions$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?ChangePromotionAfterCombat@CvUnitPromotions@@QAE?AW4PromotionTypes@@W42@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ChangePromotionAfterCombat@CvUnitPromotions@@QAE?AW4PromotionTypes@@W42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ChangePromotionAfterCombat@CvUnitPromotions@@QAE?AW4PromotionTypes@@W42@@Z ENDP ; CvUnitPromotions::ChangePromotionAfterCombat
END
