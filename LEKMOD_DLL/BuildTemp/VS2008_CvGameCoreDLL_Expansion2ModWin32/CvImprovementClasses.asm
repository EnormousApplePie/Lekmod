; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	s:\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvImprovementClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG218069 DB	'ArtDefineTag', 00H
	ORG $+3
$SG218070 DB	'GoldMaintenance', 00H
$SG218071 DB	'CultureBombRadius', 00H
	ORG $+2
$SG218072 DB	'CultureBombRadiusNeutral', 00H
	ORG $+3
$SG218073 DB	'RequiresXAdjacentLand', 00H
	ORG $+2
$SG218074 DB	'CultureAdjacentSameType', 00H
$SG218075 DB	'HillsMakesValid', 00H
$SG218076 DB	'WaterAdjacencyMakesValid', 00H
	ORG $+3
$SG218077 DB	'FreshWaterMakesValid', 00H
	ORG $+3
$SG218078 DB	'RiverSideMakesValid', 00H
$SG218079 DB	'NoFreshWater', 00H
	ORG $+3
$SG218080 DB	'RequiresFlatlands', 00H
	ORG $+2
$SG218081 DB	'RequiresFlatlandsOrFreshWater', 00H
	ORG $+2
$SG218082 DB	'RequiresFeature', 00H
$SG218083 DB	'RequiresImprovement', 00H
$SG218084 DB	'RemovesResource', 00H
$SG218085 DB	'PromptWhenComplete', 00H
	ORG $+1
$SG218086 DB	'Water', 00H
	ORG $+2
$SG218087 DB	'Coastal', 00H
$SG218088 DB	'DestroyedWhenPillaged', 00H
	ORG $+2
$SG218089 DB	'DisplacePillager', 00H
	ORG $+3
$SG218090 DB	'BuildableOnResources', 00H
	ORG $+3
$SG218091 DB	'BarbarianCamp', 00H
	ORG $+2
$SG218092 DB	'Goody', 00H
	ORG $+2
$SG218093 DB	'Permanent', 00H
	ORG $+2
$SG218094 DB	'TilesPerGoody', 00H
	ORG $+2
$SG218095 DB	'GoodyRange', 00H
	ORG $+1
$SG218096 DB	'FeatureGrowth', 00H
	ORG $+2
$SG218097 DB	'UpgradeTime', 00H
$SG218098 DB	'RiverSideUpgradeMod', 00H
$SG218099 DB	'CoastalLandUpgradeMod', 00H
	ORG $+2
$SG218100 DB	'HillsUpgradeMod', 00H
$SG218101 DB	'FreshWaterUpgradeMod', 00H
	ORG $+3
$SG218102 DB	'DefenseModifier', 00H
$SG218103 DB	'DefenseModifierGlobal', 00H
	ORG $+2
$SG218104 DB	'NearbyEnemyDamage', 00H
	ORG $+2
$SG218105 DB	'PillageGold', 00H
$SG218106 DB	'OutsideBorders', 00H
	ORG $+1
$SG218107 DB	'InAdjacentFriendly', 00H
	ORG $+1
$SG218108 DB	'IgnoreOwnership', 00H
$SG218109 DB	'OnlyCityStateTerritory', 00H
	ORG $+1
$SG218110 DB	'NoTwoAdjacent', 00H
	ORG $+2
$SG218111 DB	'AdjacentLuxury', 00H
	ORG $+1
$SG218112 DB	'AllowsWalkWater', 00H
$SG218113 DB	'AllowsSailLand', 00H
	ORG $+1
$SG218114 DB	'CreatedByGreatPerson', 00H
	ORG $+3
$SG218115 DB	'SpecificCivRequired', 00H
$SG218116 DB	'ResourceExtractionMod', 00H
	ORG $+2
$SG218117 DB	'LuxuryCopiesSiphonedFromMinor', 00H
	ORG $+2
$SG218119 DB	'CivilizationType', 00H
	ORG $+3
$SG218122 DB	'WorldSoundscapeAudioScript', 00H
	ORG $+1
$SG218125 DB	'Warning: Missing soundscape definition in XML for featur'
	DB	'e: ''%s''', 00H
$SG218127 DB	'ImprovementPillage', 00H
	ORG $+1
$SG218129 DB	'ImprovementUpgrade', 00H
	ORG $+1
$SG218132 DB	'ImprovementType', 00H
$SG218133 DB	'TerrainType', 00H
$SG218134 DB	'Improvement_ValidTerrains', 00H
	ORG $+2
$SG218135 DB	'Terrains', 00H
	ORG $+3
$SG218136 DB	'ImprovementType', 00H
$SG218137 DB	'FeatureType', 00H
$SG218138 DB	'Improvement_ValidFeatures', 00H
	ORG $+2
$SG218139 DB	'Features', 00H
	ORG $+3
$SG218140 DB	'ImprovementType', 00H
$SG218141 DB	'PrereqImprovement', 00H
	ORG $+2
$SG218142 DB	'Improvement_ValidImprovements', 00H
	ORG $+2
$SG218143 DB	'Improvements', 00H
	ORG $+3
$SG218144 DB	'ImprovementType', 00H
$SG218145 DB	'Improvement_Yields', 00H
	ORG $+1
$SG218146 DB	'ImprovementType', 00H
$SG218147 DB	'Improvement_YieldPerEra', 00H
$SG218148 DB	'ImprovementType', 00H
$SG218149 DB	'Improvement_AdjacentCityYields', 00H
	ORG $+1
$SG218150 DB	'ImprovementType', 00H
$SG218151 DB	'Improvement_AdjacentMountainYieldChanges', 00H
	ORG $+3
$SG218152 DB	'ImprovementType', 00H
$SG218153 DB	'Improvement_CoastalLandYields', 00H
	ORG $+2
$SG218154 DB	'ImprovementType', 00H
$SG218155 DB	'Improvement_FreshWaterYields', 00H
	ORG $+3
$SG218156 DB	'ImprovementType', 00H
$SG218157 DB	'Improvement_HillsYields', 00H
$SG218158 DB	'ImprovementType', 00H
$SG218159 DB	'Improvement_RiverSideYields', 00H
$SG218160 DB	'ImprovementType', 00H
$SG218161 DB	'Improvement_PrereqNatureYields', 00H
	ORG $+1
$SG218162 DB	'ImprovementType', 00H
$SG218163 DB	'Improvement_Flavors', 00H
$SG218165 DB	'Resources', 00H
	ORG $+2
$SG218179 DB	'Improvements - ResourceTypes', 00H
	ORG $+3
$SG218182 DB	'select Resources.ID, ResourceType, ResourceMakesValid, R'
	DB	'esourceTrade, DiscoveryRand from Improvement_ResourceTypes in'
	DB	'ner join Resources on ResourceType = Resources.Type where Imp'
	DB	'rovementType = ?', 00H
	ORG $+1
$SG218184 DB	'Improvements - YieldResults', 00H
$SG218187 DB	'select Yields.ID, Yield from Improvement_ResourceType_Yi'
	DB	'elds inner join Yields on YieldType = Yields.Type where Impro'
	DB	'vementType = ? and ResourceType = ?', 00H
	ORG $+3
$SG218192 DB	'ID', 00H
	ORG $+1
$SG218195 DB	'ResourceType', 00H
	ORG $+3
$SG218196 DB	'ResourceMakesValid', 00H
	ORG $+1
$SG218197 DB	'ResourceTrade', 00H
	ORG $+2
$SG218198 DB	'DiscoveryRand', 00H
	ORG $+2
$SG218199 DB	'QuantityRequirement', 00H
$SG218201 DB	'Yields', 00H
	ORG $+1
$SG218206 DB	'ID', 00H
	ORG $+1
$SG218208 DB	'Yield', 00H
	ORG $+2
$SG218210 DB	'Yields', 00H
	ORG $+1
$SG218213 DB	'Improvements - TechYieldChanges', 00H
$SG218224 DB	'Improvements - TechNoFreshWaterYieldChanges', 00H
$SG218216 DB	'select Yields.ID as YieldID, Technologies.ID as TechID, '
	DB	'Yield from Improvement_TechYieldChanges inner join Yields on '
	DB	'YieldType = Yields.Type inner join Technologies on TechType ='
	DB	' Technologies.Type where ImprovementType = ?', 00H
	ORG $+1
$SG218227 DB	'select Yields.ID as YieldID, Technologies.ID as TechID, '
	DB	'Yield from Improvement_TechNoFreshWaterYieldChanges inner joi'
	DB	'n Yields on YieldType = Yields.Type inner join Technologies o'
	DB	'n TechType = Technologies.Type where ImprovementType = ?', 00H
	ORG $+1
$SG218235 DB	'Improvements - TechFreshWaterYieldChanges', 00H
	ORG $+2
$SG218238 DB	'select Yields.ID as YieldID, Technologies.ID as TechID, '
	DB	'Yield from Improvement_TechFreshWaterYieldChanges inner join '
	DB	'Yields on YieldType = Yields.Type inner join Technologies on '
	DB	'TechType = Technologies.Type where ImprovementType = ?', 00H
	ORG $+3
$SG218246 DB	'Routes', 00H
	ORG $+1
$SG218248 DB	'Improvements - RouteYieldChanges', 00H
	ORG $+3
$SG218251 DB	'select Yields.ID as YieldID, Routes.ID as RouteID, Yield'
	DB	' from Improvement_RouteYieldChanges inner join Yields on Yiel'
	DB	'dType = Yields.Type inner join Routes on RouteType = Routes.T'
	DB	'ype where ImprovementType = ?;', 00H
	ORG $+3
$SG218790 DB	'LOAD ERROR: Improvement Type not found', 00H
	ORG $+1
$SG218829 DB	'LOAD ERROR: Improvement Type not found: %08x', 00H
CONST	ENDS
PUBLIC	?Remark@@YA_NHPBDZZ				; Remark
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
;	COMDAT ?Remark@@YA_NHPBDZZ
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?Remark@@YA_NHPBDZZ PROC				; Remark, COMDAT

; 21   : REMARK_GROUP("CvImprovementClasses");

	xor	al, al
	ret	0
?Remark@@YA_NHPBDZZ ENDP				; Remark
_TEXT	ENDS
PUBLIC	??0CvImprovementResourceInfo@@QAE@XZ		; CvImprovementResourceInfo::CvImprovementResourceInfo
; Function compile flags: /Ogtpy
;	COMDAT ??0CvImprovementResourceInfo@@QAE@XZ
_TEXT	SEGMENT
??0CvImprovementResourceInfo@@QAE@XZ PROC		; CvImprovementResourceInfo::CvImprovementResourceInfo, COMDAT
; _this$ = ecx

; 32   : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], cl
	mov	BYTE PTR [eax+5], cl
	mov	DWORD PTR [eax+8], ecx

; 33   : }

	ret	0
??0CvImprovementResourceInfo@@QAE@XZ ENDP		; CvImprovementResourceInfo::CvImprovementResourceInfo
_TEXT	ENDS
PUBLIC	?getDiscoverRand@CvImprovementResourceInfo@@QBEHXZ ; CvImprovementResourceInfo::getDiscoverRand
; Function compile flags: /Ogtpy
;	COMDAT ?getDiscoverRand@CvImprovementResourceInfo@@QBEHXZ
_TEXT	SEGMENT
?getDiscoverRand@CvImprovementResourceInfo@@QBEHXZ PROC	; CvImprovementResourceInfo::getDiscoverRand, COMDAT
; _this$ = ecx

; 42   : 	return m_iDiscoverRand;

	mov	eax, DWORD PTR [ecx]

; 43   : }

	ret	0
?getDiscoverRand@CvImprovementResourceInfo@@QBEHXZ ENDP	; CvImprovementResourceInfo::getDiscoverRand
_TEXT	ENDS
PUBLIC	?isResourceMakesValid@CvImprovementResourceInfo@@QBE_NXZ ; CvImprovementResourceInfo::isResourceMakesValid
; Function compile flags: /Ogtpy
;	COMDAT ?isResourceMakesValid@CvImprovementResourceInfo@@QBE_NXZ
_TEXT	SEGMENT
?isResourceMakesValid@CvImprovementResourceInfo@@QBE_NXZ PROC ; CvImprovementResourceInfo::isResourceMakesValid, COMDAT
; _this$ = ecx

; 47   : 	return m_bResourceMakesValid;

	mov	al, BYTE PTR [ecx+4]

; 48   : }

	ret	0
?isResourceMakesValid@CvImprovementResourceInfo@@QBE_NXZ ENDP ; CvImprovementResourceInfo::isResourceMakesValid
_TEXT	ENDS
PUBLIC	?isResourceTrade@CvImprovementResourceInfo@@QBE_NXZ ; CvImprovementResourceInfo::isResourceTrade
; Function compile flags: /Ogtpy
;	COMDAT ?isResourceTrade@CvImprovementResourceInfo@@QBE_NXZ
_TEXT	SEGMENT
?isResourceTrade@CvImprovementResourceInfo@@QBE_NXZ PROC ; CvImprovementResourceInfo::isResourceTrade, COMDAT
; _this$ = ecx

; 52   : 	return m_bResourceTrade;

	mov	al, BYTE PTR [ecx+5]

; 53   : }

	ret	0
?isResourceTrade@CvImprovementResourceInfo@@QBE_NXZ ENDP ; CvImprovementResourceInfo::isResourceTrade
_TEXT	ENDS
PUBLIC	?getYieldChange@CvImprovementResourceInfo@@QBEHH@Z ; CvImprovementResourceInfo::getYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?getYieldChange@CvImprovementResourceInfo@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?getYieldChange@CvImprovementResourceInfo@@QBEHH@Z PROC	; CvImprovementResourceInfo::getYieldChange, COMDAT
; _this$ = ecx

; 57   : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 58   : 	CvAssertMsg(i > -1, "Index out of bounds");
; 59   : 	return m_piYieldChange ? m_piYieldChange[i] : -1;

	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN3@getYieldCh
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 60   : }

	ret	4
$LN3@getYieldCh:

; 57   : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 58   : 	CvAssertMsg(i > -1, "Index out of bounds");
; 59   : 	return m_piYieldChange ? m_piYieldChange[i] : -1;

	or	eax, -1

; 60   : }

	ret	4
?getYieldChange@CvImprovementResourceInfo@@QBEHH@Z ENDP	; CvImprovementResourceInfo::getYieldChange
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File s:\msvs2008\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ	; CvImprovementEntry::GetGoldMaintenance
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
;	COMDAT ?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetGoldMaintenance, COMDAT
; _this$ = ecx

; 537  : 	return m_iGoldMaintenance;

	mov	eax, DWORD PTR [ecx+260]

; 538  : }

	ret	0
?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetGoldMaintenance
_TEXT	ENDS
PUBLIC	?GetCultureBombRadius@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureBombRadius
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureBombRadius@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCultureBombRadius@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetCultureBombRadius, COMDAT
; _this$ = ecx

; 543  : 	return m_iCultureBombRadius;

	mov	eax, DWORD PTR [ecx+264]

; 544  : }

	ret	0
?GetCultureBombRadius@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetCultureBombRadius
_TEXT	ENDS
PUBLIC	?GetCultureBombRadiusNeutral@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureBombRadiusNeutral
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureBombRadiusNeutral@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCultureBombRadiusNeutral@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetCultureBombRadiusNeutral, COMDAT
; _this$ = ecx

; 548  : 	return m_iCultureBombRadiusNeutral;

	mov	eax, DWORD PTR [ecx+268]

; 549  : }

	ret	0
?GetCultureBombRadiusNeutral@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetCultureBombRadiusNeutral
_TEXT	ENDS
PUBLIC	?GetRequiresXAdjacentLand@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetRequiresXAdjacentLand
; Function compile flags: /Ogtpy
;	COMDAT ?GetRequiresXAdjacentLand@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRequiresXAdjacentLand@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetRequiresXAdjacentLand, COMDAT
; _this$ = ecx

; 554  : 	return m_iRequiresXAdjacentLand;

	mov	eax, DWORD PTR [ecx+340]

; 555  : }

	ret	0
?GetRequiresXAdjacentLand@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetRequiresXAdjacentLand
_TEXT	ENDS
PUBLIC	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType
; Function compile flags: /Ogtpy
;	COMDAT ?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetCultureAdjacentSameType, COMDAT
; _this$ = ecx

; 560  : 	return m_iCultureAdjacentSameType;

	mov	eax, DWORD PTR [ecx+272]

; 561  : }

	ret	0
?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetCultureAdjacentSameType
_TEXT	ENDS
PUBLIC	?GetTilesPerGoody@CvImprovementEntry@@QBEHXZ	; CvImprovementEntry::GetTilesPerGoody
; Function compile flags: /Ogtpy
;	COMDAT ?GetTilesPerGoody@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetTilesPerGoody@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetTilesPerGoody, COMDAT
; _this$ = ecx

; 566  : 	return m_iTilesPerGoody;

	mov	eax, DWORD PTR [ecx+276]

; 567  : }

	ret	0
?GetTilesPerGoody@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetTilesPerGoody
_TEXT	ENDS
PUBLIC	?GetGoodyUniqueRange@CvImprovementEntry@@QBEHXZ	; CvImprovementEntry::GetGoodyUniqueRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetGoodyUniqueRange@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGoodyUniqueRange@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetGoodyUniqueRange, COMDAT
; _this$ = ecx

; 572  : 	return m_iGoodyUniqueRange;

	mov	eax, DWORD PTR [ecx+280]

; 573  : }

	ret	0
?GetGoodyUniqueRange@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetGoodyUniqueRange
_TEXT	ENDS
PUBLIC	?GetFeatureGrowthProbability@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetFeatureGrowthProbability
; Function compile flags: /Ogtpy
;	COMDAT ?GetFeatureGrowthProbability@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFeatureGrowthProbability@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetFeatureGrowthProbability, COMDAT
; _this$ = ecx

; 578  : 	return m_iFeatureGrowthProbability;

	mov	eax, DWORD PTR [ecx+284]

; 579  : }

	ret	0
?GetFeatureGrowthProbability@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetFeatureGrowthProbability
_TEXT	ENDS
PUBLIC	?GetUpgradeTime@CvImprovementEntry@@QBEHXZ	; CvImprovementEntry::GetUpgradeTime
; Function compile flags: /Ogtpy
;	COMDAT ?GetUpgradeTime@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUpgradeTime@CvImprovementEntry@@QBEHXZ PROC		; CvImprovementEntry::GetUpgradeTime, COMDAT
; _this$ = ecx

; 584  : 	return m_iUpgradeTime;

	mov	eax, DWORD PTR [ecx+288]

; 585  : }

	ret	0
?GetUpgradeTime@CvImprovementEntry@@QBEHXZ ENDP		; CvImprovementEntry::GetUpgradeTime
_TEXT	ENDS
PUBLIC	?GetRiverSideUpgradeMod@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetRiverSideUpgradeMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetRiverSideUpgradeMod@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetRiverSideUpgradeMod@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetRiverSideUpgradeMod, COMDAT
; _this$ = ecx

; 590  : 	return m_iRiverSideUpgradeMod;

	mov	eax, DWORD PTR [ecx+292]

; 591  : }

	ret	0
?GetRiverSideUpgradeMod@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetRiverSideUpgradeMod
_TEXT	ENDS
PUBLIC	?GetCoastalLandUpgradeMod@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCoastalLandUpgradeMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetCoastalLandUpgradeMod@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetCoastalLandUpgradeMod@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetCoastalLandUpgradeMod, COMDAT
; _this$ = ecx

; 596  : 	return m_iCoastalLandUpgradeMod;

	mov	eax, DWORD PTR [ecx+296]

; 597  : }

	ret	0
?GetCoastalLandUpgradeMod@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetCoastalLandUpgradeMod
_TEXT	ENDS
PUBLIC	?GetHillsUpgradeMod@CvImprovementEntry@@QBEHXZ	; CvImprovementEntry::GetHillsUpgradeMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetHillsUpgradeMod@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetHillsUpgradeMod@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetHillsUpgradeMod, COMDAT
; _this$ = ecx

; 602  : 	return m_iHillsUpgradeMod;

	mov	eax, DWORD PTR [ecx+300]

; 603  : }

	ret	0
?GetHillsUpgradeMod@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetHillsUpgradeMod
_TEXT	ENDS
PUBLIC	?GetFreshWaterUpgradeMod@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetFreshWaterUpgradeMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreshWaterUpgradeMod@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFreshWaterUpgradeMod@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetFreshWaterUpgradeMod, COMDAT
; _this$ = ecx

; 608  : 	return m_iFreshWaterUpgradeMod;

	mov	eax, DWORD PTR [ecx+304]

; 609  : }

	ret	0
?GetFreshWaterUpgradeMod@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetFreshWaterUpgradeMod
_TEXT	ENDS
PUBLIC	?GetDefenseModifier@CvImprovementEntry@@QBEHXZ	; CvImprovementEntry::GetDefenseModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetDefenseModifier@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetDefenseModifier@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetDefenseModifier, COMDAT
; _this$ = ecx

; 614  : 	return m_iDefenseModifier;

	mov	eax, DWORD PTR [ecx+308]

; 615  : }

	ret	0
?GetDefenseModifier@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetDefenseModifier
_TEXT	ENDS
PUBLIC	?GetDefenseModifierGlobal@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetDefenseModifierGlobal
; Function compile flags: /Ogtpy
;	COMDAT ?GetDefenseModifierGlobal@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetDefenseModifierGlobal@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetDefenseModifierGlobal, COMDAT
; _this$ = ecx

; 620  : 	return m_iDefenseModifierGlobal;

	mov	eax, DWORD PTR [ecx+312]

; 621  : }

	ret	0
?GetDefenseModifierGlobal@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetDefenseModifierGlobal
_TEXT	ENDS
PUBLIC	?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetNearbyEnemyDamage
; Function compile flags: /Ogtpy
;	COMDAT ?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetNearbyEnemyDamage, COMDAT
; _this$ = ecx

; 626  : 	return m_iNearbyEnemyDamage;

	mov	eax, DWORD PTR [ecx+316]

; 627  : }

	ret	0
?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetNearbyEnemyDamage
_TEXT	ENDS
PUBLIC	?GetPillageGold@CvImprovementEntry@@QBEHXZ	; CvImprovementEntry::GetPillageGold
; Function compile flags: /Ogtpy
;	COMDAT ?GetPillageGold@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetPillageGold@CvImprovementEntry@@QBEHXZ PROC		; CvImprovementEntry::GetPillageGold, COMDAT
; _this$ = ecx

; 632  : 	return m_iPillageGold;

	mov	eax, DWORD PTR [ecx+320]

; 633  : }

	ret	0
?GetPillageGold@CvImprovementEntry@@QBEHXZ ENDP		; CvImprovementEntry::GetPillageGold
_TEXT	ENDS
PUBLIC	?GetResourceExtractionMod@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetResourceExtractionMod
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceExtractionMod@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetResourceExtractionMod@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetResourceExtractionMod, COMDAT
; _this$ = ecx

; 638  : 	return m_iResourceExtractionMod;

	mov	eax, DWORD PTR [ecx+324]

; 639  : }

	ret	0
?GetResourceExtractionMod@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetResourceExtractionMod
_TEXT	ENDS
PUBLIC	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
; Function compile flags: /Ogtpy
;	COMDAT ?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor, COMDAT
; _this$ = ecx

; 644  : 	return m_iLuxuryCopiesSiphonedFromMinor;

	mov	eax, DWORD PTR [ecx+328]

; 645  : }

	ret	0
?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
_TEXT	ENDS
PUBLIC	?GetImprovementPillage@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetImprovementPillage
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementPillage@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetImprovementPillage@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetImprovementPillage, COMDAT
; _this$ = ecx

; 650  : 	return m_iImprovementPillage;

	mov	eax, DWORD PTR [ecx+332]

; 651  : }

	ret	0
?GetImprovementPillage@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetImprovementPillage
_TEXT	ENDS
PUBLIC	?SetImprovementPillage@CvImprovementEntry@@QAEXH@Z ; CvImprovementEntry::SetImprovementPillage
; Function compile flags: /Ogtpy
;	COMDAT ?SetImprovementPillage@CvImprovementEntry@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?SetImprovementPillage@CvImprovementEntry@@QAEXH@Z PROC	; CvImprovementEntry::SetImprovementPillage, COMDAT
; _this$ = ecx

; 656  : 	m_iImprovementPillage = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+332], eax

; 657  : }

	ret	4
?SetImprovementPillage@CvImprovementEntry@@QAEXH@Z ENDP	; CvImprovementEntry::SetImprovementPillage
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File s:\msvs2008\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetImprovementUpgrade
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
;	COMDAT ?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ PROC	; CvImprovementEntry::GetImprovementUpgrade, COMDAT
; _this$ = ecx

; 662  : 	return m_iImprovementUpgrade;

	mov	eax, DWORD PTR [ecx+336]

; 663  : }

	ret	0
?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ ENDP	; CvImprovementEntry::GetImprovementUpgrade
_TEXT	ENDS
PUBLIC	?SetImprovementUpgrade@CvImprovementEntry@@QAEXH@Z ; CvImprovementEntry::SetImprovementUpgrade
; Function compile flags: /Ogtpy
;	COMDAT ?SetImprovementUpgrade@CvImprovementEntry@@QAEXH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?SetImprovementUpgrade@CvImprovementEntry@@QAEXH@Z PROC	; CvImprovementEntry::SetImprovementUpgrade, COMDAT
; _this$ = ecx

; 668  : 	m_iImprovementUpgrade = i;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	DWORD PTR [ecx+336], eax

; 669  : }

	ret	4
?SetImprovementUpgrade@CvImprovementEntry@@QAEXH@Z ENDP	; CvImprovementEntry::SetImprovementUpgrade
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\stdexcept
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
PUBLIC	?IsHillsMakesValid@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsHillsMakesValid
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
;	COMDAT ?IsHillsMakesValid@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsHillsMakesValid@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsHillsMakesValid, COMDAT
; _this$ = ecx

; 674  : 	return m_bHillsMakesValid;

	mov	al, BYTE PTR [ecx+344]

; 675  : }

	ret	0
?IsHillsMakesValid@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsHillsMakesValid
_TEXT	ENDS
PUBLIC	?IsWaterAdjacencyMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsWaterAdjacencyMakesValid
; Function compile flags: /Ogtpy
;	COMDAT ?IsWaterAdjacencyMakesValid@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsWaterAdjacencyMakesValid@CvImprovementEntry@@QBE_NXZ PROC ; CvImprovementEntry::IsWaterAdjacencyMakesValid, COMDAT
; _this$ = ecx

; 679  : 	return m_bWaterAdjacencyMakesValid;

	mov	al, BYTE PTR [ecx+345]

; 680  : }

	ret	0
?IsWaterAdjacencyMakesValid@CvImprovementEntry@@QBE_NXZ ENDP ; CvImprovementEntry::IsWaterAdjacencyMakesValid
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	?IsFreshWaterMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsFreshWaterMakesValid
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
;	COMDAT ?IsFreshWaterMakesValid@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsFreshWaterMakesValid@CvImprovementEntry@@QBE_NXZ PROC ; CvImprovementEntry::IsFreshWaterMakesValid, COMDAT
; _this$ = ecx

; 685  : 	return m_bFreshWaterMakesValid;

	mov	al, BYTE PTR [ecx+346]

; 686  : }

	ret	0
?IsFreshWaterMakesValid@CvImprovementEntry@@QBE_NXZ ENDP ; CvImprovementEntry::IsFreshWaterMakesValid
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?IsRiverSideMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRiverSideMakesValid
; Function compile flags: /Ogtpy
;	COMDAT ?IsRiverSideMakesValid@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRiverSideMakesValid@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsRiverSideMakesValid, COMDAT
; _this$ = ecx

; 691  : 	return m_bRiverSideMakesValid;

	mov	al, BYTE PTR [ecx+347]

; 692  : }

	ret	0
?IsRiverSideMakesValid@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsRiverSideMakesValid
_TEXT	ENDS
PUBLIC	?IsNoFreshWater@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsNoFreshWater
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoFreshWater@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNoFreshWater@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsNoFreshWater, COMDAT
; _this$ = ecx

; 697  : 	return m_bNoFreshWater;

	mov	al, BYTE PTR [ecx+348]

; 698  : }

	ret	0
?IsNoFreshWater@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsNoFreshWater
_TEXT	ENDS
PUBLIC	?IsRequiresFlatlands@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresFlatlands
; Function compile flags: /Ogtpy
;	COMDAT ?IsRequiresFlatlands@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRequiresFlatlands@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsRequiresFlatlands, COMDAT
; _this$ = ecx

; 703  : 	return m_bRequiresFlatlands;

	mov	al, BYTE PTR [ecx+349]

; 704  : }

	ret	0
?IsRequiresFlatlands@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsRequiresFlatlands
_TEXT	ENDS
PUBLIC	?IsRequiresFlatlandsOrFreshWater@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresFlatlandsOrFreshWater
; Function compile flags: /Ogtpy
;	COMDAT ?IsRequiresFlatlandsOrFreshWater@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRequiresFlatlandsOrFreshWater@CvImprovementEntry@@QBE_NXZ PROC ; CvImprovementEntry::IsRequiresFlatlandsOrFreshWater, COMDAT
; _this$ = ecx

; 709  : 	return m_bRequiresFlatlandsOrFreshWater;

	mov	al, BYTE PTR [ecx+350]

; 710  : }

	ret	0
?IsRequiresFlatlandsOrFreshWater@CvImprovementEntry@@QBE_NXZ ENDP ; CvImprovementEntry::IsRequiresFlatlandsOrFreshWater
_TEXT	ENDS
PUBLIC	?IsRequiresFeature@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsRequiresFeature
; Function compile flags: /Ogtpy
;	COMDAT ?IsRequiresFeature@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRequiresFeature@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsRequiresFeature, COMDAT
; _this$ = ecx

; 715  : 	return m_bRequiresFeature;

	mov	al, BYTE PTR [ecx+351]

; 716  : }

	ret	0
?IsRequiresFeature@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsRequiresFeature
_TEXT	ENDS
PUBLIC	?IsRequiresImprovement@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresImprovement
; Function compile flags: /Ogtpy
;	COMDAT ?IsRequiresImprovement@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRequiresImprovement@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsRequiresImprovement, COMDAT
; _this$ = ecx

; 721  : 	return m_bRequiresImprovement;

	mov	al, BYTE PTR [ecx+352]

; 722  : }

	ret	0
?IsRequiresImprovement@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsRequiresImprovement
_TEXT	ENDS
PUBLIC	?IsRemovesResource@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsRemovesResource
; Function compile flags: /Ogtpy
;	COMDAT ?IsRemovesResource@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRemovesResource@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsRemovesResource, COMDAT
; _this$ = ecx

; 727  : 	return m_bRemovesResource;

	mov	al, BYTE PTR [ecx+353]

; 728  : }

	ret	0
?IsRemovesResource@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsRemovesResource
_TEXT	ENDS
PUBLIC	?IsPromptWhenComplete@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsPromptWhenComplete
; Function compile flags: /Ogtpy
;	COMDAT ?IsPromptWhenComplete@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsPromptWhenComplete@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsPromptWhenComplete, COMDAT
; _this$ = ecx

; 733  : 	return m_bPromptWhenComplete;

	mov	al, BYTE PTR [ecx+354]

; 734  : }

	ret	0
?IsPromptWhenComplete@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsPromptWhenComplete
_TEXT	ENDS
PUBLIC	?IsWater@CvImprovementEntry@@QBE_NXZ		; CvImprovementEntry::IsWater
; Function compile flags: /Ogtpy
;	COMDAT ?IsWater@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsWater@CvImprovementEntry@@QBE_NXZ PROC		; CvImprovementEntry::IsWater, COMDAT
; _this$ = ecx

; 739  : 	return m_bWater;

	mov	al, BYTE PTR [ecx+355]

; 740  : }

	ret	0
?IsWater@CvImprovementEntry@@QBE_NXZ ENDP		; CvImprovementEntry::IsWater
_TEXT	ENDS
PUBLIC	?IsCoastal@CvImprovementEntry@@QBE_NXZ		; CvImprovementEntry::IsCoastal
; Function compile flags: /Ogtpy
;	COMDAT ?IsCoastal@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsCoastal@CvImprovementEntry@@QBE_NXZ PROC		; CvImprovementEntry::IsCoastal, COMDAT
; _this$ = ecx

; 745  : 	return m_bCoastal;

	mov	al, BYTE PTR [ecx+356]

; 746  : }

	ret	0
?IsCoastal@CvImprovementEntry@@QBE_NXZ ENDP		; CvImprovementEntry::IsCoastal
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File s:\msvs2008\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?IsDestroyedWhenPillaged@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsDestroyedWhenPillaged
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
;	COMDAT ?IsDestroyedWhenPillaged@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsDestroyedWhenPillaged@CvImprovementEntry@@QBE_NXZ PROC ; CvImprovementEntry::IsDestroyedWhenPillaged, COMDAT
; _this$ = ecx

; 752  : 	return m_bDestroyedWhenPillaged;

	mov	al, BYTE PTR [ecx+357]

; 753  : }

	ret	0
?IsDestroyedWhenPillaged@CvImprovementEntry@@QBE_NXZ ENDP ; CvImprovementEntry::IsDestroyedWhenPillaged
_TEXT	ENDS
PUBLIC	?IsDisplacePillager@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsDisplacePillager
; Function compile flags: /Ogtpy
;	COMDAT ?IsDisplacePillager@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsDisplacePillager@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsDisplacePillager, COMDAT
; _this$ = ecx

; 758  : 	return m_bDisplacePillager;

	mov	al, BYTE PTR [ecx+358]

; 759  : }

	ret	0
?IsDisplacePillager@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsDisplacePillager
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\stdexcept
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
_TEXT	ENDS
PUBLIC	?IsBuildableOnResources@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsBuildableOnResources
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
;	COMDAT ?IsBuildableOnResources@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsBuildableOnResources@CvImprovementEntry@@QBE_NXZ PROC ; CvImprovementEntry::IsBuildableOnResources, COMDAT
; _this$ = ecx

; 764  : 	return m_bBuildableOnResources;

	mov	al, BYTE PTR [ecx+359]

; 765  : }

	ret	0
?IsBuildableOnResources@CvImprovementEntry@@QBE_NXZ ENDP ; CvImprovementEntry::IsBuildableOnResources
_TEXT	ENDS
PUBLIC	?IsBarbarianCamp@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsBarbarianCamp
; Function compile flags: /Ogtpy
;	COMDAT ?IsBarbarianCamp@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsBarbarianCamp@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsBarbarianCamp, COMDAT
; _this$ = ecx

; 770  : 	return m_bBarbarianCamp;

	mov	al, BYTE PTR [ecx+360]

; 771  : }

	ret	0
?IsBarbarianCamp@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsBarbarianCamp
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?IsGoody@CvImprovementEntry@@QBE_NXZ		; CvImprovementEntry::IsGoody
; Function compile flags: /Ogtpy
;	COMDAT ?IsGoody@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsGoody@CvImprovementEntry@@QBE_NXZ PROC		; CvImprovementEntry::IsGoody, COMDAT
; _this$ = ecx

; 776  : 	return m_bGoody;

	mov	al, BYTE PTR [ecx+361]

; 777  : }

	ret	0
?IsGoody@CvImprovementEntry@@QBE_NXZ ENDP		; CvImprovementEntry::IsGoody
_TEXT	ENDS
PUBLIC	?IsPermanent@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsPermanent
; Function compile flags: /Ogtpy
;	COMDAT ?IsPermanent@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsPermanent@CvImprovementEntry@@QBE_NXZ PROC		; CvImprovementEntry::IsPermanent, COMDAT
; _this$ = ecx

; 782  : 	return m_bPermanent;

	mov	al, BYTE PTR [ecx+362]

; 783  : }

	ret	0
?IsPermanent@CvImprovementEntry@@QBE_NXZ ENDP		; CvImprovementEntry::IsPermanent
_TEXT	ENDS
PUBLIC	?IsOutsideBorders@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsOutsideBorders
; Function compile flags: /Ogtpy
;	COMDAT ?IsOutsideBorders@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsOutsideBorders@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsOutsideBorders, COMDAT
; _this$ = ecx

; 788  : 	return m_bOutsideBorders;

	mov	al, BYTE PTR [ecx+363]

; 789  : }

	ret	0
?IsOutsideBorders@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsOutsideBorders
_TEXT	ENDS
PUBLIC	?IsIgnoreOwnership@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsIgnoreOwnership
; Function compile flags: /Ogtpy
;	COMDAT ?IsIgnoreOwnership@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsIgnoreOwnership@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsIgnoreOwnership, COMDAT
; _this$ = ecx

; 794  : 	return m_bIgnoreOwnership;

	mov	al, BYTE PTR [ecx+365]

; 795  : }

	ret	0
?IsIgnoreOwnership@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsIgnoreOwnership
_TEXT	ENDS
PUBLIC	?IsOnlyCityStateTerritory@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsOnlyCityStateTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?IsOnlyCityStateTerritory@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsOnlyCityStateTerritory@CvImprovementEntry@@QBE_NXZ PROC ; CvImprovementEntry::IsOnlyCityStateTerritory, COMDAT
; _this$ = ecx

; 800  : 	return m_bOnlyCityStateTerritory;

	mov	al, BYTE PTR [ecx+366]

; 801  : }

	ret	0
?IsOnlyCityStateTerritory@CvImprovementEntry@@QBE_NXZ ENDP ; CvImprovementEntry::IsOnlyCityStateTerritory
_TEXT	ENDS
PUBLIC	?IsNoTwoAdjacent@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsNoTwoAdjacent
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoTwoAdjacent@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsNoTwoAdjacent@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsNoTwoAdjacent, COMDAT
; _this$ = ecx

; 806  : 	return m_bNoTwoAdjacent;

	mov	al, BYTE PTR [ecx+367]

; 807  : }

	ret	0
?IsNoTwoAdjacent@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsNoTwoAdjacent
_TEXT	ENDS
PUBLIC	?IsAdjacentLuxury@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsAdjacentLuxury
; Function compile flags: /Ogtpy
;	COMDAT ?IsAdjacentLuxury@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAdjacentLuxury@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsAdjacentLuxury, COMDAT
; _this$ = ecx

; 812  : 	return m_bAdjacentLuxury;

	mov	al, BYTE PTR [ecx+368]

; 813  : }

	ret	0
?IsAdjacentLuxury@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsAdjacentLuxury
_TEXT	ENDS
PUBLIC	?IsAllowsWalkWater@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsAllowsWalkWater
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowsWalkWater@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAllowsWalkWater@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsAllowsWalkWater, COMDAT
; _this$ = ecx

; 818  : 	return m_bAllowsWalkWater;

	mov	al, BYTE PTR [ecx+369]

; 819  : }

	ret	0
?IsAllowsWalkWater@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsAllowsWalkWater
_TEXT	ENDS
PUBLIC	?IsAllowsSailLand@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsAllowsSailLand
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowsSailLand@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAllowsSailLand@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsAllowsSailLand, COMDAT
; _this$ = ecx

; 823  :     return m_bAllowsSailLand;

	mov	al, BYTE PTR [ecx+370]

; 824  : }

	ret	0
?IsAllowsSailLand@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsAllowsSailLand
_TEXT	ENDS
PUBLIC	?IsInAdjacentFriendly@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsInAdjacentFriendly
; Function compile flags: /Ogtpy
;	COMDAT ?IsInAdjacentFriendly@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsInAdjacentFriendly@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsInAdjacentFriendly, COMDAT
; _this$ = ecx

; 828  : 	return m_bInAdjacentFriendly;

	mov	al, BYTE PTR [ecx+364]

; 829  : }

	ret	0
?IsInAdjacentFriendly@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsInAdjacentFriendly
_TEXT	ENDS
PUBLIC	?IsCreatedByGreatPerson@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsCreatedByGreatPerson
; Function compile flags: /Ogtpy
;	COMDAT ?IsCreatedByGreatPerson@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsCreatedByGreatPerson@CvImprovementEntry@@QBE_NXZ PROC ; CvImprovementEntry::IsCreatedByGreatPerson, COMDAT
; _this$ = ecx

; 833  : 	return m_bCreatedByGreatPerson;

	mov	al, BYTE PTR [ecx+371]

; 834  : }

	ret	0
?IsCreatedByGreatPerson@CvImprovementEntry@@QBE_NXZ ENDP ; CvImprovementEntry::IsCreatedByGreatPerson
_TEXT	ENDS
PUBLIC	?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsSpecificCivRequired
; Function compile flags: /Ogtpy
;	COMDAT ?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ PROC	; CvImprovementEntry::IsSpecificCivRequired, COMDAT
; _this$ = ecx

; 838  : 	return m_bSpecificCivRequired;

	mov	al, BYTE PTR [ecx+372]

; 839  : }

	ret	0
?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ ENDP	; CvImprovementEntry::IsSpecificCivRequired
_TEXT	ENDS
PUBLIC	?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ ; CvImprovementEntry::GetRequiredCivilization
; Function compile flags: /Ogtpy
;	COMDAT ?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ
_TEXT	SEGMENT
?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ PROC ; CvImprovementEntry::GetRequiredCivilization, COMDAT
; _this$ = ecx

; 843  : 	return m_eRequiredCivilization;

	mov	eax, DWORD PTR [ecx+408]

; 844  : }

	ret	0
?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ ENDP ; CvImprovementEntry::GetRequiredCivilization
_TEXT	ENDS
PUBLIC	?GetImprovementUsage@CvImprovementEntry@@QBE?AW4ImprovementUsageTypes@@XZ ; CvImprovementEntry::GetImprovementUsage
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementUsage@CvImprovementEntry@@QBE?AW4ImprovementUsageTypes@@XZ
_TEXT	SEGMENT
?GetImprovementUsage@CvImprovementEntry@@QBE?AW4ImprovementUsageTypes@@XZ PROC ; CvImprovementEntry::GetImprovementUsage, COMDAT
; _this$ = ecx

; 860  : 	return m_eImprovementUsageType;

	mov	eax, DWORD PTR [ecx+404]

; 861  : }

	ret	0
?GetImprovementUsage@CvImprovementEntry@@QBE?AW4ImprovementUsageTypes@@XZ ENDP ; CvImprovementEntry::GetImprovementUsage
_TEXT	ENDS
PUBLIC	?SetImprovementUsage@CvImprovementEntry@@QAEXW4ImprovementUsageTypes@@@Z ; CvImprovementEntry::SetImprovementUsage
; Function compile flags: /Ogtpy
;	COMDAT ?SetImprovementUsage@CvImprovementEntry@@QAEXW4ImprovementUsageTypes@@@Z
_TEXT	SEGMENT
_usageType$ = 8						; size = 4
?SetImprovementUsage@CvImprovementEntry@@QAEXW4ImprovementUsageTypes@@@Z PROC ; CvImprovementEntry::SetImprovementUsage, COMDAT
; _this$ = ecx

; 865  : 	m_eImprovementUsageType = usageType;

	mov	eax, DWORD PTR _usageType$[esp-4]
	mov	DWORD PTR [ecx+404], eax

; 866  : }

	ret	4
?SetImprovementUsage@CvImprovementEntry@@QAEXW4ImprovementUsageTypes@@@Z ENDP ; CvImprovementEntry::SetImprovementUsage
_TEXT	ENDS
PUBLIC	?GetWorldSoundscapeScriptId@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetWorldSoundscapeScriptId
; Function compile flags: /Ogtpy
;	COMDAT ?GetWorldSoundscapeScriptId@CvImprovementEntry@@QBEHXZ
_TEXT	SEGMENT
?GetWorldSoundscapeScriptId@CvImprovementEntry@@QBEHXZ PROC ; CvImprovementEntry::GetWorldSoundscapeScriptId, COMDAT
; _this$ = ecx

; 871  : 	return m_iWorldSoundscapeScriptId;

	mov	eax, DWORD PTR [ecx+412]

; 872  : }

	ret	0
?GetWorldSoundscapeScriptId@CvImprovementEntry@@QBEHXZ ENDP ; CvImprovementEntry::GetWorldSoundscapeScriptId
_TEXT	ENDS
PUBLIC	?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetResourceQuantityRequirement
; Function compile flags: /Ogtpy
;	COMDAT ?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z PROC ; CvImprovementEntry::GetResourceQuantityRequirement, COMDAT
; _this$ = ecx

; 877  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 878  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 879  : 	return m_piResourceQuantityRequirements ? m_piResourceQuantityRequirements[i] : -1;

	mov	eax, DWORD PTR [ecx+416]
	test	eax, eax
	je	SHORT $LN3@GetResourc
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 880  : }

	ret	4
$LN3@GetResourc:

; 877  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 878  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 879  : 	return m_piResourceQuantityRequirements ? m_piResourceQuantityRequirements[i] : -1;

	or	eax, -1

; 880  : }

	ret	4
?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z ENDP ; CvImprovementEntry::GetResourceQuantityRequirement
_TEXT	ENDS
PUBLIC	?GetPrereqNatureYield@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetPrereqNatureYield
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqNatureYield@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPrereqNatureYield@CvImprovementEntry@@QBEHH@Z PROC	; CvImprovementEntry::GetPrereqNatureYield, COMDAT
; _this$ = ecx

; 885  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 886  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 887  : 	return m_piPrereqNatureYield ? m_piPrereqNatureYield[i] : -1;

	mov	eax, DWORD PTR [ecx+420]
	test	eax, eax
	je	SHORT $LN3@GetPrereqN
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 888  : }

	ret	4
$LN3@GetPrereqN:

; 885  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 886  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 887  : 	return m_piPrereqNatureYield ? m_piPrereqNatureYield[i] : -1;

	or	eax, -1

; 888  : }

	ret	4
?GetPrereqNatureYield@CvImprovementEntry@@QBEHH@Z ENDP	; CvImprovementEntry::GetPrereqNatureYield
_TEXT	ENDS
PUBLIC	?GetPrereqNatureYieldArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetPrereqNatureYieldArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqNatureYieldArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
?GetPrereqNatureYieldArray@CvImprovementEntry@@QAEPAHXZ PROC ; CvImprovementEntry::GetPrereqNatureYieldArray, COMDAT
; _this$ = ecx

; 892  : 	return m_piPrereqNatureYield;

	mov	eax, DWORD PTR [ecx+420]

; 893  : }

	ret	0
?GetPrereqNatureYieldArray@CvImprovementEntry@@QAEPAHXZ ENDP ; CvImprovementEntry::GetPrereqNatureYieldArray
_TEXT	ENDS
PUBLIC	?GetYieldChange@CvImprovementEntry@@QBEHH@Z	; CvImprovementEntry::GetYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChange@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChange@CvImprovementEntry@@QBEHH@Z PROC	; CvImprovementEntry::GetYieldChange, COMDAT
; _this$ = ecx

; 898  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 899  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 900  : 	return m_piYieldChange ? m_piYieldChange[i] : 0;

	mov	eax, DWORD PTR [ecx+424]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 901  : }

	ret	4
$LN3@GetYieldCh:

; 898  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 899  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 900  : 	return m_piYieldChange ? m_piYieldChange[i] : 0;

	xor	eax, eax

; 901  : }

	ret	4
?GetYieldChange@CvImprovementEntry@@QBEHH@Z ENDP	; CvImprovementEntry::GetYieldChange
_TEXT	ENDS
PUBLIC	?GetYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangeArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
?GetYieldChangeArray@CvImprovementEntry@@QAEPAHXZ PROC	; CvImprovementEntry::GetYieldChangeArray, COMDAT
; _this$ = ecx

; 905  : 	return m_piYieldChange;

	mov	eax, DWORD PTR [ecx+424]

; 906  : }

	ret	0
?GetYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ENDP	; CvImprovementEntry::GetYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetYieldChangePerEra@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChangePerEra
; Function compile flags: /Ogtpy
;	COMDAT ?GetYieldChangePerEra@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetYieldChangePerEra@CvImprovementEntry@@QBEHH@Z PROC	; CvImprovementEntry::GetYieldChangePerEra, COMDAT
; _this$ = ecx

; 911  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 912  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 913  : 	return m_piYieldPerEra ? m_piYieldPerEra[i] : 0;

	mov	eax, DWORD PTR [ecx+428]
	test	eax, eax
	je	SHORT $LN3@GetYieldCh@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 914  : }

	ret	4
$LN3@GetYieldCh@2:

; 911  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 912  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 913  : 	return m_piYieldPerEra ? m_piYieldPerEra[i] : 0;

	xor	eax, eax

; 914  : }

	ret	4
?GetYieldChangePerEra@CvImprovementEntry@@QBEHH@Z ENDP	; CvImprovementEntry::GetYieldChangePerEra
_TEXT	ENDS
PUBLIC	?GetRiverSideYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetRiverSideYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetRiverSideYieldChange@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetRiverSideYieldChange@CvImprovementEntry@@QBEHH@Z PROC ; CvImprovementEntry::GetRiverSideYieldChange, COMDAT
; _this$ = ecx

; 919  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 920  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 921  : 	return m_piRiverSideYieldChange ? m_piRiverSideYieldChange[i] : 0;

	mov	eax, DWORD PTR [ecx+432]
	test	eax, eax
	je	SHORT $LN3@GetRiverSi
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 922  : }

	ret	4
$LN3@GetRiverSi:

; 919  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 920  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 921  : 	return m_piRiverSideYieldChange ? m_piRiverSideYieldChange[i] : 0;

	xor	eax, eax

; 922  : }

	ret	4
?GetRiverSideYieldChange@CvImprovementEntry@@QBEHH@Z ENDP ; CvImprovementEntry::GetRiverSideYieldChange
_TEXT	ENDS
PUBLIC	?GetRiverSideYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetRiverSideYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetRiverSideYieldChangeArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
?GetRiverSideYieldChangeArray@CvImprovementEntry@@QAEPAHXZ PROC ; CvImprovementEntry::GetRiverSideYieldChangeArray, COMDAT
; _this$ = ecx

; 926  : 	return m_piRiverSideYieldChange;

	mov	eax, DWORD PTR [ecx+432]

; 927  : }

	ret	0
?GetRiverSideYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ENDP ; CvImprovementEntry::GetRiverSideYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetCoastalLandYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetCoastalLandYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetCoastalLandYieldChange@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetCoastalLandYieldChange@CvImprovementEntry@@QBEHH@Z PROC ; CvImprovementEntry::GetCoastalLandYieldChange, COMDAT
; _this$ = ecx

; 932  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 933  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 934  : 	return m_piCoastalLandYieldChange ? m_piCoastalLandYieldChange[i] : 0;

	mov	eax, DWORD PTR [ecx+436]
	test	eax, eax
	je	SHORT $LN3@GetCoastal
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 935  : }

	ret	4
$LN3@GetCoastal:

; 932  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 933  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 934  : 	return m_piCoastalLandYieldChange ? m_piCoastalLandYieldChange[i] : 0;

	xor	eax, eax

; 935  : }

	ret	4
?GetCoastalLandYieldChange@CvImprovementEntry@@QBEHH@Z ENDP ; CvImprovementEntry::GetCoastalLandYieldChange
_TEXT	ENDS
PUBLIC	?GetCoastalLandYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetCoastalLandYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetCoastalLandYieldChangeArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
?GetCoastalLandYieldChangeArray@CvImprovementEntry@@QAEPAHXZ PROC ; CvImprovementEntry::GetCoastalLandYieldChangeArray, COMDAT
; _this$ = ecx

; 939  : 	return m_piCoastalLandYieldChange;

	mov	eax, DWORD PTR [ecx+436]

; 940  : }

	ret	0
?GetCoastalLandYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ENDP ; CvImprovementEntry::GetCoastalLandYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetHillsYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetHillsYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetHillsYieldChange@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetHillsYieldChange@CvImprovementEntry@@QBEHH@Z PROC	; CvImprovementEntry::GetHillsYieldChange, COMDAT
; _this$ = ecx

; 945  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 946  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 947  : 	return m_piHillsYieldChange ? m_piHillsYieldChange[i] : 0;

	mov	eax, DWORD PTR [ecx+440]
	test	eax, eax
	je	SHORT $LN3@GetHillsYi
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 948  : }

	ret	4
$LN3@GetHillsYi:

; 945  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 946  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 947  : 	return m_piHillsYieldChange ? m_piHillsYieldChange[i] : 0;

	xor	eax, eax

; 948  : }

	ret	4
?GetHillsYieldChange@CvImprovementEntry@@QBEHH@Z ENDP	; CvImprovementEntry::GetHillsYieldChange
_TEXT	ENDS
PUBLIC	?GetHillsYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetHillsYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetHillsYieldChangeArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
?GetHillsYieldChangeArray@CvImprovementEntry@@QAEPAHXZ PROC ; CvImprovementEntry::GetHillsYieldChangeArray, COMDAT
; _this$ = ecx

; 952  : 	return m_piHillsYieldChange;

	mov	eax, DWORD PTR [ecx+440]

; 953  : }

	ret	0
?GetHillsYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ENDP ; CvImprovementEntry::GetHillsYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetFreshWaterYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetFreshWaterYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreshWaterYieldChange@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFreshWaterYieldChange@CvImprovementEntry@@QBEHH@Z PROC ; CvImprovementEntry::GetFreshWaterYieldChange, COMDAT
; _this$ = ecx

; 958  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 959  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 960  : 	return m_piFreshWaterChange ? m_piFreshWaterChange[i] : 0;

	mov	eax, DWORD PTR [ecx+444]
	test	eax, eax
	je	SHORT $LN3@GetFreshWa
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 961  : }

	ret	4
$LN3@GetFreshWa:

; 958  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 959  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 960  : 	return m_piFreshWaterChange ? m_piFreshWaterChange[i] : 0;

	xor	eax, eax

; 961  : }

	ret	4
?GetFreshWaterYieldChange@CvImprovementEntry@@QBEHH@Z ENDP ; CvImprovementEntry::GetFreshWaterYieldChange
_TEXT	ENDS
PUBLIC	?GetFreshWaterYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetFreshWaterYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetFreshWaterYieldChangeArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
?GetFreshWaterYieldChangeArray@CvImprovementEntry@@QAEPAHXZ PROC ; CvImprovementEntry::GetFreshWaterYieldChangeArray, COMDAT
; _this$ = ecx

; 965  : 	return m_piFreshWaterChange;

	mov	eax, DWORD PTR [ecx+444]

; 966  : }

	ret	0
?GetFreshWaterYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ENDP ; CvImprovementEntry::GetFreshWaterYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetAdjacentCityYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetAdjacentCityYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdjacentCityYieldChange@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetAdjacentCityYieldChange@CvImprovementEntry@@QBEHH@Z PROC ; CvImprovementEntry::GetAdjacentCityYieldChange, COMDAT
; _this$ = ecx

; 971  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 972  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 973  : 	return m_piAdjacentCityYieldChange ? m_piAdjacentCityYieldChange[i] : 0;

	mov	eax, DWORD PTR [ecx+448]
	test	eax, eax
	je	SHORT $LN3@GetAdjacen
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 974  : }

	ret	4
$LN3@GetAdjacen:

; 971  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 972  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 973  : 	return m_piAdjacentCityYieldChange ? m_piAdjacentCityYieldChange[i] : 0;

	xor	eax, eax

; 974  : }

	ret	4
?GetAdjacentCityYieldChange@CvImprovementEntry@@QBEHH@Z ENDP ; CvImprovementEntry::GetAdjacentCityYieldChange
_TEXT	ENDS
PUBLIC	?GetAdjacentCityYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetAdjacentCityYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdjacentCityYieldChangeArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
?GetAdjacentCityYieldChangeArray@CvImprovementEntry@@QAEPAHXZ PROC ; CvImprovementEntry::GetAdjacentCityYieldChangeArray, COMDAT
; _this$ = ecx

; 978  : 	return m_piAdjacentCityYieldChange;

	mov	eax, DWORD PTR [ecx+448]

; 979  : }

	ret	0
?GetAdjacentCityYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ENDP ; CvImprovementEntry::GetAdjacentCityYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetAdjacentMountainYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetAdjacentMountainYieldChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdjacentMountainYieldChange@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetAdjacentMountainYieldChange@CvImprovementEntry@@QBEHH@Z PROC ; CvImprovementEntry::GetAdjacentMountainYieldChange, COMDAT
; _this$ = ecx

; 984  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 985  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 986  : 	return m_piAdjacentMountainYieldChange ? m_piAdjacentMountainYieldChange[i] : 0;

	mov	eax, DWORD PTR [ecx+452]
	test	eax, eax
	je	SHORT $LN3@GetAdjacen@2
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 987  : }

	ret	4
$LN3@GetAdjacen@2:

; 984  : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 985  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 986  : 	return m_piAdjacentMountainYieldChange ? m_piAdjacentMountainYieldChange[i] : 0;

	xor	eax, eax

; 987  : }

	ret	4
?GetAdjacentMountainYieldChange@CvImprovementEntry@@QBEHH@Z ENDP ; CvImprovementEntry::GetAdjacentMountainYieldChange
_TEXT	ENDS
PUBLIC	?GetAdjacentMountainYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ; CvImprovementEntry::GetAdjacentMountainYieldChangeArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdjacentMountainYieldChangeArray@CvImprovementEntry@@QAEPAHXZ
_TEXT	SEGMENT
?GetAdjacentMountainYieldChangeArray@CvImprovementEntry@@QAEPAHXZ PROC ; CvImprovementEntry::GetAdjacentMountainYieldChangeArray, COMDAT
; _this$ = ecx

; 991  : 	return m_piAdjacentMountainYieldChange;

	mov	eax, DWORD PTR [ecx+452]

; 992  : }

	ret	0
?GetAdjacentMountainYieldChangeArray@CvImprovementEntry@@QAEPAHXZ ENDP ; CvImprovementEntry::GetAdjacentMountainYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetTerrainMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetTerrainMakesValid
; Function compile flags: /Ogtpy
;	COMDAT ?GetTerrainMakesValid@CvImprovementEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetTerrainMakesValid@CvImprovementEntry@@QBE_NH@Z PROC	; CvImprovementEntry::GetTerrainMakesValid, COMDAT
; _this$ = ecx

; 997  : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 998  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 999  : 	return m_pbTerrainMakesValid ? m_pbTerrainMakesValid[i] : false;

	mov	eax, DWORD PTR [ecx+460]
	test	eax, eax
	je	SHORT $LN3@GetTerrain
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 1000 : }

	ret	4
$LN3@GetTerrain:

; 997  : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 998  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 999  : 	return m_pbTerrainMakesValid ? m_pbTerrainMakesValid[i] : false;

	xor	al, al

; 1000 : }

	ret	4
?GetTerrainMakesValid@CvImprovementEntry@@QBE_NH@Z ENDP	; CvImprovementEntry::GetTerrainMakesValid
_TEXT	ENDS
PUBLIC	?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetFeatureMakesValid
; Function compile flags: /Ogtpy
;	COMDAT ?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z PROC	; CvImprovementEntry::GetFeatureMakesValid, COMDAT
; _this$ = ecx

; 1005 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 1006 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1007 : 	return m_pbFeatureMakesValid ? m_pbFeatureMakesValid[i] : false;

	mov	eax, DWORD PTR [ecx+464]
	test	eax, eax
	je	SHORT $LN3@GetFeature
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 1008 : }

	ret	4
$LN3@GetFeature:

; 1005 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 1006 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1007 : 	return m_pbFeatureMakesValid ? m_pbFeatureMakesValid[i] : false;

	xor	al, al

; 1008 : }

	ret	4
?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z ENDP	; CvImprovementEntry::GetFeatureMakesValid
_TEXT	ENDS
PUBLIC	?GetImprovementMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetImprovementMakesValid
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementMakesValid@CvImprovementEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetImprovementMakesValid@CvImprovementEntry@@QBE_NH@Z PROC ; CvImprovementEntry::GetImprovementMakesValid, COMDAT
; _this$ = ecx

; 1013 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 1014 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1015 : 	return m_pbImprovementMakesValid ? m_pbImprovementMakesValid[i] : false;

	mov	eax, DWORD PTR [ecx+468]
	test	eax, eax
	je	SHORT $LN3@GetImprove
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	al, BYTE PTR [eax+ecx]

; 1016 : }

	ret	4
$LN3@GetImprove:

; 1013 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 1014 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1015 : 	return m_pbImprovementMakesValid ? m_pbImprovementMakesValid[i] : false;

	xor	al, al

; 1016 : }

	ret	4
?GetImprovementMakesValid@CvImprovementEntry@@QBE_NH@Z ENDP ; CvImprovementEntry::GetImprovementMakesValid
_TEXT	ENDS
PUBLIC	?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechYieldChanges
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z PROC	; CvImprovementEntry::GetTechYieldChanges, COMDAT
; _this$ = ecx

; 1021 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 1022 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1023 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 1024 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 1025 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1026 : 	return m_ppiTechYieldChanges.first ? m_ppiTechYieldChanges.first[i][j] : 0;
; 1027 : #else
; 1028 : 	return m_ppiTechYieldChanges[i][j];

	mov	eax, DWORD PTR [ecx+472]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1029 : #endif
; 1030 : }

	ret	8
?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z ENDP	; CvImprovementEntry::GetTechYieldChanges
_TEXT	ENDS
PUBLIC	?GetTechYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ; CvImprovementEntry::GetTechYieldChangesArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetTechYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z PROC ; CvImprovementEntry::GetTechYieldChangesArray, COMDAT
; _this$ = ecx

; 1034 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1035 : 	return m_ppiTechYieldChanges.first ? m_ppiTechYieldChanges.first[i] : NULL;
; 1036 : #else
; 1037 : 	return m_ppiTechYieldChanges[i];

	mov	eax, DWORD PTR [ecx+472]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1038 : #endif
; 1039 : }

	ret	4
?GetTechYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ENDP ; CvImprovementEntry::GetTechYieldChangesArray
_TEXT	ENDS
PUBLIC	?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechNoFreshWaterYieldChanges
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z PROC ; CvImprovementEntry::GetTechNoFreshWaterYieldChanges, COMDAT
; _this$ = ecx

; 1044 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 1045 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1046 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 1047 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 1048 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1049 : 	return m_ppiTechNoFreshWaterYieldChanges.first ? m_ppiTechNoFreshWaterYieldChanges.first[i][j] : 0;
; 1050 : #else
; 1051 : 	return m_ppiTechNoFreshWaterYieldChanges[i][j];

	mov	eax, DWORD PTR [ecx+476]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1052 : #endif
; 1053 : }

	ret	8
?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ENDP ; CvImprovementEntry::GetTechNoFreshWaterYieldChanges
_TEXT	ENDS
PUBLIC	?GetTechNoFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ; CvImprovementEntry::GetTechNoFreshWaterYieldChangesArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechNoFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetTechNoFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z PROC ; CvImprovementEntry::GetTechNoFreshWaterYieldChangesArray, COMDAT
; _this$ = ecx

; 1057 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1058 : 	return m_ppiTechNoFreshWaterYieldChanges.first ? m_ppiTechNoFreshWaterYieldChanges.first[i] : NULL;
; 1059 : #else
; 1060 : 	return m_ppiTechNoFreshWaterYieldChanges[i];

	mov	eax, DWORD PTR [ecx+476]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1061 : #endif
; 1062 : }

	ret	4
?GetTechNoFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ENDP ; CvImprovementEntry::GetTechNoFreshWaterYieldChangesArray
_TEXT	ENDS
PUBLIC	?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechFreshWaterYieldChanges
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z PROC ; CvImprovementEntry::GetTechFreshWaterYieldChanges, COMDAT
; _this$ = ecx

; 1067 : 	CvAssertMsg(i < GC.getNumTechInfos(), "Index out of bounds");
; 1068 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1069 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 1070 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 1071 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1072 : 	return m_ppiTechFreshWaterYieldChanges.first ? m_ppiTechFreshWaterYieldChanges.first[i][j] : 0;
; 1073 : #else
; 1074 : 	return m_ppiTechFreshWaterYieldChanges[i][j];

	mov	eax, DWORD PTR [ecx+480]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1075 : #endif
; 1076 : }

	ret	8
?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ENDP ; CvImprovementEntry::GetTechFreshWaterYieldChanges
_TEXT	ENDS
PUBLIC	?GetTechFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ; CvImprovementEntry::GetTechFreshWaterYieldChangesArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetTechFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z PROC ; CvImprovementEntry::GetTechFreshWaterYieldChangesArray, COMDAT
; _this$ = ecx

; 1080 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1081 : 	return m_ppiTechFreshWaterYieldChanges.first ? m_ppiTechFreshWaterYieldChanges.first[i] : NULL;
; 1082 : #else
; 1083 : 	return m_ppiTechFreshWaterYieldChanges[i];

	mov	eax, DWORD PTR [ecx+480]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1084 : #endif
; 1085 : }

	ret	4
?GetTechFreshWaterYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ENDP ; CvImprovementEntry::GetTechFreshWaterYieldChangesArray
_TEXT	ENDS
PUBLIC	?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetRouteYieldChanges
; Function compile flags: /Ogtpy
;	COMDAT ?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z PROC	; CvImprovementEntry::GetRouteYieldChanges, COMDAT
; _this$ = ecx

; 1090 : 	CvAssertMsg(i < GC.getNumRouteInfos(), "Index out of bounds");
; 1091 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1092 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 1093 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 1094 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1095 : 	return m_ppiRouteYieldChanges.first ? m_ppiRouteYieldChanges.first[i][j] : 0;
; 1096 : #else
; 1097 : 	return m_ppiRouteYieldChanges[i][j];

	mov	eax, DWORD PTR [ecx+484]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1098 : #endif
; 1099 : }

	ret	8
?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z ENDP	; CvImprovementEntry::GetRouteYieldChanges
_TEXT	ENDS
PUBLIC	?GetRouteYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ; CvImprovementEntry::GetRouteYieldChangesArray
; Function compile flags: /Ogtpy
;	COMDAT ?GetRouteYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetRouteYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z PROC ; CvImprovementEntry::GetRouteYieldChangesArray, COMDAT
; _this$ = ecx

; 1103 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1104 : 	return m_ppiRouteYieldChanges.first ? m_ppiRouteYieldChanges.first[i] : NULL;
; 1105 : #else
; 1106 : 	return m_ppiRouteYieldChanges[i];

	mov	eax, DWORD PTR [ecx+484]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1107 : #endif
; 1108 : }

	ret	4
?GetRouteYieldChangesArray@CvImprovementEntry@@QAEPAHH@Z ENDP ; CvImprovementEntry::GetRouteYieldChangesArray
_TEXT	ENDS
PUBLIC	?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetImprovementResourceYield
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z PROC ; CvImprovementEntry::GetImprovementResourceYield, COMDAT
; _this$ = ecx

; 1113 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 1114 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1115 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 1116 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 1117 : 	return m_paImprovementResource[i].m_piYieldChange ? m_paImprovementResource[i].getYieldChange(j) : 0;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	ecx, DWORD PTR [ecx+488]
	lea	eax, DWORD PTR [eax+eax*2]
	cmp	DWORD PTR [ecx+eax*4+8], 0
	lea	eax, DWORD PTR [ecx+eax*4]
	je	SHORT $LN3@GetImprove@2
	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN7@GetImprove@2
	mov	edx, DWORD PTR _j$[esp-4]
	mov	eax, DWORD PTR [eax+edx*4]

; 1118 : }

	ret	8

; 1113 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 1114 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1115 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 1116 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 1117 : 	return m_paImprovementResource[i].m_piYieldChange ? m_paImprovementResource[i].getYieldChange(j) : 0;

$LN7@GetImprove@2:
	or	eax, -1

; 1118 : }

	ret	8
$LN3@GetImprove@2:

; 1113 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 1114 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1115 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 1116 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 1117 : 	return m_paImprovementResource[i].m_piYieldChange ? m_paImprovementResource[i].getYieldChange(j) : 0;

	xor	eax, eax

; 1118 : }

	ret	8
?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z ENDP ; CvImprovementEntry::GetImprovementResourceYield
_TEXT	ENDS
PUBLIC	?IsImprovementResourceMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceMakesValid
; Function compile flags: /Ogtpy
;	COMDAT ?IsImprovementResourceMakesValid@CvImprovementEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?IsImprovementResourceMakesValid@CvImprovementEntry@@QBE_NH@Z PROC ; CvImprovementEntry::IsImprovementResourceMakesValid, COMDAT
; _this$ = ecx

; 1123 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 1124 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1125 : 	return m_paImprovementResource[i].m_bResourceMakesValid;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	ecx, DWORD PTR [ecx+488]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	al, BYTE PTR [ecx+eax*4+4]

; 1126 : }

	ret	4
?IsImprovementResourceMakesValid@CvImprovementEntry@@QBE_NH@Z ENDP ; CvImprovementEntry::IsImprovementResourceMakesValid
_TEXT	ENDS
PUBLIC	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z PROC ; CvImprovementEntry::IsImprovementResourceTrade, COMDAT
; _this$ = ecx

; 1131 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 1132 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1133 : 	return m_paImprovementResource[i].m_bResourceTrade;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	ecx, DWORD PTR [ecx+488]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	al, BYTE PTR [ecx+eax*4+5]

; 1134 : }

	ret	4
?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ENDP ; CvImprovementEntry::IsImprovementResourceTrade
_TEXT	ENDS
PUBLIC	?GetImprovementResourceDiscoverRand@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetImprovementResourceDiscoverRand
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementResourceDiscoverRand@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetImprovementResourceDiscoverRand@CvImprovementEntry@@QBEHH@Z PROC ; CvImprovementEntry::GetImprovementResourceDiscoverRand, COMDAT
; _this$ = ecx

; 1139 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 1140 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1141 : 	return m_paImprovementResource[i].m_iDiscoverRand;

	mov	eax, DWORD PTR _i$[esp-4]
	mov	ecx, DWORD PTR [ecx+488]
	lea	eax, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx+eax*4]

; 1142 : }

	ret	4
?GetImprovementResourceDiscoverRand@CvImprovementEntry@@QBEHH@Z ENDP ; CvImprovementEntry::GetImprovementResourceDiscoverRand
_TEXT	ENDS
PUBLIC	?GetFlavorValue@CvImprovementEntry@@QBEHH@Z	; CvImprovementEntry::GetFlavorValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlavorValue@CvImprovementEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFlavorValue@CvImprovementEntry@@QBEHH@Z PROC	; CvImprovementEntry::GetFlavorValue, COMDAT
; _this$ = ecx

; 1147 : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 1148 : 	CvAssertMsg(i > -1, "Indes out of bounds");
; 1149 : 	return m_piFlavorValue[i];

	mov	eax, DWORD PTR [ecx+456]
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1150 : }

	ret	4
?GetFlavorValue@CvImprovementEntry@@QBEHH@Z ENDP	; CvImprovementEntry::GetFlavorValue
_TEXT	ENDS
PUBLIC	?GetImprovementEntries@CvImprovementXMLEntries@@QAEAAV?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@XZ ; CvImprovementXMLEntries::GetImprovementEntries
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementEntries@CvImprovementXMLEntries@@QAEAAV?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetImprovementEntries@CvImprovementXMLEntries@@QAEAAV?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@XZ PROC ; CvImprovementXMLEntries::GetImprovementEntries, COMDAT
; _this$ = ecx

; 1170 : {

	mov	eax, ecx

; 1171 : 	return m_paImprovementEntries;
; 1172 : }

	ret	0
?GetImprovementEntries@CvImprovementXMLEntries@@QAEAAV?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@XZ ENDP ; CvImprovementXMLEntries::GetImprovementEntries
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEIXZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?size@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAPAVCvImprovementEntry@@I@Z ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAPAVCvImprovementEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAPAVCvImprovementEntry@@I@Z PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAPAVCvImprovementEntry@@I@Z ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvImprovementEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvImprovementEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvImprovementEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvImprovementEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvImprovementEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvImprovementEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvImprovementEntry@@@std@@QAE@XZ ; std::allocator<CvImprovementEntry *>::allocator<CvImprovementEntry *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvImprovementEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvImprovementEntry@@@std@@QAE@XZ PROC	; std::allocator<CvImprovementEntry *>::allocator<CvImprovementEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvImprovementEntry@@@std@@QAE@XZ ENDP	; std::allocator<CvImprovementEntry *>::allocator<CvImprovementEntry *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEABQAVCvImprovementEntry@@XZ ; std::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEABQAVCvImprovementEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEABQAVCvImprovementEntry@@XZ PROC ; std::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEABQAVCvImprovementEntry@@XZ ENDP ; std::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator==
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T219896 = -80						; size = 28
$T219895 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T219896[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T219895[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T219896[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T219895[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T219895[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T219895[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T219895[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T219896[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T219895[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE@V?$allocator@PAVCvImprovementEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvImprovementEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvImprovementEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE@V?$allocator@PAVCvImprovementEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE@V?$allocator@PAVCvImprovementEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvImprovementEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvImprovementEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE@V?$allocator@PAVCvImprovementEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvImprovementEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvImprovementEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvImprovementEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvImprovementEntry *>::allocator<CvImprovementEntry *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvImprovementEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvImprovementEntry@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvImprovementEntry *>::allocator<CvImprovementEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvImprovementEntry@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvImprovementEntry *>::allocator<CvImprovementEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvImprovementEntry@@@std@@QAEXPAPAVCvImprovementEntry@@I@Z ; std::allocator<CvImprovementEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvImprovementEntry@@@std@@QAEXPAPAVCvImprovementEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvImprovementEntry@@@std@@QAEXPAPAVCvImprovementEntry@@I@Z PROC ; std::allocator<CvImprovementEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvImprovementEntry@@@std@@QAEXPAPAVCvImprovementEntry@@I@Z ENDP ; std::allocator<CvImprovementEntry *>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@PAPAVCvImprovementEntry@@@Z ; std::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@PAPAVCvImprovementEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@PAPAVCvImprovementEntry@@@Z PROC ; std::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@PAPAVCvImprovementEntry@@@Z ENDP ; std::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvImprovementEntry@@@std@@QBEIXZ ; std::allocator<CvImprovementEntry *>::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvImprovementEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvImprovementEntry@@@std@@QBEIXZ PROC ; std::allocator<CvImprovementEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvImprovementEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvImprovementEntry *>::max_size
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z		; SAFE_DELETE_ARRAY<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z PROC		; SAFE_DELETE_ARRAY<bool>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z ENDP		; SAFE_DELETE_ARRAY<bool>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVCvImprovementEntry@@@std@@YAPAPAVCvImprovementEntry@@IPAPAV1@@Z ; std::_Allocate<CvImprovementEntry *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File s:\msvs2008\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVCvImprovementEntry@@@std@@YAPAPAVCvImprovementEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T219946 = -12						; size = 12
$T219950 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvImprovementEntry@@@std@@YAPAPAVCvImprovementEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvImprovementEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T219950[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T219946[esp+16]
	mov	DWORD PTR $T219950[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T219946[esp+16]
	push	ecx
	mov	DWORD PTR $T219946[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@PAVCvImprovementEntry@@@std@@YAPAPAVCvImprovementEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvImprovementEntry *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvImprovementEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvImprovementEntry@@0@Z ; std::_Iter_random<CvImprovementEntry * *,CvImprovementEntry * *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAPAVCvImprovementEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvImprovementEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvImprovementEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvImprovementEntry@@0@Z PROC ; std::_Iter_random<CvImprovementEntry * *,CvImprovementEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvImprovementEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvImprovementEntry@@0@Z ENDP ; std::_Iter_random<CvImprovementEntry * *,CvImprovementEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvImprovementEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvImprovementEntry@@0@Z ; std::_Ptr_cat<CvImprovementEntry * *,CvImprovementEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvImprovementEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvImprovementEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvImprovementEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvImprovementEntry@@0@Z PROC ; std::_Ptr_cat<CvImprovementEntry * *,CvImprovementEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvImprovementEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvImprovementEntry@@0@Z ENDP ; std::_Ptr_cat<CvImprovementEntry * *,CvImprovementEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvImprovementEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvImprovementEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvImprovementEntry * *,CvImprovementEntry * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvImprovementEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvImprovementEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvImprovementEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvImprovementEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvImprovementEntry * *,CvImprovementEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvImprovementEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvImprovementEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvImprovementEntry * *,CvImprovementEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@YAXPAPAVCvImprovementEntry@@0AAV?$allocator@PAVCvImprovementEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvImprovementEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@YAXPAPAVCvImprovementEntry@@0AAV?$allocator@PAVCvImprovementEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@YAXPAPAVCvImprovementEntry@@0AAV?$allocator@PAVCvImprovementEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvImprovementEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@YAXPAPAVCvImprovementEntry@@0AAV?$allocator@PAVCvImprovementEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvImprovementEntry *> >
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?GetCString@CvString@@QBEPBDXZ			; CvString::GetCString
; Function compile flags: /Ogtpy
;	COMDAT ?GetCString@CvString@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@CvString@@QBEPBDXZ PROC			; CvString::GetCString, COMDAT
; _this$ = ecx

; 42   : 	const char* GetCString() const 	{ return c_str(); }

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCString@CvString@@QBEPBDXZ ENDP			; CvString::GetCString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7703 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8564]

; 7704 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z
_TEXT	SEGMENT
_pArray$ = 8						; size = 4
_count$ = 12						; size = 4
_iDefault$ = 16						; size = 4
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z PROC	; CvDatabaseUtility::InitializeArray, COMDAT
; _this$ = ecx

; 120  : {

	push	esi

; 121  : 	CvAssertMsg(count > 0, "Initializing array to 0 or less items.");
; 122  : #ifdef AUI_WARNING_FIXES
; 123  : 	delete[] pArray;
; 124  : #endif
; 125  : 	pArray = FNEW(int[count], c_eCiv5GameplayDLL, 0);

	mov	esi, DWORD PTR _count$[esp]
	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 126  : 	if(iDefault == 0)

	mov	edx, DWORD PTR _iDefault$[esp+4]
	mov	ecx, DWORD PTR _pArray$[esp+4]
	add	esp, 4
	mov	DWORD PTR [ecx], eax
	test	edx, edx
	jne	SHORT $LN5@Initialize

; 127  : 	{
; 128  : 		ZeroMemory(pArray, sizeof(int) * count);

	lea	ecx, DWORD PTR [esi*4]
	push	ecx
	push	edx
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
$LN5@Initialize:

; 129  : 	}
; 130  : 	else
; 131  : 	{
; 132  : 		for(size_t i = 0; i < count; ++i)

	xor	eax, eax
	test	esi, esi
	jbe	SHORT $LN1@Initialize
	push	edi
	npad	5
$LL3@Initialize:

; 133  : 			pArray[i] = iDefault;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edi+eax*4], edx
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL3@Initialize
	pop	edi
$LN1@Initialize:
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ENDP	; CvDatabaseUtility::InitializeArray
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??1CvImprovementResourceInfo@@QAE@XZ		; CvImprovementResourceInfo::~CvImprovementResourceInfo
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
;	COMDAT ??1CvImprovementResourceInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvImprovementResourceInfo@@QAE@XZ PROC		; CvImprovementResourceInfo::~CvImprovementResourceInfo, COMDAT
; _this$ = ecx

; 36   : {

	push	esi
	mov	esi, ecx

; 37   : 	SAFE_DELETE_ARRAY(m_piYieldChange);

	mov	eax, DWORD PTR [esi+8]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
	pop	esi

; 38   : }

	ret	0
??1CvImprovementResourceInfo@@QAE@XZ ENDP		; CvImprovementResourceInfo::~CvImprovementResourceInfo
_TEXT	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_ECvImprovementResourceInfo@@QAEPAXI@Z	; CvImprovementResourceInfo::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_ECvImprovementResourceInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECvImprovementResourceInfo@@QAEPAXI@Z PROC		; CvImprovementResourceInfo::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	mov	esi, ecx
	test	bl, 2
	je	SHORT $LN3@vector
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET ??1CvImprovementResourceInfo@@QAE@XZ ; CvImprovementResourceInfo::~CvImprovementResourceInfo
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	12					; 0000000cH
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN2@vector
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$LN3@vector:
	mov	ecx, DWORD PTR [esi+8]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
	test	bl, 1
	je	SHORT $LN1@vector
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	4
??_ECvImprovementResourceInfo@@QAEPAXI@Z ENDP		; CvImprovementResourceInfo::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?GetArtDefineTag@CvImprovementEntry@@QBEPBDXZ	; CvImprovementEntry::GetArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?GetArtDefineTag@CvImprovementEntry@@QBEPBDXZ
_TEXT	SEGMENT
?GetArtDefineTag@CvImprovementEntry@@QBEPBDXZ PROC	; CvImprovementEntry::GetArtDefineTag, COMDAT
; _this$ = ecx

; 849  : 	return m_strArtDefineTag;

	add	ecx, 376				; 00000178H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetArtDefineTag@CvImprovementEntry@@QBEPBDXZ ENDP	; CvImprovementEntry::GetArtDefineTag
_TEXT	ENDS
PUBLIC	?SetArtDefineTag@CvImprovementEntry@@QAEXPBD@Z	; CvImprovementEntry::SetArtDefineTag
; Function compile flags: /Ogtpy
;	COMDAT ?SetArtDefineTag@CvImprovementEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?SetArtDefineTag@CvImprovementEntry@@QAEXPBD@Z PROC	; CvImprovementEntry::SetArtDefineTag, COMDAT
; _this$ = ecx

; 855  : 	m_strArtDefineTag = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 376				; 00000178H
	test	eax, eax
	je	SHORT $LN4@SetArtDefi
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@SetArtDefi:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 856  : }

	ret	4
?SetArtDefineTag@CvImprovementEntry@@QAEXPBD@Z ENDP	; CvImprovementEntry::SetArtDefineTag
_TEXT	ENDS
PUBLIC	?GetNumImprovements@CvImprovementXMLEntries@@QAEHXZ ; CvImprovementXMLEntries::GetNumImprovements
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumImprovements@CvImprovementXMLEntries@@QAEHXZ
_TEXT	SEGMENT
?GetNumImprovements@CvImprovementXMLEntries@@QAEHXZ PROC ; CvImprovementXMLEntries::GetNumImprovements, COMDAT
; _this$ = ecx

; 1181 : 	return m_paImprovementEntries.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1182 : }

	ret	0
?GetNumImprovements@CvImprovementXMLEntries@@QAEHXZ ENDP ; CvImprovementXMLEntries::GetNumImprovements
_TEXT	ENDS
PUBLIC	?GetEntry@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z ; CvImprovementXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetEntry@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetEntry@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z PROC ; CvImprovementXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 1191 : 	return m_paImprovementEntries[index];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1192 : }

	ret	4
?GetEntry@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z ENDP ; CvImprovementXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	?GetImprovementForResource@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z ; CvImprovementXMLEntries::GetImprovementForResource
; Function compile flags: /Ogtpy
;	COMDAT ?GetImprovementForResource@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z
_TEXT	SEGMENT
_eResource$ = 8						; size = 4
?GetImprovementForResource@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z PROC ; CvImprovementXMLEntries::GetImprovementForResource, COMDAT
; _this$ = ecx

; 1196 : {

	push	ebx
	push	ebp
	push	esi

; 1197 : 	for(unsigned int iImprovement = 0; iImprovement < m_paImprovementEntries.size(); ++iImprovement)

	mov	esi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+8]
	sub	ecx, esi
	sar	ecx, 2
	xor	edx, edx
	push	edi
	test	ecx, ecx
	jbe	SHORT $LN2@GetImprove@3
	mov	edi, DWORD PTR _eResource$[esp+12]
	npad	7
$LL18@GetImprove@3:

; 1198 : 	{
; 1199 : 		CvImprovementEntry* pImprovement = GetEntry((ImprovementTypes)iImprovement);

	mov	eax, DWORD PTR [esi]

; 1200 : 		if(pImprovement && pImprovement->IsImprovementResourceMakesValid(eResource))

	test	eax, eax
	je	SHORT $LN3@GetImprove@3
	mov	ebp, DWORD PTR [eax+488]
	lea	ebx, DWORD PTR [edi+edi*2]
	cmp	BYTE PTR [ebp+ebx*4+4], 0
	jne	SHORT $LN5@GetImprove@3
$LN3@GetImprove@3:

; 1197 : 	for(unsigned int iImprovement = 0; iImprovement < m_paImprovementEntries.size(); ++iImprovement)

	inc	edx
	add	esi, 4
	cmp	edx, ecx
	jb	SHORT $LL18@GetImprove@3
$LN2@GetImprove@3:

; 1201 : 		{
; 1202 : 			return pImprovement;
; 1203 : 		}
; 1204 : 	}
; 1205 : 
; 1206 : 	return NULL;

	xor	eax, eax
$LN5@GetImprove@3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1207 : }

	ret	4
?GetImprovementForResource@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z ENDP ; CvImprovementXMLEntries::GetImprovementForResource
_TEXT	ENDS
PUBLIC	?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; ImprovementArrayHelpers::Read
EXTRN	?LogMessage@CvGlobals@@QAEXPBD@Z:PROC		; CvGlobals::LogMessage
EXTRN	?getInfoTypeForHash@CvGlobals@@QBEHI_N@Z:PROC	; CvGlobals::getInfoTypeForHash
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z$0
__ehfuncinfo$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
xdata$x	ENDS
;	COMDAT ?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z
_TEXT	SEGMENT
_iNumEntries$ = -56					; size = 4
_uiHash$218783 = -52					; size = 4
_iArraySize$ = -48					; size = 4
_iDummy$218791 = -44					; size = 4
_szError$218789 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
_paiImprovementArray$ = 12				; size = 4
?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z PROC ; ImprovementArrayHelpers::Read, COMDAT

; 1222 : {

	push	-1
	push	__ehhandler$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	push	ebp
	push	esi

; 1223 : 	int iNumEntries;
; 1224 : 
; 1225 : 	kStream >> iNumEntries;

	mov	esi, DWORD PTR _kStream$[esp+60]
	lea	eax, DWORD PTR _iNumEntries$[esp+64]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1226 : 
; 1227 : 	int iArraySize = GC.getNumImprovementInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos

; 1228 : 	for(int iI = 0; iI < iNumEntries; iI++)

	xor	ebp, ebp
	cmp	DWORD PTR _iNumEntries$[esp+64], ebp
	mov	DWORD PTR _iArraySize$[esp+64], eax
	jle	$LN4@Read
$LL6@Read:

; 1229 : 	{
; 1230 : 		uint uiHash;
; 1231 : 		kStream >> uiHash;

	lea	ecx, DWORD PTR _uiHash$218783[esp+64]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 1232 : 		if (uiHash != 0 && uiHash != (uint)NO_IMPROVEMENT)

	mov	eax, DWORD PTR _uiHash$218783[esp+64]
	test	eax, eax
	je	$LN5@Read
	cmp	eax, -1
	je	$LN5@Read

; 1233 : 		{
; 1234 : 			int iType = GC.getInfoTypeForHash(uiHash);

	push	0
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForHash@CvGlobals@@QBEHI_N@Z ; CvGlobals::getInfoTypeForHash

; 1235 : 			if(iType != -1 && iType < iArraySize)

	cmp	eax, -1
	je	SHORT $LN2@Read
	cmp	eax, DWORD PTR _iArraySize$[esp+64]
	jge	SHORT $LN2@Read

; 1236 : 			{
; 1237 : 				kStream >> paiImprovementArray[iType];

	mov	edx, DWORD PTR _paiImprovementArray$[esp+60]
	lea	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1238 : 			}
; 1239 : 			else

	jmp	SHORT $LN5@Read
$LN2@Read:

; 1240 : 			{
; 1241 : 				CvString szError;

	lea	ecx, DWORD PTR _szError$218789[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1242 : 				szError.Format("LOAD ERROR: Improvement Type not found");

	lea	ecx, DWORD PTR _szError$218789[esp+64]
	push	OFFSET $SG218790
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+80], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 1243 : 				GC.LogMessage(szError.GetCString());

	lea	ecx, DWORD PTR _szError$218789[esp+64]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage

; 1244 : 				CvAssertMsg(false, szError);
; 1245 : 
; 1246 : 				int iDummy;
; 1247 : 				kStream >> iDummy;

	lea	edx, DWORD PTR _iDummy$218791[esp+64]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1248 : 			}

	lea	ecx, DWORD PTR _szError$218789[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@Read:
	inc	ebp
	cmp	ebp, DWORD PTR _iNumEntries$[esp+64]
	jl	$LL6@Read
$LN4@Read:

; 1249 : 		}
; 1250 : 	}
; 1251 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 56					; 00000038H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z$0:
	lea	ecx, DWORD PTR _szError$218789[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z:
	mov	eax, OFFSET __ehfuncinfo$?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z ENDP ; ImprovementArrayHelpers::Read
PUBLIC	?Write@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; ImprovementArrayHelpers::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
; Function compile flags: /Ogtpy
;	COMDAT ?Write@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
$T220235 = -4						; size = 4
_kStream$ = 8						; size = 4
_paiImprovementArray$ = 12				; size = 4
_iArraySize$ = 16					; size = 4
?Write@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAHH@Z PROC ; ImprovementArrayHelpers::Write, COMDAT

; 1255 : {

	push	ecx
	push	esi
	push	edi

; 1256 : 	kStream << iArraySize;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	eax, DWORD PTR _iArraySize$[esp+8]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1257 : 
; 1258 : 	for(int iI = 0; iI < iArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _iArraySize$[esp+8], esi
	jle	SHORT $LN3@Write
	push	ebx
	mov	ebx, DWORD PTR _paiImprovementArray$[esp+12]
$LL5@Write:

; 1259 : 	{
; 1260 : 		const ImprovementTypes eImprovement = static_cast<ImprovementTypes>(iI);
; 1261 : 		CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 1262 : 		if(pkImprovementInfo)

	test	eax, eax
	je	SHORT $LN2@Write

; 1263 : 		{
; 1264 : 			CvInfosSerializationHelper::WriteHashed(kStream, pkImprovementInfo);

	push	eax
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 1265 : 			kStream << paiImprovementArray[iI];

	push	ebx

; 1266 : 		}
; 1267 : 		else

	jmp	SHORT $LN16@Write
$LN2@Write:

; 1268 : 		{
; 1269 : 			kStream << (int)NO_IMPROVEMENT;

	lea	ecx, DWORD PTR $T220235[esp+16]
	mov	DWORD PTR $T220235[esp+16], -1
	push	ecx
$LN16@Write:
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	inc	esi
	add	ebx, 4
	cmp	esi, DWORD PTR _iArraySize$[esp+12]
	jl	SHORT $LL5@Write
	pop	ebx
$LN3@Write:
	pop	edi
	pop	esi

; 1270 : 		}
; 1271 : 	}
; 1272 : }

	pop	ecx
	ret	0
?Write@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ENDP ; ImprovementArrayHelpers::Write
_TEXT	ENDS
PUBLIC	?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::ReadYieldArray
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z$0
__ehfuncinfo$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
xdata$x	ENDS
;	COMDAT ?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z
_TEXT	SEGMENT
_iHash$218818 = -56					; size = 4
_iI$218814 = -52					; size = 4
_iNumEntries$ = -48					; size = 4
_iDummy$218834 = -44					; size = 4
_szError$218828 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
_ppaaiImprovementYieldArray$ = 12			; size = 4
_iNumYields$ = 16					; size = 4
?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z PROC ; ImprovementArrayHelpers::ReadYieldArray, COMDAT

; 1276 : {

	push	-1
	push	__ehhandler$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	push	ebp

; 1277 : 	int iNumEntries;
; 1278 : 
; 1279 : 	kStream >> iNumEntries;

	mov	ebp, DWORD PTR _kStream$[esp+56]
	lea	eax, DWORD PTR _iNumEntries$[esp+60]
	push	eax
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1280 : 
; 1281 : 	for(int iI = 0; iI < iNumEntries; iI++)

	cmp	DWORD PTR _iNumEntries$[esp+60], 0
	mov	DWORD PTR _iI$218814[esp+60], 0
	jle	$LN10@ReadYieldA
	push	ebx
	mov	ebx, DWORD PTR _iNumYields$[esp+60]
	push	esi
	push	edi
$LL39@ReadYieldA:

; 1282 : 	{
; 1283 : 		int iHash;
; 1284 : 		kStream >> iHash;

	lea	ecx, DWORD PTR _iHash$218818[esp+72]
	push	ecx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1285 : 		if(iHash != (int)0)

	mov	eax, DWORD PTR _iHash$218818[esp+72]
	xor	esi, esi
	cmp	eax, esi
	je	$LN11@ReadYieldA

; 1286 : 		{
; 1287 : 			int iType = GC.getInfoTypeForHash(iHash);

	push	esi
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForHash@CvGlobals@@QBEHI_N@Z ; CvGlobals::getInfoTypeForHash
	mov	edi, eax

; 1288 : 			if(iType != -1)

	cmp	edi, -1
	je	SHORT $LN8@ReadYieldA

; 1289 : 			{
; 1290 : 				for(int jJ = 0; jJ < iNumYields; jJ++)

	test	ebx, ebx
	jle	$LN11@ReadYieldA
	npad	8
$LL7@ReadYieldA:
	mov	edx, DWORD PTR _ppaaiImprovementYieldArray$[esp+68]
	mov	eax, DWORD PTR [edx+edi*4]
	lea	ecx, DWORD PTR [eax+esi*4]

; 1291 : 				{
; 1292 : 					kStream >> ppaaiImprovementYieldArray[iType][jJ];

	push	ecx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL7@ReadYieldA

; 1294 : 			}
; 1295 : 			else

	jmp	SHORT $LN11@ReadYieldA
$LN8@ReadYieldA:

; 1296 : 			{
; 1297 : 				CvString szError;

	lea	ecx, DWORD PTR _szError$218828[esp+72]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1298 : 				szError.Format("LOAD ERROR: Improvement Type not found: %08x", iHash);

	mov	edx, DWORD PTR _iHash$218818[esp+72]
	push	edx
	lea	eax, DWORD PTR _szError$218828[esp+76]
	push	OFFSET $SG218829
	push	eax
	mov	DWORD PTR __$EHRec$[esp+92], esi
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1299 : 				GC.LogMessage(szError.GetCString());

	lea	ecx, DWORD PTR _szError$218828[esp+72]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage

; 1300 : 				CvAssertMsg(false, szError);
; 1301 : 
; 1302 : 				for(int jJ = 0; jJ < iNumYields; jJ++)

	cmp	ebx, esi
	jle	SHORT $LN1@ReadYieldA

; 1293 : 				}

	mov	esi, ebx
	npad	7
$LL3@ReadYieldA:

; 1303 : 				{
; 1304 : 					int iDummy;
; 1305 : 					kStream >> iDummy;

	lea	ecx, DWORD PTR _iDummy$218834[esp+72]
	push	ecx
	mov	ecx, ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	sub	esi, 1
	jne	SHORT $LL3@ReadYieldA
$LN1@ReadYieldA:

; 1306 : 				}
; 1307 : 			}

	lea	ecx, DWORD PTR _szError$218828[esp+72]
	mov	DWORD PTR __$EHRec$[esp+80], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN11@ReadYieldA:
	mov	eax, DWORD PTR _iI$218814[esp+72]
	inc	eax
	cmp	eax, DWORD PTR _iNumEntries$[esp+72]
	mov	DWORD PTR _iI$218814[esp+72], eax
	jl	$LL39@ReadYieldA
	pop	edi
	pop	esi
	pop	ebx
$LN10@ReadYieldA:

; 1308 : 		}
; 1309 : 	}
; 1310 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 56					; 00000038H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z$0:
	lea	ecx, DWORD PTR _szError$218828[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z:
	mov	eax, OFFSET __ehfuncinfo$?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ReadYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ENDP ; ImprovementArrayHelpers::ReadYieldArray
PUBLIC	?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ; ImprovementArrayHelpers::WriteYieldArray
; Function compile flags: /Ogtpy
;	COMDAT ?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z
_TEXT	SEGMENT
$T220293 = -4						; size = 4
_kStream$ = 8						; size = 4
_ppaaiImprovementYieldArray$ = 12			; size = 4
_iArraySize$ = 16					; size = 4
?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z PROC ; ImprovementArrayHelpers::WriteYieldArray, COMDAT

; 1314 : {

	push	ecx
	push	ebp
	push	edi

; 1315 : 	kStream << iArraySize;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	eax, DWORD PTR _iArraySize$[esp+8]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1316 : 
; 1317 : 	for(int iI = 0; iI < iArraySize; iI++)

	xor	ebp, ebp
	cmp	DWORD PTR _iArraySize$[esp+8], ebp
	jle	SHORT $LN6@WriteYield
	push	ebx
	mov	ebx, DWORD PTR _ppaaiImprovementYieldArray$[esp+12]
	push	esi
$LL21@WriteYield:

; 1318 : 	{
; 1319 : 		const ImprovementTypes eImprovement = static_cast<ImprovementTypes>(iI);
; 1320 : 		CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 1321 : 		if(pkImprovementInfo)

	xor	esi, esi
	cmp	eax, esi
	je	SHORT $LN5@WriteYield

; 1322 : 		{
; 1323 : 			CvInfosSerializationHelper::WriteHashed(kStream, pkImprovementInfo);

	push	eax
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	npad	4
$LL4@WriteYield:

; 1324 : 			for(int jJ = 0; jJ < NUM_YIELD_TYPES; jJ++)
; 1325 : 			{
; 1326 : 				kStream << ppaaiImprovementYieldArray[iI][jJ];

	mov	ecx, DWORD PTR [ebx]
	add	ecx, esi
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	cmp	esi, 24					; 00000018H
	jl	SHORT $LL4@WriteYield

; 1327 : 			}
; 1328 : 		}
; 1329 : 		else

	jmp	SHORT $LN7@WriteYield
$LN5@WriteYield:

; 1330 : 		{
; 1331 : 			kStream << (int)0;

	lea	edx, DWORD PTR $T220293[esp+20]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR $T220293[esp+24], esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN7@WriteYield:
	inc	ebp
	add	ebx, 4
	cmp	ebp, DWORD PTR _iArraySize$[esp+16]
	jl	SHORT $LL21@WriteYield
	pop	esi
	pop	ebx
$LN6@WriteYield:
	pop	edi
	pop	ebp

; 1332 : 		}
; 1333 : 	}
; 1334 : }

	pop	ecx
	ret	0
?WriteYieldArray@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAPAHH@Z ENDP ; ImprovementArrayHelpers::WriteYieldArray
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEAAPAVCvImprovementEntry@@XZ ; std::_Vector_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator*
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEAAPAVCvImprovementEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEAAPAVCvImprovementEntry@@XZ PROC ; std::_Vector_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEAAPAVCvImprovementEntry@@XZ ENDP ; std::_Vector_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::~_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::~_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::~_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE@V?$allocator@PAVCvImprovementEntry@@@1@@Z ; std::_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE@V?$allocator@PAVCvImprovementEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE@V?$allocator@PAVCvImprovementEntry@@@1@@Z PROC ; std::_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE@V?$allocator@PAVCvImprovementEntry@@@1@@Z ENDP ; std::_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Vector_val<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@PAPAVCvImprovementEntry@@@Z ; std::_Vector_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Vector_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@PAPAVCvImprovementEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@PAPAVCvImprovementEntry@@@Z PROC ; std::_Vector_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Vector_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@PAPAVCvImprovementEntry@@@Z ENDP ; std::_Vector_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Vector_iterator<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@@Z ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@@Z PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@@Z ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEIXZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvImprovementEntry@@@std@@QAEPAPAVCvImprovementEntry@@I@Z ; std::allocator<CvImprovementEntry *>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvImprovementEntry@@@std@@QAEPAPAVCvImprovementEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvImprovementEntry@@@std@@QAEPAPAVCvImprovementEntry@@I@Z PROC ; std::allocator<CvImprovementEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvImprovementEntry@@@std@@YAPAPAVCvImprovementEntry@@IPAPAV1@@Z ; std::_Allocate<CvImprovementEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvImprovementEntry@@@std@@QAEPAPAVCvImprovementEntry@@I@Z ENDP ; std::allocator<CvImprovementEntry *>::allocate
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@VCvImprovementResourceInfo@@@@YAXAAPAVCvImprovementResourceInfo@@@Z ; SAFE_DELETE_ARRAY<CvImprovementResourceInfo>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@VCvImprovementResourceInfo@@@@YAXAAPAVCvImprovementResourceInfo@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@VCvImprovementResourceInfo@@@@YAXAAPAVCvImprovementResourceInfo@@@Z PROC ; SAFE_DELETE_ARRAY<CvImprovementResourceInfo>, COMDAT

; 311  : {

	push	edi

; 312  : 	delete[] pkInstanceArray;

	mov	edi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN14@SAFE_DELET
	mov	ecx, DWORD PTR [eax-4]
	push	esi
	lea	esi, DWORD PTR [eax-4]
	push	OFFSET ??1CvImprovementResourceInfo@@QAE@XZ ; CvImprovementResourceInfo::~CvImprovementResourceInfo
	push	ecx
	push	12					; 0000000cH
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	esi
$LN14@SAFE_DELET:

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@VCvImprovementResourceInfo@@@@YAXAAPAVCvImprovementResourceInfo@@@Z ENDP ; SAFE_DELETE_ARRAY<CvImprovementResourceInfo>
_TEXT	ENDS
PUBLIC	??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z ; CvDatabaseUtility::InitializeArray<int>
EXTRN	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z:PROC	; CvDatabaseUtility::MaxRows
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z
_TEXT	SEGMENT
_pArray$ = 8						; size = 4
_szTableName$ = 12					; size = 4
_default$ = 16						; size = 4
??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z PROC ; CvDatabaseUtility::InitializeArray<int>, COMDAT
; _this$ = ecx

; 180  : 	size_t count = MaxRows(szTableName);

	mov	eax, DWORD PTR _szTableName$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 181  : 
; 182  : 	//This is a bit of a hack to support empty tables.
; 183  : 	//For example, the "Automates" table will be empty during a tutorial.
; 184  : 	//We cannot simply NULL out the array because WAY too much code blindly assumes SOMETHING will be there..
; 185  : 	//Instead we allocate room for 1 element and just roll with it.
; 186  : 
; 187  : 	//CvAssertMsg(count > 0, DB.ErrorMessage());
; 188  : 	if(count == 0)

	test	eax, eax
	jne	SHORT $LN1@Initialize@2

; 189  : 		count = 1;

	mov	eax, 1
$LN1@Initialize@2:

; 190  : 
; 191  : 	InitializeArray(pArray, count, default);

	mov	ecx, DWORD PTR _default$[esp]
	mov	edx, DWORD PTR _pArray$[esp]
	push	ecx
	push	eax
	push	edx
	mov	ecx, esi
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
	pop	esi

; 192  : }

	ret	12					; 0000000cH
??$InitializeArray@H@CvDatabaseUtility@@QAEXAAPAHPBDH@Z ENDP ; CvDatabaseUtility::InitializeArray<int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvImprovementEntry@@PAPAV1@@stdext@@YAPAPAVCvImprovementEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvImprovementEntry * *,CvImprovementEntry * *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvImprovementEntry@@PAPAV1@@stdext@@YAPAPAVCvImprovementEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvImprovementEntry@@PAPAV1@@stdext@@YAPAPAVCvImprovementEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvImprovementEntry * *,CvImprovementEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvImprovementEntry@@PAPAV1@@stdext@@YAPAPAVCvImprovementEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvImprovementEntry * *,CvImprovementEntry * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@YAXPAPAVCvImprovementEntry@@0AAV?$allocator@PAVCvImprovementEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvImprovementEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@YAXPAPAVCvImprovementEntry@@0AAV?$allocator@PAVCvImprovementEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@YAXPAPAVCvImprovementEntry@@0AAV?$allocator@PAVCvImprovementEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvImprovementEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@YAXPAPAVCvImprovementEntry@@0AAV?$allocator@PAVCvImprovementEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvImprovementEntry *> >
_TEXT	ENDS
PUBLIC	??_7CvImprovementEntry@@6B@			; CvImprovementEntry::`vftable'
PUBLIC	??0CvImprovementEntry@@QAE@XZ			; CvImprovementEntry::CvImprovementEntry
PUBLIC	??_R4CvImprovementEntry@@6B@			; CvImprovementEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvImprovementEntry@@@8			; CvImprovementEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvImprovementEntry@@8			; CvImprovementEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvImprovementEntry@@8			; CvImprovementEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvImprovementEntry@@8		; CvImprovementEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvImprovementEntry::CacheResults
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_R2CvBaseInfo@@8
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvImprovementEntry@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvImprovementEntry@@8 DD FLAT:??_R0?AVCvImprovementEntry@@@8 ; CvImprovementEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvImprovementEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvImprovementEntry@@8
rdata$r	SEGMENT
??_R2CvImprovementEntry@@8 DD FLAT:??_R1A@?0A@EA@CvImprovementEntry@@8 ; CvImprovementEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvImprovementEntry@@8
rdata$r	SEGMENT
??_R3CvImprovementEntry@@8 DD 00H			; CvImprovementEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvImprovementEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvImprovementEntry@@@8
_DATA	SEGMENT
??_R0?AVCvImprovementEntry@@@8 DD FLAT:??_7type_info@@6B@ ; CvImprovementEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvImprovementEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvImprovementEntry@@6B@
rdata$r	SEGMENT
??_R4CvImprovementEntry@@6B@ DD 00H			; CvImprovementEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvImprovementEntry@@@8
	DD	FLAT:??_R3CvImprovementEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvImprovementEntry@@6B@
CONST	SEGMENT
??_7CvImprovementEntry@@6B@ DD FLAT:??_R4CvImprovementEntry@@6B@ ; CvImprovementEntry::`vftable'
	DD	FLAT:?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvImprovementEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvImprovementEntry@@QAE@XZ$0
__ehfuncinfo$??0CvImprovementEntry@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvImprovementEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvImprovementEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvImprovementEntry@@QAE@XZ PROC			; CvImprovementEntry::CvImprovementEntry, COMDAT
; _this$ = ecx

; 146  : {

	push	-1
	push	__ehhandler$??0CvImprovementEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	ebx, ebx
	or	edi, -1
	lea	ecx, DWORD PTR [esi+376]
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	mov	DWORD PTR [esi], OFFSET ??_7CvImprovementEntry@@6B@
	mov	DWORD PTR [esi+260], ebx
	mov	DWORD PTR [esi+264], ebx
	mov	DWORD PTR [esi+268], ebx
	mov	DWORD PTR [esi+272], ebx
	mov	DWORD PTR [esi+276], ebx
	mov	DWORD PTR [esi+280], ebx
	mov	DWORD PTR [esi+284], ebx
	mov	DWORD PTR [esi+288], ebx
	mov	DWORD PTR [esi+292], ebx
	mov	DWORD PTR [esi+296], ebx
	mov	DWORD PTR [esi+300], ebx
	mov	DWORD PTR [esi+304], ebx
	mov	DWORD PTR [esi+308], ebx
	mov	DWORD PTR [esi+312], ebx
	mov	DWORD PTR [esi+316], ebx
	mov	DWORD PTR [esi+320], ebx
	mov	DWORD PTR [esi+324], ebx
	mov	DWORD PTR [esi+328], ebx
	mov	DWORD PTR [esi+332], edi
	mov	DWORD PTR [esi+336], edi
	mov	DWORD PTR [esi+340], edi
	mov	BYTE PTR [esi+344], bl
	mov	BYTE PTR [esi+345], bl
	mov	BYTE PTR [esi+346], bl
	mov	BYTE PTR [esi+347], bl
	mov	BYTE PTR [esi+348], bl
	mov	BYTE PTR [esi+349], bl
	mov	BYTE PTR [esi+350], bl
	mov	BYTE PTR [esi+351], bl
	mov	BYTE PTR [esi+352], bl
	mov	BYTE PTR [esi+353], bl
	mov	BYTE PTR [esi+354], bl
	mov	BYTE PTR [esi+355], bl
	mov	BYTE PTR [esi+356], bl
	mov	BYTE PTR [esi+357], bl
	mov	BYTE PTR [esi+358], bl
	mov	BYTE PTR [esi+359], bl
	mov	BYTE PTR [esi+360], bl
	mov	BYTE PTR [esi+361], bl
	mov	BYTE PTR [esi+362], bl
	mov	BYTE PTR [esi+363], bl
	mov	BYTE PTR [esi+364], bl
	mov	BYTE PTR [esi+365], bl
	mov	BYTE PTR [esi+366], bl
	mov	BYTE PTR [esi+367], bl
	mov	BYTE PTR [esi+368], bl
	mov	BYTE PTR [esi+369], bl
	mov	BYTE PTR [esi+370], bl
	mov	BYTE PTR [esi+371], bl
	mov	BYTE PTR [esi+372], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR [esi+404], ebx
	mov	DWORD PTR [esi+408], edi
	mov	DWORD PTR [esi+412], ebx
	mov	DWORD PTR [esi+416], ebx
	mov	DWORD PTR [esi+420], ebx
	mov	DWORD PTR [esi+424], ebx
	mov	DWORD PTR [esi+428], ebx
	mov	DWORD PTR [esi+432], ebx
	mov	DWORD PTR [esi+436], ebx
	mov	DWORD PTR [esi+440], ebx
	mov	DWORD PTR [esi+444], ebx
	mov	DWORD PTR [esi+448], ebx
	mov	DWORD PTR [esi+452], ebx
	mov	DWORD PTR [esi+456], ebx
	mov	DWORD PTR [esi+460], ebx
	mov	DWORD PTR [esi+464], ebx
	mov	DWORD PTR [esi+468], ebx
	mov	DWORD PTR [esi+472], ebx

; 147  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR [esi+476], ebx
	mov	DWORD PTR [esi+480], ebx
	mov	DWORD PTR [esi+484], ebx
	mov	DWORD PTR [esi+488], ebx
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvImprovementEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??0CvImprovementEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvImprovementEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvImprovementEntry@@QAE@XZ ENDP			; CvImprovementEntry::CvImprovementEntry
PUBLIC	??1CvImprovementEntry@@QAE@XZ			; CvImprovementEntry::~CvImprovementEntry
EXTRN	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z:PROC ; CvDatabaseUtility::SafeDelete2DArray
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvImprovementEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvImprovementEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvImprovementEntry@@QAE@XZ$1
__ehfuncinfo$??1CvImprovementEntry@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvImprovementEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvImprovementEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvImprovementEntry@@QAE@XZ PROC			; CvImprovementEntry::~CvImprovementEntry, COMDAT
; _this$ = ecx

; 151  : {

	push	-1
	push	__ehhandler$??1CvImprovementEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvImprovementEntry@@6B@

; 152  : 	SAFE_DELETE_ARRAY(m_piResourceQuantityRequirements);

	mov	eax, DWORD PTR [esi+416]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], 1
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+416], ebx

; 153  : 	SAFE_DELETE_ARRAY(m_piPrereqNatureYield);

	mov	eax, DWORD PTR [esi+420]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+420], ebx

; 154  : 	SAFE_DELETE_ARRAY(m_piYieldChange);

	mov	eax, DWORD PTR [esi+424]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+424], ebx

; 155  : 	SAFE_DELETE_ARRAY(m_piYieldPerEra);

	mov	eax, DWORD PTR [esi+428]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+428], ebx

; 156  : 	SAFE_DELETE_ARRAY(m_piRiverSideYieldChange);

	mov	eax, DWORD PTR [esi+432]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+432], ebx

; 157  : 	SAFE_DELETE_ARRAY(m_piCoastalLandYieldChange);

	mov	eax, DWORD PTR [esi+436]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+436], ebx

; 158  : 	SAFE_DELETE_ARRAY(m_piHillsYieldChange);

	mov	eax, DWORD PTR [esi+440]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+440], ebx

; 159  : 	SAFE_DELETE_ARRAY(m_piFreshWaterChange);

	mov	eax, DWORD PTR [esi+444]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+444], ebx

; 160  : 	SAFE_DELETE_ARRAY(m_piAdjacentCityYieldChange);

	mov	eax, DWORD PTR [esi+448]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+448], ebx

; 161  : 	SAFE_DELETE_ARRAY(m_piAdjacentMountainYieldChange);

	mov	eax, DWORD PTR [esi+452]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+452], ebx

; 162  : 	SAFE_DELETE_ARRAY(m_piFlavorValue);

	mov	eax, DWORD PTR [esi+456]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+456], ebx

; 163  : 	SAFE_DELETE_ARRAY(m_pbTerrainMakesValid);

	mov	eax, DWORD PTR [esi+460]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+460], ebx

; 164  : 	SAFE_DELETE_ARRAY(m_pbFeatureMakesValid);

	mov	eax, DWORD PTR [esi+464]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+464], ebx

; 165  : 	SAFE_DELETE_ARRAY(m_pbImprovementMakesValid);

	mov	eax, DWORD PTR [esi+468]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 56					; 00000038H
	mov	DWORD PTR [esi+468], ebx

; 166  : 
; 167  : 	if(m_paImprovementResource != NULL)

	cmp	DWORD PTR [esi+488], ebx
	je	SHORT $LN38@CvImprovem

; 168  : 	{
; 169  : 		SAFE_DELETE_ARRAY(m_paImprovementResource); // XXX make sure this isn't leaking memory...

	mov	eax, DWORD PTR [esi+488]
	cmp	eax, ebx
	je	SHORT $LN40@CvImprovem
	mov	ecx, DWORD PTR [eax-4]
	push	edi
	lea	edi, DWORD PTR [eax-4]
	push	OFFSET ??1CvImprovementResourceInfo@@QAE@XZ ; CvImprovementResourceInfo::~CvImprovementResourceInfo
	push	ecx
	push	12					; 0000000cH
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	edi
$LN40@CvImprovem:
	mov	DWORD PTR [esi+488], ebx
$LN38@CvImprovem:

; 170  : 	}
; 171  : 
; 172  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 173  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiTechYieldChanges.first, m_ppiTechYieldChanges.second);
; 174  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiTechNoFreshWaterYieldChanges.first, m_ppiTechNoFreshWaterYieldChanges.second);
; 175  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiTechFreshWaterYieldChanges.first, m_ppiTechFreshWaterYieldChanges.second);
; 176  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiRouteYieldChanges.first, m_ppiRouteYieldChanges.second);
; 177  : #else
; 178  : 	if(m_ppiTechYieldChanges != NULL)

	cmp	DWORD PTR [esi+472], ebx
	lea	eax, DWORD PTR [esi+472]
	je	SHORT $LN4@CvImprovem

; 179  : 	{
; 180  : 		CvDatabaseUtility::SafeDelete2DArray(m_ppiTechYieldChanges);

	push	eax
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4
$LN4@CvImprovem:

; 181  : 	}
; 182  : 
; 183  : 	if(m_ppiTechNoFreshWaterYieldChanges != NULL)

	cmp	DWORD PTR [esi+476], ebx
	lea	eax, DWORD PTR [esi+476]
	je	SHORT $LN3@CvImprovem

; 184  : 	{
; 185  : 		CvDatabaseUtility::SafeDelete2DArray(m_ppiTechNoFreshWaterYieldChanges);

	push	eax
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4
$LN3@CvImprovem:

; 186  : 	}
; 187  : 
; 188  : 	if(m_ppiTechFreshWaterYieldChanges != NULL)

	cmp	DWORD PTR [esi+480], ebx
	lea	eax, DWORD PTR [esi+480]
	je	SHORT $LN2@CvImprovem

; 189  : 	{
; 190  : 		CvDatabaseUtility::SafeDelete2DArray(m_ppiTechFreshWaterYieldChanges);

	push	eax
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4
$LN2@CvImprovem:

; 191  : 	}
; 192  : 
; 193  : 	if(m_ppiRouteYieldChanges != NULL)

	cmp	DWORD PTR [esi+484], ebx
	lea	eax, DWORD PTR [esi+484]
	je	SHORT $LN1@CvImprovem

; 194  : 	{
; 195  : 		CvDatabaseUtility::SafeDelete2DArray(m_ppiRouteYieldChanges);

	push	eax
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4
$LN1@CvImprovem:

; 196  : 	}
; 197  : #endif
; 198  : }

	lea	ecx, DWORD PTR [esi+376]
	mov	BYTE PTR __$EHRec$[esp+32], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvImprovementEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvImprovementEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 376				; 00000178H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvImprovementEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvImprovementEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvImprovementEntry@@QAE@XZ ENDP			; CvImprovementEntry::~CvImprovementEntry
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	?Initialize2DArray@CvDatabaseUtility@@QAEXAAPAPAHIIH@Z:PROC ; CvDatabaseUtility::Initialize2DArray
EXTRN	?getNumTechInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumTechInfos
EXTRN	__imp_?Reset@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z:PROC
EXTRN	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; CvDatabaseUtility::PrepareResults
EXTRN	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CvDatabaseUtility::GetResults
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z:PROC ; CvDatabaseUtility::SetYields
EXTRN	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z:PROC ; CvDatabaseUtility::PopulateArrayByExistence
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
xdata$x	SEGMENT
__ehfuncinfo$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_yield_idx$218231 = -116				; size = 4
_yield_idx$218220 = -116				; size = 4
_pYieldResults$218185 = -116				; size = 4
_lenImprovementType$ = -112				; size = 4
_yield_idx$218242 = -108				; size = 4
_iNumTechs$ = -108					; size = 4
_pResourceInfo$218193 = -108				; size = 4
tv1093 = -104						; size = 4
_count$220686 = -104					; size = 4
_iNumYields$ = -104					; size = 4
_idx$218191 = -104					; size = 4
tv1168 = -100						; size = 4
_tech_idx$218243 = -100					; size = 4
_tech_idx$218232 = -100					; size = 4
_tech_idx$218221 = -100					; size = 4
_yieldIdx$218205 = -100					; size = 4
_szResourceType$218194 = -100				; size = 4
$T220618 = -100						; size = 4
_strYieldResultsKey$218183 = -96			; size = 28
_strKey$218234 = -68					; size = 28
_strKey$218223 = -68					; size = 28
_strKey$218212 = -68					; size = 28
_strResourceTypesKey$218178 = -68			; size = 28
_strKey$218247 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_szImprovementType$ = 8					; size = 4
_kResults$ = 8						; size = 4
_route_idx$218256 = 12					; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvImprovementEntry::CacheResults, COMDAT
; _this$ = ecx

; 202  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax

; 203  : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 104				; 00000068H
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+120]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN21@CacheResul
	pop	edi
	pop	esi

; 530  : 
; 531  : 	return true;
; 532  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+116]
	mov	DWORD PTR fs:0, ecx
	add	esp, 116				; 00000074H
	ret	8
$LN21@CacheResul:

; 204  : 		return false;
; 205  : 
; 206  : 	//Basic properties
; 207  : 	const char* szArtDefineTag = kResults.GetText("ArtDefineTag");

	push	OFFSET $SG218069
	mov	ecx, edi
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 208  : 	SetArtDefineTag(szArtDefineTag);

	lea	ecx, DWORD PTR [esi+376]
	test	eax, eax
	je	SHORT $LN36@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN35@CacheResul
$LN36@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN35@CacheResul:
	push	ebx

; 209  : 
; 210  : 	m_iGoldMaintenance = kResults.GetInt("GoldMaintenance");

	mov	ebx, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	ebp
	push	OFFSET $SG218070
	mov	ecx, edi
	call	ebx

; 211  : 	m_iCultureBombRadius = kResults.GetInt("CultureBombRadius");

	push	OFFSET $SG218071
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebx

; 212  : 	m_iCultureBombRadiusNeutral = kResults.GetInt("CultureBombRadiusNeutral");

	push	OFFSET $SG218072
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebx

; 213  : 	m_iRequiresXAdjacentLand = kResults.GetInt("RequiresXAdjacentLand");

	push	OFFSET $SG218073
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebx

; 214  : 	m_iCultureAdjacentSameType = kResults.GetInt("CultureAdjacentSameType");

	push	OFFSET $SG218074
	mov	ecx, edi
	mov	DWORD PTR [esi+340], eax
	call	ebx

; 215  : 	m_bHillsMakesValid = kResults.GetBool("HillsMakesValid");

	mov	ebp, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG218075
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebp

; 216  : 	m_bWaterAdjacencyMakesValid = kResults.GetBool("WaterAdjacencyMakesValid");

	push	OFFSET $SG218076
	mov	ecx, edi
	mov	BYTE PTR [esi+344], al
	call	ebp

; 217  : 	m_bFreshWaterMakesValid = kResults.GetBool("FreshWaterMakesValid");

	push	OFFSET $SG218077
	mov	ecx, edi
	mov	BYTE PTR [esi+345], al
	call	ebp

; 218  : 	m_bRiverSideMakesValid = kResults.GetBool("RiverSideMakesValid");

	push	OFFSET $SG218078
	mov	ecx, edi
	mov	BYTE PTR [esi+346], al
	call	ebp

; 219  : 	m_bNoFreshWater = kResults.GetBool("NoFreshWater");

	push	OFFSET $SG218079
	mov	ecx, edi
	mov	BYTE PTR [esi+347], al
	call	ebp

; 220  : 	m_bRequiresFlatlands = kResults.GetBool("RequiresFlatlands");

	push	OFFSET $SG218080
	mov	ecx, edi
	mov	BYTE PTR [esi+348], al
	call	ebp

; 221  : 	m_bRequiresFlatlandsOrFreshWater = kResults.GetBool("RequiresFlatlandsOrFreshWater");

	push	OFFSET $SG218081
	mov	ecx, edi
	mov	BYTE PTR [esi+349], al
	call	ebp

; 222  : 	m_bRequiresFeature = kResults.GetBool("RequiresFeature");

	push	OFFSET $SG218082
	mov	ecx, edi
	mov	BYTE PTR [esi+350], al
	call	ebp

; 223  : 	m_bRequiresImprovement = kResults.GetBool("RequiresImprovement");

	push	OFFSET $SG218083
	mov	ecx, edi
	mov	BYTE PTR [esi+351], al
	call	ebp

; 224  : 	m_bRemovesResource = kResults.GetBool("RemovesResource");

	push	OFFSET $SG218084
	mov	ecx, edi
	mov	BYTE PTR [esi+352], al
	call	ebp

; 225  : 	m_bPromptWhenComplete = kResults.GetBool("PromptWhenComplete");

	push	OFFSET $SG218085
	mov	ecx, edi
	mov	BYTE PTR [esi+353], al
	call	ebp

; 226  : 	m_bWater = kResults.GetBool("Water");

	push	OFFSET $SG218086
	mov	ecx, edi
	mov	BYTE PTR [esi+354], al
	call	ebp

; 227  : 	m_bCoastal = kResults.GetBool("Coastal");

	push	OFFSET $SG218087
	mov	ecx, edi
	mov	BYTE PTR [esi+355], al
	call	ebp

; 228  : 	m_bDestroyedWhenPillaged = kResults.GetBool("DestroyedWhenPillaged");

	push	OFFSET $SG218088
	mov	ecx, edi
	mov	BYTE PTR [esi+356], al
	call	ebp
	mov	BYTE PTR [esi+357], al

; 229  : 	m_bDisplacePillager = kResults.GetBool("DisplacePillager");

	push	OFFSET $SG218089
	mov	ecx, edi
	call	ebp

; 230  : 	m_bBuildableOnResources = kResults.GetBool("BuildableOnResources");

	push	OFFSET $SG218090
	mov	ecx, edi
	mov	BYTE PTR [esi+358], al
	call	ebp

; 231  : 	m_eImprovementUsageType = m_bBuildableOnResources ? IMPROVEMENTUSAGE_LANDMARK : IMPROVEMENTUSAGE_BASIC;

	xor	ecx, ecx
	test	al, al
	setne	cl

; 232  : 	m_bBarbarianCamp = kResults.GetBool("BarbarianCamp");

	push	OFFSET $SG218091
	mov	BYTE PTR [esi+359], al
	mov	DWORD PTR [esi+404], ecx
	mov	ecx, edi
	call	ebp

; 233  : 	m_bGoody = kResults.GetBool("Goody");

	push	OFFSET $SG218092
	mov	ecx, edi
	mov	BYTE PTR [esi+360], al
	call	ebp

; 234  : 	m_bPermanent = kResults.GetBool("Permanent");

	push	OFFSET $SG218093
	mov	ecx, edi
	mov	BYTE PTR [esi+361], al
	call	ebp

; 235  : 	m_iTilesPerGoody = kResults.GetInt("TilesPerGoody");

	push	OFFSET $SG218094
	mov	ecx, edi
	mov	BYTE PTR [esi+362], al
	call	ebx

; 236  : 	m_iGoodyUniqueRange = kResults.GetInt("GoodyRange");

	push	OFFSET $SG218095
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebx

; 237  : 	m_iFeatureGrowthProbability = kResults.GetInt("FeatureGrowth");

	push	OFFSET $SG218096
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebx

; 238  : 	m_iUpgradeTime = kResults.GetInt("UpgradeTime");

	push	OFFSET $SG218097
	mov	ecx, edi
	mov	DWORD PTR [esi+284], eax
	call	ebx

; 239  : 	m_iRiverSideUpgradeMod = kResults.GetInt("RiverSideUpgradeMod");

	push	OFFSET $SG218098
	mov	ecx, edi
	mov	DWORD PTR [esi+288], eax
	call	ebx

; 240  : 	m_iCoastalLandUpgradeMod = kResults.GetInt("CoastalLandUpgradeMod");

	push	OFFSET $SG218099
	mov	ecx, edi
	mov	DWORD PTR [esi+292], eax
	call	ebx

; 241  : 	m_iHillsUpgradeMod = kResults.GetInt("HillsUpgradeMod");

	push	OFFSET $SG218100
	mov	ecx, edi
	mov	DWORD PTR [esi+296], eax
	call	ebx

; 242  : 	m_iFreshWaterUpgradeMod = kResults.GetInt("FreshWaterUpgradeMod");

	push	OFFSET $SG218101
	mov	ecx, edi
	mov	DWORD PTR [esi+300], eax
	call	ebx

; 243  : 	m_iDefenseModifier = kResults.GetInt("DefenseModifier");

	push	OFFSET $SG218102
	mov	ecx, edi
	mov	DWORD PTR [esi+304], eax
	call	ebx

; 244  : 	m_iDefenseModifierGlobal = kResults.GetInt("DefenseModifierGlobal");

	push	OFFSET $SG218103
	mov	ecx, edi
	mov	DWORD PTR [esi+308], eax
	call	ebx

; 245  : 	m_iNearbyEnemyDamage = kResults.GetInt("NearbyEnemyDamage");

	push	OFFSET $SG218104
	mov	ecx, edi
	mov	DWORD PTR [esi+312], eax
	call	ebx

; 246  : 	m_iPillageGold = kResults.GetInt("PillageGold");

	push	OFFSET $SG218105
	mov	ecx, edi
	mov	DWORD PTR [esi+316], eax
	call	ebx

; 247  : 	m_bOutsideBorders = kResults.GetBool("OutsideBorders");

	push	OFFSET $SG218106
	mov	ecx, edi
	mov	DWORD PTR [esi+320], eax
	call	ebp

; 248  : 	m_bInAdjacentFriendly = kResults.GetBool("InAdjacentFriendly");

	push	OFFSET $SG218107
	mov	ecx, edi
	mov	BYTE PTR [esi+363], al
	call	ebp
	mov	BYTE PTR [esi+364], al

; 249  : 	m_bIgnoreOwnership = kResults.GetBool("IgnoreOwnership");

	push	OFFSET $SG218108
	mov	ecx, edi
	call	ebp

; 250  : 	m_bOnlyCityStateTerritory = kResults.GetBool("OnlyCityStateTerritory");

	push	OFFSET $SG218109
	mov	ecx, edi
	mov	BYTE PTR [esi+365], al
	call	ebp

; 251  : 	m_bNoTwoAdjacent = kResults.GetBool("NoTwoAdjacent");

	push	OFFSET $SG218110
	mov	ecx, edi
	mov	BYTE PTR [esi+366], al
	call	ebp

; 252  : 	m_bAdjacentLuxury = kResults.GetBool("AdjacentLuxury");

	push	OFFSET $SG218111
	mov	ecx, edi
	mov	BYTE PTR [esi+367], al
	call	ebp

; 253  : 	m_bAllowsWalkWater = kResults.GetBool("AllowsWalkWater");

	push	OFFSET $SG218112
	mov	ecx, edi
	mov	BYTE PTR [esi+368], al
	call	ebp

; 254  : 	m_bAllowsSailLand = kResults.GetBool("AllowsSailLand"); // from Izy

	push	OFFSET $SG218113
	mov	ecx, edi
	mov	BYTE PTR [esi+369], al
	call	ebp

; 255  : 	m_bCreatedByGreatPerson = kResults.GetBool("CreatedByGreatPerson");

	push	OFFSET $SG218114
	mov	ecx, edi
	mov	BYTE PTR [esi+370], al
	call	ebp

; 256  : 	m_bSpecificCivRequired = kResults.GetBool("SpecificCivRequired");

	push	OFFSET $SG218115
	mov	ecx, edi
	mov	BYTE PTR [esi+371], al
	call	ebp

; 257  : 	m_iResourceExtractionMod = kResults.GetInt("ResourceExtractionMod");

	push	OFFSET $SG218116
	mov	ecx, edi
	mov	BYTE PTR [esi+372], al
	call	ebx

; 258  : 	m_iLuxuryCopiesSiphonedFromMinor = kResults.GetInt("LuxuryCopiesSiphonedFromMinor");

	push	OFFSET $SG218117
	mov	ecx, edi
	mov	DWORD PTR [esi+324], eax
	call	ebx

; 259  : 
; 260  : 	const char* szCivilizationType = kResults.GetText("CivilizationType");

	push	OFFSET $SG218119
	mov	ecx, edi
	mov	DWORD PTR [esi+328], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 261  : 	m_eRequiredCivilization = (CivilizationTypes)GC.getInfoTypeForString(szCivilizationType, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 262  : 
; 263  : 	//References
; 264  : 	const char* szWorldsoundscapeAudioScript = kResults.GetText("WorldSoundscapeAudioScript");

	push	OFFSET $SG218122
	mov	ecx, edi
	mov	DWORD PTR [esi+408], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 265  : 	if(szWorldsoundscapeAudioScript != NULL)

	test	eax, eax
	je	SHORT $LN20@CacheResul

; 266  : 	{
; 267  : 		m_iWorldSoundscapeScriptId = gDLL->GetAudioTagIndex(szWorldsoundscapeAudioScript, AUDIOTAG_SOUNDSCAPE);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	edx, DWORD PTR [ecx]
	push	5
	push	eax
	mov	eax, DWORD PTR [edx+508]
	call	eax
	mov	DWORD PTR [esi+412], eax

; 268  : 	}
; 269  : 	else

	jmp	SHORT $LN19@CacheResul
$LN20@CacheResul:

; 270  : 	{
; 271  : 		m_iWorldSoundscapeScriptId = -1;
; 272  : 		Remark(1, "Warning: Missing soundscape definition in XML for feature: '%s'", GetType());

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+412], -1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG218125
	push	1
	call	?Remark@@YA_NHPBDZZ			; Remark
	add	esp, 12					; 0000000cH
$LN19@CacheResul:

; 273  : 	}
; 274  : 
; 275  : 	const char* szImprovementPillage = kResults.GetText("ImprovementPillage");

	push	OFFSET $SG218127
	mov	ecx, edi
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 276  : 	m_iImprovementPillage = GC.getInfoTypeForString(szImprovementPillage, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 277  : 
; 278  : 	const char* szImprovementUpgrade = kResults.GetText("ImprovementUpgrade");

	push	OFFSET $SG218129
	mov	ecx, edi
	mov	DWORD PTR [esi+332], eax
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 279  : 	m_iImprovementUpgrade = GC.getInfoTypeForString(szImprovementUpgrade, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 280  : 
; 281  : 	//Arrays
; 282  : 	const char* szImprovementType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR [esi+336], eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edi, eax

; 283  : 	const size_t lenImprovementType = strlen(szImprovementType);

	mov	ecx, edi
	mov	DWORD PTR _szImprovementType$[esp+128], edi
	lea	eax, DWORD PTR [ecx+1]
$LL74@CacheResul:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL74@CacheResul

; 284  : 
; 285  : 	kUtility.PopulateArrayByExistence(m_pbTerrainMakesValid,
; 286  : 	                                  "Terrains",
; 287  : 	                                  "Improvement_ValidTerrains",
; 288  : 	                                  "TerrainType",
; 289  : 	                                  "ImprovementType",
; 290  : 	                                  szImprovementType);

	push	edi
	mov	edi, DWORD PTR _kUtility$[esp+132]
	push	OFFSET $SG218132
	push	OFFSET $SG218133
	sub	ecx, eax
	push	OFFSET $SG218134
	mov	DWORD PTR _lenImprovementType$[esp+148], ecx
	push	OFFSET $SG218135
	lea	ecx, DWORD PTR [esi+460]
	push	ecx
	mov	ecx, edi
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 291  : 
; 292  : 	kUtility.PopulateArrayByExistence(m_pbFeatureMakesValid,
; 293  : 	                                  "Features",
; 294  : 	                                  "Improvement_ValidFeatures",
; 295  : 	                                  "FeatureType",
; 296  : 	                                  "ImprovementType",
; 297  : 	                                  szImprovementType);

	mov	edx, DWORD PTR _szImprovementType$[esp+128]
	push	edx
	push	OFFSET $SG218136
	push	OFFSET $SG218137
	push	OFFSET $SG218138
	push	OFFSET $SG218139
	lea	eax, DWORD PTR [esi+464]
	push	eax
	mov	ecx, edi
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 298  : 
; 299  : 	kUtility.PopulateArrayByExistence(m_pbImprovementMakesValid,
; 300  : 									  "Improvements",
; 301  : 									  "Improvement_ValidImprovements",
; 302  : 									  "PrereqImprovement",
; 303  : 									  "ImprovementType",
; 304  : 							          szImprovementType);

	mov	ecx, DWORD PTR _szImprovementType$[esp+128]
	push	ecx
	push	OFFSET $SG218140
	push	OFFSET $SG218141
	push	OFFSET $SG218142
	push	OFFSET $SG218143
	lea	edx, DWORD PTR [esi+468]
	push	edx
	mov	ecx, edi
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 305  : 
; 306  : 	kUtility.SetYields(m_piYieldChange, "Improvement_Yields", "ImprovementType", szImprovementType);

	mov	eax, DWORD PTR _szImprovementType$[esp+128]
	push	eax
	push	OFFSET $SG218144
	push	OFFSET $SG218145
	lea	ecx, DWORD PTR [esi+424]
	push	ecx
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 307  : 	kUtility.SetYields(m_piYieldPerEra, "Improvement_YieldPerEra", "ImprovementType", szImprovementType);

	mov	edx, DWORD PTR _szImprovementType$[esp+128]
	push	edx
	push	OFFSET $SG218146
	push	OFFSET $SG218147
	lea	eax, DWORD PTR [esi+428]
	push	eax
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 308  : 	kUtility.SetYields(m_piAdjacentCityYieldChange, "Improvement_AdjacentCityYields", "ImprovementType", szImprovementType);

	mov	ecx, DWORD PTR _szImprovementType$[esp+128]
	push	ecx
	push	OFFSET $SG218148
	push	OFFSET $SG218149
	lea	edx, DWORD PTR [esi+448]
	push	edx
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 309  : 	kUtility.SetYields(m_piAdjacentMountainYieldChange, "Improvement_AdjacentMountainYieldChanges", "ImprovementType", szImprovementType);

	mov	eax, DWORD PTR _szImprovementType$[esp+128]
	push	eax
	push	OFFSET $SG218150
	push	OFFSET $SG218151
	lea	ecx, DWORD PTR [esi+452]
	push	ecx
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 310  : 	kUtility.SetYields(m_piCoastalLandYieldChange, "Improvement_CoastalLandYields", "ImprovementType", szImprovementType);

	mov	edx, DWORD PTR _szImprovementType$[esp+128]
	push	edx
	push	OFFSET $SG218152
	push	OFFSET $SG218153
	lea	eax, DWORD PTR [esi+436]
	push	eax
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 311  : 	kUtility.SetYields(m_piFreshWaterChange, "Improvement_FreshWaterYields", "ImprovementType", szImprovementType);

	mov	ecx, DWORD PTR _szImprovementType$[esp+128]
	push	ecx
	push	OFFSET $SG218154
	push	OFFSET $SG218155
	lea	edx, DWORD PTR [esi+444]
	push	edx
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 312  : 	kUtility.SetYields(m_piHillsYieldChange, "Improvement_HillsYields", "ImprovementType", szImprovementType);

	mov	eax, DWORD PTR _szImprovementType$[esp+128]
	push	eax
	push	OFFSET $SG218156
	push	OFFSET $SG218157
	lea	ecx, DWORD PTR [esi+440]
	push	ecx
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 313  : 	kUtility.SetYields(m_piRiverSideYieldChange, "Improvement_RiverSideYields", "ImprovementType", szImprovementType);

	mov	edx, DWORD PTR _szImprovementType$[esp+128]
	push	edx
	push	OFFSET $SG218158
	push	OFFSET $SG218159
	lea	eax, DWORD PTR [esi+432]
	push	eax
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 314  : 	kUtility.SetYields(m_piPrereqNatureYield, "Improvement_PrereqNatureYields", "ImprovementType", szImprovementType);

	mov	ecx, DWORD PTR _szImprovementType$[esp+128]
	push	ecx
	push	OFFSET $SG218160
	push	OFFSET $SG218161
	lea	edx, DWORD PTR [esi+420]
	push	edx
	mov	ecx, edi
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 315  : 
; 316  : 	kUtility.SetFlavors(m_piFlavorValue, "Improvement_Flavors", "ImprovementType", szImprovementType);

	mov	eax, DWORD PTR _szImprovementType$[esp+128]
	push	0
	push	eax
	push	OFFSET $SG218162
	push	OFFSET $SG218163
	lea	ecx, DWORD PTR [esi+456]
	push	ecx
	mov	ecx, edi
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 317  : 
; 318  : 	{
; 319  : 		//Initialize Improvement Resource Types to number of Resources
; 320  : 		const int iNumResources = kUtility.MaxRows("Resources");

	push	OFFSET $SG218165
	mov	ecx, edi
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	edi, eax

; 321  : 		m_paImprovementResource = FNEW(CvImprovementResourceInfo[iNumResources], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	edx, 12					; 0000000cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T220618[esp+132], eax
	mov	DWORD PTR __$EHRec$[esp+140], 0
	test	eax, eax
	je	SHORT $LN24@CacheResul
	push	OFFSET ??1CvImprovementResourceInfo@@QAE@XZ ; CvImprovementResourceInfo::~CvImprovementResourceInfo
	push	OFFSET ??0CvImprovementResourceInfo@@QAE@XZ ; CvImprovementResourceInfo::CvImprovementResourceInfo
	push	edi
	mov	DWORD PTR [eax], edi
	add	eax, 4
	push	12					; 0000000cH
	push	eax
	mov	DWORD PTR tv1093[esp+152], eax
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	eax, DWORD PTR tv1093[esp+132]
	jmp	SHORT $LN25@CacheResul
$LN24@CacheResul:
	xor	eax, eax
$LN25@CacheResul:
	mov	DWORD PTR [esi+488], eax

; 322  : 
; 323  : 		kUtility.InitializeArray(m_piResourceQuantityRequirements, iNumResources);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	mov	DWORD PTR __$EHRec$[esp+140], -1
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+416], eax
	call	_memset
	add	esp, 16					; 00000010H

; 324  : 
; 325  : 
; 326  : 		std::string strResourceTypesKey = "Improvements - ResourceTypes";

	push	OFFSET $SG218179
	lea	ecx, DWORD PTR _strResourceTypesKey$218178[esp+136]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 327  : 		Database::Results* pResourceTypes = kUtility.GetResults(strResourceTypesKey);

	mov	ecx, DWORD PTR _kUtility$[esp+128]
	lea	edx, DWORD PTR _strResourceTypesKey$218178[esp+132]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+144], 1
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 328  : 		if(pResourceTypes == NULL)

	test	edi, edi
	jne	SHORT $LN18@CacheResul

; 329  : 		{
; 330  : 			pResourceTypes = kUtility.PrepareResults(strResourceTypesKey, "select Resources.ID, ResourceType, ResourceMakesValid, ResourceTrade, DiscoveryRand from Improvement_ResourceTypes inner join Resources on ResourceType = Resources.Type where ImprovementType = ?");

	mov	ecx, DWORD PTR _kUtility$[esp+128]
	push	OFFSET $SG218182
	lea	eax, DWORD PTR _strResourceTypesKey$218178[esp+136]
	push	eax
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax
$LN18@CacheResul:

; 331  : 		}
; 332  : 
; 333  : 		std::string strYieldResultsKey = "Improvements - YieldResults";

	push	OFFSET $SG218184
	lea	ecx, DWORD PTR _strYieldResultsKey$218183[esp+136]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 334  : 		Database::Results* pYieldResults = kUtility.GetResults(strYieldResultsKey);

	lea	ecx, DWORD PTR _strYieldResultsKey$218183[esp+132]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[esp+132]
	mov	BYTE PTR __$EHRec$[esp+144], 2
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pYieldResults$218185[esp+132], eax

; 335  : 		if(pYieldResults == NULL)

	test	eax, eax
	jne	SHORT $LN17@CacheResul

; 336  : 		{
; 337  : 			pYieldResults = kUtility.PrepareResults(strYieldResultsKey, "select Yields.ID, Yield from Improvement_ResourceType_Yields inner join Yields on YieldType = Yields.Type where ImprovementType = ? and ResourceType = ?");

	mov	ecx, DWORD PTR _kUtility$[esp+128]
	push	OFFSET $SG218187
	lea	edx, DWORD PTR _strYieldResultsKey$218183[esp+136]
	push	edx
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pYieldResults$218185[esp+132], eax
$LN17@CacheResul:

; 338  : 		}
; 339  : 
; 340  : 		pResourceTypes->Bind(1, szImprovementType, lenImprovementType, false);

	mov	eax, DWORD PTR _lenImprovementType$[esp+132]
	mov	ecx, DWORD PTR _szImprovementType$[esp+128]
	push	0
	push	eax
	push	ecx
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 341  : 
; 342  : 		while(pResourceTypes->Step())

	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	$LN15@CacheResul
$LL16@CacheResul:

; 343  : 		{
; 344  : 			const int idx = pResourceTypes->GetInt("ID");

	push	OFFSET $SG218192
	mov	ecx, edi
	call	ebx

; 345  : 			CvImprovementResourceInfo& pResourceInfo = m_paImprovementResource[idx];

	lea	edx, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _idx$218191[esp+132], eax
	mov	eax, DWORD PTR [esi+488]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _pResourceInfo$218193[esp+132], ecx

; 346  : 
; 347  : 			const char* szResourceType = pResourceTypes->GetText("ResourceType");

	push	OFFSET $SG218195
	mov	ecx, edi
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z

; 348  : 			pResourceInfo.m_bResourceMakesValid = pResourceTypes->GetBool("ResourceMakesValid");

	push	OFFSET $SG218196
	mov	ecx, edi
	mov	DWORD PTR _szResourceType$218194[esp+136], eax
	call	ebp
	mov	edx, DWORD PTR _pResourceInfo$218193[esp+132]

; 349  : 			pResourceInfo.m_bResourceTrade = pResourceTypes->GetBool("ResourceTrade");

	push	OFFSET $SG218197
	mov	ecx, edi
	mov	BYTE PTR [edx+4], al
	call	ebp
	mov	ecx, DWORD PTR _pResourceInfo$218193[esp+132]
	mov	BYTE PTR [ecx+5], al

; 350  : 			pResourceInfo.m_iDiscoverRand = pResourceTypes->GetInt("DiscoveryRand");

	push	OFFSET $SG218198
	mov	ecx, edi
	call	ebx
	mov	edx, DWORD PTR _pResourceInfo$218193[esp+132]

; 351  : 			m_piResourceQuantityRequirements[idx] = pResourceTypes->GetInt("QuantityRequirement");

	push	OFFSET $SG218199
	mov	ecx, edi
	mov	DWORD PTR [edx], eax
	call	ebx
	mov	ecx, DWORD PTR [esi+416]
	mov	edx, DWORD PTR _idx$218191[esp+132]
	mov	DWORD PTR [ecx+edx*4], eax

; 352  : 
; 353  : 			//Populate Yields for structure
; 354  : 			kUtility.InitializeArray(pResourceInfo.m_piYieldChange, "Yields");

	mov	ecx, DWORD PTR _kUtility$[esp+128]
	push	OFFSET $SG218201
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	DWORD PTR _count$220686[esp+132], eax
	test	eax, eax
	jne	SHORT $LN52@CacheResul
	mov	DWORD PTR _count$220686[esp+132], 1
	mov	eax, DWORD PTR _count$220686[esp+132]
$LN52@CacheResul:
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR _pResourceInfo$218193[esp+136]
	mov	edx, DWORD PTR _count$220686[esp+136]
	mov	DWORD PTR [ecx+8], eax
	lea	ecx, DWORD PTR [edx*4]
	push	ecx
	push	0
	push	eax
	call	_memset

; 355  : 
; 356  : 			pYieldResults->Bind(1, szImprovementType, lenImprovementType, false);

	mov	edx, DWORD PTR _lenImprovementType$[esp+148]
	mov	eax, DWORD PTR _szImprovementType$[esp+144]
	mov	ecx, DWORD PTR _pYieldResults$218185[esp+148]
	add	esp, 16					; 00000010H
	push	0
	push	edx
	push	eax
	push	1
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 357  : 			pYieldResults->Bind(2, szResourceType, -1, false);

	mov	ecx, DWORD PTR _szResourceType$218194[esp+132]
	push	0
	push	-1
	push	ecx
	mov	ecx, DWORD PTR _pYieldResults$218185[esp+144]
	push	2
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 358  : 			while(pYieldResults->Step())

	mov	ecx, DWORD PTR _pYieldResults$218185[esp+132]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN13@CacheResul
$LL14@CacheResul:

; 359  : 			{
; 360  : 				const int yieldIdx = pYieldResults->GetInt("ID");

	mov	ecx, DWORD PTR _pYieldResults$218185[esp+132]
	push	OFFSET $SG218206
	call	ebx

; 361  : 				const int yield = pYieldResults->GetInt("Yield");

	mov	ecx, DWORD PTR _pYieldResults$218185[esp+132]
	push	OFFSET $SG218208
	mov	DWORD PTR _yieldIdx$218205[esp+136], eax
	call	ebx

; 362  : 				pResourceInfo.m_piYieldChange[yieldIdx] = yield;

	mov	edx, DWORD PTR _pResourceInfo$218193[esp+132]
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _yieldIdx$218205[esp+132]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR _pYieldResults$218185[esp+132]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL14@CacheResul
$LN13@CacheResul:

; 363  : 			}
; 364  : 
; 365  : 			pYieldResults->Reset();

	mov	ecx, DWORD PTR _pYieldResults$218185[esp+132]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ
	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	$LL16@CacheResul
$LN15@CacheResul:

; 366  : 		}
; 367  : 
; 368  : 		pResourceTypes->Reset();

	mov	ecx, edi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 369  : 	}

	lea	ecx, DWORD PTR _strYieldResultsKey$218183[esp+132]
	mov	BYTE PTR __$EHRec$[esp+140], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strResourceTypesKey$218178[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 370  : 
; 371  : 
; 372  : 	const int iNumYields = kUtility.MaxRows("Yields");

	mov	edi, DWORD PTR _kUtility$[esp+128]
	push	OFFSET $SG218210
	mov	ecx, edi
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	ebx, eax

; 373  : 	const int iNumTechs = GC.getNumTechInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iNumYields$[esp+132], ebx
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos

; 374  : 	CvAssertMsg(iNumTechs > 0, "Num Tech Infos <= 0");
; 375  : 
; 376  : 
; 377  : 	//TechYieldChanges
; 378  : 	{
; 379  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 380  : 		kUtility.Initialize2DArray(m_ppiTechYieldChanges.first, iNumTechs, iNumYields);
; 381  : 		m_ppiTechYieldChanges.second = iNumTechs;
; 382  : #else
; 383  : 		kUtility.Initialize2DArray(m_ppiTechYieldChanges, iNumTechs, iNumYields);

	push	0
	push	ebx
	lea	ecx, DWORD PTR [esi+472]
	push	eax
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR _iNumTechs$[esp+148], eax
	call	?Initialize2DArray@CvDatabaseUtility@@QAEXAAPAPAHIIH@Z ; CvDatabaseUtility::Initialize2DArray

; 384  : #endif
; 385  : 
; 386  : 		std::string strKey = "Improvements - TechYieldChanges";

	push	OFFSET $SG218213
	lea	ecx, DWORD PTR _strKey$218212[esp+136]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 387  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$218212[esp+132]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[esp+144], 3
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebx, eax

; 388  : 		if(pResults == NULL)

	test	ebx, ebx
	jne	SHORT $LN12@CacheResul

; 389  : 		{
; 390  : 			pResults = kUtility.PrepareResults(strKey, "select Yields.ID as YieldID, Technologies.ID as TechID, Yield from Improvement_TechYieldChanges inner join Yields on YieldType = Yields.Type inner join Technologies on TechType = Technologies.Type where ImprovementType = ?");

	push	OFFSET $SG218216
	lea	ecx, DWORD PTR _strKey$218212[esp+136]
	push	ecx
	mov	ecx, edi
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebx, eax
$LN12@CacheResul:

; 391  : 		}
; 392  : 
; 393  : 		pResults->Bind(1, szImprovementType, lenImprovementType, false);

	mov	edx, DWORD PTR _lenImprovementType$[esp+132]
	mov	eax, DWORD PTR _szImprovementType$[esp+128]
	push	0
	push	edx
	push	eax
	push	1
	mov	ecx, ebx
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 394  : 
; 395  : 		while(pResults->Step())

	mov	ebp, DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	mov	ecx, ebx
	call	ebp
	mov	edi, DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	test	al, al
	je	SHORT $LN10@CacheResul
$LL11@CacheResul:

; 396  : 		{
; 397  : 			const int yield_idx = pResults->GetInt(0);

	push	0
	mov	ecx, ebx
	call	edi

; 398  : 			CvAssert(yield_idx > -1);
; 399  : 
; 400  : 			const int tech_idx = pResults->GetInt(1);

	push	1
	mov	ecx, ebx
	mov	DWORD PTR _yield_idx$218220[esp+136], eax
	call	edi

; 401  : 			CvAssert(tech_idx > -1);
; 402  : 
; 403  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, ebx
	mov	DWORD PTR _tech_idx$218221[esp+136], eax
	call	edi

; 404  : 
; 405  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 406  : 			m_ppiTechYieldChanges.first[tech_idx][yield_idx] = yield;
; 407  : #else
; 408  : 			m_ppiTechYieldChanges[tech_idx][yield_idx] = yield;

	mov	ecx, DWORD PTR [esi+472]
	mov	edx, DWORD PTR _tech_idx$218221[esp+132]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _yield_idx$218220[esp+132]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, ebx
	call	ebp
	test	al, al
	jne	SHORT $LL11@CacheResul
$LN10@CacheResul:

; 409  : #endif
; 410  : 		}
; 411  : 	}

	lea	ecx, DWORD PTR _strKey$218212[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 412  : 
; 413  : 	//TechNoFreshWaterYieldChanges
; 414  : 	{
; 415  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 416  : 		kUtility.Initialize2DArray(m_ppiTechNoFreshWaterYieldChanges.first, iNumTechs, iNumYields);
; 417  : 		m_ppiTechNoFreshWaterYieldChanges.second = iNumTechs;
; 418  : #else
; 419  : 		kUtility.Initialize2DArray(m_ppiTechNoFreshWaterYieldChanges, iNumTechs, iNumYields);

	mov	ecx, DWORD PTR _iNumYields$[esp+132]
	mov	edx, DWORD PTR _iNumTechs$[esp+132]
	mov	ebx, DWORD PTR _kUtility$[esp+128]
	push	0
	push	ecx
	lea	eax, DWORD PTR [esi+476]
	push	edx
	push	eax
	mov	ecx, ebx
	call	?Initialize2DArray@CvDatabaseUtility@@QAEXAAPAPAHIIH@Z ; CvDatabaseUtility::Initialize2DArray

; 420  : #endif
; 421  : 
; 422  : 		std::string strKey = "Improvements - TechNoFreshWaterYieldChanges";

	push	OFFSET $SG218224
	lea	ecx, DWORD PTR _strKey$218223[esp+136]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 423  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$218223[esp+132]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+144], 4
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebx, eax

; 424  : 		if(pResults == NULL)

	test	ebx, ebx
	jne	SHORT $LN9@CacheResul

; 425  : 		{
; 426  : 			pResults = kUtility.PrepareResults(strKey, "select Yields.ID as YieldID, Technologies.ID as TechID, Yield from Improvement_TechNoFreshWaterYieldChanges inner join Yields on YieldType = Yields.Type inner join Technologies on TechType = Technologies.Type where ImprovementType = ?");

	push	OFFSET $SG218227
	lea	ecx, DWORD PTR _strKey$218223[esp+136]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[esp+136]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebx, eax
$LN9@CacheResul:

; 427  : 		}
; 428  : 
; 429  : 		pResults->Bind(1, szImprovementType, lenImprovementType, false);

	mov	edx, DWORD PTR _lenImprovementType$[esp+132]
	mov	eax, DWORD PTR _szImprovementType$[esp+128]
	push	0
	push	edx
	push	eax
	push	1
	mov	ecx, ebx
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 430  : 
; 431  : 		while(pResults->Step())

	mov	ecx, ebx
	call	ebp
	test	al, al
	je	SHORT $LN7@CacheResul
$LL8@CacheResul:

; 432  : 		{
; 433  : 			const int yield_idx = pResults->GetInt(0);

	push	0
	mov	ecx, ebx
	call	edi

; 434  : 			CvAssert(yield_idx > -1);
; 435  : 
; 436  : 			const int tech_idx = pResults->GetInt(1);

	push	1
	mov	ecx, ebx
	mov	DWORD PTR _yield_idx$218231[esp+136], eax
	call	edi

; 437  : 			CvAssert(tech_idx > -1);
; 438  : 
; 439  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, ebx
	mov	DWORD PTR _tech_idx$218232[esp+136], eax
	call	edi

; 440  : 
; 441  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 442  : 			m_ppiTechNoFreshWaterYieldChanges.first[tech_idx][yield_idx] = yield;
; 443  : #else
; 444  : 			m_ppiTechNoFreshWaterYieldChanges[tech_idx][yield_idx] = yield;

	mov	ecx, DWORD PTR [esi+476]
	mov	edx, DWORD PTR _tech_idx$218232[esp+132]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _yield_idx$218231[esp+132]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, ebx
	call	ebp
	test	al, al
	jne	SHORT $LL8@CacheResul
$LN7@CacheResul:

; 445  : #endif
; 446  : 		}
; 447  : 
; 448  : 		pResults->Reset();

	mov	ecx, ebx
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 449  : 
; 450  : 	}

	lea	ecx, DWORD PTR _strKey$218223[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 451  : 
; 452  : 	//TechFreshWaterYieldChanges
; 453  : 	{
; 454  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 455  : 		kUtility.Initialize2DArray(m_ppiTechFreshWaterYieldChanges.first, iNumTechs, iNumYields);
; 456  : 		m_ppiTechFreshWaterYieldChanges.second = iNumTechs;
; 457  : #else
; 458  : 		kUtility.Initialize2DArray(m_ppiTechFreshWaterYieldChanges, iNumTechs, iNumYields);

	mov	ecx, DWORD PTR _iNumYields$[esp+132]
	mov	edx, DWORD PTR _iNumTechs$[esp+132]
	mov	ebx, DWORD PTR _kUtility$[esp+128]
	push	0
	push	ecx
	lea	eax, DWORD PTR [esi+480]
	push	edx
	push	eax
	mov	ecx, ebx
	call	?Initialize2DArray@CvDatabaseUtility@@QAEXAAPAPAHIIH@Z ; CvDatabaseUtility::Initialize2DArray

; 459  : #endif
; 460  : 
; 461  : 		std::string strKey = "Improvements - TechFreshWaterYieldChanges";

	push	OFFSET $SG218235
	lea	ecx, DWORD PTR _strKey$218234[esp+136]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 462  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$218234[esp+132]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+144], 5
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebx, eax

; 463  : 		if(pResults == NULL)

	test	ebx, ebx
	jne	SHORT $LN6@CacheResul

; 464  : 		{
; 465  : 			pResults = kUtility.PrepareResults(strKey, "select Yields.ID as YieldID, Technologies.ID as TechID, Yield from Improvement_TechFreshWaterYieldChanges inner join Yields on YieldType = Yields.Type inner join Technologies on TechType = Technologies.Type where ImprovementType = ?");

	push	OFFSET $SG218238
	lea	ecx, DWORD PTR _strKey$218234[esp+136]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[esp+136]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebx, eax
$LN6@CacheResul:

; 466  : 		}
; 467  : 
; 468  : 		pResults->Bind(1, szImprovementType, lenImprovementType, false);

	mov	edx, DWORD PTR _lenImprovementType$[esp+132]
	mov	eax, DWORD PTR _szImprovementType$[esp+128]
	push	0
	push	edx
	push	eax
	push	1
	mov	ecx, ebx
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 469  : 
; 470  : 		while(pResults->Step())

	mov	ecx, ebx
	call	ebp
	test	al, al
	je	SHORT $LN4@CacheResul
	npad	1
$LL5@CacheResul:

; 471  : 		{
; 472  : 			const int yield_idx = pResults->GetInt(0);

	push	0
	mov	ecx, ebx
	call	edi

; 473  : 			CvAssert(yield_idx > -1);
; 474  : 
; 475  : 			const int tech_idx = pResults->GetInt(1);

	push	1
	mov	ecx, ebx
	mov	DWORD PTR _yield_idx$218242[esp+136], eax
	call	edi

; 476  : 			CvAssert(tech_idx > -1);
; 477  : 
; 478  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, ebx
	mov	DWORD PTR _tech_idx$218243[esp+136], eax
	call	edi

; 479  : 
; 480  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 481  : 			m_ppiTechFreshWaterYieldChanges.first[tech_idx][yield_idx] = yield;
; 482  : #else
; 483  : 			m_ppiTechFreshWaterYieldChanges[tech_idx][yield_idx] = yield;

	mov	ecx, DWORD PTR [esi+480]
	mov	edx, DWORD PTR _tech_idx$218243[esp+132]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _yield_idx$218242[esp+132]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, ebx
	call	ebp
	test	al, al
	jne	SHORT $LL5@CacheResul
$LN4@CacheResul:

; 484  : #endif
; 485  : 		}
; 486  : 
; 487  : 		pResults->Reset();

	mov	ecx, ebx
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 488  : 
; 489  : 	}

	lea	ecx, DWORD PTR _strKey$218234[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 490  : 
; 491  : 	//RouteYieldChanges
; 492  : 	{
; 493  : 		const int iNumRoutes = kUtility.MaxRows("Routes");

	mov	ebx, DWORD PTR _kUtility$[esp+128]
	push	OFFSET $SG218246
	mov	ecx, ebx
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 494  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 495  : 		kUtility.Initialize2DArray(m_ppiRouteYieldChanges.first, iNumRoutes, iNumYields);
; 496  : 		m_ppiRouteYieldChanges.second = iNumRoutes;
; 497  : #else
; 498  : 		kUtility.Initialize2DArray(m_ppiRouteYieldChanges, iNumRoutes, iNumYields);

	mov	ecx, DWORD PTR _iNumYields$[esp+132]
	push	0
	push	ecx
	add	esi, 484				; 000001e4H
	push	eax
	push	esi
	mov	ecx, ebx
	mov	DWORD PTR tv1168[esp+148], esi
	call	?Initialize2DArray@CvDatabaseUtility@@QAEXAAPAPAHIIH@Z ; CvDatabaseUtility::Initialize2DArray

; 499  : #endif
; 500  : 
; 501  : 		std::string strKey = "Improvements - RouteYieldChanges";

	push	OFFSET $SG218248
	lea	ecx, DWORD PTR _strKey$218247[esp+136]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 502  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$218247[esp+132]
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+144], 6
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	ebx, eax

; 503  : 		if(pResults == NULL)

	test	ebx, ebx
	jne	SHORT $LN3@CacheResul

; 504  : 		{
; 505  : 			pResults = kUtility.PrepareResults(strKey, "select Yields.ID as YieldID, Routes.ID as RouteID, Yield from Improvement_RouteYieldChanges inner join Yields on YieldType = Yields.Type inner join Routes on RouteType = Routes.Type where ImprovementType = ?;");

	mov	ecx, DWORD PTR _kUtility$[esp+128]
	push	OFFSET $SG218251
	lea	eax, DWORD PTR _strKey$218247[esp+136]
	push	eax
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	ebx, eax
$LN3@CacheResul:

; 506  : 		}
; 507  : 
; 508  : 		pResults->Bind(1, szImprovementType, lenImprovementType, false);

	mov	ecx, DWORD PTR _lenImprovementType$[esp+132]
	mov	edx, DWORD PTR _szImprovementType$[esp+128]
	push	0
	push	ecx
	push	edx
	push	1
	mov	ecx, ebx
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 509  : 
; 510  : 		while(pResults->Step())

	mov	ecx, ebx
	call	ebp
	test	al, al
	je	SHORT $LN1@CacheResul
$LL2@CacheResul:

; 511  : 		{
; 512  : 			const int yield_idx = pResults->GetInt(0);

	push	0
	mov	ecx, ebx
	call	edi

; 513  : 			CvAssert(yield_idx > -1);
; 514  : 
; 515  : 			const int route_idx = pResults->GetInt(1);

	push	1
	mov	ecx, ebx
	mov	esi, eax
	call	edi

; 516  : 			CvAssert(route_idx > -1);
; 517  : 
; 518  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, ebx
	mov	DWORD PTR _route_idx$218256[esp+132], eax
	call	edi

; 519  : 
; 520  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 521  : 			m_ppiRouteYieldChanges.first[route_idx][yield_idx] = yield;
; 522  : #else
; 523  : 			m_ppiRouteYieldChanges[route_idx][yield_idx] = yield;

	mov	ecx, DWORD PTR tv1168[esp+132]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _route_idx$218256[esp+128]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, ebx
	mov	DWORD PTR [edx+esi*4], eax
	call	ebp
	test	al, al
	jne	SHORT $LL2@CacheResul
$LN1@CacheResul:

; 524  : #endif
; 525  : 		}
; 526  : 
; 527  : 		pResults->Reset();

	mov	ecx, ebx
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 528  : 
; 529  : 	}

	lea	ecx, DWORD PTR _strKey$218247[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 530  : 
; 531  : 	return true;
; 532  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+132]
	pop	ebp
	pop	ebx
	pop	edi
	mov	al, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 116				; 00000074H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	mov	eax, DWORD PTR $T220618[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _strResourceTypesKey$218178[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2:
	lea	ecx, DWORD PTR _strYieldResultsKey$218183[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3:
	lea	ecx, DWORD PTR _strKey$218212[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4:
	lea	ecx, DWORD PTR _strKey$218223[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5:
	lea	ecx, DWORD PTR _strKey$218234[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6:
	lea	ecx, DWORD PTR _strKey$218247[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvImprovementEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvImprovementEntry::CacheResults
PUBLIC	?begin@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@XZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::begin
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@XZ PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@XZ ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@XZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@XZ PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@XZ ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@KAXXZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvImprovementEntry@@@std@@YAPAPAVCvImprovementEntry@@IPAPAV1@@Z ; std::_Allocate<CvImprovementEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAEXPAPAVCvImprovementEntry@@0@Z ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAEXPAPAVCvImprovementEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAEXPAPAVCvImprovementEntry@@0@Z PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAEXPAPAVCvImprovementEntry@@0@Z ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	??_GCvImprovementEntry@@QAEPAXI@Z		; CvImprovementEntry::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvImprovementEntry@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvImprovementEntry@@QAEPAXI@Z PROC			; CvImprovementEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvImprovementEntry@@QAE@XZ		; CvImprovementEntry::~CvImprovementEntry
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvImprovementEntry@@QAEPAXI@Z ENDP			; CvImprovementEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@0@Z ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@0@Z PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@2@0@Z ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAEXXZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvImprovementEntry@@@@YAXAAPAVCvImprovementEntry@@@Z ; SAFE_DELETE<CvImprovementEntry>
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvImprovementEntry@@@@YAXAAPAVCvImprovementEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvImprovementEntry@@@@YAXAAPAVCvImprovementEntry@@@Z PROC ; SAFE_DELETE<CvImprovementEntry>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@2
	mov	ecx, esi
	call	??1CvImprovementEntry@@QAE@XZ		; CvImprovementEntry::~CvImprovementEntry
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@2:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvImprovementEntry@@@@YAXAAPAVCvImprovementEntry@@@Z ENDP ; SAFE_DELETE<CvImprovementEntry>
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::~vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::~vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::~vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEXXZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::clear
_TEXT	ENDS
PUBLIC	??0CvImprovementXMLEntries@@QAE@XZ		; CvImprovementXMLEntries::CvImprovementXMLEntries
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
;	COMDAT ??0CvImprovementXMLEntries@@QAE@XZ
_TEXT	SEGMENT
??0CvImprovementXMLEntries@@QAE@XZ PROC			; CvImprovementXMLEntries::CvImprovementXMLEntries, COMDAT
; _this$ = ecx

; 1158 : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 1159 : 
; 1160 : }

	ret	0
??0CvImprovementXMLEntries@@QAE@XZ ENDP			; CvImprovementXMLEntries::CvImprovementXMLEntries
_TEXT	ENDS
PUBLIC	?DeleteArray@CvImprovementXMLEntries@@QAEXXZ	; CvImprovementXMLEntries::DeleteArray
; Function compile flags: /Ogtpy
;	COMDAT ?DeleteArray@CvImprovementXMLEntries@@QAEXXZ
_TEXT	SEGMENT
?DeleteArray@CvImprovementXMLEntries@@QAEXXZ PROC	; CvImprovementXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 1211 : {

	push	ebx
	mov	ebx, ecx
	push	esi

; 1212 : 	for(std::vector<CvImprovementEntry*>::iterator it = m_paImprovementEntries.begin(); it != m_paImprovementEntries.end(); ++it)

	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@DeleteArra
	npad	3
$LL14@DeleteArra:

; 1213 : 	{
; 1214 : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@DeleteArra
	mov	ecx, edi
	call	??1CvImprovementEntry@@QAE@XZ		; CvImprovementEntry::~CvImprovementEntry
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@DeleteArra:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@DeleteArra
$LN1@DeleteArra:

; 1215 : 	}
; 1216 : 
; 1217 : 	m_paImprovementEntries.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN51@DeleteArra
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN76@DeleteArra
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN76@DeleteArra:
	mov	DWORD PTR [ebx+8], edi
$LN51@DeleteArra:
	pop	edi
	pop	esi
	pop	ebx

; 1218 : }

	ret	0
?DeleteArray@CvImprovementXMLEntries@@QAEXXZ ENDP	; CvImprovementXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	??1CvImprovementXMLEntries@@QAE@XZ		; CvImprovementXMLEntries::~CvImprovementXMLEntries
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvImprovementXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvImprovementXMLEntries@@QAE@XZ$0
__ehfuncinfo$??1CvImprovementXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvImprovementXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvimprovementclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvImprovementXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvImprovementXMLEntries@@QAE@XZ PROC			; CvImprovementXMLEntries::~CvImprovementXMLEntries, COMDAT
; _this$ = ecx

; 1164 : {

	push	-1
	push	__ehhandler$??1CvImprovementXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi

; 1165 : 	DeleteArray();

	call	?DeleteArray@CvImprovementXMLEntries@@QAEXXZ ; CvImprovementXMLEntries::DeleteArray

; 1166 : }

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN9@CvImprovem@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@CvImprovem@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvImprovementXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvImprovementEntry@@V?$allocator@PAVCvImprovementEntry@@@std@@@std@@QAE@XZ ; std::vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >::~vector<CvImprovementEntry *,std::allocator<CvImprovementEntry *> >
__ehhandler$??1CvImprovementXMLEntries@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvImprovementXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvImprovementXMLEntries@@QAE@XZ ENDP			; CvImprovementXMLEntries::~CvImprovementXMLEntries
END
